public static void main(String[] args) throws IOException, ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException
{    InputStream is = FatJarMain.class.getResourceAsStream("/mainClasses");    if (is == null) {        System.err.println("Couldn't find /mainClasses in classpath.");        System.exit(3);    }    BufferedReader br = new BufferedReader(new InputStreamReader(is));    String line;    while ((line = br.readLine()) != null) {        String[] parts = line.split(":", 3);        if (parts.length != 3 || (parts[0].length() > 0 && parts[0].charAt(0) == '#')) {            continue;        }        if (parts[0].length() > 0) {            cmds.put(parts[0], new Cmd(parts[0], parts[1], parts[2]));                                    order.add(parts[0]);        } else {                        order.add(parts[2]);        }    }    if (args.length == 0) {        doHelp();        return;    }    Cmd cmd = cmds.get(args[0]);    if (cmd == null) {        doHelp();        return;    }    Class<?> clazz = Class.forName(cmd.clazz);    Method main = clazz.getMethod("main", String[].class);    String[] newArgs = new String[args.length - 1];    System.arraycopy(args, 1, newArgs, 0, newArgs.length);    try {        main.invoke(null, (Object) newArgs);    } catch (InvocationTargetException e) {        if (e.getCause() != null) {            e.getCause().printStackTrace();        } else {            e.printStackTrace();        }    }}
0
private static void doHelp()
{    System.err.println("USAGE: FatJarMain cmd args");    System.err.println("Available cmds:");    for (String c : order) {        Cmd cmd = cmds.get(c);        if (cmd != null) {            System.err.println("  " + c + " " + cmd.desc);        } else {            System.err.println(c);        }    }    System.exit(2);}
0
public static FilterOp newOp(String op) throws FilterException
{    if (op.equals("or"))        return new OrOp();    if (op.equals("and"))        return new AndOp();    if (op.equals("not"))        return new NotOp();    if (op.equals("xor"))        return new XorOp();    if (op.equals("="))        return new EqualsOp();    if (op.equals("<"))        return new LessThanOp();    if (op.equals(">"))        return new GreaterThanOp();    throw new FilterException("Invalid operation '" + op + "'");}
0
public void addSubOp(FilterOp op)
{    subOps.add(op);}
0
public void addArg(Arg arg)
{    args.add(arg);}
0
public String toString()
{    String op = "(" + getClass().getName();    for (FilterOp f : subOps) {        op += " " + f;    }    for (Arg a : args) {        op += " " + a;    }    return op + ")";}
0
public boolean matches(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (!f.matches(entry)) {            return false;        }    }    return true;}
0
public ArgType getType()
{    return type;}
0
public T getValue()
{    return value;}
0
public String toString()
{    return "[" + type + ":" + value + "]";}
0
public boolean matches(LogEntry entry) throws FilterException
{    Object last = null;    for (Arg a : args) {        Object v = a.getValue();        if (a.getType() == FilterOp.ArgType.SYMBOL) {            String key = (String) a.getValue();            v = entry.getAttribute(key);        }        if (last != null && !last.equals(v)) {            return false;        }        last = v;    }    return true;}
0
public boolean matches(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) <= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                                        if (((Number) last).longValue() <= ((Number) v).longValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
0
public boolean matches(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) >= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                    if (((Number) last).doubleValue() >= ((Number) v).doubleValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
0
public boolean matches(LogEntry entry) throws FilterException
{    if (subOps.size() != 1) {        throw new FilterException("Not operation can only take one argument");    }    return !subOps.get(0).matches(entry);}
0
public boolean matches(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (f.matches(entry)) {            return true;        }    }    return false;}
0
public boolean matches(LogEntry entry) throws FilterException
{    int count = 0;    for (FilterOp f : subOps) {        if (f.matches(entry)) {            count++;            if (count > 1) {                return false;            }        }    }    if (count == 1) {        return true;    }    return false;}
0
private String readUntilSpace() throws IOException
{    StringBuffer buffer = new StringBuffer();    int c = reader.read();    while (!Character.isWhitespace(c) && c != ')' && c != '(') {        buffer.append((char) c);        c = reader.read();        if (c == -1) {            break;        }    }    reader.unread(c);    return buffer.toString().trim();}
0
private StringArg readStringArg() throws IOException, FilterException
{    int c = reader.read();    int last = 0;    if (c != '"') {        throw new FilterException("Check the parser, trying to read a string that doesn't begin with quotes");    }    StringBuffer buffer = new StringBuffer();    while (reader.ready()) {        last = c;        c = reader.read();        if (c == -1) {            break;        }        if (c == '"' && last != '\\') {            return new StringArg(buffer.toString());        } else {            buffer.append((char) c);        }    }    throw new FilterException("Unterminated string");}
0
private NumberArg readNumberArg() throws IOException, FilterException
{    String strval = readUntilSpace();    try {        if (strval.startsWith("0x")) {            return new NumberArg(Long.valueOf(strval.substring(2), 16));        } else {            return new NumberArg(Long.valueOf(strval));        }    } catch (NumberFormatException e) {        throw new FilterException("Not a number [" + strval + "]\n" + e);    }}
0
private SymbolArg readSymbolArg() throws IOException, FilterException
{    return new SymbolArg(readUntilSpace());}
0
public FilterOp parse() throws IOException, FilterException
{    int c = reader.read();    if (c != '(') {        throw new FilterException("Invalid format");    }    String opstr = readUntilSpace();    FilterOp op = FilterOp.newOp(opstr);    while (reader.ready()) {        c = reader.read();        if (c == -1) {            break;        }        if (c == '(') {            reader.unread(c);            op.addSubOp(parse());        } else if (c == ')') {            return op;        } else if (c == '"') {            reader.unread(c);            op.addArg(readStringArg());        } else if (Character.isDigit(c) || c == '-' || c == '+') {            reader.unread(c);            op.addArg(readNumberArg());        } else if (Character.isJavaIdentifierStart(c)) {            reader.unread(c);            op.addArg(readSymbolArg());        }    }    throw new FilterException("Incomplete filter");}
0
public static void main(String[] args) throws IOException, FilterException
{    if (args.length == 1) {        System.out.println(new FilterParser(args[0]).parse());    } else {        System.out.println(new FilterParser("(or (and (= session foobar) (= session barfoo)) (= session sdfs))").parse());    }}
0
public boolean equals(Message m)
{    return (m.from == this.from && m.to == this.to && m.zxid == this.zxid);}
0
public JSONObject txnEntry(TransactionEntry e)
{    JSONObject event = new JSONObject();    event.put("time", Long.toString(e.getTimestamp()));    event.put("client", Long.toHexString(e.getClientId()));    event.put("cxid", Long.toHexString(e.getCxid()));    event.put("zxid", Long.toHexString(e.getZxid()));    event.put("op", e.getOp());    event.put("extra", e.getExtra());    event.put("type", "transaction");    return event;}
0
public String toString()
{    return JSONValue.toJSONString(root);}
0
public static void main(String[] args) throws Exception
{    MergedLogSource src = new MergedLogSource(args);    LogIterator iter = src.iterator();    System.out.println(new JsonGenerator(iter));}
0
public String getEntry()
{    return (String) getAttribute("log-text");}
0
public String toString()
{    return "" + getTimestamp() + "::::" + getNode() + "::::" + getEntry();}
0
public int getNode()
{    return (Integer) getAttribute("node");}
0
public Type getType()
{    return LogEntry.Type.LOG4J;}
0
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
0
public long size()
{    return size;}
0
public long getStartTime()
{    return starttime;}
0
public long getEndTime()
{    return endtime;}
0
public LogSkipList getSkipList()
{    return skiplist;}
0
public synchronized long size() throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("size() called");    }    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = in.getPosition();    if (LOG.isTraceEnabled()) {        LOG.trace("saved pos () = " + pos);    }    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    in.seek(lastseg.getBytes());        buf = "";        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (LOG.isTraceEnabled()) {                }        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    in.seek(pos);    buf = "";    if (LOG.isTraceEnabled()) {        LOG.trace("size() = " + count);    }    return count;}
0
private synchronized LogEntry readNextEntry()
{    try {        try {            while (true) {                String line = in.readLine();                if (line == null) {                    break;                }                Matcher m = src.timep.matcher(line);                if (m.lookingAt()) {                    if (buf.length() > 0) {                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);                        buf = line;                        return e;                    }                    buf = line;                } else if (buf.length() > 0) {                    buf += line + "\n";                }            }        } catch (EOFException eof) {                }        if (buf.length() > 0) {            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);            buf = "";            return e;        }    } catch (Exception e) {                return null;    }    return null;}
1
public boolean hasNext()
{    return next != null;}
0
public LogEntry next() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(e.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
0
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for L4J logs");}
0
public void close() throws IOException
{    in.close();}
0
public String toString()
{    String size;    try {        size = new Long(size()).toString();    } catch (IOException ioe) {        size = "Unable to read";    }    return "Log4JSourceIterator(start=" + starttime + ", end=" + endtime + ", size=" + size + ")";}
0
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
0
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new Log4JSourceIterator(this, starttime, endtime, filter);}
0
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
0
private static long timestampFromText(SimpleDateFormat format, String s)
{    Date d = null;    try {        d = format.parse(s);    } catch (ParseException e) {        return 0;    }    Calendar c = new GregorianCalendar();    c.setTime(d);    return c.getTimeInMillis();}
0
private void init() throws IOException
{    File f = new File(file);    RandomAccessFileReader in = new RandomAccessFileReader(f);    SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);    Pattern idp = Pattern.compile("\\[myid:(\\d+)\\]");    long lastFp = in.getPosition();    String line = in.readLine();    Matcher m = null;        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {        starttime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. First line doesn't start with time");    }    /*	  Count number of log entries. Any line starting with a timestamp counts as an entry	*/    String lastentry = line;    try {        while (line != null) {            m = timep.matcher(line);            if (m.lookingAt()) {                if (size % skipN == 0) {                    long time = timestampFromText(dateformat, m.group(1));                    skiplist.addMark(time, lastFp, size);                }                size++;                lastentry = line;            }            if (serverid == 0 && (m = idp.matcher(line)).find()) {                serverid = Integer.valueOf(m.group(1));            }            lastFp = in.getPosition();            line = in.readLine();        }    } catch (EOFException eof) {        } finally {        in.close();    }    m = timep.matcher(lastentry);    if (m.lookingAt()) {        endtime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. Last line doesn't start with time");    }}
0
public String toString()
{    return "Log4JSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ", id=" + serverid + ")";}
0
public static void main(String[] args) throws IOException
{    final Log4JSource s = new Log4JSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        final long starttime = Long.valueOf(args[1]);        final long endtime = Long.valueOf(args[2]);        iter = s.iterator(starttime, endtime);        Thread t1 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t2 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t3 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);            }        };        t1.start();        t2.start();        } else {        iter = s.iterator();    }    /*while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();}
0
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
0
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
0
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);}
0
public int getServerId()
{    return serverid;}
0
public long getTimestamp()
{    return (Long) getAttribute("timestamp");}
0
public void setAttribute(String key, Object v)
{    attributes.put(key, v);}
0
public Object getAttribute(String key)
{    return attributes.get(key);}
0
public static void main(String[] args)
{    try {        MergedLogSource src = new MergedLogSource(args);        System.out.println(src);        Server server = new Server(8182);        server.setHandler(new LogServer(src));        server.start();        server.join();    } catch (Exception e) {                e.printStackTrace();    }}
0
public long getTime()
{    return this.time;}
0
public long getBytes()
{    return this.bytes;}
0
public long getEntriesSkipped()
{    return this.skipped;}
0
public String toString()
{    return "Mark(time=" + time + ", bytes=" + bytes + ", skipped=" + skipped + ")";}
0
public void addMark(long time, long bytes, long skipped)
{    if (LOG.isTraceEnabled()) {        LOG.trace("addMark (time:" + time + ", bytes: " + bytes + ", skipped: " + skipped + ")");    }    marks.add(new Mark(time, bytes, skipped));}
0
public Mark findMarkBefore(long time) throws NoSuchElementException
{    if (LOG.isTraceEnabled()) {        LOG.trace("findMarkBefore(" + time + ")");    }    Mark last = marks.getFirst();    for (Mark m : marks) {        if (m.getTime() > time) {            break;        }        last = m;    }    if (LOG.isTraceEnabled()) {        LOG.trace("return " + last);    }    return last;}
0
public static void main(String[] args) throws IOException
{    MergedLogSource source = new MergedLogSource(args);    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-ms.out")));    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-sec.out")));    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-min.out")));    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-hour.out")));    LogIterator iter;    System.out.println(source);    iter = source.iterator();    long currentms = 0;    long currentsec = 0;    long currentmin = 0;    long currenthour = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxid_sec = 0;    long zxid_min = 0;    long zxid_hour = 0;    while (iter.hasNext()) {        LogEntry e = iter.next();        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long sec = ms / MS_PER_SEC;        long min = ms / MS_PER_MIN;        long hour = ms / MS_PER_HOUR;        if (currentms != ms && currentms != 0) {            ps_ms.println("" + currentms + " " + zxids_ms.size());            zxid_sec += zxids_ms.size();            zxid_min += zxids_ms.size();            zxid_hour += zxids_ms.size();            zxids_ms.clear();        }        if (currentsec != sec && currentsec != 0) {            ps_sec.println("" + currentsec * MS_PER_SEC + " " + zxid_sec);            zxid_sec = 0;        }        if (currentmin != min && currentmin != 0) {            ps_min.println("" + currentmin * MS_PER_MIN + " " + zxid_min);            zxid_min = 0;        }        if (currenthour != hour && currenthour != 0) {            ps_hour.println("" + currenthour * MS_PER_HOUR + " " + zxid_hour);            zxid_hour = 0;        }        currentms = ms;        currentsec = sec;        currentmin = min;        currenthour = hour;        zxids_ms.add(cxn.getZxid());    }    iter.close();    ps_ms.close();    ps_sec.close();    ps_min.close();    ps_hour.close();}
0
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
0
public long size()
{    return size;}
0
public long getStartTime()
{    return starttime;}
0
public long getEndTime()
{    return endtime;}
0
public long size() throws IOException
{    long size = 0;    for (LogIterator i : sources) {        size += i.size();    }    return size;}
0
public boolean hasNext()
{    for (LogEntry n : nexts) {        if (n != null)            return true;    }    return false;}
0
public LogEntry next()
{    int min = -1;    for (int i = 0; i < nexts.length; i++) {        if (nexts[i] != null) {            if (min == -1) {                min = i;            } else if (nexts[i].getTimestamp() < nexts[min].getTimestamp()) {                min = i;            }        }    }    if (min == -1) {        return null;    } else {        LogEntry e = nexts[min];        nexts[min] = sources[min].next();        return e;    }}
0
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Merged logs");}
0
public void close() throws IOException
{    for (LogIterator i : sources) {        i.close();    }}
0
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
0
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new MergedLogSourceIterator(this, starttime, endtime, filter);}
0
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
0
public void addSource(String f) throws IOException
{    LogSource s = null;    if (TxnLogSource.isTransactionFile(f)) {        s = new TxnLogSource(f);    } else {        s = new Log4JSource(f);    }    size += s.size();    endtime = s.getEndTime() > endtime ? s.getEndTime() : endtime;    starttime = s.getStartTime() < starttime || starttime == 0 ? s.getStartTime() : starttime;    sources.add(s);}
0
public String toString()
{    String s = "MergedLogSource(size=" + size + ", start=" + starttime + ", end=" + endtime + ")";    for (LogSource src : sources) {        s += "\n\t- " + src;    }    return s;}
0
public static void main(String[] args) throws IOException
{    System.out.println("Time: " + System.currentTimeMillis());    MergedLogSource s = new MergedLogSource(args);    System.out.println(s);    LogIterator iter;    iter = s.iterator();    System.out.println("Time: " + System.currentTimeMillis());    System.out.println("Iterator Size: " + iter.size());    System.out.println("Time: " + System.currentTimeMillis());    /*	while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();    System.out.println("Time: " + System.currentTimeMillis());}
0
private int fill() throws IOException
{    fileoffset = fp;    int read = file.read(buffer, 0, buffer.length);    if (LOG.isDebugEnabled()) {        String buf = new String(buffer, 0, 40, "UTF-8");            }    if (read == -1) {                buffersize = 0;    } else {        buffersize = read;    }    fp += buffersize;    bufferoffset = 0;    return buffersize;}
1
public boolean markSupported()
{    return false;}
0
public synchronized int read(char[] cbuf, int off, int len) throws IOException
{        byte[] b = new byte[2];    int bytesread = 0;    while (len > 0) {        int read = read(b, 0, 2);        bytesread += read;        if (read < 2) {            return bytesread;        }        cbuf[off] = (char) ((b[0] << 8) | (b[1] & 0xff));        off += read;        len -= read;    }    return bytesread;}
0
public synchronized int read(byte[] buf, int off, int len) throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("read(buf, off=" + off + ", len=" + len);    }    int read = 0;    while (len > 0) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        int tocopy = Math.min(len, buffersize);        if (LOG.isTraceEnabled()) {            LOG.trace("tocopy=" + tocopy);        }        System.arraycopy(buffer, bufferoffset, buf, off, tocopy);        buffersize -= tocopy;        bufferoffset += tocopy;        len -= tocopy;        read += tocopy;        off += tocopy;    }    if (LOG.isTraceEnabled()) {        LOG.trace("read=" + read);    }    return read;}
0
public void close() throws IOException
{    file.close();}
0
public long getPosition()
{    return bufferoffset + fileoffset;}
0
public synchronized void seek(long pos) throws IOException
{    if (LOG.isDebugEnabled()) {            }    file.seek(pos);    fp = pos;        buffersize = 0;}
1
public synchronized String readLine() throws IOException
{    StringBuffer s = null;        buffering: for (; ; ) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        for (int i = 0; i < buffersize; i++) {            if (buffer[bufferoffset + i] == '\n') {                if (i > 0) {                                        if (s == null) {                        s = new StringBuffer();                    }                    s.append(new String(buffer, bufferoffset, i, "UTF-8"));                }                bufferoffset += i + 1;                buffersize -= i + 1;                break buffering;            }        }                if (s == null) {            s = new StringBuffer();        }        s.append(new String(buffer, bufferoffset, buffersize, "UTF-8"));        buffersize = 0;    }    if (s == null) {        return null;    } else {        return s.toString();    }}
0
public void readFully(byte[] b) throws IOException
{    readFully(b, 0, b.length);}
0
public void readFully(byte[] b, int off, int len) throws IOException
{    while (len > 0) {        int read = read(b, off, len);        len -= read;        off += read;        if (read == 0) {            throw new EOFException("End of file reached");        }    }}
0
public int skipBytes(int n) throws IOException
{    seek(getPosition() + n);    return n;}
0
public boolean readBoolean() throws IOException
{    return (readByte() != 0);}
0
public byte readByte() throws IOException
{    byte[] b = new byte[1];    readFully(b, 0, 1);    return b[0];}
0
public int readUnsignedByte() throws IOException
{    return (int) readByte();}
0
public short readShort() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (short) ((b[0] << 8) | (b[1] & 0xff));}
0
public int readUnsignedShort() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (((b[0] & 0xff) << 8) | (b[1] & 0xff));}
0
public char readChar() throws IOException
{    return (char) readShort();}
0
public int readInt() throws IOException
{    byte[] b = new byte[4];    readFully(b, 0, 4);    return (((b[0] & 0xff) << 24) | ((b[1] & 0xff) << 16) | ((b[2] & 0xff) << 8) | (b[3] & 0xff));}
0
public long readLong() throws IOException
{    byte[] b = new byte[8];    readFully(b, 0, 8);    return (((long) (b[0] & 0xff) << 56) | ((long) (b[1] & 0xff) << 48) | ((long) (b[2] & 0xff) << 40) | ((long) (b[3] & 0xff) << 32) | ((long) (b[4] & 0xff) << 24) | ((long) (b[5] & 0xff) << 16) | ((long) (b[6] & 0xff) << 8) | ((long) (b[7] & 0xff)));}
0
public float readFloat() throws IOException
{    return Float.intBitsToFloat(readInt());}
0
public double readDouble() throws IOException
{    return Double.longBitsToDouble(readLong());}
0
public String readUTF() throws IOException
{    int len = readUnsignedShort();    byte[] bytes = new byte[len + 2];    bytes[0] = (byte) ((len >> 8) & 0xFF);    bytes[1] = (byte) (len & 0xFF);    readFully(bytes, 2, len);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));    return dis.readUTF();}
0
public static void main(String[] args) throws IOException
{    RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));    long pos0 = f.getPosition();    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    long pos1 = f.getPosition();    System.out.println("pos: " + pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos0);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    long pos2 = f.getPosition();    System.out.println("=============");    System.out.println(f.readLine());    f.seek(pos2);    System.out.println(f.readLine());    f.close();}
0
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    String file = request.getString("path", "/");    JSONObject o = new JSONObject();    try {        this.source.addSource(file);        o.put("status", "OK");    } catch (Exception e) {        o.put("status", "ERR");        o.put("error", e.toString());    }    return JSONValue.toJSONString(o);}
0
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    JSONArray filelist = new JSONArray();    File base = new File(request.getString("path", "/"));    if (!base.exists() || !base.isDirectory()) {        throw new FileNotFoundException("Couldn't find [" + request + "]");    }    File[] files = base.listFiles();    Arrays.sort(files, new Comparator<File>() {        public int compare(File o1, File o2) {            if (o1.isDirectory() != o2.isDirectory()) {                if (o1.isDirectory()) {                    return -1;                } else {                    return 1;                }            }            return o1.getName().compareToIgnoreCase(o2.getName());        }    });    for (File f : files) {        JSONObject o = new JSONObject();        o.put("file", f.getName());        o.put("type", f.isDirectory() ? "D" : "F");        o.put("path", f.getCanonicalPath());        filelist.add(o);    }    return JSONValue.toJSONString(filelist);}
0
public int compare(File o1, File o2)
{    if (o1.isDirectory() != o2.isDirectory()) {        if (o1.isDirectory()) {            return -1;        } else {            return 1;        }    }    return o1.getName().compareToIgnoreCase(o2.getName());}
0
 String handleRequest(JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    FilterOp fo = null;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    String filterstr = request.getString("filter", "");    if (filterstr.length() > 0) {        fo = new FilterParser(filterstr).parse();    }    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = starttime + DEFAULT_PERIOD;        }    }    if (LOG.isDebugEnabled()) {            }    LogIterator iterator = (fo != null) ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);    return new JsonGenerator(iterator).toString();}
1
public long getNumber(String name, long defaultnum)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultnum;    }    try {        return Long.valueOf(vals[0]);    } catch (NumberFormatException e) {        return defaultnum;    }}
0
public String getString(String name, String defaultstr)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultstr;    } else {        return vals[0];    }}
0
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    response.setContentType("text/plain;charset=utf-8");    response.setStatus(HttpServletResponse.SC_OK);    try {        String req = request.getRequestURI().substring(request.getServletPath().length());        response.getWriter().println(handleRequest(new JsonRequest(request)));    } catch (Exception e) {        JSONObject o = new JSONObject();        o.put("error", e.toString());        response.getWriter().println(JSONValue.toJSONString(o));    } catch (java.lang.OutOfMemoryError oom) {        JSONObject o = new JSONObject();        o.put("error", "Out of memory. Perhaps you've requested too many logs. Try narrowing you're filter criteria.");        response.getWriter().println(JSONValue.toJSONString(o));    }}
0
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    long starttime = 0;    long endtime = 0;    long period = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    LogIterator iter = source.iterator(starttime, endtime);    JSONObject data = new JSONObject();    data.put("startTime", starttime);    data.put("endTime", endtime);    long size = 0;    size = iter.size();    data.put("numEntries", size);    if (LOG.isDebugEnabled()) {            }    iter.close();    return JSONValue.toJSONString(data);}
1
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    String path = request.getRequestURI().substring(request.getServletPath().length());    InputStream resource = ClassLoader.getSystemResourceAsStream("org/apache/zookeeper/graph/resources" + path);    if (resource == null) {        response.getWriter().println(path + " not found!");        response.setStatus(HttpServletResponse.SC_NOT_FOUND);        return;    }    try {        while (resource.available() > 0) {            response.getWriter().write(resource.read());        }    } finally {        resource.close();    }        response.setStatus(HttpServletResponse.SC_OK);}
0
public String handleRequest(JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    long scale = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    String scalestr = request.getString("scale", "minutes");    if (scalestr.equals("seconds")) {        scale = MS_PER_SEC;    } else if (scalestr.equals("hours")) {        scale = MS_PER_HOUR;    } else {        scale = MS_PER_MIN;    }    LogIterator iter = source.iterator(starttime, endtime);    long current = 0;    long currentms = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxidcount = 0;    JSONArray events = new JSONArray();    while (iter.hasNext()) {        LogEntry e = iter.next();        if (e.getType() != LogEntry.Type.TXN) {            continue;        }        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long inscale = ms / scale;        if (currentms != ms && currentms != 0) {            zxidcount += zxids_ms.size();            zxids_ms.clear();        }        if (inscale != current && current != 0) {            JSONObject o = new JSONObject();            o.put("time", current * scale);            o.put("count", zxidcount);            events.add(o);            zxidcount = 0;        }        current = inscale;        currentms = ms;        zxids_ms.add(cxn.getZxid());    }    JSONObject o = new JSONObject();    o.put("time", current * scale);    o.put("count", zxidcount);    events.add(o);    iter.close();    return JSONValue.toJSONString(events);}
0
public long getClientId()
{    return (Long) getAttribute("client-id");}
0
public long getCxid()
{    return (Long) getAttribute("cxid");}
0
public long getZxid()
{    return (Long) getAttribute("zxid");}
0
public String getOp()
{    return (String) getAttribute("operation");}
0
public String getExtra()
{    return (String) getAttribute("extra");}
0
public String toString()
{    return getTimestamp() + ":::session(0x" + Long.toHexString(getClientId()) + ") cxid(0x" + Long.toHexString(getCxid()) + ") zxid(0x" + Long.toHexString(getZxid()) + ") op(" + getOp() + ") extra(" + getExtra() + ")";}
0
public Type getType()
{    return LogEntry.Type.TXN;}
0
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
0
public long size()
{    return size;}
0
public long getStartTime()
{    return starttime;}
0
public long getEndTime()
{    return endtime;}
0
public LogSkipList getSkipList()
{    return skiplist;}
0
public static boolean isTransactionFile(String file) throws IOException
{    RandomAccessFileReader reader = new RandomAccessFileReader(new File(file));    BinaryInputArchive logStream = new BinaryInputArchive(reader);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    reader.close();    return fhdr.getMagic() == FileTxnLog.TXNLOG_MAGIC;}
0
public long size() throws IOException
{    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = reader.getPosition();    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    reader.seek(lastseg.getBytes());        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    reader.seek(pos);    ;    return count;}
0
private LogEntry readNextEntry()
{    LogEntry e = null;    try {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException ex) {            return null;        }        if (bytes.length == 0) {            return null;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record r = SerializeUtils.deserializeTxn(bytes, hdr);        switch(hdr.getType()) {            case OpCode.createSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "createSession");                }                break;            case OpCode.closeSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "closeSession");                }                break;            case OpCode.create:                if (r != null) {                    CreateTxn create = (CreateTxn) r;                    String path = create.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "create", path);                }                break;            case OpCode.setData:                if (r != null) {                    SetDataTxn set = (SetDataTxn) r;                    String path = set.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setData", path);                }                break;            case OpCode.setACL:                if (r != null) {                    SetACLTxn setacl = (SetACLTxn) r;                    String path = setacl.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setACL", path);                }                break;            case OpCode.error:                if (r != null) {                    ErrorTxn error = (ErrorTxn) r;                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "error", "Error: " + error.getErr());                }                break;            default:                                break;        }        if (logStream.readByte("EOR") != 'B') {            throw new EOFException("Last transaction was partial.");        }    } catch (Exception ex) {                return null;    }    return e;}
1
public boolean hasNext()
{    return next != null;}
0
public LogEntry next() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(fe.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
0
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Txn logs");}
0
public void close() throws IOException
{    reader.close();}
0
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
0
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new TxnLogSourceIterator(this, starttime, endtime, filter);}
0
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
0
public String toString()
{    return "TxnLogSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ")";}
0
public static void main(String[] args) throws IOException, FilterException
{    TxnLogSource s = new TxnLogSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        long starttime = Long.valueOf(args[1]);        long endtime = Long.valueOf(args[2]);        FilterOp fo = new FilterParser("(or (and (> zxid 0x2f0bd6f5e0) (< zxid 0x2f0bd6f5e9)) (= operation \"error\"))").parse();        System.out.println("fo: " + fo);        iter = s.iterator(starttime, endtime, fo);    } else {        iter = s.iterator();    }    System.out.println(iter);    while (iter.hasNext()) {        System.out.println(iter.next());    }    iter.close();}
0
public static Credentials join(Credentials a, Credentials b)
{    Credentials result = new Credentials();    result.putAll(a);    result.putAll(b);    return result;}
0
public String getContext()
{    return context;}
0
public String getHostPort()
{    return hostPort.toString();}
0
public Credentials getCredentials()
{    return credentials;}
0
public void setCredentials(String c)
{    this.credentials = new Credentials(c);}
0
public void setZooKeeperAuthInfo(String digest)
{    zookeeperAuth = new Credentials(digest);}
0
public final Credentials getZooKeeperAuthInfo()
{    return zookeeperAuth;}
0
public boolean equals(Object o)
{    Endpoint e = (Endpoint) o;    return context.equals(e.context);}
0
public int hashCode()
{    return context.hashCode();}
0
public String toString()
{    return String.format("<Endpoint %s %s>", context, hostPort.toString());}
0
public String getHost()
{    return host;}
0
public int getPort()
{    return port;}
0
public boolean equals(Object o)
{    HostPort p = (HostPort) o;    return host.equals(p.host) && port == p.port;}
0
public int hashCode()
{    return String.format("%s:%d", host, port).hashCode();}
0
public String toString()
{    return original;}
0
private void extractCredentials()
{    if (cfg.containsKey("rest.http.auth")) {        credentials = new Credentials(cfg.getProperty("rest.http.auth", ""));    }}
0
private void extractEndpoints()
{    int count = 1;    while (true) {        String e = cfg.getProperty(String.format("rest.endpoint.%d", count), null);        if (e == null) {            break;        }        String[] parts = e.split(";");        if (parts.length != 2) {            count++;            continue;        }        Endpoint point = new Endpoint(parts[0], parts[1]);        String c = cfg.getProperty(String.format("rest.endpoint.%d.http.auth", count), "");        point.setCredentials(c);        String digest = cfg.getProperty(String.format("rest.endpoint.%d.zk.digest", count), "");        point.setZooKeeperAuthInfo(digest);        endpoints.add(point);        count++;    }}
0
public int getPort()
{    return Integer.parseInt(cfg.getProperty("rest.port", "9998"));}
0
public boolean useSSL()
{    return Boolean.valueOf(cfg.getProperty("rest.ssl", "false"));}
0
public final Set<Endpoint> getEndpoints()
{    return endpoints;}
0
public final Credentials getCredentials()
{    return credentials;}
0
public String getJKS()
{    return cfg.getProperty("rest.ssl.jks");}
0
public String getJKS(String def)
{    return cfg.getProperty("rest.ssl.jks", def);}
0
public String getJKSPassword()
{    return cfg.getProperty("rest.ssl.jks.pass");}
0
public void doFilter(ServletRequest req0, ServletResponse resp0, FilterChain chain) throws IOException, ServletException
{    HttpServletRequest request = (HttpServletRequest) req0;    HttpServletResponse response = (HttpServletResponse) resp0;    String authorization = request.getHeader("Authorization");    if (authorization != null) {        String[] c = parseAuthorization(authorization);        if (c != null && credentials.containsKey(c[0]) && credentials.get(c[0]).equals(c[1])) {            chain.doFilter(request, response);            return;        }    }    response.setHeader("WWW-Authenticate", "Basic realm=\"Restricted\"");    response.sendError(401);}
0
private String[] parseAuthorization(String authorization)
{    String[] parts = authorization.split(" ");    if (parts.length == 2 && parts[0].equalsIgnoreCase("Basic")) {        String userPass = Base64.base64Decode(parts[1]);        int p = userPass.indexOf(":");        if (p != -1) {            return new String[] { userPass.substring(0, p), userPass.substring(p + 1) };        }    }    return null;}
0
public void init(FilterConfig arg0) throws ServletException
{}
0
public void destroy()
{}
0
public int hashCode()
{    return path.hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof ZChildren)) {        return false;    }    ZChildren o = (ZChildren) obj;    return path.equals(o.path) && children.equals(o.children);}
0
public String toString()
{    return "ZChildren(" + path + "," + children + ")";}
0
public int hashCode()
{    return path.hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof ZChildrenJSON)) {        return false;    }    ZChildrenJSON o = (ZChildrenJSON) obj;    return path.equals(o.path) && children.equals(o.children);}
0
public String toString()
{    return "ZChildrenJSON(" + path + "," + children + ")";}
0
public int hashCode()
{    return path.hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof ZPath)) {        return false;    }    ZPath o = (ZPath) obj;    return path.equals(o.path);}
0
public String toString()
{    return "ZPath(" + path + ")";}
0
public int hashCode()
{    return id.hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof ZSession)) {        return false;    }    ZSession s = (ZSession) obj;    return id.equals(s.id);}
0
public String toString()
{    return "ZSession(" + id + ")";}
0
public int hashCode()
{    return path.hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof ZStat)) {        return false;    }    ZStat o = (ZStat) obj;    return toString().equals(o.toString());}
0
public String toString()
{    return "ZStat(" + path + "," + "b64[" + (data64 == null ? null : new String(data64)) + "]," + dataUtf8 + ")";}
0
public JAXBContext getContext(Class<?> objectType)
{    return (typesSet.contains(objectType)) ? context : null;}
0
public Response toResponse(KeeperException e)
{    Response.Status status;    String message;    String path = e.getPath();    switch(e.code()) {        case AUTHFAILED:            status = Response.Status.UNAUTHORIZED;            message = path + " not authorized";            break;        case BADARGUMENTS:            status = Response.Status.BAD_REQUEST;            message = path + " bad arguments";            break;        case BADVERSION:            status = Response.Status.PRECONDITION_FAILED;            message = path + " bad version";            break;        case INVALIDACL:            status = Response.Status.BAD_REQUEST;            message = path + " invalid acl";            break;        case NODEEXISTS:            status = Response.Status.CONFLICT;            message = path + " already exists";            break;        case NONODE:            status = Response.Status.NOT_FOUND;            message = path + " not found";            break;        case NOTEMPTY:            status = Response.Status.CONFLICT;            message = path + " not empty";            break;        default:                        status = Response.Status.fromStatusCode(502);            message = "Error processing request for " + path + " : " + e.getMessage();    }    return Response.status(status).entity(new ZError(ui.getRequestUri().toString(), message)).build();}
0
public Response toResponse(RuntimeException e)
{        if (e instanceof WebApplicationException) {        WebApplicationException ie = (WebApplicationException) e;        return ie.getResponse();    }    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(new ZError(ui.getRequestUri().toString(), "Error processing request due to " + e)).build();}
0
public Response keepAliveSession(@PathParam("session") String session, @Context UriInfo ui, byte[] data)
{    if (!ZooKeeperService.isConnected(contextPath, session)) {        throwNotFound(session, ui);    }    ZooKeeperService.resetTimer(contextPath, session);    return Response.status(Response.Status.OK).build();}
0
public Response createSession(@QueryParam("op") String op, @DefaultValue("5") @QueryParam("expire") String expire, @Context UriInfo ui)
{    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), "")).build());    }    int expireInSeconds;    try {        expireInSeconds = Integer.parseInt(expire);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());    }    String uuid = UUID.randomUUID().toString();    while (ZooKeeperService.isConnected(contextPath, uuid)) {        uuid = UUID.randomUUID().toString();    }        try {        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);    } catch (IOException e) {                throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());    }    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();    return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();}
1
public void deleteSession(@PathParam("session") String session, @Context UriInfo ui)
{    ZooKeeperService.close(contextPath, session);}
0
private static void throwNotFound(String session, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), session + " not found")).build());}
0
public long getSize(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
0
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ZError.class.isAssignableFrom(type);}
0
public void writeTo(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream os) throws IOException, WebApplicationException
{    PrintStream p = new PrintStream(os);    p.print("Request " + t.request + " failed due to " + t.message);    p.flush();}
0
private void ensurePathNotNull(String path)
{    if (path == null) {        throw new IllegalArgumentException("Invalid path \"" + path + "\"");    }}
0
public Response existsZNode(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.OK).build();}
0
public Response existsZNodeAsOctet(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.NO_CONTENT).build();}
0
public Response getZNodeListJSON(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("data") @QueryParam("view") String view, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(true, path, callback, view, dataformat, ui);}
0
public Response getZNodeList(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("data") @QueryParam("view") String view, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(false, path, callback, view, dataformat, ui);}
0
private Response getZNodeList(boolean json, String path, String callback, String view, String dataformat, UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (view.equals("children")) {        List<String> children = new ArrayList<String>();        for (String child : zk.getChildren(path, false)) {            children.add(child);        }        Object child;        String childTemplate = ui.getAbsolutePath().toString();        if (!childTemplate.endsWith("/")) {            childTemplate += "/";        }        childTemplate += "{child}";        if (json) {            child = new ZChildrenJSON(path, ui.getAbsolutePath().toString(), childTemplate, children);        } else {            child = new ZChildren(path, ui.getAbsolutePath().toString(), childTemplate, children);        }        return Response.status(Response.Status.OK).entity(new JSONWithPadding(child, callback)).build();    } else {        Stat stat = new Stat();        byte[] data = zk.getData(path, false, stat);        byte[] data64;        String dataUtf8;        if (data == null) {            data64 = null;            dataUtf8 = null;        } else if (!dataformat.equals("utf8")) {            data64 = data;            dataUtf8 = null;        } else {            data64 = null;            dataUtf8 = new String(data);        }        ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), data64, dataUtf8, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());        return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();    }}
0
public Response getZNodeListAsOctet(@PathParam("path") String path) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    Stat stat = new Stat();    byte[] data = zk.getData(path, false, stat);    if (data == null) {        return Response.status(Response.Status.NO_CONTENT).build();    } else {        return Response.status(Response.Status.OK).entity(data).build();    }}
0
public Response setZNode(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("-1") @QueryParam("version") String versionParam, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @DefaultValue("false") @QueryParam("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    Stat stat = zk.setData(path, data, version);    ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), null, null, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());    return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();}
0
public void setZNodeAsOctet(@PathParam("path") String path, @DefaultValue("-1") @QueryParam("version") String versionParam, @DefaultValue("false") @QueryParam("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    zk.setData(path, data, version);}
0
public Response createZNode(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("create") @QueryParam("op") String op, @QueryParam("name") String name, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @DefaultValue("false") @QueryParam("null") String setNull, @DefaultValue("false") @QueryParam("sequence") String sequence, @DefaultValue("false") @QueryParam("ephemeral") String ephemeral, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        if (ephemeral.equals("false")) {            createMode = CreateMode.PERSISTENT_SEQUENTIAL;        } else {            createMode = CreateMode.EPHEMERAL_SEQUENTIAL;        }    } else if (ephemeral.equals("false")) {        createMode = CreateMode.PERSISTENT;    } else {        createMode = CreateMode.EPHEMERAL;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new JSONWithPadding(new ZPath(newPath, ui.getAbsolutePath().toString()))).build();}
0
public Response createZNodeAsOctet(@PathParam("path") String path, @DefaultValue("create") @QueryParam("op") String op, @QueryParam("name") String name, @DefaultValue("false") @QueryParam("null") String setNull, @DefaultValue("false") @QueryParam("sequence") String sequence, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        createMode = CreateMode.PERSISTENT_SEQUENTIAL;    } else {        createMode = CreateMode.PERSISTENT;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new ZPath(newPath, ui.getAbsolutePath().toString())).build();}
0
public void deleteZNode(@PathParam("path") String path, @DefaultValue("-1") @QueryParam("version") String versionParam, @Context UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    zk.delete(path, version);}
0
private static void throwNotFound(String path, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), path + " not found")).build());}
0
public void start() throws IOException
{    System.out.println("Starting grizzly ...");    boolean useSSL = cfg.useSSL();    gws = new GrizzlyWebServer(cfg.getPort(), "/tmp/23cxv45345/2131xc2/", useSSL);    for (Endpoint e : cfg.getEndpoints()) {        ZooKeeperService.mapContext(e.getContext(), e);        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });    }    if (useSSL) {        System.out.println("Starting SSL ...");        String jks = cfg.getJKS("keys/rest.jks");        String jksPassword = cfg.getJKSPassword();        SSLConfig sslConfig = new SSLConfig();        URL resource = getClass().getClassLoader().getResource(jks);        if (resource == null) {                        System.exit(2);        }        try {            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());        } catch (URISyntaxException e1) {                        System.exit(2);        }        sslConfig.setKeyStorePass(jksPassword);        gws.setSSLConfig(sslConfig);    }    gws.start();}
1
public void stop()
{    gws.stop();    ZooKeeperService.closeAll();}
0
private ServletAdapter createJerseyAdapter(Endpoint e)
{    ServletAdapter jersey = new ServletAdapter();    jersey.setServletInstance(new ServletContainer());    jersey.addInitParameter("com.sun.jersey.config.property.packages", "org.apache.zookeeper.server.jersey.resources");    jersey.setContextPath(e.getContext());    Credentials c = Credentials.join(e.getCredentials(), cfg.getCredentials());    if (!c.isEmpty()) {        jersey.addFilter(new HTTPBasicAuth(c), e.getContext() + "-basic-auth", null);    }    return jersey;}
0
public static void main(String[] args) throws Exception
{    RestCfg cfg = new RestCfg("rest.properties");    final RestMain main = new RestMain(cfg);    main.start();    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            main.stop();            System.out.println("Got exit request. Bye.");        }    });    printEndpoints(cfg);    System.out.println("Server started.");}
0
public void run()
{    main.stop();    System.out.println("Got exit request. Bye.");}
0
private static void printEndpoints(RestCfg cfg)
{    int port = cfg.getPort();    for (Endpoint e : cfg.getEndpoints()) {        String context = e.getContext();        if (context.charAt(context.length() - 1) != '/') {            context += "/";        }        System.out.println(String.format("Started %s - WADL: http://localhost:%d%sapplication.wadl", context, port, context));    }}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        close(contextPath);    }}
0
public void run()
{    if (LOG.isInfoEnabled()) {            }    ZooKeeperService.close(contextPath, session);}
1
public void reset()
{    timer.schedule(this, delay);}
0
public static synchronized void mapContext(String contextPath, Endpoint e)
{    contextMap.put(contextPath, e);}
0
public static synchronized void resetTimer(String contextPath, String session)
{    if (session != null) {        String uri = concat(contextPath, session);        SessionTimerTask t = zkSessionTimers.remove(uri);        t.cancel();        zkSessionTimers.put(uri, new SessionTimerTask(t));    }}
0
public static void close(String contextPath)
{    close(contextPath, null);}
0
public static synchronized void close(String contextPath, String session)
{    String uri = concat(contextPath, session);    TimerTask t = zkSessionTimers.remove(uri);    if (t != null) {        t.cancel();    }    ZooKeeper zk = zkMap.remove(uri);    if (zk == null) {        return;    }    try {        zk.close();    } catch (InterruptedException e) {            }}
1
public static synchronized void closeAll()
{    Set<String> sessions = new TreeSet<String>(zkMap.keySet());    for (String key : sessions) {        close(key);    }}
0
public static synchronized boolean isConnected(String contextPath, String session)
{    return zkMap.containsKey(concat(contextPath, session));}
0
public static ZooKeeper getClient(String contextPath) throws IOException
{    return getClient(contextPath, null);}
0
public static ZooKeeper getClient(String contextPath, String session) throws IOException
{    return getClient(contextPath, session, 5);}
0
public static synchronized ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException
{    final String connectionId = concat(contextPath, session);    ZooKeeper zk = zkMap.get(connectionId);    if (zk == null) {        if (LOG.isInfoEnabled()) {                    }        Endpoint e = contextMap.get(contextPath);        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {            zk.addAuthInfo("digest", String.format("%s:%s", p.getKey(), p.getValue()).getBytes());        }        zkMap.put(connectionId, zk);                if (session != null) {            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));        }    }    return zk;}
1
private static String concat(String contextPath, String session)
{    if (session != null) {        return String.format("%s@%s", contextPath, session);    }    return contextPath;}
0
public void setUp() throws Exception
{    RestCfg cfg = new RestCfg(new ByteArrayInputStream(String.format("rest.port=%s\n" + "rest.endpoint.1=%s;%s\n", GRIZZLY_PORT, CONTEXT_PATH, ZKHOSTPORT).getBytes()));    rest = new RestMain(cfg);    rest.start();    zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    client = Client.create();    znodesr = client.resource(BASEURI).path("znodes/v1");    sessionsr = client.resource(BASEURI).path("sessions/v1/");}
0
public void tearDown() throws Exception
{    client.destroy();    zk.close();    rest.stop();}
0
protected static String createBaseZNode() throws Exception
{    ZooKeeper zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    String baseZnode = zk.create("/test-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.close();    return baseZnode;}
0
public void process(WatchedEvent event)
{}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "foo bar", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/foo bar"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t1"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t2"), "".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t3"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t4", "base64", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t4"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true } });}
0
public void testCreate() throws Exception
{    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding).queryParam("name", name);    if (data == null) {        wr = wr.queryParam("null", "true");    }    if (sequence) {        wr = wr.queryParam("sequence", "true");    }    Builder builder = wr.accept(accept);    ClientResponse cr;    if (data == null) {        cr = builder.post(ClientResponse.class);    } else {        cr = builder.post(ClientResponse.class, data);    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedPath == null) {        return;    }    ZPath zpath = cr.getEntity(ZPath.class);    if (sequence) {        Assert.assertTrue(zpath.path.startsWith(expectedPath.path));        Assert.assertTrue(zpath.uri.startsWith(znodesr.path(path).toString()));    } else {        Assert.assertEquals(expectedPath, zpath);        Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);    }        byte[] data = zk.getData(zpath.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.assertEquals(data, this.data);    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
0
public void process(WatchedEvent event)
{}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT }, { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT } });}
0
public void verify(String type) throws Exception
{    if (expectedStatus != ClientResponse.Status.NOT_FOUND) {        zpath = zk.create(zpath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    }    ClientResponse cr = znodesr.path(zpath).accept(type).type(type).delete(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());        Stat stat = zk.exists(zpath, false);    Assert.assertNull(stat);}
0
public void testDelete() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, ClientResponse.Status.OK }, { baseZnode + "dkdk38383", ClientResponse.Status.NOT_FOUND } });}
0
private void verify(String type)
{    ClientResponse cr = znodesr.path(path).accept(type).type(type).head();    if (type.equals(MediaType.APPLICATION_OCTET_STREAM) && expectedStatus == ClientResponse.Status.OK) {        Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    } else {        Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    }}
0
public void testExists() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    String baseZnode2 = Base.createBaseZNode();    String baseZnode3 = Base.createBaseZNode();    String baseZnode4 = Base.createBaseZNode();    String baseZnode5 = Base.createBaseZNode();    String baseZnode6 = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_XML, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_XML, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_XML, baseZnode4, ClientResponse.Status.OK, baseZnode4, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_JSON, baseZnode2, ClientResponse.Status.OK, baseZnode2, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_XML, baseZnode5, ClientResponse.Status.OK, baseZnode5, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_JSON, baseZnode3, ClientResponse.Status.OK, baseZnode3, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) }, { MediaType.APPLICATION_XML, baseZnode6, ClientResponse.Status.OK, baseZnode6, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) } });}
0
public void testGetChildren() throws Exception
{    if (expectedChildren != null) {        for (String child : expectedChildren) {            zk.create(expectedPath + "/" + child, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    ClientResponse cr = znodesr.path(path).queryParam("view", "children").accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedChildren == null) {        return;    }    if (accept.equals(MediaType.APPLICATION_JSON)) {        ZChildrenJSON zchildren = cr.getEntity(ZChildrenJSON.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else if (accept.equals(MediaType.APPLICATION_XML)) {        ZChildren zchildren = cr.getEntity(ZChildren.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else {        Assert.fail("unknown accept type");    }}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "") }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_XML, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null } });}
0
public void testGet() throws Exception
{    if (expectedStat != null) {        if (expectedStat.data64 != null || expectedStat.dataUtf8 == null) {            zk.setData(expectedStat.path, expectedStat.data64, -1);        } else {            zk.setData(expectedStat.path, expectedStat.dataUtf8.getBytes(), -1);        }    }    ClientResponse cr = znodesr.path(path).queryParam("dataformat", encoding).accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);    Assert.assertEquals(znodesr.path(path).toString(), zstat.uri);}
0
public static void setUp()
{}
0
public static void tearDown()
{}
0
public void testCreate() throws Exception
{    String path = "/";    String name = "roottest-create";    byte[] data = "foo".getBytes();    WebResource wr = znodesr.path(path).queryParam("dataformat", "utf8").queryParam("name", name);    Builder builder = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr;    cr = builder.post(ClientResponse.class, data);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    ZPath zpath = cr.getEntity(ZPath.class);    Assert.assertEquals(new ZPath(path + name), zpath);    Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);        byte[] rdata = zk.getData(zpath.path, false, new Stat());    Assert.assertTrue(new String(rdata) + " == " + new String(data), Arrays.equals(rdata, data));}
0
private ZSession createSession()
{    return createSession("30");}
0
private ZSession createSession(String expire)
{    WebResource wr = sessionsr.queryParam("op", "create").queryParam("expire", expire);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    return cr.getEntity(ZSession.class);}
0
public void testCreateNewSession() throws JSONException
{    ZSession session = createSession();    Assert.assertEquals(session.id.length(), 36);        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
0
public void testSessionExpires() throws InterruptedException
{    ZSession session = createSession("1");        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));        Thread.sleep(1500);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
0
public void testDeleteSession()
{    ZSession session = createSession("30");    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    ClientResponse cr = b.delete(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
0
public void testSendHeartbeat() throws InterruptedException
{    ZSession session = createSession("2");    Thread.sleep(1000);    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.put(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.OK, cr.getClientResponseStatus());    Thread.sleep(1500);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    Thread.sleep(1000);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
0
public void testCreateEphemeralZNode() throws KeeperException, InterruptedException, IOException
{    ZSession session = createSession("30");    WebResource wr = znodesr.path("/").queryParam("op", "create").queryParam("name", "ephemeral-test").queryParam("ephemeral", "true").queryParam("session", session.id).queryParam("null", "true");    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    Stat stat = new Stat();    zk.getData("/ephemeral-test", false, stat);    ZooKeeper sessionZK = ZooKeeperService.getClient(CONTEXT_PATH, session.id);    Assert.assertEquals(stat.getEphemeralOwner(), sessionZK.getSessionId());}
0
public void process(WatchedEvent event)
{}
0
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "/s-t1", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t1", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t2", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t2", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t3", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t3", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t4", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t4", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t5", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t5", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t6", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t6", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "utf8", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "base64", ClientResponse.Status.NOT_FOUND, null, null } });}
0
public void testSet() throws Exception
{    if (expectedStat != null) {        zk.create(expectedStat.path, "initial".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding);    if (data == null) {        wr = wr.queryParam("null", "true");    }    Builder builder = wr.accept(accept).type(MediaType.APPLICATION_OCTET_STREAM);    ClientResponse cr;    if (data == null) {        cr = builder.put(ClientResponse.class);    } else {                                        cr = builder.put(ClientResponse.class, new String(data));    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);        byte[] data = zk.getData(zstat.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.fail((data == null ? null : new String(data)) + " == " + (this.data == null ? null : new String(this.data)));    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
0
public void testApplicationWadl()
{    WebResource r = client.resource(BASEURI);    String serviceWadl = r.path("application.wadl").accept(MediaTypes.WADL).get(String.class);    Assert.assertTrue("Something wrong. Returned wadl length not > 0.", serviceWadl.length() > 0);}
0
private void initComponents()
{    setSize(toasterWidth, toasterHeight);    message.setFont(getToasterMessageFont());    JPanel externalPanel = new JPanel(new BorderLayout(1, 1));    externalPanel.setBackground(getBorderColor());    JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));    innerPanel.setBackground(getToasterColor());    message.setBackground(getToasterColor());    message.setMargin(new Insets(2, 2, 2, 2));    message.setLineWrap(true);    message.setWrapStyleWord(true);    EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();    externalPanel.setBorder(etchedBorder);    externalPanel.add(innerPanel);    message.setForeground(getMessageColor());    innerPanel.add(iconLabel, BorderLayout.WEST);    innerPanel.add(message, BorderLayout.CENTER);    getContentPane().add(externalPanel);}
0
public void animate()
{    (new Animation(this)).start();}
0
protected void animateVertically(int posx, int fromY, int toY) throws InterruptedException
{    toaster.setLocation(posx, fromY);    if (toY < fromY) {        for (int i = fromY; i > toY; i -= step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    } else {        for (int i = fromY; i < toY; i += step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    }    toaster.setLocation(posx, toY);}
0
public void run()
{    try {        boolean animateFromBottom = true;        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();        Rectangle screenRect = ge.getMaximumWindowBounds();        int screenHeight = (int) screenRect.height;        int startYPosition;        int stopYPosition;        if (screenRect.y > 0) {                        animateFromBottom = false;        }        maxToasterInSceen = screenHeight / toasterHeight;        int posx = (int) screenRect.width - toasterWidth - 1;        toaster.setLocation(posx, screenHeight);        toaster.setVisible(true);        if (useAlwaysOnTop) {            toaster.setAlwaysOnTop(true);        }        if (animateFromBottom) {            startYPosition = screenHeight;            stopYPosition = startYPosition - toasterHeight - 1;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition - (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        } else {            startYPosition = screenRect.y - toasterHeight;            stopYPosition = screenRect.y;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition + (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        }        currentNumberOfToaster++;        maxToaster++;        animateVertically(posx, startYPosition, stopYPosition);        Thread.sleep(displayTime);        animateVertically(posx, stopYPosition, startYPosition);        currentNumberOfToaster--;        toaster.setVisible(false);        toaster.dispose();    } catch (Exception e) {        e.printStackTrace();    }}
0
public void showToaster(Icon icon, String msg)
{    SingleToaster singleToaster = new SingleToaster();    if (icon != null) {        singleToaster.iconLabel.setIcon(icon);    }    singleToaster.message.setText(msg);    singleToaster.animate();}
0
public void showToaster(String msg)
{    showToaster(null, msg);}
0
public Font getToasterMessageFont()
{        return font;}
0
public void setToasterMessageFont(Font f)
{    font = f;}
0
public Color getBorderColor()
{    return borderColor;}
0
public void setBorderColor(Color borderColor)
{    this.borderColor = borderColor;}
0
public int getDisplayTime()
{    return displayTime;}
0
public void setDisplayTime(int displayTime)
{    this.displayTime = displayTime;}
0
public int getMargin()
{    return margin;}
0
public void setMargin(int margin)
{    this.margin = margin;}
0
public Color getMessageColor()
{    return messageColor;}
0
public void setMessageColor(Color messageColor)
{    this.messageColor = messageColor;}
0
public int getStep()
{    return step;}
0
public void setStep(int step)
{    this.step = step;}
0
public int getStepTime()
{    return stepTime;}
0
public void setStepTime(int stepTime)
{    this.stepTime = stepTime;}
0
public Color getToasterColor()
{    return toasterColor;}
0
public void setToasterColor(Color toasterColor)
{    this.toasterColor = toasterColor;}
0
public int getToasterHeight()
{    return toasterHeight;}
0
public void setToasterHeight(int toasterHeight)
{    this.toasterHeight = toasterHeight;}
0
public int getToasterWidth()
{    return toasterWidth;}
0
public void setToasterWidth(int toasterWidth)
{    this.toasterWidth = toasterWidth;}
0
public String decryptData(byte[] encrypted) throws Exception
{    return new String(encrypted);}
0
public byte[] encryptData(String data) throws Exception
{    if (data == null) {        return new byte[0];    }    return data.getBytes();}
0
public void actionPerformed(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 1) {        final String nodeName = JOptionPane.showInputDialog(panel, "Please Enter a name for the new node", "Create Node", JOptionPane.INFORMATION_MESSAGE);        if (nodeName != null && nodeName.length() > 0) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    } else {        JOptionPane.showMessageDialog(panel, "Please select 1 parent node for the new node.");    }}
0
protected Boolean doInBackground() throws Exception
{    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);}
0
protected void done()
{    treeViewer.refreshView();}
0
public void actionPerformed(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 0) {        JOptionPane.showMessageDialog(parentPanel, "Please select at least 1 node to be deleted");    } else {        int answer = JOptionPane.showConfirmDialog(parentPanel, "Are you sure you want to delete the selected nodes?" + "(This action cannot be reverted)", "Confirm Delete", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        if (answer == JOptionPane.YES_OPTION) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    for (String nodePath : selectedNodes) {                        zooInspectorManager.deleteNode(nodePath);                    }                    return true;                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    }}
0
protected Boolean doInBackground() throws Exception
{    for (String nodePath : selectedNodes) {        zooInspectorManager.deleteNode(nodePath);    }    return true;}
0
protected void done()
{    treeViewer.refreshView();}
0
public URL find(String name)
{    String iconPath = buildIconPath(name);    URL iconUrl = findInPaths(iconPath);    if (null != iconUrl)        return iconUrl;    iconUrl = getClass().getResource(iconPath);    if (null != iconUrl)        return iconUrl;    if (!name.equals(FALLBACK_ICON))        return find(FALLBACK_ICON);    return null;}
0
public ImageIcon get(String name, String description)
{    URL iconUrl = find(name);    if (null == iconUrl) {        ImageIcon icon = new ImageIcon();        icon.setDescription(description);        return icon;    } else {        return new ImageIcon(iconUrl, description);    }}
0
private URL findInPaths(String iconPath)
{    for (String dataDir : DEFAULT_XDG_DATA_DIRS) {        File file = new File(dataDir + iconPath);        if (file.exists()) {            try {                return file.toURI().toURL();            } catch (MalformedURLException e) {                LoggerFactory.getLogger().warn(e.toString());            }        }    }    return null;}
0
private String buildIconPath(String name)
{    return "/icons/" + theme + "/" + size + "/" + name + ".png";}
0
public String getTitle()
{    return "Node ACLs";}
0
public void nodeSelectionChanged(List<String> selectedNodes)
{    this.aclDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<List<Map<String, String>>, Void> worker = new SwingWorker<List<Map<String, String>>, Void>() {            @Override            protected List<Map<String, String>> doInBackground() throws Exception {                return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);            }            @Override            protected void done() {                List<Map<String, String>> acls = null;                try {                    acls = get();                } catch (InterruptedException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                } catch (ExecutionException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                }                aclDataPanel.setLayout(new GridBagLayout());                int j = 0;                for (Map<String, String> data : acls) {                    int rowPos = 2 * j + 1;                    JPanel aclPanel = new JPanel();                    aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));                    aclPanel.setBackground(Color.WHITE);                    aclPanel.setLayout(new GridBagLayout());                    int i = 0;                    for (Map.Entry<String, String> entry : data.entrySet()) {                        int rowPosACL = 2 * i + 1;                        JLabel label = new JLabel(entry.getKey());                        JTextField text = new JTextField(entry.getValue());                        text.setEditable(false);                        GridBagConstraints c1 = new GridBagConstraints();                        c1.gridx = 1;                        c1.gridy = rowPosACL;                        c1.gridwidth = 1;                        c1.gridheight = 1;                        c1.weightx = 0;                        c1.weighty = 0;                        c1.anchor = GridBagConstraints.NORTHWEST;                        c1.fill = GridBagConstraints.BOTH;                        c1.insets = new Insets(5, 5, 5, 5);                        c1.ipadx = 0;                        c1.ipady = 0;                        aclPanel.add(label, c1);                        GridBagConstraints c2 = new GridBagConstraints();                        c2.gridx = 3;                        c2.gridy = rowPosACL;                        c2.gridwidth = 1;                        c2.gridheight = 1;                        c2.weightx = 0;                        c2.weighty = 0;                        c2.anchor = GridBagConstraints.NORTHWEST;                        c2.fill = GridBagConstraints.BOTH;                        c2.insets = new Insets(5, 5, 5, 5);                        c2.ipadx = 0;                        c2.ipady = 0;                        aclPanel.add(text, c2);                        i++;                    }                    GridBagConstraints c = new GridBagConstraints();                    c.gridx = 1;                    c.gridy = rowPos;                    c.gridwidth = 1;                    c.gridheight = 1;                    c.weightx = 1;                    c.weighty = 1;                    c.anchor = GridBagConstraints.NORTHWEST;                    c.fill = GridBagConstraints.NONE;                    c.insets = new Insets(5, 5, 5, 5);                    c.ipadx = 0;                    c.ipady = 0;                    aclDataPanel.add(aclPanel, c);                }                NodeViewerACL.this.aclDataPanel.revalidate();                NodeViewerACL.this.aclDataPanel.repaint();            }        };        worker.execute();    }}
0
protected List<Map<String, String>> doInBackground() throws Exception
{    return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);}
0
protected void done()
{    List<Map<String, String>> acls = null;    try {        acls = get();    } catch (InterruptedException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    } catch (ExecutionException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    }    aclDataPanel.setLayout(new GridBagLayout());    int j = 0;    for (Map<String, String> data : acls) {        int rowPos = 2 * j + 1;        JPanel aclPanel = new JPanel();        aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));        aclPanel.setBackground(Color.WHITE);        aclPanel.setLayout(new GridBagLayout());        int i = 0;        for (Map.Entry<String, String> entry : data.entrySet()) {            int rowPosACL = 2 * i + 1;            JLabel label = new JLabel(entry.getKey());            JTextField text = new JTextField(entry.getValue());            text.setEditable(false);            GridBagConstraints c1 = new GridBagConstraints();            c1.gridx = 1;            c1.gridy = rowPosACL;            c1.gridwidth = 1;            c1.gridheight = 1;            c1.weightx = 0;            c1.weighty = 0;            c1.anchor = GridBagConstraints.NORTHWEST;            c1.fill = GridBagConstraints.BOTH;            c1.insets = new Insets(5, 5, 5, 5);            c1.ipadx = 0;            c1.ipady = 0;            aclPanel.add(label, c1);            GridBagConstraints c2 = new GridBagConstraints();            c2.gridx = 3;            c2.gridy = rowPosACL;            c2.gridwidth = 1;            c2.gridheight = 1;            c2.weightx = 0;            c2.weighty = 0;            c2.anchor = GridBagConstraints.NORTHWEST;            c2.fill = GridBagConstraints.BOTH;            c2.insets = new Insets(5, 5, 5, 5);            c2.ipadx = 0;            c2.ipady = 0;            aclPanel.add(text, c2);            i++;        }        GridBagConstraints c = new GridBagConstraints();        c.gridx = 1;        c.gridy = rowPos;        c.gridwidth = 1;        c.gridheight = 1;        c.weightx = 1;        c.weighty = 1;        c.anchor = GridBagConstraints.NORTHWEST;        c.fill = GridBagConstraints.NONE;        c.insets = new Insets(5, 5, 5, 5);        c.ipadx = 0;        c.ipady = 0;        aclDataPanel.add(aclPanel, c);    }    NodeViewerACL.this.aclDataPanel.revalidate();    NodeViewerACL.this.aclDataPanel.repaint();}
0
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
0
public void actionPerformed(ActionEvent e)
{    if (selectedNode != null) {        if (JOptionPane.showConfirmDialog(NodeViewerData.this, "Are you sure you want to save this node?" + " (this action cannot be reverted)", "Confirm Save", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {            zooInspectorManager.setData(selectedNode, dataArea.getText());        }    }}
0
public String getTitle()
{    return "Node Data";}
0
public void nodeSelectionChanged(List<String> selectedNodes)
{    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<String, Void> worker = new SwingWorker<String, Void>() {            @Override            protected String doInBackground() throws Exception {                return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);            }            @Override            protected void done() {                String data = "";                try {                    data = get();                } catch (InterruptedException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                } catch (ExecutionException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                }                NodeViewerData.this.dataArea.setText(data);            }        };        worker.execute();    }}
0
protected String doInBackground() throws Exception
{    return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);}
0
protected void done()
{    String data = "";    try {        data = get();    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    }    NodeViewerData.this.dataArea.setText(data);}
0
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
0
public String getTitle()
{    return "Node Metadata";}
0
public void nodeSelectionChanged(List<String> selectedNodes)
{    this.metaDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<Map<String, String>, Void> worker = new SwingWorker<Map<String, String>, Void>() {            @Override            protected Map<String, String> doInBackground() throws Exception {                return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);            }            @Override            protected void done() {                Map<String, String> data = null;                try {                    data = get();                } catch (InterruptedException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                } catch (ExecutionException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                }                NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());                JPanel infoPanel = new JPanel();                infoPanel.setBackground(Color.WHITE);                infoPanel.setLayout(new GridBagLayout());                int i = 0;                int rowPos = 0;                for (Map.Entry<String, String> entry : data.entrySet()) {                    rowPos = 2 * i + 1;                    JLabel label = new JLabel(entry.getKey());                    JTextField text = new JTextField(entry.getValue());                    text.setEditable(false);                    GridBagConstraints c1 = new GridBagConstraints();                    c1.gridx = 0;                    c1.gridy = rowPos;                    c1.gridwidth = 1;                    c1.gridheight = 1;                    c1.weightx = 0;                    c1.weighty = 0;                    c1.anchor = GridBagConstraints.WEST;                    c1.fill = GridBagConstraints.HORIZONTAL;                    c1.insets = new Insets(5, 5, 5, 5);                    c1.ipadx = 0;                    c1.ipady = 0;                    infoPanel.add(label, c1);                    GridBagConstraints c2 = new GridBagConstraints();                    c2.gridx = 2;                    c2.gridy = rowPos;                    c2.gridwidth = 1;                    c2.gridheight = 1;                    c2.weightx = 0;                    c2.weighty = 0;                    c2.anchor = GridBagConstraints.WEST;                    c2.fill = GridBagConstraints.HORIZONTAL;                    c2.insets = new Insets(5, 5, 5, 5);                    c2.ipadx = 0;                    c2.ipady = 0;                    infoPanel.add(text, c2);                    i++;                }                GridBagConstraints c = new GridBagConstraints();                c.gridx = 1;                c.gridy = rowPos;                c.gridwidth = 1;                c.gridheight = 1;                c.weightx = 1;                c.weighty = 1;                c.anchor = GridBagConstraints.NORTHWEST;                c.fill = GridBagConstraints.NONE;                c.insets = new Insets(5, 5, 5, 5);                c.ipadx = 0;                c.ipady = 0;                NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);                NodeViewerMetaData.this.metaDataPanel.revalidate();                NodeViewerMetaData.this.metaDataPanel.repaint();            }        };        worker.execute();    }}
0
protected Map<String, String> doInBackground() throws Exception
{    return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);}
0
protected void done()
{    Map<String, String> data = null;    try {        data = get();    } catch (InterruptedException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    } catch (ExecutionException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    }    NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());    JPanel infoPanel = new JPanel();    infoPanel.setBackground(Color.WHITE);    infoPanel.setLayout(new GridBagLayout());    int i = 0;    int rowPos = 0;    for (Map.Entry<String, String> entry : data.entrySet()) {        rowPos = 2 * i + 1;        JLabel label = new JLabel(entry.getKey());        JTextField text = new JTextField(entry.getValue());        text.setEditable(false);        GridBagConstraints c1 = new GridBagConstraints();        c1.gridx = 0;        c1.gridy = rowPos;        c1.gridwidth = 1;        c1.gridheight = 1;        c1.weightx = 0;        c1.weighty = 0;        c1.anchor = GridBagConstraints.WEST;        c1.fill = GridBagConstraints.HORIZONTAL;        c1.insets = new Insets(5, 5, 5, 5);        c1.ipadx = 0;        c1.ipady = 0;        infoPanel.add(label, c1);        GridBagConstraints c2 = new GridBagConstraints();        c2.gridx = 2;        c2.gridy = rowPos;        c2.gridwidth = 1;        c2.gridheight = 1;        c2.weightx = 0;        c2.weighty = 0;        c2.anchor = GridBagConstraints.WEST;        c2.fill = GridBagConstraints.HORIZONTAL;        c2.insets = new Insets(5, 5, 5, 5);        c2.ipadx = 0;        c2.ipady = 0;        infoPanel.add(text, c2);        i++;    }    GridBagConstraints c = new GridBagConstraints();    c.gridx = 1;    c.gridy = rowPos;    c.gridwidth = 1;    c.gridheight = 1;    c.weightx = 1;    c.weighty = 1;    c.anchor = GridBagConstraints.NORTHWEST;    c.fill = GridBagConstraints.NONE;    c.insets = new Insets(5, 5, 5, 5);    c.ipadx = 0;    c.ipady = 0;    NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);    NodeViewerMetaData.this.metaDataPanel.revalidate();    NodeViewerMetaData.this.metaDataPanel.repaint();}
0
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
0
public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException
{    if (flavor.equals(nodeViewerDataFlavor)) {        return this.getClass().getCanonicalName();    } else {        return null;    }}
0
public DataFlavor[] getTransferDataFlavors()
{    return new DataFlavor[] { nodeViewerDataFlavor };}
0
public boolean isDataFlavorSupported(DataFlavor flavor)
{    return flavor.equals(nodeViewerDataFlavor);}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorNodeViewer other = (ZooInspectorNodeViewer) obj;    if (getClass().getCanonicalName() != other.getClass().getCanonicalName()) {        return false;    }    if (getTitle() == null) {        if (other.getTitle() != null)            return false;    } else if (!getTitle().equals(other.getTitle()))        return false;    return true;}
0
public void addActionListener(Button button, ActionListener actionListener)
{    buttons.get(button).addActionListener(actionListener);}
0
public JToolBar getJToolBar()
{    return toolbar;}
0
public void toggleButtons(boolean connected)
{    for (Button button : buttonsToToggle) {        buttons.get(button).setEnabled(connected != button.enabled);    }}
0
private void init()
{    toolbar.setFloatable(false);    for (Button button : Button.values()) {        JButton jbutton = button.createJButton(iconResource);        buttons.put(button, jbutton);        toolbar.add(jbutton);    }}
0
public JButton createJButton(IconResource iconResource)
{    JButton jbutton = new JButton(iconResource.get(icon, toolTip));    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorAboutDialog.this.dispose();}
0
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorConnectionPropertiesDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File propsFilePath = fileChooser.getSelectedFile();        Properties props = new Properties();        try {            FileReader reader = new FileReader(propsFilePath);            try {                props.load(reader);                loadConnectionProps(props);            } finally {                reader.close();            }        } catch (IOException ex) {            LoggerFactory.getLogger().error("An Error occurred loading connection properties from file", ex);            JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred loading connection properties from file", "Error", JOptionPane.ERROR_MESSAGE);        }        options.revalidate();        options.repaint();    }}
0
public void actionPerformed(ActionEvent e)
{    Properties connectionProps = getConnectionProps();    try {        zooInspectorPanel.setdefaultConnectionProps(connectionProps);    } catch (IOException ex) {        LoggerFactory.getLogger().error("An Error occurred saving the default connection properties file", ex);        JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred saving the default connection properties file", "Error", JOptionPane.ERROR_MESSAGE);    }}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();    Properties connectionProps = getConnectionProps();    zooInspectorPanel.connect(connectionProps);}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();}
0
private void loadConnectionProps(Properties props)
{    if (props != null) {        for (Object key : props.keySet()) {            String propsKey = (String) key;            if (components.containsKey(propsKey)) {                JComponent component = components.get(propsKey);                String value = props.getProperty(propsKey);                if (component instanceof JTextField) {                    ((JTextField) component).setText(value);                } else if (component instanceof JComboBox) {                    ((JComboBox) component).setSelectedItem(value);                }            }        }    }}
0
private Properties getConnectionProps()
{    Properties connectionProps = new Properties();    for (Entry<String, JComponent> entry : components.entrySet()) {        String value = null;        JComponent component = entry.getValue();        if (component instanceof JTextField) {            value = ((JTextField) component).getText();        } else if (component instanceof JComboBox) {            value = ((JComboBox) component).getSelectedItem().toString();        }        connectionProps.put(entry.getKey(), value);    }    return connectionProps;}
0
public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus)
{    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) value;    JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);    label.setText(viewer.getTitle());    return label;}
0
public boolean canImport(TransferHandler.TransferSupport info)
{        if (!info.isDataFlavorSupported(ZooInspectorNodeViewer.nodeViewerDataFlavor)) {        return false;    }    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    if (dl.getIndex() == -1) {        return false;    }    return true;}
0
public boolean importData(TransferHandler.TransferSupport info)
{    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    int index = dl.getIndex();    boolean insert = dl.isInsert();        Transferable t = info.getTransferable();    String data;    try {        data = (String) t.getTransferData(ZooInspectorNodeViewer.nodeViewerDataFlavor);    } catch (Exception e) {        return false;    }    try {        ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(data).newInstance();        if (listModel.contains(viewer)) {            listModel.removeElement(viewer);        }        if (insert) {            listModel.add(index, viewer);        } else {            listModel.set(index, viewer);        }        return true;    } catch (Exception e) {        LoggerFactory.getLogger().error("Error instantiating class: " + data, e);        return false;    }}
0
public int getSourceActions(JComponent c)
{    return MOVE;}
0
protected Transferable createTransferable(JComponent c)
{    JList list = (JList) c;    ZooInspectorNodeViewer value = (ZooInspectorNodeViewer) list.getSelectedValue();    return value;}
0
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index - 1);        viewersList.setSelectedValue(viewer, true);    }}
0
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index + 1);        viewersList.setSelectedValue(viewer, true);    }}
0
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElement(viewer);        viewersList.setSelectedIndex(index == listModel.size() ? index - 1 : index);    }}
0
public void actionPerformed(ActionEvent e)
{    String className = newViewerTextField.getText();    if (className == null || className.length() == 0) {        JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Please enter the full class name for a Node Viewer and click the add button", "Input Error", JOptionPane.ERROR_MESSAGE);    } else {        try {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(className).newInstance();            if (listModel.contains(viewer)) {                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Node viewer already exists.  Each node viewer can only be added once.", "Input Error", JOptionPane.ERROR_MESSAGE);            } else {                listModel.addElement(viewer);            }        } catch (Exception ex) {            LoggerFactory.getLogger().error("An error occurred while instaniating the node viewer. ", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "An error occurred while instaniating the node viewer: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
0
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showSaveDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File selectedFile = fileChooser.getSelectedFile();        int answer = JOptionPane.YES_OPTION;        if (selectedFile.exists()) {            answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "The specified file already exists.  do you want to overwrite it?", "Confirm Overwrite", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        }        if (answer == JOptionPane.YES_OPTION) {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            List<String> nodeViewersClassNames = new ArrayList<String>();            Object[] modelContents = listModel.toArray();            for (Object o : modelContents) {                nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());            }            try {                manager.saveNodeViewersFile(selectedFile, nodeViewersClassNames);            } catch (IOException ex) {                LoggerFactory.getLogger().error("Error saving node viewer configuration from file.", ex);                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error saving node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);            }        }    }}
0
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        try {            List<String> nodeViewersClassNames = manager.loadNodeViewersFile(fileChooser.getSelectedFile());            List<ZooInspectorNodeViewer> nodeViewers = new ArrayList<ZooInspectorNodeViewer>();            for (String nodeViewersClassName : nodeViewersClassNames) {                ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(nodeViewersClassName).newInstance();                nodeViewers.add(viewer);            }            DefaultListModel model = new DefaultListModel();            for (ZooInspectorNodeViewer viewer : nodeViewers) {                model.addElement(viewer);            }            viewersList.setModel(model);            panel.revalidate();            panel.repaint();        } catch (Exception ex) {            LoggerFactory.getLogger().error("Error loading node viewer configuration from file.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error loading node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
0
public void actionPerformed(ActionEvent e)
{    int answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "Are you sure you want to save this configuration as the default?", "Confirm Set Defaults", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);    if (answer == JOptionPane.YES_OPTION) {        DefaultListModel listModel = (DefaultListModel) viewersList.getModel();        List<String> nodeViewersClassNames = new ArrayList<String>();        Object[] modelContents = listModel.toArray();        for (Object o : modelContents) {            nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());        }        try {            manager.setDefaultNodeViewerConfiguration(nodeViewersClassNames);        } catch (IOException ex) {            LoggerFactory.getLogger().error("Error setting default node viewer configuration.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error setting default node viewer configuration: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    newViewers.clear();    Object[] modelContents = listModel.toArray();    for (Object o : modelContents) {        newViewers.add((ZooInspectorNodeViewer) o);    }    currentViewers.clear();    currentViewers.addAll(newViewers);    for (NodeViewersChangeListener listener : listeners) {        listener.nodeViewersChanged(currentViewers);    }}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();}
0
public void valueChanged(ListSelectionEvent e)
{    JButton removeButton = buttons.get(Button.remove);    JButton upButton = buttons.get(Button.up);    JButton downButton = buttons.get(Button.down);    int index = viewersList.getSelectedIndex();    if (index == -1) {        removeButton.setEnabled(false);        upButton.setEnabled(false);        downButton.setEnabled(false);    } else {        removeButton.setEnabled(true);        if (index == 0) {            upButton.setEnabled(false);        } else {            upButton.setEnabled(true);        }        if (index == ((DefaultListModel) viewersList.getModel()).getSize()) {            downButton.setEnabled(false);        } else {            downButton.setEnabled(true);        }    }}
0
public JButton createJButton(IconResource iconResource)
{    ImageIcon imageIcon = iconResource.get(icon, toolTip);    JButton jbutton;    if (imageIcon == null) {        jbutton = new JButton(icon);    } else {        jbutton = new JButton(imageIcon);    }    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
0
public void setNodeViewers(List<ZooInspectorNodeViewer> nodeViewers)
{    this.nodeVeiwers.clear();    this.nodeVeiwers.addAll(nodeViewers);    needsReload.clear();    tabbedPane.removeAll();    for (ZooInspectorNodeViewer nodeViewer : nodeVeiwers) {        nodeViewer.setZooInspectorManager(zooInspectorManager);        needsReload.add(true);        tabbedPane.add(nodeViewer.getTitle(), nodeViewer);    }    this.revalidate();    this.repaint();}
0
private void reloadSelectedViewer()
{    int index = this.tabbedPane.getSelectedIndex();    if (index != -1 && this.needsReload.get(index)) {        ZooInspectorNodeViewer viewer = this.nodeVeiwers.get(index);        viewer.nodeSelectionChanged(selectedNodes);        this.needsReload.set(index, false);    }}
0
public void valueChanged(TreeSelectionEvent e)
{    TreePath[] paths = e.getPaths();    selectedNodes.clear();    for (TreePath path : paths) {        boolean appended = false;        StringBuilder sb = new StringBuilder();        Object[] pathArray = path.getPath();        for (Object o : pathArray) {            if (o != null) {                String nodeName = o.toString();                if (nodeName != null) {                    if (nodeName.length() > 0) {                        appended = true;                                                sb.append("/");                        sb.append(o.toString());                    }                }            }        }        if (appended) {            selectedNodes.add(sb.toString());        }    }    for (int i = 0; i < needsReload.size(); i++) {        this.needsReload.set(i, true);    }    reloadSelectedViewer();}
0
public void stateChanged(ChangeEvent e)
{    reloadSelectedViewer();}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog zicpd = new ZooInspectorConnectionPropertiesDialog(zooInspectorManager.getLastConnectionProps(), zooInspectorManager.getConnectionPropertiesTemplate(), ZooInspectorPanel.this);    zicpd.setVisible(true);}
0
public void actionPerformed(ActionEvent e)
{    disconnect();}
0
public void actionPerformed(ActionEvent e)
{    treeViewer.refreshView();}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog nvd = new ZooInspectorNodeViewersDialog(JOptionPane.getRootFrame(), nodeViewers, listeners, zooInspectorManager, iconResource);    nvd.setVisible(true);}
0
public void actionPerformed(ActionEvent e)
{    ZooInspectorAboutDialog zicpd = new ZooInspectorAboutDialog(JOptionPane.getRootFrame(), iconResource);    zicpd.setVisible(true);}
0
public void connect(final Properties connectionProps)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            zooInspectorManager.setLastConnectionProps(connectionProps);            return zooInspectorManager.connect(connectionProps);        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.refreshView();                    toolbar.toggleButtons(true);                } else {                    JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            }        }    };    worker.execute();}
0
protected Boolean doInBackground() throws Exception
{    zooInspectorManager.setLastConnectionProps(connectionProps);    return zooInspectorManager.connect(connectionProps);}
0
protected void done()
{    try {        if (get()) {            treeViewer.refreshView();            toolbar.toggleButtons(true);        } else {            JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    }}
0
public void disconnect()
{    disconnect(false);}
0
public void disconnect(boolean wait)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            return ZooInspectorPanel.this.zooInspectorManager.disconnect();        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.clearView();                    toolbar.toggleButtons(false);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    };    worker.execute();    if (wait) {        while (!worker.isDone()) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    }}
0
protected Boolean doInBackground() throws Exception
{    return ZooInspectorPanel.this.zooInspectorManager.disconnect();}
0
protected void done()
{    try {        if (get()) {            treeViewer.clearView();            toolbar.toggleButtons(false);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }}
0
public void nodeViewersChanged(List<ZooInspectorNodeViewer> newViewers)
{    this.nodeViewersPanel.setNodeViewers(newViewers);}
0
public void setdefaultConnectionProps(Properties connectionProps) throws IOException
{    this.zooInspectorManager.saveDefaultConnectionFile(connectionProps);}
0
public void actionPerformed(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.addWatchers(selectedNodes, ZooInspectorTreeViewer.this);}
0
public void actionPerformed(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.removeWatchers(selectedNodes);}
0
public void mouseClicked(MouseEvent e)
{    if (e.isPopupTrigger() || e.getButton() == MouseEvent.BUTTON3) {                                popupMenu.removeAll();        popupMenu.add(addNode);        popupMenu.add(deleteNode);        popupMenu.add(addNotify);        popupMenu.add(removeNotify);        popupMenu.show(ZooInspectorTreeViewer.this, e.getX(), e.getY());    }}
0
public void refreshView()
{    final Set<TreePath> expandedNodes = new LinkedHashSet<TreePath>();    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {        TreePath path = tree.getPathForRow(i);        if (tree.isExpanded(path)) {            expandedNodes.add(path);        }    }    final TreePath[] selectedNodes = tree.getSelectionPaths();    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));            return true;        }        @Override        protected void done() {            for (TreePath path : expandedNodes) {                tree.expandPath(path);            }            tree.getSelectionModel().setSelectionPaths(selectedNodes);        }    };    worker.execute();}
0
protected Boolean doInBackground() throws Exception
{    tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));    return true;}
0
protected void done()
{    for (TreePath path : expandedNodes) {        tree.expandPath(path);    }    tree.getSelectionModel().setSelectionPaths(selectedNodes);}
0
public void clearView()
{    tree.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));}
0
public Enumeration<TreeNode> children()
{    List<String> children = zooInspectorManager.getChildren(this.nodePath);    Collections.sort(children);    List<TreeNode> returnChildren = new ArrayList<TreeNode>();    for (String child : children) {        returnChildren.add(new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this));    }    return Collections.enumeration(returnChildren);}
0
public boolean getAllowsChildren()
{    return zooInspectorManager.isAllowsChildren(this.nodePath);}
0
public TreeNode getChildAt(int childIndex)
{    String child = zooInspectorManager.getNodeChild(this.nodePath, childIndex);    if (child != null) {        return new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this);    }    return null;}
0
public int getChildCount()
{    return zooInspectorManager.getNumChildren(this.nodePath);}
0
public int getIndex(TreeNode node)
{    return zooInspectorManager.getNodeIndex(this.nodePath);}
0
public TreeNode getParent()
{    return this.parent;}
0
public boolean isLeaf()
{    return !zooInspectorManager.hasChildren(this.nodePath);}
0
public String toString()
{    return this.nodeName;}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + getOuterType().hashCode();    result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());    result = prime * result + ((parent == null) ? 0 : parent.hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorTreeNode other = (ZooInspectorTreeNode) obj;    if (!getOuterType().equals(other.getOuterType()))        return false;    if (nodePath == null) {        if (other.nodePath != null)            return false;    } else if (!nodePath.equals(other.nodePath))        return false;    if (parent == null) {        if (other.parent != null)            return false;    } else if (!parent.equals(other.parent))        return false;    return true;}
0
private ZooInspectorTreeViewer getOuterType()
{    return ZooInspectorTreeViewer.this;}
0
public List<String> getSelectedNodes()
{    TreePath[] paths = tree.getSelectionPaths();    List<String> selectedNodes = new ArrayList<String>();    if (paths != null) {        for (TreePath path : paths) {            StringBuilder sb = new StringBuilder();            Object[] pathArray = path.getPath();            for (Object o : pathArray) {                String nodeName = o.toString();                if (nodeName.length() > 0) {                    sb.append("/");                    sb.append(o.toString());                }            }            selectedNodes.add(sb.toString());        }    }    return selectedNodes;}
0
public void processEvent(String nodePath, String eventType, Map<String, String> eventInfo)
{    StringBuilder sb = new StringBuilder();    sb.append("Node: ");    sb.append(nodePath);    sb.append("\nEvent: ");    sb.append(eventType);    if (eventInfo != null) {        for (Map.Entry<String, String> entry : eventInfo.entrySet()) {            sb.append("\n");            sb.append(entry.getKey());            sb.append(": ");            sb.append(entry.getValue());        }    }    this.toasterManager.showToaster(toasterIcon, sb.toString());}
0
public static org.slf4j.Logger getLogger()
{    return logger;}
0
public List<String> load(String nodePath) throws Exception
{    return getChildren(nodePath);}
0
public List<String> getChildren(String nodePath)
{    try {        Stat s = zooKeeper.exists(nodePath, false);        if (s != null) {            List<String> children = this.zooKeeper.getChildren(nodePath, false);            Collections.sort(children);            return children;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving child of node: " + nodePath, e);    }    return null;}
0
public String getNodeChild(String nodePath, int index)
{    List<String> childNodes = null;    try {        childNodes = nodes.get(nodePath);        return childNodes.get(index);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred retrieving child " + index + "of node: " + nodePath, e);    }    return null;}
0
public K getKey()
{    return key;}
0
public void setKey(K key)
{    this.key = key;}
0
public V getValue()
{    return value;}
0
public void setValue(V value)
{    this.value = value;}
0
public String toString()
{    return "Pair [" + key + ", " + value + "]";}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((key == null) ? 0 : key.hashCode());    result = prime * result + ((value == null) ? 0 : value.hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    Pair<?, ?> other = (Pair<?, ?>) obj;    if (key == null) {        if (other.key != null)            return false;    } else if (!key.equals(other.key))        return false;    if (value == null) {        if (other.value != null)            return false;    } else if (!value.equals(other.value))        return false;    return true;}
0
public boolean connect(Properties connectionProps)
{    try {        if (this.zooKeeper == null) {            String connectString = connectionProps.getProperty(CONNECT_STRING);            String sessionTimeout = connectionProps.getProperty(SESSION_TIMEOUT);            String encryptionManager = connectionProps.getProperty(DATA_ENCRYPTION_MANAGER);            String authScheme = connectionProps.getProperty(AUTH_SCHEME_KEY);            String authData = connectionProps.getProperty(AUTH_DATA_KEY);            if (connectString == null || sessionTimeout == null) {                throw new IllegalArgumentException("Both connect string and session timeout are required.");            }            if (encryptionManager == null) {                this.encryptionManager = new BasicDataEncryptionManager();            } else {                Class<?> clazz = Class.forName(encryptionManager);                if (Arrays.asList(clazz.getInterfaces()).contains(DataEncryptionManager.class)) {                    this.encryptionManager = (DataEncryptionManager) Class.forName(encryptionManager).newInstance();                } else {                    throw new IllegalArgumentException("Data encryption manager must implement DataEncryptionManager interface");                }            }            this.connectString = connectString;            this.sessionTimeout = Integer.valueOf(sessionTimeout);            this.zooKeeper = new ZooKeeperRetry(connectString, Integer.valueOf(sessionTimeout), new Watcher() {                public void process(WatchedEvent event) {                    if (event.getState() == KeeperState.Expired) {                        connected = false;                    }                }            });            if (authData != null && authData.length() > 0) {                this.zooKeeper.addAuthInfo(authScheme, authData.getBytes());            }            ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);            connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();        }    } catch (Exception e) {        connected = false;        e.printStackTrace();    }    if (!connected) {        disconnect();    } else {        this.nodesCache = new NodesCache(zooKeeper);    }    return connected;}
0
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        connected = false;    }}
0
public boolean disconnect()
{    try {        if (this.zooKeeper != null) {            this.zooKeeper.close();            this.zooKeeper = null;            connected = false;            removeWatchers(this.watchers.keySet());            return true;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }    return false;}
0
public List<String> getChildren(String nodePath)
{    if (connected) {        return nodesCache.getChildren(nodePath);    }    return null;}
0
public String getData(String nodePath)
{    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return this.encryptionManager.decryptData(zooKeeper.getData(nodePath, false, s));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting data for node: " + nodePath, e);        }    }    return null;}
0
public String getNodeChild(String nodePath, int childIndex)
{    if (connected) {        return this.nodesCache.getNodeChild(nodePath, childIndex);    }    return null;}
0
public int getNodeIndex(String nodePath)
{    if (connected) {        int index = nodePath.lastIndexOf("/");        if (index == -1 || (!nodePath.equals("/") && nodePath.charAt(nodePath.length() - 1) == '/')) {            throw new IllegalArgumentException("Invalid node path: " + nodePath);        }        String parentPath = nodePath.substring(0, index);        String child = nodePath.substring(index + 1);        if (parentPath != null && parentPath.length() > 0) {            List<String> children = this.nodesCache.getChildren(parentPath);            if (children != null) {                return children.indexOf(child);            }        }    }    return -1;}
0
public List<Map<String, String>> getACLs(String nodePath)
{    List<Map<String, String>> returnACLs = new ArrayList<Map<String, String>>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<ACL> acls = zooKeeper.getACL(nodePath, s);                for (ACL acl : acls) {                    Map<String, String> aclMap = new LinkedHashMap<String, String>();                    aclMap.put(ACL_SCHEME, acl.getId().getScheme());                    aclMap.put(ACL_ID, acl.getId().getId());                    StringBuilder sb = new StringBuilder();                    int perms = acl.getPerms();                    boolean addedPerm = false;                    if ((perms & Perms.READ) == Perms.READ) {                        sb.append("Read");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.WRITE) == Perms.WRITE) {                        sb.append("Write");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.CREATE) == Perms.CREATE) {                        sb.append("Create");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.DELETE) == Perms.DELETE) {                        sb.append("Delete");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.ADMIN) == Perms.ADMIN) {                        sb.append("Admin");                        addedPerm = true;                    }                    aclMap.put(ACL_PERMS, sb.toString());                    returnACLs.add(aclMap);                }            }        } catch (InterruptedException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        } catch (KeeperException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        }    }    return returnACLs;}
0
public Map<String, String> getNodeMeta(String nodePath)
{    Map<String, String> nodeMeta = new LinkedHashMap<String, String>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                nodeMeta.put(A_VERSION, String.valueOf(s.getAversion()));                nodeMeta.put(C_TIME, String.valueOf(s.getCtime()));                nodeMeta.put(C_VERSION, String.valueOf(s.getCversion()));                nodeMeta.put(CZXID, String.valueOf(s.getCzxid()));                nodeMeta.put(DATA_LENGTH, String.valueOf(s.getDataLength()));                nodeMeta.put(EPHEMERAL_OWNER, String.valueOf(s.getEphemeralOwner()));                nodeMeta.put(M_TIME, String.valueOf(s.getMtime()));                nodeMeta.put(MZXID, String.valueOf(s.getMzxid()));                nodeMeta.put(NUM_CHILDREN, String.valueOf(s.getNumChildren()));                nodeMeta.put(PZXID, String.valueOf(s.getPzxid()));                nodeMeta.put(VERSION, String.valueOf(s.getVersion()));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred retrieving meta data for node: " + nodePath, e);        }    }    return nodeMeta;}
0
public int getNumChildren(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getNumChildren();            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting the number of children of node: " + nodePath, e);        }    }    return -1;}
0
public boolean hasChildren(String nodePath)
{    return getNumChildren(nodePath) > 0;}
0
public boolean isAllowsChildren(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getEphemeralOwner() == 0;            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred determining whether node is allowed children: " + nodePath, e);        }    }    return false;}
0
public Map<String, String> getSessionMeta()
{    Map<String, String> sessionMeta = new LinkedHashMap<String, String>();    try {        if (zooKeeper != null) {            sessionMeta.put(SESSION_ID, String.valueOf(zooKeeper.getSessionId()));            sessionMeta.put(SESSION_STATE, String.valueOf(zooKeeper.getState().toString()));            sessionMeta.put(CONNECT_STRING, this.connectString);            sessionMeta.put(SESSION_TIMEOUT, String.valueOf(this.sessionTimeout));        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving session meta data.", e);    }    return sessionMeta;}
0
public boolean createNode(String parent, String nodeName)
{    if (connected) {        try {            String[] nodeElements = nodeName.split("/");            for (String nodeElement : nodeElements) {                String node = parent + "/" + nodeElement;                Stat s = zooKeeper.exists(node, false);                if (s == null) {                    zooKeeper.create(node, this.encryptionManager.encryptData(null), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    parent = node;                }            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred creating node: " + parent + "/" + nodeName, e);        }    }    return false;}
0
public boolean deleteNode(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<String> children = zooKeeper.getChildren(nodePath, false);                for (String child : children) {                    String node = nodePath + "/" + child;                    deleteNode(node);                }                zooKeeper.delete(nodePath, -1);            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred deleting node: " + nodePath, e);        }    }    return false;}
0
public boolean setData(String nodePath, String data)
{    if (connected) {        try {            zooKeeper.setData(nodePath, this.encryptionManager.encryptData(data), -1);            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred setting data for node: " + nodePath, e);        }    }    return false;}
0
public Pair<Map<String, List<String>>, Map<String, String>> getConnectionPropertiesTemplate()
{    Map<String, List<String>> template = new LinkedHashMap<String, List<String>>();    template.put(CONNECT_STRING, Arrays.asList(new String[] { defaultHosts }));    template.put(SESSION_TIMEOUT, Arrays.asList(new String[] { defaultTimeout }));    template.put(DATA_ENCRYPTION_MANAGER, Arrays.asList(new String[] { defaultEncryptionManager }));    template.put(AUTH_SCHEME_KEY, Arrays.asList(new String[] { defaultAuthScheme }));    template.put(AUTH_DATA_KEY, Arrays.asList(new String[] { defaultAuthValue }));    Map<String, String> labels = new LinkedHashMap<String, String>();    labels.put(CONNECT_STRING, "Connect String");    labels.put(SESSION_TIMEOUT, "Session Timeout");    labels.put(DATA_ENCRYPTION_MANAGER, "Data Encryption Manager");    labels.put(AUTH_SCHEME_KEY, "Authentication Scheme");    labels.put(AUTH_DATA_KEY, "Authentication Data");    return new Pair<Map<String, List<String>>, Map<String, String>>(template, labels);}
0
public void addWatchers(Collection<String> selectedNodes, NodeListener nodeListener)
{        if (connected) {        for (String node : selectedNodes) {            if (!watchers.containsKey(node)) {                try {                    watchers.put(node, new NodeWatcher(node, nodeListener, zooKeeper));                } catch (Exception e) {                    LoggerFactory.getLogger().error("Error occurred adding node watcher for node: " + node, e);                }            }        }    }}
0
public void removeWatchers(Collection<String> selectedNodes)
{        if (connected) {        for (String node : selectedNodes) {            if (watchers.containsKey(node)) {                NodeWatcher watcher = watchers.remove(node);                if (watcher != null) {                    watcher.stop();                }            }        }    }}
0
public void process(WatchedEvent event)
{    if (!closed) {        try {            if (event.getType() != EventType.NodeDeleted) {                Stat s = zooKeeper.exists(nodePath, this);                if (s != null) {                    zookeeper.getChildren(nodePath, this);                }            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred re-adding node watcherfor node " + nodePath, e);        }        nodeListener.processEvent(event.getPath(), event.getType().name(), null);    }}
0
public void stop()
{    this.closed = true;}
0
public List<String> loadNodeViewersFile(File selectedFile) throws IOException
{    List<String> result = new ArrayList<String>();    if (defaultNodeViewersFile.exists()) {        FileReader reader = new FileReader(selectedFile);        try {            BufferedReader buff = new BufferedReader(reader);            try {                while (buff.ready()) {                    String line = buff.readLine();                    if (line != null && line.length() > 0 && !line.startsWith("#")) {                        result.add(line);                    }                }            } finally {                buff.close();            }        } finally {            reader.close();        }    }    return result;}
0
private void loadDefaultConnectionFile() throws IOException
{    if (defaultConnectionFile.exists()) {        Properties props = new Properties();        FileReader reader = new FileReader(defaultConnectionFile);        try {            props.load(reader);        } finally {            reader.close();        }        defaultEncryptionManager = props.getProperty(DATA_ENCRYPTION_MANAGER) == null ? "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager" : props.getProperty(DATA_ENCRYPTION_MANAGER);        defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ? "5000" : props.getProperty(SESSION_TIMEOUT);        defaultHosts = props.getProperty(CONNECT_STRING) == null ? "localhost:2181" : props.getProperty(CONNECT_STRING);        defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ? "" : props.getProperty(AUTH_SCHEME_KEY);        defaultAuthValue = props.getProperty(AUTH_DATA_KEY) == null ? "" : props.getProperty(AUTH_DATA_KEY);    } else {        defaultEncryptionManager = "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager";        defaultTimeout = "5000";        defaultHosts = "localhost:2181";        defaultAuthScheme = "";        defaultAuthValue = "";    }}
0
public void saveDefaultConnectionFile(Properties props) throws IOException
{    File defaultDir = defaultConnectionFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    if (!defaultConnectionFile.exists()) {        if (!defaultConnectionFile.createNewFile()) {            throw new IOException("Failed to create default connection file: " + defaultConnectionFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(defaultConnectionFile);    try {        props.store(writer, "Default connection for ZooInspector");    } finally {        writer.close();    }}
0
public void saveNodeViewersFile(File selectedFile, List<String> nodeViewersClassNames) throws IOException
{    if (!selectedFile.exists()) {        if (!selectedFile.createNewFile()) {            throw new IOException("Failed to create node viewers configuration file: " + selectedFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(selectedFile);    try {        BufferedWriter buff = new BufferedWriter(writer);        try {            for (String nodeViewersClassName : nodeViewersClassNames) {                buff.append(nodeViewersClassName);                buff.append("\n");            }        } finally {            buff.flush();            buff.close();        }    } finally {        writer.close();    }}
0
public void setDefaultNodeViewerConfiguration(List<String> nodeViewersClassNames) throws IOException
{    File defaultDir = defaultNodeViewersFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    saveNodeViewersFile(defaultNodeViewersFile, nodeViewersClassNames);}
0
public List<String> getDefaultNodeViewerConfiguration() throws IOException
{    List<String> defaultNodeViewers = loadNodeViewersFile(defaultNodeViewersFile);    if (defaultNodeViewers.isEmpty()) {        LoggerFactory.getLogger().warn("List of default node viewers is empty");    }    return defaultNodeViewers;}
0
public Properties getLastConnectionProps()
{    return this.lastConnectionProps;}
0
public void setLastConnectionProps(Properties connectionProps)
{    this.lastConnectionProps = connectionProps;}
0
public static void main(String[] args)
{    try {        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());        JFrame frame = new JFrame("ZooInspector");        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        iconResource = new IconResource();        final ZooInspectorPanel zooInspectorPanel = new ZooInspectorPanel(new ZooInspectorManagerImpl(), iconResource);        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosed(WindowEvent e) {                super.windowClosed(e);                zooInspectorPanel.disconnect(true);            }        });        frame.setContentPane(zooInspectorPanel);        frame.setSize(1024, 768);        frame.setVisible(true);    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred loading ZooInspector", e);        JOptionPane.showMessageDialog(null, "ZooInspector failed to start: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);    }}
0
public void windowClosed(WindowEvent e)
{    super.windowClosed(e);    zooInspectorPanel.disconnect(true);}
0
public synchronized void close() throws InterruptedException
{    this.closed = true;    super.close();}
0
public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.create(path, data, acl, createMode);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) != null) {                return path;            }        } catch (KeeperException.NodeExistsException e) {            return path;        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public void delete(String path, int version) throws InterruptedException, KeeperException
{    int count = 0;    do {        try {            super.delete(path, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) == null) {                return;            }        } catch (KeeperException.NoNodeException e) {            break;        }    } while (!closed && (limit == -1 || count++ < limit));}
0
public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public List<ACL> getACL(String path, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getACL(path, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
0
public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
0
public byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watch ? watcher : null, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watcher, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public Stat setACL(String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setACL(path, acl, aclVersion);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getACL(path, s).equals(acl)) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public Stat setData(String path, byte[] data, int version) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setData(path, data, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getData(path, false, s) == data) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
0
public void setRetryLimit(int limit)
{    this.limit = limit;}
0
public boolean testConnection()
{    int count = 0;    do {        try {            return super.exists("/", null) != null;        } catch (Exception e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (count++ < 5);    return false;}
0
public static void main(String[] args) throws Exception
{    org.openjdk.jmh.Main.main(args);}
0
 static IWatchManager createWatchManager(String className) throws Exception
{    Class clazz = Class.forName("org.apache.zookeeper.server.watch." + className);    return (IWatchManager) clazz.newInstance();}
0
 static void forceGC()
{    int gcTimes = 3;    for (int i = 0; i < gcTimes; i++) {        try {            System.gc();            Thread.currentThread().sleep(1000);            System.runFinalization();            Thread.currentThread().sleep(1000);        } catch (InterruptedException ex) {        /* ignore */        }    }}
0
 static long getMemoryUse()
{    forceGC();    long totalMem = Runtime.getRuntime().totalMemory();    forceGC();    long freeMem = Runtime.getRuntime().freeMemory();    return totalMem - freeMem;}
0
public void setup() throws Exception
{    paths = new String[pathCount];    for (int i = 0; i < paths.length; i++) {        paths[i] = pathPrefix + i;    }    watchesAdded = 0;    watchManager = createWatchManager(watchManagerClass);    memWhenSetup = getMemoryUse();}
0
public void tearDown()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");}
0
public void testAddConcentrateWatch(IterationState state) throws Exception
{    Watcher watcher = new DumbWatcher();        for (String path : state.paths) {        if (state.watchManager.addWatch(path, watcher)) {            state.watchesAdded++;        }    }}
0
public void setup() throws Exception
{    initialize();    prepare();}
0
 void initialize() throws Exception
{    if (paths == null || paths.length != pathCount) {        paths = new String[pathCount];        for (int i = 0; i < pathCount; i++) {            paths[i] = pathPrefix + i;        }    }    if (watchers == null || watchers.length != watcherCount) {        watchers = new Watcher[watcherCount];        for (int i = 0; i < watcherCount; i++) {            watchers[i] = new DumbWatcher();        }    }    if (watchManager == null || !watchManager.getClass().getSimpleName().contains(watchManagerClass)) {        watchManager = createWatchManager(watchManagerClass);    }}
0
 void prepare()
{    for (String path : paths) {        for (Watcher watcher : watchers) {            watchManager.addWatch(path, watcher);        }    }}
0
public void testTriggerConcentrateWatch(InvocationState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
0
public void prepare()
{    watchesAdded = 0;    memWhenSetup = getMemoryUse();}
0
public void tearDown()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million sparse watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");        for (String path : paths) {        watchManager.triggerWatch(path, event);    }}
0
public void testAddSparseWatch(AddSparseWatchState state) throws Exception
{        for (Watcher watcher : state.watchers) {        if (state.watchManager.addWatch(state.paths[0], watcher)) {            state.watchesAdded++;        }    }        for (String path : state.paths) {        if (state.watchManager.addWatch(path, state.watchers[0])) {            state.watchesAdded++;        }    }}
0
public void prepare()
{        for (Watcher watcher : watchers) {        watchManager.addWatch(paths[0], watcher);    }        for (String path : paths) {        watchManager.addWatch(path, watchers[0]);    }}
0
public void testTriggerSparseWatch(TriggerSparseWatchState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
0
public void setUp() throws Exception
{    if (!fakeMachines) {        zk = new ZooKeeper(zkHostPort, 15000, new Watcher() {            public void process(WatchedEvent e) {            }        });        im = new InstanceManager(zk, prefix);    }}
0
public void process(WatchedEvent e)
{}
0
public void tearDown() throws Exception
{    if (null != im) {        im.close();    }}
0
public String getHostPort()
{    return serverHostPort;}
0
public int getServerCount()
{    return serverCount;}
0
public int getClientCount()
{    return clientCount;}
0
public void startServers() throws IOException
{    for (int i = 0; i < serverCount; i++) {        startServer(i);    }}
0
public void stopServers() throws IOException
{    for (int i = 0; i < serverCount; i++) {        stopServer(i);    }}
0
public void startClients() throws IOException
{    for (int i = 0; i < clientCount; i++) {        startClient(i);    }}
0
public void stopClients() throws IOException
{    for (int i = 0; i < clientCount; i++) {        stopClient(i);    }}
0
public void configureServers(int count) throws Exception
{    serverCount = count;    if (fakeMachines) {        fakeConfigureServers(count);    } else {        distributedConfigureServers(count);    }}
0
private void distributedConfigureServers(int count) throws IOException
{    StringBuilder sbClient = new StringBuilder();    StringBuilder sbServer = new StringBuilder();    try {        for (int i = 0; i < count; i++) {            String[] r = QuorumPeerInstance.createServer(im, i);            if (i > 0) {                sbClient.append(',');                sbServer.append(',');            }                        sbClient.append(r[0]);                        sbServer.append(r[1]);                        sbServer.append(";" + (r[0].split(":"))[1]);        }        serverHostPort = sbClient.toString();        quorumHostPort = sbServer.toString();    } catch (Exception e) {        IOException ioe = new IOException(e.getMessage());        ioe.setStackTrace(e.getStackTrace());        throw ioe;    }}
0
private void fakeConfigureServers(int count) throws IOException
{    peers = new HashMap<Long, QuorumServer>();    qps = new QuorumPeer[count];    qpsDirs = new File[count];    for (int i = 1; i <= count; i++) {        InetSocketAddress peerAddress = new InetSocketAddress("127.0.0.1", fakeBasePort + i);        InetSocketAddress electionAddr = new InetSocketAddress("127.0.0.1", serverCount + fakeBasePort + i);        peers.put(Long.valueOf(i), new QuorumServer(i, peerAddress, electionAddr));    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i < count; i++) {                testData.mkdirs();        qpsDirs[i] = File.createTempFile("sysTest", ".tmp", testData);        qpsDirs[i].delete();        qpsDirs[i].mkdir();        int port = fakeBasePort + 10 + i;        if (sb.length() > 0) {            sb.append(',');        }        sb.append("localhost:");        sb.append(port);    }    serverHostPort = sb.toString();}
0
public void startServer(int index) throws IOException
{    int port = fakeBasePort + 10 + index;    if (fakeMachines) {        qps[index] = new QuorumPeer(peers, qpsDirs[index], qpsDirs[index], port, 3, index + 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);        qps[index].start();    } else {        try {            QuorumPeerInstance.startInstance(im, quorumHostPort, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getClass().getName() + ": " + e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
0
public void stopServer(int index) throws IOException
{    if (fakeMachines) {        qps[index].shutdown();    } else {        try {            QuorumPeerInstance.stopInstance(im, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
0
public void configureClients(int count, Class<? extends Instance> clazz, String params) throws Exception
{    clientCount = count;    if (fakeMachines) {        fakeConfigureClients(count, clazz, params);    } else {        distributedConfigureClients(count, clazz, params);    }}
0
private void distributedConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException
{    this.clazz = clazz;    this.params = params;}
0
private void fakeConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException, ClassNotFoundException
{    fakeBaseClients = new Instance[count];    for (int i = 0; i < count; i++) {        try {            fakeBaseClients[i] = clazz.newInstance();        } catch (InstantiationException e) {            e.printStackTrace();            return;        } catch (IllegalAccessException e) {            e.printStackTrace();            return;        }        fakeBaseClients[i].configure(i + " " + params);    }}
0
public void startClient(int index) throws IOException
{    if (fakeMachines) {        fakeStartClient(index);    } else {        distributedStartClient(index);    }}
0
private void distributedStartClient(int index) throws IOException
{    try {        im.assignInstance("client" + index, clazz, index + " " + params, 1);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
0
private void fakeStartClient(int index)
{    fakeBaseClients[index].start();}
0
public void stopClient(int index) throws IOException
{    if (fakeMachines) {        fakeStopClient(index);    } else {        distributedStopClient(index);    }}
0
private void distributedStopClient(int index) throws IOException
{    try {        im.removeInstance("client" + index);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
0
private void fakeStopClient(int index)
{    fakeBaseClients[index].stop();}
0
public static void main(String[] args)
{    JUnitCore.main(args);}
0
 static synchronized void add(long time, int count, Socket s)
{    long interval = time / INTERVAL;    if (currentInterval == 0 || currentInterval > interval) {        System.out.println("Dropping " + count + " for " + new Date(time) + " " + currentInterval + ">" + interval);        return;    }        Long total = totalByTime.get(interval);    if (total == null) {        totalByTime.put(interval, (long) count);    } else {        totalByTime.put(interval, total.longValue() + count);    }    tf.println(interval + " " + count + " " + s);}
0
 static synchronized long remove(long interval)
{    Long total = totalByTime.remove(interval);    return total == null ? -1 : total;}
0
public void run()
{    try {        System.out.println("Connected to " + s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String result;        while ((result = is.readLine()) != null) {            String[] timePercentCount = result.split(" ");            if (timePercentCount.length != 5) {                System.err.println("Got " + result + " from " + s + " exitng.");                throw new IOException(result);            }            long time = Long.parseLong(timePercentCount[0]);                        int count = Integer.parseInt(timePercentCount[2]);            int errs = Integer.parseInt(timePercentCount[3]);            if (errs > 0) {                System.out.println(s + " Got an error! " + errs);            }            add(time, count, s);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        close();    }}
0
 void send(int percentage)
{    try {        s.getOutputStream().write((percentage + "\n").getBytes());    } catch (IOException e) {        e.printStackTrace();    }}
0
 void close()
{    try {        System.err.println("Closing " + s);        slaves.remove(this);        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void run()
{    try {        while (true) {            Socket s = ss.accept();            System.err.println("Accepted connection from " + s);            slaves.add(new SlaveThread(s));        }    } catch (IOException e) {        e.printStackTrace();    } finally {        for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext(); ) {            SlaveThread st = it.next();            it.remove();            st.close();        }    }}
0
public void run()
{    try {        currentInterval = Time.currentElapsedTime() / INTERVAL;                Thread.sleep(INTERVAL * 2);        long min = 99999;        long max = 0;        long total = 0;        int number = 0;        while (true) {            long now = Time.currentElapsedTime();            long lastInterval = currentInterval;            currentInterval += 1;            long count = remove(lastInterval);                        count = count * 1000 / INTERVAL;                        if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {                if (count < min) {                    min = count;                }                if (count > max) {                    max = count;                }                total += count;                number++;                Calendar calendar = Calendar.getInstance();                calendar.setTimeInMillis(lastInterval * INTERVAL);                String report = lastInterval + " " + calendar.get(Calendar.HOUR_OF_DAY) + ":" + calendar.get(Calendar.MINUTE) + ":" + calendar.get(Calendar.SECOND) + " " + percentage + "% " + count + " " + min + " " + ((double) total / (double) number) + " " + max;                System.err.println(report);                if (sf != null) {                    sf.println(report);                }            } else {                max = total = 0;                min = 999999999;                number = 0;            }            Thread.sleep(INTERVAL);        }    } catch (Exception e) {        e.printStackTrace();    }}
0
 static synchronized void sendChange(int percentage)
{    long now = Time.currentElapsedTime();    long start = now;    ReporterThread.percentage = percentage;    for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {        st.send(percentage);    }    now = Time.currentElapsedTime();    long delay = now - start;    if (delay > 1000) {        System.out.println("Delay of " + delay + " to send new percentage");    }    lastChange = now;}
0
 synchronized void incOutstanding() throws InterruptedException
{    outstanding++;    while (outstanding > outstandingLimit) {        wait();    }}
0
 synchronized void decOutstanding()
{    outstanding--;    notifyAll();}
0
public void run()
{    try {        zk = new ZooKeeper(host, 60000, this);        synchronized (this) {            if (!connected) {                wait(20000);            }        }        for (int i = 0; i < 300; i++) {            try {                Thread.sleep(100);                path = zk.create("/client", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);                break;            } catch (KeeperException e) {                            }        }        if (path == null) {            System.err.println("Couldn't create a node in /!");            return;        }        while (alive) {            if (r.nextInt(100) < percentage) {                zk.setData(path, bytes, -1, this, System.currentTimeMillis());            } else {                zk.getData(path, false, this, System.currentTimeMillis());            }            incOutstanding();        }    } catch (Exception e) {        e.printStackTrace();    } finally {        alive = false;        try {            zk.close();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
1
public void process(WatchedEvent event)
{    System.err.println(event);    synchronized (this) {        if (event.getType() == EventType.None) {            connected = (event.getState() == KeeperState.SyncConnected);            notifyAll();        }    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (!alive) {            return;        }        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            rlatency += Time.currentElapsedTime() - (Long) ctx;            reads++;        }    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            wlatency += Time.currentElapsedTime() - (Long) ctx;            writes++;        }    }}
0
public void run()
{    try {        OutputStream os = s.getOutputStream();        finished = 0;        errors = 0;        while (alive) {            Thread.sleep(300);            if (percentage == -1 || (finished == 0 && errors == 0)) {                continue;            }            String report = Time.currentElapsedTime() + " " + percentage + " " + finished + " " + errors + " " + outstanding + "\n";            /* String subreport = reads + " "                                + (((double) rlatency) / reads) + " " + writes                                + " " + (((double) wlatency / writes)); */            synchronized (statSync) {                finished = 0;                errors = 0;                reads = 0;                writes = 0;                rlatency = 0;                wlatency = 0;            }            os.write(report.getBytes());                }    } catch (Exception e) {        e.printStackTrace();    }}
0
public void configure(final String params)
{    System.err.println("Got " + params);    new Thread() {        public void run() {            try {                String[] parts = params.split(" ");                String[] hostPort = parts[1].split(":");                int bytesSize = 1024;                if (parts.length == 3) {                    try {                        bytesSize = Integer.parseInt(parts[2]);                    } catch (Exception e) {                        System.err.println("Not an integer: " + parts[2]);                    }                }                bytes = new byte[bytesSize];                s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));                zkThread = new ZooKeeperThread(parts[0]);                sendThread = new SenderThread(s);                BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));                String line;                while ((line = is.readLine()) != null) {                    percentage = Integer.parseInt(line);                }            } catch (Exception e) {                e.printStackTrace();            }        }    }.start();}
0
public void run()
{    try {        String[] parts = params.split(" ");        String[] hostPort = parts[1].split(":");        int bytesSize = 1024;        if (parts.length == 3) {            try {                bytesSize = Integer.parseInt(parts[2]);            } catch (Exception e) {                System.err.println("Not an integer: " + parts[2]);            }        }        bytes = new byte[bytesSize];        s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));        zkThread = new ZooKeeperThread(parts[0]);        sendThread = new SenderThread(s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String line;        while ((line = is.readLine()) != null) {            percentage = Integer.parseInt(line);        }    } catch (Exception e) {        e.printStackTrace();    }}
0
public void setReporter(Reporter r)
{    this.r = r;}
0
public void start()
{    try {        r.report("started");    } catch (Exception e) {        e.printStackTrace();    }}
0
public void stop()
{    alive = false;    zkThread.interrupt();    sendThread.interrupt();    try {        zkThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        sendThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        r.report("stopped");    } catch (Exception e) {        e.printStackTrace();    }    try {        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void process(WatchedEvent event)
{    if (event.getType() == Watcher.Event.EventType.None) {        synchronized (this) {            connected = event.getState() == Watcher.Event.KeeperState.SyncConnected;            notifyAll();        }    }}
0
public synchronized boolean waitConnected(long timeout) throws InterruptedException
{    long endTime = Time.currentElapsedTime() + timeout;    while (!connected && Time.currentElapsedTime() < endTime) {        wait(endTime - Time.currentElapsedTime());    }    return connected;}
0
private static String[] processOptions(String[] args)
{    ArrayList<String> newArgs = new ArrayList<String>();    for (String a : args) {        if (a.equals("--leaderOnly")) {            leaderOnly = true;            leaderServes = true;        } else if (a.equals("--leaderServes")) {            leaderServes = true;        } else {            newArgs.add(a);        }    }    return newArgs.toArray(new String[0]);}
0
public static void main(String[] args) throws InterruptedException, KeeperException, NoAvailableContainers, DuplicateNameException, NoAssignmentException
{    args = processOptions(args);    if (args.length == 5) {        try {            StatusWatcher statusWatcher = new StatusWatcher();            ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);            if (!statusWatcher.waitConnected(5000)) {                System.err.println("Could not connect to " + args[0]);                return;            }            InstanceManager im = new InstanceManager(zk, args[1]);            ss = new ServerSocket(0);            int port = ss.getLocalPort();            int serverCount = Integer.parseInt(args[2]);            int clientCount = Integer.parseInt(args[3]);            StringBuilder quorumHostPort = new StringBuilder();            StringBuilder zkHostPort = new StringBuilder();            for (int i = 0; i < serverCount; i++) {                String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);                if (i > 0) {                    quorumHostPort.append(',');                    zkHostPort.append(',');                }                                zkHostPort.append(r[0]);                                quorumHostPort.append(r[1]);                                quorumHostPort.append(";" + (r[0].split(":"))[1]);            }            for (int i = 0; i < serverCount; i++) {                QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);            }            if (leaderOnly) {                int tries = 0;                outer: while (true) {                    Thread.sleep(1000);                    IOException lastException = null;                    String[] parts = zkHostPort.toString().split(",");                    for (int i = 0; i < parts.length; i++) {                        try {                            String mode = getMode(parts[i]);                            if (mode.equals("leader")) {                                zkHostPort = new StringBuilder(parts[i]);                                System.out.println("Connecting exclusively to " + zkHostPort.toString());                                break outer;                            }                        } catch (IOException e) {                            lastException = e;                        }                    }                    if (tries++ > 3) {                        throw lastException;                    }                }            }            for (int i = 0; i < clientCount; i++) {                im.assignInstance("client" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);            }            new AcceptorThread();            new ReporterThread();            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = is.readLine()) != null) {                try {                    String[] cmdNumber = line.split(" ");                    if (cmdNumber[0].equals("percentage") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        if (number < 0 || number > 100) {                            throw new NumberFormatException("must be between 0 and 100");                        }                        sendChange(number);                    } else if (cmdNumber[0].equals("sleep") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        Thread.sleep(number * 1000);                    } else if (cmdNumber[0].equals("save") && cmdNumber.length > 1) {                        sf = new PrintStream(cmdNumber[1]);                    } else {                        System.err.println("Commands must be:");                        System.err.println("\tpercentage new_write_percentage");                        System.err.println("\tsleep seconds_to_sleep");                        System.err.println("\tsave file_to_save_output");                    }                } catch (NumberFormatException e) {                    System.out.println("Not a valid number: " + e.getMessage());                }            }        } catch (NumberFormatException e) {            doUsage();        } catch (IOException e) {            e.printStackTrace();            System.exit(ExitCode.INVALID_INVOCATION.getValue());        }    } else {        doUsage();    }}
0
private static String getMode(String hostPort) throws NumberFormatException, UnknownHostException, IOException
{    String[] parts = hostPort.split(":");    Socket s = new Socket(parts[0], Integer.parseInt(parts[1]));    s.getOutputStream().write("stat".getBytes());    BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));    String line;    try {        while ((line = br.readLine()) != null) {            if (line.startsWith("Mode: ")) {                return line.substring(6);            }        }        return "unknown";    } finally {        s.close();    }}
0
private static void doUsage()
{    System.err.println("USAGE: " + GenerateLoad.class.getName() + " [--leaderOnly] [--leaderServes] zookeeper_host:port containerPrefix #ofServers #ofClients requestSize");    System.exit(ExitCode.INVALID_INVOCATION.getValue());}
0
public void process(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals(myNode)) {        zk.getData(myNode, this, dc, this);    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                return;    }    if (rc != KeeperException.Code.OK.intValue()) {        zk.getData(myNode, (Watcher) ctx, this, ctx);    }    int currVer = stat.getVersion();    if (currVer != lastVer) {        String[] parts = new String(data).split(" ", 2);        myInstance.configure(parts[1]);        lastVer = currVer;    }}
0
public void report(String report) throws KeeperException, InterruptedException
{    for (int j = 0; j < maxTries; j++) {        try {            try {                zk.setData(myReportNode, report.getBytes(), -1);            } catch (NoNodeException e) {                zk.create(myReportNode, report.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            }            break;        } catch (ConnectionLossException e) {        }    }}
0
private void rmnod(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            lastException = null;            break;        } catch (KeeperException.NoNodeException e) {                        break;        } catch (KeeperException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
0
private void mknod_inner(String path, CreateMode mode) throws KeeperException, InterruptedException
{    for (int i = 0; i < maxTries; i++) {        try {            zk.create(path, null, Ids.OPEN_ACL_UNSAFE, mode);            break;        } catch (NodeExistsException e) {            if (mode != CreateMode.EPHEMERAL) {                return;            }            Stat stat = zk.exists(path, false);            if (stat == null) {                continue;            }            if (stat.getEphemeralOwner() != zk.getSessionId()) {                throw e;            }            break;        } catch (ConnectionLossException e) {            e.printStackTrace();        }    }}
0
private void mknod(String path, CreateMode mode) throws KeeperException, InterruptedException
{    String[] subpath = path.split("/");    StringBuilder sb = new StringBuilder();        for (int i = 1; i < subpath.length; i++) {        sb.append("/");        sb.append(subpath[i]);        CreateMode m = CreateMode.PERSISTENT;        if (i == subpath.length - 1) {            m = mode;        }        mknod_inner(sb.toString(), m);    }}
0
public void run() throws IOException, InterruptedException, KeeperException
{    zk = new ZooKeeper(zkHostPort, sessTimeout, this);    mknod(assignmentsNode, CreateMode.PERSISTENT);    mknod(statusNode, CreateMode.EPHEMERAL);    mknod(reportsNode, CreateMode.PERSISTENT);        zk.getChildren(assignmentsNode, true, this, null);}
0
public static void main(String[] args) throws UnknownHostException, IOException, InterruptedException, KeeperException
{    if (args.length != 3) {        System.err.println("USAGE: " + InstanceContainer.class.getName() + " name zkHostPort znodePrefix");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new InstanceContainer(args[0], args[1], args[2]).run();    while (true) {        Thread.sleep(1000);    }}
0
public void process(WatchedEvent event)
{    if (KeeperState.Expired == event.getState()) {                        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    }    if (event.getPath() != null && event.getPath().equals(assignmentsNode)) {                zk.getChildren(assignmentsNode, true, this, null);    }}
1
public void processResult(int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {                zk.getChildren(assignmentsNode, true, this, null);        return;    }    Map<String, Instance> newList = new HashMap<String, Instance>();        Stat stat = new Stat();    for (String child : children) {        Instance i = instances.remove(child);        if (i == null) {                        byte[] data = null;            String myNode = assignmentsNode + '/' + child;            while (true) {                try {                    data = zk.getData(myNode, true, stat);                    break;                } catch (NoNodeException e) {                                        break;                } catch (KeeperException e) {                    e.printStackTrace();                } catch (InterruptedException e) {                    return;                }            }            if (data != null) {                String instanceSpec = new String(data);                int spaceIndex = instanceSpec.indexOf(' ');                String clazz;                String conf;                if (spaceIndex == -1) {                    clazz = instanceSpec;                    conf = null;                } else {                    clazz = instanceSpec.substring(0, spaceIndex);                    conf = instanceSpec.substring(spaceIndex + 1);                }                try {                    Class<?> c = Class.forName(clazz);                    i = (Instance) c.newInstance();                    Reporter reporter = new MyReporter(child);                    i.setReporter(reporter);                    i.configure(conf);                    i.start();                    newList.put(child, i);                    int ver = stat.getVersion();                    Instance myInstance = i;                    DataCallback dc = new MyDataCallback(myNode, myInstance, ver);                    Watcher watcher = new MyWatcher(myNode, dc);                    zk.getData(myNode, watcher, dc, watcher);                } catch (Exception e) {                                        if (e.getCause() != null) {                                            }                }            }        } else {                        newList.put(child, i);        }    }        for (Map.Entry<String, Instance> i : instances.entrySet()) {        i.getValue().stop();        try {            rmnod(reportsNode + '/' + i.getKey());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        } catch (KeeperException e) {            e.printStackTrace();        }    }    instances = newList;}
1
private void setupNodes(ZooKeeper zk) throws KeeperException, InterruptedException
{    try {        zk.create(prefixNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(assignmentsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(statusNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(reportsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(readyNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }}
0
public synchronized void processResult(int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {        zk.getChildren(statusNode, this, this, null);        return;    }    if (LOG.isDebugEnabled()) {            }    Map<String, HashSet<Assigned>> newAssignments = new HashMap<String, HashSet<Assigned>>();    for (String c : children) {        HashSet<Assigned> a = assignments.remove(c);        if (a != null) {            newAssignments.put(c, a);        } else {            newAssignments.put(c, new HashSet<Assigned>());        }    }        for (String dead : assignments.keySet()) {        try {            removeInstance(dead);        } catch (KeeperException e) {            e.printStackTrace();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    assignments = newAssignments;}
1
public void process(WatchedEvent event)
{    if (event.getPath().equals(statusNode)) {        zk.getChildren(statusNode, this, this, null);    }}
0
public synchronized String assignInstance(String name, Class<? extends Instance> clazz, String params, int weight) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    if (weight < 1) {                weight = 1;    }    String instanceSpec = clazz.getName() + ' ' + params;    if (instanceToAssignment.get(name) != null) {        throw new DuplicateNameException(name + " already exists");    }        String mostIdle = null;    int mostIdleWeight = Integer.MAX_VALUE;    for (String preferred : preferredList) {        HashSet<Assigned> assignmentList = assignments.get(preferred);        int w = 0;        if (assignmentList != null) {            for (Assigned a : assignmentList) {                w += a.weight;            }            if (w < mostIdleWeight) {                mostIdleWeight = w;                mostIdle = preferred;            }        }    }    for (Entry<String, HashSet<Assigned>> e : assignments.entrySet()) {        int w = 0;        for (Assigned a : e.getValue()) {            w += a.weight;        }        if (w < mostIdleWeight) {            mostIdleWeight = w;            mostIdle = e.getKey();        }    }    if (mostIdle == null) {        throw new NoAvailableContainers("No available containers");    }    Assigned a = new Assigned(mostIdle, weight);    instanceToAssignment.put(name, a);    HashSet<Assigned> as = assignments.get(mostIdle);    if (as == null) {        as = new HashSet<Assigned>();        assignments.put(mostIdle, as);    }    as.add(a);    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.create(assignmentsNode + '/' + mostIdle + '/' + name, instanceSpec.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            return mostIdle;        } catch (NodeExistsException e) {            return mostIdle;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
0
public void reconfigureInstance(String name, String params) throws NoAssignmentException, InterruptedException, KeeperException
{    if (LOG.isDebugEnabled()) {            }    Assigned assigned = instanceToAssignment.get(name);    if (assigned == null) {        throw new NoAssignmentException();    }    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, ("update " + params).getBytes(), -1);            break;        } catch (ConnectionLossException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
1
private void doDelete(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            return;        } catch (NoNodeException e) {            return;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
0
public synchronized void removeInstance(String name) throws InterruptedException, KeeperException
{    Assigned assigned = instanceToAssignment.remove(name);    if (assigned == null) {        return;    }    assignments.get(assigned.container).remove(name);    doDelete(assignmentsNode + '/' + assigned.container + '/' + name);    doDelete(reportsNode + '/' + name);}
0
 synchronized boolean isAlive(String name)
{    return instanceToAssignment.get(name) != null;}
0
public void resetStatus(String name) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(reportsNode + '/' + name, -1);            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {                }    }    if (lastException != null) {        throw lastException;    }}
0
public String getStatus(String name, long timeout) throws KeeperException, InterruptedException
{    Stat stat = new Stat();    byte[] data = null;    long endTime = Time.currentElapsedTime() + timeout;    KeeperException lastException = null;    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {        try {            data = zk.getData(reportsNode + '/' + name, false, stat);            if (LOG.isDebugEnabled()) {                            }            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {            final Object eventObj = new Object();            synchronized (eventObj) {                                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {                    public void process(WatchedEvent event) {                        synchronized (eventObj) {                            eventObj.notifyAll();                        }                    }                });                if (eStat == null) {                    eventObj.wait(endTime - Time.currentElapsedTime());                }            }            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }    return new String(data);}
1
public void process(WatchedEvent event)
{    synchronized (eventObj) {        eventObj.notifyAll();    }}
0
public synchronized void close() throws InterruptedException
{    for (String name : instanceToAssignment.keySet().toArray(new String[0])) {        try {            removeInstance(name);        } catch (KeeperException e) {            e.printStackTrace();        }    }    try {        doDelete(readyNode);    } catch (KeeperException e) {        e.printStackTrace();    }}
0
public void setReporter(Reporter r)
{    this.r = r;}
0
public void configure(String params)
{    if (clientAddr == null) {        String[] parts = params.split(" ");                        serverId = Integer.parseInt(parts[0]);        if (LOG.isDebugEnabled()) {                    }        if (parts.length > 1 && parts[1].equals("false")) {            System.setProperty("zookeeper.leaderServes", "no");        } else {            System.setProperty("zookeeper.leaderServes", "yes");        }                try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();        try {            if (LOG.isDebugEnabled()) {                            }            r.report(report);        } catch (Exception e) {            e.printStackTrace();        }        return;    } else {        int spaceIndex = params.indexOf(' ');        if (spaceIndex == -1) {                        return;        }        String quorumSpecs = params.substring(0, spaceIndex);        String cmd = params.substring(spaceIndex + 1);        if (LOG.isDebugEnabled()) {                    }        if (!cmd.equals("start")) {            if (peer != null) {                peer.shutdown();            }            peer = null;            try {                for (int i = 0; i < 5; i++) {                    Thread.sleep(500);                    try {                                                new Socket("127.0.0.1", clientAddr.getPort()).close();                    } catch (IOException e) {                        break;                    }                }                r.report("stopped");            } catch (Exception e) {                            }            return;        }        String[] parts = quorumSpecs.split(",");        peers = new HashMap<Long, QuorumServer>();        for (int i = 0; i < parts.length; i++) {                        String[] subparts = ((parts[i].split(";"))[0]).split(":");            String clientPort = (parts[i].split(";"))[1];            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));        }        try {            if (LOG.isDebugEnabled()) {                            }            if (peer != null) {                                return;            }            System.err.println("SnapDir = " + snapDir + " LogDir = " + logDir);            peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            peer.start();            for (int i = 0; i < 5; i++) {                Thread.sleep(500);                try {                                        new Socket("127.0.0.1", clientAddr.getPort()).close();                    break;                } catch (IOException e) {                }            }            r.report("started");        } catch (Exception e) {                    }    }}
1
public void start()
{}
0
public void stop()
{    if (LOG.isDebugEnabled()) {            }    if (peer != null) {        peer.shutdown();    }    if (logDir != null) {        TestUtils.deleteFileRecursively(logDir);    }    if (snapDir != null) {        TestUtils.deleteFileRecursively(snapDir);    }}
1
public static String[] createServer(InstanceManager im, int i) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    return createServer(im, i, true);}
0
public static String[] createServer(InstanceManager im, int i, boolean leaderServes) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    im.assignInstance("server" + i, QuorumPeerInstance.class, Integer.toString(i) + " " + leaderServes, 50);    return im.getStatus("server" + i, 3000).split(",");}
0
public static void startInstance(InstanceManager im, String quorumHostPort, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, quorumHostPort + " start");    im.getStatus("server" + index, 5000);}
0
public static void stopInstance(InstanceManager im, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, Integer.toString(index) + " stop");    im.getStatus("server" + index, 3000);}
0
public void configure(String params)
{    String[] parts = params.split(" ");    hostPort = parts[1];    this.index = Integer.parseInt(parts[0]);    myPath = "/simpleCase/" + index;}
0
public void start()
{    try {        zk = new ZooKeeper(hostPort, 15000, this);        zk.getData("/simpleCase", true, this, null);        if (null != r) {            r.report("Client " + index + " connecting to " + hostPort);        }    } catch (Exception e) {        e.printStackTrace();    }}
0
public void stop()
{    try {        if (zk != null) {            zk.close();        }    } catch (InterruptedException e) {        e.printStackTrace();    }}
0
public void process(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals("/simpleCase")) {        zk.getData("/simpleCase", true, this, null);    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc != 0) {        zk.getData("/simpleCase", true, this, null);    } else {        this.data = data;        String content = new String(data);        if (content.equals("die")) {            this.stop();            return;        }        if (!createdEphemeral) {            zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);            createdEphemeral = true;        } else {            zk.setData(myPath, data, -1, this, null);        }    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    if (rc != 0) {        zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc != 0) {        zk.setData(myPath, data, -1, this, null);    }}
0
public String toString()
{    return SimpleClient.class.getName() + "[" + index + "] using " + hostPort;}
0
public void setReporter(Reporter r)
{    this.r = r;}
0
private synchronized boolean waitForConnect(ZooKeeper zk, long timeout) throws InterruptedException
{    connected = (zk.getState() == States.CONNECTED);    long end = Time.currentElapsedTime() + timeout;    while (!connected && end > Time.currentElapsedTime()) {        wait(timeout);        connected = (zk.getState() == States.CONNECTED);    }    return connected;}
0
public void testSimpleCase() throws Exception
{    configureServers(serverCount);    configureClients(clientCount, SimpleClient.class, getHostPort());    Stat stat = new Stat();    startServers();        ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);    waitForConnect(zk, 10000);    zk.create("/simpleCase", "orig".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    startClients();        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            try {                byte[] b = zk.getData("/simpleCase/" + i, false, stat);                Assert.assertEquals("orig", new String(b));            } catch (NoNodeException e) {                if (j + 1 == maxTries) {                    Assert.fail("Max tries exceeded on client " + i);                }                Thread.sleep(1000);            }        }    }        for (int i = 0; i < getServerCount(); i++) {        stopServer(i);        if (i + 1 > getServerCount() / 2) {            startServer(i);        } else if (i + 1 == getServerCount() / 2) {            Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));            try {                zk.setData("/simpleCase", "new".getBytes(), -1);            } catch (ConnectionLossException e) {                Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));                zk.setData("/simpleCase", "new".getBytes(), -1);            }            for (int j = 0; j < i; j++) {                                startServer(i);            }        }    }        Thread.sleep(100);    Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    try {        zk.getData("/simpleCase", false, stat);    } catch (ConnectionLossException e) {        Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    }        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            byte[] data = zk.getData("/simpleCase/" + i, false, stat);            if (new String(data).equals("new")) {                break;            }            if (j + 1 == maxTries) {                Assert.fail("max tries exceeded for " + i);            }            Thread.sleep(1000);        }    }        zk.setData("/simpleCase", "die".getBytes(), -1);        for (int i = 0; i < getClientCount(); i++) {        try {            for (int j = 0; j < maxTries; j++) {                zk.getData("/simpleCase/" + i, false, stat);                if (j + 1 == maxTries) {                    Assert.fail("max tries exceeded waiting for child " + i + " to die");                }                Thread.sleep(200);            }        } catch (NoNodeException e) {                }    }    stopClients();    stopServers();}
1
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        synchronized (this) {            connected = true;            notifyAll();        }    } else if (event.getState() == KeeperState.Disconnected) {        synchronized (this) {            connected = false;            notifyAll();        }    }}
0
public static BinaryInputArchive getArchive(InputStream strm)
{    return new BinaryInputArchive(new DataInputStream(strm));}
0
public boolean done()
{    return (nelems <= 0);}
0
public void incr()
{    nelems--;}
0
public byte readByte(String tag) throws IOException
{    return in.readByte();}
0
public boolean readBool(String tag) throws IOException
{    return in.readBoolean();}
0
public int readInt(String tag) throws IOException
{    return in.readInt();}
0
public long readLong(String tag) throws IOException
{    return in.readLong();}
0
public float readFloat(String tag) throws IOException
{    return in.readFloat();}
0
public double readDouble(String tag) throws IOException
{    return in.readDouble();}
0
public String readString(String tag) throws IOException
{    int len = in.readInt();    if (len == -1) {        return null;    }    checkLength(len);    byte[] b = new byte[len];    in.readFully(b);    return new String(b, StandardCharsets.UTF_8);}
0
public byte[] readBuffer(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    checkLength(len);    byte[] arr = new byte[len];    in.readFully(arr);    return arr;}
0
public void readRecord(Record r, String tag) throws IOException
{    r.deserialize(this, tag);}
0
public void startRecord(String tag) throws IOException
{}
0
public void endRecord(String tag) throws IOException
{}
0
public Index startVector(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    return new BinaryIndex(len);}
0
public void endVector(String tag) throws IOException
{}
0
public Index startMap(String tag) throws IOException
{    return new BinaryIndex(readInt(tag));}
0
public void endMap(String tag) throws IOException
{}
0
private void checkLength(int len) throws IOException
{    if (len < 0 || len > maxBufferSize + extraMaxBufferSize) {        throw new IOException(UNREASONBLE_LENGTH + len);    }}
0
public static BinaryOutputArchive getArchive(OutputStream strm)
{    return new BinaryOutputArchive(new DataOutputStream(strm));}
0
public void writeByte(byte b, String tag) throws IOException
{    out.writeByte(b);}
0
public void writeBool(boolean b, String tag) throws IOException
{    out.writeBoolean(b);}
0
public void writeInt(int i, String tag) throws IOException
{    out.writeInt(i);}
0
public void writeLong(long l, String tag) throws IOException
{    out.writeLong(l);}
0
public void writeFloat(float f, String tag) throws IOException
{    out.writeFloat(f);}
0
public void writeDouble(double d, String tag) throws IOException
{    out.writeDouble(d);}
0
private ByteBuffer stringToByteBuffer(CharSequence s)
{    bb.clear();    final int len = s.length();    for (int i = 0; i < len; i++) {        if (bb.remaining() < 3) {            ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);            bb.flip();            n.put(bb);            bb = n;        }        char c = s.charAt(i);        if (c < 0x80) {            bb.put((byte) c);        } else if (c < 0x800) {            bb.put((byte) (0xc0 | (c >> 6)));            bb.put((byte) (0x80 | (c & 0x3f)));        } else {            bb.put((byte) (0xe0 | (c >> 12)));            bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));            bb.put((byte) (0x80 | (c & 0x3f)));        }    }    bb.flip();    return bb;}
0
public void writeString(String s, String tag) throws IOException
{    if (s == null) {        writeInt(-1, "len");        return;    }    ByteBuffer bb = stringToByteBuffer(s);    writeInt(bb.remaining(), "len");    out.write(bb.array(), bb.position(), bb.limit());}
0
public void writeBuffer(byte[] barr, String tag) throws IOException
{    if (barr == null) {        out.writeInt(-1);        return;    }    out.writeInt(barr.length);    out.write(barr);}
0
public void writeRecord(Record r, String tag) throws IOException
{    r.serialize(this, tag);}
0
public void startRecord(Record r, String tag) throws IOException
{}
0
public void endRecord(Record r, String tag) throws IOException
{}
0
public void startVector(List<?> v, String tag) throws IOException
{    if (v == null) {        writeInt(-1, tag);        return;    }    writeInt(v.size(), tag);}
0
public void endVector(List<?> v, String tag) throws IOException
{}
0
public void startMap(TreeMap<?, ?> v, String tag) throws IOException
{    writeInt(v.size(), tag);}
0
public void endMap(TreeMap<?, ?> v, String tag) throws IOException
{}
0
 void genCode() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter c = new FileWriter(new File(outputDirectory, mName + ".c"));        FileWriter h = new FileWriter(new File(outputDirectory, mName + ".h"))) {        h.write("/**\n");        h.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        h.write("* or more contributor license agreements.  See the NOTICE file\n");        h.write("* distributed with this work for additional information\n");        h.write("* regarding copyright ownership.  The ASF licenses this file\n");        h.write("* to you under the Apache License, Version 2.0 (the\n");        h.write("* \"License\"); you may not use this file except in compliance\n");        h.write("* with the License.  You may obtain a copy of the License at\n");        h.write("*\n");        h.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        h.write("*\n");        h.write("* Unless required by applicable law or agreed to in writing, software\n");        h.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        h.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        h.write("* See the License for the specific language governing permissions and\n");        h.write("* limitations under the License.\n");        h.write("*/\n");        h.write("\n");        c.write("/**\n");        c.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        c.write("* or more contributor license agreements.  See the NOTICE file\n");        c.write("* distributed with this work for additional information\n");        c.write("* regarding copyright ownership.  The ASF licenses this file\n");        c.write("* to you under the Apache License, Version 2.0 (the\n");        c.write("* \"License\"); you may not use this file except in compliance\n");        c.write("* with the License.  You may obtain a copy of the License at\n");        c.write("*\n");        c.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        c.write("*\n");        c.write("* Unless required by applicable law or agreed to in writing, software\n");        c.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        c.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        c.write("* See the License for the specific language governing permissions and\n");        c.write("* limitations under the License.\n");        c.write("*/\n");        c.write("\n");        h.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#include \"recordio.h\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            h.write("#include \"" + f.getName() + ".h\"\n");        }                h.write("\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");                c.write("#include <stdlib.h>\n");        c.write("#include \"" + mName + ".h\"\n\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCCode(h, c);        }        h.write("\n#ifdef __cplusplus\n}\n#endif\n\n");        h.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
0
 void genCode() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter cc = new FileWriter(new File(outputDirectory, mName + ".cc"));        FileWriter hh = new FileWriter(new File(outputDirectory, mName + ".hh"))) {        hh.write("/**\n");        hh.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        hh.write("* or more contributor license agreements.  See the NOTICE file\n");        hh.write("* distributed with this work for additional information\n");        hh.write("* regarding copyright ownership.  The ASF licenses this file\n");        hh.write("* to you under the Apache License, Version 2.0 (the\n");        hh.write("* \"License\"); you may not use this file except in compliance\n");        hh.write("* with the License.  You may obtain a copy of the License at\n");        hh.write("*\n");        hh.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        hh.write("*\n");        hh.write("* Unless required by applicable law or agreed to in writing, software\n");        hh.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        hh.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        hh.write("* See the License for the specific language governing permissions and\n");        hh.write("* limitations under the License.\n");        hh.write("*/\n");        hh.write("\n");        cc.write("/**\n");        cc.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        cc.write("* or more contributor license agreements.  See the NOTICE file\n");        cc.write("* distributed with this work for additional information\n");        cc.write("* regarding copyright ownership.  The ASF licenses this file\n");        cc.write("* to you under the Apache License, Version 2.0 (the\n");        cc.write("* \"License\"); you may not use this file except in compliance\n");        cc.write("* with the License.  You may obtain a copy of the License at\n");        cc.write("*\n");        cc.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        cc.write("*\n");        cc.write("* Unless required by applicable law or agreed to in writing, software\n");        cc.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        cc.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        cc.write("* See the License for the specific language governing permissions and\n");        cc.write("* limitations under the License.\n");        cc.write("*/\n");        cc.write("\n");        hh.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#include \"recordio.hh\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            hh.write("#include \"" + f.getName() + ".hh\"\n");        }        cc.write("#include \"" + mName + ".hh\"\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCppCode(hh, cc);        }        hh.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
0
 void genCode() throws IOException
{    for (JRecord rec : mRecList) {        rec.genCsharpCode(outputDirectory);    }}
0
 void genCode() throws IOException
{    for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {        JRecord rec = i.next();        rec.genJavaCode(outputDirectory);    }}
0
public String getSignature()
{    return "z";}
0
public String genJavaCompareTo(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 : (" + fname + "?1:-1);\n";}
0
public String genJavaHashCode(String fname)
{    return "     ret = (" + fname + ")?0:1;\n";}
0
 String genCsharpHashCode(String fname)
{    return "     ret = (" + capitalize(fname) + ")?0:1;\n";}
0
 String genCsharpCompareTo(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 : (" + capitalize(name) + "?1:-1);\n";}
0
public String genCppGetSet(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
0
public String getSignature()
{    return "B";}
0
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    byte[] " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readBuffer(\"" + tag + "\");\n";}
0
public String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.writeBuffer(" + fname + ",\"" + tag + "\");\n";}
0
public String genJavaCompareTo(String fname, String other)
{    StringBuilder sb = new StringBuilder();    sb.append("    {\n");    sb.append("      byte[] my = " + fname + ";\n");    sb.append("      byte[] ur = " + other + ";\n");    sb.append("      ret = org.apache.jute.Utils.compareBytes(my,0,my.length,ur,0,ur.length);\n");    sb.append("    }\n");    return sb.toString();}
0
public String genJavaCompareTo(String fname)
{    return genJavaCompareTo(fname, "peer." + fname);}
0
public String genJavaCompareToWrapper(String fname, String other)
{    return "    " + genJavaCompareTo(fname, other);}
0
public String genJavaEquals(String fname, String peer)
{    return "    ret = org.apache.jute.Utils.bufEquals(" + fname + "," + peer + ");\n";}
0
public String genJavaHashCode(String fname)
{    return "    ret = java.util.Arrays.toString(" + fname + ").hashCode();\n";}
0
public String genJavaSlurpBytes(String b, String s, String l)
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i = org.apache.jute.Utils.readVInt(" + b + ", " + s + ");\n");    sb.append("           int z = WritableUtils.getVIntSize(i);\n");    sb.append("           " + s + " += z+i; " + l + " -= (z+i);\n");    sb.append("        }\n");    return sb.toString();}
0
public String genJavaCompareBytes()
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i1 = org.apache.jute.Utils.readVInt(b1, s1);\n");    sb.append("           int i2 = org.apache.jute.Utils.readVInt(b2, s2);\n");    sb.append("           int z1 = WritableUtils.getVIntSize(i1);\n");    sb.append("           int z2 = WritableUtils.getVIntSize(i2);\n");    sb.append("           s1+=z1; s2+=z2; l1-=z1; l2-=z2;\n");    sb.append("           int r1 = org.apache.jute.Utils.compareBytes(b1,s1,l1,b2,s2,l2);\n");    sb.append("           if (r1 != 0) { return (r1<0)?-1:0; }\n");    sb.append("           s1+=i1; s2+=i2; l1-=i1; l1-=i2;\n");    sb.append("        }\n");    return sb.toString();}
0
public String getSignature()
{    return "b";}
0
 String genCppGetSet(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
0
 String genJavaCompareTo(String fname)
{    return "    ret = " + fname + ".compareTo(peer." + fname + ");\n";}
0
 String genJavaEquals(String fname, String peer)
{    return "    ret = " + fname + ".equals(" + peer + ");\n";}
0
 String genJavaHashCode(String fname)
{    return "    ret = " + fname + ".hashCode();\n";}
0
 String genCsharpHashCode(String fname)
{    return "    ret = " + capitalize(fname) + ".GetHashCode();\n";}
0
 String genCsharpEquals(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = " + capitalize(name) + ".Equals(" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
0
 String genCsharpCompareTo(String name)
{    return "    ret = " + capitalize(name) + ".CompareTo(peer." + capitalize(name) + ");\n";}
0
public String getSignature()
{    return "d";}
0
public String genJavaHashCode(String fname)
{    String tmp = "Double.doubleToLongBits(" + fname + ")";    return "    ret = (int)(" + tmp + "^(" + tmp + ">>>32));\n";}
0
public String getSignature()
{    return mType.getSignature();}
0
public String genCppDecl()
{    return mType.genCppDecl(mName);}
0
public String genCDecl()
{    return mType.genCDecl(mName);}
0
public String genCsharpDecl()
{    return mType.genCsharpDecl(mName);}
0
public String genCsharpConstructorParam(String fname)
{    return mType.genCsharpConstructorParam(fname);}
0
public String genJavaDecl()
{    return mType.genJavaDecl(mName);}
0
public String genJavaConstructorParam(String fname)
{    return mType.genJavaConstructorParam(fname);}
0
public String getName()
{    return mName;}
0
public String getCsharpName()
{    return "Id".equals(mName) ? "ZKId" : mName;}
0
public String getTag()
{    return mName;}
0
public JType getType()
{    return mType;}
0
public String genCppGetSet(int fIdx)
{    return mType.genCppGetSet(mName, fIdx);}
0
public String genCsharpConstructorSet(String fname)
{    return mType.genCsharpConstructorSet(mName, fname);}
0
public String genCsharpGetSet(int fIdx)
{    return mType.genCsharpGetSet(getCsharpName(), fIdx);}
0
public String genCsharpWriteMethodName()
{    return mType.genCsharpWriteMethod(getCsharpName(), getTag());}
0
public String genCsharpReadMethodName()
{    return mType.genCsharpReadMethod(getCsharpName(), getTag());}
0
public String genCsharpCompareTo()
{    return mType.genCsharpCompareTo(getCsharpName());}
0
public String genCsharpEquals()
{    return mType.genCsharpEquals(getCsharpName(), "peer." + getCsharpName());}
0
public String genCsharpHashCode()
{    return mType.genCsharpHashCode(getCsharpName());}
0
public String genJavaGetSet(int fIdx)
{    return mType.genJavaGetSet(mName, fIdx);}
0
public String genJavaWriteMethodName()
{    return mType.genJavaWriteMethod(getName(), getTag());}
0
public String genJavaReadMethodName()
{    return mType.genJavaReadMethod(getName(), getTag());}
0
public String genJavaCompareTo()
{    return mType.genJavaCompareTo(getName());}
0
public String genJavaEquals()
{    return mType.genJavaEquals(getName(), "peer." + getName());}
0
public String genJavaHashCode()
{    return mType.genJavaHashCode(getName());}
0
public String genJavaConstructorSet(String fname)
{    return mType.genJavaConstructorSet(mName, fname);}
0
 String getName()
{    int idx = mName.lastIndexOf('/');    return (idx > 0) ? mName.substring(idx) : mName;}
0
public void genCode(String language, File outputDirectory) throws IOException
{    if ("c++".equals(language)) {        CppGenerator gen = new CppGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("java".equals(language)) {        JavaGenerator gen = new JavaGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("c".equals(language)) {        CGenerator gen = new CGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("csharp".equals(language)) {        CSharpGenerator gen = new CSharpGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else {        throw new IOException("Cannnot recognize language:" + language);    }}
0
public String getSignature()
{    return "f";}
0
public String genJavaHashCode(String fname)
{    return "    ret = Float.floatToIntBits(" + fname + ");\n";}
0
public String getSignature()
{    return "i";}
0
public String getSignature()
{    return "l";}
0
public String genJavaHashCode(String fname)
{    return "    ret = (int) (" + fname + "^(" + fname + ">>>32));\n";}
0
private static String getLevel()
{    return Integer.toString(level);}
0
private static void incrLevel()
{    level++;}
0
private static void decrLevel()
{    level--;}
0
private static String getId(String id)
{    return id + getLevel();}
0
public String getSignature()
{    return "{" + mKey.getSignature() + mValue.getSignature() + "}";}
0
public String genJavaCompareTo(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
0
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    java.util.TreeMap " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      org.apache.jute.Index " + getId("midx") + " = a_.startMap(\"" + tag + "\");\n");    ret.append("      " + fname + "=new java.util.TreeMap();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genJavaReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genJavaReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".put(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.endMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
0
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
0
public String genJavaWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getJavaWrapperType() + " " + getId("k") + " = (" + mKey.getJavaWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getJavaWrapperType() + " " + getId("v") + " = (" + mValue.getJavaWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genJavaWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genJavaWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.endMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
0
public String genJavaWriteMethod(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
0
public String genCsharpWriteWrapper(String fname, int tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getCsharpWrapperType() + " " + getId("k") + " = (" + mKey.getCsharpWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getCsharpWrapperType() + " " + getId("v") + " = (" + mValue.getCsharpWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genCsharpWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genCsharpWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.EndMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
0
 String genCsharpWriteMethod(String fname, int tag)
{    return genCsharpWriteWrapper(fname, tag);}
0
public String genCsharpReadWrapper(String fname, int tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    System.Collections.SortedDictionary<string,string> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Org.Apache.Jute.IIndex " + getId("midx") + " = a_.StartMap(\"" + tag + "\");\n");    ret.append("      " + fname + "= new System.Collections.SortedDictionary<string,string>();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genCsharpReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genCsharpReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".Add(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.EndMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
0
 String genCsharpReadMethod(String fname, int tag)
{    return genCsharpReadWrapper(fname, tag, false);}
0
public String getName()
{    return mName;}
0
public String getCsharpName()
{    return "Id".equals(mName) ? "ZKId" : mName;}
0
public String getJavaFQName()
{    return mFQName;}
0
public String getCppFQName()
{    return mFQName.replaceAll("\\.", "::");}
0
public String getJavaPackage()
{    return mModule;}
0
public String getCppNameSpace()
{    return mModule.replaceAll("\\.", "::");}
0
public String getCsharpNameSpace()
{    String[] parts = mModule.split("\\.");    StringBuffer namespace = new StringBuffer();    for (int i = 0; i < parts.length; i++) {        String capitalized = parts[i].substring(0, 1).toUpperCase() + parts[i].substring(1).toLowerCase();        namespace.append(capitalized);        if (i != parts.length - 1) {            namespace.append(".");        }    }    return namespace.toString();}
0
public List<JField> getFields()
{    return mFields;}
0
public String getSignature()
{    StringBuilder sb = new StringBuilder();    sb.append("L").append(mName).append("(");    for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {        String s = i.next().getSignature();        sb.append(s);    }    sb.append(")");    return sb.toString();}
0
public String genCppDecl(String fname)
{    return "  " + getCppNameSpace() + "::" + mName + " m" + fname + ";\n";}
0
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
0
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getJavaFQName() + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getJavaFQName() + "();\n");    ret.append("    a_.readRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
0
public String genJavaWriteWrapper(String fname, String tag)
{    return "    a_.writeRecord(" + fname + ",\"" + tag + "\");\n";}
0
 String genCsharpReadMethod(String fname, String tag)
{        return genCsharpReadWrapper(capitalize(fname), tag, false);}
0
public String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getCsharpFQName(mFQName) + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getCsharpFQName(mFQName) + "();\n");    ret.append("    a_.ReadRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
0
public String genCsharpWriteWrapper(String fname, String tag)
{    return "    a_.WriteRecord(" + fname + ",\"" + tag + "\");\n";}
0
public void genCCode(FileWriter h, FileWriter c) throws IOException
{    for (JField f : mFields) {        if (f.getType() instanceof JVector) {            JVector jv = (JVector) f.getType();            JType jvType = jv.getElementType();            String structName = JVector.extractVectorName(jvType);            if (vectorStructs.get(structName) == null) {                vectorStructs.put(structName, structName);                h.write("struct " + structName + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + "\n};\n");                h.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v);\n");                h.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v);\n");                h.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len);\n");                h.write("int deallocate_" + structName + "(struct " + structName + " *v);\n");                c.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len) {\n");                c.write("    if (!len) {\n");                c.write("        v->count = 0;\n");                c.write("        v->data = 0;\n");                c.write("    } else {\n");                c.write("        v->count = len;\n");                c.write("        v->data = calloc(sizeof(*v->data), len);\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int deallocate_" + structName + "(struct " + structName + " *v) {\n");                c.write("    if (v->data) {\n");                c.write("        int32_t i;\n");                c.write("        for(i=0;i<v->count; i++) {\n");                c.write("            deallocate_" + JRecord.extractMethodSuffix(jvType) + "(&v->data[i]);\n");                c.write("        }\n");                c.write("        free(v->data);\n");                c.write("        v->data = 0;\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int32_t count = v->count;\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = out->start_vector(out, tag, &count);\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genSerialize(c, jvType, "data", "data[i]");                c.write("    }\n");                c.write("    rc = rc ? rc : out->end_vector(out, tag);\n");                c.write("    return rc;\n");                c.write("}\n");                c.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = in->start_vector(in, tag, &v->count);\n");                c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genDeserialize(c, jvType, "value", "data[i]");                c.write("    }\n");                c.write("    rc = in->end_vector(in, tag);\n");                c.write("    return rc;\n");                c.write("}\n");            }        }    }    String recName = getName();    h.write("struct " + recName + " {\n");    for (JField f : mFields) {        h.write(f.genCDecl());    }    h.write("};\n");    h.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v);\n");    h.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v);\n");    h.write("void deallocate_" + recName + "(struct " + recName + "*);\n");    c.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = out->start_record(out, tag);\n");    for (JField f : mFields) {        genSerialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : out->end_record(out, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = in->start_record(in, tag);\n");    for (JField f : mFields) {        genDeserialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : in->end_record(in, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("void deallocate_" + recName + "(struct " + recName + "*v)");    c.write("{\n");    for (JField f : mFields) {        if (f.getType() instanceof JRecord) {            c.write("    deallocate_" + extractStructName(f.getType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JVector) {            JVector vt = (JVector) f.getType();            c.write("    deallocate_" + JVector.extractVectorName(vt.getElementType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JCompType) {            c.write("    deallocate_" + extractMethodSuffix(f.getType()) + "(&v->" + f.getName() + ");\n");        }    }    c.write("}\n");}
0
private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : serialize_" + extractStructName(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : serialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : out->serialize_" + extractMethodSuffix(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    }}
0
private void genDeserialize(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : deserialize_" + extractStructName(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : deserialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : in->deserialize_" + extractMethodSuffix(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    }}
0
 static String extractMethodSuffix(JType t)
{    if (t instanceof JRecord) {        return extractStructName(t);    }    return t.getMethodSuffix();}
0
private static String extractStructName(JType t)
{    String type = t.getCType();    if (!type.startsWith("struct ")) {        return type;    }    return type.substring("struct ".length());}
0
public static String getCsharpFQName(String name)
{    String[] packages = name.split("\\.");    StringBuffer fQName = new StringBuffer();    for (int i = 0; i < packages.length; i++) {        String pack = packages[i];        pack = capitalize(pack);        pack = "Id".equals(pack) ? "ZKId" : pack;        fQName.append(capitalize(pack));        if (i != packages.length - 1) {            fQName.append(".");        }    }    return fQName.toString();}
0
public String getSignature()
{    return "s";}
0
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    String " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readString(\"" + tag + "\");\n";}
0
public String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.writeString(" + fname + ",\"" + tag + "\");\n";}
0
 String genCppDecl(String fname)
{    return "  " + mCppName + " m" + fname + ";\n";}
0
 String genCDecl(String name)
{    return "    " + mCName + " " + name + ";\n";}
0
public String genCsharpDecl(String name)
{    return "  private " + mCsharpName + " " + name + ";\n";}
0
 String genJavaDecl(String fname)
{    return "  private " + mJavaName + " " + fname + ";\n";}
0
 String genJavaConstructorParam(String fname)
{    return "        " + mJavaName + " " + fname;}
0
 String genCppGetSet(String fname, int fIdx)
{    String getFunc = "  virtual " + mCppName + " get" + fname + "() const {\n";    getFunc += "    return m" + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  virtual void set" + fname + "(" + mCppName + " m_) {\n";    setFunc += "    m" + fname + "=m_; bs_.set(" + fIdx + ");\n";    setFunc += "  }\n";    return getFunc + setFunc;}
0
 String genCsharpGetSet(String fname, int fIdx)
{    String getFunc = "  public " + getCsharpType() + " " + capitalize(fname) + " { get; set; } ";    return getFunc;}
0
 static String capitalize(String s)
{    return s.substring(0, 1).toUpperCase() + s.substring(1);}
0
 String genJavaGetSet(String fname, int fIdx)
{    String getFunc = "  public " + mJavaName + " get" + capitalize(fname) + "() {\n";    getFunc += "    return " + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  public void set" + capitalize(fname) + "(" + mJavaName + " m_) {\n";    setFunc += "    " + fname + "=m_;\n";    setFunc += "  }\n";    return getFunc + setFunc;}
0
 String getCType()
{    return mCName;}
0
 String getCppType()
{    return mCppName;}
0
 String getCsharpType()
{    return mCsharpName;}
0
 String getJavaType()
{    return mJavaName;}
0
 String getJavaWrapperType()
{    return mWrapper;}
0
 String getCsharpWrapperType()
{    return mSharpWrapper;}
0
 String getMethodSuffix()
{    return mMethodSuffix;}
0
 String genJavaWriteMethod(String fname, String tag)
{    return "    a_.write" + mMethodSuffix + "(" + fname + ",\"" + tag + "\");\n";}
0
 String genJavaReadMethod(String fname, String tag)
{    return "    " + fname + "=a_.read" + mMethodSuffix + "(\"" + tag + "\");\n";}
0
 String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=new " + mWrapper + "(a_.read" + mMethodSuffix + "(\"" + tag + "\"));\n";}
0
 String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
0
 String genJavaCompareTo(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 :((" + fname + "<peer." + fname + ")?-1:1);\n";}
0
 String genJavaEquals(String fname, String peer)
{    return "    ret = (" + fname + "==" + peer + ");\n";}
0
 String genJavaHashCode(String fname)
{    return "    ret = (int)" + fname + ";\n";}
0
 String genJavaConstructorSet(String fname, String name)
{    return "    this." + fname + "=" + name + ";\n";}
0
 String genCsharpWriteMethod(String fname, String tag)
{    return "    a_.Write" + mMethodSuffix + "(" + capitalize(fname) + ",\"" + tag + "\");\n";}
0
 String genCsharpReadMethod(String fname, String tag)
{    return "    " + capitalize(fname) + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
0
 String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
0
 String genCsharpWriteWrapper(String fname, String tag)
{    return (mUnwrapMethod == null) ? "        a_.Write" + mMethodSuffix + "(" + fname + "," + tag + ");\n" : "        a_.Write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
0
 String genCsharpCompareTo(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 :((" + capitalize(name) + "<peer." + capitalize(name) + ")?-1:1);\n";}
0
 String genCsharpEquals(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = (" + capitalize(name) + "==" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
0
 String genCsharpHashCode(String fname)
{    return "    ret = (int)" + capitalize(fname) + ";\n";}
0
 String genCsharpConstructorSet(String mName, String fname)
{    return capitalize(fname) + "=" + mName + ";\n";}
0
public String genCsharpConstructorParam(String fname)
{    return "  " + mCsharpName + " " + fname + "\n";}
0
private static String getId(String id)
{    return id + getLevel();}
0
private static String getLevel()
{    return Integer.toString(level);}
0
private static void incrLevel()
{    level++;}
0
private static void decrLevel()
{    level--;}
0
public String getSignature()
{    return "[" + mElement.getSignature() + "]";}
0
public String genJavaCompareTo(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
0
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("      java.util.List " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Index " + getId("vidx") + " = a_.startVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + fname + "=new java.util.ArrayList<" + mElement.getJavaType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".done(); " + getId("vidx") + ".incr()) {\n");    ret.append(mElement.genJavaReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + fname + ".add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.endVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
0
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
0
public String genJavaWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startVector(" + fname + ",\"" + tag + "\");\n");    ret.append("      if (" + fname + "!= null) {");    ret.append("          int " + getId("len") + " = " + fname + ".size();\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getJavaWrapperType() + " " + getId("e") + " = (" + mElement.getJavaWrapperType() + ") " + fname + ".get(" + getId("vidx") + ");\n");    ret.append(mElement.genJavaWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.endVector(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
0
public String genJavaWriteMethod(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
0
public JType getElementType()
{    return mElement;}
0
public String genCsharpWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("      if (" + capitalize(fname) + "!= null) {");    ret.append("          int " + getId("len") + " = " + capitalize(fname) + ".Count;\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getCsharpWrapperType() + " " + getId("e") + " = (" + mElement.getCsharpWrapperType() + ") " + capitalize(fname) + "[" + getId("vidx") + "];\n");    ret.append(mElement.genCsharpWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.EndVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
0
 String genCsharpWriteMethod(String fname, String tag)
{    return genCsharpWriteWrapper(fname, tag);}
0
public String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder();    if (decl) {        ret.append("      System.Collections.Generic.List<" + mElement.getCsharpType() + "> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      IIndex " + getId("vidx") + " = a_.StartVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + capitalize(fname) + "=new System.Collections.Generic.List<" + mElement.getCsharpType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".Done(); " + getId("vidx") + ".Incr()) {\n");    ret.append(mElement.genCsharpReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + capitalize(fname) + ".Add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.EndVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
0
 String genCsharpReadMethod(String fname, String tag)
{    return genCsharpReadWrapper(fname, tag, false);}
0
 static String extractVectorName(JType jvType)
{    return JRecord.extractMethodSuffix(jvType) + "_vector";}
0
private static InputArchive createArchive(InputStream in, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { in };        try {            return (InputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
0
public void read(Record r) throws IOException
{    r.deserialize(archive, "");}
0
 static HashMap<String, Method> constructFactory()
{    HashMap<String, Method> factory = new HashMap<String, Method>();    try {        factory.put("binary", BinaryOutputArchive.class.getDeclaredMethod("getArchive", OutputStream.class));    } catch (SecurityException | NoSuchMethodException ex) {        ex.printStackTrace();    }    return factory;}
0
private static OutputArchive createArchive(OutputStream out, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { out };        try {            return (OutputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
0
public void write(Record r) throws IOException
{    r.serialize(archive, "");}
0
private void throwExceptionOnError(String tag) throws IOException
{    if (stream.checkError()) {        throw new IOException("Error serializing " + tag);    }}
0
private void printCommaUnlessFirst()
{    if (!isFirst) {        stream.print(",");    }    isFirst = false;}
0
public void writeByte(byte b, String tag) throws IOException
{    writeLong((long) b, tag);}
0
public void writeBool(boolean b, String tag) throws IOException
{    printCommaUnlessFirst();    String val = b ? "T" : "F";    stream.print(val);    throwExceptionOnError(tag);}
0
public void writeInt(int i, String tag) throws IOException
{    writeLong((long) i, tag);}
0
public void writeLong(long l, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(l);    throwExceptionOnError(tag);}
0
public void writeFloat(float f, String tag) throws IOException
{    writeDouble((double) f, tag);}
0
public void writeDouble(double d, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(d);    throwExceptionOnError(tag);}
0
public void writeString(String s, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeString(s));    throwExceptionOnError(tag);}
0
public void writeBuffer(byte[] buf, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeBuffer(buf));    throwExceptionOnError(tag);}
0
public void writeRecord(Record r, String tag) throws IOException
{    if (r == null) {        return;    }    r.serialize(this, tag);}
0
public void startRecord(Record r, String tag) throws IOException
{    if (tag != null && !"".equals(tag)) {        printCommaUnlessFirst();        stream.print("s{");        isFirst = true;    }}
0
public void endRecord(Record r, String tag) throws IOException
{    if (tag == null || "".equals(tag)) {        stream.print("\n");        isFirst = true;    } else {        stream.print("}");        isFirst = false;    }}
0
public void startVector(List<?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("v{");    isFirst = true;}
0
public void endVector(List<?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
0
public void startMap(TreeMap<?, ?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("m{");    isFirst = true;}
0
public void endMap(TreeMap<?, ?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
0
private static String escapeString(String s)
{    if (s == null) {        return "";    }    StringBuilder sb = new StringBuilder(s.length() + 1);    sb.append('\'');    int len = s.length();    for (int i = 0; i < len; i++) {        char c = s.charAt(i);        switch(c) {            case '\0':                sb.append("%00");                break;            case '\n':                sb.append("%0A");                break;            case '\r':                sb.append("%0D");                break;            case ',':                sb.append("%2C");                break;            case '}':                sb.append("%7D");                break;            case '%':                sb.append("%25");                break;            default:                sb.append(c);        }    }    return sb.toString();}
0
private static String escapeBuffer(byte[] barr)
{    if (barr == null || barr.length == 0) {        return "";    }    StringBuilder sb = new StringBuilder(barr.length + 1);    sb.append('#');    for (byte b : barr) {        sb.append(Integer.toHexString(b));    }    return sb.toString();}
0
public static boolean bufEquals(byte[] onearray, byte[] twoarray)
{    if (onearray == twoarray) {        return true;    }    boolean ret = (onearray.length == twoarray.length);    if (!ret) {        return ret;    }    for (int idx = 0; idx < onearray.length; idx++) {        if (onearray[idx] != twoarray[idx]) {            return false;        }    }    return true;}
0
public static int compareBytes(byte[] b1, int off1, int len1, byte[] b2, int off2, int len2)
{    int i;    for (i = 0; i < len1 && i < len2; i++) {        if (b1[off1 + i] != b2[off2 + i]) {            return b1[off1 + i] < b2[off2 + i] ? -1 : 1;        }    }    if (len1 != len2) {        return len1 < len2 ? -1 : 1;    }    return 0;}
0
public void testReadStringCheckLength()
{    byte[] buf = new byte[] { Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE };    ByteArrayInputStream is = new ByteArrayInputStream(buf);    BinaryInputArchive ia = BinaryInputArchive.getArchive(is);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
0
private void checkWriterAndReader(TestWriter writer, TestReader reader)
{    TestCheckWriterReader.checkWriterAndReader(BinaryOutputArchive::getArchive, BinaryInputArchive::getArchive, writer, reader);}
0
public void testInt()
{    final int expected = 4;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeInt(expected, tag), (ia) -> {        int actual = ia.readInt(tag);        assertEquals(expected, actual);    });}
0
public void testBool()
{    final boolean expected = false;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBool(expected, tag), (ia) -> {        boolean actual = ia.readBool(tag);        assertEquals(expected, actual);    });}
0
public void testString()
{    final String expected = "hello";    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeString(expected, tag), (ia) -> {        String actual = ia.readString(tag);        assertEquals(expected, actual);    });}
0
public void testFloat()
{    final float expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-10f;    checkWriterAndReader((oa) -> oa.writeFloat(expected, tag), (ia) -> {        float actual = ia.readFloat(tag);        assertEquals(expected, actual, delta);    });}
0
public void testDouble()
{    final double expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-20f;    checkWriterAndReader((oa) -> oa.writeDouble(expected, tag), (ia) -> {        double actual = ia.readDouble(tag);        assertEquals(expected, actual, delta);    });}
0
public void testBuffer()
{    final byte[] expected = "hello-world".getBytes(StandardCharsets.UTF_8);    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBuffer(expected, tag), (ia) -> {        byte[] actual = ia.readBuffer(tag);        assertArrayEquals(expected, actual);    });}
0
public void testReadStringForRecordsHavingLengthMoreThanMaxAllowedSize()
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;        int recordSize = maxBufferSize + extraMaxBufferSize + 100;    BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
0
public void testReadStringForRecordsHavingLengthLessThanMaxAllowedSize() throws IOException
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;    int recordSize = maxBufferSize + extraMaxBufferSize - 100;        BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    String s = ia.readString("");    assertNotNull(s);    assertEquals(recordSize, s.getBytes().length);}
0
private BinaryInputArchive getBinaryInputArchive(int recordSize, int maxBufferSize, int extraMaxBufferSize)
{    byte[] data = getData(recordSize);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));    return new BinaryInputArchive(dis, maxBufferSize, extraMaxBufferSize);}
0
private byte[] getData(int recordSize)
{    ByteBuffer buf = ByteBuffer.allocate(recordSize + 4);    buf.putInt(recordSize);    byte[] bytes = new byte[recordSize];    for (int i = 0; i < recordSize; i++) {        bytes[i] = (byte) 'a';    }    buf.put(bytes);    return buf.array();}
0
 static void checkWriterAndReader(TestOutputArchive output, TestInputArchive input, TestWriter writer, TestReader reader)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        OutputArchive oa = output.getArchive(baos);        writer.write(oa);    } catch (IOException e) {        fail("Should not throw IOException while writing");    }    InputStream is = new ByteArrayInputStream(baos.toByteArray());    try {        InputArchive ia = input.getArchive(is);        reader.read(ia);    } catch (IOException e) {        fail("Should not throw IOException while reading back");    }}
0
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{        this.port = Integer.parseInt(configuration.getProperty("httpPort", "7000"));    this.exportJvmInfo = Boolean.parseBoolean(configuration.getProperty("exportJvmInfo", "true"));}
1
public void start() throws MetricsProviderLifeCycleException
{    try {                if (exportJvmInfo) {            DefaultExports.initialize();        }        server = new Server(port);        ServletContextHandler context = new ServletContextHandler();        context.setContextPath("/");        server.setHandler(context);        context.addServlet(new ServletHolder(servlet), "/metrics");        server.start();    } catch (Exception err) {                if (server != null) {            try {                server.stop();            } catch (Exception suppressed) {                err.addSuppressed(suppressed);            } finally {                server = null;            }        }        throw new MetricsProviderLifeCycleException(err);    }}
1
 MetricsServletImpl getServlet()
{    return servlet;}
0
public MetricsContext getRootContext()
{    return rootContext;}
0
public void stop()
{    if (server != null) {        try {            server.stop();        } catch (Exception err) {                    } finally {            server = null;        }    }}
1
public void dump(BiConsumer<String, Object> sink)
{    sampleGauges();    Enumeration<Collector.MetricFamilySamples> samplesFamilies = collectorRegistry.metricFamilySamples();    while (samplesFamilies.hasMoreElements()) {        Collector.MetricFamilySamples samples = samplesFamilies.nextElement();        samples.samples.forEach(sample -> {            String key = buildKeyForDump(sample);            sink.accept(key, sample.value);        });    }}
0
private static String buildKeyForDump(Collector.MetricFamilySamples.Sample sample)
{    StringBuilder keyBuilder = new StringBuilder();    keyBuilder.append(sample.name);    if (sample.labelNames.size() > 0) {        keyBuilder.append('{');        for (int i = 0; i < sample.labelNames.size(); ++i) {            if (i > 0) {                keyBuilder.append(',');            }            keyBuilder.append(sample.labelNames.get(i));            keyBuilder.append("=\"");            keyBuilder.append(sample.labelValues.get(i));            keyBuilder.append('"');        }        keyBuilder.append('}');    }    return keyBuilder.toString();}
0
private void sampleGauges()
{    rootContext.gauges.values().forEach(PrometheusGaugeWrapper::sample);}
0
public void resetAllValues()
{}
0
public MetricsContext getContext(String name)
{        return this;}
0
public Counter getCounter(String name)
{    return counters.computeIfAbsent(name, PrometheusCounter::new);}
0
public void registerGauge(String name, Gauge gauge)
{    Objects.requireNonNull(name);    gauges.compute(name, (id, prev) -> new PrometheusGaugeWrapper(id, gauge, prev != null ? prev.inner : null));}
0
public void unregisterGauge(String name)
{    PrometheusGaugeWrapper existing = gauges.remove(name);    if (existing != null) {        existing.unregister();    }}
0
public Summary getSummary(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    }}
0
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    }}
0
public void add(long delta)
{    try {        inner.inc(delta);    } catch (IllegalArgumentException err) {            }}
1
public long get()
{        return (long) inner.get();}
0
private void sample()
{    Number value = gauge.get();    this.inner.set(value != null ? value.doubleValue() : 0);}
0
private void unregister()
{    collectorRegistry.unregister(inner);}
0
public void add(long delta)
{    try {        inner.observe(delta);    } catch (IllegalArgumentException err) {            }}
1
public void add(String key, long value)
{    try {        inner.labels(key).observe(value);    } catch (IllegalArgumentException err) {            }}
1
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
{            sampleGauges();        super.doGet(req, resp);}
0
public void exportInfo() throws Exception
{    runTest(true);}
0
public void doNotExportInfo() throws Exception
{    runTest(false);}
0
private void runTest(boolean exportJvmInfo) throws Exception
{    CollectorRegistry.defaultRegistry.clear();    PrometheusMetricsProvider provider = new PrometheusMetricsProvider();    try {        Properties configuration = new Properties();                configuration.setProperty("httpPort", "0");        configuration.setProperty("exportJvmInfo", exportJvmInfo + "");        provider.configure(configuration);        provider.start();        boolean[] found = { false };        provider.dump((k, v) -> {            found[0] = found[0] || k.contains("heap");        });        assertEquals(exportJvmInfo, found[0]);    } finally {        provider.stop();    }}
0
public void setup() throws Exception
{    CollectorRegistry.defaultRegistry.clear();    provider = new PrometheusMetricsProvider();    Properties configuration = new Properties();        configuration.setProperty("httpPort", "0");    configuration.setProperty("exportJvmInfo", "false");    provider.configure(configuration);    provider.start();}
0
public void tearDown()
{    if (provider != null) {        provider.stop();    }    CollectorRegistry.defaultRegistry.clear();}
0
public void testCounters() throws Exception
{    Counter counter = provider.getRootContext().getCounter("cc");    counter.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);    count[0] = 0;        counter.add(-1);    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);        assertSame(counter, provider.getRootContext().getCounter("cc"));    String res = callServlet();    assertThat(res, CoreMatchers.containsString("# TYPE cc counter"));    assertThat(res, CoreMatchers.containsString("cc 10.0"));}
0
public void testGauge() throws Exception
{    int[] values = { 78, -89 };    int[] callCounts = { 0, 0 };    Gauge gauge0 = () -> {        callCounts[0]++;        return values[0];    };    Gauge gauge1 = () -> {        callCounts[1]++;        return values[1];    };    provider.getRootContext().registerGauge("gg", gauge0);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[0], ((Number) v).intValue());        count[0]++;    });    assertEquals(1, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res2 = callServlet();    assertThat(res2, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res2, CoreMatchers.containsString("gg 78.0"));    provider.getRootContext().unregisterGauge("gg");    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(0, count[0]);    String res3 = callServlet();    assertTrue(res3.isEmpty());    provider.getRootContext().registerGauge("gg", gauge1);    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[1], ((Number) v).intValue());        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(1, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res4 = callServlet();    assertThat(res4, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res4, CoreMatchers.containsString("gg -89.0"));    assertEquals(2, callCounts[0]);        assertEquals(2, callCounts[1]);        provider.getRootContext().registerGauge("gg", gauge0);    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(1, count[0]);    assertEquals(3, callCounts[0]);    assertEquals(2, callCounts[1]);}
0
public void testBasicSummary() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(3, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));}
0
public void testAdvancedSummary() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.9\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.99\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(5, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.9\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.99\",} 10.0"));}
0
private String callServlet() throws ServletException, IOException
{            StringWriter writer = new StringWriter();    HttpServletResponse response = mock(HttpServletResponse.class);    when(response.getWriter()).thenReturn(new PrintWriter(writer));    HttpServletRequest req = mock(HttpServletRequest.class);    provider.getServlet().doGet(req, response);    String res = writer.toString();    return res;}
0
public synchronized void start()
{    state = State.START;    dispatchEvent(EventType.START);        if (zooKeeper == null) {        throw new IllegalStateException("No instance of zookeeper provided. Hint: use setZooKeeper()");    }    if (hostName == null) {        throw new IllegalStateException("No hostname provided. Hint: use setHostName()");    }    try {        makeOffer();        determineElectionStatus();    } catch (KeeperException | InterruptedException e) {        becomeFailed(e);    }}
1
public synchronized void stop()
{    state = State.STOP;    dispatchEvent(EventType.STOP_START);        if (leaderOffer != null) {        try {            zooKeeper.delete(leaderOffer.getNodePath(), -1);                    } catch (InterruptedException | KeeperException e) {            becomeFailed(e);        }    }    dispatchEvent(EventType.STOP_COMPLETE);}
1
private void makeOffer() throws KeeperException, InterruptedException
{    state = State.OFFER;    dispatchEvent(EventType.OFFER_START);    LeaderOffer newLeaderOffer = new LeaderOffer();    byte[] hostnameBytes;    synchronized (this) {        newLeaderOffer.setHostName(hostName);        hostnameBytes = hostName.getBytes();        newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + "/" + "n_", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));        leaderOffer = newLeaderOffer;    }        dispatchEvent(EventType.OFFER_COMPLETE);}
1
private synchronized LeaderOffer getLeaderOffer()
{    return leaderOffer;}
0
private void determineElectionStatus() throws KeeperException, InterruptedException
{    state = State.DETERMINE;    dispatchEvent(EventType.DETERMINE_START);    LeaderOffer currentLeaderOffer = getLeaderOffer();    String[] components = currentLeaderOffer.getNodePath().split("/");    currentLeaderOffer.setId(Integer.valueOf(components[components.length - 1].substring("n_".length())));    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    /*         * For each leader offer, find out where we fit in. If we're first, we         * become the leader. If we're not elected the leader, attempt to stat the         * offer just less than us. If they exist, watch for their failure, but if         * they don't, become the leader.         */    for (int i = 0; i < leaderOffers.size(); i++) {        LeaderOffer leaderOffer = leaderOffers.get(i);        if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {                        dispatchEvent(EventType.DETERMINE_COMPLETE);            if (i == 0) {                becomeLeader();            } else {                becomeReady(leaderOffers.get(i - 1));            }            /* Once we've figured out where we are, we're done. */            break;        }    }}
1
private void becomeReady(LeaderOffer neighborLeaderOffer) throws KeeperException, InterruptedException
{        /*         * Make sure to pass an explicit Watcher because we could be sharing this         * zooKeeper instance with someone else.         */    Stat stat = zooKeeper.exists(neighborLeaderOffer.getNodePath(), this);    if (stat != null) {        dispatchEvent(EventType.READY_START);                state = State.READY;        dispatchEvent(EventType.READY_COMPLETE);    } else {        /*             * If the stat fails, the node has gone missing between the call to             * getChildren() and exists(). We need to try and become the leader.             */                determineElectionStatus();    }}
1
private void becomeLeader()
{    state = State.ELECTED;    dispatchEvent(EventType.ELECTED_START);        dispatchEvent(EventType.ELECTED_COMPLETE);}
1
private void becomeFailed(Exception e)
{        state = State.FAILED;    dispatchEvent(EventType.FAILED);}
1
public String getLeaderHostName() throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    if (leaderOffers.size() > 0) {        return leaderOffers.get(0).getHostName();    }    return null;}
0
private List<LeaderOffer> toLeaderOffers(List<String> strings) throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = new ArrayList<>(strings.size());    /*         * Turn each child of rootNodeName into a leader offer. This is a tuple of         * the sequence number and the node name.         */    for (String offer : strings) {        String hostName = new String(zooKeeper.getData(rootNodeName + "/" + offer, false, null));        leaderOffers.add(new LeaderOffer(Integer.valueOf(offer.substring("n_".length())), rootNodeName + "/" + offer, hostName));    }    /*         * We sort leader offers by sequence number (which may not be zero-based or         * contiguous) and keep their paths handy for setting watches.         */    Collections.sort(leaderOffers, new LeaderOffer.IdComparator());    return leaderOffers;}
0
public void process(WatchedEvent event)
{    if (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) {        if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {                        try {                determineElectionStatus();            } catch (KeeperException | InterruptedException e) {                becomeFailed(e);            }        }    }}
1
private void dispatchEvent(EventType eventType)
{        synchronized (listeners) {        if (listeners.size() > 0) {            for (LeaderElectionAware observer : listeners) {                observer.onElectionEvent(eventType);            }        }    }}
1
public void addListener(LeaderElectionAware listener)
{    listeners.add(listener);}
0
public void removeListener(LeaderElectionAware listener)
{    listeners.remove(listener);}
0
public String toString()
{    return "{" + " state:" + state + " leaderOffer:" + getLeaderOffer() + " zooKeeper:" + zooKeeper + " hostName:" + getHostName() + " listeners:" + listeners + " }";}
0
public String getRootNodeName()
{    return rootNodeName;}
0
public void setRootNodeName(String rootNodeName)
{    this.rootNodeName = rootNodeName;}
0
public ZooKeeper getZooKeeper()
{    return zooKeeper;}
0
public void setZooKeeper(ZooKeeper zooKeeper)
{    this.zooKeeper = zooKeeper;}
0
public synchronized String getHostName()
{    return hostName;}
0
public synchronized void setHostName(String hostName)
{    this.hostName = hostName;}
0
public String toString()
{    return "{" + " id:" + id + " nodePath:" + nodePath + " hostName:" + hostName + " }";}
0
public Integer getId()
{    return id;}
0
public void setId(Integer id)
{    this.id = id;}
0
public String getNodePath()
{    return nodePath;}
0
public void setNodePath(String nodePath)
{    this.nodePath = nodePath;}
0
public String getHostName()
{    return hostName;}
0
public void setHostName(String hostName)
{    this.hostName = hostName;}
0
public int compare(LeaderOffer o1, LeaderOffer o2)
{    return o1.getId().compareTo(o2.getId());}
0
public void setUp() throws Exception
{    super.setUp();    zooKeeper = createClient();    zooKeeper.create(TEST_ROOT_NODE + Thread.currentThread().getId(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
0
public void tearDown() throws Exception
{    if (zooKeeper != null) {        zooKeeper.delete(TEST_ROOT_NODE + Thread.currentThread().getId(), -1);    }    super.tearDown();}
0
public void testNode() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();    Thread.sleep(3000);    electionSupport.stop();}
0
public void testNodes3() throws Exception
{    int testIterations = 3;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
1
public void testNodes9() throws Exception
{    int testIterations = 9;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
1
public void testNodes20() throws Exception
{    int testIterations = 20;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
1
public void testNodes100() throws Exception
{    int testIterations = 100;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(20, TimeUnit.SECONDS)) {            }}
1
public void testOfferShuffle() throws InterruptedException
{    int testIterations = 10;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    List<Thread> threads = new ArrayList<>(testIterations);    for (int i = 1; i <= testIterations; i++) {        threads.add(runElectionSupportThread(latch, failureCounter, Math.min(i * 1200, 10000)));    }    if (!latch.await(60, TimeUnit.SECONDS)) {            }}
1
public void testGetLeaderHostName() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();        Thread.sleep(3000);    String leaderHostName = electionSupport.getLeaderHostName();    Assert.assertNotNull(leaderHostName);    Assert.assertEquals("foohost", leaderHostName);    electionSupport.stop();}
0
public void testReadyOffer() throws Exception
{    final ArrayList<EventType> events = new ArrayList<>();    final CountDownLatch electedComplete = new CountDownLatch(1);    final LeaderElectionSupport electionSupport1 = createLeaderElectionSupport();    electionSupport1.start();    LeaderElectionSupport electionSupport2 = createLeaderElectionSupport();    LeaderElectionAware listener = new LeaderElectionAware() {        boolean stoppedElectedNode = false;        @Override        public void onElectionEvent(EventType eventType) {            events.add(eventType);            if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {                stoppedElectedNode = true;                try {                                        electionSupport1.stop();                } catch (Exception e) {                                    }            }            if (eventType == EventType.ELECTED_COMPLETE) {                electedComplete.countDown();            }        }    };    electionSupport2.addListener(listener);    electionSupport2.start();        electedComplete.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS);    final ArrayList<EventType> expectedevents = new ArrayList<>();    expectedevents.add(EventType.START);    expectedevents.add(EventType.OFFER_START);    expectedevents.add(EventType.OFFER_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.ELECTED_START);    expectedevents.add(EventType.ELECTED_COMPLETE);    Assert.assertEquals("Events has failed to executed in the order", expectedevents, events);    electionSupport2.stop();}
1
public void onElectionEvent(EventType eventType)
{    events.add(eventType);    if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {        stoppedElectedNode = true;        try {                        electionSupport1.stop();        } catch (Exception e) {                    }    }    if (eventType == EventType.ELECTED_COMPLETE) {        electedComplete.countDown();    }}
1
private LeaderElectionSupport createLeaderElectionSupport()
{    LeaderElectionSupport electionSupport = new LeaderElectionSupport();    electionSupport.setZooKeeper(zooKeeper);    electionSupport.setRootNodeName(TEST_ROOT_NODE + Thread.currentThread().getId());    electionSupport.setHostName("foohost");    return electionSupport;}
0
private Thread runElectionSupportThread(final CountDownLatch latch, final AtomicInteger failureCounter)
{    return runElectionSupportThread(latch, failureCounter, 3000);}
0
private Thread runElectionSupportThread(final CountDownLatch latch, final AtomicInteger failureCounter, final long sleepDuration)
{    final LeaderElectionSupport electionSupport = createLeaderElectionSupport();    Thread t = new Thread(() -> {        try {            electionSupport.start();            Thread.sleep(sleepDuration);            electionSupport.stop();            latch.countDown();        } catch (Exception e) {                        failureCounter.incrementAndGet();        }    });    t.start();    return t;}
1
public void close()
{    if (closed.compareAndSet(false, true)) {        doClose();    }}
0
public ZooKeeper getZookeeper()
{    return zookeeper;}
0
public List<ACL> getAcl()
{    return acl;}
0
public void setAcl(List<ACL> acl)
{    this.acl = acl;}
0
public long getRetryDelay()
{    return retryDelay;}
0
public void setRetryDelay(long retryDelay)
{    this.retryDelay = retryDelay;}
0
protected void doClose()
{}
0
protected Object retryOperation(ZooKeeperOperation operation) throws KeeperException, InterruptedException
{    KeeperException exception = null;    for (int i = 0; i < retryCount; i++) {        try {            return operation.execute();        } catch (KeeperException.SessionExpiredException e) {                        throw e;        } catch (KeeperException.ConnectionLossException e) {            if (exception == null) {                exception = e;            }                        retryDelay(i);        }    }    throw exception;}
1
protected void ensurePathExists(String path)
{    ensureExists(path, null, acl, CreateMode.PERSISTENT);}
0
protected void ensureExists(final String path, final byte[] data, final List<ACL> acl, final CreateMode flags)
{    try {        retryOperation(() -> {            Stat stat = zookeeper.exists(path, false);            if (stat != null) {                return true;            }            zookeeper.create(path, data, acl, flags);            return true;        });    } catch (KeeperException | InterruptedException e) {            }}
1
protected boolean isClosed()
{    return closed.get();}
0
protected void retryDelay(int attemptCount)
{    if (attemptCount > 0) {        try {            Thread.sleep(attemptCount * retryDelay);        } catch (InterruptedException e) {                    }    }}
1
public synchronized LockListener getLockListener()
{    return this.callback;}
0
public synchronized void setLockListener(LockListener callback)
{    this.callback = callback;}
0
public synchronized void unlock() throws RuntimeException
{    if (!isClosed() && id != null) {                try {            ZooKeeperOperation zopdel = () -> {                zookeeper.delete(id, -1);                return Boolean.TRUE;            };            zopdel.execute();        } catch (InterruptedException e) {                                    Thread.currentThread().interrupt();        } catch (KeeperException.NoNodeException e) {                } catch (KeeperException e) {                        throw new RuntimeException(e.getMessage(), e);        } finally {            LockListener lockListener = getLockListener();            if (lockListener != null) {                lockListener.lockReleased();            }            id = null;        }    }}
1
public void process(WatchedEvent event)
{            try {        lock();    } catch (Exception e) {            }}
1
private void findPrefixInChildren(String prefix, ZooKeeper zookeeper, String dir) throws KeeperException, InterruptedException
{    List<String> names = zookeeper.getChildren(dir, false);    for (String name : names) {        if (name.startsWith(prefix)) {            id = name;                        break;        }    }    if (id == null) {        id = zookeeper.create(dir + "/" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);            }}
1
public boolean execute() throws KeeperException, InterruptedException
{    do {        if (id == null) {            long sessionId = zookeeper.getSessionId();            String prefix = "x-" + sessionId + "-";                                    findPrefixInChildren(prefix, zookeeper, dir);            idName = new ZNodeName(id);        }        List<String> names = zookeeper.getChildren(dir, false);        if (names.isEmpty()) {                                    id = null;        } else {                        SortedSet<ZNodeName> sortedNames = new TreeSet<>();            for (String name : names) {                sortedNames.add(new ZNodeName(dir + "/" + name));            }            ownerId = sortedNames.first().getName();            SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);            if (!lessThanMe.isEmpty()) {                ZNodeName lastChildName = lessThanMe.last();                lastChildId = lastChildName.getName();                                Stat stat = zookeeper.exists(lastChildId, new LockWatcher());                if (stat != null) {                    return Boolean.FALSE;                } else {                                    }            } else {                if (isOwner()) {                    LockListener lockListener = getLockListener();                    if (lockListener != null) {                        lockListener.lockAcquired();                    }                    return Boolean.TRUE;                }            }        }    } while (id == null);    return Boolean.FALSE;}
1
public synchronized boolean lock() throws KeeperException, InterruptedException
{    if (isClosed()) {        return false;    }    ensurePathExists(dir);    return (Boolean) retryOperation(zop);}
0
public String getDir()
{    return dir;}
0
public boolean isOwner()
{    return id != null && id.equals(ownerId);}
0
public String getId()
{    return this.id;}
0
public String toString()
{    return name.toString();}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZNodeName sequence = (ZNodeName) o;    return name.equals(sequence.name);}
0
public int hashCode()
{    return name.hashCode() + 37;}
0
public int compareTo(ZNodeName that)
{    int answer = this.sequence - that.sequence;    if (answer == 0) {        return this.prefix.compareTo(that.prefix);    }    return answer;}
0
public String getName()
{    return name;}
0
public int getZNodeName()
{    return sequence;}
0
public String getPrefix()
{    return prefix;}
0
public void testRun() throws Exception
{    runTest(3);}
0
public void lockAcquired()
{    latch.countDown();}
0
public void lockReleased()
{}
0
protected void runTest(int count) throws Exception
{    nodes = new WriteLock[count];    for (int i = 0; i < count; i++) {        ZooKeeper keeper = createClient();        WriteLock leader = new WriteLock(keeper, dir, null);        leader.setLockListener(new LockCallback());        nodes[i] = leader;        leader.lock();    }            latch.await(30, TimeUnit.SECONDS);    WriteLock first = nodes[0];    dumpNodes(count);        Assert.assertTrue("The first znode should be the leader " + first.getId(), first.isOwner());    for (int i = 1; i < count; i++) {        WriteLock node = nodes[i];        Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());    }    if (count > 1) {        if (killLeader) {            System.out.println("Now killing the leader");                        latch = new CountDownLatch(1);            first.unlock();            latch.await(30, TimeUnit.SECONDS);                        WriteLock second = nodes[1];            dumpNodes(count);                        Assert.assertTrue("The second znode should be the leader " + second.getId(), second.isOwner());            for (int i = 2; i < count; i++) {                WriteLock node = nodes[i];                Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());            }        }        if (restartServer) {                        System.out.println("Now stopping the server");            stopServer();            Thread.sleep(10000);                        dumpNodes(count);            System.out.println("Starting the server");            startServer();            Thread.sleep(10000);            for (int i = 0; i < count - 1; i++) {                System.out.println("Calling acquire for node: " + i);                nodes[i].lock();            }            dumpNodes(count);            System.out.println("Now closing down...");        }    }}
0
protected void dumpNodes(int count)
{    for (int i = 0; i < count; i++) {        WriteLock node = nodes[i];        System.out.println("node: " + i + " id: " + node.getId() + " is leader: " + node.isOwner());    }}
0
public void tearDown() throws Exception
{    if (nodes != null) {        for (int i = 0; i < nodes.length; i++) {            WriteLock node = nodes[i];            if (node != null) {                System.out.println("Closing node: " + i);                node.close();                if (workAroundClosingLastZNodeFails && i == nodes.length - 1) {                    System.out.println("Not closing zookeeper: " + i + " due to bug!");                } else {                    System.out.println("Closing zookeeper: " + i);                    node.getZookeeper().close();                    System.out.println("Closed zookeeper: " + i);                }            }        }    }    System.out.println("Now lets stop the server");    super.tearDown();}
0
public void testOrderWithSamePrefix() throws Exception
{    String[] names = { "x-3", "x-5", "x-11", "x-1" };    String[] expected = { "x-1", "x-3", "x-5", "x-11" };    assertOrderedNodeNames(names, expected);}
0
public void testOrderWithDifferentPrefixes() throws Exception
{    String[] names = { "r-3", "r-2", "r-1", "w-2", "w-1" };    String[] expected = { "r-1", "w-1", "r-2", "w-2", "r-3" };    assertOrderedNodeNames(names, expected);}
0
public void testOrderWithDifferentPrefixIncludingSessionId() throws Exception
{    String[] names = { "x-242681582799028564-0000000002", "x-170623981976748329-0000000003", "x-98566387950223723-0000000001" };    String[] expected = { "x-98566387950223723-0000000001", "x-242681582799028564-0000000002", "x-170623981976748329-0000000003" };    assertOrderedNodeNames(names, expected);}
0
public void testOrderWithExtraPrefixes() throws Exception
{    String[] names = { "r-1-3-2", "r-2-2-1", "r-3-1-3" };    String[] expected = { "r-2-2-1", "r-1-3-2", "r-3-1-3" };    assertOrderedNodeNames(names, expected);}
0
protected void assertOrderedNodeNames(String[] names, String[] expected)
{    int size = names.length;    SortedSet<ZNodeName> nodeNames = new TreeSet<>();    for (String name : names) {        nodeNames.add(new ZNodeName(name));    }    Assert.assertEquals("The SortedSet does not have the expected size!", nodeNames.size(), expected.length);    int index = 0;    for (ZNodeName nodeName : nodeNames) {        String name = nodeName.getName();        Assert.assertEquals("Node " + index, expected[index++], name);    }}
0
private Map<Long, String> orderedChildren(Watcher watcher) throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren = new TreeMap<>();    List<String> childNames;    childNames = zookeeper.getChildren(dir, watcher);    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                                continue;            }            String suffix = childName.substring(prefix.length());            Long childId = Long.parseLong(suffix);            orderedChildren.put(childId, childName);        } catch (NumberFormatException e) {                    }    }    return orderedChildren;}
1
private String smallestChildName() throws KeeperException, InterruptedException
{    long minId = Long.MAX_VALUE;    String minName = "";    List<String> childNames;    try {        childNames = zookeeper.getChildren(dir, false);    } catch (KeeperException.NoNodeException e) {                return null;    }    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                                continue;            }            String suffix = childName.substring(prefix.length());            long childId = Long.parseLong(suffix);            if (childId < minId) {                minId = childId;                minName = childName;            }        } catch (NumberFormatException e) {                    }    }    if (minId < Long.MAX_VALUE) {        return minName;    } else {        return null;    }}
1
public byte[] element() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            if (headNode != null) {                try {                    return zookeeper.getData(dir + "/" + headNode, false, null);                } catch (KeeperException.NoNodeException e) {                                }            }        }    }}
0
public byte[] remove() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
0
public void process(WatchedEvent event)
{        latch.countDown();}
1
public void await() throws InterruptedException
{    latch.await();}
0
public byte[] take() throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        LatchChildWatcher childWatcher = new LatchChildWatcher();        try {            orderedChildren = orderedChildren(childWatcher);        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);            continue;        }        if (orderedChildren.size() == 0) {            childWatcher.await();            continue;        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
0
public boolean offer(byte[] data) throws KeeperException, InterruptedException
{    for (; ; ) {        try {            zookeeper.create(dir + "/" + prefix, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);            return true;        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);        }    }}
0
public byte[] peek() throws KeeperException, InterruptedException
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
0
public byte[] poll() throws KeeperException, InterruptedException
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
0
public void tearDown() throws Exception
{    super.tearDown();    }
1
public void testOffer1() throws Exception
{    String dir = "/testOffer1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
0
public void testOffer2() throws Exception
{    String dir = "/testOffer2";    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[1].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
0
public void testTake1() throws Exception
{    String dir = "/testTake1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].take();    Assert.assertEquals(new String(dequeuedBytes), testString);}
0
public void testRemove1() throws Exception
{    String dir = "/testRemove1";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    try {        queueHandles[0].remove();    } catch (NoSuchElementException e) {        return;    }    Assert.fail();}
0
public void createNremoveMtest(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    byte[] data = null;    for (int i = 0; i < m; i++) {        data = queueHandles[1].remove();    }    Assert.assertNotNull(data);    Assert.assertEquals(new String(data), testString + (m - 1));}
0
public void testRemove2() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
0
public void testRemove3() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
0
public void createNremoveMelementTest(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    for (int i = 0; i < m; i++) {        queueHandles[1].remove();    }    Assert.assertEquals(new String(queueHandles[1].element()), testString + m);}
0
public void testElement1() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
0
public void testElement2() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
0
public void testElement3() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
0
public void testElement4() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
0
public void testTakeWait1() throws Exception
{    String dir = "/testTakeWait1";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    final byte[][] takeResult = new byte[1][];    Thread takeThread = new Thread(() -> {        try {            takeResult[0] = queueHandles[0].take();        } catch (KeeperException | InterruptedException ignore) {                }    });    takeThread.start();    Thread.sleep(1000);    Thread offerThread = new Thread(() -> {        try {            queueHandles[0].offer(testString.getBytes());        } catch (KeeperException | InterruptedException ignore) {                }    });    offerThread.start();    offerThread.join();    takeThread.join();    Assert.assertNotNull(takeResult[0]);    Assert.assertEquals(new String(takeResult[0]), testString);}
0
public void testTakeWait2() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    int numAttempts = 2;    for (int i = 0; i < numAttempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread(() -> {            try {                takeResult[0] = queueHandles[0].take();            } catch (KeeperException | InterruptedException ignore) {                        }        });        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread(() -> {            try {                queueHandles[0].offer(threadTestString.getBytes());            } catch (KeeperException | InterruptedException ignore) {                        }        });        offerThread.start();        offerThread.join();        takeThread.join();        Assert.assertNotNull(takeResult[0]);        Assert.assertEquals(new String(takeResult[0]), threadTestString);    }}
0
public byte[] reconfigure(String joiningServers, String leavingServers, String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), "");    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
0
public byte[] reconfigure(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    return reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, stat);}
0
public void reconfigure(String joiningServers, String leavingServers, String newMembers, long fromConfig, DataCallback cb, Object ctx)
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, ZooDefs.CONFIG_NODE, ZooDefs.CONFIG_NODE, ctx, null);}
0
public void reconfigure(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, DataCallback cb, Object ctx)
{    reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, cb, ctx);}
0
public String toString()
{    return super.toString();}
0
public static List<ACL> parse(String aclString)
{    List<ACL> acl;    String[] acls = aclString.split(",");    acl = new ArrayList<ACL>();    for (String a : acls) {        int firstColon = a.indexOf(':');        int lastColon = a.lastIndexOf(':');        if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {            System.err.println(a + " does not have the form scheme:id:perm");            continue;        }        ACL newAcl = new ACL();        newAcl.setId(new Id(a.substring(0, firstColon), a.substring(firstColon + 1, lastColon)));        newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));        acl.add(newAcl);    }    return acl;}
0
private static int getPermFromString(String permString)
{    int perm = 0;    for (int i = 0; i < permString.length(); i++) {        switch(permString.charAt(i)) {            case 'r':                perm |= ZooDefs.Perms.READ;                break;            case 'w':                perm |= ZooDefs.Perms.WRITE;                break;            case 'c':                perm |= ZooDefs.Perms.CREATE;                break;            case 'd':                perm |= ZooDefs.Perms.DELETE;                break;            case 'a':                perm |= ZooDefs.Perms.ADMIN;                break;            default:                System.err.println("Unknown perm type: " + permString.charAt(i));        }    }    return perm;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    byte[] b = null;    if (args.length >= 3) {        b = args[2].getBytes();    }    zk.addAuthInfo(args[1], b);    return false;}
0
public void setOut(PrintStream out)
{    this.out = out;}
0
public void setErr(PrintStream err)
{    this.err = err;}
0
public void setZk(ZooKeeper zk)
{    this.zk = zk;}
0
public String getCmdStr()
{    return cmdStr;}
0
public String getOptionStr()
{    return optionStr;}
0
public String getUsageStr()
{    return cmdStr + " " + optionStr;}
0
public void addToMap(Map<String, CliCommand> cmdMap)
{    cmdMap.put(cmdStr, this);}
0
public int getExitCode()
{    return exitCode;}
0
private static String getMessage(Throwable cause)
{    if (cause instanceof KeeperException) {        KeeperException keeperException = (KeeperException) cause;        if (keeperException instanceof KeeperException.NoNodeException) {            return "Node does not exist: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoChildrenForEphemeralsException) {            return "Ephemerals cannot have children: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NodeExistsException) {            return "Node already exists: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotEmptyException) {            return "Node not empty: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotReadOnlyException) {            return "Not a read-only call: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.InvalidACLException) {            return "Acl is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoAuthException) {            return "Authentication is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadArgumentsException) {            return "Arguments are not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadVersionException) {            return "version No is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.ReconfigInProgress) {            return "Another reconfiguration is in progress -- concurrent " + "reconfigs not supported (yet)";        } else if (keeperException instanceof KeeperException.NewConfigNoQuorum) {            return "No quorum of new config is connected and " + "up-to-date with the leader of last commmitted config - try invoking reconfiguration after " + "new servers are connected and synced";        }    }    return cause.getMessage();}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    return this;}
0
public boolean exec() throws CliException
{    try {        zk.close();    } catch (Exception ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    boolean hasE = cl.hasOption("e");    boolean hasS = cl.hasOption("s");    boolean hasC = cl.hasOption("c");    boolean hasT = cl.hasOption("t");    if (hasC && (hasE || hasS)) {        throw new MalformedCommandException("-c cannot be combined with -s or -e. Containers cannot be ephemeral or sequential.");    }    long ttl;    try {        ttl = hasT ? Long.parseLong(cl.getOptionValue("t")) : 0;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-t argument must be a long value");    }    if (hasT && hasE) {        throw new MalformedCommandException("TTLs cannot be used with Ephemeral znodes");    }    if (hasT && hasC) {        throw new MalformedCommandException("TTLs cannot be used with Container znodes");    }    CreateMode flags;    if (hasE && hasS) {        flags = CreateMode.EPHEMERAL_SEQUENTIAL;    } else if (hasE) {        flags = CreateMode.EPHEMERAL;    } else if (hasS) {        flags = hasT ? CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL : CreateMode.PERSISTENT_SEQUENTIAL;    } else if (hasC) {        flags = CreateMode.CONTAINER;    } else {        flags = hasT ? CreateMode.PERSISTENT_WITH_TTL : CreateMode.PERSISTENT;    }    if (hasT) {        try {            EphemeralType.TTL.toEphemeralOwner(ttl);        } catch (IllegalArgumentException e) {            throw new MalformedCommandException(e.getMessage());        }    }    String path = args[1];    byte[] data = null;    if (args.length > 2) {        data = args[2].getBytes();    }    List<ACL> acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;    if (args.length > 3) {        acl = AclParser.parse(args[3]);    }    try {        String newPath = hasT ? zk.create(path, data, acl, flags, new Stat(), ttl) : zk.create(path, data, acl, flags);        err.println("Created " + newPath);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.EphemeralOnLocalSessionException e) {        err.println("Unable to create ephemeral node on a local session");        throw new CliWrapperException(e);    } catch (KeeperException.InvalidACLException ex) {        err.println(ex.getMessage());        throw new CliWrapperException(ex);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    printDeprecatedWarning();    int batchSize;    try {        batchSize = cl.hasOption("b") ? Integer.parseInt(cl.getOptionValue("b")) : 1000;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-b argument must be an int value");    }    String path = args[1];    try {        boolean success = ZKUtil.deleteRecursive(zk, path, batchSize);        if (!success) {            err.println("Failed to delete some node(s) in the subtree!");        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
private void printDeprecatedWarning()
{    if ("rmr".equals(args[0])) {        err.println("The command 'rmr' has been deprecated. " + "Please use 'deleteall' instead.");    }}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
0
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{    if (args.length > 2) {        err.println("'delete path [version]' has been deprecated. " + "Please use 'delete [-v version] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
0
public boolean exec() throws CliException
{    String path = args[1];    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        zk.delete(path, version);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{            String path = args[1];    try {        if (cl.hasOption("b")) {            delQuota(zk, path, true, false);        } else if (cl.hasOption("n")) {            delQuota(zk, path, false, true);        } else if (args.length == 2) {                                    delQuota(zk, path, true, true);        }    } catch (KeeperException | InterruptedException | IOException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public static boolean delQuota(ZooKeeper zk, String path, boolean bytes, boolean numNodes) throws KeeperException, IOException, InterruptedException, MalformedPathException
{    String parentPath = Quotas.quotaZookeeper + path;    String quotaPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    if (zk.exists(quotaPath, false) == null) {        System.out.println("Quota does not exist for " + path);        return true;    }    byte[] data = null;    try {        data = zk.getData(quotaPath, false, new Stat());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        System.err.println("quota does not exist for " + path);        return true;    }    StatsTrack strack = new StatsTrack(new String(data));    if (bytes && !numNodes) {        strack.setBytes(-1L);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (!bytes && numNodes) {        strack.setCount(-1);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (bytes && numNodes) {                        List<String> children = zk.getChildren(parentPath, false);                for (String child : children) {            zk.delete(parentPath + "/" + child, -1);        }                trimProcQuotas(zk, parentPath);    }    return true;}
0
private static boolean trimProcQuotas(ZooKeeper zk, String path) throws KeeperException, IOException, InterruptedException
{    if (Quotas.quotaZookeeper.equals(path)) {        return true;    }    List<String> children = zk.getChildren(path, false);    if (children.size() == 0) {        zk.delete(path, -1);        String parent = path.substring(0, path.lastIndexOf('/'));        return trimProcQuotas(zk, parent);    } else {        return true;    }}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    String path = args[1];    Stat stat = new Stat();    List<ACL> acl;    try {        acl = zk.getACL(path, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    for (ACL a : acl) {        out.println(a.getId() + ": " + getPermString(a.getPerms()));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return false;}
0
private static String getPermString(int perms)
{    StringBuilder p = new StringBuilder();    if ((perms & ZooDefs.Perms.CREATE) != 0) {        p.append('c');    }    if ((perms & ZooDefs.Perms.DELETE) != 0) {        p.append('d');    }    if ((perms & ZooDefs.Perms.READ) != 0) {        p.append('r');    }    if ((perms & ZooDefs.Perms.WRITE) != 0) {        p.append('w');    }    if ((perms & ZooDefs.Perms.ADMIN) != 0) {        p.append('a');    }    return p.toString();}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
0
public boolean exec() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    try {        String path = args[1];        int allChildrenNumber = zk.getAllChildrenNumber(path);        out.println(allChildrenNumber);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
0
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'get path [watch]' has been deprecated. " + "Please use 'get [-s] [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
0
public boolean exec() throws CliException
{    boolean watch = cl.hasOption("w");    String path = args[1];    Stat stat = new Stat();    byte[] data;    try {        data = zk.getData(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliException(ex);    }    data = (data == null) ? "null".getBytes() : data;    out.println(new String(data));    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 1) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    boolean watch = cl.hasOption("w");    Stat stat = new Stat();    byte[] data;    try {        data = zk.getConfig(watch, stat);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    data = (data == null) ? "null".getBytes() : data;    if (cl.hasOption("c")) {        out.println(ConfigUtils.getClientConfigStr(new String(data)));    } else {        out.println(new String(data));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
0
public boolean exec() throws CliException
{    String path;    List<String> ephemerals;    try {        if (args.length < 2) {                        ephemerals = zk.getEphemerals();        } else {            path = args[1];            ephemerals = zk.getEphemerals(path);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(ephemerals);    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    String path = args[1];    String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    try {        err.println("absolute path is " + absolutePath);        Stat stat = new Stat();        byte[] data = zk.getData(absolutePath, false, stat);        StatsTrack st = new StatsTrack(new String(data));        out.println("Output quota for " + path + " " + st.toString());        data = zk.getData(Quotas.quotaZookeeper + path + "/" + Quotas.statNode, false, stat);        out.println("Output stat for " + path + " " + new StatsTrack(new String(data)).toString());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        err.println("quota for " + path + " does not exist.");    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    err.println("'ls2' has been deprecated. " + "Please use 'ls [-s] path' instead.");    String path = args[1];    boolean watch = args.length > 2;    Stat stat = new Stat();    List<String> children;    try {        children = zk.getChildren(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(children);    new StatPrinter(out).print(stat);    return watch;}
0
private void printHelp()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ls [options] path", options);}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (cl.hasOption("?")) {        printHelp();    }    retainCompatibility(cmdArgs);    return this;}
0
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'ls path [watch]' has been deprecated. " + "Please use 'ls [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
0
public boolean exec() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    String path = args[1];    boolean watch = cl.hasOption("w");    boolean withStat = cl.hasOption("s");    boolean recursive = cl.hasOption("R");    try {        if (recursive) {            ZKUtil.visitSubTreeDFS(zk, path, watch, new StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    out.println(path);                }            });        } else {            Stat stat = withStat ? new Stat() : null;            List<String> children = zk.getChildren(path, watch, stat);            printChildren(children, stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return watch;}
0
public void processResult(int rc, String path, Object ctx, String name)
{    out.println(path);}
0
private void printChildren(List<String> children, Stat stat)
{    Collections.sort(children);    out.append("[");    boolean first = true;    for (String child : children) {        if (!first) {            out.append(", ");        } else {            first = false;        }        out.append(child);    }    out.append("]");    if (stat != null) {        new StatPrinter(out).print(stat);    }    out.append("\n");}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    joining = null;    leaving = null;    members = null;    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    if (!(cl.hasOption("file") || cl.hasOption("members")) && !cl.hasOption("add") && !cl.hasOption("remove")) {        throw new CliParseException(getUsageStr());    }    if (cl.hasOption("v")) {        try {            version = Long.parseLong(cl.getOptionValue("v"), 16);        } catch (NumberFormatException e) {            throw new CliParseException("-v must be followed by a long (configuration version)");        }    } else {        version = -1;    }        if ((cl.hasOption("file") || cl.hasOption("members")) && (cl.hasOption("add") || cl.hasOption("remove"))) {        throw new CliParseException("Can't use -file or -members together with -add or -remove (mixing incremental" + " and non-incremental modes is not allowed)");    }    if (cl.hasOption("file") && cl.hasOption("members")) {        throw new CliParseException("Can't use -file and -members together (conflicting non-incremental modes)");    }        if (cl.hasOption("add")) {        joining = cl.getOptionValue("add").toLowerCase();    }    if (cl.hasOption("remove")) {        leaving = cl.getOptionValue("remove").toLowerCase();    }    if (cl.hasOption("members")) {        members = cl.getOptionValue("members").toLowerCase();    }    if (cl.hasOption("file")) {        try {            Properties dynamicCfg = new Properties();            try (FileInputStream inConfig = new FileInputStream(cl.getOptionValue("file"))) {                dynamicCfg.load(inConfig);            }                                                members = QuorumPeerConfig.parseDynamicConfig(dynamicCfg, 0, true, false).toString();        } catch (Exception e) {            throw new CliParseException("Error processing " + cl.getOptionValue("file") + e.getMessage());        }    }    return this;}
0
public boolean exec() throws CliException
{    try {        Stat stat = new Stat();        if (!(zk instanceof ZooKeeperAdmin)) {                        return false;        }        byte[] curConfig = ((ZooKeeperAdmin) zk).reconfigure(joining, leaving, members, version, stat);        out.println("Committed new configuration:\n" + new String(curConfig));        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliWrapperException, MalformedPathException
{    String path = args[1];    WatcherType wtype = WatcherType.Any;        if (cl.hasOption("c")) {        wtype = WatcherType.Children;    } else if (cl.hasOption("d")) {        wtype = WatcherType.Data;    } else if (cl.hasOption("a")) {        wtype = WatcherType.Any;    }        boolean local = cl.hasOption("l");    try {        zk.removeAllWatches(path, wtype, local);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    String path = args[1];    String aclStr = args[2];    List<ACL> acl = AclParser.parse(aclStr);    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        if (cl.hasOption("R")) {            ZKUtil.visitSubTreeDFS(zk, path, false, new StringCallback() {                @Override                public void processResult(int rc, String p, Object ctx, String name) {                    try {                        zk.setACL(p, acl, version);                    } catch (KeeperException | InterruptedException e) {                        out.print(e.getMessage());                    }                }            });        } else {            Stat stat = zk.setACL(path, acl, version);            if (cl.hasOption("s")) {                new StatPrinter(out).print(stat);            }        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public void processResult(int rc, String p, Object ctx, String name)
{    try {        zk.setACL(p, acl, version);    } catch (KeeperException | InterruptedException e) {        out.print(e.getMessage());    }}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    String path = args[1];    byte[] data = args[2].getBytes();    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        Stat stat = zk.setData(path, data, version);        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{        String path = args[1];    if (path.startsWith(Quotas.quotaZookeeper)) {        err.println("cannot set a quota under the path: " + Quotas.quotaZookeeper);        return false;    }    if (cl.hasOption("b")) {                long bytes = Long.parseLong(cl.getOptionValue("b"));        try {            createQuota(zk, path, bytes, -1);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else if (cl.hasOption("n")) {                int numNodes = Integer.parseInt(cl.getOptionValue("n"));        try {            createQuota(zk, path, -1L, numNodes);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else {        throw new MalformedCommandException(getUsageStr());    }    return false;}
0
public static boolean createQuota(ZooKeeper zk, String path, long bytes, int numNodes) throws KeeperException, InterruptedException, IllegalArgumentException, MalformedPathException
{                Stat initStat;    try {        initStat = zk.exists(path, false);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    }    if (initStat == null) {        throw new IllegalArgumentException(path + " does not exist.");    }            String quotaPath = Quotas.quotaZookeeper;                            checkIfChildQuota(zk, path);        checkIfParentQuota(zk, path);        if (zk.exists(quotaPath, false) == null) {        try {            zk.create(Quotas.procZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.create(Quotas.quotaZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }            String[] splits = path.split("/");    StringBuilder sb = new StringBuilder();    sb.append(quotaPath);    for (int i = 1; i < splits.length; i++) {        sb.append("/").append(splits[i]);        quotaPath = sb.toString();        try {            zk.create(quotaPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }    String statPath = quotaPath + "/" + Quotas.statNode;    quotaPath = quotaPath + "/" + Quotas.limitNode;    StatsTrack strack = new StatsTrack(null);    strack.setBytes(bytes);    strack.setCount(numNodes);    try {        zk.create(quotaPath, strack.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        StatsTrack stats = new StatsTrack(null);        stats.setBytes(0L);        stats.setCount(0);        zk.create(statPath, stats.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ne) {        byte[] data = zk.getData(quotaPath, false, new Stat());        StatsTrack strackC = new StatsTrack(new String(data));        if (bytes != -1L) {            strackC.setBytes(bytes);        }        if (numNodes != -1) {            strackC.setCount(numNodes);        }        zk.setData(quotaPath, strackC.toString().getBytes(), -1);    }    return true;}
0
private static void checkIfChildQuota(ZooKeeper zk, String path) throws KeeperException, InterruptedException
{    String realPath = Quotas.quotaZookeeper + path;    try {        ZKUtil.visitSubTreeDFS(zk, realPath, false, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String quotaPath, Object ctx, String name) {                List<String> children = new ArrayList<>();                try {                    children = zk.getChildren(quotaPath, false);                } catch (KeeperException.NoNodeException ne) {                                        return;                } catch (InterruptedException | KeeperException e) {                    e.printStackTrace();                }                if (children.size() == 0) {                    return;                }                for (String child : children) {                    if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                        throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");                    }                }            }        });    } catch (KeeperException.NoNodeException ne) {        }}
1
public void processResult(int rc, String quotaPath, Object ctx, String name)
{    List<String> children = new ArrayList<>();    try {        children = zk.getChildren(quotaPath, false);    } catch (KeeperException.NoNodeException ne) {                return;    } catch (InterruptedException | KeeperException e) {        e.printStackTrace();    }    if (children.size() == 0) {        return;    }    for (String child : children) {        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {            throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");        }    }}
1
private static void checkIfParentQuota(ZooKeeper zk, String path) throws InterruptedException, KeeperException
{    final String[] splits = path.split("/");    String quotaPath = Quotas.quotaZookeeper;    for (String str : splits) {        if (str.length() == 0) {                        continue;        }        quotaPath += "/" + str;        List<String> children = null;        try {            children = zk.getChildren(quotaPath, false);        } catch (KeeperException.NoNodeException ne) {                        return;        }        if (children.size() == 0) {            return;        }        for (String child : children) {            if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                throw new IllegalArgumentException(path + " has a parent " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");            }        }    }}
1
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
0
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'stat path [watch]' has been deprecated. " + "Please use 'stat [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
0
public boolean exec() throws CliException
{    String path = args[1];    boolean watch = cl.hasOption("w");    Stat stat;    try {        stat = zk.exists(path, watch);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    if (stat == null) {        throw new CliWrapperException(new KeeperException.NoNodeException(path));    }    new StatPrinter(out).print(stat);    return watch;}
0
public void print(Stat stat)
{    out.println("cZxid = 0x" + Long.toHexString(stat.getCzxid()));    out.println("ctime = " + new Date(stat.getCtime()).toString());    out.println("mZxid = 0x" + Long.toHexString(stat.getMzxid()));    out.println("mtime = " + new Date(stat.getMtime()).toString());    out.println("pZxid = 0x" + Long.toHexString(stat.getPzxid()));    out.println("cversion = " + stat.getCversion());    out.println("dataVersion = " + stat.getVersion());    out.println("aclVersion = " + stat.getAversion());    out.println("ephemeralOwner = 0x" + Long.toHexString(stat.getEphemeralOwner()));    out.println("dataLength = " + stat.getDataLength());    out.println("numChildren = " + stat.getNumChildren());}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    String path = args[1];    CompletableFuture<Integer> cf = new CompletableFuture<>();    try {        zk.sync(path, new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                cf.complete(rc);            }        }, null);        int resultCode = cf.get(SYNC_TIMEOUT, TimeUnit.MILLISECONDS);        if (resultCode == 0) {            out.println("Sync is OK");        } else {            out.println("Sync has failed. rc=" + resultCode);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (InterruptedException ie) {        Thread.currentThread().interrupt();        throw new CliWrapperException(ie);    } catch (TimeoutException | ExecutionException ex) {        throw new CliWrapperException(ex);    }    return false;}
0
public void processResult(int rc, String path, Object ctx)
{    cf.complete(rc);}
0
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length > 1) {        throw new CliParseException(getUsageStr());    }    return this;}
0
public boolean exec() throws CliException
{    out.println("ZooKeeper CLI version: " + Version.getFullVersion());    return false;}
0
public String getChrootPath()
{    return chrootPath;}
0
public ArrayList<InetSocketAddress> getServerAddresses()
{    return serverAddresses;}
0
public static String send4LetterWord(String host, int port, String cmd) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, false, DEFAULT_SOCKET_TIMEOUT);}
0
public static String send4LetterWord(String host, int port, String cmd, boolean secure) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, secure, DEFAULT_SOCKET_TIMEOUT);}
0
public static String send4LetterWord(String host, int port, String cmd, boolean secure, int timeout) throws IOException, SSLContextException
{        Socket sock;    InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);    if (secure) {                try (X509Util x509Util = new ClientX509Util()) {            SSLContext sslContext = x509Util.getDefaultSSLContext();            SSLSocketFactory socketFactory = sslContext.getSocketFactory();            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();            sslSock.connect(hostaddress, timeout);            sslSock.startHandshake();            sock = sslSock;        }    } else {        sock = new Socket();        sock.connect(hostaddress, timeout);    }    sock.setSoTimeout(timeout);    BufferedReader reader = null;    try {        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                if (!secure) {                        sock.shutdownOutput();        }        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) {            sb.append(line).append("\n");        }        return sb.toString();    } catch (SocketTimeoutException e) {        throw new IOException("Exception while executing four letter word: " + cmd, e);    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
1
public static void main(String[] args) throws IOException, SSLContextException
{    if (args.length == 3) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2]));    } else if (args.length == 4) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2], Boolean.parseBoolean(args[3])));    } else {        System.out.println("Usage: FourLetterWordMain <host> <port> <cmd> <secure(optional)>");    }}
0
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
0
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
0
private void init(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver)
{    this.sourceOfRandomness = new Random(randomnessSeed);    this.resolver = resolver;    if (serverAddresses.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }    this.serverAddresses = shuffle(serverAddresses);    currentIndex = -1;    lastIndex = -1;}
0
private InetSocketAddress resolve(InetSocketAddress address)
{    try {        String curHostString = address.getHostString();        List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));        if (resolvedAddresses.isEmpty()) {            return address;        }        Collections.shuffle(resolvedAddresses);        return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());    } catch (UnknownHostException e) {                return address;    }}
1
private List<InetSocketAddress> shuffle(Collection<InetSocketAddress> serverAddresses)
{    List<InetSocketAddress> tmpList = new ArrayList<>(serverAddresses.size());    tmpList.addAll(serverAddresses);    Collections.shuffle(tmpList, sourceOfRandomness);    return tmpList;}
0
public synchronized boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    List<InetSocketAddress> shuffledList = shuffle(serverAddresses);    if (shuffledList.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }        boolean myServerInNewConfig = false;    InetSocketAddress myServer = currentHost;        if (reconfigMode) {        myServer = next(0);    }        if (myServer == null) {                if (lastIndex >= 0) {                        myServer = this.serverAddresses.get(lastIndex);        } else {                        myServer = this.serverAddresses.get(0);        }    }    for (InetSocketAddress addr : shuffledList) {        if (addr.getPort() == myServer.getPort() && ((addr.getAddress() != null && myServer.getAddress() != null && addr.getAddress().equals(myServer.getAddress())) || addr.getHostString().equals(myServer.getHostString()))) {            myServerInNewConfig = true;            break;        }    }    reconfigMode = true;    newServers.clear();    oldServers.clear();        for (InetSocketAddress address : shuffledList) {        if (this.serverAddresses.contains(address)) {            oldServers.add(address);        } else {            newServers.add(address);        }    }    int numOld = oldServers.size();    int numNew = newServers.size();        if (numOld + numNew > this.serverAddresses.size()) {        if (myServerInNewConfig) {                        if (sourceOfRandomness.nextFloat() <= (1 - ((float) this.serverAddresses.size()) / (numOld + numNew))) {                pNew = 1;                pOld = 0;            } else {                                reconfigMode = false;            }        } else {                                                pNew = 1;            pOld = 0;        }    } else {                if (myServerInNewConfig) {                                    reconfigMode = false;        } else {            pOld = ((float) (numOld * (this.serverAddresses.size() - (numOld + numNew)))) / ((numOld + numNew) * (this.serverAddresses.size() - numOld));            pNew = 1 - pOld;        }    }    if (!reconfigMode) {        currentIndex = shuffledList.indexOf(getServerAtCurrentIndex());    } else {        currentIndex = -1;    }    this.serverAddresses = shuffledList;    currentIndexOld = -1;    currentIndexNew = -1;    lastIndex = currentIndex;    return reconfigMode;}
0
public synchronized InetSocketAddress getServerAtIndex(int i)
{    if (i < 0 || i >= serverAddresses.size()) {        return null;    }    return serverAddresses.get(i);}
0
public synchronized InetSocketAddress getServerAtCurrentIndex()
{    return getServerAtIndex(currentIndex);}
0
public synchronized int size()
{    return serverAddresses.size();}
0
private InetSocketAddress nextHostInReconfigMode()
{    boolean takeNew = (sourceOfRandomness.nextFloat() <= pNew);        if (((currentIndexNew + 1) < newServers.size()) && (takeNew || (currentIndexOld + 1) >= oldServers.size())) {        ++currentIndexNew;        return newServers.get(currentIndexNew);    }        if ((currentIndexOld + 1) < oldServers.size()) {        ++currentIndexOld;        return oldServers.get(currentIndexOld);    }    return null;}
0
public InetSocketAddress next(long spinDelay)
{    boolean needToSleep = false;    InetSocketAddress addr;    synchronized (this) {        if (reconfigMode) {            addr = nextHostInReconfigMode();            if (addr != null) {                currentIndex = serverAddresses.indexOf(addr);                return resolve(addr);            }                        reconfigMode = false;            needToSleep = (spinDelay > 0);        }        ++currentIndex;        if (currentIndex == serverAddresses.size()) {            currentIndex = 0;        }        addr = serverAddresses.get(currentIndex);        needToSleep = needToSleep || (currentIndex == lastIndex && spinDelay > 0);        if (lastIndex == -1) {                        lastIndex = 0;        }    }    if (needToSleep) {        try {            Thread.sleep(spinDelay);        } catch (InterruptedException e) {                    }    }    return resolve(addr);}
1
public synchronized void onConnected()
{    lastIndex = currentIndex;    reconfigMode = false;}
0
private void initFromJavaSystemProperties()
{    setProperty(ZOOKEEPER_REQUEST_TIMEOUT, System.getProperty(ZOOKEEPER_REQUEST_TIMEOUT));}
0
protected void handleBackwardCompatibility()
{    /**     * backward compatibility for properties which are common to both client     * and server     */    super.handleBackwardCompatibility();    /**     * backward compatibility for client specific properties     */    setProperty(ZK_SASL_CLIENT_USERNAME, System.getProperty(ZK_SASL_CLIENT_USERNAME));    setProperty(LOGIN_CONTEXT_NAME_KEY, System.getProperty(LOGIN_CONTEXT_NAME_KEY));    setProperty(ENABLE_CLIENT_SASL_KEY, System.getProperty(ENABLE_CLIENT_SASL_KEY));    setProperty(ZOOKEEPER_SERVER_REALM, System.getProperty(ZOOKEEPER_SERVER_REALM));    setProperty(DISABLE_AUTO_WATCH_RESET, System.getProperty(DISABLE_AUTO_WATCH_RESET));    setProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET, System.getProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET));    setProperty(SECURE_CLIENT, System.getProperty(SECURE_CLIENT));}
0
public boolean isSaslClientEnabled()
{    return Boolean.valueOf(getProperty(ENABLE_CLIENT_SASL_KEY, ENABLE_CLIENT_SASL_DEFAULT));}
0
public long getLong(String key, long defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Long.parseLong(value.trim());    }    return defaultValue;}
0
public static boolean isEnabled()
{    return Boolean.parseBoolean(System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT));}
0
public SaslState getSaslState()
{    return saslState;}
0
public String getLoginContext()
{    if (login != null) {        return login.getLoginContextName();    }    return null;}
0
public String getConfigStatus()
{    return configStatus;}
0
public boolean isComplete()
{    return (saslState == SaslState.COMPLETE);}
0
public boolean isFailed()
{    return (saslState == SaslState.FAILED);}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{                    ZooKeeperSaslClient client = ((ClientCnxn) ctx).zooKeeperSaslClient;    if (client == null) {                return;    }    byte[] usedata = data;    if (data != null) {            } else {        usedata = new byte[0];            }    client.respondToServer(usedata, (ClientCnxn) ctx);}
1
private SaslClient createSaslClient(final String servicePrincipal, final String loginContext) throws LoginException
{    try {        if (!initializedLogin) {            synchronized (this) {                if (login == null) {                                                                                login = new Login(loginContext, new SaslClientCallbackHandler(null, "Client"), clientConfig);                    login.startThreadIfNeeded();                    initializedLogin = true;                }            }        }        return SecurityUtils.createSaslClient(login.getSubject(), servicePrincipal, "zookeeper", "zk-sasl-md5", LOG, "Client");    } catch (LoginException e) {                throw e;    } catch (Exception e) {                        return null;    }}
1
private byte[] createSaslToken() throws SaslException
{    saslState = SaslState.INTERMEDIATE;    return createSaslToken(saslToken);}
0
private byte[] createSaslToken(final byte[] saslToken) throws SaslException
{    if (saslToken == null) {                saslState = SaslState.FAILED;        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    Subject subject = login.getSubject();    if (subject != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                                                return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's " + " received SASL token.";                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.";                }                error += " Zookeeper Client will go to AUTH_FAILED state.";                                saslState = SaslState.FAILED;                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
1
public byte[] run() throws SaslException
{        return saslClient.evaluateChallenge(saslToken);}
1
private void sendSaslPacket(byte[] saslToken, ClientCnxn cnxn) throws SaslException
{        GetSASLRequest request = new GetSASLRequest();    request.setToken(saslToken);    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server.", e);    }}
1
private void sendSaslPacket(ClientCnxn cnxn) throws SaslException
{        GetSASLRequest request = new GetSASLRequest();    request.setToken(createSaslToken());    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server due " + "to IOException:", e);    }}
1
public KeeperState getKeeperState()
{    if (saslClient != null) {        if (saslState == SaslState.FAILED) {            return KeeperState.AuthFailed;        }        if (saslClient.isComplete()) {            if (saslState == SaslState.INTERMEDIATE) {                saslState = SaslState.COMPLETE;                return KeeperState.SaslAuthenticated;            }        }    }        return null;}
0
public void initialize(ClientCnxn cnxn) throws SaslException
{    if (saslClient == null) {        saslState = SaslState.FAILED;        throw new SaslException("saslClient failed to initialize properly: it's null.");    }    if (saslState == SaslState.INITIAL) {        if (saslClient.hasInitialResponse()) {            sendSaslPacket(cnxn);        } else {            byte[] emptyToken = new byte[0];            sendSaslPacket(emptyToken, cnxn);        }        saslState = SaslState.INTERMEDIATE;    }}
0
public boolean clientTunneledAuthenticationInProgress()
{    if (!isSASLConfigured) {        return false;    }        try {        if ((clientConfig.getJaasConfKey() != null) || ((Configuration.getConfiguration() != null) && (Configuration.getConfiguration().getAppConfigurationEntry(clientConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)) != null))) {                        if (!isComplete() && !isFailed()) {                return true;            }                        if (!gotLastPacket) {                                return true;            }        }                return false;    } catch (SecurityException e) {                                return false;    }}
1
public void shutdown()
{    if (null != login) {        login.shutdown();    }}
0
public long getSessionId()
{    return sessionId;}
0
public byte[] getSessionPasswd()
{    return sessionPasswd;}
0
public int getSessionTimeout()
{    return negotiatedSessionTimeout;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    SocketAddress local = sendThread.getClientCnxnSocket().getLocalSocketAddress();    SocketAddress remote = sendThread.getClientCnxnSocket().getRemoteSocketAddress();    sb.append("sessionid:0x").append(Long.toHexString(getSessionId())).append(" local:").append(local).append(" remoteserver:").append(remote).append(" lastZxid:").append(lastZxid).append(" xid:").append(xid).append(" sent:").append(sendThread.getClientCnxnSocket().getSentCount()).append(" recv:").append(sendThread.getClientCnxnSocket().getRecvCount()).append(" queuedpkts:").append(outgoingQueue.size()).append(" pendingresp:").append(pendingQueue.size()).append(" queuedevents:").append(eventThread.waitingEvents.size());    return sb.toString();}
0
public void createBB()
{    try {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(-1, "len");        if (requestHeader != null) {            requestHeader.serialize(boa, "header");        }        if (request instanceof ConnectRequest) {            request.serialize(boa, "connect");                        boa.writeBool(readOnly, "readOnly");        } else if (request != null) {            request.serialize(boa, "request");        }        baos.close();        this.bb = ByteBuffer.wrap(baos.toByteArray());        this.bb.putInt(this.bb.capacity() - 4);        this.bb.rewind();    } catch (IOException e) {            }}
1
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("clientPath:" + clientPath);    sb.append(" serverPath:" + serverPath);    sb.append(" finished:" + finished);    sb.append(" header:: " + requestHeader);    sb.append(" replyHeader:: " + replyHeader);    sb.append(" request:: " + request);    sb.append(" response:: " + response);        return sb.toString().replaceAll("\r*\n+", " ");}
0
public void start()
{    sendThread.start();    eventThread.start();}
0
private static String makeThreadName(String suffix)
{    String name = Thread.currentThread().getName().replaceAll("-EventThread", "");    return name + suffix;}
0
public void queueEvent(WatchedEvent event)
{    queueEvent(event, null);}
0
private void queueEvent(WatchedEvent event, Set<Watcher> materializedWatchers)
{    if (event.getType() == EventType.None && sessionState == event.getState()) {        return;    }    sessionState = event.getState();    final Set<Watcher> watchers;    if (materializedWatchers == null) {                watchers = watcher.materialize(event.getState(), event.getType(), event.getPath());    } else {        watchers = new HashSet<Watcher>();        watchers.addAll(materializedWatchers);    }    WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);        waitingEvents.add(pair);}
0
public void queueCallback(AsyncCallback cb, int rc, String path, Object ctx)
{    waitingEvents.add(new LocalCallback(cb, rc, path, ctx));}
0
public void queuePacket(Packet packet)
{    if (wasKilled) {        synchronized (waitingEvents) {            if (isRunning) {                waitingEvents.add(packet);            } else {                processEvent(packet);            }        }    } else {        waitingEvents.add(packet);    }}
0
public void queueEventOfDeath()
{    waitingEvents.add(eventOfDeath);}
0
public void run()
{    try {        isRunning = true;        while (true) {            Object event = waitingEvents.take();            if (event == eventOfDeath) {                wasKilled = true;            } else {                processEvent(event);            }            if (wasKilled) {                synchronized (waitingEvents) {                    if (waitingEvents.isEmpty()) {                        isRunning = false;                        break;                    }                }            }        }    } catch (InterruptedException e) {            }    }
1
private void processEvent(Object event)
{    try {        if (event instanceof WatcherSetEventPair) {                        WatcherSetEventPair pair = (WatcherSetEventPair) event;            for (Watcher watcher : pair.watchers) {                try {                    watcher.process(pair.event);                } catch (Throwable t) {                                    }            }        } else if (event instanceof LocalCallback) {            LocalCallback lcb = (LocalCallback) event;            if (lcb.cb instanceof StatCallback) {                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof DataCallback) {                ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ACLCallback) {                ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ChildrenCallback) {                ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof Children2Callback) {                ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof StringCallback) {                ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {                ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {                ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);            } else {                ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);            }        } else {            Packet p = (Packet) event;            int rc = 0;            String clientPath = p.clientPath;            if (p.replyHeader.getErr() != 0) {                rc = p.replyHeader.getErr();            }            if (p.cb == null) {                            } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {                StatCallback cb = (StatCallback) p.cb;                if (rc == 0) {                    if (p.response instanceof ExistsResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());                    } else if (p.response instanceof SetDataResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());                    } else if (p.response instanceof SetACLResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());                    }                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetDataResponse) {                DataCallback cb = (DataCallback) p.cb;                GetDataResponse rsp = (GetDataResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetACLResponse) {                ACLCallback cb = (ACLCallback) p.cb;                GetACLResponse rsp = (GetACLResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetChildrenResponse) {                ChildrenCallback cb = (ChildrenCallback) p.cb;                GetChildrenResponse rsp = (GetChildrenResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetAllChildrenNumberResponse) {                AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;                GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());                } else {                    cb.processResult(rc, clientPath, p.ctx, -1);                }            } else if (p.response instanceof GetChildren2Response) {                Children2Callback cb = (Children2Callback) p.cb;                GetChildren2Response rsp = (GetChildren2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof CreateResponse) {                StringCallback cb = (StringCallback) p.cb;                CreateResponse rsp = (CreateResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof Create2Response) {                Create2Callback cb = (Create2Callback) p.cb;                Create2Response rsp = (Create2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof MultiResponse) {                MultiCallback cb = (MultiCallback) p.cb;                MultiResponse rsp = (MultiResponse) p.response;                if (rc == 0) {                    List<OpResult> results = rsp.getResultList();                    int newRc = rc;                    for (OpResult result : results) {                        if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {                            break;                        }                    }                    cb.processResult(newRc, clientPath, p.ctx, results);                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetEphemeralsResponse) {                EphemeralsCallback cb = (EphemeralsCallback) p.cb;                GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, p.ctx, rsp.getEphemerals());                } else {                    cb.processResult(rc, p.ctx, null);                }            } else if (p.cb instanceof VoidCallback) {                VoidCallback cb = (VoidCallback) p.cb;                cb.processResult(rc, clientPath, p.ctx);            }        }    } catch (Throwable t) {            }}
1
protected void finishPacket(Packet p)
{    int err = p.replyHeader.getErr();    if (p.watchRegistration != null) {        p.watchRegistration.register(err);    }        if (p.watchDeregistration != null) {        Map<EventType, Set<Watcher>> materializedWatchers = null;        try {            materializedWatchers = p.watchDeregistration.unregister(err);            for (Entry<EventType, Set<Watcher>> entry : materializedWatchers.entrySet()) {                Set<Watcher> watchers = entry.getValue();                if (watchers.size() > 0) {                    queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());                                                            p.replyHeader.setErr(Code.OK.intValue());                }            }        } catch (KeeperException.NoWatcherException nwe) {            p.replyHeader.setErr(nwe.code().intValue());        } catch (KeeperException ke) {            p.replyHeader.setErr(ke.code().intValue());        }    }    if (p.cb == null) {        synchronized (p) {            p.finished = true;            p.notifyAll();        }    } else {        p.finished = true;        eventThread.queuePacket(p);    }}
0
 void queueEvent(String clientPath, int err, Set<Watcher> materializedWatchers, EventType eventType)
{    KeeperState sessionState = KeeperState.SyncConnected;    if (KeeperException.Code.SESSIONEXPIRED.intValue() == err || KeeperException.Code.CONNECTIONLOSS.intValue() == err) {        sessionState = Event.KeeperState.Disconnected;    }    WatchedEvent event = new WatchedEvent(eventType, sessionState, clientPath);    eventThread.queueEvent(event, materializedWatchers);}
0
 void queueCallback(AsyncCallback cb, int rc, String path, Object ctx)
{    eventThread.queueCallback(cb, rc, path, ctx);}
0
private void conLossPacket(Packet p)
{    if (p.replyHeader == null) {        return;    }    switch(state) {        case AUTH_FAILED:            p.replyHeader.setErr(KeeperException.Code.AUTHFAILED.intValue());            break;        case CLOSED:            p.replyHeader.setErr(KeeperException.Code.SESSIONEXPIRED.intValue());            break;        default:            p.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());    }    finishPacket(p);}
0
public long getLastZxid()
{    return lastZxid;}
0
public String toString()
{    return "EndOfStreamException: " + getMessage();}
0
 void readResponse(ByteBuffer incomingBuffer) throws IOException
{    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);    ReplyHeader replyHdr = new ReplyHeader();    replyHdr.deserialize(bbia, "header");    if (replyHdr.getXid() == -2) {                if (LOG.isDebugEnabled()) {                    }        return;    }    if (replyHdr.getXid() == -4) {                if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {            state = States.AUTH_FAILED;            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            eventThread.queueEventOfDeath();        }        if (LOG.isDebugEnabled()) {                    }        return;    }    if (replyHdr.getXid() == -1) {                if (LOG.isDebugEnabled()) {                    }        WatcherEvent event = new WatcherEvent();        event.deserialize(bbia, "response");                if (chrootPath != null) {            String serverPath = event.getPath();            if (serverPath.compareTo(chrootPath) == 0) {                event.setPath("/");            } else if (serverPath.length() > chrootPath.length()) {                event.setPath(serverPath.substring(chrootPath.length()));            } else {                            }        }        WatchedEvent we = new WatchedEvent(event);        if (LOG.isDebugEnabled()) {                    }        eventThread.queueEvent(we);        return;    }        if (tunnelAuthInProgress()) {        GetSASLRequest request = new GetSASLRequest();        request.deserialize(bbia, "token");        zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);        return;    }    Packet packet;    synchronized (pendingQueue) {        if (pendingQueue.size() == 0) {            throw new IOException("Nothing in the queue, but got " + replyHdr.getXid());        }        packet = pendingQueue.remove();    }    /*             * Since requests are processed in order, we better get a response             * to the first request!             */    try {        if (packet.requestHeader.getXid() != replyHdr.getXid()) {            packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());            throw new IOException("Xid out of order. Got Xid " + replyHdr.getXid() + " with err " + replyHdr.getErr() + " expected Xid " + packet.requestHeader.getXid() + " for a packet with details: " + packet);        }        packet.replyHeader.setXid(replyHdr.getXid());        packet.replyHeader.setErr(replyHdr.getErr());        packet.replyHeader.setZxid(replyHdr.getZxid());        if (replyHdr.getZxid() > 0) {            lastZxid = replyHdr.getZxid();        }        if (packet.response != null && replyHdr.getErr() == 0) {            packet.response.deserialize(bbia, "response");        }        if (LOG.isDebugEnabled()) {                    }    } finally {        finishPacket(packet);    }}
1
 ZooKeeper.States getZkState()
{    return state;}
0
 ClientCnxnSocket getClientCnxnSocket()
{    return clientCnxnSocket;}
0
 void primeConnection() throws IOException
{        isFirstConnect = false;    long sessId = (seenRwServerBefore) ? sessionId : 0;    ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd);        if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {        List<String> dataWatches = zooKeeper.getDataWatches();        List<String> existWatches = zooKeeper.getExistWatches();        List<String> childWatches = zooKeeper.getChildWatches();        if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty()) {            Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();            Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();            Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();            long setWatchesLastZxid = lastZxid;            while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext()) {                List<String> dataWatchesBatch = new ArrayList<String>();                List<String> existWatchesBatch = new ArrayList<String>();                List<String> childWatchesBatch = new ArrayList<String>();                int batchLength = 0;                                while (batchLength < SET_WATCHES_MAX_LENGTH) {                    final String watch;                    if (dataWatchesIter.hasNext()) {                        watch = dataWatchesIter.next();                        dataWatchesBatch.add(watch);                    } else if (existWatchesIter.hasNext()) {                        watch = existWatchesIter.next();                        existWatchesBatch.add(watch);                    } else if (childWatchesIter.hasNext()) {                        watch = childWatchesIter.next();                        childWatchesBatch.add(watch);                    } else {                        break;                    }                    batchLength += watch.length();                }                SetWatches sw = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);                RequestHeader header = new RequestHeader(-8, OpCode.setWatches);                Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);                outgoingQueue.addFirst(packet);            }        }    }    for (AuthData id : authInfo) {        outgoingQueue.addFirst(new Packet(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, id.scheme, id.data), null, null));    }    outgoingQueue.addFirst(new Packet(null, null, conReq, null, null, readOnly));    clientCnxnSocket.connectionPrimed();    }
1
private List<String> prependChroot(List<String> paths)
{    if (chrootPath != null && !paths.isEmpty()) {        for (int i = 0; i < paths.size(); ++i) {            String clientPath = paths.get(i);            String serverPath;                        if (clientPath.length() == 1) {                serverPath = chrootPath;            } else {                serverPath = chrootPath + clientPath;            }            paths.set(i, serverPath);        }    }    return paths;}
0
private void sendPing()
{    lastPingSentNs = System.nanoTime();    RequestHeader h = new RequestHeader(-2, OpCode.ping);    queuePacket(h, null, null, null, null, null, null, null, null);}
0
private void startConnect(InetSocketAddress addr) throws IOException
{        saslLoginFailed = false;    if (!isFirstConnect) {        try {            Thread.sleep(r.nextInt(1000));        } catch (InterruptedException e) {                    }    }    state = States.CONNECTING;    String hostPort = addr.getHostString() + ":" + addr.getPort();    MDC.put("myid", hostPort);    setName(getName().replaceAll("\\(.*\\)", "(" + hostPort + ")"));    if (clientConfig.isSaslClientEnabled()) {        try {            if (zooKeeperSaslClient != null) {                zooKeeperSaslClient.shutdown();            }            zooKeeperSaslClient = new ZooKeeperSaslClient(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);        } catch (LoginException e) {                                                                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            saslLoginFailed = true;        }    }    logStartConnect(addr);    clientCnxnSocket.connect(addr);}
1
private void logStartConnect(InetSocketAddress addr)
{    String msg = "Opening socket connection to server " + addr;    if (zooKeeperSaslClient != null) {        msg += ". " + zooKeeperSaslClient.getConfigStatus();    }    }
1
public void run()
{    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();    int to;    long lastPingRwServer = Time.currentElapsedTime();        final int MAX_SEND_PING_INTERVAL = 10000;    InetSocketAddress serverAddress = null;    while (state.isAlive()) {        try {            if (!clientCnxnSocket.isConnected()) {                                if (closing) {                    break;                }                if (rwServerAddress != null) {                    serverAddress = rwServerAddress;                    rwServerAddress = null;                } else {                    serverAddress = hostProvider.next(1000);                }                startConnect(serverAddress);                clientCnxnSocket.updateLastSendAndHeard();            }            if (state.isConnected()) {                                if (zooKeeperSaslClient != null) {                    boolean sendAuthEvent = false;                    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {                        try {                            zooKeeperSaslClient.initialize(ClientCnxn.this);                        } catch (SaslException e) {                                                        state = States.AUTH_FAILED;                            sendAuthEvent = true;                        }                    }                    KeeperState authState = zooKeeperSaslClient.getKeeperState();                    if (authState != null) {                        if (authState == KeeperState.AuthFailed) {                                                        state = States.AUTH_FAILED;                            sendAuthEvent = true;                        } else {                            if (authState == KeeperState.SaslAuthenticated) {                                sendAuthEvent = true;                            }                        }                    }                    if (sendAuthEvent) {                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));                        if (state == States.AUTH_FAILED) {                            eventThread.queueEventOfDeath();                        }                    }                }                to = readTimeout - clientCnxnSocket.getIdleRecv();            } else {                to = connectTimeout - clientCnxnSocket.getIdleRecv();            }            if (to <= 0) {                String warnInfo;                warnInfo = "Client session timed out, have not heard from server in " + clientCnxnSocket.getIdleRecv() + "ms" + " for sessionid 0x" + Long.toHexString(sessionId);                                throw new SessionTimeoutException(warnInfo);            }            if (state.isConnected()) {                                                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);                                if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {                    sendPing();                    clientCnxnSocket.updateLastSend();                } else {                    if (timeToNextPing < to) {                        to = timeToNextPing;                    }                }            }                        if (state == States.CONNECTEDREADONLY) {                long now = Time.currentElapsedTime();                int idlePingRwServer = (int) (now - lastPingRwServer);                if (idlePingRwServer >= pingRwTimeout) {                    lastPingRwServer = now;                    idlePingRwServer = 0;                    pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);                    pingRwServer();                }                to = Math.min(to, pingRwTimeout - idlePingRwServer);            }            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);        } catch (Throwable e) {            if (closing) {                if (LOG.isDebugEnabled()) {                                                        }                break;            } else {                                if (e instanceof SessionExpiredException) {                                    } else if (e instanceof SessionTimeoutException) {                                    } else if (e instanceof EndOfStreamException) {                                    } else if (e instanceof RWServerFoundException) {                                    } else if (e instanceof SocketException) {                                    } else {                                    }                                                cleanAndNotifyState();            }        }    }    synchronized (state) {                        cleanup();    }    clientCnxnSocket.close();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "SendThread exited loop for session: 0x" + Long.toHexString(getSessionId()));}
1
private void cleanAndNotifyState()
{    cleanup();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();}
0
private void pingRwServer() throws RWServerFoundException
{    String result = null;    InetSocketAddress addr = hostProvider.next(0);        Socket sock = null;    BufferedReader br = null;    try {        sock = new Socket(addr.getHostString(), addr.getPort());        sock.setSoLinger(false, -1);        sock.setSoTimeout(1000);        sock.setTcpNoDelay(true);        sock.getOutputStream().write("isro".getBytes());        sock.getOutputStream().flush();        sock.shutdownOutput();        br = new BufferedReader(new InputStreamReader(sock.getInputStream()));        result = br.readLine();    } catch (ConnectException e) {        } catch (IOException e) {                    } finally {        if (sock != null) {            try {                sock.close();            } catch (IOException e) {                            }        }        if (br != null) {            try {                br.close();            } catch (IOException e) {                            }        }    }    if ("rw".equals(result)) {        pingRwTimeout = minPingRwTimeout;                        rwServerAddress = addr;        throw new RWServerFoundException("Majority server found at " + addr.getHostString() + ":" + addr.getPort());    }}
1
private void cleanup()
{    clientCnxnSocket.cleanup();    synchronized (pendingQueue) {        for (Packet p : pendingQueue) {            conLossPacket(p);        }        pendingQueue.clear();    }                Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        conLossPacket(p);        iter.remove();    }}
0
 void onConnected(int _negotiatedSessionTimeout, long _sessionId, byte[] _sessionPasswd, boolean isRO) throws IOException
{    negotiatedSessionTimeout = _negotiatedSessionTimeout;    if (negotiatedSessionTimeout <= 0) {        state = States.CLOSED;        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));        eventThread.queueEventOfDeath();        String warnInfo;        warnInfo = "Unable to reconnect to ZooKeeper service, session 0x" + Long.toHexString(sessionId) + " has expired";                throw new SessionExpiredException(warnInfo);    }    if (!readOnly && isRO) {            }    readTimeout = negotiatedSessionTimeout * 2 / 3;    connectTimeout = negotiatedSessionTimeout / hostProvider.size();    hostProvider.onConnected();    sessionId = _sessionId;    sessionPasswd = _sessionPasswd;    state = (isRO) ? States.CONNECTEDREADONLY : States.CONNECTED;    seenRwServerBefore |= !isRO;        KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));}
1
 void close()
{    state = States.CLOSED;    clientCnxnSocket.onClosing();}
0
 void testableCloseSocket() throws IOException
{    clientCnxnSocket.testableCloseSocket();}
0
public boolean tunnelAuthInProgress()
{        if (!clientConfig.isSaslClientEnabled()) {        return false;    }        if (saslLoginFailed) {        return false;    }        if (zooKeeperSaslClient == null) {        return true;    }        return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();}
0
public void sendPacket(Packet p) throws IOException
{    clientCnxnSocket.sendPacket(p);}
0
public void disconnect()
{    if (LOG.isDebugEnabled()) {            }    sendThread.close();    try {        sendThread.join();    } catch (InterruptedException ex) {            }    eventThread.queueEventOfDeath();    if (zooKeeperSaslClient != null) {        zooKeeperSaslClient.shutdown();    }}
1
public void close() throws IOException
{    if (LOG.isDebugEnabled()) {            }    try {        RequestHeader h = new RequestHeader();        h.setType(ZooDefs.OpCode.closeSession);        submitRequest(h, null, null, null);    } catch (InterruptedException e) {        } finally {        disconnect();    }}
1
public synchronized int getXid()
{        if (xid == Integer.MAX_VALUE) {        xid = 1;    }    return xid++;}
0
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return submitRequest(h, request, response, watchRegistration, null);}
0
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration) throws InterruptedException
{    ReplyHeader r = new ReplyHeader();    Packet packet = queuePacket(h, r, request, response, null, null, null, null, watchRegistration, watchDeregistration);    synchronized (packet) {        if (requestTimeout > 0) {                        waitForPacketFinish(r, packet);        } else {                        while (!packet.finished) {                packet.wait();            }        }    }    if (r.getErr() == Code.REQUESTTIMEOUT.intValue()) {        sendThread.cleanAndNotifyState();    }    return r;}
0
private void waitForPacketFinish(ReplyHeader r, Packet packet) throws InterruptedException
{    long waitStartTime = Time.currentElapsedTime();    while (!packet.finished) {        packet.wait(requestTimeout);        if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {                        r.setErr(Code.REQUESTTIMEOUT.intValue());            break;        }    }}
1
public void saslCompleted()
{    sendThread.getClientCnxnSocket().saslCompleted();}
0
public void sendPacket(Record request, Record response, AsyncCallback cb, int opCode) throws IOException
{            int xid = getXid();    RequestHeader h = new RequestHeader();    h.setXid(xid);    h.setType(opCode);    ReplyHeader r = new ReplyHeader();    r.setXid(xid);    Packet p = new Packet(h, r, request, response, null, false);    p.cb = cb;    sendThread.sendPacket(p);}
0
public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration)
{    return queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, watchRegistration, null);}
0
public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration)
{    Packet packet = null;                packet = new Packet(h, r, request, response, watchRegistration);    packet.cb = cb;    packet.ctx = ctx;    packet.clientPath = clientPath;    packet.serverPath = serverPath;    packet.watchDeregistration = watchDeregistration;        synchronized (state) {        if (!state.isAlive() || closing) {            conLossPacket(packet);        } else {                        if (h.getType() == OpCode.closeSession) {                closing = true;            }            outgoingQueue.add(packet);        }    }    sendThread.getClientCnxnSocket().packetAdded();    return packet;}
0
public void addAuthInfo(String scheme, byte[] auth)
{    if (!state.isAlive()) {        return;    }    authInfo.add(new AuthData(scheme, auth));    queuePacket(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, scheme, auth), null, null, null, null, null, null);}
0
 States getState()
{    return state;}
0
private void initRequestTimeout()
{    try {        requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);            } catch (NumberFormatException e) {                throw e;    }}
1
 void introduce(ClientCnxn.SendThread sendThread, long sessionId, LinkedBlockingDeque<Packet> outgoingQueue)
{    this.sendThread = sendThread;    this.sessionId = sessionId;    this.outgoingQueue = outgoingQueue;}
0
 void updateNow()
{    now = Time.currentElapsedTime();}
0
 int getIdleRecv()
{    return (int) (now - lastHeard);}
0
 int getIdleSend()
{    return (int) (now - lastSend);}
0
 long getSentCount()
{    return sentCount.get();}
0
 long getRecvCount()
{    return recvCount.get();}
0
 void updateLastHeard()
{    this.lastHeard = now;}
0
 void updateLastSend()
{    this.lastSend = now;}
0
 void updateLastSendAndHeard()
{    this.lastSend = now;    this.lastHeard = now;}
0
 void readLength() throws IOException
{    int len = incomingBuffer.getInt();    if (len < 0 || len >= packetLen) {        throw new IOException("Packet len " + len + " is out of range!");    }    incomingBuffer = ByteBuffer.allocate(len);}
0
protected void initProperties() throws IOException
{    try {        packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);            } catch (NumberFormatException e) {        String msg = MessageFormat.format("Configured value {0} for property {1} can not be parsed to int", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);                throw new IOException(msg);    }}
1
 boolean isConnected()
{            connectLock.lock();    try {        return channel != null || connectFuture != null;    } finally {        connectLock.unlock();    }}
0
private Bootstrap configureBootstrapAllocator(Bootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
0
 void connect(InetSocketAddress addr) throws IOException
{    firstConnect = new CountDownLatch(1);    Bootstrap bootstrap = new Bootstrap().group(eventLoopGroup).channel(NettyUtils.nioOrEpollSocketChannel()).option(ChannelOption.SO_LINGER, -1).option(ChannelOption.TCP_NODELAY, true).handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));    bootstrap = configureBootstrapAllocator(bootstrap);    bootstrap.validate();    connectLock.lock();    try {        connectFuture = bootstrap.connect(addr);        connectFuture.addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception {                                boolean connected = false;                connectLock.lock();                try {                    if (!channelFuture.isSuccess()) {                                                return;                    } else if (connectFuture == null) {                                                                                                                        channelFuture.channel().close();                        return;                    }                                        channel = channelFuture.channel();                    disconnected.set(false);                    initialized = false;                    lenBuffer.clear();                    incomingBuffer = lenBuffer;                    sendThread.primeConnection();                    updateNow();                    updateLastSendAndHeard();                    if (sendThread.tunnelAuthInProgress()) {                        waitSasl.drainPermits();                        needSasl.set(true);                        sendPrimePacket();                    } else {                        needSasl.set(false);                    }                    connected = true;                } finally {                    connectFuture = null;                    connectLock.unlock();                    if (connected) {                                            }                                                                                wakeupCnxn();                    firstConnect.countDown();                }            }        });    } finally {        connectLock.unlock();    }}
1
public void operationComplete(ChannelFuture channelFuture) throws Exception
{        boolean connected = false;    connectLock.lock();    try {        if (!channelFuture.isSuccess()) {                        return;        } else if (connectFuture == null) {                                                            channelFuture.channel().close();            return;        }                channel = channelFuture.channel();        disconnected.set(false);        initialized = false;        lenBuffer.clear();        incomingBuffer = lenBuffer;        sendThread.primeConnection();        updateNow();        updateLastSendAndHeard();        if (sendThread.tunnelAuthInProgress()) {            waitSasl.drainPermits();            needSasl.set(true);            sendPrimePacket();        } else {            needSasl.set(false);        }        connected = true;    } finally {        connectFuture = null;        connectLock.unlock();        if (connected) {                    }                                wakeupCnxn();        firstConnect.countDown();    }}
1
 void cleanup()
{    connectLock.lock();    try {        if (connectFuture != null) {            connectFuture.cancel(false);            connectFuture = null;        }        if (channel != null) {            channel.close().syncUninterruptibly();            channel = null;        }    } finally {        connectLock.unlock();    }    Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p == WakeupPacket.getInstance()) {            iter.remove();        }    }}
0
 void close()
{    eventLoopGroup.shutdownGracefully();}
0
 void saslCompleted()
{    needSasl.set(false);    waitSasl.release();}
0
 void connectionPrimed()
{}
0
 void packetAdded()
{}
0
 void onClosing()
{    firstConnect.countDown();    wakeupCnxn();    }
1
private void wakeupCnxn()
{    if (needSasl.get()) {        waitSasl.release();    }    outgoingQueue.add(WakeupPacket.getInstance());}
0
 void doTransport(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    try {        if (!firstConnect.await(waitTimeOut, TimeUnit.MILLISECONDS)) {            return;        }        Packet head = null;        if (needSasl.get()) {            if (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) {                return;            }        } else {            head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS);        }                if (!sendThread.getZkState().isAlive()) {                        addBack(head);            return;        }                if (disconnected.get()) {            addBack(head);            throw new EndOfStreamException("channel for sessionid 0x" + Long.toHexString(sessionId) + " is lost");        }        if (head != null) {            doWrite(pendingQueue, head, cnxn);        }    } finally {        updateNow();    }}
0
private void addBack(Packet head)
{    if (head != null && head != WakeupPacket.getInstance()) {        outgoingQueue.addFirst(head);    }}
0
private ChannelFuture sendPktAndFlush(Packet p)
{    return sendPkt(p, true);}
0
private ChannelFuture sendPktOnly(Packet p)
{    return sendPkt(p, false);}
0
private ChannelFuture sendPkt(Packet p, boolean doFlush)
{            p.createBB();    updateLastSend();    final ByteBuf writeBuffer = Unpooled.wrappedBuffer(p.bb);    final ChannelFuture result = doFlush ? channel.writeAndFlush(writeBuffer) : channel.write(writeBuffer);    result.addListener(onSendPktDoneListener);    return result;}
0
private void sendPrimePacket()
{        sendPktAndFlush(outgoingQueue.remove());}
0
private void doWrite(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn)
{    updateNow();    boolean anyPacketsSent = false;    while (true) {        if (p != WakeupPacket.getInstance()) {            if ((p.requestHeader != null) && (p.requestHeader.getType() != ZooDefs.OpCode.ping) && (p.requestHeader.getType() != ZooDefs.OpCode.auth)) {                p.requestHeader.setXid(cnxn.getXid());                synchronized (pendingQueue) {                    pendingQueue.add(p);                }            }            sendPktOnly(p);            anyPacketsSent = true;        }        if (outgoingQueue.isEmpty()) {            break;        }        p = outgoingQueue.remove();    }        if (anyPacketsSent) {        channel.flush();    }}
0
 void sendPacket(ClientCnxn.Packet p) throws IOException
{    if (channel == null) {        throw new IOException("channel has been closed");    }    sendPktAndFlush(p);}
0
 SocketAddress getRemoteSocketAddress()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.remoteAddress();}
0
 SocketAddress getLocalSocketAddress()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.localAddress();}
0
 void testableCloseSocket() throws IOException
{    Channel copiedChanRef = channel;    if (copiedChanRef != null) {        copiedChanRef.disconnect().awaitUninterruptibly();    }}
0
public static Packet getInstance()
{    return instance;}
0
protected void initChannel(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (clientConfig.getBoolean(ZKClientConfig.SECURE_CLIENT)) {        initSSL(pipeline);    }    pipeline.addLast("handler", new ZKClientHandler());}
0
private synchronized void initSSL(ChannelPipeline pipeline) throws SSLContextException
{    if (sslContext == null || sslEngine == null) {        try (X509Util x509Util = new ClientX509Util()) {            sslContext = x509Util.createSSLContext(clientConfig);            sslEngine = sslContext.createSSLEngine(host, port);            sslEngine.setUseClientMode(true);        }    }    pipeline.addLast("ssl", new SslHandler(sslEngine));    }
1
public void channelInactive(ChannelHandlerContext ctx) throws Exception
{        cleanup();}
1
private void cleanup()
{    if (!channelClosed.compareAndSet(false, true)) {        return;    }    disconnected.set(true);    onClosing();}
0
protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception
{    updateNow();    while (buf.isReadable()) {        if (incomingBuffer.remaining() > buf.readableBytes()) {            int newLimit = incomingBuffer.position() + buf.readableBytes();            incomingBuffer.limit(newLimit);        }        buf.readBytes(incomingBuffer);        incomingBuffer.limit(incomingBuffer.capacity());        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                lenBuffer.clear();                incomingBuffer = lenBuffer;                initialized = true;                updateLastHeard();            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    wakeupCnxn();}
0
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
{        cleanup();}
1
 static void setTestAllocator(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
0
 static void clearTestAllocator()
{    TEST_ALLOCATOR.set(null);}
0
 boolean isConnected()
{    return sockKey != null;}
0
 void doIO(Queue<Packet> pendingQueue, ClientCnxn cnxn) throws InterruptedException, IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    if (sockKey.isReadable()) {        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new EndOfStreamException("Unable to read additional data from server sessionid 0x" + Long.toHexString(sessionId) + ", likely server has closed socket");        }        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                enableRead();                if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {                                                            enableWrite();                }                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();                initialized = true;            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    if (sockKey.isWritable()) {        Packet p = findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress());        if (p != null) {            updateLastSend();                        if (p.bb == null) {                if ((p.requestHeader != null) && (p.requestHeader.getType() != OpCode.ping) && (p.requestHeader.getType() != OpCode.auth)) {                    p.requestHeader.setXid(cnxn.getXid());                }                p.createBB();            }            sock.write(p.bb);            if (!p.bb.hasRemaining()) {                sentCount.getAndIncrement();                outgoingQueue.removeFirstOccurrence(p);                if (p.requestHeader != null && p.requestHeader.getType() != OpCode.ping && p.requestHeader.getType() != OpCode.auth) {                    synchronized (pendingQueue) {                        pendingQueue.add(p);                    }                }            }        }        if (outgoingQueue.isEmpty()) {                                                                        disableWrite();        } else if (!initialized && p != null && !p.bb.hasRemaining()) {                                                                                                                        disableWrite();        } else {                        enableWrite();        }    }}
0
private Packet findSendablePacket(LinkedBlockingDeque<Packet> outgoingQueue, boolean tunneledAuthInProgres)
{    if (outgoingQueue.isEmpty()) {        return null;    }        if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {        return outgoingQueue.getFirst();    }                        Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p.requestHeader == null) {                        iter.remove();            outgoingQueue.addFirst(p);            return p;        } else {                                            }    }    return null;}
1
 void cleanup()
{    if (sockKey != null) {        SocketChannel sock = (SocketChannel) sockKey.channel();        sockKey.cancel();        try {            sock.socket().shutdownInput();        } catch (IOException e) {                    }        try {            sock.socket().shutdownOutput();        } catch (IOException e) {                    }        try {            sock.socket().close();        } catch (IOException e) {                    }        try {            sock.close();        } catch (IOException e) {                    }    }    try {        Thread.sleep(100);    } catch (InterruptedException e) {            }    sockKey = null;}
1
 void close()
{    try {        LOG.trace("Doing client selector close");        selector.close();        LOG.trace("Closed client selector");    } catch (IOException e) {            }}
1
 SocketChannel createSock() throws IOException
{    SocketChannel sock;    sock = SocketChannel.open();    sock.configureBlocking(false);    sock.socket().setSoLinger(false, -1);    sock.socket().setTcpNoDelay(true);    return sock;}
0
 void registerAndConnect(SocketChannel sock, InetSocketAddress addr) throws IOException
{    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);    boolean immediateConnect = sock.connect(addr);    if (immediateConnect) {        sendThread.primeConnection();    }}
0
 void connect(InetSocketAddress addr) throws IOException
{    SocketChannel sock = createSock();    try {        registerAndConnect(sock, addr);    } catch (IOException e) {                sock.close();        throw e;    }    initialized = false;    /*         * Reset incomingBuffer         */    lenBuffer.clear();    incomingBuffer = lenBuffer;}
1
 SocketAddress getRemoteSocketAddress()
{    return remoteSocketAddress;}
0
 SocketAddress getLocalSocketAddress()
{    return localSocketAddress;}
0
private void updateSocketAddresses()
{    Socket socket = ((SocketChannel) sockKey.channel()).socket();    localSocketAddress = socket.getLocalSocketAddress();    remoteSocketAddress = socket.getRemoteSocketAddress();}
0
 void packetAdded()
{    wakeupCnxn();}
0
 void onClosing()
{    wakeupCnxn();}
0
private synchronized void wakeupCnxn()
{    selector.wakeup();}
0
 void doTransport(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    selector.select(waitTimeOut);    Set<SelectionKey> selected;    synchronized (this) {        selected = selector.selectedKeys();    }                updateNow();    for (SelectionKey k : selected) {        SocketChannel sc = ((SocketChannel) k.channel());        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {            if (sc.finishConnect()) {                updateLastSendAndHeard();                updateSocketAddresses();                sendThread.primeConnection();            }        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {            doIO(pendingQueue, cnxn);        }    }    if (sendThread.getZkState().isConnected()) {        if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {            enableWrite();        }    }    selected.clear();}
0
 void testableCloseSocket() throws IOException
{                SelectionKey tmp = sockKey;    if (tmp != null) {        ((SocketChannel) tmp.channel()).socket().close();    }}
1
 void saslCompleted()
{    enableWrite();}
0
 synchronized void enableWrite()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) == 0) {        sockKey.interestOps(i | SelectionKey.OP_WRITE);    }}
0
private synchronized void disableWrite()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) != 0) {        sockKey.interestOps(i & (~SelectionKey.OP_WRITE));    }}
0
private synchronized void enableRead()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_READ) == 0) {        sockKey.interestOps(i | SelectionKey.OP_READ);    }}
0
 void connectionPrimed()
{    sockKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);}
0
 Selector getSelector()
{    return selector;}
0
 void sendPacket(Packet p) throws IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    p.createBB();    ByteBuffer pbb = p.bb;    sock.write(pbb);}
0
public void write(byte[] b, int off, int len) throws IOException
{    out.write(b, off, len);}
0
public void close() throws IOException
{    boolean triedToClose = false, success = false;    try {        flush();        ((FileOutputStream) out).getFD().sync();        triedToClose = true;        super.close();        success = true;    } finally {        if (success) {            boolean renamed = tmpFile.renameTo(origFile);            if (!renamed) {                                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {                    throw new IOException("Could not rename temporary file " + tmpFile + " to " + origFile);                }            }        } else {            if (!triedToClose) {                                                IOUtils.closeStream(out);            }                        if (!tmpFile.delete()) {                            }        }    }}
1
public void abort()
{    try {        super.close();    } catch (IOException ioe) {            }    if (!tmpFile.delete()) {            }}
1
protected String getConfigPrefix()
{    return "zookeeper.ssl.";}
0
protected boolean shouldVerifyClientHostname()
{    return false;}
0
public String getSslAuthProviderProperty()
{    return sslAuthProviderProperty;}
0
public synchronized State getState()
{    return state;}
0
 synchronized void waitForState(State desiredState) throws InterruptedException
{    while (this.state != desiredState) {        this.wait();    }}
0
private synchronized void setState(State newState)
{    state = newState;    this.notifyAll();}
0
private synchronized boolean compareAndSetState(State expected, State update)
{    if (state == expected) {        setState(update);        return true;    } else {        return false;    }}
0
private synchronized boolean compareAndSetState(State[] expectedStates, State update)
{    for (State expected : expectedStates) {        if (state == expected) {            setState(update);            return true;        }    }    return false;}
0
public void start()
{    if (!compareAndSetState(State.NEW, State.STARTING)) {                return;    }    this.watcherThread.start();}
0
public void stop()
{    if (compareAndSetState(new State[] { State.RUNNING, State.STARTING }, State.STOPPING)) {        watcherThread.interrupt();    }}
0
public void run()
{    try {                if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {                                    FileChangeWatcher.State state = FileChangeWatcher.this.getState();            if (state != FileChangeWatcher.State.STOPPING) {                throw new IllegalStateException("Unexpected state: " + state);            }            return;        }        runLoop();    } catch (Exception e) {                throw e;    } finally {        try {            watchService.close();        } catch (IOException e) {                    }                FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);    }}
1
private void runLoop()
{    while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {        WatchKey key;        try {            key = watchService.take();        } catch (InterruptedException | ClosedWatchServiceException e) {                        break;        }        for (WatchEvent<?> event : key.pollEvents()) {                        try {                callback.accept(event);            } catch (Throwable e) {                            }        }        boolean isKeyValid = key.reset();        if (!isKeyValid) {                                                                        break;        }    }}
1
 Builder<T> setKeyStorePath(String keyStorePath)
{    this.keyStorePath = Objects.requireNonNull(keyStorePath);    return this;}
0
 Builder<T> setTrustStorePath(String trustStorePath)
{    this.trustStorePath = Objects.requireNonNull(trustStorePath);    return this;}
0
 Builder<T> setKeyStorePassword(String keyStorePassword)
{    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);    return this;}
0
 Builder<T> setTrustStorePassword(String trustStorePassword)
{    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);    return this;}
0
 static FileKeyStoreLoader.Builder<? extends FileKeyStoreLoader> getBuilderForKeyStoreFileType(KeyStoreFileType type)
{    switch(Objects.requireNonNull(type)) {        case JKS:            return new JKSFileLoader.Builder();        case PEM:            return new PEMFileLoader.Builder();        case PKCS12:            return new PKCS12FileLoader.Builder();        default:            throw new AssertionError("Unexpected StoreFileType: " + type.name());    }}
0
public static void closeStream(Closeable stream)
{    cleanup(null, stream);}
0
public static void cleanup(Logger log, Closeable... closeables)
{    for (Closeable c : closeables) {        if (c != null) {            try {                c.close();            } catch (IOException e) {                if (log != null) {                                    }            }        }    }}
1
public static void copyBytes(InputStream in, OutputStream out, int buffSize, boolean close) throws IOException
{    try {        copyBytes(in, out, buffSize);        if (close) {            out.close();            out = null;            in.close();            in = null;        }    } finally {        if (close) {            closeStream(out);            closeStream(in);        }    }}
0
public static void copyBytes(InputStream in, OutputStream out, int buffSize) throws IOException
{    PrintStream ps = out instanceof PrintStream ? (PrintStream) out : null;    byte[] buf = new byte[buffSize];    int bytesRead = in.read(buf);    while (bytesRead >= 0) {        out.write(buf, 0, bytesRead);        if ((ps != null) && ps.checkError()) {            throw new IOException("Unable to write to output stream.");        }        bytesRead = in.read(buf);    }}
0
protected KeyStore keyStoreInstance() throws KeyStoreException
{    return KeyStore.getInstance("JKS");}
0
 JKSFileLoader build()
{    return new JKSFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
0
public String getPropertyValue()
{    return this.name();}
0
public String getDefaultFileExtension()
{    return defaultFileExtension;}
0
public static KeyStoreFileType fromPropertyValue(String propertyValue)
{    if (propertyValue == null || propertyValue.length() == 0) {        return null;    }    return KeyStoreFileType.valueOf(propertyValue.toUpperCase());}
0
public static KeyStoreFileType fromFilename(String filename)
{    int i = filename.lastIndexOf('.');    if (i >= 0) {        String extension = filename.substring(i);        for (KeyStoreFileType storeFileType : KeyStoreFileType.values()) {            if (storeFileType.getDefaultFileExtension().equals(extension)) {                return storeFileType;            }        }    }    throw new IllegalArgumentException("Unable to auto-detect store file type from file name: " + filename);}
0
public static KeyStoreFileType fromPropertyValueOrFileName(String propertyValue, String filename)
{    KeyStoreFileType result = KeyStoreFileType.fromPropertyValue(propertyValue);    if (result == null) {        result = KeyStoreFileType.fromFilename(filename);    }    return result;}
0
public static EventLoopGroup newNioOrEpollEventLoopGroup()
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup();    } else {        return new NioEventLoopGroup();    }}
0
public static EventLoopGroup newNioOrEpollEventLoopGroup(int nThreads)
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup(nThreads);    } else {        return new NioEventLoopGroup(nThreads);    }}
0
public static Class<? extends SocketChannel> nioOrEpollSocketChannel()
{    if (Epoll.isAvailable()) {        return EpollSocketChannel.class;    } else {        return NioSocketChannel.class;    }}
0
public static Class<? extends ServerSocketChannel> nioOrEpollServerSocketChannel()
{    if (Epoll.isAvailable()) {        return EpollServerSocketChannel.class;    } else {        return NioServerSocketChannel.class;    }}
0
public static int getClientReachableLocalInetAddressCount()
{    try {        Set<InetAddress> validInetAddresses = new HashSet<>();        Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();        for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {                if (inetAddress.isLinkLocalAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                if (inetAddress.isMulticastAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                if (inetAddress.isLoopbackAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                validInetAddresses.add(inetAddress);            }        }                return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;    } catch (SocketException ex) {                return DEFAULT_INET_ADDRESS_COUNT;    }}
1
public static String formatInetAddr(InetSocketAddress addr)
{    InetAddress ia = addr.getAddress();    if (ia == null) {        return String.format("%s:%s", addr.getHostString(), addr.getPort());    }    if (ia instanceof Inet6Address) {        return String.format("[%s]:%s", ia.getHostAddress(), addr.getPort());    } else {        return String.format("%s:%s", ia.getHostAddress(), addr.getPort());    }}
0
 TrieNode getParent()
{    return this.parent;}
0
 void setParent(TrieNode parent)
{    this.parent = parent;}
0
 void setProperty(boolean prop)
{    this.property = prop;}
0
 boolean hasProperty()
{    return this.property;}
0
public String getValue()
{    return this.value;}
0
 void addChild(String childName, TrieNode node)
{    this.children.putIfAbsent(childName, node);}
0
 void deleteChild(String childName)
{    this.children.computeIfPresent(childName, (key, childNode) -> {                childNode.setProperty(false);                if (childNode.isLeafNode()) {            childNode.setParent(null);            return null;        }        return childNode;    });}
0
 TrieNode getChild(String childName)
{    return this.children.get(childName);}
0
 Collection<String> getChildren()
{    return children.keySet();}
0
 boolean isLeafNode()
{    return children.isEmpty();}
0
public String toString()
{    return "TrieNode [name=" + value + ", property=" + property + ", children=" + children.keySet() + "]";}
0
public void addPath(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            TrieNode child = parent.getChild(part);            if (child == null) {                child = new TrieNode(parent, part);                parent.addChild(part, child);            }            parent = child;        }        parent.setProperty(true);    } finally {        writeLock.unlock();    }}
0
public void deletePath(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return;            }            parent = parent.getChild(part);                    }        final TrieNode realParent = parent.getParent();        realParent.deleteChild(parent.getValue());    } finally {        writeLock.unlock();    }}
1
public boolean existsNode(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    readLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return false;            }            parent = parent.getChild(part);                    }    } finally {        readLock.unlock();    }    return true;}
1
public String findMaxPrefix(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    readLock.lock();    try {        TrieNode parent = rootNode;        TrieNode deepestPropertyNode = null;        for (final String element : pathComponents) {            parent = parent.getChild(element);            if (parent == null) {                                break;            }            if (parent.hasProperty()) {                deepestPropertyNode = parent;            }        }        if (deepestPropertyNode == null) {            return "/";        }        final Deque<String> treePath = new ArrayDeque<>();        TrieNode node = deepestPropertyNode;        while (node != this.rootNode) {            treePath.offerFirst(node.getValue());            node = node.parent;        }        return "/" + String.join("/", treePath);    } finally {        readLock.unlock();    }}
1
public void clear()
{    writeLock.lock();    try {        rootNode.getChildren().clear();    } finally {        writeLock.unlock();    }}
0
public static void validatePath(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
0
public static void validatePath(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c <= '\u001f' || c >= '\u007f' && c <= '\u009F' || c >= '\ud800' && c <= '\uf8ff' || c >= '\ufff0' && c <= '\uffff') {            reason = "invalid character @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }}
0
public static String normalizeFileSystemPath(String path)
{    if (path != null) {        String osname = java.lang.System.getProperty("os.name");        if (osname.toLowerCase().contains("windows")) {            return path.replace('\\', '/');        }    }    return path;}
0
public KeyStore loadKeyStore() throws IOException, GeneralSecurityException
{    Optional<String> passwordOption;    if (keyStorePassword == null || keyStorePassword.length() == 0) {        passwordOption = Optional.empty();    } else {        passwordOption = Optional.of(keyStorePassword);    }    File file = new File(keyStorePath);    return PemReader.loadKeyStore(file, file, passwordOption);}
0
public KeyStore loadTrustStore() throws IOException, GeneralSecurityException
{    return PemReader.loadTrustStore(new File(trustStorePath));}
0
 PEMFileLoader build()
{    return new PEMFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
0
protected KeyStore keyStoreInstance() throws KeyStoreException
{    return KeyStore.getInstance("PKCS12");}
0
 PKCS12FileLoader build()
{    return new PKCS12FileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
0
protected String getConfigPrefix()
{    return "zookeeper.ssl.quorum.";}
0
protected boolean shouldVerifyClientHostname()
{    return true;}
0
public SSLContext getSSLContext()
{    return sslContext;}
0
public SSLSocket createSSLSocket() throws IOException
{    return configureSSLSocket((SSLSocket) sslContext.getSocketFactory().createSocket(), true);}
0
public SSLSocket createSSLSocket(Socket socket, byte[] pushbackBytes) throws IOException
{    SSLSocket sslSocket;    if (pushbackBytes != null && pushbackBytes.length > 0) {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, new ByteArrayInputStream(pushbackBytes), true);    } else {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, null, socket.getPort(), true);    }    return configureSSLSocket(sslSocket, false);}
0
public SSLServerSocket createSSLServerSocket() throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket();    return configureSSLServerSocket(sslServerSocket);}
0
public SSLServerSocket createSSLServerSocket(int port) throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket(port);    return configureSSLServerSocket(sslServerSocket);}
0
public SslContext createNettyJdkSslContext(SSLContext sslContext, boolean isClientSocket)
{    return new JdkSslContext(sslContext, isClientSocket, cipherSuitesAsList, IdentityCipherSuiteFilter.INSTANCE, null, isClientSocket ? X509Util.ClientAuth.NONE.toNettyClientAuth() : clientAuth.toNettyClientAuth(), enabledProtocols, false);}
0
public int getHandshakeDetectionTimeoutMillis()
{    return handshakeDetectionTimeoutMillis;}
0
private SSLSocket configureSSLSocket(SSLSocket socket, boolean isClientSocket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, isClientSocket);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(isClientSocket);    return socket;}
0
private SSLServerSocket configureSSLServerSocket(SSLServerSocket socket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, false);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(false);    return socket;}
0
private void configureSslParameters(SSLParameters sslParameters, boolean isClientSocket)
{    if (cipherSuites != null) {        if (LOG.isDebugEnabled()) {                    }        sslParameters.setCipherSuites(cipherSuites);    }    if (enabledProtocols != null) {        if (LOG.isDebugEnabled()) {                    }        sslParameters.setProtocols(enabledProtocols);    }    if (!isClientSocket) {        switch(clientAuth) {            case NEED:                sslParameters.setNeedClientAuth(true);                break;            case WANT:                sslParameters.setWantClientAuth(true);                break;            default:                                sslParameters.setNeedClientAuth(false);                break;        }    }}
1
private String[] getEnabledProtocols(final ZKConfig config, final SSLContext sslContext)
{    String enabledProtocolsInput = config.getProperty(x509Util.getSslEnabledProtocolsProperty());    if (enabledProtocolsInput == null) {        return new String[] { sslContext.getProtocol() };    }    return enabledProtocolsInput.split(",");}
0
private String[] getCipherSuites(final ZKConfig config)
{    String cipherSuitesInput = config.getProperty(x509Util.getSslCipherSuitesProperty());    if (cipherSuitesInput == null) {        return X509Util.getDefaultCipherSuites();    } else {        return cipherSuitesInput.split(",");    }}
0
private X509Util.ClientAuth getClientAuth(final ZKConfig config)
{    return X509Util.ClientAuth.fromPropertyValue(config.getProperty(x509Util.getSslClientAuthProperty()));}
0
private int getHandshakeDetectionTimeoutMillis(final ZKConfig config)
{    String propertyString = config.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    int result;    if (propertyString == null) {        result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } else {        result = Integer.parseInt(propertyString);        if (result < 1) {                                                result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;        }    }    return result;}
1
public KeyStore loadKeyStore() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(keyStorePath))) {        KeyStore ks = keyStoreInstance();        ks.load(inputStream, passwordStringToCharArray(keyStorePassword));        return ks;    }}
0
public KeyStore loadTrustStore() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(trustStorePath))) {        KeyStore ts = keyStoreInstance();        ts.load(inputStream, passwordStringToCharArray(trustStorePassword));        return ts;    }}
0
private static char[] passwordStringToCharArray(String password)
{    return password == null ? EMPTY_CHAR_ARRAY : password.toCharArray();}
0
public static List<String> split(String value, String separator)
{    String[] splits = value.split(separator);    List<String> results = new ArrayList<String>();    for (int i = 0; i < splits.length; i++) {        splits[i] = splits[i].trim();        if (splits[i].length() > 0) {            results.add(splits[i]);        }    }    return Collections.unmodifiableList(results);}
0
public static String joinStrings(List<String> list, String delim)
{    if (list == null) {        return null;    }    StringBuilder builder = new StringBuilder(list.get(0));    for (String s : list.subList(1, list.size())) {        builder.append(delim).append(s);    }    return builder.toString();}
0
public static long currentElapsedTime()
{    return System.nanoTime() / 1000000;}
0
public static long currentWallTime()
{    return System.currentTimeMillis();}
0
public static Date elapsedTimeToDate(long elapsedTime)
{    long wallTime = currentWallTime() + elapsedTime - currentElapsedTime();    return new Date(wallTime);}
0
private static String[] getGCMCiphers()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" };}
0
private static String[] getCBCCiphers()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA" };}
0
private static String[] concatArrays(String[] left, String[] right)
{    String[] result = new String[left.length + right.length];    System.arraycopy(left, 0, result, 0, left.length);    System.arraycopy(right, 0, result, left.length, right.length);    return result;}
0
public static ClientAuth fromPropertyValue(String prop)
{    if (prop == null || prop.length() == 0) {        return NEED;    }    return ClientAuth.valueOf(prop.toUpperCase());}
0
public io.netty.handler.ssl.ClientAuth toNettyClientAuth()
{    return nettyAuth;}
0
public String getSslProtocolProperty()
{    return sslProtocolProperty;}
0
public String getSslEnabledProtocolsProperty()
{    return sslEnabledProtocolsProperty;}
0
public String getCipherSuitesProperty()
{    return cipherSuitesProperty;}
0
public String getSslKeystoreLocationProperty()
{    return sslKeystoreLocationProperty;}
0
public String getSslCipherSuitesProperty()
{    return cipherSuitesProperty;}
0
public String getSslKeystorePasswdProperty()
{    return sslKeystorePasswdProperty;}
0
public String getSslKeystoreTypeProperty()
{    return sslKeystoreTypeProperty;}
0
public String getSslTruststoreLocationProperty()
{    return sslTruststoreLocationProperty;}
0
public String getSslTruststorePasswdProperty()
{    return sslTruststorePasswdProperty;}
0
public String getSslTruststoreTypeProperty()
{    return sslTruststoreTypeProperty;}
0
public String getSslContextSupplierClassProperty()
{    return sslContextSupplierClassProperty;}
0
public String getSslHostnameVerificationEnabledProperty()
{    return sslHostnameVerificationEnabledProperty;}
0
public String getSslCrlEnabledProperty()
{    return sslCrlEnabledProperty;}
0
public String getSslOcspEnabledProperty()
{    return sslOcspEnabledProperty;}
0
public String getSslClientAuthProperty()
{    return sslClientAuthProperty;}
0
public String getSslHandshakeDetectionTimeoutMillisProperty()
{    return sslHandshakeDetectionTimeoutMillisProperty;}
0
public SSLContext getDefaultSSLContext() throws X509Exception.SSLContextException
{    return getDefaultSSLContextAndOptions().getSSLContext();}
0
public SSLContext createSSLContext(ZKConfig config) throws SSLContextException
{    return createSSLContextAndOptions(config).getSSLContext();}
0
public SSLContextAndOptions getDefaultSSLContextAndOptions() throws X509Exception.SSLContextException
{    SSLContextAndOptions result = defaultSSLContextAndOptions.get();    if (result == null) {        result = createSSLContextAndOptions();        if (!defaultSSLContextAndOptions.compareAndSet(null, result)) {                        result = defaultSSLContextAndOptions.get();        }    }    return result;}
0
private void resetDefaultSSLContextAndOptions() throws X509Exception.SSLContextException
{    SSLContextAndOptions newContext = createSSLContextAndOptions();    defaultSSLContextAndOptions.set(newContext);}
0
private SSLContextAndOptions createSSLContextAndOptions() throws SSLContextException
{    /*         * Since Configuration initializes the key store and trust store related         * configuration from system property. Reading property from         * configuration will be same reading from system property         */    return createSSLContextAndOptions(zkConfig == null ? new ZKConfig() : zkConfig);}
0
public int getSslHandshakeTimeoutMillis()
{    try {        SSLContextAndOptions ctx = getDefaultSSLContextAndOptions();        return ctx.getHandshakeDetectionTimeoutMillis();    } catch (SSLContextException e) {                return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } catch (Exception e) {                return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    }}
1
public SSLContextAndOptions createSSLContextAndOptions(ZKConfig config) throws SSLContextException
{    final String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);    if (supplierContextClassName != null) {        if (LOG.isDebugEnabled()) {                    }        try {            Class<?> sslContextClass = Class.forName(supplierContextClassName);            Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();            return new SSLContextAndOptions(this, config, sslContextSupplier.get());        } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {            throw new SSLContextException("Could not retrieve the SSLContext from supplier source '" + supplierContextClassName + "' provided in the property '" + sslContextSupplierClassProperty + "'", e);        }    } else {        return createSSLContextAndOptionsFromConfig(config);    }}
1
public SSLContextAndOptions createSSLContextAndOptionsFromConfig(ZKConfig config) throws SSLContextException
{    KeyManager[] keyManagers = null;    TrustManager[] trustManagers = null;    String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty, "");    String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty, "");    String keyStoreTypeProp = config.getProperty(sslKeystoreTypeProperty);    if (keyStoreLocationProp.isEmpty()) {            } else {        try {            keyManagers = new KeyManager[] { createKeyManager(keyStoreLocationProp, keyStorePasswordProp, keyStoreTypeProp) };        } catch (KeyManagerException keyManagerException) {            throw new SSLContextException("Failed to create KeyManager", keyManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslKeystoreTypeProperty + ": " + keyStoreTypeProp, e);        }    }    String trustStoreLocationProp = config.getProperty(sslTruststoreLocationProperty, "");    String trustStorePasswordProp = config.getProperty(sslTruststorePasswdProperty, "");    String trustStoreTypeProp = config.getProperty(sslTruststoreTypeProperty);    boolean sslCrlEnabled = config.getBoolean(this.sslCrlEnabledProperty);    boolean sslOcspEnabled = config.getBoolean(this.sslOcspEnabledProperty);    boolean sslServerHostnameVerificationEnabled = config.getBoolean(this.getSslHostnameVerificationEnabledProperty(), true);    boolean sslClientHostnameVerificationEnabled = sslServerHostnameVerificationEnabled && shouldVerifyClientHostname();    if (trustStoreLocationProp.isEmpty()) {            } else {        try {            trustManagers = new TrustManager[] { createTrustManager(trustStoreLocationProp, trustStorePasswordProp, trustStoreTypeProp, sslCrlEnabled, sslOcspEnabled, sslServerHostnameVerificationEnabled, sslClientHostnameVerificationEnabled) };        } catch (TrustManagerException trustManagerException) {            throw new SSLContextException("Failed to create TrustManager", trustManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslTruststoreTypeProperty + ": " + trustStoreTypeProp, e);        }    }    String protocol = config.getProperty(sslProtocolProperty, DEFAULT_PROTOCOL);    try {        SSLContext sslContext = SSLContext.getInstance(protocol);        sslContext.init(keyManagers, trustManagers, null);        return new SSLContextAndOptions(this, config, sslContext);    } catch (NoSuchAlgorithmException | KeyManagementException sslContextInitException) {        throw new SSLContextException(sslContextInitException);    }}
1
public static KeyStore loadKeyStore(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(keyStoreTypeProp, keyStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setKeyStorePath(keyStoreLocation).setKeyStorePassword(keyStorePassword).build().loadKeyStore();}
0
public static KeyStore loadTrustStore(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(trustStoreTypeProp, trustStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setTrustStorePath(trustStoreLocation).setTrustStorePassword(trustStorePassword).build().loadTrustStore();}
0
public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws KeyManagerException
{    if (keyStorePassword == null) {        keyStorePassword = "";    }    try {        KeyStore ks = loadKeyStore(keyStoreLocation, keyStorePassword, keyStoreTypeProp);        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");        kmf.init(ks, keyStorePassword.toCharArray());        for (KeyManager km : kmf.getKeyManagers()) {            if (km instanceof X509KeyManager) {                return (X509KeyManager) km;            }        }        throw new KeyManagerException("Couldn't find X509KeyManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new KeyManagerException(e);    }}
0
public static X509TrustManager createTrustManager(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp, boolean crlEnabled, boolean ocspEnabled, final boolean serverHostnameVerificationEnabled, final boolean clientHostnameVerificationEnabled) throws TrustManagerException
{    if (trustStorePassword == null) {        trustStorePassword = "";    }    try {        KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);        PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());        if (crlEnabled || ocspEnabled) {            pbParams.setRevocationEnabled(true);            System.setProperty("com.sun.net.ssl.checkRevocation", "true");            System.setProperty("com.sun.security.enableCRLDP", "true");            if (ocspEnabled) {                Security.setProperty("ocsp.enable", "true");            }        } else {            pbParams.setRevocationEnabled(false);        }                TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");        tmf.init(new CertPathTrustManagerParameters(pbParams));        for (final TrustManager tm : tmf.getTrustManagers()) {            if (tm instanceof X509ExtendedTrustManager) {                return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);            }        }        throw new TrustManagerException("Couldn't find X509TrustManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new TrustManagerException(e);    }}
0
public SSLSocket createSSLSocket() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket();}
0
public SSLSocket createSSLSocket(Socket socket, byte[] pushbackBytes) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket(socket, pushbackBytes);}
0
public SSLServerSocket createSSLServerSocket() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket();}
0
public SSLServerSocket createSSLServerSocket(int port) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket(port);}
0
 static String[] getDefaultCipherSuites()
{    return getDefaultCipherSuitesForJavaVersion(System.getProperty("java.specification.version"));}
0
 static String[] getDefaultCipherSuitesForJavaVersion(String javaVersion)
{    Objects.requireNonNull(javaVersion);    if (javaVersion.matches("\\d+")) {                        return DEFAULT_CIPHERS_JAVA9;    } else if (javaVersion.startsWith("1.")) {                        return DEFAULT_CIPHERS_JAVA8;    } else {                return DEFAULT_CIPHERS_JAVA8;    }}
1
private FileChangeWatcher newFileChangeWatcher(String fileLocation) throws IOException
{    if (fileLocation == null || fileLocation.isEmpty()) {        return null;    }    final Path filePath = Paths.get(fileLocation).toAbsolutePath();    Path parentPath = filePath.getParent();    if (parentPath == null) {        throw new IOException("Key/trust store path does not have a parent: " + filePath);    }    return new FileChangeWatcher(parentPath, watchEvent -> {        handleWatchEvent(filePath, watchEvent);    });}
0
public void enableCertFileReloading() throws IOException
{        ZKConfig config = zkConfig == null ? new ZKConfig() : zkConfig;    FileChangeWatcher newKeyStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslKeystoreLocationProperty));    if (newKeyStoreFileWatcher != null) {                if (keyStoreFileWatcher != null) {            keyStoreFileWatcher.stop();        }        keyStoreFileWatcher = newKeyStoreFileWatcher;        keyStoreFileWatcher.start();    }    FileChangeWatcher newTrustStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslTruststoreLocationProperty));    if (newTrustStoreFileWatcher != null) {                if (trustStoreFileWatcher != null) {            trustStoreFileWatcher.stop();        }        trustStoreFileWatcher = newTrustStoreFileWatcher;        trustStoreFileWatcher.start();    }}
1
public void close()
{    if (keyStoreFileWatcher != null) {        keyStoreFileWatcher.stop();        keyStoreFileWatcher = null;    }    if (trustStoreFileWatcher != null) {        trustStoreFileWatcher.stop();        trustStoreFileWatcher = null;    }}
0
private void handleWatchEvent(Path filePath, WatchEvent<?> event)
{    boolean shouldResetContext = false;    Path dirPath = filePath.getParent();    if (event.kind().equals(StandardWatchEventKinds.OVERFLOW)) {                shouldResetContext = true;    } else if (event.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY) || event.kind().equals(StandardWatchEventKinds.ENTRY_CREATE)) {        Path eventFilePath = dirPath.resolve((Path) event.context());        if (filePath.equals(eventFilePath)) {            shouldResetContext = true;        }    }        if (shouldResetContext) {        if (LOG.isDebugEnabled()) {                    }        try {            this.resetDefaultSSLContextAndOptions();        } catch (SSLContextException e) {            throw new RuntimeException(e);        }    } else {        if (LOG.isDebugEnabled()) {                    }    }}
1
private void init()
{    /**     * backward compatibility for all currently available client properties     */    handleBackwardCompatibility();}
0
protected void handleBackwardCompatibility()
{    properties.put(JUTE_MAXBUFFER, System.getProperty(JUTE_MAXBUFFER));    properties.put(KINIT_COMMAND, System.getProperty(KINIT_COMMAND));    properties.put(JGSS_NATIVE, System.getProperty(JGSS_NATIVE));    try (ClientX509Util clientX509Util = new ClientX509Util()) {        putSSLProperties(clientX509Util);        properties.put(clientX509Util.getSslAuthProviderProperty(), System.getProperty(clientX509Util.getSslAuthProviderProperty()));    }    try (X509Util x509Util = new QuorumX509Util()) {        putSSLProperties(x509Util);    }}
0
private void putSSLProperties(X509Util x509Util)
{    properties.put(x509Util.getSslProtocolProperty(), System.getProperty(x509Util.getSslProtocolProperty()));    properties.put(x509Util.getSslEnabledProtocolsProperty(), System.getProperty(x509Util.getSslEnabledProtocolsProperty()));    properties.put(x509Util.getSslCipherSuitesProperty(), System.getProperty(x509Util.getSslCipherSuitesProperty()));    properties.put(x509Util.getSslKeystoreLocationProperty(), System.getProperty(x509Util.getSslKeystoreLocationProperty()));    properties.put(x509Util.getSslKeystorePasswdProperty(), System.getProperty(x509Util.getSslKeystorePasswdProperty()));    properties.put(x509Util.getSslKeystoreTypeProperty(), System.getProperty(x509Util.getSslKeystoreTypeProperty()));    properties.put(x509Util.getSslTruststoreLocationProperty(), System.getProperty(x509Util.getSslTruststoreLocationProperty()));    properties.put(x509Util.getSslTruststorePasswdProperty(), System.getProperty(x509Util.getSslTruststorePasswdProperty()));    properties.put(x509Util.getSslTruststoreTypeProperty(), System.getProperty(x509Util.getSslTruststoreTypeProperty()));    properties.put(x509Util.getSslContextSupplierClassProperty(), System.getProperty(x509Util.getSslContextSupplierClassProperty()));    properties.put(x509Util.getSslHostnameVerificationEnabledProperty(), System.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));    properties.put(x509Util.getSslCrlEnabledProperty(), System.getProperty(x509Util.getSslCrlEnabledProperty()));    properties.put(x509Util.getSslOcspEnabledProperty(), System.getProperty(x509Util.getSslOcspEnabledProperty()));    properties.put(x509Util.getSslClientAuthProperty(), System.getProperty(x509Util.getSslClientAuthProperty()));    properties.put(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), System.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty()));}
0
public String getProperty(String key)
{    return properties.get(key);}
0
public String getProperty(String key, String defaultValue)
{    String value = properties.get(key);    return (value == null) ? defaultValue : value;}
0
public String getJaasConfKey()
{    return System.getProperty(Environment.JAAS_CONF_KEY);}
0
public void setProperty(String key, String value)
{    if (null == key) {        throw new IllegalArgumentException("property key is null.");    }    String oldValue = properties.put(key, value);    if (LOG.isDebugEnabled()) {        if (null != oldValue && !oldValue.equals(value)) {                    }    }}
1
public void addConfiguration(File configFile) throws ConfigException
{        try {        configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).validate(configFile);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parseProperties(cfg);    } catch (IOException | IllegalArgumentException e) {                throw new ConfigException("Error while processing " + configFile.getAbsolutePath(), e);    }}
1
public void addConfiguration(String configPath) throws ConfigException
{    addConfiguration(new File(configPath));}
0
private void parseProperties(Properties cfg)
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        setProperty(key, value);    }}
0
public boolean getBoolean(String key)
{    return getBoolean(key, false);}
0
public boolean getBoolean(String key, boolean defaultValue)
{    String propertyValue = getProperty(key);    if (propertyValue == null) {        return defaultValue;    } else {        return Boolean.parseBoolean(propertyValue);    }}
0
public int getInt(String key, int defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Integer.parseInt(value.trim());    }    return defaultValue;}
0
 static SubjectName IP(final String value)
{    return new SubjectName(value, IP);}
0
 static SubjectName DNS(final String value)
{    return new SubjectName(value, DNS);}
0
public int getType()
{    return type;}
0
public String getValue()
{    return value;}
0
public String toString()
{    return value;}
0
 static boolean isIPv4Address(final String input)
{    return IPV4_PATTERN.matcher(input).matches();}
0
 static boolean isIPv6StdAddress(final String input)
{    return IPV6_STD_PATTERN.matcher(input).matches();}
0
 static boolean isIPv6HexCompressedAddress(final String input)
{    return IPV6_HEX_COMPRESSED_PATTERN.matcher(input).matches();}
0
 static boolean isIPv6Address(final String input)
{    return isIPv6StdAddress(input) || isIPv6HexCompressedAddress(input);}
0
public boolean verify(final String host, final SSLSession session)
{    try {        final Certificate[] certs = session.getPeerCertificates();        final X509Certificate x509 = (X509Certificate) certs[0];        verify(host, x509);        return true;    } catch (final SSLException ex) {        if (log.isDebugEnabled()) {                    }        return false;    }}
1
 void verify(final String host, final X509Certificate cert) throws SSLException
{    final HostNameType hostType = determineHostFormat(host);    final List<SubjectName> subjectAlts = getSubjectAltNames(cert);    if (subjectAlts != null && !subjectAlts.isEmpty()) {        switch(hostType) {            case IPv4:                matchIPAddress(host, subjectAlts);                break;            case IPv6:                matchIPv6Address(host, subjectAlts);                break;            default:                matchDNSName(host, subjectAlts);        }    } else {                        final X500Principal subjectPrincipal = cert.getSubjectX500Principal();        final String cn = extractCN(subjectPrincipal.getName(X500Principal.RFC2253));        if (cn == null) {            throw new SSLException("Certificate subject for <" + host + "> doesn't contain " + "a common name and does not have alternative names");        }        matchCN(host, cn);    }}
0
private static void matchIPAddress(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            if (host.equals(subjectAlt.getValue())) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
0
private static void matchIPv6Address(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalisedHost = normaliseAddress(host);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            final String normalizedSubjectAlt = normaliseAddress(subjectAlt.getValue());            if (normalisedHost.equals(normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
0
private static void matchDNSName(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.DNS) {            final String normalizedSubjectAlt = subjectAlt.getValue().toLowerCase(Locale.ROOT);            if (matchIdentityStrict(normalizedHost, normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
0
private static void matchCN(final String host, final String cn) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    final String normalizedCn = cn.toLowerCase(Locale.ROOT);    if (!matchIdentityStrict(normalizedHost, normalizedCn)) {        throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match " + "common name of the certificate subject: " + cn);    }}
0
private static boolean matchIdentity(final String host, final String identity, final boolean strict)
{                        final int asteriskIdx = identity.indexOf('*');    if (asteriskIdx != -1) {        final String prefix = identity.substring(0, asteriskIdx);        final String suffix = identity.substring(asteriskIdx + 1);        if (!prefix.isEmpty() && !host.startsWith(prefix)) {            return false;        }        if (!suffix.isEmpty() && !host.endsWith(suffix)) {            return false;        }                if (strict) {            final String remainder = host.substring(prefix.length(), host.length() - suffix.length());            return !remainder.contains(".");        }        return true;    }    return host.equalsIgnoreCase(identity);}
0
private static boolean matchIdentityStrict(final String host, final String identity)
{    return matchIdentity(host, identity, true);}
0
private static String extractCN(final String subjectPrincipal) throws SSLException
{    if (subjectPrincipal == null) {        return null;    }    try {        final LdapName subjectDN = new LdapName(subjectPrincipal);        final List<Rdn> rdns = subjectDN.getRdns();        for (int i = rdns.size() - 1; i >= 0; i--) {            final Rdn rds = rdns.get(i);            final Attributes attributes = rds.toAttributes();            final Attribute cn = attributes.get("cn");            if (cn != null) {                try {                    final Object value = cn.get();                    if (value != null) {                        return value.toString();                    }                } catch (final NoSuchElementException ignore) {                                } catch (final NamingException ignore) {                                }            }        }        return null;    } catch (final InvalidNameException e) {        throw new SSLException(subjectPrincipal + " is not a valid X500 distinguished name");    }}
0
private static HostNameType determineHostFormat(final String host)
{    if (InetAddressUtils.isIPv4Address(host)) {        return HostNameType.IPv4;    }    String s = host;    if (s.startsWith("[") && s.endsWith("]")) {        s = host.substring(1, host.length() - 1);    }    if (InetAddressUtils.isIPv6Address(s)) {        return HostNameType.IPv6;    }    return HostNameType.DNS;}
0
private static List<SubjectName> getSubjectAltNames(final X509Certificate cert)
{    try {        final Collection<List<?>> entries = cert.getSubjectAlternativeNames();        if (entries == null) {            return Collections.emptyList();        }        final List<SubjectName> result = new ArrayList<SubjectName>();        for (List<?> entry : entries) {            final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;            if (type != null) {                final String s = (String) entry.get(1);                result.add(new SubjectName(s, type));            }        }        return result;    } catch (final CertificateParsingException ignore) {        return Collections.emptyList();    }}
0
private static String normaliseAddress(final String hostname)
{    if (hostname == null) {        return hostname;    }    try {        final InetAddress inetAddress = InetAddress.getByName(hostname);        return inetAddress.getHostAddress();    } catch (final UnknownHostException unexpected) {                return hostname;    }}
0
public X509Certificate[] getAcceptedIssuers()
{    return x509ExtendedTrustManager.getAcceptedIssuers();}
0
public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, socket);    if (clientHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
0
public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, socket);    if (serverHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
0
public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);    if (clientHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
0
public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);    if (serverHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
0
public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType);}
0
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType);}
0
private void performHostVerification(InetAddress inetAddress, X509Certificate certificate) throws CertificateException
{    String hostAddress = "";    String hostName = "";    try {        hostAddress = inetAddress.getHostAddress();        hostnameVerifier.verify(hostAddress, certificate);    } catch (SSLException addressVerificationException) {        try {                        hostName = inetAddress.getHostName();            hostnameVerifier.verify(hostName, certificate);        } catch (SSLException hostnameVerificationException) {                                    throw new CertificateException("Failed to verify both host address and host name", hostnameVerificationException);        }    }}
1
public boolean isEphemeral()
{    return ephemeral;}
0
public boolean isSequential()
{    return sequential;}
0
public boolean isContainer()
{    return isContainer;}
0
public boolean isTTL()
{    return isTTL;}
0
public int toFlag()
{    return flag;}
0
public static CreateMode fromFlag(int flag) throws KeeperException
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            String errMsg = "Received an invalid flag value: " + flag + " to convert to a CreateMode";                        throw new KeeperException.BadArgumentsException(errMsg);    }}
1
public static CreateMode fromFlag(int flag, CreateMode defaultMode)
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            return defaultMode;    }}
0
public String getKey()
{    return k;}
0
public String getValue()
{    return v;}
0
public String toString()
{    return k + "=" + v;}
0
private static void put(List<Entry> l, String k, String v)
{    l.add(new Entry(k, v));}
0
public static List<Entry> list()
{    List<Entry> l = new ArrayList<Entry>();    put(l, "zookeeper.version", Version.getFullVersion());    try {        put(l, "host.name", InetAddress.getLocalHost().getCanonicalHostName());    } catch (UnknownHostException e) {        put(l, "host.name", "<NA>");    }    put(l, "java.version", System.getProperty("java.version", "<NA>"));    put(l, "java.vendor", System.getProperty("java.vendor", "<NA>"));    put(l, "java.home", System.getProperty("java.home", "<NA>"));    put(l, "java.class.path", System.getProperty("java.class.path", "<NA>"));    put(l, "java.library.path", System.getProperty("java.library.path", "<NA>"));    put(l, "java.io.tmpdir", System.getProperty("java.io.tmpdir", "<NA>"));    put(l, "java.compiler", System.getProperty("java.compiler", "<NA>"));    put(l, "os.name", System.getProperty("os.name", "<NA>"));    put(l, "os.arch", System.getProperty("os.arch", "<NA>"));    put(l, "os.version", System.getProperty("os.version", "<NA>"));    put(l, "user.name", System.getProperty("user.name", "<NA>"));    put(l, "user.home", System.getProperty("user.home", "<NA>"));    put(l, "user.dir", System.getProperty("user.dir", "<NA>"));        Runtime runtime = Runtime.getRuntime();    int mb = 1024 * 1024;    put(l, "os.memory.free", runtime.freeMemory() / mb + "MB");    put(l, "os.memory.max", runtime.maxMemory() / mb + "MB");    put(l, "os.memory.total", runtime.totalMemory() / mb + "MB");    return l;}
0
public static void logEnv(String msg, Logger log)
{    List<Entry> env = Environment.list();    for (Entry e : env) {            }}
1
public int complete(String buffer, int cursor, List candidates)
{        buffer = buffer.substring(0, cursor);    String token = "";    if (!buffer.endsWith(" ")) {        String[] tokens = buffer.split(" ");        if (tokens.length != 0) {            token = tokens[tokens.length - 1];        }    }    if (token.startsWith("/")) {        return completeZNode(buffer, token, candidates);    }    return completeCommand(buffer, token, candidates);}
0
private int completeCommand(String buffer, String token, List<String> candidates)
{    for (String cmd : ZooKeeperMain.getCommands()) {        if (cmd.startsWith(token)) {            candidates.add(cmd);        }    }    return buffer.lastIndexOf(" ") + 1;}
0
private int completeZNode(String buffer, String token, List<String> candidates)
{    String path = token;    int idx = path.lastIndexOf("/") + 1;    String prefix = path.substring(idx);    try {                String dir = idx == 1 ? "/" : path.substring(0, idx - 1);        List<String> children = zk.getChildren(dir, false);        for (String child : children) {            if (child.startsWith(prefix)) {                candidates.add(child);            }        }    } catch (InterruptedException e) {        return 0;    } catch (KeeperException e) {        return 0;    }    Collections.sort(candidates);    return candidates.size() == 0 ? buffer.length() : buffer.lastIndexOf("/") + 1;}
0
private static boolean isLog4jJmxEnabled()
{    boolean enabled = false;    try {        Class.forName("org.apache.log4j.spi.LoggerRepository");        if (Boolean.getBoolean("zookeeper.jmx.log4j.disable")) {                    } else {            enabled = true;                    }    } catch (ClassNotFoundException e) {            }    return enabled;}
1
public static void registerLog4jMBeans() throws JMException
{    if (isLog4jJmxEnabled()) {                MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();        try {                                    Object hdm = Class.forName("org.apache.log4j.jmx.HierarchyDynamicMBean").getConstructor().newInstance();            String mbean = System.getProperty("zookeeper.jmx.log4j.mbean", "log4j:hierarchy=default");            ObjectName mbo = new ObjectName(mbean);            mbs.registerMBean(hdm, mbo);                                                Object rootLogger = Class.forName("org.apache.log4j.Logger").getMethod("getRootLogger", (Class<?>[]) null).invoke(null, (Object[]) null);                        Object rootLoggerName = rootLogger.getClass().getMethod("getName", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);            hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, rootLoggerName);                                                            Object r = Class.forName("org.apache.log4j.LogManager").getMethod("getLoggerRepository", (Class<?>[]) null).invoke(null, (Object[]) null);                        Enumeration enumer = (Enumeration) r.getClass().getMethod("getCurrentLoggers", (Class<?>[]) null).invoke(r, (Object[]) null);            while (enumer.hasMoreElements()) {                Object logger = enumer.nextElement();                                Object loggerName = logger.getClass().getMethod("getName", (Class<?>[]) null).invoke(logger, (Object[]) null);                hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, loggerName);            }        } catch (Exception e) {                        throw new JMException(e.toString());        }    }}
1
public static void setInstance(MBeanRegistry instance)
{    MBeanRegistry.instance = instance;}
0
public static MBeanRegistry getInstance()
{    return instance;}
0
public MBeanServer getPlatformMBeanServer()
{    return mBeanServer;}
0
public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{    assert bean != null;    String path = null;    if (parent != null) {        path = mapBean2Path.get(parent);        assert path != null;    }    path = makeFullPath(path, parent);    if (bean.isHidden()) {        return;    }    ObjectName oname = makeObjectName(path, bean);    try {        synchronized (LOCK) {            mBeanServer.registerMBean(bean, oname);            mapBean2Path.put(bean, path);        }    } catch (JMException e) {                throw e;    }}
1
private void unregister(String path, ZKMBeanInfo bean) throws JMException
{    if (path == null) {        return;    }    if (!bean.isHidden()) {        final ObjectName objName = makeObjectName(path, bean);                synchronized (LOCK) {            mBeanServer.unregisterMBean(objName);        }    }}
1
public Set<ZKMBeanInfo> getRegisteredBeans()
{    return new HashSet<ZKMBeanInfo>(mapBean2Path.keySet());}
0
public void unregister(ZKMBeanInfo bean)
{    if (bean == null) {        return;    }    String path = mapBean2Path.remove(bean);    try {        unregister(path, bean);    } catch (JMException e) {            } catch (Throwable t) {            }}
1
public String makeFullPath(String prefix, String... name)
{    StringBuilder sb = new StringBuilder(prefix == null ? "/" : (prefix.equals("/") ? prefix : prefix + "/"));    boolean first = true;    for (String s : name) {        if (s == null) {            continue;        }        if (!first) {            sb.append("/");        } else {            first = false;        }        sb.append(s);    }    return sb.toString();}
0
protected String makeFullPath(String prefix, ZKMBeanInfo bean)
{    return makeFullPath(prefix, bean == null ? null : bean.getName());}
0
private int tokenize(StringBuilder sb, String path, int index)
{    String[] tokens = path.split("/");    for (String s : tokens) {        if (s.length() == 0) {            continue;        }        sb.append("name").append(index++).append("=").append(s).append(",");    }    return index;}
0
protected ObjectName makeObjectName(String path, ZKMBeanInfo bean) throws MalformedObjectNameException
{    if (path == null) {        return null;    }    StringBuilder beanName = new StringBuilder(DOMAIN + ":");    int counter = 0;    counter = tokenize(beanName, path, counter);    tokenize(beanName, bean.getName(), counter);    beanName.deleteCharAt(beanName.length() - 1);    try {        return new ObjectName(beanName.toString());    } catch (MalformedObjectNameException e) {                throw e;    }}
1
public static KeeperException create(Code code, String path)
{    KeeperException r = create(code);    r.path = path;    return r;}
0
public static KeeperException create(int code, String path)
{    KeeperException r = create(Code.get(code));    r.path = path;    return r;}
0
public static KeeperException create(int code)
{    return create(Code.get(code));}
0
public static KeeperException create(Code code)
{    switch(code) {        case SYSTEMERROR:            return new SystemErrorException();        case RUNTIMEINCONSISTENCY:            return new RuntimeInconsistencyException();        case DATAINCONSISTENCY:            return new DataInconsistencyException();        case CONNECTIONLOSS:            return new ConnectionLossException();        case MARSHALLINGERROR:            return new MarshallingErrorException();        case UNIMPLEMENTED:            return new UnimplementedException();        case OPERATIONTIMEOUT:            return new OperationTimeoutException();        case NEWCONFIGNOQUORUM:            return new NewConfigNoQuorum();        case RECONFIGINPROGRESS:            return new ReconfigInProgress();        case BADARGUMENTS:            return new BadArgumentsException();        case APIERROR:            return new APIErrorException();        case NONODE:            return new NoNodeException();        case NOAUTH:            return new NoAuthException();        case BADVERSION:            return new BadVersionException();        case NOCHILDRENFOREPHEMERALS:            return new NoChildrenForEphemeralsException();        case NODEEXISTS:            return new NodeExistsException();        case INVALIDACL:            return new InvalidACLException();        case AUTHFAILED:            return new AuthFailedException();        case NOTEMPTY:            return new NotEmptyException();        case SESSIONEXPIRED:            return new SessionExpiredException();        case INVALIDCALLBACK:            return new InvalidCallbackException();        case SESSIONMOVED:            return new SessionMovedException();        case NOTREADONLY:            return new NotReadOnlyException();        case EPHEMERALONLOCALSESSION:            return new EphemeralOnLocalSessionException();        case NOWATCHER:            return new NoWatcherException();        case RECONFIGDISABLED:            return new ReconfigDisabledException();        case SESSIONCLOSEDREQUIRESASLAUTH:            return new SessionClosedRequireAuthException();        case REQUESTTIMEOUT:            return new RequestTimeoutException();        case OK:        default:            throw new IllegalArgumentException("Invalid exception code");    }}
0
public void setCode(int code)
{    this.code = Code.get(code);}
0
public int intValue()
{    return code;}
0
public static Code get(int code)
{    return lookup.get(code);}
0
 static String getCodeMessage(Code code)
{    switch(code) {        case OK:            return "ok";        case SYSTEMERROR:            return "SystemError";        case RUNTIMEINCONSISTENCY:            return "RuntimeInconsistency";        case DATAINCONSISTENCY:            return "DataInconsistency";        case CONNECTIONLOSS:            return "ConnectionLoss";        case MARSHALLINGERROR:            return "MarshallingError";        case NEWCONFIGNOQUORUM:            return "NewConfigNoQuorum";        case RECONFIGINPROGRESS:            return "ReconfigInProgress";        case UNIMPLEMENTED:            return "Unimplemented";        case OPERATIONTIMEOUT:            return "OperationTimeout";        case BADARGUMENTS:            return "BadArguments";        case APIERROR:            return "APIError";        case NONODE:            return "NoNode";        case NOAUTH:            return "NoAuth";        case BADVERSION:            return "BadVersion";        case NOCHILDRENFOREPHEMERALS:            return "NoChildrenForEphemerals";        case NODEEXISTS:            return "NodeExists";        case INVALIDACL:            return "InvalidACL";        case AUTHFAILED:            return "AuthFailed";        case NOTEMPTY:            return "Directory not empty";        case SESSIONEXPIRED:            return "Session expired";        case INVALIDCALLBACK:            return "Invalid callback";        case SESSIONMOVED:            return "Session moved";        case NOTREADONLY:            return "Not a read-only call";        case EPHEMERALONLOCALSESSION:            return "Ephemeral node on local session";        case NOWATCHER:            return "No such watcher";        case RECONFIGDISABLED:            return "Reconfig is disabled";        case SESSIONCLOSEDREQUIRESASLAUTH:            return "Session closed because client failed to authenticate";        default:            return "Unknown error " + code;    }}
0
public int getCode()
{    return code.code;}
0
public Code code()
{    return code;}
0
public String getPath()
{    return path;}
0
public String getMessage()
{    if (path == null || path.isEmpty()) {        return "KeeperErrorCode = " + getCodeMessage(code);    }    return "KeeperErrorCode = " + getCodeMessage(code) + " for " + path;}
0
 void setMultiResults(List<OpResult> results)
{    this.results = results;}
0
public List<OpResult> getResults()
{    return results != null ? new ArrayList<OpResult>(results) : null;}
0
public void startThreadIfNeeded()
{        if (t != null) {        t.start();    }}
0
public void shutdown()
{    if ((t != null) && (t.isAlive())) {        t.interrupt();        try {            t.join();        } catch (InterruptedException e) {                    }    }}
1
public Subject getSubject()
{    return subject;}
0
public String getLoginContextName()
{    return loginContextName;}
0
private synchronized LoginContext login(final String loginContextName) throws LoginException
{    if (loginContextName == null) {        throw new LoginException("loginContext name (JAAS file section header) was null. " + "Please check your java.security.login.auth.config (=" + System.getProperty("java.security.login.auth.config") + ") and your " + getLoginContextMessage());    }    LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);    loginContext.login();        return loginContext;}
1
private String getLoginContextMessage()
{    if (zkConfig instanceof ZKClientConfig) {        return ZKClientConfig.LOGIN_CONTEXT_NAME_KEY + "(=" + zkConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT) + ")";    } else {        return ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + "(=" + System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME) + ")";    }}
0
private long getRefreshTime(KerberosTicket tgt)
{    long start = tgt.getStartTime().getTime();    long expires = tgt.getEndTime().getTime();            long proposedRefresh = start + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));    if (proposedRefresh > expires) {                return Time.currentWallTime();    } else {        return proposedRefresh;    }}
1
private synchronized KerberosTicket getTGT()
{    Set<KerberosTicket> tickets = subject.getPrivateCredentials(KerberosTicket.class);    for (KerberosTicket ticket : tickets) {        KerberosPrincipal server = ticket.getServer();        if (server.getName().equals("krbtgt/" + server.getRealm() + "@" + server.getRealm())) {                                    return ticket;        }    }    return null;}
1
private boolean hasSufficientTimeElapsed()
{    long now = Time.currentElapsedTime();    if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) {                return false;    }        setLastLogin(now);    return true;}
1
private LoginContext getLogin()
{    return login;}
0
private void setLogin(LoginContext login)
{    this.login = login;}
0
private void setLastLogin(long time)
{    lastLogin = time;}
0
private long getLastLogin()
{    return lastLogin;}
0
private synchronized void reLogin() throws LoginException
{    if (!isKrbTicket) {        return;    }    LoginContext login = getLogin();    if (login == null) {        throw new LoginException("login must be done first");    }    if (!hasSufficientTimeElapsed()) {        return;    }        synchronized (Login.class) {                                login.logout();                        login = new LoginContext(loginContextName, getSubject());                login.login();        setLogin(login);    }}
1
 void inc()
{    add(1);}
0
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{}
0
public void start() throws MetricsProviderLifeCycleException
{}
0
public MetricsContext getRootContext()
{    return rootMetricsContext;}
0
public void stop()
{        rootMetricsContext.gauges.clear();}
0
public void dump(BiConsumer<String, Object> sink)
{    rootMetricsContext.dump(sink);}
0
public void resetAllValues()
{    rootMetricsContext.reset();}
0
public MetricsContext getContext(String name)
{        return this;}
0
public Counter getCounter(String name)
{    return counters.computeIfAbsent(name, (n) -> {        return new SimpleCounter(n);    });}
0
public void registerGauge(String name, Gauge gauge)
{    Objects.requireNonNull(gauge, "Cannot register a null Gauge for " + name);    gauges.put(name, gauge);}
0
public void unregisterGauge(String name)
{    gauges.remove(name);}
0
public Summary getSummary(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new AvgMinMaxCounter(name);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new AvgMinMaxPercentileCounter(name);        });    }}
0
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new AvgMinMaxCounterSet(name);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new AvgMinMaxPercentileCounterSet(name);        });    }}
0
 void dump(BiConsumer<String, Object> sink)
{    gauges.forEach((name, metric) -> {        Number value = metric.get();        if (value != null) {            sink.accept(name, value);        }    });    counters.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    summaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });    summarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });}
0
 void reset()
{    counters.values().forEach(metric -> {        metric.reset();    });    basicSummaries.values().forEach(metric -> {        metric.reset();    });    summaries.values().forEach(metric -> {        metric.reset();    });    basicSummarySets.values().forEach(metric -> {        metric.reset();    });    summarySets.values().forEach(metric -> {        metric.reset();    });}
0
public static MetricsProvider startMetricsProvider(String metricsProviderClassName, Properties configuration) throws MetricsProviderLifeCycleException
{    try {        Class<?> clazz = Class.forName(metricsProviderClassName, true, Thread.currentThread().getContextClassLoader());        MetricsProvider metricsProvider = (MetricsProvider) clazz.getConstructor().newInstance();        metricsProvider.configure(configuration);        metricsProvider.start();        return metricsProvider;    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException error) {                throw new MetricsProviderLifeCycleException("Cannot boot MetricsProvider " + metricsProviderClassName, error);    } catch (MetricsProviderLifeCycleException error) {                throw error;    }}
1
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{}
0
public void start() throws MetricsProviderLifeCycleException
{}
0
public MetricsContext getRootContext()
{    return NullMetricsContext.INSTANCE;}
0
public void dump(BiConsumer<String, Object> sink)
{}
0
public void resetAllValues()
{}
0
public void stop()
{}
0
public MetricsContext getContext(String name)
{    return INSTANCE;}
0
public Counter getCounter(String name)
{    return NullCounter.INSTANCE;}
0
public void registerGauge(String name, Gauge gauge)
{}
0
public void unregisterGauge(String name)
{}
0
public Summary getSummary(String name, DetailLevel detailLevel)
{    return NullSummary.INSTANCE;}
0
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    return NullSummarySet.INSTANCE;}
0
public void add(long delta)
{}
0
public long get()
{    return 0;}
0
public void add(long value)
{}
0
public void add(String key, long value)
{}
0
public Iterator<Op> iterator()
{    return ops.iterator();}
0
public void add(Op op) throws IllegalArgumentException
{    setOrCheckOpKind(op.getKind());    ops.add(op);}
0
public int size()
{    return ops.size();}
0
public Op.OpKind getOpKind()
{    return opKind;}
0
private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException
{    if (opKind == null) {        opKind = ok;    } else if (ok != opKind) {        throw new IllegalArgumentException("Mixing read and write operations (transactions)" + " is not allowed in a multi request.");    }}
0
public void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (Op op : ops) {        MultiHeader h = new MultiHeader(op.getType(), false, -1);        h.serialize(archive, tag);        switch(op.getType()) {            case ZooDefs.OpCode.create:            case ZooDefs.OpCode.create2:            case ZooDefs.OpCode.createTTL:            case ZooDefs.OpCode.createContainer:            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.setData:            case ZooDefs.OpCode.check:            case ZooDefs.OpCode.getChildren:            case ZooDefs.OpCode.getData:                op.toRequestRecord().serialize(archive, tag);                break;            default:                throw new IOException("Invalid type of op");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
0
public void deserialize(InputArchive archive, String tag) throws IOException
{    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    try {        while (!h.getDone()) {            switch(h.getType()) {                case ZooDefs.OpCode.create:                case ZooDefs.OpCode.create2:                case ZooDefs.OpCode.createContainer:                    CreateRequest cr = new CreateRequest();                    cr.deserialize(archive, tag);                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));                    break;                case ZooDefs.OpCode.createTTL:                    CreateTTLRequest crTtl = new CreateTTLRequest();                    crTtl.deserialize(archive, tag);                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));                    break;                case ZooDefs.OpCode.delete:                    DeleteRequest dr = new DeleteRequest();                    dr.deserialize(archive, tag);                    add(Op.delete(dr.getPath(), dr.getVersion()));                    break;                case ZooDefs.OpCode.setData:                    SetDataRequest sdr = new SetDataRequest();                    sdr.deserialize(archive, tag);                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));                    break;                case ZooDefs.OpCode.check:                    CheckVersionRequest cvr = new CheckVersionRequest();                    cvr.deserialize(archive, tag);                    add(Op.check(cvr.getPath(), cvr.getVersion()));                    break;                case ZooDefs.OpCode.getChildren:                    GetChildrenRequest gcr = new GetChildrenRequest();                    gcr.deserialize(archive, tag);                    add(Op.getChildren(gcr.getPath()));                    break;                case ZooDefs.OpCode.getData:                    GetDataRequest gdr = new GetDataRequest();                    gdr.deserialize(archive, tag);                    add(Op.getData(gdr.getPath()));                    break;                default:                    throw new IOException("Invalid type of op");            }            h.deserialize(archive, tag);        }    } catch (IllegalArgumentException e) {        throw new IOException("Mixing different kind of ops");    }    archive.endRecord(tag);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiOperationRecord)) {        return false;    }    MultiOperationRecord that = (MultiOperationRecord) o;    if (ops != null) {        Iterator<Op> other = that.ops.iterator();        for (Op op : ops) {            boolean hasMoreData = other.hasNext();            if (!hasMoreData) {                return false;            }            Op otherOp = other.next();            if (!op.equals(otherOp)) {                return false;            }        }        return !other.hasNext();    } else {        return that.ops == null;    }}
0
public int hashCode()
{    int h = 1023;    for (Op op : ops) {        h = h * 25 + op.hashCode();    }    return h;}
0
public void add(OpResult x)
{    results.add(x);}
0
public Iterator<OpResult> iterator()
{    return results.iterator();}
0
public int size()
{    return results.size();}
0
public void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (OpResult result : results) {        int err = result.getType() == ZooDefs.OpCode.error ? ((OpResult.ErrorResult) result).getErr() : 0;        new MultiHeader(result.getType(), false, err).serialize(archive, tag);        switch(result.getType()) {            case ZooDefs.OpCode.create:                new CreateResponse(((OpResult.CreateResult) result).getPath()).serialize(archive, tag);                break;            case ZooDefs.OpCode.create2:                OpResult.CreateResult createResult = (OpResult.CreateResult) result;                new Create2Response(createResult.getPath(), createResult.getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.check:                break;            case ZooDefs.OpCode.setData:                new SetDataResponse(((OpResult.SetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getChildren:                new GetChildrenResponse(((OpResult.GetChildrenResult) result).getChildren()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getData:                new GetDataResponse(((OpResult.GetDataResult) result).getData(), ((OpResult.GetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.error:                new ErrorResponse(((OpResult.ErrorResult) result).getErr()).serialize(archive, tag);                break;            default:                throw new IOException("Invalid type " + result.getType() + " in MultiResponse");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
0
public void deserialize(InputArchive archive, String tag) throws IOException
{    results = new ArrayList<OpResult>();    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    while (!h.getDone()) {        switch(h.getType()) {            case ZooDefs.OpCode.create:                CreateResponse cr = new CreateResponse();                cr.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr.getPath()));                break;            case ZooDefs.OpCode.create2:                Create2Response cr2 = new Create2Response();                cr2.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr2.getPath(), cr2.getStat()));                break;            case ZooDefs.OpCode.delete:                results.add(new OpResult.DeleteResult());                break;            case ZooDefs.OpCode.setData:                SetDataResponse sdr = new SetDataResponse();                sdr.deserialize(archive, tag);                results.add(new OpResult.SetDataResult(sdr.getStat()));                break;            case ZooDefs.OpCode.check:                results.add(new OpResult.CheckResult());                break;            case ZooDefs.OpCode.getChildren:                GetChildrenResponse gcr = new GetChildrenResponse();                gcr.deserialize(archive, tag);                results.add(new OpResult.GetChildrenResult(gcr.getChildren()));                break;            case ZooDefs.OpCode.getData:                GetDataResponse gdr = new GetDataResponse();                gdr.deserialize(archive, tag);                results.add(new OpResult.GetDataResult(gdr.getData(), gdr.getStat()));                break;            case ZooDefs.OpCode.error:                                ErrorResponse er = new ErrorResponse();                er.deserialize(archive, tag);                results.add(new OpResult.ErrorResult(er.getErr()));                break;            default:                throw new IOException("Invalid type " + h.getType() + " in MultiResponse");        }        h.deserialize(archive, tag);    }    archive.endRecord(tag);}
0
public List<OpResult> getResultList()
{    return results;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiResponse)) {        return false;    }    MultiResponse other = (MultiResponse) o;    if (results != null) {        Iterator<OpResult> i = other.results.iterator();        for (OpResult result : results) {            if (i.hasNext()) {                if (!result.equals(i.next())) {                    return false;                }            } else {                return false;            }        }        return !i.hasNext();    } else {        return other.results == null;    }}
0
public int hashCode()
{    int hash = results.size();    for (OpResult result : results) {        hash = (hash * 35) + result.hashCode();    }    return hash;}
0
public static Op create(String path, byte[] data, List<ACL> acl, int flags)
{    return new Create(path, data, acl, flags);}
0
public static Op create(String path, byte[] data, List<ACL> acl, int flags, long ttl)
{    CreateMode createMode = CreateMode.fromFlag(flags, CreateMode.PERSISTENT);    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, flags);}
0
public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    return new Create(path, data, acl, createMode);}
0
public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode, long ttl)
{    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, createMode);}
0
public static Op delete(String path, int version)
{    return new Delete(path, version);}
0
public static Op setData(String path, byte[] data, int version)
{    return new SetData(path, data, version);}
0
public static Op check(String path, int version)
{    return new Check(path, version);}
0
public static Op getChildren(String path)
{    return new GetChildren(path);}
0
public static Op getData(String path)
{    return new GetData(path);}
0
public int getType()
{    return type;}
0
public String getPath()
{    return path;}
0
public OpKind getKind()
{    return opKind;}
0
 void validate() throws KeeperException
{    PathUtils.validatePath(path);}
0
private static int getOpcode(CreateMode createMode)
{    if (createMode.isTTL()) {        return ZooDefs.OpCode.createTTL;    }    return createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Create)) {        return false;    }    Create op = (Create) o;    boolean aclEquals = true;    Iterator<ACL> i = op.acl.iterator();    for (ACL acl : op.acl) {        boolean hasMoreData = i.hasNext();        if (!hasMoreData) {            aclEquals = false;            break;        }        ACL otherAcl = i.next();        if (!acl.equals(otherAcl)) {            aclEquals = false;            break;        }    }    return !i.hasNext() && getType() == op.getType() && Arrays.equals(data, op.data) && flags == op.flags && aclEquals;}
0
public int hashCode()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data);}
0
public Record toRequestRecord()
{    return new CreateRequest(getPath(), data, acl, flags);}
0
 Op withChroot(String path)
{    return new Create(path, data, acl, flags);}
0
 void validate() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);}
0
public boolean equals(Object o)
{    return super.equals(o) && (o instanceof CreateTTL) && (ttl == ((CreateTTL) o).ttl);}
0
public int hashCode()
{    return super.hashCode() + (int) (ttl ^ (ttl >>> 32));}
0
public Record toRequestRecord()
{    return new CreateTTLRequest(getPath(), data, acl, flags, ttl);}
0
 Op withChroot(String path)
{    return new CreateTTL(path, data, acl, flags, ttl);}
0
 void validate() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Delete)) {        return false;    }    Delete op = (Delete) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath());}
0
public int hashCode()
{    return getType() + getPath().hashCode() + version;}
0
public Record toRequestRecord()
{    return new DeleteRequest(getPath(), version);}
0
 Op withChroot(String path)
{    return new Delete(path, version);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetData)) {        return false;    }    SetData op = (SetData) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath()) && Arrays.equals(data, op.data);}
0
public int hashCode()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data) + version;}
0
public Record toRequestRecord()
{    return new SetDataRequest(getPath(), data, version);}
0
 Op withChroot(String path)
{    return new SetData(path, data, version);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Check)) {        return false;    }    Check op = (Check) o;    return getType() == op.getType() && getPath().equals(op.getPath()) && version == op.version;}
0
public int hashCode()
{    return getType() + getPath().hashCode() + version;}
0
public Record toRequestRecord()
{    return new CheckVersionRequest(getPath(), version);}
0
 Op withChroot(String path)
{    return new Check(path, version);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildren)) {        return false;    }    GetChildren op = (GetChildren) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
0
public int hashCode()
{    return getType() + getPath().hashCode();}
0
public Record toRequestRecord()
{    return new GetChildrenRequest(getPath(), false);}
0
 Op withChroot(String path)
{    return new GetChildren(path);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetData)) {        return false;    }    GetData op = (GetData) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
0
public int hashCode()
{    return getType() + getPath().hashCode();}
0
public Record toRequestRecord()
{    return new GetDataRequest(getPath(), false);}
0
 Op withChroot(String path)
{    return new GetData(path);}
0
public int getType()
{    return type;}
0
public String getPath()
{    return path;}
0
public Stat getStat()
{    return stat;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CreateResult)) {        return false;    }    CreateResult other = (CreateResult) o;    boolean statsAreEqual = stat == null && other.stat == null || (stat != null && other.stat != null && stat.getMzxid() == other.stat.getMzxid());    return getType() == other.getType() && path.equals(other.getPath()) && statsAreEqual;}
0
public int hashCode()
{    return (int) (getType() * 35 + path.hashCode() + (stat == null ? 0 : stat.getMzxid()));}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof DeleteResult)) {        return false;    }    DeleteResult opResult = (DeleteResult) o;    return getType() == opResult.getType();}
0
public int hashCode()
{    return getType();}
0
public Stat getStat()
{    return stat;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetDataResult)) {        return false;    }    SetDataResult other = (SetDataResult) o;    return getType() == other.getType() && stat.getMzxid() == other.stat.getMzxid();}
0
public int hashCode()
{    return (int) (getType() * 35 + stat.getMzxid());}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CheckResult)) {        return false;    }    CheckResult other = (CheckResult) o;    return getType() == other.getType();}
0
public int hashCode()
{    return getType();}
0
public List<String> getChildren()
{    return children;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildrenResult)) {        return false;    }    GetChildrenResult other = (GetChildrenResult) o;    return getType() == other.getType() && children.equals(other.children);}
0
public int hashCode()
{    return getType() * 35 + children.hashCode();}
0
public byte[] getData()
{    return data == null ? null : Arrays.copyOf(data, data.length);}
0
public Stat getStat()
{    return stat;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetDataResult)) {        return false;    }    GetDataResult other = (GetDataResult) o;    return getType() == other.getType() && stat.equals(other.stat) && Arrays.equals(data, other.data);}
0
public int hashCode()
{    return (int) (getType() * 35 + stat.getMzxid() + Arrays.hashCode(data));}
0
public int getErr()
{    return err;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof ErrorResult)) {        return false;    }    ErrorResult other = (ErrorResult) o;    return getType() == other.getType() && err == other.getErr();}
0
public int hashCode()
{    return getType() * 35 + err;}
0
public static String quotaPath(String path)
{    return quotaZookeeper + path + "/" + limitNode;}
0
public static String statPath(String path)
{    return quotaZookeeper + path + "/" + statNode;}
0
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            NameCallback nc = (NameCallback) callback;            nc.setName(nc.getDefaultName());        } else {            if (callback instanceof PasswordCallback) {                PasswordCallback pc = (PasswordCallback) callback;                if (password != null) {                    pc.setPassword(this.password.toCharArray());                } else {                                    }            } else {                if (callback instanceof RealmCallback) {                    RealmCallback rc = (RealmCallback) callback;                    rc.setText(rc.getDefaultText());                } else {                    if (callback instanceof AuthorizeCallback) {                        AuthorizeCallback ac = (AuthorizeCallback) callback;                        String authid = ac.getAuthenticationID();                        String authzid = ac.getAuthorizationID();                        if (authid.equals(authzid)) {                            ac.setAuthorized(true);                        } else {                            ac.setAuthorized(false);                        }                        if (ac.isAuthorized()) {                            ac.setAuthorizedID(authzid);                        }                    } else {                        throw new UnsupportedCallbackException(callback, "Unrecognized SASL " + entity + "Callback");                    }                }            }        }    }}
1
 static String getServerPrincipal(InetSocketAddress addr, ZKClientConfig clientConfig)
{    return getServerPrincipal(new WrapperInetSocketAddress(addr), clientConfig);}
0
 static String getServerPrincipal(WrapperInetSocketAddress addr, ZKClientConfig clientConfig)
{    String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME, ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);    String hostName = addr.getHostName();    boolean canonicalize = true;    String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);    try {        canonicalize = Boolean.parseBoolean(canonicalizeText);    } catch (IllegalArgumentException ea) {            }    if (canonicalize) {        WrapperInetAddress ia = addr.getAddress();        if (ia == null) {            throw new IllegalArgumentException("Unable to canonicalize address " + addr + " because it's not resolvable");        }        String canonicalHostName = ia.getCanonicalHostName();                if (!canonicalHostName.equals(ia.getHostAddress())) {            hostName = canonicalHostName;        }            }    String serverPrincipal = principalUserName + "/" + hostName;    return serverPrincipal;}
1
public String getHostName()
{    return addr.getHostName();}
0
public WrapperInetAddress getAddress()
{    InetAddress ia = addr.getAddress();    return ia == null ? null : new WrapperInetAddress(ia);}
0
public String toString()
{    return addr.toString();}
0
public String getCanonicalHostName()
{    return ia.getCanonicalHostName();}
0
public String getHostAddress()
{    return ia.getHostAddress();}
0
public String toString()
{    return ia.toString();}
0
public static AdminServer createAdminServer()
{    if (!"false".equals(System.getProperty("zookeeper.admin.enableServer"))) {        try {            Class<?> jettyAdminServerC = Class.forName("org.apache.zookeeper.server.admin.JettyAdminServer");            Object adminServer = jettyAdminServerC.getConstructor().newInstance();            return (AdminServer) adminServer;        } catch (ClassNotFoundException e) {                    } catch (InstantiationException e) {                    } catch (IllegalAccessException e) {                    } catch (InvocationTargetException e) {                    } catch (NoSuchMethodException e) {                    } catch (NoClassDefFoundError e) {                    }    }    return new DummyAdminServer();}
1
public String getPrimaryName()
{    return primaryName;}
0
public Set<String> getNames()
{    return names;}
0
public String getDoc()
{    return doc;}
0
public boolean isServerRequired()
{    return serverRequired;}
0
protected CommandResponse initializeResponse()
{    return new CommandResponse(primaryName);}
0
public String getCommand()
{    return command;}
0
public String getError()
{    return error;}
0
public Object put(String key, Object value)
{    return data.put(key, value);}
0
public void putAll(Map<? extends String, ?> m)
{    data.putAll(m);}
0
public Map<String, Object> toMap()
{    Map<String, Object> m = new LinkedHashMap<String, Object>(data);    m.put(KEY_COMMAND, command);    m.put(KEY_ERROR, error);    m.putAll(data);    return m;}
0
public static void registerCommand(Command command)
{    for (String name : command.getNames()) {        Command prev = commands.put(name, command);        if (prev != null) {                    }    }    primaryNames.add(command.getPrimaryName());}
1
public static CommandResponse runCommand(String cmdName, ZooKeeperServer zkServer, Map<String, String> kwargs)
{    Command command = getCommand(cmdName);    if (command == null) {        return new CommandResponse(cmdName, "Unknown command: " + cmdName);    }    if (command.isServerRequired() && (zkServer == null || !zkServer.isRunning())) {        return new CommandResponse(cmdName, "This ZooKeeper instance is not currently serving requests");    }    return command.run(zkServer, kwargs);}
0
public static Set<String> getPrimaryNames()
{    return primaryNames;}
0
public static Command getCommand(String cmdName)
{    return commands.get(cmdName);}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.getServerCnxnFactory().resetAllConnectionStats();    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.putAll(zkServer.getConf().toMap());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    ServerCnxnFactory serverCnxnFactory = zkServer.getServerCnxnFactory();    if (serverCnxnFactory != null) {        response.put("connections", serverCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("connections", Collections.emptyList());    }    ServerCnxnFactory secureServerCnxnFactory = zkServer.getSecureServerCnxnFactory();    if (secureServerCnxnFactory != null) {        response.put("secure_connections", secureServerCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("secure_connections", Collections.emptyList());    }    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("datadir_size", zkServer.getDataDirSize());    response.put("logdir_size", zkServer.getLogDirSize());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("expiry_time_to_session_ids", zkServer.getSessionExpiryMap());    response.put("session_id_to_ephemeral_paths", zkServer.getEphemerals());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    for (Entry e : Environment.list()) {        response.put(e.getKey(), e.getValue());    }    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("digests", zkServer.getZKDatabase().getDataTree().getDigestLog());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("tracemask", ZooTrace.getTextTraceLevel());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("initial_configuration", zkServer.getInitialConfig());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    SnapshotInfo info = zkServer.getTxnLogFactory().getLastSnapshotInfo();    response.put("zxid", Long.toHexString(info == null ? -1L : info.zxid));    response.put("timestamp", info == null ? -1L : info.timestamp);    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        response.put("is_leader", zkServer instanceof LeaderZooKeeperServer);        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        response.put("leader_id", peer.getLeaderId());        String leaderAddress = peer.getLeaderAddress();        response.put("leader_ip", leaderAddress != null ? leaderAddress : "");    } else {        response.put("error", "server is not initialized");    }    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.dumpMonitorValues(response::put);    ServerMetrics.getMetrics().getMetricsProvider().dump(response::put);    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        leader.resetObserverConnectionStats();    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        follower.resetObserverConnectionStats();    }    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    return initializeResponse();}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    long traceMask;    if (!kwargs.containsKey("traceMask")) {        response.put("error", "setTraceMask requires long traceMask argument");        return response;    }    try {        traceMask = Long.parseLong(kwargs.get("traceMask"));    } catch (NumberFormatException e) {        response.put("error", "setTraceMask requires long traceMask argument, got " + kwargs.get("traceMask"));        return response;    }    ZooTrace.setTextTraceLevel(traceMask);    response.put("tracemask", traceMask);    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();        response.put("version", Version.getFullVersion());    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    response.put("server_stats", zkServer.serverStats());    response.put("client_response", zkServer.serverStats().getClientResponseStats());    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("proposal_stats", leader.getProposalStats());    }    response.put("node_count", zkServer.getZKDatabase().getNodeCount());    return response;}
1
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = super.run(zkServer, kwargs);    response.put("connections", zkServer.getServerCnxnFactory().getAllConnectionInfo(true));    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.serverStats().reset();    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("synced_observers", leader.getObservingLearners().size());        response.put("observers", leader.getObservingLearnersInfo());        return response;    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        Integer syncedObservers = follower.getSyncedObserverSize();        if (syncedObservers != null) {            response.put("synced_observers", syncedObservers);            response.put("observers", follower.getSyncedObserversInfo());            return response;        }    }    response.put("synced_observers", 0);    response.put("observers", Collections.emptySet());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    Properties systemProperties = System.getProperties();    SortedMap<String, String> sortedSystemProperties = new TreeMap<>();    systemProperties.forEach((k, v) -> sortedSystemProperties.put(k.toString(), v.toString()));    response.putAll(sortedSystemProperties);    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        VotingView votingView = new VotingView(peer.getVotingView());        response.put("current_config", votingView);    } else {        response.put("current_config", Collections.emptyMap());    }    return response;}
0
public Map<Long, String> getView()
{    return view;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("session_id_to_watched_paths", dt.getWatches().toMap());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("path_to_session_ids", dt.getWatchesByPath().toMap());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.putAll(dt.getWatchesSummary().toMap());    return response;}
0
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        QuorumPeer.ZabState zabState = peer.getZabState();        QuorumVerifier qv = peer.getQuorumVerifier();        QuorumPeer.QuorumServer voter = qv.getVotingMembers().get(peer.getId());        boolean voting = (voter != null && voter.addr.equals(peer.getQuorumAddress()) && voter.electionAddr.equals(peer.getElectionAddress()));        response.put("voting", voting);        response.put("zabstate", zabState.name().toLowerCase());    } else {        response.put("voting", false);        response.put("zabstate", "");    }    return response;}
0
public void start() throws AdminServerException
{}
0
public void shutdown() throws AdminServerException
{}
0
public void setZooKeeperServer(ZooKeeperServer zkServer)
{}
0
public void start() throws AdminServerException
{    try {        server.start();    } catch (Exception e) {                        String message = String.format("Problem starting AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }    }
1
public void shutdown() throws AdminServerException
{    try {        server.stop();    } catch (Exception e) {        String message = String.format("Problem stopping AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }}
0
public void setZooKeeperServer(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
0
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{        String cmd = request.getPathInfo();    if (cmd == null || cmd.equals("/")) {                for (String link : commandLinks()) {            response.getWriter().println(link);            response.getWriter().println("<br/>");        }        return;    }        cmd = cmd.substring(1);        @SuppressWarnings("unchecked")    Map<String, String[]> parameterMap = request.getParameterMap();    Map<String, String> kwargs = new HashMap<String, String>();    for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {        kwargs.put(entry.getKey(), entry.getValue()[0]);    }        CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs);        CommandOutputter outputter = new JsonOutputter();    response.setStatus(HttpServletResponse.SC_OK);    response.setContentType(outputter.getContentType());    outputter.output(cmdResponse, response.getWriter());}
0
private List<String> commandLinks()
{    List<String> links = new ArrayList<String>();    List<String> commands = new ArrayList<String>(Commands.getPrimaryNames());    Collections.sort(commands);    for (String command : commands) {        String url = commandUrl + "/" + command;        links.add(String.format("<a href=\"%s\">%s</a>", url, command));    }    return links;}
0
public String getContentType()
{    return "application/json";}
0
public void output(CommandResponse response, PrintWriter pw)
{    try {        mapper.writeValue(pw, response.toMap());    } catch (JsonGenerationException e) {                pw.write(ERROR_RESPONSE);    } catch (JsonMappingException e) {                pw.write(ERROR_RESPONSE);    } catch (IOException e) {                pw.write(ERROR_RESPONSE);    }}
1
public InetSocketAddress getLocalAddress()
{    return endPoint.getLocalAddress();}
0
public InetSocketAddress getRemoteAddress()
{    return endPoint.getRemoteAddress();}
0
public boolean isOpen()
{    return endPoint.isOpen();}
0
public long getCreatedTimeStamp()
{    return endPoint.getCreatedTimeStamp();}
0
public boolean isOutputShutdown()
{    return endPoint.isOutputShutdown();}
0
public boolean isInputShutdown()
{    return endPoint.isInputShutdown();}
0
public void shutdownOutput()
{    endPoint.shutdownOutput();}
0
public void close()
{    endPoint.close();}
0
public Object getTransport()
{    return endPoint.getTransport();}
0
public long getIdleTimeout()
{    return endPoint.getIdleTimeout();}
0
public Connection getConnection()
{    return endPoint.getConnection();}
0
public void onOpen()
{    endPoint.onOpen();}
0
public void onClose()
{    endPoint.onClose();}
0
public boolean isOptimizedForDirectBuffers()
{    return endPoint.isOptimizedForDirectBuffers();}
0
public boolean isFillInterested()
{    return endPoint.isFillInterested();}
0
public boolean tryFillInterested(Callback v)
{    return endPoint.tryFillInterested(v);}
0
public boolean flush(ByteBuffer... v) throws IOException
{    return endPoint.flush(v);}
0
public void setIdleTimeout(long v)
{    endPoint.setIdleTimeout(v);}
0
public void write(Callback v, ByteBuffer... b) throws WritePendingException
{    endPoint.write(v, b);}
0
public void setConnection(Connection v)
{    endPoint.setConnection(v);}
0
public void upgrade(Connection v)
{    endPoint.upgrade(v);}
0
public void fillInterested(Callback v) throws ReadPendingException
{    endPoint.fillInterested(v);}
0
private synchronized void readAhead() throws IOException
{    if (leftToRead > 0) {        int n = 0;        do {            n = endPoint.fill(start);        } while (n == 0 && endPoint.isOpen() && !endPoint.isInputShutdown());        if (n == -1) {            leftToRead = -1;        } else {            leftToRead -= n;        }        if (leftToRead <= 0) {            start.rewind();        }    }}
0
private int readFromStart(final ByteBuffer dst) throws IOException
{    final int n = Math.min(dst.remaining(), start.remaining());    if (n > 0) {        dst.put(bytes, start.position(), n);        start.position(start.position() + n);        dst.flip();    }    return n;}
0
public synchronized int fill(final ByteBuffer dst) throws IOException
{    throwPendingException();    if (leftToRead > 0) {        readAhead();    }    if (leftToRead > 0) {        return 0;    }    final int sr = start.remaining();    if (sr > 0) {        dst.compact();        final int n = readFromStart(dst);        if (n < sr) {            return n;        }    }    return sr + endPoint.fill(dst);}
0
public byte[] getBytes()
{    if (pendingException == null) {        try {            readAhead();        } catch (IOException e) {            pendingException = e;        }    }    byte[] ret = new byte[bytes.length];    System.arraycopy(bytes, 0, ret, 0, ret.length);    return ret;}
0
private void throwPendingException() throws IOException
{    if (pendingException != null) {        IOException e = pendingException;        pendingException = null;        throw e;    }}
0
protected void doStart() throws Exception
{    super.doStart();    SSLEngine engine = this.sslContextFactory.newSSLEngine();    SSLSession session = engine.getSession();    engine.setUseClientMode(false);    if (session.getPacketBufferSize() > this.getInputBufferSize()) {        this.setInputBufferSize(session.getPacketBufferSize());    }}
0
public Connection newConnection(Connector connector, EndPoint realEndPoint)
{    ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);    byte[] bytes = aheadEndpoint.getBytes();    boolean isSSL;    if (bytes == null || bytes.length == 0) {        isSSL = false;            } else {                byte b = bytes[0];                isSSL = b == 0x16;    }        EndPoint plainEndpoint;    SslConnection sslConnection;    if (isSSL) {        SSLEngine engine = this.sslContextFactory.newSSLEngine(aheadEndpoint.getRemoteAddress());        engine.setUseClientMode(false);        sslConnection = this.newSslConnection(connector, aheadEndpoint, engine);        sslConnection.setRenegotiationAllowed(this.sslContextFactory.isRenegotiationAllowed());        this.configure(sslConnection, connector, aheadEndpoint);        plainEndpoint = sslConnection.getDecryptedEndPoint();    } else {        sslConnection = null;        plainEndpoint = aheadEndpoint;    }    ConnectionFactory next = connector.getConnectionFactory(nextProtocol);    Connection connection = next.newConnection(connector, plainEndpoint);    plainEndpoint.setConnection(connection);    return (sslConnection == null) ? connection : sslConnection;}
1
protected SslConnection newSslConnection(final Connector connector, final EndPoint endPoint, final SSLEngine engine)
{    return new SslConnection(connector.getByteBufferPool(), connector.getExecutor(), endPoint, engine);}
0
public String toString()
{    return String.format("%s@%x{%s->%s}", this.getClass().getSimpleName(), this.hashCode(), this.getProtocol(), this.nextProtocol);}
0
public String getScheme()
{    return "digest";}
0
private static String base64Encode(byte[] b)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < b.length; ) {        int pad = 0;        int v = (b[i++] & 0xff) << 16;        if (i < b.length) {            v |= (b[i++] & 0xff) << 8;        } else {            pad++;        }        if (i < b.length) {            v |= (b[i++] & 0xff);        } else {            pad++;        }        sb.append(encode(v >> 18));        sb.append(encode(v >> 12));        if (pad < 2) {            sb.append(encode(v >> 6));        } else {            sb.append('=');        }        if (pad < 1) {            sb.append(encode(v));        } else {            sb.append('=');        }    }    return sb.toString();}
0
private static char encode(int i)
{    i &= 0x3f;    if (i < 26) {        return (char) ('A' + i);    }    if (i < 52) {        return (char) ('a' + i - 26);    }    if (i < 62) {        return (char) ('0' + i - 52);    }    return i == 62 ? '+' : '/';}
0
public static String generateDigest(String idPassword) throws NoSuchAlgorithmException
{    String[] parts = idPassword.split(":", 2);    byte[] digest = MessageDigest.getInstance("SHA1").digest(idPassword.getBytes());    return parts[0] + ":" + base64Encode(digest);}
0
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    String id = new String(authData);    try {        String digest = generateDigest(id);        if (digest.equals(superDigest)) {            cnxn.addAuthInfo(new Id("super", ""));        }        cnxn.addAuthInfo(new Id(getScheme(), digest));        return KeeperException.Code.OK;    } catch (NoSuchAlgorithmException e) {            }    return KeeperException.Code.AUTHFAILED;}
1
public boolean isAuthenticated()
{    return true;}
0
public boolean isValid(String id)
{    String[] parts = id.split(":");    return parts.length == 2;}
0
public boolean matches(String id, String aclExpr)
{    return id.equals(aclExpr);}
0
public static void main(String[] args) throws NoSuchAlgorithmException
{    for (int i = 0; i < args.length; i++) {        System.out.println(args[i] + "->" + generateDigest(args[i]));    }}
0
public boolean abort()
{    return false;}
0
public boolean commit()
{    return true;}
0
public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
{    if (options.containsKey("username")) {                this.subject = subject;        String username = (String) options.get("username");        this.subject.getPublicCredentials().add(username);        String password = (String) options.get("password");        this.subject.getPrivateCredentials().add(password);    }    return;}
0
public boolean logout()
{    return true;}
0
public boolean login()
{        return true;}
0
public void setEnsembleNames(String namesCSV)
{    ensembleNames = new HashSet<String>();    for (String name : namesCSV.split(",")) {        ensembleNames.add(name.trim());    }}
0
public String getScheme()
{    return "ensemble";}
0
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    if (authData == null || authData.length == 0) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    String receivedEnsembleName = new String(authData);    if (ensembleNames == null) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    if (ensembleNames.contains(receivedEnsembleName)) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SUCCESS.add(1);        return KeeperException.Code.OK;    }    long currentTime = System.currentTimeMillis();    if (lastFailureLogged + MIN_LOGGING_INTERVAL_MS < currentTime) {        String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();                lastFailureLogged = currentTime;    }    /*         * we are doing a close here rather than returning some other error         * since we want the client to choose another server to connect to. if         * we return an error, the client will get a fatal auth error and         * shutdown.         */    ServerMetrics.getMetrics().ENSEMBLE_AUTH_FAIL.add(1);    cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    return KeeperException.Code.BADARGUMENTS;}
1
public boolean matches(String id, String aclExpr)
{    return false;}
0
public boolean isAuthenticated()
{    return false;}
0
public boolean isValid(String id)
{    return false;}
0
public String getScheme()
{    return "ip";}
0
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();    cnxn.addAuthInfo(new Id(getScheme(), id));    return KeeperException.Code.OK;}
0
private byte[] addr2Bytes(String addr)
{    byte[] b = v4addr2Bytes(addr);        return b;}
0
private byte[] v4addr2Bytes(String addr)
{    String[] parts = addr.split("\\.", -1);    if (parts.length != 4) {        return null;    }    byte[] b = new byte[4];    for (int i = 0; i < 4; i++) {        try {            int v = Integer.parseInt(parts[i]);            if (v >= 0 && v <= 255) {                b[i] = (byte) v;            } else {                return null;            }        } catch (NumberFormatException e) {            return null;        }    }    return b;}
0
private void mask(byte[] b, int bits)
{    int start = bits / 8;    int startMask = (1 << (8 - (bits % 8))) - 1;    startMask = ~startMask;    while (start < b.length) {        b[start] &= startMask;        startMask = 0;        start++;    }}
0
public boolean matches(String id, String aclExpr)
{    String[] parts = aclExpr.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    int bits = aclAddr.length * 8;    if (parts.length == 2) {        try {            bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    mask(aclAddr, bits);    byte[] remoteAddr = addr2Bytes(id);    if (remoteAddr == null) {        return false;    }    mask(remoteAddr, bits);    for (int i = 0; i < remoteAddr.length; i++) {        if (remoteAddr[i] != aclAddr[i]) {            return false;        }    }    return true;}
0
public boolean isAuthenticated()
{    return false;}
0
public boolean isValid(String id)
{    String[] parts = id.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    if (parts.length == 2) {        try {            int bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    return true;}
0
public String getDefaultRealm()
{    return defaultRealm;}
0
public String toString()
{    StringBuilder result = new StringBuilder();    result.append(serviceName);    if (hostName != null) {        result.append('/');        result.append(hostName);    }    if (realm != null) {        result.append('@');        result.append(realm);    }    return result.toString();}
0
public String getServiceName()
{    return serviceName;}
0
public String getHostName()
{    return hostName;}
0
public String getRealm()
{    return realm;}
0
public String toString()
{    StringBuilder buf = new StringBuilder();    if (isDefault) {        buf.append("DEFAULT");    } else {        buf.append("RULE:[");        buf.append(numOfComponents);        buf.append(':');        buf.append(format);        buf.append(']');        if (match != null) {            buf.append('(');            buf.append(match);            buf.append(')');        }        if (fromPattern != null) {            buf.append("s/");            buf.append(fromPattern);            buf.append('/');            buf.append(toPattern);            buf.append('/');            if (repeat) {                buf.append('g');            }        }    }    return buf.toString();}
0
 static String replaceParameters(String format, String[] params) throws BadFormatString
{    Matcher match = parameterPattern.matcher(format);    int start = 0;    StringBuilder result = new StringBuilder();    while (start < format.length() && match.find(start)) {        result.append(match.group(1));        String paramNum = match.group(3);        if (paramNum != null) {            try {                int num = Integer.parseInt(paramNum);                if (num < 0 || num > params.length) {                    throw new BadFormatString(String.format("index %d from %s is outside of the valid range 0 to %d", num, format, (params.length - 1)));                }                result.append(params[num]);            } catch (NumberFormatException nfe) {                throw new BadFormatString("bad format in username mapping in " + paramNum, nfe);            }        }        start = match.end();    }    return result.toString();}
0
 static String replaceSubstitution(String base, Pattern from, String to, boolean repeat)
{    Matcher match = from.matcher(base);    if (repeat) {        return match.replaceAll(to);    } else {        return match.replaceFirst(to);    }}
0
 String apply(String[] params) throws IOException
{    String result = null;    if (isDefault) {        if (defaultRealm.equals(params[0])) {            result = params[1];        }    } else if (params.length - 1 == numOfComponents) {        String base = replaceParameters(format, params);        if (match == null || match.matcher(base).matches()) {            if (fromPattern == null) {                result = base;            } else {                result = replaceSubstitution(base, fromPattern, toPattern, repeat);            }        }    }    if (result != null && nonSimplePattern.matcher(result).find()) {        throw new NoMatchingRule("Non-simple name " + result + " after auth_to_local rule " + this);    }    return result;}
0
 static List<Rule> parseRules(String rules)
{    List<Rule> result = new ArrayList<Rule>();    String remaining = rules.trim();    while (remaining.length() > 0) {        Matcher matcher = ruleParser.matcher(remaining);        if (!matcher.lookingAt()) {            throw new IllegalArgumentException("Invalid rule: " + remaining);        }        if (matcher.group(2) != null) {            result.add(new Rule());        } else {            result.add(new Rule(Integer.parseInt(matcher.group(4)), matcher.group(5), matcher.group(7), matcher.group(9), matcher.group(10), "g".equals(matcher.group(11))));        }        remaining = remaining.substring(matcher.end());    }    return result;}
0
public static void setConfiguration() throws IOException
{    String ruleString = System.getProperty("zookeeper.security.auth_to_local", "DEFAULT");    rules = parseRules(ruleString);}
0
public String getShortName() throws IOException
{    String[] params;    if (hostName == null) {                if (realm == null) {            return serviceName;        }        params = new String[] { realm, serviceName };    } else {        params = new String[] { realm, serviceName, hostName };    }    for (Rule r : rules) {        String result = r.apply(params);        if (result != null) {            return result;        }    }    throw new NoMatchingRule("No rules applied to " + toString());}
0
 static void printRules() throws IOException
{    int i = 0;    for (Rule r : rules) {        System.out.println(++i + " " + r);    }}
0
public static void main(String[] args) throws Exception
{    for (String arg : args) {        KerberosName name = new KerberosName(arg);        System.out.println("Name: " + name + " to " + name.getShortName());    }}
0
public String getScheme()
{    return "key";}
0
private byte[] getKey(ZooKeeperServer zks)
{    ZKDatabase db = zks.getZKDatabase();    if (db != null) {        try {            Stat stat = new Stat();            return db.getData("/key", stat, null);        } catch (NoNodeException e) {                    }    }    return null;}
1
private boolean validate(byte[] key, byte[] auth)
{        try {        String keyStr = new String(key, StandardCharsets.UTF_8);        String authStr = new String(auth, StandardCharsets.UTF_8);        int keyVal = Integer.parseInt(keyStr);        int authVal = Integer.parseInt(authStr);        if (keyVal != 0 && ((authVal % keyVal) != 0)) {            return false;        }    } catch (NumberFormatException nfe) {                return false;    }    return true;}
1
public KeeperException.Code handleAuthentication(ServerObjs serverObjs, byte[] authData)
{    byte[] key = getKey(serverObjs.getZks());    String authStr = "";    String keyStr = "";    try {        authStr = new String(authData, StandardCharsets.UTF_8);    } catch (Exception e) {            }    if (key != null) {        if (!validate(key, authData)) {            try {                keyStr = new String(key, StandardCharsets.UTF_8);            } catch (Exception e) {                                                keyStr = authStr;            }                        return KeeperException.Code.AUTHFAILED;        }    }                                serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr));    return KeeperException.Code.OK;}
1
public boolean matches(ServerObjs serverObjs, MatchValues matchValues)
{    return matchValues.getId().equals(matchValues.getAclExpr());}
0
public boolean isAuthenticated()
{    return true;}
0
public boolean isValid(String id)
{    return true;}
0
public static void reset()
{    synchronized (ProviderRegistry.class) {        initialized = false;        authenticationProviders.clear();    }}
0
public static void initialize()
{    synchronized (ProviderRegistry.class) {        IPAuthenticationProvider ipp = new IPAuthenticationProvider();        DigestAuthenticationProvider digp = new DigestAuthenticationProvider();        authenticationProviders.put(ipp.getScheme(), ipp);        authenticationProviders.put(digp.getScheme(), digp);        Enumeration<Object> en = System.getProperties().keys();        while (en.hasMoreElements()) {            String k = (String) en.nextElement();            if (k.startsWith("zookeeper.authProvider.")) {                String className = System.getProperty(k);                try {                    Class<?> c = ZooKeeperServer.class.getClassLoader().loadClass(className);                    AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor().newInstance();                    authenticationProviders.put(ap.getScheme(), ap);                } catch (Exception e) {                                    }            }        }        initialized = true;    }}
1
public static ServerAuthenticationProvider getServerProvider(String scheme)
{    return WrappedAuthenticationProvider.wrap(getProvider(scheme));}
0
public static AuthenticationProvider getProvider(String scheme)
{    if (!initialized) {        initialize();    }    return authenticationProviders.get(scheme);}
0
public static void removeProvider(String scheme)
{    authenticationProviders.remove(scheme);}
0
public static String listProviders()
{    StringBuilder sb = new StringBuilder();    for (String s : authenticationProviders.keySet()) {        sb.append(s).append(" ");    }    return sb.toString();}
0
public String getScheme()
{    return "sasl";}
0
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{        return KeeperException.Code.AUTHFAILED;}
0
public boolean matches(String id, String aclExpr)
{    if ((id.equals("super") || id.equals(aclExpr))) {        return true;    }    String readAccessUser = System.getProperty("zookeeper.letAnySaslUserDoX");    return readAccessUser != null && aclExpr.equals(readAccessUser);}
0
public boolean isAuthenticated()
{    return true;}
0
public boolean isValid(String id)
{        try {        new KerberosName(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
0
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
0
private void handleNameCallback(NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {                return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
1
private void handlePasswordCallback(PasswordCallback pc)
{    if ("super".equals(this.userName) && System.getProperty(SYSPROP_SUPER_PASSWORD) != null) {                pc.setPassword(System.getProperty(SYSPROP_SUPER_PASSWORD).toCharArray());    } else if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {            }}
1
private void handleRealmCallback(RealmCallback rc)
{        rc.setText(rc.getDefaultText());}
1
private boolean shouldAppendRealm(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_REALM) && kerberosName.getRealm() != null;}
0
private boolean shouldAppendHost(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_HOST) && kerberosName.getHostName() != null;}
0
private boolean isSystemPropertyTrue(String propertyName)
{    return "true".equals(System.getProperty(propertyName));}
0
public ZooKeeperServer getZks()
{    return zks;}
0
public ServerCnxn getCnxn()
{    return cnxn;}
0
public String getPath()
{    return path;}
0
public String getId()
{    return id;}
0
public String getAclExpr()
{    return aclExpr;}
0
public int getPerm()
{    return perm;}
0
public List<ACL> getSetAcls()
{    return setAcls;}
0
public final KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    throw new UnsupportedOperationException();}
0
public final boolean matches(String id, String aclExpr)
{    throw new UnsupportedOperationException();}
0
 static ServerAuthenticationProvider wrap(AuthenticationProvider provider)
{    if (provider == null) {        return null;    }    return (provider instanceof ServerAuthenticationProvider) ? (ServerAuthenticationProvider) provider : new WrappedAuthenticationProvider(provider);}
0
public KeeperException.Code handleAuthentication(ServerObjs serverObjs, byte[] authData)
{    return implementation.handleAuthentication(serverObjs.getCnxn(), authData);}
0
public boolean matches(ServerObjs serverObjs, MatchValues matchValues)
{    return implementation.matches(matchValues.getId(), matchValues.getAclExpr());}
0
public String getScheme()
{    return implementation.getScheme();}
0
public boolean isAuthenticated()
{    return implementation.isAuthenticated();}
0
public boolean isValid(String id)
{    return implementation.isValid(id);}
0
public String getScheme()
{    return "x509";}
0
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    X509Certificate[] certChain = (X509Certificate[]) cnxn.getClientCertificateChain();    if (certChain == null || certChain.length == 0) {        return KeeperException.Code.AUTHFAILED;    }    if (trustManager == null) {                return KeeperException.Code.AUTHFAILED;    }    X509Certificate clientCert = certChain[0];    try {                trustManager.checkClientTrusted(certChain, clientCert.getPublicKey().getAlgorithm());    } catch (CertificateException ce) {                return KeeperException.Code.AUTHFAILED;    }    String clientId = getClientId(clientCert);    if (clientId.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER))) {        cnxn.addAuthInfo(new Id("super", clientId));            }    Id authInfo = new Id(getScheme(), clientId);    cnxn.addAuthInfo(authInfo);        return KeeperException.Code.OK;}
1
protected String getClientId(X509Certificate clientCert)
{    return clientCert.getSubjectX500Principal().getName();}
0
public boolean matches(String id, String aclExpr)
{    if (System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER) != null) {        return id.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER)) || id.equals(aclExpr);    }    return id.equals(aclExpr);}
0
public boolean isAuthenticated()
{    return true;}
0
public boolean isValid(String id)
{    try {        new X500Principal(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
0
public X509TrustManager getTrustManager() throws TrustManagerException
{    if (trustManager == null) {        throw new TrustManagerException("No trust manager available");    }    return trustManager;}
0
public X509KeyManager getKeyManager() throws KeyManagerException
{    if (keyManager == null) {        throw new KeyManagerException("No key manager available");    }    return keyManager;}
0
protected static void setConnectionWeightEnabled(boolean enabled)
{    connectionWeightEnabled = enabled;    logWeighedThrottlingSetting();}
0
private static void logWeighedThrottlingSetting()
{    if (connectionWeightEnabled) {                    } else {            }}
1
private static double getDoubleProp(String name, double def)
{    String val = System.getProperty(name);    if (val != null) {        return Double.parseDouble(val);    } else {        return def;    }}
0
public synchronized void setMaxTokens(int max)
{    int deficit = maxTokens - tokens;    maxTokens = max;    tokens = max - deficit;}
0
public synchronized void setFillTime(int time)
{    fillTime = time;}
0
public synchronized void setFillCount(int count)
{    fillCount = count;}
0
public synchronized void setFreezeTime(int time)
{    freezeTime = time;}
0
public synchronized void setDropIncrease(double increase)
{    dropIncrease = increase;}
0
public synchronized void setDropDecrease(double decrease)
{    dropDecrease = decrease;}
0
public synchronized void setDecreasePoint(double ratio)
{    decreasePoint = ratio;}
0
public synchronized int getMaxTokens()
{    return maxTokens;}
0
public synchronized int getFillTime()
{    return fillTime;}
0
public synchronized int getFillCount()
{    return fillCount;}
0
public synchronized int getFreezeTime()
{    return freezeTime;}
0
public synchronized double getDropIncrease()
{    return dropIncrease;}
0
public synchronized double getDropDecrease()
{    return dropDecrease;}
0
public synchronized double getDecreasePoint()
{    return decreasePoint;}
0
public synchronized double getDropChance()
{    return drop;}
0
public synchronized int getDeficit()
{    return maxTokens - tokens;}
0
public int getRequiredTokensForGlobal()
{    return BlueThrottle.DEFAULT_GLOBAL_SESSION_WEIGHT;}
0
public int getRequiredTokensForLocal()
{    return BlueThrottle.DEFAULT_LOCAL_SESSION_WEIGHT;}
0
public int getRequiredTokensForRenew()
{    return BlueThrottle.DEFAULT_RENEW_SESSION_WEIGHT;}
0
public boolean isConnectionWeightEnabled()
{    return BlueThrottle.connectionWeightEnabled;}
0
public synchronized boolean checkLimit(int need)
{        if (maxTokens == 0) {        return true;    }    long now = Time.currentElapsedTime();    long diff = now - lastTime;    if (diff > fillTime) {        int refill = (int) (diff * fillCount / fillTime);        tokens = Math.min(tokens + refill, maxTokens);        lastTime = now;    }        if (freezeTime != -1) {        if (!checkBlue(now)) {            return false;        }    }    if (tokens < need) {        return false;    }    tokens -= need;    return true;}
0
public synchronized boolean checkBlue(long now)
{    int length = maxTokens - tokens;    int limit = maxTokens;    long diff = now - lastFreeze;    long threshold = Math.round(maxTokens * decreasePoint);    if (diff > freezeTime) {        if ((length == limit) && (drop < 1)) {            drop = Math.min(drop + dropIncrease, 1);        } else if ((length <= threshold) && (drop > 0)) {            drop = Math.max(drop - dropDecrease, 0);        }        lastFreeze = now;    }    return !(rng.nextDouble() < drop);}
0
public int read() throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    return bb.get() & 0xff;}
0
public int available() throws IOException
{    return bb.remaining();}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    if (len > bb.remaining()) {        len = bb.remaining();    }    bb.get(b, off, len);    return len;}
0
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
0
public long skip(long n) throws IOException
{    if (n < 0L) {        return 0;    }    n = Math.min(n, bb.remaining());    bb.position(bb.position() + (int) n);    return n;}
0
public static void byteBuffer2Record(ByteBuffer bb, Record record) throws IOException
{    BinaryInputArchive ia;    ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    record.deserialize(ia, "request");}
0
public void write(int b) throws IOException
{    bb.put((byte) b);}
0
public void write(byte[] b) throws IOException
{    bb.put(b);}
0
public void write(byte[] b, int off, int len) throws IOException
{    bb.put(b, off, len);}
0
public static void record2ByteBuffer(Record record, ByteBuffer bb) throws IOException
{    BinaryOutputArchive oa;    oa = BinaryOutputArchive.getArchive(new ByteBufferOutputStream(bb));    record.serialize(oa, "request");}
0
public void start()
{    run();}
0
public void run()
{    try {        commandRun();    } catch (IOException ie) {            } finally {        serverCnxn.cleanupWriterSocket(pw);    }}
1
public void setZkServer(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
0
 boolean isZKServerRunning()
{    return zkServer != null && zkServer.isRunning();}
0
public void setFactory(ServerCnxnFactory factory)
{    this.factory = factory;}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        factory.resetAllConnectionStats();        pw.println("Connection stats reset.");    }}
0
public boolean execute(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode, ZooKeeperServer zkServer, ServerCnxnFactory factory)
{    AbstractFourLetterCommand command = getCommand(serverCnxn, pwriter, commandCode);    if (command == null) {        return false;    }    command.setZkServer(zkServer);    command.setFactory(factory);    command.start();    return true;}
0
private AbstractFourLetterCommand getCommand(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode)
{    AbstractFourLetterCommand command = null;    if (commandCode == FourLetterCommands.ruokCmd) {        command = new RuokCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.getTraceMaskCmd) {        command = new TraceMaskCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.enviCmd) {        command = new EnvCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.confCmd) {        command = new ConfCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.srstCmd) {        command = new StatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.crstCmd) {        command = new CnxnStatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dirsCmd) {        command = new DirsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dumpCmd) {        command = new DumpCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.statCmd || commandCode == FourLetterCommands.srvrCmd) {        command = new StatCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.consCmd) {        command = new ConsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.wchpCmd || commandCode == FourLetterCommands.wchcCmd || commandCode == FourLetterCommands.wchsCmd) {        command = new WatchCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.mntrCmd) {        command = new MonitorCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.isroCmd) {        command = new IsroCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.hashCmd) {        command = new DigestCommand(pwriter, serverCnxn);    }    return command;}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        zkServer.dumpConf(pw);    }}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        for (ServerCnxn c : factory.getConnections()) {            c.dumpConnectionInfo(pw, false);            pw.println();        }        pw.println();    }}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.print(ZK_NOT_SERVING);    } else {        List<ZxidDigest> digestLog = zkServer.getZKDatabase().getDataTree().getDigestLog();        for (ZxidDigest zd : digestLog) {            pw.println(Long.toHexString(zd.getZxid()) + ": " + zd.getDigest());        }    }}
0
public void commandRun() throws IOException
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }    pw.println("datadir_size: " + zkServer.getDataDirSize());    pw.println("logdir_size: " + zkServer.getLogDirSize());}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.println("SessionTracker dump:");        zkServer.getSessionTracker().dumpSessions(pw);        pw.println("ephemeral nodes dump:");        zkServer.dumpEphemerals(pw);        pw.println("Connections dump:");                if (factory instanceof NIOServerCnxnFactory) {            ((NIOServerCnxnFactory) factory).dumpConnections(pw);        }    }}
0
public void commandRun()
{    List<Environment.Entry> env = Environment.list();    pw.println("Environment:");    for (Environment.Entry e : env) {        pw.print(e.getKey());        pw.print("=");        pw.println(e.getValue());    }}
0
public static synchronized void resetWhiteList()
{    whiteListInitialized = false;    whiteListedCommands.clear();}
0
public static String getCommandString(int command)
{    return cmd2String.get(command);}
0
public static boolean isKnown(int command)
{    return cmd2String.containsKey(command);}
0
public static synchronized boolean isEnabled(String command)
{    if (whiteListInitialized) {        return whiteListedCommands.contains(command);    }    String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);    if (commands != null) {        String[] list = commands.split(",");        for (String cmd : list) {            if (cmd.trim().equals("*")) {                for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {                    whiteListedCommands.add(entry.getValue());                }                break;            }            if (!cmd.trim().isEmpty()) {                whiteListedCommands.add(cmd.trim());            }        }    }        if (System.getProperty("readonlymode.enabled", "false").equals("true")) {        whiteListedCommands.add("isro");    }        whiteListedCommands.add("srvr");    whiteListInitialized = true;            return whiteListedCommands.contains(command);}
1
public void commandRun()
{    if (!isZKServerRunning()) {        pw.print("null");    } else if (zkServer instanceof ReadOnlyZooKeeperServer) {        pw.print("ro");    } else {        pw.print("rw");    }}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }        zkServer.dumpMonitorValues(this::print);    ServerMetrics.getMetrics().getMetricsProvider().dump(this::print);}
0
private void print(String key, Object value)
{    if (value == null) {        output(key, null);    } else if (value instanceof Long || value instanceof Integer) {                output(key, value + "");    } else if (value instanceof Number) {                output(key, ((Number) value).doubleValue() + "");    } else {        output(key, value.toString());    }}
0
private void output(String key, String value)
{    pw.print("zk_");    pw.print(key);    pw.print("\t");    pw.println(value);}
0
public void commandRun()
{    pw.println(msg);}
0
public void commandRun()
{    pw.print("imok");}
0
public void commandRun()
{    pw.print(trace);}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.print("Zookeeper version: ");        pw.println(Version.getFullVersion());        if (zkServer instanceof ReadOnlyZooKeeperServer) {            pw.println("READ-ONLY mode; serving only read-only clients");        }        if (len == FourLetterCommands.statCmd) {                        pw.println("Clients:");            for (ServerCnxn c : factory.getConnections()) {                c.dumpConnectionInfo(pw, true);                pw.println();            }            pw.println();        }        ServerStats serverStats = zkServer.serverStats();        pw.print(serverStats.toString());        pw.print("Node count: ");        pw.println(zkServer.getZKDatabase().getNodeCount());        if (serverStats.getServerState().equals("leader")) {            Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();            BufferStats proposalStats = leader.getProposalStats();            pw.printf("Proposal sizes last/min/max: %s%n", proposalStats.toString());        }    }}
1
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        ServerStats serverStats = zkServer.serverStats();        serverStats.reset();        if (serverStats.getServerState().equals("leader")) {            ((LeaderZooKeeperServer) zkServer).getLeader().getProposalStats().reset();        }        pw.println("Server stats reset.");    }}
0
public void commandRun()
{    long traceMask = ZooTrace.getTextTraceLevel();    pw.print(traceMask);}
0
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        DataTree dt = zkServer.getZKDatabase().getDataTree();        if (len == FourLetterCommands.wchsCmd) {            dt.dumpWatchesSummary(pw);        } else if (len == FourLetterCommands.wchpCmd) {            dt.dumpWatches(pw, true);        } else {            dt.dumpWatches(pw, false);        }        pw.println();    }}
0
public String getSessionId()
{    return "0x" + Long.toHexString(sessionId);}
0
public String getSourceIP()
{    InetSocketAddress sockAddr = connection.getRemoteSocketAddress();    if (sockAddr == null) {        return null;    }    return sockAddr.getAddress().getHostAddress() + ":" + sockAddr.getPort();}
0
public String getName()
{    return MBeanRegistry.getInstance().makeFullPath("Connections", remoteIP, getSessionId());}
0
public boolean isHidden()
{    return false;}
0
public String[] getEphemeralNodes()
{    if (zk.getZKDatabase() != null) {        String[] res = zk.getZKDatabase().getEphemerals(sessionId).toArray(new String[0]);        Arrays.sort(res);        return res;    }    return null;}
0
public String getStartedTime()
{    return stats.getEstablished().toString();}
0
public void terminateSession()
{    try {        zk.closeSession(sessionId);    } catch (Exception e) {            }}
1
public void terminateConnection()
{    connection.sendCloseSession();}
0
public void resetCounters()
{    stats.resetStats();}
0
public String toString()
{    return "ConnectionBean{ClientIP=" + ObjectName.quote(getSourceIP()) + ",SessionId=0x" + getSessionId() + "}";}
0
public long getOutstandingRequests()
{    return stats.getOutstandingRequests();}
0
public long getPacketsReceived()
{    return stats.getPacketsReceived();}
0
public long getPacketsSent()
{    return stats.getPacketsSent();}
0
public int getSessionTimeout()
{    return connection.getSessionTimeout();}
0
public long getMinLatency()
{    return stats.getMinLatency();}
0
public long getAvgLatency()
{    return stats.getAvgLatency();}
0
public long getMaxLatency()
{    return stats.getMaxLatency();}
0
public String getLastOperation()
{    return stats.getLastOperation();}
0
public String getLastCxid()
{    return "0x" + Long.toHexString(stats.getLastCxid());}
0
public String getLastZxid()
{    return "0x" + Long.toHexString(stats.getLastZxid());}
0
public String getLastResponseTime()
{    return Time.elapsedTimeToDate(stats.getLastResponseTime()).toString();}
0
public long getLastLatency()
{    return stats.getLastLatency();}
0
public void start()
{    if (task.get() == null) {        TimerTask timerTask = new TimerTask() {            @Override            public void run() {                try {                    checkContainers();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                                        cancel();                } catch (Throwable e) {                                    }            }        };        if (task.compareAndSet(null, timerTask)) {            timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);        }    }}
1
public void run()
{    try {        checkContainers();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();                cancel();    } catch (Throwable e) {            }}
1
public void stop()
{    TimerTask timerTask = task.getAndSet(null);    if (timerTask != null) {        timerTask.cancel();    }    timer.cancel();}
0
public void checkContainers() throws InterruptedException
{    long minIntervalMs = getMinIntervalMs();    for (String containerPath : getCandidates()) {        long startMs = Time.currentElapsedTime();        ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());        Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);        try {                        requestProcessor.processRequest(request);        } catch (Exception e) {                    }        long elapsedMs = Time.currentElapsedTime() - startMs;        long waitMs = minIntervalMs - elapsedMs;        if (waitMs > 0) {            Thread.sleep(waitMs);        }    }}
1
protected long getMinIntervalMs()
{    return TimeUnit.MINUTES.toMillis(1) / maxPerMinute;}
0
protected Collection<String> getCandidates()
{    Set<String> candidates = new HashSet<String>();    for (String containerPath : zkDb.getDataTree().getContainers()) {        DataNode node = zkDb.getDataTree().getNode(containerPath);        /*                cversion > 0: keep newly created containers from being deleted                before any children have been added. If you were to create the                container just before a container cleaning period the container                would be immediately be deleted.             */        if ((node != null) && (node.stat.getCversion() > 0) && (node.getChildren().isEmpty())) {            candidates.add(containerPath);        }    }    for (String ttlPath : zkDb.getDataTree().getTtls()) {        DataNode node = zkDb.getDataTree().getNode(ttlPath);        if (node != null) {            Set<String> children = node.getChildren();            if (children.isEmpty()) {                if (EphemeralType.get(node.stat.getEphemeralOwner()) == EphemeralType.TTL) {                    long elapsed = getElapsed(node);                    long ttl = EphemeralType.TTL.getValue(node.stat.getEphemeralOwner());                    if ((ttl != 0) && (getElapsed(node) > ttl)) {                        candidates.add(ttlPath);                    }                }            }        }    }    return candidates;}
0
protected long getElapsed(DataNode node)
{    return Time.currentWallTime() - node.stat.getMtime();}
0
public void start()
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {                return;    }        if (purgeInterval <= 0) {                return;    }    timer = new Timer("PurgeTask", true);    TimerTask task = new PurgeTask(dataLogDir, snapDir, snapRetainCount);    timer.scheduleAtFixedRate(task, 0, TimeUnit.HOURS.toMillis(purgeInterval));    purgeTaskStatus = PurgeTaskStatus.STARTED;}
1
public void shutdown()
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {                timer.cancel();        purgeTaskStatus = PurgeTaskStatus.COMPLETED;    } else {            }}
1
public void run()
{        try {        PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);    } catch (Exception e) {            }    }
1
public PurgeTaskStatus getPurgeTaskStatus()
{    return purgeTaskStatus;}
0
public File getSnapDir()
{    return snapDir;}
0
public File getDataLogDir()
{    return dataLogDir;}
0
public int getPurgeInterval()
{    return purgeInterval;}
0
public int getSnapRetainCount()
{    return snapRetainCount;}
0
public synchronized boolean addChild(String child)
{    if (children == null) {                children = new HashSet<String>(8);    }    return children.add(child);}
0
public synchronized boolean removeChild(String child)
{    if (children == null) {        return false;    }    return children.remove(child);}
0
public synchronized void setChildren(HashSet<String> children)
{    this.children = children;}
0
public synchronized Set<String> getChildren()
{    if (children == null) {        return EMPTY_SET;    }    return Collections.unmodifiableSet(children);}
0
public synchronized void copyStat(Stat to)
{    to.setAversion(stat.getAversion());    to.setCtime(stat.getCtime());    to.setCzxid(stat.getCzxid());    to.setMtime(stat.getMtime());    to.setMzxid(stat.getMzxid());    to.setPzxid(stat.getPzxid());    to.setVersion(stat.getVersion());    to.setEphemeralOwner(getClientEphemeralOwner(stat));    to.setDataLength(data == null ? 0 : data.length);    int numChildren = 0;    if (this.children != null) {        numChildren = children.size();    }                to.setCversion(stat.getCversion() * 2 - numChildren);    to.setNumChildren(numChildren);}
0
private static long getClientEphemeralOwner(StatPersisted stat)
{    EphemeralType ephemeralType = EphemeralType.get(stat.getEphemeralOwner());    if (ephemeralType != EphemeralType.NORMAL) {        return 0;    }    return stat.getEphemeralOwner();}
0
public synchronized void deserialize(InputArchive archive, String tag) throws IOException
{    archive.startRecord("node");    data = archive.readBuffer("data");    acl = archive.readLong("acl");    stat = new StatPersisted();    stat.deserialize(archive, "statpersisted");    archive.endRecord("node");}
0
public synchronized void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, "node");    archive.writeBuffer(data, "data");    archive.writeLong(acl, "acl");    stat.serialize(archive, "statpersisted");    archive.endRecord(this, "node");}
0
public boolean isDigestCached()
{    return digestCached;}
0
public void setDigestCached(boolean digestCached)
{    this.digestCached = digestCached;}
0
public long getDigest()
{    return digest;}
0
public void setDigest(long digest)
{    this.digest = digest;}
0
public byte[] getData()
{    return data;}
0
public Set<String> getEphemerals(long sessionId)
{    HashSet<String> retv = ephemerals.get(sessionId);    if (retv == null) {        return new HashSet<String>();    }    Set<String> cloned = null;    synchronized (retv) {        cloned = (HashSet<String>) retv.clone();    }    return cloned;}
0
public Set<String> getContainers()
{    return new HashSet<String>(containers);}
0
public Set<String> getTtls()
{    return new HashSet<String>(ttls);}
0
public Collection<Long> getSessions()
{    return ephemerals.keySet();}
0
public DataNode getNode(String path)
{    return nodes.get(path);}
0
public int getNodeCount()
{    return nodes.size();}
0
public int getWatchCount()
{    return dataWatches.size() + childWatches.size();}
0
public int getEphemeralsCount()
{    int result = 0;    for (HashSet<String> set : ephemerals.values()) {        result += set.size();    }    return result;}
0
public long approximateDataSize()
{    long result = 0;    for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {        DataNode value = entry.getValue();        synchronized (value) {            result += getNodeSize(entry.getKey(), value.data);        }    }    return result;}
0
private static long getNodeSize(String path, byte[] data)
{    return (path == null ? 0 : path.length()) + (data == null ? 0 : data.length);}
0
public long cachedApproximateDataSize()
{    return nodeDataSize.get();}
0
public void addConfigNode()
{    DataNode zookeeperZnode = nodes.get(procZookeeper);    if (zookeeperZnode != null) {                zookeeperZnode.addChild(configChildZookeeper);    } else {        assert false : "There's no /zookeeper znode - this should never happen.";    }    nodes.put(configZookeeper, new DataNode(new byte[0], -1L, new StatPersisted()));    try {                setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoNodeException e) {        assert false : "There's no " + configZookeeper + " znode - this should never happen.";    }}
0
 boolean isSpecialPath(String path)
{    return rootZookeeper.equals(path) || procZookeeper.equals(path) || quotaZookeeper.equals(path) || configZookeeper.equals(path);}
0
public static void copyStatPersisted(StatPersisted from, StatPersisted to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());}
0
public static void copyStat(Stat from, Stat to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());    to.setDataLength(from.getDataLength());    to.setNumChildren(from.getNumChildren());}
0
public void updateCountBytes(String lastPrefix, long bytesDiff, int countDiff)
{    String statNode = Quotas.statPath(lastPrefix);    DataNode node = nodes.get(statNode);    StatsTrack updatedStat = null;    if (node == null) {                        return;    }    synchronized (node) {        updatedStat = new StatsTrack(new String(node.data));        updatedStat.setCount(updatedStat.getCount() + countDiff);        updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);        node.data = updatedStat.toString().getBytes();    }        String quotaNode = Quotas.quotaPath(lastPrefix);    node = nodes.get(quotaNode);    StatsTrack thisStats = null;    if (node == null) {                        return;    }    synchronized (node) {        thisStats = new StatsTrack(new String(node.data));    }    if (thisStats.getCount() > -1 && (thisStats.getCount() < updatedStat.getCount())) {            }    if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {            }}
1
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time) throws NoNodeException, NodeExistsException
{    createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);}
0
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws KeeperException.NoNodeException, KeeperException.NodeExistsException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);    StatPersisted stat = new StatPersisted();    stat.setCtime(time);    stat.setMtime(time);    stat.setCzxid(zxid);    stat.setMzxid(zxid);    stat.setPzxid(zxid);    stat.setVersion(0);    stat.setAversion(0);    stat.setEphemeralOwner(ephemeralOwner);    DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {                                                                                                Long longval = aclCache.convertAcls(acl);        Set<String> children = parent.getChildren();        if (children.contains(childName)) {            throw new KeeperException.NodeExistsException();        }        nodes.preChange(parentName, parent);        if (parentCVersion == -1) {            parentCVersion = parent.stat.getCversion();            parentCVersion++;        }                if (parentCVersion > parent.stat.getCversion()) {            parent.stat.setCversion(parentCVersion);            parent.stat.setPzxid(zxid);        }        DataNode child = new DataNode(data, longval, stat);        parent.addChild(childName);        nodes.postChange(parentName, parent);        nodeDataSize.addAndGet(getNodeSize(path, child.data));        nodes.put(path, child);        EphemeralType ephemeralType = EphemeralType.get(ephemeralOwner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.add(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.add(path);        } else if (ephemeralOwner != 0) {            HashSet<String> list = ephemerals.get(ephemeralOwner);            if (list == null) {                list = new HashSet<String>();                ephemerals.put(ephemeralOwner, list);            }            synchronized (list) {                list.add(path);            }        }        if (outputStat != null) {            child.copyStat(outputStat);        }    }        if (parentName.startsWith(quotaZookeeper)) {                if (Quotas.limitNode.equals(childName)) {                                    pTrie.addPath(parentName.substring(quotaZookeeper.length()));        }        if (Quotas.statNode.equals(childName)) {            updateQuotaForPath(parentName.substring(quotaZookeeper.length()));        }    }        String lastPrefix = getMaxPrefixWithQuota(path);    long bytes = data == null ? 0 : data.length;    if (lastPrefix != null) {                updateCountBytes(lastPrefix, bytes, 1);    }    updateWriteStat(path, bytes);    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);    childWatches.triggerWatch(parentName.equals("") ? "/" : parentName, Event.EventType.NodeChildrenChanged);}
0
public void deleteNode(String path, long zxid) throws KeeperException.NoNodeException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);                DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {        nodes.preChange(parentName, parent);        parent.removeChild(childName);                if (zxid > parent.stat.getPzxid()) {            parent.stat.setPzxid(zxid);        }        nodes.postChange(parentName, parent);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException();    }    nodes.remove(path);    synchronized (node) {        aclCache.removeUsage(node.acl);        nodeDataSize.addAndGet(-getNodeSize(path, node.data));    }        synchronized (parent) {        long eowner = node.stat.getEphemeralOwner();        EphemeralType ephemeralType = EphemeralType.get(eowner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.remove(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.remove(path);        } else if (eowner != 0) {            Set<String> nodes = ephemerals.get(eowner);            if (nodes != null) {                synchronized (nodes) {                    nodes.remove(path);                }            }        }    }    if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {                        pTrie.deletePath(parentName.substring(quotaZookeeper.length()));    }        String lastPrefix = getMaxPrefixWithQuota(path);    if (lastPrefix != null) {                int bytes = 0;        synchronized (node) {            bytes = (node.data == null ? 0 : -(node.data.length));        }        updateCountBytes(lastPrefix, bytes, -1);    }    updateWriteStat(path, 0L);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "dataWatches.triggerWatch " + path);        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "childWatches.triggerWatch " + parentName);    }    WatcherOrBitSet processed = dataWatches.triggerWatch(path, EventType.NodeDeleted);    childWatches.triggerWatch(path, EventType.NodeDeleted, processed);    childWatches.triggerWatch("".equals(parentName) ? "/" : parentName, EventType.NodeChildrenChanged);}
0
public Stat setData(String path, byte[] data, int version, long zxid, long time) throws KeeperException.NoNodeException
{    Stat s = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    byte[] lastdata = null;    synchronized (n) {        lastdata = n.data;        nodes.preChange(path, n);        n.data = data;        n.stat.setMtime(time);        n.stat.setMzxid(zxid);        n.stat.setVersion(version);        n.copyStat(s);        nodes.postChange(path, n);    }        String lastPrefix = getMaxPrefixWithQuota(path);    long dataBytes = data == null ? 0 : data.length;    if (lastPrefix != null) {        this.updateCountBytes(lastPrefix, dataBytes - (lastdata == null ? 0 : lastdata.length), 0);    }    nodeDataSize.addAndGet(getNodeSize(path, data) - getNodeSize(path, lastdata));    updateWriteStat(path, dataBytes);    dataWatches.triggerWatch(path, EventType.NodeDataChanged);    return s;}
0
public String getMaxPrefixWithQuota(String path)
{                String lastPrefix = pTrie.findMaxPrefix(path);    if (rootZookeeper.equals(lastPrefix) || lastPrefix.isEmpty()) {        return null;    } else {        return lastPrefix;    }}
0
public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    byte[] data = null;    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);        if (watcher != null) {            dataWatches.addWatch(path, watcher);        }        data = n.data;    }    updateReadStat(path, data == null ? 0 : data.length);    return data;}
0
public Stat statNode(String path, Watcher watcher) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (watcher != null) {        dataWatches.addWatch(path, watcher);    }    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);    }    updateReadStat(path, 0L);    return stat;}
0
public List<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    List<String> children;    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        children = new ArrayList<String>(n.getChildren());        if (watcher != null) {            childWatches.addWatch(path, watcher);        }    }    int bytes = 0;    for (String child : children) {        bytes += child.length();    }    updateReadStat(path, bytes);    return children;}
0
public int getAllChildrenNumber(String path)
{        if ("/".equals(path)) {        return nodes.size() - 2;    }    return (int) nodes.keySet().parallelStream().filter(key -> key.startsWith(path + "/")).count();}
0
public Stat setACL(String path, List<ACL> acl, int version) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        aclCache.removeUsage(n.acl);        nodes.preChange(path, n);        n.stat.setAversion(version);        n.acl = aclCache.convertAcls(acl);        n.copyStat(stat);        nodes.postChange(path, n);        return stat;    }}
0
public List<ACL> getACL(String path, Stat stat) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        return new ArrayList<ACL>(aclCache.convertLong(n.acl));    }}
0
public List<ACL> getACL(DataNode node)
{    synchronized (node) {        return aclCache.convertLong(node.acl);    }}
0
public int aclCacheSize()
{    return aclCache.size();}
0
public boolean equals(Object o)
{    if (o instanceof ProcessTxnResult) {        ProcessTxnResult other = (ProcessTxnResult) o;        return other.clientId == clientId && other.cxid == cxid;    }    return false;}
0
public int hashCode()
{    return (int) ((clientId ^ cxid) % Integer.MAX_VALUE);}
0
public ProcessTxnResult processTxn(TxnHeader header, Record txn)
{    return this.processTxn(header, txn, false);}
0
public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTxn)
{    ProcessTxnResult rc = new ProcessTxnResult();    try {        rc.clientId = header.getClientId();        rc.cxid = header.getCxid();        rc.zxid = header.getZxid();        rc.type = header.getType();        rc.err = 0;        rc.multiResult = null;        switch(header.getType()) {            case OpCode.create:                CreateTxn createTxn = (CreateTxn) txn;                rc.path = createTxn.getPath();                createNode(createTxn.getPath(), createTxn.getData(), createTxn.getAcl(), createTxn.getEphemeral() ? header.getClientId() : 0, createTxn.getParentCVersion(), header.getZxid(), header.getTime(), null);                break;            case OpCode.create2:                CreateTxn create2Txn = (CreateTxn) txn;                rc.path = create2Txn.getPath();                Stat stat = new Stat();                createNode(create2Txn.getPath(), create2Txn.getData(), create2Txn.getAcl(), create2Txn.getEphemeral() ? header.getClientId() : 0, create2Txn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createTTL:                CreateTTLTxn createTtlTxn = (CreateTTLTxn) txn;                rc.path = createTtlTxn.getPath();                stat = new Stat();                createNode(createTtlTxn.getPath(), createTtlTxn.getData(), createTtlTxn.getAcl(), EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()), createTtlTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createContainer:                CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;                rc.path = createContainerTxn.getPath();                stat = new Stat();                createNode(createContainerTxn.getPath(), createContainerTxn.getData(), createContainerTxn.getAcl(), EphemeralType.CONTAINER_EPHEMERAL_OWNER, createContainerTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.delete:            case OpCode.deleteContainer:                DeleteTxn deleteTxn = (DeleteTxn) txn;                rc.path = deleteTxn.getPath();                deleteNode(deleteTxn.getPath(), header.getZxid());                break;            case OpCode.reconfig:            case OpCode.setData:                SetDataTxn setDataTxn = (SetDataTxn) txn;                rc.path = setDataTxn.getPath();                rc.stat = setData(setDataTxn.getPath(), setDataTxn.getData(), setDataTxn.getVersion(), header.getZxid(), header.getTime());                break;            case OpCode.setACL:                SetACLTxn setACLTxn = (SetACLTxn) txn;                rc.path = setACLTxn.getPath();                rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());                break;            case OpCode.closeSession:                long sessionId = header.getClientId();                if (txn != null) {                    killSession(sessionId, header.getZxid(), ephemerals.remove(sessionId), ((CloseSessionTxn) txn).getPaths2Delete());                } else {                    killSession(sessionId, header.getZxid());                }                break;            case OpCode.error:                ErrorTxn errTxn = (ErrorTxn) txn;                rc.err = errTxn.getErr();                break;            case OpCode.check:                CheckVersionTxn checkTxn = (CheckVersionTxn) txn;                rc.path = checkTxn.getPath();                break;            case OpCode.multi:                MultiTxn multiTxn = (MultiTxn) txn;                List<Txn> txns = multiTxn.getTxns();                rc.multiResult = new ArrayList<ProcessTxnResult>();                boolean failed = false;                for (Txn subtxn : txns) {                    if (subtxn.getType() == OpCode.error) {                        failed = true;                        break;                    }                }                boolean post_failed = false;                for (Txn subtxn : txns) {                    ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());                    Record record = null;                    switch(subtxn.getType()) {                        case OpCode.create:                            record = new CreateTxn();                            break;                        case OpCode.createTTL:                            record = new CreateTTLTxn();                            break;                        case OpCode.createContainer:                            record = new CreateContainerTxn();                            break;                        case OpCode.delete:                        case OpCode.deleteContainer:                            record = new DeleteTxn();                            break;                        case OpCode.setData:                            record = new SetDataTxn();                            break;                        case OpCode.error:                            record = new ErrorTxn();                            post_failed = true;                            break;                        case OpCode.check:                            record = new CheckVersionTxn();                            break;                        default:                            throw new IOException("Invalid type of op: " + subtxn.getType());                    }                    assert (record != null);                    ByteBufferInputStream.byteBuffer2Record(bb, record);                    if (failed && subtxn.getType() != OpCode.error) {                        int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() : Code.OK.intValue();                        subtxn.setType(OpCode.error);                        record = new ErrorTxn(ec);                    }                    assert !failed || (subtxn.getType() == OpCode.error);                    TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(), header.getZxid(), header.getTime(), subtxn.getType());                    ProcessTxnResult subRc = processTxn(subHdr, record, true);                    rc.multiResult.add(subRc);                    if (subRc.err != 0 && rc.err == 0) {                        rc.err = subRc.err;                    }                }                break;        }    } catch (KeeperException e) {                rc.err = e.code().intValue();    } catch (IOException e) {            }    /*         * Snapshots are taken lazily. When serializing a node, it's data         * and children copied in a synchronization block on that node,         * which means newly created node won't be in the snapshot, so         * we won't have mismatched cversion and pzxid when replaying the         * createNode txn.         *         * But there is a tricky scenario that if the child is deleted due         * to session close and re-created in a different global session         * after that the parent is serialized, then when replay the txn         * because the node is belonging to a different session, replay the         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS         * error when replay the createNode txn. In this case, we need to         * update the cversion and pzxid to the new value.         *         * Note, such failures on DT should be seen only during         * restore.         */    if (header.getType() == OpCode.create && rc.err == Code.NODEEXISTS.intValue()) {                int lastSlash = rc.path.lastIndexOf('/');        String parentName = rc.path.substring(0, lastSlash);        CreateTxn cTxn = (CreateTxn) txn;        try {            setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());        } catch (KeeperException.NoNodeException e) {                        rc.err = e.code().intValue();        }    } else if (rc.err != Code.OK.intValue()) {            }    /*         * Things we can only update after the whole txn is applied to data         * tree.         *         * If we update the lastProcessedZxid with the first sub txn in multi         * and there is a snapshot in progress, it's possible that the zxid         * associated with the snapshot only include partial of the multi op.         *         * When loading snapshot, it will only load the txns after the zxid         * associated with snapshot file, which could cause data inconsistency         * due to missing sub txns.         *         * To avoid this, we only update the lastProcessedZxid when the whole         * multi-op txn is applied to DataTree.         */    if (!isSubTxn) {        /*             * A snapshot might be in progress while we are modifying the data             * tree. If we set lastProcessedZxid prior to making corresponding             * change to the tree, then the zxid associated with the snapshot             * file will be ahead of its contents. Thus, while restoring from             * the snapshot, the restore method will not apply the transaction             * for zxid associated with the snapshot file, since the restore             * method assumes that transaction to be present in the snapshot.             *             * To avoid this, we first apply the transaction and then modify             * lastProcessedZxid.  During restore, we correctly handle the             * case where the snapshot contains data ahead of the zxid associated             * with the file.             */        if (rc.zxid > lastProcessedZxid) {            lastProcessedZxid = rc.zxid;        }        if (digestFromLoadedSnapshot != null) {            compareSnapshotDigests(rc.zxid);        } else {                        logZxidDigest(rc.zxid, getTreeDigest());        }    }    return rc;}
1
 void killSession(long session, long zxid)
{                            killSession(session, zxid, ephemerals.remove(session), null);}
0
 void killSession(long session, long zxid, Set<String> paths2DeleteLocal, List<String> paths2DeleteInTxn)
{    if (paths2DeleteInTxn != null) {        deleteNodes(session, zxid, paths2DeleteInTxn);    }    if (paths2DeleteLocal == null) {        return;    }    if (paths2DeleteInTxn != null) {                for (String path : paths2DeleteInTxn) {            paths2DeleteLocal.remove(path);        }        if (!paths2DeleteLocal.isEmpty()) {                    }    }    deleteNodes(session, zxid, paths2DeleteLocal);}
1
 void deleteNodes(long session, long zxid, Iterable<String> paths2Delete)
{    for (String path : paths2Delete) {        try {            deleteNode(path, zxid);            if (LOG.isDebugEnabled()) {                            }        } catch (NoNodeException e) {                    }    }}
1
private void getCounts(String path, Counts counts)
{    DataNode node = getNode(path);    if (node == null) {        return;    }    String[] children = null;    int len = 0;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);        len = (node.data == null ? 0 : node.data.length);    }        counts.count += 1;    counts.bytes += len;    for (String child : children) {        getCounts(path + "/" + child, counts);    }}
0
private void updateQuotaForPath(String path)
{    Counts c = new Counts();    getCounts(path, c);    StatsTrack strack = new StatsTrack();    strack.setBytes(c.bytes);    strack.setCount(c.count);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    DataNode node = getNode(statPath);        if (node == null) {                return;    }    synchronized (node) {        nodes.preChange(statPath, node);        node.data = strack.toString().getBytes();        nodes.postChange(statPath, node);    }}
1
private void traverseNode(String path)
{    DataNode node = getNode(path);    String[] children = null;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    if (children.length == 0) {                                String endString = "/" + Quotas.limitNode;        if (path.endsWith(endString)) {                                                String realPath = path.substring(Quotas.quotaZookeeper.length(), path.indexOf(endString));            updateQuotaForPath(realPath);            this.pTrie.addPath(realPath);        }        return;    }    for (String child : children) {        traverseNode(path + "/" + child);    }}
0
private void setupQuota()
{    String quotaPath = Quotas.quotaZookeeper;    DataNode node = getNode(quotaPath);    if (node == null) {        return;    }    traverseNode(quotaPath);}
0
 void serializeNode(OutputArchive oa, StringBuilder path) throws IOException
{    String pathString = path.toString();    DataNode node = getNode(pathString);    if (node == null) {        return;    }    String[] children = null;    DataNode nodeCopy;    synchronized (node) {        StatPersisted statCopy = new StatPersisted();        copyStatPersisted(node.stat, statCopy);                        nodeCopy = new DataNode(node.data, node.acl, statCopy);        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    serializeNodeData(oa, pathString, nodeCopy);    path.append('/');    int off = path.length();    for (String child : children) {                                path.delete(off, Integer.MAX_VALUE);        path.append(child);        serializeNode(oa, path);    }}
0
public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException
{    oa.writeString(path, "path");    oa.writeRecord(node, "node");}
0
public void serializeAcls(OutputArchive oa) throws IOException
{    aclCache.serialize(oa);}
0
public void serializeNodes(OutputArchive oa) throws IOException
{    serializeNode(oa, new StringBuilder());        if (root != null) {        oa.writeString("/", "path");    }}
0
public void serialize(OutputArchive oa, String tag) throws IOException
{    serializeAcls(oa);    serializeNodes(oa);}
0
public void deserialize(InputArchive ia, String tag) throws IOException
{    aclCache.deserialize(ia);    nodes.clear();    pTrie.clear();    nodeDataSize.set(0);    String path = ia.readString("path");    while (!"/".equals(path)) {        DataNode node = new DataNode();        ia.readRecord(node, "node");        nodes.put(path, node);        synchronized (node) {            aclCache.addUsage(node.acl);        }        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1) {            root = node;        } else {            String parentPath = path.substring(0, lastSlash);            DataNode parent = nodes.get(parentPath);            if (parent == null) {                throw new IOException("Invalid Datatree, unable to find " + "parent " + parentPath + " of path " + path);            }            parent.addChild(path.substring(lastSlash + 1));            long eowner = node.stat.getEphemeralOwner();            EphemeralType ephemeralType = EphemeralType.get(eowner);            if (ephemeralType == EphemeralType.CONTAINER) {                containers.add(path);            } else if (ephemeralType == EphemeralType.TTL) {                ttls.add(path);            } else if (eowner != 0) {                HashSet<String> list = ephemerals.get(eowner);                if (list == null) {                    list = new HashSet<String>();                    ephemerals.put(eowner, list);                }                list.add(path);            }        }        path = ia.readString("path");    }            nodes.putWithoutDigest("/", root);    nodeDataSize.set(approximateDataSize());                    setupQuota();    aclCache.purgeUnused();}
0
public synchronized void dumpWatchesSummary(PrintWriter pwriter)
{    pwriter.print(dataWatches.toString());}
0
public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath)
{    dataWatches.dumpWatches(pwriter, byPath);}
0
public synchronized WatchesReport getWatches()
{    return dataWatches.getWatches();}
0
public synchronized WatchesPathReport getWatchesByPath()
{    return dataWatches.getWatchesByPath();}
0
public synchronized WatchesSummary getWatchesSummary()
{    return dataWatches.getWatchesSummary();}
0
public void dumpEphemerals(PrintWriter pwriter)
{    pwriter.println("Sessions with Ephemerals (" + ephemerals.keySet().size() + "):");    for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {        pwriter.print("0x" + Long.toHexString(entry.getKey()));        pwriter.println(":");        Set<String> tmp = entry.getValue();        if (tmp != null) {            synchronized (tmp) {                for (String path : tmp) {                    pwriter.println("\t" + path);                }            }        }    }}
0
public void shutdownWatcher()
{    dataWatches.shutdown();    childWatches.shutdown();}
0
public Map<Long, Set<String>> getEphemerals()
{    Map<Long, Set<String>> ephemeralsCopy = new HashMap<Long, Set<String>>();    for (Entry<Long, HashSet<String>> e : ephemerals.entrySet()) {        synchronized (e.getValue()) {            ephemeralsCopy.put(e.getKey(), new HashSet<String>(e.getValue()));        }    }    return ephemeralsCopy;}
0
public void removeCnxn(Watcher watcher)
{    dataWatches.removeWatcher(watcher);    childWatches.removeWatcher(watcher);}
0
public void setWatches(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    for (String path : dataWatches) {        DataNode node = getNode(path);        WatchedEvent e = null;        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getMzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : existWatches) {        DataNode node = getNode(path);        if (node != null) {            watcher.process(new WatchedEvent(EventType.NodeCreated, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : childWatches) {        DataNode node = getNode(path);        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getPzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, path));        } else {            this.childWatches.addWatch(path, watcher);        }    }}
0
public void setCversionPzxid(String path, int newCversion, long zxid) throws KeeperException.NoNodeException
{    if (path.endsWith("/")) {        path = path.substring(0, path.length() - 1);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException(path);    }    synchronized (node) {        if (newCversion == -1) {            newCversion = node.stat.getCversion() + 1;        }        if (newCversion > node.stat.getCversion()) {            nodes.preChange(path, node);            node.stat.setCversion(newCversion);            node.stat.setPzxid(zxid);            nodes.postChange(path, node);        }    }}
0
public boolean containsWatcher(String path, WatcherType type, Watcher watcher)
{    boolean containsWatcher = false;    switch(type) {        case Children:            containsWatcher = this.childWatches.containsWatcher(path, watcher);            break;        case Data:            containsWatcher = this.dataWatches.containsWatcher(path, watcher);            break;        case Any:            if (this.childWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            if (this.dataWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            break;    }    return containsWatcher;}
0
public boolean removeWatch(String path, WatcherType type, Watcher watcher)
{    boolean removed = false;    switch(type) {        case Children:            removed = this.childWatches.removeWatcher(path, watcher);            break;        case Data:            removed = this.dataWatches.removeWatcher(path, watcher);            break;        case Any:            if (this.childWatches.removeWatcher(path, watcher)) {                removed = true;            }            if (this.dataWatches.removeWatcher(path, watcher)) {                removed = true;            }            break;    }    return removed;}
0
public ReferenceCountedACLCache getReferenceCountedAclCache()
{    return aclCache;}
0
private String getTopNamespace(String path)
{    String[] parts = path.split("/");    return parts.length > 1 ? parts[1] : null;}
0
private void updateReadStat(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    long totalBytes = path.length() + bytes + STAT_OVERHEAD_BYTES;    ServerMetrics.getMetrics().READ_PER_NAMESPACE.add(namespace, totalBytes);}
0
private void updateWriteStat(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    ServerMetrics.getMetrics().WRITE_PER_NAMESPACE.add(namespace, path.length() + bytes);}
0
private void logZxidDigest(long zxid, long digest)
{    ZxidDigest zxidDigest = new ZxidDigest(zxid, digestCalculator.getDigestVersion(), digest);    lastProcessedZxidDigest = zxidDigest;    if (zxidDigest.zxid % DIGEST_LOG_INTERVAL == 0) {        synchronized (digestLog) {            digestLog.add(zxidDigest);            if (digestLog.size() > DIGEST_LOG_LIMIT) {                digestLog.poll();            }        }    }}
0
public boolean serializeZxidDigest(OutputArchive oa) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    ZxidDigest zxidDigest = lastProcessedZxidDigest;    if (zxidDigest == null) {                zxidDigest = new ZxidDigest();    }    zxidDigest.serialize(oa);    return true;}
0
public boolean deserializeZxidDigest(InputArchive ia) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    try {        ZxidDigest zxidDigest = new ZxidDigest();        zxidDigest.deserialize(ia);        if (zxidDigest.zxid > 0) {            digestFromLoadedSnapshot = zxidDigest;        }        return true;    } catch (EOFException e) {                return false;    }}
1
public void compareSnapshotDigests(long zxid)
{    if (zxid == digestFromLoadedSnapshot.zxid) {        if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {                        digestFromLoadedSnapshot = null;            return;        }        if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {            reportDigestMismatch(zxid);        }        digestFromLoadedSnapshot = null;    } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {            }}
1
public void reportDigestMismatch(long zxid)
{    ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.add(1);    RATE_LOGGER.rateLimitLog("Digests are not matching. Value is Zxid.", String.valueOf(zxid));    for (DigestWatcher watcher : digestWatchers) {        watcher.process(zxid);    }}
0
public long getTreeDigest()
{    return nodes.getDigest();}
0
public ZxidDigest getLastProcessedZxidDigest()
{    return lastProcessedZxidDigest;}
0
public ZxidDigest getDigestFromLoadedSnapshot()
{    return digestFromLoadedSnapshot;}
0
public void addDigestWatcher(DigestWatcher digestWatcher)
{    digestWatchers.add(digestWatcher);}
0
public List<ZxidDigest> getDigestLog()
{    synchronized (digestLog) {                return new LinkedList<ZxidDigest>(digestLog);    }}
0
public void serialize(OutputArchive oa) throws IOException
{    oa.writeLong(zxid, "zxid");    oa.writeInt(digestVersion, "digestVersion");    oa.writeLong(digest, "digest");}
0
public void deserialize(InputArchive ia) throws IOException
{    zxid = ia.readLong("zxid");    digestVersion = ia.readInt("digestVersion");        if (digestVersion < 2) {        String d = ia.readString("digest");        if (d != null) {            digest = Long.parseLong(d);        }    } else {        digest = ia.readLong("digest");    }}
0
public long getZxid()
{    return zxid;}
0
public int getDigestVersion()
{    return digestVersion;}
0
public Long getDigest()
{    return digest;}
0
public int getNodeCount()
{    return dataTree.getNodeCount();}
0
public long approximateDataSize()
{    return dataTree.cachedApproximateDataSize();}
0
public int countEphemerals()
{    return dataTree.getEphemeralsCount();}
0
public int getWatchCount()
{    return dataTree.getWatchCount();}
0
public String getName()
{    return "InMemoryDataTree";}
0
public boolean isHidden()
{    return false;}
0
public String getLastZxid()
{    return "0x" + Long.toHexString(dataTree.lastProcessedZxid);}
0
 long calculateDigest(String path, byte[] data, StatPersisted stat)
{    if (!ZooKeeperServer.isDigestEnabled()) {        return 0;    }        if (path.startsWith(ZooDefs.ZOOKEEPER_NODE_SUBTREE)) {        return 0;    }        if (path.equals("/")) {        path = "";    }        byte[] b = new byte[60];    ByteBuffer bb = ByteBuffer.wrap(b);    bb.putLong(stat.getCzxid());    bb.putLong(stat.getMzxid());    bb.putLong(stat.getPzxid());    bb.putLong(stat.getCtime());    bb.putLong(stat.getMtime());    bb.putInt(stat.getVersion());    bb.putInt(stat.getCversion());    bb.putInt(stat.getAversion());    bb.putLong(stat.getEphemeralOwner());    CRC32 crc = new CRC32();    crc.update(path.getBytes());    if (data != null) {        crc.update(data);    }    crc.update(b);    return crc.getValue();}
0
 long calculateDigest(String path, DataNode node)
{    if (!node.isDigestCached()) {        node.setDigest(calculateDigest(path, node.getData(), node.stat));        node.setDigestCached(true);    }    return node.getDigest();}
0
 int getDigestVersion()
{    return DIGEST_VERSION;}
0
 void setSessionTimeout(int sessionTimeout)
{}
0
public void process(WatchedEvent event)
{}
0
 int getSessionTimeout()
{    return 0;}
0
public void close(DisconnectReason reason)
{}
0
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
0
public void sendCloseSession()
{}
0
public long getSessionId()
{    return sessionId;}
0
 void setSessionId(long sessionId)
{}
0
 void sendBuffer(ByteBuffer... closeConn)
{}
0
 void enableRecv()
{}
0
 void disableRecv(boolean waitDisableRecv)
{}
0
protected ServerStats serverStats()
{    return null;}
0
public long getOutstandingRequests()
{    return 0;}
0
public InetSocketAddress getRemoteSocketAddress()
{    return null;}
0
public int getInterestOps()
{    return 0;}
0
public boolean isSecure()
{    return false;}
0
public Certificate[] getClientCertificateChain()
{    return null;}
0
public void setClientCertificateChain(Certificate[] chain)
{}
0
public long maxValue()
{    return 0;}
0
public long toEphemeralOwner(long value)
{    return 0;}
0
public long getValue(long ephemeralOwner)
{    return 0;}
0
public static boolean extendedEphemeralTypesEnabled()
{    return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);}
0
public static EphemeralType get(long ephemeralOwner)
{    if (extendedEphemeralTypesEnabled()) {        if (Boolean.getBoolean(TTL_3_5_3_EMULATION_PROPERTY)) {            if (EphemeralTypeEmulate353.get(ephemeralOwner) == EphemeralTypeEmulate353.TTL) {                return TTL;            }        }        if ((ephemeralOwner & EXTENDED_MASK) == EXTENDED_MASK) {            long extendedFeatureBit = getExtendedFeatureBit(ephemeralOwner);            EphemeralType ephemeralType = extendedFeatureMap.get(extendedFeatureBit);            if (ephemeralType == null) {                throw new IllegalArgumentException(String.format("Invalid ephemeralOwner. [%s]", Long.toHexString(ephemeralOwner)));            }            return ephemeralType;        }    }    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
0
public static void validateServerId(long serverId)
{    if (extendedEphemeralTypesEnabled()) {        if (serverId > EphemeralType.MAX_EXTENDED_SERVER_ID) {            throw new RuntimeException("extendedTypesEnabled is true but Server ID is too large. Cannot be larger than " + EphemeralType.MAX_EXTENDED_SERVER_ID);        }    }}
0
public static void validateTTL(CreateMode mode, long ttl)
{    if (mode.isTTL()) {        TTL.toEphemeralOwner(ttl);    } else if (ttl >= 0) {        throw new IllegalArgumentException("ttl not valid for mode: " + mode);    }}
0
private static long getExtendedFeatureBit(long ephemeralOwner)
{    return (ephemeralOwner & RESERVED_BITS_MASK) >> RESERVED_BITS_SHIFT;}
0
private static long getExtendedFeatureValue(long ephemeralOwner)
{    return ephemeralOwner & EXTENDED_FEATURE_VALUE_MASK;}
0
public long maxValue()
{        return EXTENDED_FEATURE_VALUE_MASK;}
0
public long toEphemeralOwner(long ttl)
{    if ((ttl > TTL.maxValue()) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + TTL.maxValue());    }        return EXTENDED_MASK | EXTENDED_BIT_TTL |     ttl;}
0
public long getValue(long ephemeralOwner)
{    return getExtendedFeatureValue(ephemeralOwner);}
0
public static EphemeralTypeEmulate353 get(long ephemeralOwner)
{    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    if (ephemeralOwner < 0) {        return TTL;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
0
public static long ttlToEphemeralOwner(long ttl)
{    if ((ttl > MAX_TTL) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + MAX_TTL);    }    return TTL_MASK | ttl;}
0
public int getValue()
{    return value;}
0
private long roundToNextInterval(long time)
{    return (time / expirationInterval + 1) * expirationInterval;}
0
public Long remove(E elem)
{    Long expiryTime = elemMap.remove(elem);    if (expiryTime != null) {        Set<E> set = expiryMap.get(expiryTime);        if (set != null) {            set.remove(elem);                        }    }    return expiryTime;}
0
public Long update(E elem, int timeout)
{    Long prevExpiryTime = elemMap.get(elem);    long now = Time.currentElapsedTime();    Long newExpiryTime = roundToNextInterval(now + timeout);    if (newExpiryTime.equals(prevExpiryTime)) {                return null;    }        Set<E> set = expiryMap.get(newExpiryTime);    if (set == null) {                set = Collections.newSetFromMap(new ConcurrentHashMap<E, Boolean>());                        Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(elem);            prevExpiryTime = elemMap.put(elem, newExpiryTime);    if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {        Set<E> prevSet = expiryMap.get(prevExpiryTime);        if (prevSet != null) {            prevSet.remove(elem);        }    }    return newExpiryTime;}
0
public long getWaitTime()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    return now < expirationTime ? (expirationTime - now) : 0L;}
0
public Set<E> poll()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    if (now < expirationTime) {        return Collections.emptySet();    }    Set<E> set = null;    long newExpirationTime = expirationTime + expirationInterval;    if (nextExpirationTime.compareAndSet(expirationTime, newExpirationTime)) {        set = expiryMap.remove(expirationTime);    }    if (set == null) {        return Collections.emptySet();    }    return set;}
0
public void dump(PrintWriter pwriter)
{    pwriter.print("Sets (");    pwriter.print(expiryMap.size());    pwriter.print(")/(");    pwriter.print(elemMap.size());    pwriter.println("):");    ArrayList<Long> keys = new ArrayList<Long>(expiryMap.keySet());    Collections.sort(keys);    for (long time : keys) {        Set<E> set = expiryMap.get(time);        if (set != null) {            pwriter.print(set.size());            pwriter.print(" expire at ");            pwriter.print(Time.elapsedTimeToDate(time));            pwriter.println(":");            for (E elem : set) {                pwriter.print("\t");                pwriter.println(elem.toString());            }        }    }}
0
public Map<Long, Set<E>> getExpiryMap()
{    return Collections.unmodifiableMap(expiryMap);}
0
public void processRequest(Request request)
{            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;    if (request.type == OpCode.ping) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logRequest(LOG, traceMask, 'E', request, "");    }    ProcessTxnResult rc = zks.processTxn(request);        if (request.type == OpCode.closeSession && connClosedByClient(request)) {                if (closeSession(zks.serverCnxnFactory, request.sessionId) || closeSession(zks.secureServerCnxnFactory, request.sessionId)) {            return;        }    }    if (request.getHdr() != null) {        /*             * Request header is created only by the leader, so this must be             * a quorum request. Since we're comparing timestamps across hosts,             * this metric may be incorrect. However, it's still a very useful             * metric to track in the happy case. If there is clock drift,             * the latency can go negative. Note: headers use wall time, not             * CLOCK_MONOTONIC.             */        long propagationLatency = Time.currentWallTime() - request.getHdr().getTime();        if (propagationLatency >= 0) {            ServerMetrics.getMetrics().PROPAGATION_LATENCY.add(propagationLatency);        }    }    if (request.cnxn == null) {        return;    }    ServerCnxn cnxn = request.cnxn;    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();    String lastOp = "NA";            zks.decInProcess();    zks.requestFinished(request);    Code err = Code.OK;    Record rsp = null;    String path = null;    try {        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {            /*                 * When local session upgrading is disabled, leader will                 * reject the ephemeral node creation due to session expire.                 * However, if this is the follower that issue the request,                 * it will have the correct error code, so we should use that                 * and report to user                 */            if (request.getException() != null) {                throw request.getException();            } else {                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));            }        }        KeeperException ke = request.getException();        if (ke instanceof SessionMovedException) {            throw ke;        }        if (ke != null && request.type != OpCode.multi) {            throw ke;        }                if (request.isStale()) {            ServerMetrics.getMetrics().STALE_REPLIES.add(1);        }        switch(request.type) {            case OpCode.ping:                {                    lastOp = "PING";                    updateStats(request, lastOp, lastZxid);                    cnxn.sendResponse(new ReplyHeader(-2, lastZxid, 0), null, "response");                    return;                }            case OpCode.createSession:                {                    lastOp = "SESS";                    updateStats(request, lastOp, lastZxid);                    zks.finishSessionInit(request.cnxn, true);                    return;                }            case OpCode.multi:                {                    lastOp = "MULT";                    rsp = new MultiResponse();                    for (ProcessTxnResult subTxnResult : rc.multiResult) {                        OpResult subResult;                        switch(subTxnResult.type) {                            case OpCode.check:                                subResult = new CheckResult();                                break;                            case OpCode.create:                                subResult = new CreateResult(subTxnResult.path);                                break;                            case OpCode.create2:                            case OpCode.createTTL:                            case OpCode.createContainer:                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);                                break;                            case OpCode.delete:                            case OpCode.deleteContainer:                                subResult = new DeleteResult();                                break;                            case OpCode.setData:                                subResult = new SetDataResult(subTxnResult.stat);                                break;                            case OpCode.error:                                subResult = new ErrorResult(subTxnResult.err);                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {                                    throw new SessionMovedException();                                }                                break;                            default:                                throw new IOException("Invalid type of op");                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.multiRead:                {                    lastOp = "MLTR";                    MultiOperationRecord multiReadRecord = new MultiOperationRecord();                    ByteBufferInputStream.byteBuffer2Record(request.request, multiReadRecord);                    rsp = new MultiResponse();                    OpResult subResult;                    for (Op readOp : multiReadRecord) {                        try {                            Record rec;                            switch(readOp.getType()) {                                case OpCode.getChildren:                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());                                    break;                                case OpCode.getData:                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    GetDataResponse gdr = (GetDataResponse) rec;                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());                                    break;                                default:                                    throw new IOException("Invalid type of readOp");                            }                        } catch (KeeperException e) {                            subResult = new ErrorResult(e.code().intValue());                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.create:                {                    lastOp = "CREA";                    rsp = new CreateResponse(rc.path);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.create2:            case OpCode.createTTL:            case OpCode.createContainer:                {                    lastOp = "CREA";                    rsp = new Create2Response(rc.path, rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.delete:            case OpCode.deleteContainer:                {                    lastOp = "DELE";                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.setData:                {                    lastOp = "SETD";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.reconfig:                {                    lastOp = "RECO";                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.setACL:                {                    lastOp = "SETA";                    rsp = new SetACLResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.closeSession:                {                    lastOp = "CLOS";                    err = Code.get(rc.err);                    break;                }            case OpCode.sync:                {                    lastOp = "SYNC";                    SyncRequest syncRequest = new SyncRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, syncRequest);                    rsp = new SyncResponse(syncRequest.getPath());                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());                    break;                }            case OpCode.check:                {                    lastOp = "CHEC";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.exists:                {                    lastOp = "EXIS";                                        ExistsRequest existsRequest = new ExistsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, existsRequest);                    path = existsRequest.getPath();                    if (path.indexOf('\0') != -1) {                        throw new KeeperException.BadArgumentsException();                    }                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);                    rsp = new ExistsResponse(stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getData:                {                    lastOp = "GETD";                    GetDataRequest getDataRequest = new GetDataRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getDataRequest);                    path = getDataRequest.getPath();                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.setWatches:                {                    lastOp = "SETW";                    SetWatches setWatches = new SetWatches();                                        request.request.rewind();                    ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);                    long relativeZxid = setWatches.getRelativeZxid();                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), cnxn);                    break;                }            case OpCode.getACL:                {                    lastOp = "GETA";                    GetACLRequest getACLRequest = new GetACLRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getACLRequest);                    path = getACLRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);                    Stat stat = new Stat();                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());                    try {                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);                        rsp = new GetACLResponse(acl, stat);                    } catch (KeeperException.NoAuthException e) {                        List<ACL> acl1 = new ArrayList<ACL>(acl.size());                        for (ACL a : acl) {                            if ("digest".equals(a.getId().getScheme())) {                                Id id = a.getId();                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(":.*", ":x"));                                acl1.add(new ACL(a.getPerms(), id1));                            } else {                                acl1.add(a);                            }                        }                        rsp = new GetACLResponse(acl1, stat);                    }                    break;                }            case OpCode.getChildren:                {                    lastOp = "GETC";                    GetChildrenRequest getChildrenRequest = new GetChildrenRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildrenRequest);                    path = getChildrenRequest.getPath();                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getAllChildrenNumber:                {                    lastOp = "GETACN";                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = new GetAllChildrenNumberRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getAllChildrenNumberRequest);                    path = getAllChildrenNumberRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    int number = zks.getZKDatabase().getAllChildrenNumber(path);                    rsp = new GetAllChildrenNumberResponse(number);                    break;                }            case OpCode.getChildren2:                {                    lastOp = "GETC";                    GetChildren2Request getChildren2Request = new GetChildren2Request();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildren2Request);                    Stat stat = new Stat();                    path = getChildren2Request.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);                    rsp = new GetChildren2Response(children, stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.checkWatches:                {                    lastOp = "CHKW";                    CheckWatchesRequest checkWatches = new CheckWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, checkWatches);                    WatcherType type = WatcherType.fromInt(checkWatches.getType());                    path = checkWatches.getPath();                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);                    if (!containsWatcher) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());                    break;                }            case OpCode.removeWatches:                {                    lastOp = "REMW";                    RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, removeWatches);                    WatcherType type = WatcherType.fromInt(removeWatches.getType());                    path = removeWatches.getPath();                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);                    if (!removed) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());                    break;                }            case OpCode.getEphemerals:                {                    lastOp = "GETE";                    GetEphemeralsRequest getEphemerals = new GetEphemeralsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getEphemerals);                    String prefixPath = getEphemerals.getPrefixPath();                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);                    List<String> ephemerals = new ArrayList<>();                    if (StringUtils.isBlank(prefixPath) || "/".equals(prefixPath.trim())) {                        ephemerals.addAll(allEphems);                    } else {                        for (String p : allEphems) {                            if (p.startsWith(prefixPath)) {                                ephemerals.add(p);                            }                        }                    }                    rsp = new GetEphemeralsResponse(ephemerals);                    break;                }        }    } catch (SessionMovedException e) {                                                                        cnxn.sendCloseSession();        return;    } catch (KeeperException e) {        err = e.code();    } catch (Exception e) {                                StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        bb.rewind();        while (bb.hasRemaining()) {            sb.append(Integer.toHexString(bb.get() & 0xff));        }                err = Code.MARSHALLINGERROR;    }    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());    updateStats(request, lastOp, lastZxid);    try {        if (request.type == OpCode.getData && path != null && rsp != null) {                                                GetDataResponse getDataResponse = (GetDataResponse) rsp;            Stat stat = null;            if (getDataResponse.getStat() != null) {                stat = getDataResponse.getStat();            }            cnxn.sendResponse(hdr, rsp, "response", path, stat);        } else {            cnxn.sendResponse(hdr, rsp, "response");        }        if (request.type == OpCode.closeSession) {            cnxn.sendCloseSession();        }    } catch (IOException e) {            }}
1
private Record handleGetChildrenRequest(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetChildrenRequest getChildrenRequest = (GetChildrenRequest) request;    String path = getChildrenRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    List<String> children = zks.getZKDatabase().getChildren(path, null, getChildrenRequest.getWatch() ? cnxn : null);    return new GetChildrenResponse(children);}
0
private Record handleGetDataRequest(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetDataRequest getDataRequest = (GetDataRequest) request;    String path = getDataRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    Stat stat = new Stat();    byte[] b = zks.getZKDatabase().getData(path, stat, getDataRequest.getWatch() ? cnxn : null);    return new GetDataResponse(b, stat);}
0
private boolean closeSession(ServerCnxnFactory serverCnxnFactory, long sessionId)
{    if (serverCnxnFactory == null) {        return false;    }    return serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_CLOSED_SESSION);}
0
private boolean connClosedByClient(Request request)
{    return request.cnxn == null;}
0
public void shutdown()
{        }
1
private void updateStats(Request request, String lastOp, long lastZxid)
{    if (request.cnxn == null) {        return;    }    long currentTime = Time.currentElapsedTime();    zks.serverStats().updateLatency(request, currentTime);    request.cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp, request.createTime, currentTime);}
0
public static void main(String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("USAGE: LogFormatter log_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(args[0]);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileInputStream fis = new FileInputStream(args[0]);    BinaryInputArchive logStream = BinaryInputArchive.getArchive(fis);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number for " + args[0]);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())) + " session 0x" + Long.toHexString(hdr.getClientId()) + " cxid 0x" + Long.toHexString(hdr.getCxid()) + " zxid 0x" + Long.toHexString(hdr.getZxid()) + " " + Request.op2String(hdr.getType()) + " " + txn);        if (logStream.readByte("EOR") != 'B') {                        throw new EOFException("Last transaction was partial.");        }        count++;    }}
1
public void addDataPoint(long value)
{    total.addAndGet(value);    count.incrementAndGet();    setMin(value);    setMax(value);}
0
private void setMax(long value)
{    long current;    while (value > (current = max.get()) && !max.compareAndSet(current, value)) {        }}
0
private void setMin(long value)
{    long current;    while (value < (current = min.get()) && !min.compareAndSet(current, value)) {        }}
0
public double getAvg()
{            long currentCount = count.get();    long currentTotal = total.get();    if (currentCount > 0) {        double avgLatency = currentTotal / (double) currentCount;        BigDecimal bg = new BigDecimal(avgLatency);        return bg.setScale(4, RoundingMode.HALF_UP).doubleValue();    }    return 0;}
0
public long getCount()
{    return count.get();}
0
public long getMax()
{    long current = max.get();    return (current == Long.MIN_VALUE) ? 0 : current;}
0
public long getMin()
{    long current = min.get();    return (current == Long.MAX_VALUE) ? 0 : current;}
0
public long getTotal()
{    return total.get();}
0
public void resetMax()
{    max.set(getMin());}
0
public void reset()
{    count.set(0);    total.set(0);    min.set(Long.MAX_VALUE);    max.set(Long.MIN_VALUE);}
0
public void add(long value)
{    addDataPoint(value);}
0
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put("avg_" + name, this.getAvg());    m.put("min_" + name, this.getMin());    m.put("max_" + name, this.getMax());    m.put("cnt_" + name, this.getCount());    m.put("sum_" + name, this.getTotal());    return m;}
0
private AvgMinMaxCounter getCounterForKey(String key)
{    AvgMinMaxCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
0
public void addDataPoint(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
0
public void resetMax()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
0
public void reset()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
0
public void add(String key, long value)
{    addDataPoint(key, value);}
0
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
0
public int size()
{    final long c = count.get();    if (c > values.length()) {        return values.length();    }    return (int) c;}
0
public void update(long value)
{    final long c = count.incrementAndGet();    if (c <= values.length()) {        values.set((int) c - 1, value);    } else {        final long r = nextLong(c);        if (r < values.length()) {            values.set((int) r, value);        }    }}
0
private static long nextLong(long n)
{    long bits, val;    do {        bits = ThreadLocalRandom.current().nextLong() & (~(1L << BITS_PER_LONG));        val = bits % n;    } while (bits - val + (n - 1) < 0L);    return val;}
0
public Snapshot getSnapshot()
{    final int s = size();    final List<Long> copy = new ArrayList<Long>(s);    for (int i = 0; i < s; i++) {        copy.add(values.get(i));    }    return new UniformSnapshot(copy);}
0
public void reset()
{    count.set(0);    values = new AtomicLongArray(DEFAULT_SIZE);}
0
public void addDataPoint(long value)
{    counter.add(value);    histogram.update(value);}
0
public void resetMax()
{        counter.resetMax();}
0
public void reset()
{    counter.reset();    reservoir.reset();}
0
public void add(long value)
{    addDataPoint(value);}
0
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    m.putAll(counter.values());    m.put("p50_" + name, Math.round(this.histogram.getSnapshot().getMedian()));    m.put("p95_" + name, Math.round(this.histogram.getSnapshot().get95thPercentile()));    m.put("p99_" + name, Math.round(this.histogram.getSnapshot().get99thPercentile()));    m.put("p999_" + name, Math.round(this.histogram.getSnapshot().get999thPercentile()));    return m;}
0
private AvgMinMaxPercentileCounter getCounterForKey(String key)
{    AvgMinMaxPercentileCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxPercentileCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
0
public void addDataPoint(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
0
public void resetMax()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
0
public void reset()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
0
public void add(String key, long value)
{    addDataPoint(key, value);}
0
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
0
public void add(long value)
{}
0
public void add(int key, long value)
{}
0
public void add(String key, long value)
{}
0
public void reset()
{}
0
public void add(long value)
{    counter.addAndGet(value);}
0
public void reset()
{    counter.set(0);}
0
public long get()
{    return counter.get();}
0
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put(name, this.get());    return m;}
0
public void close(DisconnectReason reason)
{    disconnectReason = reason;    close();}
0
public void close()
{    closingChannel = true;    if (LOG.isDebugEnabled()) {            }    setStale();                factory.unregisterConnection(this);        if (!factory.cnxns.remove(this)) {        if (LOG.isDebugEnabled()) {                    }        return;    }    if (LOG.isDebugEnabled()) {            }    factory.removeCnxnFromSessionMap(this);    factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (channel.isOpen()) {                                channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture future) {                future.channel().close().addListener(f -> releaseQueuedBuffer());            }        });    } else {        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);        channel.eventLoop().execute(this::releaseQueuedBuffer);    }}
1
public void operationComplete(ChannelFuture future)
{    future.channel().close().addListener(f -> releaseQueuedBuffer());}
0
public long getSessionId()
{    return sessionId;}
0
public int getSessionTimeout()
{    return sessionTimeout;}
0
public void process(WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    try {        sendResponse(h, e, "notification");    } catch (IOException e1) {        if (LOG.isDebugEnabled()) {                    }        close();    }}
1
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{        if (closingChannel || !channel.isOpen()) {        return;    }    sendBuffer(serialize(h, r, tag, cacheKey, stat));    decrOutstandingAndCheckThrottle(h);}
0
public void setSessionId(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
0
public void sendBuffer(ByteBuffer... buffers)
{    if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {        close(DisconnectReason.CLIENT_CLOSED_CONNECTION);        return;    }    channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);}
0
private void checkFlush(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
0
public void close() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
0
public void flush() throws IOException
{    checkFlush(true);}
0
public void write(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
0
private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len)
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);                channel.config().setAutoRead(false);    packetReceived(4);    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {                NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }        if (len == FourLetterCommands.setTraceMaskCmd) {        ByteBuffer mask = ByteBuffer.allocate(8);        message.readBytes(mask);        mask.flip();        long traceMask = mask.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
1
private void checkIsInEventLoop(String callerMethodName)
{    if (!channel.eventLoop().inEventLoop()) {        throw new IllegalStateException(callerMethodName + "() called from non-EventLoop thread");    }}
0
private void appendToQueuedBuffer(ByteBuf buf)
{    checkIsInEventLoop("appendToQueuedBuffer");    if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {                queuedBuffer.consolidate();    }    queuedBuffer.addComponent(true, buf);    ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());}
0
 void processMessage(ByteBuf buf)
{    checkIsInEventLoop("processMessage");    if (LOG.isDebugEnabled()) {            }    if (LOG.isTraceEnabled()) {        LOG.trace("0x{} buf {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));    }    if (throttled.get()) {                        if (queuedBuffer == null) {                        queuedBuffer = channel.alloc().compositeBuffer();        }        appendToQueuedBuffer(buf.retainedDuplicate());        if (LOG.isTraceEnabled()) {            LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }    } else {                if (queuedBuffer != null) {            appendToQueuedBuffer(buf.retainedDuplicate());            processQueuedBuffer();        } else {            receiveMessage(buf);                        if (!closingChannel && buf.isReadable()) {                LOG.trace("Before copy {}", buf);                if (queuedBuffer == null) {                    queuedBuffer = channel.alloc().compositeBuffer();                }                appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));                if (LOG.isTraceEnabled()) {                    LOG.trace("Copy is {}", queuedBuffer);                    LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));                }            }        }    }}
1
 void processQueuedBuffer()
{    checkIsInEventLoop("processQueuedBuffer");    if (queuedBuffer != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("processing queue 0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }        receiveMessage(queuedBuffer);        if (closingChannel) {                                } else if (!queuedBuffer.isReadable()) {                        releaseQueuedBuffer();        } else {                                                queuedBuffer.discardReadComponents();        }    } else {            }}
1
private void releaseQueuedBuffer()
{    checkIsInEventLoop("releaseQueuedBuffer");    if (queuedBuffer != null) {        queuedBuffer.release();        queuedBuffer = null;    }}
0
private void receiveMessage(ByteBuf message)
{    checkIsInEventLoop("receiveMessage");    try {        while (message.isReadable() && !throttled.get()) {            if (bb != null) {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() > message.readableBytes()) {                    int newLimit = bb.position() + message.readableBytes();                    bb.limit(newLimit);                }                message.readBytes(bb);                bb.limit(bb.capacity());                if (LOG.isTraceEnabled()) {                    LOG.trace("after readBytes message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("after readbytes 0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() == 0) {                    bb.flip();                    packetReceived(4 + bb.remaining());                    ZooKeeperServer zks = this.zkServer;                    if (zks == null || !zks.isRunning()) {                        throw new IOException("ZK down");                    }                    if (initialized) {                                                                        zks.processPacket(this, bb);                    } else {                                                zks.processConnectRequest(this, bb);                        initialized = true;                    }                    bb = null;                }            } else {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bblenrem {}", message.readableBytes(), bbLen.remaining());                    ByteBuffer dat = bbLen.duplicate();                    dat.flip();                    LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (message.readableBytes() < bbLen.remaining()) {                    bbLen.limit(bbLen.position() + message.readableBytes());                }                message.readBytes(bbLen);                bbLen.limit(bbLen.capacity());                if (bbLen.remaining() == 0) {                    bbLen.flip();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));                    }                    int len = bbLen.getInt();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen len is {}", Long.toHexString(sessionId), len);                    }                    bbLen.clear();                    if (!initialized) {                        if (checkFourLetterWord(channel, message, len)) {                            return;                        }                    }                    if (len < 0 || len > BinaryInputArchive.maxBuffer) {                        throw new IOException("Len error " + len);                    }                                        zkServer.checkRequestSizeWhenReceivingMessage(len);                    bb = ByteBuffer.allocate(len);                }            }        }    } catch (IOException e) {                close(DisconnectReason.IO_EXCEPTION);    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);                close(DisconnectReason.CLIENT_RATE_LIMIT);    }}
1
public void disableRecv(boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {                channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);    }}
1
public void enableRecv()
{    if (throttled.compareAndSet(true, false)) {                channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);    }}
1
public void setSessionTimeout(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;}
0
public int getInterestOps()
{        if (channel == null || !channel.isOpen()) {        return 0;    }    int interestOps = 0;    if (!throttled.get()) {        interestOps |= SelectionKey.OP_READ;    }    if (!channel.isWritable()) {                        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
0
public InetSocketAddress getRemoteSocketAddress()
{    return (InetSocketAddress) channel.remoteAddress();}
0
public void sendCloseSession()
{    sendBuffer(ServerCnxnFactory.closeConn);}
0
protected ServerStats serverStats()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
0
public boolean isSecure()
{    return factory.secure;}
0
public Certificate[] getClientCertificateChain()
{    if (clientChain == null) {        return null;    }    return Arrays.copyOf(clientChain, clientChain.length);}
0
public void setClientCertificateChain(Certificate[] chain)
{    if (chain == null) {        clientChain = null;    } else {        clientChain = Arrays.copyOf(chain, chain.length);    }}
0
 Channel getChannel()
{    return channel;}
0
public int getQueuedReadableBytes()
{    checkIsInEventLoop("getQueuedReadableBytes");    if (queuedBuffer != null) {        return queuedBuffer.readableBytes();    }    return 0;}
0
protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> out) throws Exception
{    if (in.readableBytes() >= 5) {        super.decode(context, in, out);    } else if (in.readableBytes() > 0) {                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {                        handleNonSsl(context);        }    }}
1
private void handleNonSsl(ChannelHandlerContext context)
{    ChannelHandler handler = this.newNonSslHandler(context);    if (handler != null) {        context.pipeline().replace(this, this.newNonSslHandlerName(), handler);    } else {        context.pipeline().remove(this);    }}
0
protected SslHandler newSslHandler(ChannelHandlerContext context, SslContext sslContext)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());        SslHandler handler = super.newSslHandler(context, sslContext);    Future<Channel> handshakeFuture = handler.handshakeFuture();    handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));    return handler;}
1
protected ChannelHandler newNonSslHandler(ChannelHandlerContext context)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());        allChannels.add(context.channel());    addCnxn(cnxn);    return super.newNonSslHandler(context);}
1
public void channelActive(ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel active {}", ctx.channel());    }    final Channel channel = ctx.channel();    InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();    if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);                channel.close();        return;    }    NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);    ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);    if (secure) {        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);        Future<Channel> handshakeFuture = sslHandler.handshakeFuture();        handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));    } else if (!shouldUsePortUnification) {        allChannels.add(ctx.channel());        addCnxn(cnxn);    }}
1
public void channelInactive(ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel inactive {}", ctx.channel());    }    allChannels.remove(ctx.channel());    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("Channel inactive caused close {}", cnxn);        }        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);    }}
0
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
{        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);    }}
1
public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception
{    try {        if (evt == NettyServerCnxn.ReadEvent.ENABLE) {                        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();                        if (cnxn != null) {                if (cnxn.getQueuedReadableBytes() > 0) {                    cnxn.processQueuedBuffer();                    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {                                                                        ctx.read();                                            }                }            }            if (!advancedFlowControlEnabled) {                ctx.channel().config().setAutoRead(true);            }        } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {                        ctx.channel().config().setAutoRead(false);        }    } finally {        ReferenceCountUtil.release(evt);    }}
1
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
{    try {        LOG.trace("message received called {}", msg);        try {                        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();            if (cnxn == null) {                            } else {                cnxn.processMessage((ByteBuf) msg);            }        } catch (Exception ex) {                        throw ex;        }    } finally {        ReferenceCountUtil.release(msg);    }}
1
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception
{    if (advancedFlowControlEnabled) {        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();        if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {            ctx.read();                    }    }    ctx.fireChannelReadComplete();}
1
public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception
{    if (LOG.isTraceEnabled()) {        promise.addListener(onWriteCompletedTracer);    }    super.write(ctx, msg, promise);}
0
public void operationComplete(Future<Channel> future)
{    if (future.isSuccess()) {        if (LOG.isDebugEnabled()) {                    }        SSLEngine eng = sslHandler.engine();                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {            SSLSession session = eng.getSession();            try {                cnxn.setClientCertificateChain(session.getPeerCertificates());            } catch (SSLPeerUnverifiedException e) {                if (eng.getNeedClientAuth()) {                                                            cnxn.close();                    return;                } else {                                                            final Channel futureChannel = future.getNow();                    allChannels.add(Objects.requireNonNull(futureChannel));                    addCnxn(cnxn);                    return;                }            } catch (Exception e) {                                cnxn.close();                return;            }            String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), "x509");            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);            if (authProvider == null) {                                cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);                return;            }            if (KeeperException.Code.OK != authProvider.handleAuthentication(cnxn, null)) {                                cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);                return;            }        }        final Channel futureChannel = future.getNow();        allChannels.add(Objects.requireNonNull(futureChannel));        addCnxn(cnxn);    } else {                cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    }}
1
public void read(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete++;    }    ctx.read();}
0
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete = 0;    }    ctx.fireChannelReadComplete();}
0
private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator).childOption(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
0
protected void initChannel(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (advancedFlowControlEnabled) {        pipeline.addLast(readIssuedTrackingHandler);    }    if (secure) {        initSSL(pipeline, false);    } else if (shouldUsePortUnification) {        initSSL(pipeline, true);    }    pipeline.addLast("servercnxnfactory", channelHandler);}
0
private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException
{    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());    SslContext nettySslContext;    if (authProviderProp == null) {        SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();        nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);    } else {        SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), "x509"));        if (authProvider == null) {                        throw new SSLContextException("Could not create SSLContext with specified auth provider: " + authProviderProp);        }        sslContext.init(new X509KeyManager[] { authProvider.getKeyManager() }, new X509TrustManager[] { authProvider.getTrustManager() }, null);        nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);    }    if (supportPlaintext) {        p.addLast("ssl", new DualModeSslHandler(nettySslContext));            } else {        p.addLast("ssl", nettySslContext.newHandler(p.channel().alloc()));            }}
1
public void closeAll(ServerCnxn.DisconnectReason reason)
{            int length = cnxns.size();    for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {                    }    }    }
1
public void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException
{    configureSaslLogin();    localAddress = addr;    this.maxClientCnxns = maxClientCnxns;    this.secure = secure;    this.listenBacklog = backlog;}
0
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxns;}
0
public void setMaxClientCnxnsPerHost(int max)
{    maxClientCnxns = max;}
0
public int getSocketListenBacklog()
{    return listenBacklog;}
0
public int getLocalPort()
{    return localAddress.getPort();}
0
public void join() throws InterruptedException
{    synchronized (this) {        while (!killed) {            wait();        }    }}
0
public void shutdown()
{    synchronized (this) {        if (killed) {                        return;        }    }        x509Util.close();    if (login != null) {        login.shutdown();    }    final EventLoopGroup bossGroup = bootstrap.config().group();    final EventLoopGroup workerGroup = bootstrap.config().childGroup();        if (parentChannel != null) {        ChannelFuture parentCloseFuture = parentChannel.close();        if (bossGroup != null) {            parentCloseFuture.addListener(future -> {                bossGroup.shutdownGracefully();            });        }        closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        ChannelGroupFuture allChannelsCloseFuture = allChannels.close();        if (workerGroup != null) {            allChannelsCloseFuture.addListener(future -> {                workerGroup.shutdownGracefully();            });        }    } else {        if (bossGroup != null) {            bossGroup.shutdownGracefully();        }        if (workerGroup != null) {            workerGroup.shutdownGracefully();        }    }    if (zkServer != null) {        zkServer.shutdown();    }    synchronized (this) {        killed = true;        notifyAll();    }}
1
public void start()
{    if (listenBacklog != -1) {        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);    }        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();            localAddress = (InetSocketAddress) parentChannel.localAddress();    }
1
public void reconfigure(InetSocketAddress addr)
{        if (addr != null && localAddress != null) {        if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {                        return;        }    }    Channel oldChannel = parentChannel;    try {        parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();                        localAddress = (InetSocketAddress) parentChannel.localAddress();            } catch (Exception e) {            } finally {        oldChannel.close();    }}
1
public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
0
public Iterable<ServerCnxn> getConnections()
{    return cnxns;}
0
public InetSocketAddress getLocalAddress()
{    return localAddress;}
0
private void addCnxn(final NettyServerCnxn cnxn)
{    cnxns.add(cnxn);    InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();    ipMap.compute(addr, (a, cnxnCount) -> {        if (cnxnCount == null) {            cnxnCount = new AtomicInteger();        }        cnxnCount.incrementAndGet();        return cnxnCount;    });}
0
 void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress)
{    ipMap.compute(remoteAddress, (addr, cnxnCount) -> {        if (cnxnCount == null) {                        return null;        }        final int newValue = cnxnCount.decrementAndGet();        return newValue == 0 ? null : cnxnCount;    });}
1
private int getClientCnxnCount(final InetAddress addr)
{    final AtomicInteger count = ipMap.get(addr);    return count == null ? 0 : count.get();}
0
public void resetAllConnectionStats()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
0
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    Set<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
0
 static void setTestAllocator(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
0
 static void clearTestAllocator()
{    TEST_ALLOCATOR.set(null);}
0
public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled)
{    this.advancedFlowControlEnabled = advancedFlowControlEnabled;}
0
public void setSecure(boolean secure)
{    this.secure = secure;}
0
public Channel getParentChannel()
{    return parentChannel;}
0
public void sendCloseSession()
{    sendBuffer(ServerCnxnFactory.closeConn);}
0
 void sendBufferSync(ByteBuffer bb)
{    try {        /* configure socket to be blocking             * so that we dont have to do write in             * a tight while loop             */        if (bb != ServerCnxnFactory.closeConn) {            if (sock.isOpen()) {                sock.configureBlocking(true);                sock.write(bb);            }            packetSent();        }    } catch (IOException ie) {            }}
1
public void sendBuffer(ByteBuffer... buffers)
{    LOG.trace("Add a buffer to outgoingBuffers, sk {} is valid: {}", sk, sk.isValid());    synchronized (outgoingBuffers) {        for (ByteBuffer buffer : buffers) {            outgoingBuffers.add(buffer);        }        outgoingBuffers.add(packetSentinel);    }    requestInterestOpsUpdate();}
0
private void handleFailedRead() throws EndOfStreamException
{    setStale();    ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);    throw new EndOfStreamException("Unable to read additional data from client," + " it probably closed the socket:" + " address = " + sock.socket().getRemoteSocketAddress() + "," + " session = 0x" + Long.toHexString(sessionId), DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);}
0
private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (incomingBuffer.remaining() != 0) {                        int rc = sock.read(incomingBuffer);        if (rc < 0) {            handleFailedRead();        }    }    if (incomingBuffer.remaining() == 0) {                incomingBuffer.flip();        packetReceived(4 + incomingBuffer.remaining());        if (!initialized) {            readConnectRequest();        } else {            readRequest();        }        lenBuffer.clear();        incomingBuffer = lenBuffer;    }}
0
public boolean isSelectable()
{    return sk.isValid() && selectable.get();}
0
public void disableSelectable()
{    selectable.set(false);}
0
public void enableSelectable()
{    selectable.set(true);}
0
private void requestInterestOpsUpdate()
{    if (isSelectable()) {        selectorThread.addInterestOpsUpdateRequest(sk);    }}
0
 void handleWrite(SelectionKey k) throws IOException
{    if (outgoingBuffers.isEmpty()) {        return;    }    /*         * This is going to reset the buffer position to 0 and the         * limit to the size of the buffer, so that we can fill it         * with data from the non-direct buffers that we need to         * send.         */    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();    if (directBuffer == null) {        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];                        sock.write(outgoingBuffers.toArray(bufferList));                ByteBuffer bb;        while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (bb.remaining() > 0) {                break;            }            outgoingBuffers.remove();        }    } else {        directBuffer.clear();        for (ByteBuffer b : outgoingBuffers) {            if (directBuffer.remaining() < b.remaining()) {                /*                     * When we call put later, if the directBuffer is to                     * small to hold everything, nothing will be copied,                     * so we've got to slice the buffer if it's too big.                     */                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());            }            /*                 * put() is going to modify the positions of both                 * buffers, put we don't want to change the position of                 * the source buffers (we'll do that after the send, if                 * needed), so we save and reset the position after the                 * copy                 */            int p = b.position();            directBuffer.put(b);            b.position(p);            if (directBuffer.remaining() == 0) {                break;            }        }        /*             * Do the flip: limit becomes position, position gets set to             * 0. This sets us up for the write.             */        directBuffer.flip();        int sent = sock.write(directBuffer);        ByteBuffer bb;                while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (sent < bb.remaining()) {                /*                     * We only partially sent this buffer, so we update                     * the position and exit the loop.                     */                bb.position(bb.position() + sent);                break;            }            /* We've sent the whole buffer, so drop the buffer */            sent -= bb.remaining();            outgoingBuffers.remove();        }    }}
0
protected boolean isSocketOpen()
{    return sock.isOpen();}
0
 void doIO(SelectionKey k) throws InterruptedException
{    try {        if (!isSocketOpen()) {                        return;        }        if (k.isReadable()) {            int rc = sock.read(incomingBuffer);            if (rc < 0) {                handleFailedRead();            }            if (incomingBuffer.remaining() == 0) {                boolean isPayload;                if (incomingBuffer == lenBuffer) {                                        incomingBuffer.flip();                    isPayload = readLength(k);                    incomingBuffer.clear();                } else {                                        isPayload = true;                }                if (isPayload) {                                        readPayload();                } else {                                        return;                }            }        }        if (k.isWritable()) {            handleWrite(k);            if (!initialized && !getReadInterest() && !getWriteInterest()) {                throw new CloseRequestException("responded to info probe", DisconnectReason.INFO_PROBE);            }        }    } catch (CancelledKeyException e) {                        close(DisconnectReason.CANCELLED_KEY_EXCEPTION);    } catch (CloseRequestException e) {                close();    } catch (EndOfStreamException e) {                        close(e.getReason());    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        if (LOG.isDebugEnabled()) {                    }        close(DisconnectReason.CLIENT_CNX_LIMIT);    } catch (IOException e) {                        close(DisconnectReason.IO_EXCEPTION);    }}
1
private void readRequest() throws IOException
{    zkServer.processPacket(this, incomingBuffer);}
0
private boolean getWriteInterest()
{    return !outgoingBuffers.isEmpty();}
0
private boolean getReadInterest()
{    return !throttled.get();}
0
public void disableRecv(boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {        requestInterestOpsUpdate();    }}
0
public void enableRecv()
{    if (throttled.compareAndSet(true, false)) {        requestInterestOpsUpdate();    }}
0
private void readConnectRequest() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }    zkServer.processConnectRequest(this, incomingBuffer);    initialized = true;}
0
private void checkFlush(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
0
public void close() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
0
public void flush() throws IOException
{    checkFlush(true);}
0
public void write(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
0
private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);    packetReceived(4);    /**     * cancel the selection key to remove the socket handling     * from selector. This is to prevent netcat problem wherein     * netcat immediately closes the sending side after sending the     * commands and still keeps the receiving channel open.     * The idea is to remove the selectionkey from the selector     * so that the selector does not notice the closed read on the     * socket channel and keep the socket alive to write the data to     * and makes sure to close the socket after its done writing the data     */    if (k != null) {        try {            k.cancel();        } catch (Exception e) {                    }    }    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {                NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }        if (len == FourLetterCommands.setTraceMaskCmd) {        incomingBuffer = ByteBuffer.allocate(8);        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new IOException("Read error");        }        incomingBuffer.flip();        long traceMask = incomingBuffer.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
1
private boolean readLength(SelectionKey k) throws IOException
{        int len = lenBuffer.getInt();    if (!initialized && checkFourLetterWord(sk, len)) {        return false;    }    if (len < 0 || len > BinaryInputArchive.maxBuffer) {        throw new IOException("Len error " + len);    }    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }        zkServer.checkRequestSizeWhenReceivingMessage(len);    incomingBuffer = ByteBuffer.allocate(len);    return true;}
0
 boolean isZKServerRunning()
{    return zkServer != null && zkServer.isRunning();}
0
public int getSessionTimeout()
{    return sessionTimeout;}
0
public String toString()
{    return "ip: " + sock.socket().getRemoteSocketAddress() + " sessionId: 0x" + Long.toHexString(sessionId);}
0
public void close(DisconnectReason reason)
{    disconnectReason = reason;    close();}
0
private void close()
{    setStale();    if (!factory.removeCnxn(this)) {        return;    }    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (sk != null) {        try {                        sk.cancel();        } catch (Exception e) {                    }    }    closeSock();}
1
private void closeSock()
{    if (!sock.isOpen()) {        return;    }    if (LOG.isDebugEnabled()) {            }    closeSock(sock);}
1
public static void closeSock(SocketChannel sock)
{    if (!sock.isOpen()) {        return;    }    try {        /*             * The following sequence of code is stupid! You would think that             * only sock.close() is needed, but alas, it doesn't work that way.             * If you just do sock.close() there are cases where the socket             * doesn't actually close...             */        sock.socket().shutdownOutput();    } catch (IOException e) {                    }    try {        sock.socket().shutdownInput();    } catch (IOException e) {                    }    try {        sock.socket().close();    } catch (IOException e) {            }    try {        sock.close();    } catch (IOException e) {            }}
1
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat)
{    try {        sendBuffer(serialize(h, r, tag, cacheKey, stat));        decrOutstandingAndCheckThrottle(h);    } catch (Exception e) {            }}
1
public void process(WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    sendResponse(h, e, "notification", null, null);}
0
public long getSessionId()
{    return sessionId;}
0
public void setSessionId(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
0
public void setSessionTimeout(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;    factory.touchCnxn(this);}
0
public int getInterestOps()
{    if (!isSelectable()) {        return 0;    }    int interestOps = 0;    if (getReadInterest()) {        interestOps |= SelectionKey.OP_READ;    }    if (getWriteInterest()) {        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
0
public InetSocketAddress getRemoteSocketAddress()
{    if (!sock.isOpen()) {        return null;    }    return (InetSocketAddress) sock.socket().getRemoteSocketAddress();}
0
public InetAddress getSocketAddress()
{    if (!sock.isOpen()) {        return null;    }    return sock.socket().getInetAddress();}
0
protected ServerStats serverStats()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
0
public boolean isSecure()
{    return false;}
0
public Certificate[] getClientCertificateChain()
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
0
public void setClientCertificateChain(Certificate[] chain)
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
0
public void uncaughtException(Thread t, Throwable e)
{    }
1
public void wakeupSelector()
{    selector.wakeup();}
0
protected void closeSelector()
{    try {        selector.close();    } catch (IOException e) {            }}
1
protected void cleanupSelectionKey(SelectionKey key)
{    if (key != null) {        try {            key.cancel();        } catch (Exception ex) {                    }    }}
1
protected void fastCloseSock(SocketChannel sc)
{    if (sc != null) {        try {                        sc.socket().setSoLinger(true, 0);        } catch (SocketException e) {                    }        NIOServerCnxn.closeSock(sc);    }}
1
public void run()
{    try {        while (!stopped && !acceptSocket.socket().isClosed()) {            try {                select();            } catch (RuntimeException e) {                            } catch (Exception e) {                            }        }    } finally {        closeSelector();                if (!reconfiguring) {            NIOServerCnxnFactory.this.stop();        }            }}
1
public void setReconfiguring()
{    reconfiguring = true;}
0
private void select()
{    try {        selector.select();        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selectedKeys.remove();            if (!key.isValid()) {                continue;            }            if (key.isAcceptable()) {                if (!doAccept()) {                                                                                                    pauseAccept(10);                }            } else {                            }        }    } catch (IOException e) {            }}
1
private void pauseAccept(long millisecs)
{    acceptKey.interestOps(0);    try {        selector.select(millisecs);    } catch (IOException e) {        } finally {        acceptKey.interestOps(SelectionKey.OP_ACCEPT);    }}
0
private boolean doAccept()
{    boolean accepted = false;    SocketChannel sc = null;    try {        sc = acceptSocket.accept();        accepted = true;        InetAddress ia = sc.socket().getInetAddress();        int cnxncount = getClientCnxnCount(ia);        if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {            throw new IOException("Too many connections from " + ia + " - max is " + maxClientCnxns);        }                sc.configureBlocking(false);                if (!selectorIterator.hasNext()) {            selectorIterator = selectorThreads.iterator();        }        SelectorThread selectorThread = selectorIterator.next();        if (!selectorThread.addAcceptedConnection(sc)) {            throw new IOException("Unable to add connection to selector queue" + (stopped ? " (shutdown in progress)" : ""));        }        acceptErrorLogger.flush();    } catch (IOException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        acceptErrorLogger.rateLimitLog("Error accepting new connection: " + e.getMessage());        fastCloseSock(sc);    }    return accepted;}
1
public boolean addAcceptedConnection(SocketChannel accepted)
{    if (stopped || !acceptedQueue.offer(accepted)) {        return false;    }    wakeupSelector();    return true;}
0
public boolean addInterestOpsUpdateRequest(SelectionKey sk)
{    if (stopped || !updateQueue.offer(sk)) {        return false;    }    wakeupSelector();    return true;}
0
public void run()
{    try {        while (!stopped) {            try {                select();                processAcceptedConnections();                processInterestOpsUpdateRequests();            } catch (RuntimeException e) {                            } catch (Exception e) {                            }        }                for (SelectionKey key : selector.keys()) {            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            if (cnxn.isSelectable()) {                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            }            cleanupSelectionKey(key);        }        SocketChannel accepted;        while ((accepted = acceptedQueue.poll()) != null) {            fastCloseSock(accepted);        }        updateQueue.clear();    } finally {        closeSelector();                        NIOServerCnxnFactory.this.stop();            }}
1
private void select()
{    try {        selector.select();        Set<SelectionKey> selected = selector.selectedKeys();        ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(selected);        Collections.shuffle(selectedList);        Iterator<SelectionKey> selectedKeys = selectedList.iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selected.remove(key);            if (!key.isValid()) {                cleanupSelectionKey(key);                continue;            }            if (key.isReadable() || key.isWritable()) {                handleIO(key);            } else {                            }        }    } catch (IOException e) {            }}
1
private void handleIO(SelectionKey key)
{    IOWorkRequest workRequest = new IOWorkRequest(this, key);    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            cnxn.disableSelectable();    key.interestOps(0);    touchCnxn(cnxn);    workerPool.schedule(workRequest);}
0
private void processAcceptedConnections()
{    SocketChannel accepted;    while (!stopped && (accepted = acceptedQueue.poll()) != null) {        SelectionKey key = null;        try {            key = accepted.register(selector, SelectionKey.OP_READ);            NIOServerCnxn cnxn = createConnection(accepted, key, this);            key.attach(cnxn);            addCnxn(cnxn);        } catch (IOException e) {                        cleanupSelectionKey(key);            fastCloseSock(accepted);        }    }}
0
private void processInterestOpsUpdateRequests()
{    SelectionKey key;    while (!stopped && (key = updateQueue.poll()) != null) {        if (!key.isValid()) {            cleanupSelectionKey(key);        }        NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();        if (cnxn.isSelectable()) {            key.interestOps(cnxn.getInterestOps());        }    }}
0
public void doWork() throws InterruptedException
{    if (!key.isValid()) {        selectorThread.cleanupSelectionKey(key);        return;    }    if (key.isReadable() || key.isWritable()) {        cnxn.doIO(key);                if (stopped) {            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            return;        }        if (!key.isValid()) {            selectorThread.cleanupSelectionKey(key);            return;        }        touchCnxn(cnxn);    }        cnxn.enableSelectable();        if (!selectorThread.addInterestOpsUpdateRequest(key)) {        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);    }}
0
public void cleanup()
{    cnxn.close(ServerCnxn.DisconnectReason.CLEAN_UP);}
0
public void run()
{    try {        while (!stopped) {            long waitTime = cnxnExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);            }        }    } catch (InterruptedException e) {            }}
1
protected ByteBuffer initialValue()
{    return ByteBuffer.allocateDirect(directBufferBytes);}
0
public static ByteBuffer getDirectBuffer()
{    return directBufferBytes > 0 ? directBuffer.get() : null;}
0
public void configure(InetSocketAddress addr, int maxcc, int backlog, boolean secure) throws IOException
{    if (secure) {        throw new UnsupportedOperationException("SSL isn't supported in NIOServerCnxn");    }    configureSaslLogin();    maxClientCnxns = maxcc;    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);                    cnxnExpiryQueue = new ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);    expirerThread = new ConnectionExpirerThread();    int numCores = Runtime.getRuntime().availableProcessors();        numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));    if (numSelectorThreads < 1) {        throw new IOException("numSelectorThreads must be at least 1");    }    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);        for (int i = 0; i < numSelectorThreads; ++i) {        selectorThreads.add(new SelectorThread(i));    }    listenBacklog = backlog;    this.ss = ServerSocketChannel.open();    ss.socket().setReuseAddress(true);        if (listenBacklog == -1) {        ss.socket().bind(addr);    } else {        ss.socket().bind(addr, listenBacklog);    }    ss.configureBlocking(false);    acceptThread = new AcceptThread(ss, addr, selectorThreads);}
1
private void tryClose(ServerSocketChannel s)
{    try {        s.close();    } catch (IOException sse) {            }}
1
public void reconfigure(InetSocketAddress addr)
{    ServerSocketChannel oldSS = ss;    try {        acceptThread.setReconfiguring();        tryClose(oldSS);        acceptThread.wakeupSelector();        try {            acceptThread.join();        } catch (InterruptedException e) {                        Thread.currentThread().interrupt();        }        this.ss = ServerSocketChannel.open();        ss.socket().setReuseAddress(true);                ss.socket().bind(addr);        ss.configureBlocking(false);        acceptThread = new AcceptThread(ss, addr, selectorThreads);        acceptThread.start();    } catch (IOException e) {                tryClose(oldSS);    }}
1
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxns;}
0
public void setMaxClientCnxnsPerHost(int max)
{    maxClientCnxns = max;}
0
public int getSocketListenBacklog()
{    return listenBacklog;}
0
public void start()
{    stopped = false;    if (workerPool == null) {        workerPool = new WorkerService("NIOWorker", numWorkerThreads, false);    }    for (SelectorThread thread : selectorThreads) {        if (thread.getState() == Thread.State.NEW) {            thread.start();        }    }        if (acceptThread.getState() == Thread.State.NEW) {        acceptThread.start();    }    if (expirerThread.getState() == Thread.State.NEW) {        expirerThread.start();    }}
0
public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
0
public InetSocketAddress getLocalAddress()
{    return (InetSocketAddress) ss.socket().getLocalSocketAddress();}
0
public int getLocalPort()
{    return ss.socket().getLocalPort();}
0
public boolean removeCnxn(NIOServerCnxn cnxn)
{        if (!cnxns.remove(cnxn)) {        return false;    }    cnxnExpiryQueue.remove(cnxn);    removeCnxnFromSessionMap(cnxn);    InetAddress addr = cnxn.getSocketAddress();    if (addr != null) {        Set<NIOServerCnxn> set = ipMap.get(addr);        if (set != null) {            set.remove(cnxn);                        }    }        unregisterConnection(cnxn);    return true;}
0
public void touchCnxn(NIOServerCnxn cnxn)
{    cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());}
0
private void addCnxn(NIOServerCnxn cnxn) throws IOException
{    InetAddress addr = cnxn.getSocketAddress();    if (addr == null) {        throw new IOException("Socket of " + cnxn + " has been closed");    }    Set<NIOServerCnxn> set = ipMap.get(addr);    if (set == null) {                                                        set = Collections.newSetFromMap(new ConcurrentHashMap<NIOServerCnxn, Boolean>(2));                        Set<NIOServerCnxn> existingSet = ipMap.putIfAbsent(addr, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(cnxn);    cnxns.add(cnxn);    touchCnxn(cnxn);}
0
protected NIOServerCnxn createConnection(SocketChannel sock, SelectionKey sk, SelectorThread selectorThread) throws IOException
{    return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);}
0
private int getClientCnxnCount(InetAddress cl)
{    Set<NIOServerCnxn> s = ipMap.get(cl);    if (s == null) {        return 0;    }    return s.size();}
0
public void closeAll(ServerCnxn.DisconnectReason reason)
{        for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {                    }    }}
1
public void stop()
{    stopped = true;        try {        ss.close();    } catch (IOException e) {            }    if (acceptThread != null) {        if (acceptThread.isAlive()) {            acceptThread.wakeupSelector();        } else {            acceptThread.closeSelector();        }    }    if (expirerThread != null) {        expirerThread.interrupt();    }    for (SelectorThread thread : selectorThreads) {        if (thread.isAlive()) {            thread.wakeupSelector();        } else {            thread.closeSelector();        }    }    if (workerPool != null) {        workerPool.stop();    }}
1
public void shutdown()
{    try {                stop();                join();                closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        if (login != null) {            login.shutdown();        }    } catch (InterruptedException e) {            } catch (Exception e) {            }    if (zkServer != null) {        zkServer.shutdown();    }}
1
public void join() throws InterruptedException
{    if (acceptThread != null) {        acceptThread.join();    }    for (SelectorThread thread : selectorThreads) {        thread.join();    }    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }}
0
public Iterable<ServerCnxn> getConnections()
{    return cnxns;}
0
public void dumpConnections(PrintWriter pwriter)
{    pwriter.print("Connections ");    cnxnExpiryQueue.dump(pwriter);}
0
public void resetAllConnectionStats()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
0
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    HashSet<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
0
public DataNode put(String path, DataNode node)
{    DataNode oldNode = nodes.put(path, node);    addDigest(path, node);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
0
public DataNode putWithoutDigest(String path, DataNode node)
{    return nodes.put(path, node);}
0
public DataNode get(String path)
{    return nodes.get(path);}
0
public DataNode remove(String path)
{    DataNode oldNode = nodes.remove(path);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
0
public ConcurrentHashMap.KeySetView<String, DataNode> keySet()
{    return nodes.keySet();}
0
public Set<Map.Entry<String, DataNode>> entrySet()
{    return nodes.entrySet();}
0
public void clear()
{    nodes.clear();    hash = new AdHash();}
0
public int size()
{    return nodes.size();}
0
public void preChange(String path, DataNode node)
{    removeDigest(path, node);}
0
public void postChange(String path, DataNode node)
{            node.digestCached = false;    addDigest(path, node);}
0
private void addDigest(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.addDigest(digestCalculator.calculateDigest(path, node));    }}
0
private void removeDigest(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.removeDigest(digestCalculator.calculateDigest(path, node));    }}
0
public long getDigest()
{    return hash.getHash();}
0
public String getName()
{    return "Observer";}
0
public int getPendingRevalidationCount()
{    return this.observer.getPendingRevalidationsCount();}
0
public String getQuorumAddress()
{    return observer.getSocket().toString();}
0
public String getLearnerMaster()
{    QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();    if (learnerMaster == null || learnerMaster.addr == null) {        return "Unknown";    }    return learnerMaster.addr.getAddress().getHostAddress() + ":" + learnerMaster.addr.getPort();}
0
public void setLearnerMaster(String learnerMaster)
{    if (!observer.setLearnerMaster(learnerMaster)) {        throw new IllegalArgumentException("Not a valid learner master");    }}
0
public static long getPreAllocSize()
{    return preAllocSize;}
0
public static void setPreallocSize(long size)
{    preAllocSize = size;}
0
public void setCurrentSize(long currentSize)
{    this.currentSize = currentSize;}
0
 long padFile(FileChannel fileChannel) throws IOException
{    long newFileSize = calculateFileSizeWithPadding(fileChannel.position(), currentSize, preAllocSize);    if (currentSize != newFileSize) {        fileChannel.write((ByteBuffer) fill.position(0), newFileSize - fill.remaining());        currentSize = newFileSize;    }    return currentSize;}
0
public static long calculateFileSizeWithPadding(long position, long fileSize, long preAllocSize)
{        if (preAllocSize > 0 && position + 4096 >= fileSize) {                if (position > fileSize) {            fileSize = position + preAllocSize;            fileSize -= fileSize % preAllocSize;        } else {            fileSize += preAllocSize;        }    }    return fileSize;}
0
public SnapshotInfo getLastSnapshotInfo()
{    return this.lastSnapshotInfo;}
0
public long deserialize(DataTree dt, Map<Long, Integer> sessions) throws IOException
{                List<File> snapList = findNValidSnapshots(100);    if (snapList.size() == 0) {        return -1L;    }    File snap = null;    boolean foundValid = false;    for (int i = 0, snapListSize = snapList.size(); i < snapListSize; i++) {        snap = snapList.get(i);                try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {            InputArchive ia = BinaryInputArchive.getArchive(snapIS);            deserialize(dt, sessions, ia);            SnapStream.checkSealIntegrity(snapIS, ia);            if (dt.deserializeZxidDigest(ia)) {                SnapStream.checkSealIntegrity(snapIS, ia);            }            foundValid = true;            break;        } catch (IOException e) {                    }    }    if (!foundValid) {        throw new IOException("Not able to find valid snapshots in " + snapDir);    }    dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);    lastSnapshotInfo = new SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / 1000);        if (dt.getDigestFromLoadedSnapshot() != null) {        dt.compareSnapshotDigests(dt.lastProcessedZxid);    }    return dt.lastProcessedZxid;}
1
public void deserialize(DataTree dt, Map<Long, Integer> sessions, InputArchive ia) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != SNAP_MAGIC) {        throw new IOException("mismatching magic headers " + header.getMagic() + " !=  " + FileSnap.SNAP_MAGIC);    }    SerializeUtils.deserializeSnapshot(dt, ia, sessions);}
0
public File findMostRecentSnapshot() throws IOException
{    List<File> files = findNValidSnapshots(1);    if (files.size() == 0) {        return null;    }    return files.get(0);}
0
private List<File> findNValidSnapshots(int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {                try {            if (SnapStream.isValidSnapshot(f)) {                list.add(f);                count++;                if (count == n) {                    break;                }            }        } catch (IOException e) {                    }    }    return list;}
1
public List<File> findNRecentSnapshots(int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {        if (count == n) {            break;        }        if (Util.getZxidFromName(f.getName(), SNAPSHOT_FILE_PREFIX) != -1) {            count++;            list.add(f);        }    }    return list;}
0
protected void serialize(DataTree dt, Map<Long, Integer> sessions, OutputArchive oa, FileHeader header) throws IOException
{        if (header == null) {        throw new IllegalStateException("Snapshot's not open for writing: uninitialized header");    }    header.serialize(oa, "fileheader");    SerializeUtils.serializeSnapshot(dt, oa, sessions);}
0
public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{    if (!close) {        try (CheckedOutputStream snapOS = SnapStream.getOutputStream(snapShot)) {            OutputArchive oa = BinaryOutputArchive.getArchive(snapOS);            FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);            serialize(dt, sessions, oa, header);            SnapStream.sealStream(snapOS, oa);                        if (dt.serializeZxidDigest(oa)) {                SnapStream.sealStream(snapOS, oa);            }            lastSnapshotInfo = new SnapshotInfo(Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX), snapShot.lastModified() / 1000);        }    }}
0
private void writeChecksum(CheckedOutputStream crcOut, OutputArchive oa) throws IOException
{    long val = crcOut.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
0
private void checkChecksum(CheckedInputStream crcIn, InputArchive ia) throws IOException
{    long checkSum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
0
public synchronized void close() throws IOException
{    close = true;}
0
public static void setPreallocSize(long size)
{    FilePadding.setPreallocSize(size);}
0
public synchronized void setServerStats(ServerStats serverStats)
{    this.serverStats = serverStats;}
0
public static void setTxnLogSizeLimit(long size)
{    txnLogSizeLimit = size;}
0
public synchronized long getCurrentLogSize()
{    if (logFileWrite != null) {        return logFileWrite.length();    }    return 0;}
0
public synchronized void setTotalLogSize(long size)
{    prevLogsRunningTotal = size;}
0
public synchronized long getTotalLogSize()
{    return prevLogsRunningTotal + getCurrentLogSize();}
0
protected Checksum makeChecksumAlgorithm()
{    return new Adler32();}
0
public synchronized void rollLog() throws IOException
{    if (logStream != null) {        this.logStream.flush();        prevLogsRunningTotal += getCurrentLogSize();        this.logStream = null;        oa = null;        }}
0
public synchronized void close() throws IOException
{    if (logStream != null) {        logStream.close();    }    for (FileOutputStream log : streamsToFlush) {        log.close();    }}
0
public synchronized boolean append(TxnHeader hdr, Record txn) throws IOException
{    if (hdr == null) {        return false;    }    if (hdr.getZxid() <= lastZxidSeen) {            } else {        lastZxidSeen = hdr.getZxid();    }    if (logStream == null) {        if (LOG.isInfoEnabled()) {                    }        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));        fos = new FileOutputStream(logFileWrite);        logStream = new BufferedOutputStream(fos);        oa = BinaryOutputArchive.getArchive(logStream);        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);        fhdr.serialize(oa, "fileheader");                logStream.flush();        filePadding.setCurrentSize(fos.getChannel().position());        streamsToFlush.add(fos);    }    filePadding.padFile(fos.getChannel());    byte[] buf = Util.marshallTxnEntry(hdr, txn);    if (buf == null || buf.length == 0) {        throw new IOException("Faulty serialization for header " + "and txn");    }    Checksum crc = makeChecksumAlgorithm();    crc.update(buf, 0, buf.length);    oa.writeLong(crc.getValue(), "txnEntryCRC");    Util.writeTxnBytes(oa, buf);    return true;}
1
public static File[] getLogFiles(File[] logDirList, long snapshotZxid)
{    List<File> files = Util.sortDataDir(logDirList, LOG_FILE_PREFIX, true);    long logZxid = 0;        for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid > snapshotZxid) {            break;        }                if (fzxid > logZxid) {            logZxid = fzxid;        }    }    List<File> v = new ArrayList<File>(5);    for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid < logZxid) {            continue;        }        v.add(f);    }    return v.toArray(new File[0]);}
0
public long getLastLoggedZxid()
{    File[] files = getLogFiles(logDir.listFiles(), 0);    long maxLog = files.length > 0 ? Util.getZxidFromName(files[files.length - 1].getName(), LOG_FILE_PREFIX) : -1;            long zxid = maxLog;    TxnIterator itr = null;    try {        FileTxnLog txn = new FileTxnLog(logDir);        itr = txn.read(maxLog);        while (true) {            if (!itr.next()) {                break;            }            TxnHeader hdr = itr.getHeader();            zxid = hdr.getZxid();        }    } catch (IOException e) {            } finally {        close(itr);    }    return zxid;}
1
private void close(TxnIterator itr)
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {                    }    }}
1
public synchronized void commit() throws IOException
{    if (logStream != null) {        logStream.flush();    }    for (FileOutputStream log : streamsToFlush) {        log.flush();        if (forceSync) {            long startSyncNS = System.nanoTime();            FileChannel channel = log.getChannel();            channel.force(false);            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);            if (syncElapsedMS > fsyncWarningThresholdMS) {                if (serverStats != null) {                    serverStats.incrementFsyncThresholdExceedCount();                }                            }            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);        }    }    while (streamsToFlush.size() > 1) {        streamsToFlush.poll().close();    }        if (txnLogSizeLimit > 0) {        long logSize = getCurrentLogSize();        if (logSize > txnLogSizeLimit) {                        rollLog();        }    }}
1
public long getTxnLogSyncElapsedTime()
{    return syncElapsedMS;}
0
public TxnIterator read(long zxid) throws IOException
{    return read(zxid, true);}
0
public TxnIterator read(long zxid, boolean fastForward) throws IOException
{    return new FileTxnIterator(logDir, zxid, fastForward);}
0
public boolean truncate(long zxid) throws IOException
{    FileTxnIterator itr = null;    try {        itr = new FileTxnIterator(this.logDir, zxid);        PositionInputStream input = itr.inputStream;        if (input == null) {            throw new IOException("No log files found to truncate! This could " + "happen if you still have snapshots from an old setup or " + "log files were deleted accidentally or dataLogDir was changed in zoo.cfg.");        }        long pos = input.getPosition();                RandomAccessFile raf = new RandomAccessFile(itr.logFile, "rw");        raf.setLength(pos);        raf.close();        while (itr.goToNextLog()) {            if (!itr.logFile.delete()) {                            }        }    } finally {        close(itr);    }    return true;}
1
private static FileHeader readHeader(File file) throws IOException
{    InputStream is = null;    try {        is = new BufferedInputStream(new FileInputStream(file));        InputArchive ia = BinaryInputArchive.getArchive(is);        FileHeader hdr = new FileHeader();        hdr.deserialize(ia, "fileheader");        return hdr;    } finally {        try {            if (is != null) {                is.close();            }        } catch (IOException e) {                    }    }}
1
public long getDbId() throws IOException
{    FileTxnIterator itr = new FileTxnIterator(logDir, 0);    FileHeader fh = readHeader(itr.logFile);    itr.close();    if (fh == null) {        throw new IOException("Unsupported Format.");    }    return fh.getDbid();}
0
public boolean isForceSync()
{    return forceSync;}
0
public int read() throws IOException
{    int rc = super.read();    if (rc > -1) {        position++;    }    return rc;}
0
public int read(byte[] b) throws IOException
{    int rc = super.read(b);    if (rc > 0) {        position += rc;    }    return rc;}
0
public int read(byte[] b, int off, int len) throws IOException
{    int rc = super.read(b, off, len);    if (rc > 0) {        position += rc;    }    return rc;}
0
public long skip(long n) throws IOException
{    long rc = super.skip(n);    if (rc > 0) {        position += rc;    }    return rc;}
0
public long getPosition()
{    return position;}
0
public boolean markSupported()
{    return false;}
0
public void mark(int readLimit)
{    throw new UnsupportedOperationException("mark");}
0
public void reset()
{    throw new UnsupportedOperationException("reset");}
0
 void init() throws IOException
{    storedFiles = new ArrayList<>();    List<File> files = Util.sortDataDir(FileTxnLog.getLogFiles(logDir.listFiles(), 0), LOG_FILE_PREFIX, false);    for (File f : files) {        if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) >= zxid) {            storedFiles.add(f);        } else if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) < zxid) {                        storedFiles.add(f);            break;        }    }    goToNextLog();    next();}
0
public long getStorageSize()
{    long sum = 0;    for (File f : storedFiles) {        sum += f.length();    }    return sum;}
0
private boolean goToNextLog() throws IOException
{    if (storedFiles.size() > 0) {        this.logFile = storedFiles.remove(storedFiles.size() - 1);        ia = createInputArchive(this.logFile);        return true;    }    return false;}
0
protected void inStreamCreated(InputArchive ia, InputStream is) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        throw new IOException("Transaction log: " + this.logFile + " has invalid magic number " + header.getMagic() + " != " + FileTxnLog.TXNLOG_MAGIC);    }}
0
protected InputArchive createInputArchive(File logFile) throws IOException
{    if (inputStream == null) {        inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));                ia = BinaryInputArchive.getArchive(inputStream);        inStreamCreated(ia, inputStream);            }    return ia;}
1
protected Checksum makeChecksumAlgorithm()
{    return new Adler32();}
0
public boolean next() throws IOException
{    if (ia == null) {        return false;    }    try {        long crcValue = ia.readLong("crcvalue");        byte[] bytes = Util.readTxnBytes(ia);                if (bytes == null || bytes.length == 0) {            throw new EOFException("Failed to read " + logFile);        }                        Checksum crc = makeChecksumAlgorithm();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException(CRC_ERROR);        }        hdr = new TxnHeader();        record = SerializeUtils.deserializeTxn(bytes, hdr);    } catch (EOFException e) {                inputStream.close();        inputStream = null;        ia = null;        hdr = null;                if (!goToNextLog()) {            return false;        }                return next();    } catch (IOException e) {        inputStream.close();        throw e;    }    return true;}
1
public TxnHeader getHeader()
{    return hdr;}
0
public Record getTxn()
{    return record;}
0
public void close() throws IOException
{    if (inputStream != null) {        inputStream.close();    }}
0
public void setServerStats(ServerStats serverStats)
{    txnLog.setServerStats(serverStats);}
0
private void checkLogDir() throws LogDirContentCheckException
{    File[] files = this.dataDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isSnapshotFileName(name);        }    });    if (files != null && files.length > 0) {        throw new LogDirContentCheckException("Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.");    }}
0
public boolean accept(File dir, String name)
{    return Util.isSnapshotFileName(name);}
0
private void checkSnapDir() throws SnapDirContentCheckException
{    File[] files = this.snapDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isLogFileName(name);        }    });    if (files != null && files.length > 0) {        throw new SnapDirContentCheckException("Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.");    }}
0
public boolean accept(File dir, String name)
{    return Util.isLogFileName(name);}
0
public File getDataDir()
{    return this.dataDir;}
0
public File getSnapDir()
{    return this.snapDir;}
0
public SnapshotInfo getLastSnapshotInfo()
{    return this.snapLog.getLastSnapshotInfo();}
0
public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    long snapLoadingStartTime = Time.currentElapsedTime();    long deserializeResult = snapLog.deserialize(dt, sessions);    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);    FileTxnLog txnLog = new FileTxnLog(dataDir);    boolean trustEmptyDB;    File initFile = new File(dataDir.getParent(), "initialize");    if (Files.deleteIfExists(initFile.toPath())) {                trustEmptyDB = true;    } else {        trustEmptyDB = autoCreateDB;    }    if (-1L == deserializeResult) {        /* this means that we couldn't find any snapshot, so we need to             * initialize an empty database (reported in ZOOKEEPER-2325) */        if (txnLog.getLastLoggedZxid() != -1) {                        if (!trustEmptySnapshot) {                throw new IOException(EMPTY_SNAPSHOT_WARNING + "Something is broken!");            } else {                            }        }        if (trustEmptyDB) {            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()                 *       or use Map on save() */            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);            /* return a zxid of 0, since we know the database is empty */            return 0L;        } else {            /* return a zxid of -1, since we are possibly missing data */                        dt.lastProcessedZxid = -1L;            return -1L;        }    }    long highestZxid = fastForwardFromEdits(dt, sessions, listener);                    DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();    if (snapshotZxidDigest != null) {            }    return highestZxid;}
1
public long fastForwardFromEdits(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);    long highestZxid = dt.lastProcessedZxid;    TxnHeader hdr;    int txnLoaded = 0;    long startTime = Time.currentElapsedTime();    try {        while (true) {                                    hdr = itr.getHeader();            if (hdr == null) {                                return dt.lastProcessedZxid;            }            if (hdr.getZxid() < highestZxid && highestZxid != 0) {                            } else {                highestZxid = hdr.getZxid();            }            try {                processTransaction(hdr, dt, sessions, itr.getTxn());                txnLoaded++;            } catch (KeeperException.NoNodeException e) {                throw new IOException("Failed to process transaction type: " + hdr.getType() + " error: " + e.getMessage(), e);            }            listener.onTxnLoaded(hdr, itr.getTxn());            if (!itr.next()) {                break;            }        }    } finally {        if (itr != null) {            itr.close();        }    }    long loadTime = Time.currentElapsedTime() - startTime;        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);    return highestZxid;}
1
public TxnIterator readTxnLog(long zxid) throws IOException
{    return readTxnLog(zxid, true);}
0
public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.read(zxid, fastForward);}
0
public void processTransaction(TxnHeader hdr, DataTree dt, Map<Long, Integer> sessions, Record txn) throws KeeperException.NoNodeException
{    ProcessTxnResult rc;    switch(hdr.getType()) {        case OpCode.createSession:            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- create session in log: 0x" + Long.toHexString(hdr.getClientId()) + " with timeout: " + ((CreateSessionTxn) txn).getTimeOut());            }                        rc = dt.processTxn(hdr, txn);            break;        case OpCode.closeSession:            sessions.remove(hdr.getClientId());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- close session in log: 0x" + Long.toHexString(hdr.getClientId()));            }            rc = dt.processTxn(hdr, txn);            break;        default:            rc = dt.processTxn(hdr, txn);    }    /*         * Snapshots are lazily created. So when a snapshot is in progress,         * there is a chance for later transactions to make into the         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS         * errors could occur. It should be safe to ignore these.         */    if (rc.err != Code.OK.intValue()) {            }}
1
public long getLastLoggedZxid()
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.getLastLoggedZxid();}
0
public void save(DataTree dataTree, ConcurrentHashMap<Long, Integer> sessionsWithTimeouts, boolean syncSnap) throws IOException
{    long lastZxid = dataTree.lastProcessedZxid;    File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));        try {        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);    } catch (IOException e) {        if (snapshotFile.length() == 0) {            /* This may be caused by a full disk. In such a case, the server                 * will get stuck in a loop where it tries to write a snapshot                 * out to disk, and ends up creating an empty file instead.                 * Doing so will eventually result in valid snapshots being                 * removed during cleanup. */            if (snapshotFile.delete()) {                            } else {                            }        } else {        /* Something else went wrong when writing the snapshot out to                 * disk. If this snapshot file is invalid, when restarting,                 * ZooKeeper will skip it, and find the last known good snapshot                 * instead. */        }        throw e;    }}
1
public boolean truncateLog(long zxid) throws IOException
{        close();        FileTxnLog truncLog = new FileTxnLog(dataDir);    boolean truncated = truncLog.truncate(zxid);    truncLog.close();                    txnLog = new FileTxnLog(dataDir);    snapLog = new FileSnap(snapDir);    return truncated;}
0
public File findMostRecentSnapshot() throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findMostRecentSnapshot();}
0
public List<File> findNRecentSnapshots(int n) throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findNRecentSnapshots(n);}
0
public File[] getSnapshotLogs(long zxid)
{    return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);}
0
public boolean append(Request si) throws IOException
{    return txnLog.append(si.getHdr(), si.getTxn());}
0
public void commit() throws IOException
{    txnLog.commit();}
0
public long getTxnLogElapsedSyncTime()
{    return txnLog.getTxnLogSyncElapsedTime();}
0
public void rollLog() throws IOException
{    txnLog.rollLog();}
0
public void close() throws IOException
{    txnLog.close();    snapLog.close();}
0
public void setTotalLogSize(long size)
{    txnLog.setTotalLogSize(size);}
0
public long getTotalLogSize()
{    return txnLog.getTotalLogSize();}
0
public String getName()
{    return name;}
0
public String getFileExtension()
{    return name.isEmpty() ? "" : "." + name;}
0
public static StreamMode fromString(String name)
{    for (StreamMode c : values()) {        if (c.getName().compareToIgnoreCase(name) == 0) {            return c;        }    }    return DEFAULT_MODE;}
0
public static CheckedInputStream getInputStream(File file) throws IOException
{    FileInputStream fis = new FileInputStream(file);    InputStream is;    switch(getStreamMode(file.getName())) {        case GZIP:            is = new GZIPInputStream(fis);            break;        case SNAPPY:            is = new SnappyInputStream(fis);            break;        case CHECKED:        default:            is = new BufferedInputStream(fis);    }    return new CheckedInputStream(is, new Adler32());}
0
public static CheckedOutputStream getOutputStream(File file) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    OutputStream os;    switch(streamMode) {        case GZIP:            os = new GZIPOutputStream(fos);            break;        case SNAPPY:            os = new SnappyOutputStream(fos);            break;        case CHECKED:        default:            os = new BufferedOutputStream(fos);    }    return new CheckedOutputStream(os, new Adler32());}
0
public static void sealStream(CheckedOutputStream os, OutputArchive oa) throws IOException
{    long val = os.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
0
 static void checkSealIntegrity(CheckedInputStream is, InputArchive ia) throws IOException
{    long checkSum = is.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
0
public static boolean isValidSnapshot(File file) throws IOException
{    if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {        return false;    }    boolean isValid = false;    switch(getStreamMode(file.getName())) {        case GZIP:            isValid = isValidGZipStream(file);            break;        case SNAPPY:            isValid = isValidSnappyStream(file);            break;        case CHECKED:        default:            isValid = isValidCheckedStream(file);    }    return isValid;}
0
public static void setStreamMode(StreamMode mode)
{    streamMode = mode;}
0
public static StreamMode getStreamMode()
{    return streamMode;}
0
public static StreamMode getStreamMode(String fileName)
{    String[] splitSnapName = fileName.split("\\.");        if (splitSnapName.length > 1) {        String mode = splitSnapName[splitSnapName.length - 1];        return StreamMode.fromString(mode);    }    return StreamMode.CHECKED;}
0
private static boolean isValidGZipStream(File f) throws IOException
{    byte[] byteArray = new byte[2];    try (FileInputStream fis = new FileInputStream(f)) {        if (2 != fis.read(byteArray, 0, 2)) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[2];        bb.get(magicHeader, 0, 2);        int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);        return magic == GZIPInputStream.GZIP_MAGIC;    } catch (FileNotFoundException e) {                return false;    }}
1
private static boolean isValidSnappyStream(File f) throws IOException
{    byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];    try (FileInputStream fis = new FileInputStream(f)) {        if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];        bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);        return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());    } catch (FileNotFoundException e) {                return false;    }}
1
private static boolean isValidCheckedStream(File f) throws IOException
{    try (RandomAccessFile raf = new RandomAccessFile(f, "r")) {                if (raf.length() < 10) {            return false;        }        raf.seek(raf.length() - 5);        byte[] bytes = new byte[5];        int readlen = 0;        int l;        while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {            readlen += l;        }        if (readlen != bytes.length) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(bytes);        int len = bb.getInt();        byte b = bb.get();        if (len != 1 || b != '/') {                        return false;        }    }    return true;}
1
 int getExitCode()
{    return exitCode;}
0
 Options getOptions()
{    return options;}
0
public static void main(String[] args) throws Exception
{    try (final TxnLogToolkit lt = parseCommandLine(args)) {        if (lt.isDumpMode()) {            lt.dump(new Scanner(System.in));            lt.printStat();        } else {            lt.chop();        }    } catch (TxnLogToolkitParseException e) {        System.err.println(e.getMessage() + "\n");        printHelpAndExit(e.getExitCode(), e.getOptions());    } catch (TxnLogToolkitException e) {        System.err.println(e.getMessage());        System.exit(e.getExitCode());    }}
0
private File loadTxnFile(String txnLogFileName) throws TxnLogToolkitException
{    File logFile = new File(txnLogFileName);    if (!logFile.exists() || !logFile.canRead()) {        throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "File doesn't exist or not readable: %s", logFile);    }    return logFile;}
0
public void dump(Scanner scanner) throws Exception
{    crcFixed = 0;    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != TXNLOG_MAGIC) {        throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Invalid magic number for %s", txnLogFile.getName());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    if (recoveryMode) {        fhdr.serialize(recoveryOa, "fileheader");        recoveryFos.flush();        filePadding.setCurrentSize(recoveryFos.getChannel().position());    }    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            if (recoveryMode) {                if (!force) {                    printTxn(bytes, "CRC ERROR");                    if (askForFix(scanner)) {                        crcValue = crc.getValue();                        ++crcFixed;                    }                } else {                    crcValue = crc.getValue();                    printTxn(bytes, "CRC FIXED");                    ++crcFixed;                }            } else {                printTxn(bytes, "CRC ERROR");            }        }        if (!recoveryMode || verbose) {            printTxn(bytes);        }        if (logStream.readByte("EOR") != 'B') {            throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "Last transaction was partial.");        }        if (recoveryMode) {            filePadding.padFile(recoveryFos.getChannel());            recoveryOa.writeLong(crcValue, "crcvalue");            recoveryOa.writeBuffer(bytes, "txnEntry");            recoveryOa.writeByte((byte) 'B', "EOR");        }        count++;    }}
0
public void chop()
{    File targetFile = new File(txnLogFile.getParentFile(), txnLogFile.getName() + ".chopped" + zxid);    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLogFile));        OutputStream os = new BufferedOutputStream(new FileOutputStream(targetFile))) {        if (!LogChopper.chop(is, os, zxid)) {            throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Failed to chop %s", txnLogFile.getName());        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }}
0
public boolean isDumpMode()
{    return zxid < 0;}
0
private boolean askForFix(Scanner scanner) throws TxnLogToolkitException
{    while (true) {        System.out.print("Would you like to fix it (Yes/No/Abort) ? ");        char answer = Character.toUpperCase(scanner.next().charAt(0));        switch(answer) {            case 'Y':                return true;            case 'N':                return false;            case 'A':                throw new TxnLogToolkitException(ExitCode.EXECUTION_FINISHED.getValue(), "Recovery aborted.");        }    }}
0
private void printTxn(byte[] bytes) throws IOException
{    printTxn(bytes, "");}
0
private void printTxn(byte[] bytes, String prefix) throws IOException
{    TxnHeader hdr = new TxnHeader();    Record txn = SerializeUtils.deserializeTxn(bytes, hdr);    String txnStr = getFormattedTxnStr(txn);    String txns = String.format("%s session 0x%s cxid 0x%s zxid 0x%s %s %s", DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())), Long.toHexString(hdr.getClientId()), Long.toHexString(hdr.getCxid()), Long.toHexString(hdr.getZxid()), Request.op2String(hdr.getType()), txnStr);    if (prefix != null && !"".equals(prefix.trim())) {        System.out.print(prefix + " - ");    }    if (txns.endsWith("\n")) {        System.out.print(txns);    } else {        System.out.println(txns);    }}
0
private static String getFormattedTxnStr(Record txn) throws IOException
{    StringBuilder txnData = new StringBuilder();    if (txn == null) {        return txnData.toString();    }    if (txn instanceof CreateTxn) {        CreateTxn createTxn = ((CreateTxn) txn);        txnData.append(createTxn.getPath() + "," + checkNullToEmpty(createTxn.getData())).append("," + createTxn.getAcl() + "," + createTxn.getEphemeral()).append("," + createTxn.getParentCVersion());    } else if (txn instanceof SetDataTxn) {        SetDataTxn setDataTxn = ((SetDataTxn) txn);        txnData.append(setDataTxn.getPath() + "," + checkNullToEmpty(setDataTxn.getData())).append("," + setDataTxn.getVersion());    } else if (txn instanceof CreateContainerTxn) {        CreateContainerTxn createContainerTxn = ((CreateContainerTxn) txn);        txnData.append(createContainerTxn.getPath() + "," + checkNullToEmpty(createContainerTxn.getData())).append("," + createContainerTxn.getAcl() + "," + createContainerTxn.getParentCVersion());    } else if (txn instanceof CreateTTLTxn) {        CreateTTLTxn createTTLTxn = ((CreateTTLTxn) txn);        txnData.append(createTTLTxn.getPath() + "," + checkNullToEmpty(createTTLTxn.getData())).append("," + createTTLTxn.getAcl() + "," + createTTLTxn.getParentCVersion()).append("," + createTTLTxn.getTtl());    } else if (txn instanceof MultiTxn) {        MultiTxn multiTxn = ((MultiTxn) txn);        List<Txn> txnList = multiTxn.getTxns();        for (int i = 0; i < txnList.size(); i++) {            Txn t = txnList.get(i);            if (i == 0) {                txnData.append(Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            } else {                txnData.append(";" + Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            }        }    } else {        txnData.append(txn.toString());    }    return txnData.toString();}
0
private static String checkNullToEmpty(byte[] data) throws IOException
{    if (data == null || data.length == 0) {        return "";    }    return new String(data, StandardCharsets.UTF_8);}
0
private void openTxnLogFile() throws FileNotFoundException
{    txnFis = new FileInputStream(txnLogFile);    logStream = BinaryInputArchive.getArchive(txnFis);}
0
private void closeTxnLogFile() throws IOException
{    if (txnFis != null) {        txnFis.close();    }}
0
private void openRecoveryFile() throws FileNotFoundException
{    recoveryFos = new FileOutputStream(recoveryLogFile);    recoveryOa = BinaryOutputArchive.getArchive(recoveryFos);}
0
private void closeRecoveryFile() throws IOException
{    if (recoveryFos != null) {        recoveryFos.close();    }}
0
private static TxnLogToolkit parseCommandLine(String[] args) throws TxnLogToolkitException, FileNotFoundException
{    CommandLineParser parser = new PosixParser();    Options options = new Options();    Option helpOpt = new Option("h", "help", false, "Print help message");    options.addOption(helpOpt);    Option recoverOpt = new Option("r", "recover", false, "Recovery mode. Re-calculate CRC for broken entries.");    options.addOption(recoverOpt);    Option quietOpt = new Option("v", "verbose", false, "Be verbose in recovery mode: print all entries, not just fixed ones.");    options.addOption(quietOpt);    Option dumpOpt = new Option("d", "dump", false, "Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)");    options.addOption(dumpOpt);    Option forceOpt = new Option("y", "yes", false, "Non-interactive mode: repair all CRC errors without asking");    options.addOption(forceOpt);        Option chopOpt = new Option("c", "chop", false, "Chop mode. Chop txn file to a zxid.");    Option zxidOpt = new Option("z", "zxid", true, "Used with chop. Zxid to which to chop.");    options.addOption(chopOpt);    options.addOption(zxidOpt);    try {        CommandLine cli = parser.parse(options, args);        if (cli.hasOption("help")) {            printHelpAndExit(0, options);        }        if (cli.getArgs().length < 1) {            printHelpAndExit(1, options);        }        if (cli.hasOption("chop") && cli.hasOption("zxid")) {            return new TxnLogToolkit(cli.getArgs()[0], cli.getOptionValue("zxid"));        }        return new TxnLogToolkit(cli.hasOption("recover"), cli.hasOption("verbose"), cli.getArgs()[0], cli.hasOption("yes"));    } catch (ParseException e) {        throw new TxnLogToolkitParseException(options, ExitCode.UNEXPECTED_ERROR.getValue(), e.getMessage());    }}
0
private static void printHelpAndExit(int exitCode, Options options)
{    HelpFormatter help = new HelpFormatter();    help.printHelp(120, "TxnLogToolkit [-dhrvc] <txn_log_file_name> (-z <zxid>)", "", options, "");    System.exit(exitCode);}
0
private void printStat()
{    if (recoveryMode) {        System.out.printf("Recovery file %s has been written with %d fixed CRC error(s)%n", recoveryLogFile, crcFixed);    }}
0
public void close() throws IOException
{    if (recoveryMode) {        closeRecoveryFile();    }    closeTxnLogFile();}
0
public static String makeURIString(String dataDir, String dataLogDir, String convPolicy)
{    String uri = "file:" + SNAP_DIR + "=" + dataDir + ";" + LOG_DIR + "=" + dataLogDir;    if (convPolicy != null) {        uri += ";" + DB_FORMAT_CONV + "=" + convPolicy;    }    return uri.replace('\\', '/');}
0
public static URI makeFileLoggerURL(File dataDir, File dataLogDir)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), null));}
0
public static URI makeFileLoggerURL(File dataDir, File dataLogDir, String convPolicy)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), convPolicy));}
0
public static String makeLogName(long zxid)
{    return FileTxnLog.LOG_FILE_PREFIX + "." + Long.toHexString(zxid);}
0
public static String makeSnapshotName(long zxid)
{    return FileSnap.SNAPSHOT_FILE_PREFIX + "." + Long.toHexString(zxid) + SnapStream.getStreamMode().getFileExtension();}
0
public static File getSnapDir(Properties props)
{    return new File(props.getProperty(SNAP_DIR));}
0
public static File getLogDir(Properties props)
{    return new File(props.getProperty(LOG_DIR));}
0
public static String getFormatConversionPolicy(Properties props)
{    return props.getProperty(DB_FORMAT_CONV);}
0
public static long getZxidFromName(String name, String prefix)
{    long zxid = -1;    String[] nameParts = name.split("\\.");    if (nameParts.length >= 2 && nameParts[0].equals(prefix)) {        try {            zxid = Long.parseLong(nameParts[1], 16);        } catch (NumberFormatException e) {        }    }    return zxid;}
0
public static byte[] readTxnBytes(InputArchive ia) throws IOException
{    try {        byte[] bytes = ia.readBuffer("txtEntry");                if (bytes.length == 0) {            return bytes;        }        if (ia.readByte("EOF") != 'B') {                        return null;        }        return bytes;    } catch (EOFException e) {    }    return null;}
1
public static byte[] marshallTxnEntry(TxnHeader hdr, Record txn) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    hdr.serialize(boa, "hdr");    if (txn != null) {        txn.serialize(boa, "txn");    }    return baos.toByteArray();}
0
public static void writeTxnBytes(OutputArchive oa, byte[] bytes) throws IOException
{    oa.writeBuffer(bytes, "txnEntry");        oa.writeByte((byte) 0x42, "EOR");}
0
public int compare(File o1, File o2)
{    long z1 = Util.getZxidFromName(o1.getName(), prefix);    long z2 = Util.getZxidFromName(o2.getName(), prefix);    int result = z1 < z2 ? -1 : (z1 > z2 ? 1 : 0);    return ascending ? result : -result;}
0
public static List<File> sortDataDir(File[] files, String prefix, boolean ascending)
{    if (files == null) {        return new ArrayList<File>(0);    }    List<File> filelist = Arrays.asList(files);    Collections.sort(filelist, new DataDirFileComparator(prefix, ascending));    return filelist;}
0
public static boolean isLogFileName(String fileName)
{    return fileName.startsWith(FileTxnLog.LOG_FILE_PREFIX + ".");}
0
public static boolean isSnapshotFileName(String fileName)
{    return fileName.startsWith(FileSnap.SNAPSHOT_FILE_PREFIX + ".");}
0
public static void setFailCreate(boolean b)
{    failCreate = b;}
0
public void run()
{    try {        while (true) {            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());            Request request = submittedRequests.take();            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'P', request, "");            }            if (Request.requestOfDeath == request) {                break;            }            request.prepStartTime = Time.currentElapsedTime();            pRequest(request);        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {                    }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    }
1
private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException
{    ChangeRecord lastChange = null;    synchronized (zks.outstandingChanges) {        lastChange = zks.outstandingChangesForPath.get(path);        if (lastChange == null) {            DataNode n = zks.getZKDatabase().getNode(path);            if (n != null) {                Set<String> children;                synchronized (n) {                    children = n.getChildren();                }                lastChange = new ChangeRecord(-1, path, n.stat, children.size(), zks.getZKDatabase().aclForNode(n));            }        }    }    if (lastChange == null || lastChange.stat == null) {        throw new KeeperException.NoNodeException(path);    }    return lastChange;}
0
private ChangeRecord getOutstandingChange(String path)
{    synchronized (zks.outstandingChanges) {        return zks.outstandingChangesForPath.get(path);    }}
0
protected void addChangeRecord(ChangeRecord c)
{    synchronized (zks.outstandingChanges) {        zks.outstandingChanges.add(c);        zks.outstandingChangesForPath.put(c.path, c);        ServerMetrics.getMetrics().OUTSTANDING_CHANGES_QUEUED.add(1);    }}
0
private Map<String, ChangeRecord> getPendingChanges(MultiOperationRecord multiRequest)
{    Map<String, ChangeRecord> pendingChangeRecords = new HashMap<String, ChangeRecord>();    for (Op op : multiRequest) {        String path = op.getPath();        ChangeRecord cr = getOutstandingChange(path);                if (cr != null) {            pendingChangeRecords.put(path, cr);        }        /*             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord             * of the parent node of a request. So that if this is a             * sequential node creation request, rollbackPendingChanges()             * can restore previous parent's ChangeRecord correctly.             *             * Otherwise, sequential node name generation will be incorrect             * for a subsequent request.             */        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1 || path.indexOf('\0') != -1) {            continue;        }        String parentPath = path.substring(0, lastSlash);        ChangeRecord parentCr = getOutstandingChange(parentPath);        if (parentCr != null) {            pendingChangeRecords.put(parentPath, parentCr);        }    }    return pendingChangeRecords;}
0
 void rollbackPendingChanges(long zxid, Map<String, ChangeRecord> pendingChangeRecords)
{    synchronized (zks.outstandingChanges) {                Iterator<ChangeRecord> iter = zks.outstandingChanges.descendingIterator();        while (iter.hasNext()) {            ChangeRecord c = iter.next();            if (c.zxid == zxid) {                iter.remove();                                                zks.outstandingChangesForPath.remove(c.path);            } else {                break;            }        }                if (zks.outstandingChanges.isEmpty()) {            return;        }        long firstZxid = zks.outstandingChanges.peek().zxid;        for (ChangeRecord c : pendingChangeRecords.values()) {                        if (c.zxid < firstZxid) {                continue;            }                        zks.outstandingChangesForPath.put(c.path, c);        }    }}
0
private String validatePathForCreate(String path, long sessionId) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {                throw new KeeperException.BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
1
protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
{    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));    switch(type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:            {                pRequest2TxnCreate(type, request, record, deserialize);                break;            }        case OpCode.deleteContainer:            {                String path = new String(request.request.array());                String parentPath = getParentPathAndValidate(path);                ChangeRecord nodeRecord = getRecordForPath(path);                if (nodeRecord.childCount > 0) {                    throw new KeeperException.NotEmptyException(path);                }                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {                    throw new KeeperException.BadVersionException(path);                }                ChangeRecord parentRecord = getRecordForPath(parentPath);                request.setTxn(new DeleteTxn(path));                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());                parentRecord.childCount--;                addChangeRecord(parentRecord);                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));                break;            }        case OpCode.delete:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            DeleteRequest deleteRequest = (DeleteRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);            }            String path = deleteRequest.getPath();            String parentPath = getParentPathAndValidate(path);            ChangeRecord parentRecord = getRecordForPath(parentPath);            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);            ChangeRecord nodeRecord = getRecordForPath(path);            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);            if (nodeRecord.childCount > 0) {                throw new KeeperException.NotEmptyException(path);            }            request.setTxn(new DeleteTxn(path));            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());            parentRecord.childCount--;            addChangeRecord(parentRecord);            addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));            break;        case OpCode.setData:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetDataRequest setDataRequest = (SetDataRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);            }            path = setDataRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.reconfig:            if (!QuorumPeerConfig.isReconfigEnabled()) {                                throw new KeeperException.ReconfigDisabledException();            }            if (ZooKeeperServer.skipACL) {                            }            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            LeaderZooKeeperServer lzks;            try {                lzks = (LeaderZooKeeperServer) zks;            } catch (ClassCastException e) {                                throw new KeeperException.UnimplementedException();            }            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                        if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {                throw new KeeperException.ReconfigInProgress();            }            ReconfigRequest reconfigRequest = (ReconfigRequest) record;            long configId = reconfigRequest.getCurConfigId();            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {                String msg = "Reconfiguration from version " + configId + " failed -- last seen version is " + lzks.self.getLastSeenQuorumVerifier().getVersion();                throw new KeeperException.BadVersionException(msg);            }            String newMembers = reconfigRequest.getNewMembers();            if (newMembers != null) {                                                                newMembers = newMembers.replaceAll(",", "\n");                try {                    Properties props = new Properties();                    props.load(new StringReader(newMembers));                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);                    request.qv.setVersion(request.getHdr().getZxid());                } catch (IOException | ConfigException e) {                    throw new KeeperException.BadArgumentsException(e.getMessage());                }            } else {                                                List<String> joiningServers = null;                String joiningServersString = reconfigRequest.getJoiningServers();                if (joiningServersString != null) {                    joiningServers = StringUtils.split(joiningServersString, ",");                }                List<String> leavingServers = null;                String leavingServersString = reconfigRequest.getLeavingServers();                if (leavingServersString != null) {                    leavingServers = StringUtils.split(leavingServersString, ",");                }                if (!(lastSeenQV instanceof QuorumMaj)) {                    String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";                                        throw new KeeperException.BadArgumentsException(msg);                }                Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());                try {                    if (leavingServers != null) {                        for (String leaving : leavingServers) {                            long sid = Long.parseLong(leaving);                            nextServers.remove(sid);                        }                    }                    if (joiningServers != null) {                        for (String joiner : joiningServers) {                                                        String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);                            if (parts.length != 2) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string");                            }                                                        Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));                            QuorumServer qs = new QuorumServer(sid, parts[1]);                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified");                            }                                                        for (QuorumServer nqs : nextServers.values()) {                                if (qs.id == nqs.id) {                                    continue;                                }                                qs.checkAddressDuplicate(nqs);                            }                            nextServers.remove(qs.id);                            nextServers.put(qs.id, qs);                        }                    }                } catch (ConfigException e) {                    throw new KeeperException.BadArgumentsException("Reconfiguration failed");                }                request.qv = new QuorumMaj(nextServers);                request.qv.setVersion(request.getHdr().getZxid());            }            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {                String msg = "Reconfig failed - new configuration must include at least 2 followers";                                throw new KeeperException.BadArgumentsException(msg);            } else if (request.qv.getVotingMembers().size() < 1) {                String msg = "Reconfig failed - new configuration must include at least 1 follower";                                throw new KeeperException.BadArgumentsException(msg);            }            if (!lzks.getLeader().isQuorumSynced(request.qv)) {                String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";                                throw new KeeperException.NewConfigNoQuorum();            }            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);            request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(-1);            addChangeRecord(nodeRecord);            break;        case OpCode.setACL:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetACLRequest setAclRequest = (SetACLRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);            }            path = setAclRequest.getPath();            validatePath(path, request.sessionId);            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);            request.setTxn(new SetACLTxn(path, listACL, newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setAversion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.createSession:            request.request.rewind();            int to = request.request.getInt();            request.setTxn(new CreateSessionTxn(to));            request.request.rewind();                        zks.sessionTracker.trackSession(request.sessionId, to);            zks.setOwner(request.sessionId, request.getOwner());            break;        case OpCode.closeSession:                                                            long startTime = Time.currentElapsedTime();            synchronized (zks.outstandingChanges) {                                                                                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);                for (ChangeRecord c : zks.outstandingChanges) {                    if (c.stat == null) {                                                es.remove(c.path);                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {                        es.add(c.path);                    }                }                for (String path2Delete : es) {                    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));                }                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));                }                zks.sessionTracker.setSessionClosing(request.sessionId);            }            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);            break;        case OpCode.check:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);            }            path = checkVersionRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);            request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));            break;        default:                        break;    }}
1
private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException
{    if (deserialize) {        ByteBufferInputStream.byteBuffer2Record(request.request, record);    }    int flags;    String path;    List<ACL> acl;    byte[] data;    long ttl;    if (type == OpCode.createTTL) {        CreateTTLRequest createTtlRequest = (CreateTTLRequest) record;        flags = createTtlRequest.getFlags();        path = createTtlRequest.getPath();        acl = createTtlRequest.getAcl();        data = createTtlRequest.getData();        ttl = createTtlRequest.getTtl();    } else {        CreateRequest createRequest = (CreateRequest) record;        flags = createRequest.getFlags();        path = createRequest.getPath();        acl = createRequest.getAcl();        data = createRequest.getData();        ttl = -1;    }    CreateMode createMode = CreateMode.fromFlag(flags);    validateCreateRequest(path, createMode, request, ttl);    String parentPath = validatePathForCreate(path, request.sessionId);    List<ACL> listACL = fixupACL(path, request.authInfo, acl);    ChangeRecord parentRecord = getRecordForPath(parentPath);    zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);    int parentCVersion = parentRecord.stat.getCversion();    if (createMode.isSequential()) {        path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);    }    validatePath(path, request.sessionId);    try {        if (getRecordForPath(path) != null) {            throw new KeeperException.NodeExistsException(path);        }    } catch (KeeperException.NoNodeException e) {        }    boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;    if (ephemeralParent) {        throw new KeeperException.NoChildrenForEphemeralsException(path);    }    int newCversion = parentRecord.stat.getCversion() + 1;    if (type == OpCode.createContainer) {        request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));    } else if (type == OpCode.createTTL) {        request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));    } else {        request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(), newCversion));    }    StatPersisted s = new StatPersisted();    if (createMode.isEphemeral()) {        s.setEphemeralOwner(request.sessionId);    }    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());    parentRecord.childCount++;    parentRecord.stat.setCversion(newCversion);    addChangeRecord(parentRecord);    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));}
0
private void validatePath(String path, long sessionId) throws BadArgumentsException
{    try {        PathUtils.validatePath(path);    } catch (IllegalArgumentException ie) {                throw new BadArgumentsException(path);    }}
1
private String getParentPathAndValidate(String path) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || zks.getZKDatabase().isSpecialPath(path)) {        throw new BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
0
private static int checkAndIncVersion(int currentVersion, int expectedVersion, String path) throws KeeperException.BadVersionException
{    if (expectedVersion != -1 && expectedVersion != currentVersion) {        throw new KeeperException.BadVersionException(path);    }    return currentVersion + 1;}
0
protected void pRequest(Request request) throws RequestProcessorException
{            request.setHdr(null);    request.setTxn(null);    try {        switch(request.type) {            case OpCode.createContainer:            case OpCode.create:            case OpCode.create2:                CreateRequest create2Request = new CreateRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);                break;            case OpCode.createTTL:                CreateTTLRequest createTtlRequest = new CreateTTLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, true);                break;            case OpCode.deleteContainer:            case OpCode.delete:                DeleteRequest deleteRequest = new DeleteRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);                break;            case OpCode.setData:                SetDataRequest setDataRequest = new SetDataRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);                break;            case OpCode.reconfig:                ReconfigRequest reconfigRequest = new ReconfigRequest();                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);                break;            case OpCode.setACL:                SetACLRequest setAclRequest = new SetACLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);                break;            case OpCode.check:                CheckVersionRequest checkRequest = new CheckVersionRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);                break;            case OpCode.multi:                MultiOperationRecord multiRequest = new MultiOperationRecord();                try {                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);                } catch (IOException e) {                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));                    throw e;                }                List<Txn> txns = new ArrayList<Txn>();                                long zxid = zks.getNextZxid();                KeeperException ke = null;                                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);                for (Op op : multiRequest) {                    Record subrequest = op.toRequestRecord();                    int type;                    Record txn;                    /* If we've already failed one of the ops, don't bother                     * trying the rest as we know it's going to fail and it                     * would be confusing in the logfiles.                     */                    if (ke != null) {                        type = OpCode.error;                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());                    } else {                        /* Prep the request and convert to a Txn */                        try {                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);                            type = request.getHdr().getType();                            txn = request.getTxn();                        } catch (KeeperException e) {                            ke = e;                            type = OpCode.error;                            txn = new ErrorTxn(e.code().intValue());                            if (e.code().intValue() > Code.APIERROR.intValue()) {                                                            }                            request.setException(e);                            /* Rollback change records from failed multi-op */                            rollbackPendingChanges(zxid, pendingChanges);                        }                    }                                        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                        txn.serialize(boa, "request");                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());                        txns.add(new Txn(type, bb.array()));                    }                }                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));                request.setTxn(new MultiTxn(txns));                break;                        case OpCode.createSession:            case OpCode.closeSession:                if (!request.isLocalSession()) {                    pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);                }                break;                        case OpCode.sync:            case OpCode.exists:            case OpCode.getData:            case OpCode.getACL:            case OpCode.getChildren:            case OpCode.getAllChildrenNumber:            case OpCode.getChildren2:            case OpCode.ping:            case OpCode.setWatches:            case OpCode.checkWatches:            case OpCode.removeWatches:            case OpCode.getEphemerals:            case OpCode.multiRead:                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());                break;            default:                                break;        }    } catch (KeeperException e) {        if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(e.code().intValue()));        }        if (e.code().intValue() > Code.APIERROR.intValue()) {                    }        request.setException(e);    } catch (Exception e) {                                StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        if (bb != null) {            bb.rewind();            while (bb.hasRemaining()) {                sb.append(Integer.toHexString(bb.get() & 0xff));            }        } else {            sb.append("request buffer is null");        }                if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));        }    }    request.zxid = zks.getZxid();    ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(Time.currentElapsedTime() - request.prepStartTime);    nextProcessor.processRequest(request);}
1
private static List<ACL> removeDuplicates(final List<ACL> acls)
{    if (acls == null || acls.isEmpty()) {        return Collections.emptyList();    }            final ArrayList<ACL> retval = new ArrayList<>(acls.size());    for (final ACL acl : acls) {        if (!retval.contains(acl)) {            retval.add(acl);        }    }    return retval;}
0
private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl) throws KeeperException
{    if (createMode.isTTL() && !EphemeralType.extendedEphemeralTypesEnabled()) {        throw new KeeperException.UnimplementedException();    }    try {        EphemeralType.validateTTL(createMode, ttl);    } catch (IllegalArgumentException e) {        throw new BadArgumentsException(path);    }    if (createMode.isEphemeral()) {                if (request.getException() != null) {            throw request.getException();        }        zks.sessionTracker.checkGlobalSession(request.sessionId, request.getOwner());    } else {        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());    }}
0
public static List<ACL> fixupACL(String path, List<Id> authInfo, List<ACL> acls) throws KeeperException.InvalidACLException
{            List<ACL> uniqacls = removeDuplicates(acls);    if (uniqacls == null || uniqacls.size() == 0) {        throw new KeeperException.InvalidACLException(path);    }    List<ACL> rv = new ArrayList<>();    for (ACL a : uniqacls) {                if (a == null) {            throw new KeeperException.InvalidACLException(path);        }        Id id = a.getId();        if (id == null || id.getScheme() == null) {            throw new KeeperException.InvalidACLException(path);        }        if (id.getScheme().equals("world") && id.getId().equals("anyone")) {            rv.add(a);        } else if (id.getScheme().equals("auth")) {                                    boolean authIdValid = false;            for (Id cid : authInfo) {                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());                if (ap == null) {                                    } else if (ap.isAuthenticated()) {                    authIdValid = true;                    rv.add(new ACL(a.getPerms(), cid));                }            }            if (!authIdValid) {                throw new KeeperException.InvalidACLException(path);            }        } else {            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap == null || !ap.isValid(id.getId())) {                throw new KeeperException.InvalidACLException(path);            }            rv.add(a);        }    }    return rv;}
1
public void processRequest(Request request)
{    request.prepQueueStartTime = Time.currentElapsedTime();    submittedRequests.add(request);    ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUED.add(1);}
0
public void shutdown()
{        submittedRequests.clear();    submittedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
1
 static void printUsage()
{    System.out.println("Usage:");    System.out.println("PurgeTxnLog dataLogDir [snapDir] -n count");    System.out.println("\tdataLogDir -- path to the txn log directory");    System.out.println("\tsnapDir -- path to the snapshot directory");    System.out.println("\tcount -- the number of old snaps/logs you want " + "to keep, value should be greater than or equal to 3");}
0
public static void purge(File dataDir, File snapDir, int num) throws IOException
{    if (num < 3) {        throw new IllegalArgumentException(COUNT_ERR_MSG);    }    FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);    List<File> snaps = txnLog.findNRecentSnapshots(num);    int numSnaps = snaps.size();    if (numSnaps > 0) {        purgeOlderSnapshots(txnLog, snaps.get(numSnaps - 1));    }}
0
 static void purgeOlderSnapshots(FileTxnSnapLog txnLog, File snapShot)
{    final long leastZxidToBeRetain = Util.getZxidFromName(snapShot.getName(), PREFIX_SNAPSHOT);    /**     * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.     * This rule applies to both snapshot files as well as log files, with the following     * exception for log files.     *     * A log file with zxid less than X may contain transactions with zxid larger than X.  More     * precisely, a log file named log.(X-a) may contain transactions newer than snapshot.X if     * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the     * latter condition is true, log.(X-a) must be retained to ensure that snapshot.X is     * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer     * snapshot files if these newer snapshots were not accompanied by log rollover (possible in     * the learner state machine at the time of this writing).  We can make more precise     * determination of whether log.(leastZxidToBeRetain-a) for the smallest 'a' is actually     * needed or not (e.g. not needed if there's a log file named log.(leastZxidToBeRetain+1)),     * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and     * simple to just preserve log.(leastZxidToBeRetain-a) for the smallest 'a' to ensure     * recoverability of all snapshots being retained.  We determine that log file here by     * calling txnLog.getSnapshotLogs().     */    final Set<File> retainedTxnLogs = new HashSet<File>();    retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));    /**     * Finds all candidates for deletion, which are files with a zxid in their name that is less     * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.     */    class MyFileFilter implements FileFilter {        private final String prefix;        MyFileFilter(String prefix) {            this.prefix = prefix;        }        public boolean accept(File f) {            if (!f.getName().startsWith(prefix + ".")) {                return false;            }            if (retainedTxnLogs.contains(f)) {                return false;            }            long fZxid = Util.getZxidFromName(f.getName(), prefix);            return fZxid < leastZxidToBeRetain;        }    }        File[] logs = txnLog.getDataDir().listFiles(new MyFileFilter(PREFIX_LOG));    List<File> files = new ArrayList<>();    if (logs != null) {        files.addAll(Arrays.asList(logs));    }        File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));    if (snapshots != null) {        files.addAll(Arrays.asList(snapshots));    }        for (File f : files) {        final String msg = "Removing file: " + DateFormat.getDateTimeInstance().format(f.lastModified()) + "\t" + f.getPath();                System.out.println(msg);        if (!f.delete()) {            System.err.println("Failed to remove " + f.getPath());        }    }}
1
public boolean accept(File f)
{    if (!f.getName().startsWith(prefix + ".")) {        return false;    }    if (retainedTxnLogs.contains(f)) {        return false;    }    long fZxid = Util.getZxidFromName(f.getName(), prefix);    return fZxid < leastZxidToBeRetain;}
0
public static void main(String[] args) throws IOException
{    if (args.length < 3 || args.length > 4) {        printUsageThenExit();    }    File dataDir = validateAndGetFile(args[0]);    File snapDir = dataDir;    int num = -1;    String countOption = "";    if (args.length == 3) {        countOption = args[1];        num = validateAndGetCount(args[2]);    } else {        snapDir = validateAndGetFile(args[1]);        countOption = args[2];        num = validateAndGetCount(args[3]);    }    if (!"-n".equals(countOption)) {        printUsageThenExit();    }    purge(dataDir, snapDir, num);}
0
private static File validateAndGetFile(String path)
{    File file = new File(path);    if (!file.exists()) {        System.err.println("Path '" + file.getAbsolutePath() + "' does not exist. ");        printUsageThenExit();    }    return file;}
0
private static int validateAndGetCount(String number)
{    int result = 0;    try {        result = Integer.parseInt(number);        if (result < 3) {            System.err.println(COUNT_ERR_MSG);            printUsageThenExit();        }    } catch (NumberFormatException e) {        System.err.println("'" + number + "' can not be parsed to integer.");        printUsageThenExit();    }    return result;}
0
private static void printUsageThenExit()
{    printUsage();    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
0
public void processRequest(Request request)
{    QuorumPeer self = leader.self;    if (self != null) {        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);        leader.processAck(self.getId(), request.zxid, null);    } else {            }}
1
public void shutdown()
{}
0
public void authenticate(Socket sock, String hostname)
{        return;}
0
public void authenticate(final Socket sock, final DataInputStream din)
{}
0
 static Status getStatus(int status)
{    switch(status) {        case 0:            return IN_PROGRESS;        case 1:            return SUCCESS;        case -1:            return ERROR;        default:                        assert false : "Unknown status!";            return ERROR;    }}
1
 int status()
{    return status;}
0
public static QuorumAuthPacket createPacket(Status status, byte[] response)
{    return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER, status.status(), response);}
0
public static boolean nextPacketIsAuth(DataInputStream din) throws IOException
{    din.mark(32);    BinaryInputArchive bia = new BinaryInputArchive(din);    boolean firstIsAuth = (bia.readLong("NO_TAG") == QuorumAuth.QUORUM_AUTH_MAGIC_NUMBER);    din.reset();    return firstIsAuth;}
0
public void authenticate(Socket sock, String hostName) throws IOException
{    if (!quorumRequireSasl) {                        return;    }    SaslClient sc = null;    String principalConfig = SecurityUtils.getServerPrincipal(quorumServicePrincipal, hostName);    try {        DataOutputStream dout = new DataOutputStream(sock.getOutputStream());        DataInputStream din = new DataInputStream(sock.getInputStream());        byte[] responseToken = new byte[0];        sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(), principalConfig, QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, "QuorumLearner");        if (sc.hasInitialResponse()) {            responseToken = createSaslToken(new byte[0], sc, learnerLogin);        }        send(dout, responseToken);        QuorumAuthPacket authPacket = receive(din);        QuorumAuth.Status qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());        while (!sc.isComplete()) {            switch(qpStatus) {                case SUCCESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                                        if (responseToken != null) {                        throw new SaslException("Protocol error: attempting to send response after completion");                    }                    break;                case IN_PROGRESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                    send(dout, responseToken);                    authPacket = receive(din);                    qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());                    break;                case ERROR:                    throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());                default:                                        throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());            }        }                checkAuthStatus(sock, qpStatus);    } finally {        if (sc != null) {            try {                sc.dispose();            } catch (SaslException e) {                            }        }    }}
1
private void checkAuthStatus(Socket sock, QuorumAuth.Status qpStatus) throws SaslException
{    if (qpStatus == QuorumAuth.Status.SUCCESS) {            } else {        throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress() + ", qpStatus: " + qpStatus);    }}
1
private QuorumAuthPacket receive(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket;}
0
private void send(DataOutputStream dout, byte[] response) throws IOException
{    QuorumAuthPacket authPacket;    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, response);    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
0
private byte[] createSaslToken(final byte[] saslToken, final SaslClient saslClient, final Login login) throws SaslException
{    if (saslToken == null) {        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    if (login.getSubject() != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                                                return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's received SASL token.";                                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.";                }                                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
1
public byte[] run() throws SaslException
{        return saslClient.evaluateChallenge(saslToken);}
1
public void authenticate(Socket sock, DataInputStream din) throws SaslException
{    DataOutputStream dout = null;    SaslServer ss = null;    try {        if (!QuorumAuth.nextPacketIsAuth(din)) {            if (quorumRequireSasl) {                throw new SaslException("Learner not trying to authenticate" + " and authentication is required");            } else {                                return;            }        }        byte[] token = receive(din);        int tries = 0;        dout = new DataOutputStream(sock.getOutputStream());        byte[] challenge = null;        ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);        while (!ss.isComplete()) {            challenge = ss.evaluateResponse(token);            if (!ss.isComplete()) {                                if (++tries > MAX_RETRIES) {                    send(dout, challenge, QuorumAuth.Status.ERROR);                                        break;                }                send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);                token = receive(din);            }        }                if (ss.isComplete()) {            send(dout, challenge, QuorumAuth.Status.SUCCESS);                    }    } catch (Exception e) {        try {            if (dout != null) {                                send(dout, new byte[0], QuorumAuth.Status.ERROR);            }        } catch (IOException ioe) {                    }                if (quorumRequireSasl) {                        throw new SaslException("Failed to authenticate using SASL: " + e.getMessage());        } else {                                        }    } finally {        if (ss != null) {            try {                ss.dispose();            } catch (SaslException e) {                            }        }    }}
1
private byte[] receive(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket.getToken();}
0
private void send(DataOutputStream dout, byte[] challenge, QuorumAuth.Status s) throws IOException
{    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    QuorumAuthPacket authPacket;    if (challenge == null && s != QuorumAuth.Status.SUCCESS) {        authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, null);    } else {        authPacket = QuorumAuth.createPacket(s, challenge);    }    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
0
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
0
private void handleNameCallback(NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {                return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
1
private void handlePasswordCallback(PasswordCallback pc)
{    if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {            }}
1
private void handleRealmCallback(RealmCallback rc)
{        rc.setText(rc.getDefaultText());}
1
 boolean saveChallenge(long tag, long challenge)
{    Semaphore s = challengeMutex.get(tag);    if (s != null) {        synchronized (Messenger.this) {            challengeMap.put(tag, challenge);            challengeMutex.remove(tag);        }        s.release();    } else {            }    return true;}
1
public void run()
{    byte[] responseBytes = new byte[48];    ByteBuffer responseBuffer = ByteBuffer.wrap(responseBytes);    DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length);    while (true) {                try {            responseBuffer.clear();            mySocket.receive(responsePacket);        } catch (IOException e) {                    }                if (responsePacket.getLength() != responseBytes.length) {                        continue;        }        responseBuffer.clear();        int type = responseBuffer.getInt();        if ((type > 3) || (type < 0)) {                        continue;        }        long tag = responseBuffer.getLong();        QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;        switch(responseBuffer.getInt()) {            case 0:                ackstate = QuorumPeer.ServerState.LOOKING;                break;            case 1:                ackstate = QuorumPeer.ServerState.LEADING;                break;            case 2:                ackstate = QuorumPeer.ServerState.FOLLOWING;                break;            default:                                break;        }        Vote current = self.getCurrentVote();        switch(type) {            case 0:                                ToSend c = new ToSend(ToSend.mType.challenge, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                sendqueue.offer(c);                break;            case 1:                                long challenge = responseBuffer.getLong();                saveChallenge(tag, challenge);                break;            case 2:                Notification n = new Notification();                n.leader = responseBuffer.getLong();                n.zxid = responseBuffer.getLong();                n.epoch = responseBuffer.getLong();                n.state = ackstate;                n.addr = (InetSocketAddress) responsePacket.getSocketAddress();                if ((myMsg.lastEpoch <= n.epoch) && ((n.zxid > myMsg.lastProposedZxid) || ((n.zxid == myMsg.lastProposedZxid) && (n.leader > myMsg.lastProposedLeader)))) {                    myMsg.lastProposedZxid = n.zxid;                    myMsg.lastProposedLeader = n.leader;                    myMsg.lastEpoch = n.epoch;                }                long recChallenge;                InetSocketAddress addr = (InetSocketAddress) responsePacket.getSocketAddress();                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(addr);                    if (tmpMap != null) {                        if (tmpMap.get(tag) != null) {                            recChallenge = responseBuffer.getLong();                            if (tmpMap.get(tag) == recChallenge) {                                recvqueue.offer(n);                                ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), addr);                                sendqueue.offer(a);                            } else {                                                            }                        } else {                                                    }                    }                } else {                    recvqueue.offer(n);                    ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                    sendqueue.offer(a);                }                break;                        case 3:                Semaphore s = ackMutex.get(tag);                if (s != null) {                    s.release();                } else {                                    }                ackset.add(tag);                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(responsePacket.getSocketAddress());                    if (tmpMap != null) {                        tmpMap.remove(tag);                    } else {                                            }                }                if (ackstate != QuorumPeer.ServerState.LOOKING) {                    Notification outofsync = new Notification();                    outofsync.leader = responseBuffer.getLong();                    outofsync.zxid = responseBuffer.getLong();                    outofsync.epoch = responseBuffer.getLong();                    outofsync.state = ackstate;                    outofsync.addr = (InetSocketAddress) responsePacket.getSocketAddress();                    recvqueue.offer(outofsync);                }                break;                        default:                                break;        }    }}
1
 long genChallenge()
{    byte[] buf = new byte[8];    buf[0] = (byte) ((challengeCounter & 0xff000000) >>> 24);    buf[1] = (byte) ((challengeCounter & 0x00ff0000) >>> 16);    buf[2] = (byte) ((challengeCounter & 0x0000ff00) >>> 8);    buf[3] = (byte) ((challengeCounter & 0x000000ff));    challengeCounter++;    int secret = rand.nextInt(java.lang.Integer.MAX_VALUE);    buf[4] = (byte) ((secret & 0xff000000) >>> 24);    buf[5] = (byte) ((secret & 0x00ff0000) >>> 16);    buf[6] = (byte) ((secret & 0x0000ff00) >>> 8);    buf[7] = (byte) ((secret & 0x000000ff));    return (((long) (buf[0] & 0xFF)) << 56) + (((long) (buf[1] & 0xFF)) << 48) + (((long) (buf[2] & 0xFF)) << 40) + (((long) (buf[3] & 0xFF)) << 32) + (((long) (buf[4] & 0xFF)) << 24) + (((long) (buf[5] & 0xFF)) << 16) + (((long) (buf[6] & 0xFF)) << 8) + ((long) (buf[7] & 0xFF));}
0
public void run()
{    while (true) {        try {            ToSend m = sendqueue.take();            process(m);        } catch (InterruptedException e) {            break;        }    }}
0
private void process(ToSend m)
{    int attempts = 0;    byte[] zeroes;    byte[] requestBytes = new byte[48];    DatagramPacket requestPacket = new DatagramPacket(requestBytes, requestBytes.length);    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    switch(m.type) {        case 0:            /*                     * Building challenge request packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(ToSend.mType.crequest.ordinal());            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            zeroes = new byte[32];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                if (challengeMap.get(m.tag) == null) {                    mySocket.send(requestPacket);                }            } catch (IOException e) {                            }            break;        case 1:            /*                     * Building challenge packet to send                     */            long newChallenge;            ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(m.addr);            if (tmpMap != null) {                Long tmpLong = tmpMap.get(m.tag);                if (tmpLong != null) {                    newChallenge = tmpLong;                } else {                    newChallenge = genChallenge();                }                tmpMap.put(m.tag, newChallenge);                requestBuffer.clear();                requestBuffer.putInt(ToSend.mType.challenge.ordinal());                requestBuffer.putLong(m.tag);                requestBuffer.putInt(m.state.ordinal());                requestBuffer.putLong(newChallenge);                zeroes = new byte[24];                requestBuffer.put(zeroes);                requestPacket.setLength(48);                try {                    requestPacket.setSocketAddress(m.addr);                } catch (IllegalArgumentException e) {                                        throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);                }                try {                    mySocket.send(requestPacket);                } catch (IOException e) {                                    }            } else {                            }            break;        case 2:            /*                     * Building notification packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            zeroes = new byte[8];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            boolean myChallenge = false;            boolean myAck = false;            while (attempts < maxAttempts) {                try {                    if (!myChallenge && authEnabled) {                        ToSend crequest = new ToSend(ToSend.mType.crequest, m.tag, m.leader, m.zxid, m.epoch, QuorumPeer.ServerState.LOOKING, m.addr);                        sendqueue.offer(crequest);                        try {                            double timeout = ackWait * java.lang.Math.pow(2, attempts);                            Semaphore s = new Semaphore(0);                            synchronized (Messenger.this) {                                challengeMutex.put(m.tag, s);                                s.tryAcquire((long) timeout, TimeUnit.MILLISECONDS);                                myChallenge = challengeMap.containsKey(m.tag);                            }                        } catch (InterruptedException e) {                                                    }                    }                    if (authEnabled && !myChallenge) {                        attempts++;                        continue;                    }                    if (authEnabled) {                        requestBuffer.position(40);                        Long tmpLong = challengeMap.get(m.tag);                        if (tmpLong != null) {                            requestBuffer.putLong(tmpLong);                        } else {                                                    }                    }                    mySocket.send(requestPacket);                    try {                        Semaphore s = new Semaphore(0);                        double timeout = ackWait * java.lang.Math.pow(10, attempts);                        ackMutex.put(m.tag, s);                        s.tryAcquire((int) timeout, TimeUnit.MILLISECONDS);                    } catch (InterruptedException e) {                                            }                    if (ackset.remove(m.tag)) {                        myAck = true;                    }                } catch (IOException e) {                                    /*                             * Do nothing, just try again                             */                }                if (myAck) {                    /*                             * Received ack successfully, so return                             */                    challengeMap.remove(m.tag);                    return;                } else {                    attempts++;                }            }            /*                     * Return message to queue for another attempt later if                     * epoch hasn't changed.                     */            if (m.epoch == logicalclock.get()) {                challengeMap.remove(m.tag);                sendqueue.offer(m);            }            break;        case 3:            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                mySocket.send(requestPacket);            } catch (IOException e) {                            }            break;        default:                        break;    }}
1
private void starter(QuorumPeer self)
{    this.self = self;    port = self.getVotingView().get(self.getId()).electionAddr.getPort();    proposedLeader = -1;    proposedZxid = -1;    try {        mySocket = new DatagramSocket(port);        } catch (SocketException e1) {        e1.printStackTrace();        throw new RuntimeException();    }    sendqueue = new LinkedBlockingQueue<ToSend>(2 * self.getVotingView().size());    recvqueue = new LinkedBlockingQueue<Notification>(2 * self.getVotingView().size());    new Messenger(self.getVotingView().size() * 2, mySocket);}
0
private void leaveInstance()
{    logicalclock.incrementAndGet();}
0
private void sendNotifications()
{    for (QuorumServer server : self.getView().values()) {        ToSend notmsg = new ToSend(ToSend.mType.notification, AuthFastLeaderElection.sequencer++, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, self.getView().get(server.id).electionAddr);        sendqueue.offer(notmsg);    }}
0
private boolean totalOrderPredicate(long id, long zxid)
{    return (zxid > proposedZxid) || ((zxid == proposedZxid) && (id > proposedLeader));}
0
private boolean termPredicate(Map<InetSocketAddress, Vote> votes, long l, long zxid)
{    Collection<Vote> votesCast = votes.values();    int count = 0;    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Vote v : votesCast) {        if ((v.getId() == l) && (v.getZxid() == zxid)) {            count++;        }    }    return count > (self.getVotingView().size() / 2);}
0
public void shutdown()
{}
0
public Vote lookForLeader() throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {                self.jmxLeaderElectionBean = null;    }    try {        HashMap<InetSocketAddress, Vote> recvset = new HashMap<InetSocketAddress, Vote>();        HashMap<InetSocketAddress, Vote> outofelection = new HashMap<InetSocketAddress, Vote>();        logicalclock.incrementAndGet();        proposedLeader = self.getId();        proposedZxid = self.getLastLoggedZxid();                sendNotifications();        while (self.getPeerState() == ServerState.LOOKING) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(2 * finalizeWait, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (((!outofelection.isEmpty()) || (recvset.size() > 1))) {                    sendNotifications();                }            } else {                switch(n.state) {                    case LOOKING:                        if (n.epoch > logicalclock.get()) {                            logicalclock.set(n.epoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid)) {                                proposedLeader = n.leader;                                proposedZxid = n.zxid;                            }                            sendNotifications();                        } else if (n.epoch < logicalclock.get()) {                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid)) {                            proposedLeader = n.leader;                            proposedZxid = n.zxid;                            sendNotifications();                        }                        recvset.put(n.addr, new Vote(n.leader, n.zxid));                                                if (self.getVotingView().size() == recvset.size()) {                            self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                                                                                                leaveInstance();                            return new Vote(proposedLeader, proposedZxid);                        } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {                                                                                    Thread.sleep(finalizeWait);                                                        while ((!recvqueue.isEmpty()) && !totalOrderPredicate(recvqueue.peek().leader, recvqueue.peek().zxid)) {                                recvqueue.poll();                            }                            if (recvqueue.isEmpty()) {                                                                                                self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                leaveInstance();                                return new Vote(proposedLeader, proposedZxid);                            }                        }                        break;                    case LEADING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    case FOLLOWING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    default:                        break;                }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }}
1
public synchronized int getLastBufferSize()
{    return lastBufferSize;}
0
public synchronized void setLastBufferSize(int value)
{    lastBufferSize = value;    if (minBufferSize == INIT_VALUE || value < minBufferSize) {        minBufferSize = value;    }    if (value > maxBufferSize) {        maxBufferSize = value;    }}
0
public synchronized int getMinBufferSize()
{    return minBufferSize;}
0
public synchronized int getMaxBufferSize()
{    return maxBufferSize;}
0
public synchronized void reset()
{    lastBufferSize = INIT_VALUE;    minBufferSize = INIT_VALUE;    maxBufferSize = INIT_VALUE;}
0
public synchronized String toString()
{    return String.format("%d/%d/%d", lastBufferSize, minBufferSize, maxBufferSize);}
0
private boolean isProcessingRequest()
{    return numRequestsProcessing.get() != 0;}
0
protected boolean needCommit(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setData:        case OpCode.reconfig:        case OpCode.multi:        case OpCode.setACL:        case OpCode.check:            return true;        case OpCode.sync:            return matchSyncs;        case OpCode.createSession:        case OpCode.closeSession:            return !request.isLocalSession();        default:            return false;    }}
0
public void run()
{    try {        /*             * In each iteration of the following loop we process at most             * requestsToProcess requests of queuedRequests. We have to limit             * the number of request we poll from queuedRequests, since it is             * possible to endlessly poll read requests from queuedRequests, and             * that will lead to a starvation of non-local committed requests.             */        int requestsToProcess = 0;        boolean commitIsWaiting = false;        do {            /*                 * Since requests are placed in the queue before being sent to                 * the leader, if commitIsWaiting = true, the commit belongs to                 * the first update operation in the queuedRequests or to a                 * request from a client on another server (i.e., the order of                 * the following two lines is important!).                 */            commitIsWaiting = !committedRequests.isEmpty();            requestsToProcess = queuedRequests.size();                        if (requestsToProcess == 0 && !commitIsWaiting) {                                synchronized (this) {                    while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {                        wait();                        commitIsWaiting = !committedRequests.isEmpty();                        requestsToProcess = queuedRequests.size();                    }                }            }            ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());            ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());            ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());            long time = Time.currentElapsedTime();            /*                 * Processing up to requestsToProcess requests from the incoming                 * queue (queuedRequests). If maxReadBatchSize is set then no                 * commits will be processed until maxReadBatchSize number of                 * reads are processed (or no more reads remain in the queue).                 * After the loop a single committed request is processed if                 * one is waiting (or a batch of commits if maxCommitBatchSize                 * is set).                 */            Request request;            int readsProcessed = 0;            while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {                requestsToProcess--;                if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {                                        Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());                    requests.addLast(request);                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());                } else {                    readsProcessed++;                    numReadQueuedRequests.decrementAndGet();                    sendToNextProcessor(request);                }                /*                     * Stop feeding the pool if there is a local pending update                     * and a committed request that is ready. Once we have a                     * pending request with a waiting committed request, we know                     * we can process the committed one. This is because commits                     * for local requests arrive in the order they appeared in                     * the queue, so if we have a pending request and a                     * committed request, the committed request must be for that                     * pending write or for a write originating at a different                     * server. We skip this if maxReadBatchSize is set.                     */                if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {                    /*                         * We set commitIsWaiting so that we won't check                         * committedRequests again.                         */                    commitIsWaiting = true;                    break;                }            }            ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);            if (!commitIsWaiting) {                commitIsWaiting = !committedRequests.isEmpty();            }            /*                 * Handle commits, if any.                 */            if (commitIsWaiting && !stopped) {                /*                     * Drain outstanding reads                     */                waitForEmptyPool();                if (stopped) {                    return;                }                int commitsToProcess = maxCommitBatchSize;                /*                     * Loop through all the commits, and try to drain them.                     */                Set<Long> queuesToDrain = new HashSet<>();                long startWriteTime = Time.currentElapsedTime();                int commitsProcessed = 0;                while (commitIsWaiting && !stopped && commitsToProcess > 0) {                                        request = committedRequests.peek();                    /*                         * Check if this is a local write request is pending,                         * if so, update it with the committed info. If the commit matches                         * the first write queued in the blockedRequestQueue, we know this is                         * a commit for a local write, as commits are received in order. Else                         * it must be a commit for a remote write.                         */                    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {                        /*                             * Commit matches the earliest write in our write queue.                             */                        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);                        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());                        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {                            /*                                 * Can't process this write yet.                                 * Either there are reads pending in this session, or we                                 * haven't gotten to this write yet.                                 */                            break;                        } else {                            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());                                                        Request topPending = sessionQueue.poll();                            /*                                 * Generally, we want to send to the next processor our version of the request,                                 * since it contains the session information that is needed for post update processing.                                 * In more details, when a request is in the local queue, there is (or could be) a client                                 * attached to this server waiting for a response, and there is other bookkeeping of                                 * requests that are outstanding and have originated from this server                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an                                 * outstanding request completes. Note that in the other case, the operation                                 * originated from a different server and there is no local bookkeeping or a local client                                 * session that needs to be notified.                                 */                            topPending.setHdr(request.getHdr());                            topPending.setTxn(request.getTxn());                            topPending.zxid = request.zxid;                            topPending.commitRecvTime = request.commitRecvTime;                            request = topPending;                                                        numWriteQueuedRequests.decrementAndGet();                            queuedWriteRequests.poll();                            queuesToDrain.add(request.sessionId);                        }                    }                    /*                         * Pull the request off the commit queue, now that we are going                         * to process it.                         */                    committedRequests.remove();                    commitsToProcess--;                    commitsProcessed++;                                        processWrite(request);                    commitIsWaiting = !committedRequests.isEmpty();                }                ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);                ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);                /*                     * Process following reads if any, remove session queue(s) if                     * empty.                     */                readsProcessed = 0;                for (Long sessionId : queuesToDrain) {                    Deque<Request> sessionQueue = pendingRequests.get(sessionId);                    int readsAfterWrite = 0;                    while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {                        numReadQueuedRequests.decrementAndGet();                        sendToNextProcessor(sessionQueue.poll());                        readsAfterWrite++;                    }                    ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);                    readsProcessed += readsAfterWrite;                                        if (sessionQueue.isEmpty()) {                        pendingRequests.remove(sessionId);                    }                }                ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());                ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);            }            ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);            endOfIteration();        } while (!stoppedMainLoop);    } catch (Throwable e) {        handleException(this.getName(), e);    }    }
1
protected void endOfIteration()
{}
0
protected void waitForEmptyPool() throws InterruptedException
{    int numRequestsInProcess = numRequestsProcessing.get();    if (numRequestsInProcess != 0) {        ServerMetrics.getMetrics().CONCURRENT_REQUEST_PROCESSING_IN_COMMIT_PROCESSOR.add(numRequestsInProcess);    }    long startWaitTime = Time.currentElapsedTime();    synchronized (emptyPoolSync) {        while ((!stopped) && isProcessingRequest()) {            emptyPoolSync.wait();        }    }    ServerMetrics.getMetrics().TIME_WAITING_EMPTY_POOL_IN_COMMIT_PROCESSOR_READ.add(Time.currentElapsedTime() - startWaitTime);}
0
public void start()
{    int numCores = Runtime.getRuntime().availableProcessors();    int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000);    initBatchSizes();        if (workerPool == null) {        workerPool = new WorkerService("CommitProcWork", numWorkerThreads, true);    }    stopped = false;    stoppedMainLoop = false;    super.start();}
1
private void sendToNextProcessor(Request request)
{    numRequestsProcessing.incrementAndGet();    workerPool.schedule(new CommitWorkRequest(request), request.sessionId);}
0
private void processWrite(Request request) throws RequestProcessorException
{    processCommitMetrics(request, true);    long timeBeforeFinalProc = Time.currentElapsedTime();    nextProcessor.processRequest(request);    ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);}
0
private static void initBatchSizes()
{    maxReadBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_READ_BATCH_SIZE, -1);    maxCommitBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_COMMIT_BATCH_SIZE, 1);    if (maxCommitBatchSize <= 0) {        String errorMsg = "maxCommitBatchSize must be positive, was " + maxCommitBatchSize;        throw new IllegalArgumentException(errorMsg);    }    }
1
private static void processCommitMetrics(Request request, boolean isWrite)
{    if (isWrite) {        if (request.commitProcQueueStartTime != -1 && request.commitRecvTime != -1) {                        long currentTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().WRITE_COMMITPROC_TIME.add(currentTime - request.commitProcQueueStartTime);            ServerMetrics.getMetrics().LOCAL_WRITE_COMMITTED_TIME.add(currentTime - request.commitRecvTime);        } else if (request.commitRecvTime != -1) {                        ServerMetrics.getMetrics().SERVER_WRITE_COMMITTED_TIME.add(Time.currentElapsedTime() - request.commitRecvTime);        }    } else {        if (request.commitProcQueueStartTime != -1) {            ServerMetrics.getMetrics().READ_COMMITPROC_TIME.add(Time.currentElapsedTime() - request.commitProcQueueStartTime);        }    }}
0
public static int getMaxReadBatchSize()
{    return maxReadBatchSize;}
0
public static int getMaxCommitBatchSize()
{    return maxCommitBatchSize;}
0
public static void setMaxReadBatchSize(int size)
{    maxReadBatchSize = size;    }
1
public static void setMaxCommitBatchSize(int size)
{    if (size > 0) {        maxCommitBatchSize = size;            }}
1
public void cleanup()
{    if (!stopped) {                CommitProcessor.this.halt();    }}
1
public void doWork() throws RequestProcessorException
{    try {        processCommitMetrics(request, needCommit(request));        long timeBeforeFinalProc = Time.currentElapsedTime();        nextProcessor.processRequest(request);        if (needCommit(request)) {            ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        } else {            ServerMetrics.getMetrics().READ_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        }    } finally {        if (numRequestsProcessing.decrementAndGet() == 0) {            wakeupOnEmpty();        }    }}
0
private synchronized void wakeup()
{    notifyAll();}
0
private void wakeupOnEmpty()
{    synchronized (emptyPoolSync) {        emptyPoolSync.notifyAll();    }}
0
public void commit(Request request)
{    if (stopped || request == null) {        return;    }        request.commitRecvTime = Time.currentElapsedTime();    ServerMetrics.getMetrics().COMMITS_QUEUED.add(1);    committedRequests.add(request);    wakeup();}
1
public void processRequest(Request request)
{    if (stopped) {        return;    }        request.commitProcQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);        if (needCommit(request)) {        queuedWriteRequests.add(request);        numWriteQueuedRequests.incrementAndGet();    } else {        numReadQueuedRequests.incrementAndGet();    }    wakeup();}
1
private void halt()
{    stoppedMainLoop = true;    stopped = true;    wakeupOnEmpty();    wakeup();    queuedRequests.clear();    if (workerPool != null) {        workerPool.stop();    }}
0
public void shutdown()
{        halt();    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
1
public void run()
{    Message response;    while (!stop) {                try {            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (response == null) {                continue;            }                        if (response.buffer.capacity() < 28) {                                continue;            }                                                boolean backCompatibility28 = (response.buffer.capacity() == 28);                        boolean backCompatibility40 = (response.buffer.capacity() == 40);            response.buffer.clear();                        Notification n = new Notification();            int rstate = response.buffer.getInt();            long rleader = response.buffer.getLong();            long rzxid = response.buffer.getLong();            long relectionEpoch = response.buffer.getLong();            long rpeerepoch;            int version = 0x0;            if (!backCompatibility28) {                rpeerepoch = response.buffer.getLong();                if (!backCompatibility40) {                    /*                                 * Version added in 3.4.6                                 */                    version = response.buffer.getInt();                } else {                                    }            } else {                                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);            }            QuorumVerifier rqv = null;                        if (version > 0x1) {                int configLength = response.buffer.getInt();                byte[] b = new byte[configLength];                response.buffer.get(b);                synchronized (self) {                    try {                        rqv = self.configFromString(new String(b));                        QuorumVerifier curQV = self.getQuorumVerifier();                        if (rqv.getVersion() > curQV.getVersion()) {                                                        if (self.getPeerState() == ServerState.LOOKING) {                                                                self.processReconfig(rqv, null, null, false);                                if (!rqv.equals(curQV)) {                                                                        self.shuttingDownLE = true;                                    self.getElectionAlg().shutdown();                                    break;                                }                            } else {                                                            }                        }                    } catch (IOException e) {                                            } catch (ConfigException e) {                                            }                }            } else {                            }            /*                         * If it is from a non-voting server (such as an observer or                         * a non-voting follower), respond right away.                         */            if (!validVoter(response.sid)) {                Vote current = self.getCurrentVote();                QuorumVerifier qv = self.getQuorumVerifier();                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                sendqueue.offer(notmsg);            } else {                                                                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;                switch(rstate) {                    case 0:                        ackstate = QuorumPeer.ServerState.LOOKING;                        break;                    case 1:                        ackstate = QuorumPeer.ServerState.FOLLOWING;                        break;                    case 2:                        ackstate = QuorumPeer.ServerState.LEADING;                        break;                    case 3:                        ackstate = QuorumPeer.ServerState.OBSERVING;                        break;                    default:                        continue;                }                n.leader = rleader;                n.zxid = rzxid;                n.electionEpoch = relectionEpoch;                n.state = ackstate;                n.sid = response.sid;                n.peerEpoch = rpeerepoch;                n.version = version;                n.qv = rqv;                /*                             * Print notification info                             */                if (LOG.isInfoEnabled()) {                    printNotification(n);                }                if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {                    recvqueue.offer(n);                    /*                                 * Send a notification back if the peer that sent this                                 * message is also looking and its logical clock is                                 * lagging behind.                                 */                    if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {                        Vote v = getVote();                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                } else {                    /*                                 * If this server is not looking, but the one that sent the ack                                 * is looking, then send back what it believes to be the leader.                                 */                    Vote current = self.getCurrentVote();                    if (ackstate == QuorumPeer.ServerState.LOOKING) {                        if (self.leader != null) {                            if (leadingVoteSet != null) {                                self.leader.setLeadingVoteSet(leadingVoteSet);                                leadingVoteSet = null;                            }                            self.leader.reportLookingSid(response.sid);                        }                        if (LOG.isDebugEnabled()) {                                                    }                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                }            }        } catch (InterruptedException e) {                    }    }    }
1
public void run()
{    while (!stop) {        try {            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);            if (m == null) {                continue;            }            process(m);        } catch (InterruptedException e) {            break;        }    }    }
1
 void process(ToSend m)
{    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch, m.configData);    manager.toSend(m.sid, requestBuffer);}
0
 void start()
{    this.wsThread.start();    this.wrThread.start();}
0
 void halt()
{    this.ws.stop = true;    this.wr.stop = true;}
0
public long getLogicalClock()
{    return logicalclock.get();}
0
 static ByteBuffer buildMsg(int state, long leader, long zxid, long electionEpoch, long epoch)
{    byte[] requestBytes = new byte[40];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send, this is called directly only in tests         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(0x1);    return requestBuffer;}
0
 static ByteBuffer buildMsg(int state, long leader, long zxid, long electionEpoch, long epoch, byte[] configData)
{    byte[] requestBytes = new byte[44 + configData.length];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(Notification.CURRENTVERSION);    requestBuffer.putInt(configData.length);    requestBuffer.put(configData);    return requestBuffer;}
0
private void starter(QuorumPeer self, QuorumCnxManager manager)
{    this.self = self;    proposedLeader = -1;    proposedZxid = -1;    sendqueue = new LinkedBlockingQueue<ToSend>();    recvqueue = new LinkedBlockingQueue<Notification>();    this.messenger = new Messenger(manager);}
0
public void start()
{    this.messenger.start();}
0
private void leaveInstance(Vote v)
{    if (LOG.isDebugEnabled()) {            }    recvqueue.clear();}
1
public QuorumCnxManager getCnxManager()
{    return manager;}
0
public void shutdown()
{    stop = true;    proposedLeader = -1;    proposedZxid = -1;    leadingVoteSet = null;        manager.halt();        messenger.halt();    }
1
private void sendNotifications()
{    for (long sid : self.getCurrentAndNextConfigVoters()) {        QuorumVerifier qv = self.getQuorumVerifier();        ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes());        if (LOG.isDebugEnabled()) {                    }        sendqueue.offer(notmsg);    }}
1
protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    if (LOG.isDebugEnabled()) {            }    if (self.getQuorumVerifier().getWeight(newId) == 0) {        return false;    }    return ((newEpoch > curEpoch) || ((newEpoch == curEpoch) && ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));}
1
protected SyncedLearnerTracker getVoteTracker(Map<Long, Vote> votes, Vote vote)
{    SyncedLearnerTracker voteSet = new SyncedLearnerTracker();    voteSet.addQuorumVerifier(self.getQuorumVerifier());    if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {        voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());    }    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Map.Entry<Long, Vote> entry : votes.entrySet()) {        if (vote.equals(entry.getValue())) {            voteSet.addAck(entry.getKey());        }    }    return voteSet;}
0
protected boolean checkLeader(Map<Long, Vote> votes, long leader, long electionEpoch)
{    boolean predicate = true;    if (leader != self.getId()) {        if (votes.get(leader) == null) {            predicate = false;        } else if (votes.get(leader).getState() != ServerState.LEADING) {            predicate = false;        }    } else if (logicalclock.get() != electionEpoch) {        predicate = false;    }    return predicate;}
0
 synchronized void updateProposal(long leader, long zxid, long epoch)
{    if (LOG.isDebugEnabled()) {            }    proposedLeader = leader;    proposedZxid = zxid;    proposedEpoch = epoch;}
1
public synchronized Vote getVote()
{    return new Vote(proposedLeader, proposedZxid, proposedEpoch);}
0
private ServerState learningState()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {                return ServerState.FOLLOWING;    } else {                return ServerState.OBSERVING;    }}
1
private long getInitId()
{    if (self.getQuorumVerifier().getVotingMembers().containsKey(self.getId())) {        return self.getId();    } else {        return Long.MIN_VALUE;    }}
0
private long getInitLastLoggedZxid()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        return self.getLastLoggedZxid();    } else {        return Long.MIN_VALUE;    }}
0
private long getPeerEpoch()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        try {            return self.getCurrentEpoch();        } catch (IOException e) {            RuntimeException re = new RuntimeException(e.getMessage());            re.setStackTrace(e.getStackTrace());            throw re;        }    } else {        return Long.MIN_VALUE;    }}
0
private void setPeerState(long proposedLeader, SyncedLearnerTracker voteSet)
{    ServerState ss = (proposedLeader == self.getId()) ? ServerState.LEADING : learningState();    self.setPeerState(ss);    if (ss == ServerState.LEADING) {        leadingVoteSet = voteSet;    }}
0
public Vote lookForLeader() throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {                self.jmxLeaderElectionBean = null;    }    self.start_fle = Time.currentElapsedTime();    try {        Map<Long, Vote> recvset = new HashMap<Long, Vote>();        Map<Long, Vote> outofelection = new HashMap<Long, Vote>();        int notTimeout = minNotificationInterval;        synchronized (this) {            logicalclock.incrementAndGet();            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());        }                sendNotifications();        SyncedLearnerTracker voteSet;        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (manager.haveDelivered()) {                    sendNotifications();                } else {                    manager.connectAll();                }                /*                     * Exponential backoff                     */                int tmpTimeOut = notTimeout * 2;                notTimeout = (tmpTimeOut < maxNotificationInterval ? tmpTimeOut : maxNotificationInterval);                            } else if (validVoter(n.sid) && validVoter(n.leader)) {                /*                     * Only proceed if the vote comes from a replica in the current or next                     * voting view for a replica in the current or next voting view.                     */                switch(n.state) {                    case LOOKING:                        if (getInitLastLoggedZxid() == -1) {                                                        break;                        }                        if (n.zxid == -1) {                                                        break;                        }                                                if (n.electionEpoch > logicalclock.get()) {                            logicalclock.set(n.electionEpoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {                                updateProposal(n.leader, n.zxid, n.peerEpoch);                            } else {                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());                            }                            sendNotifications();                        } else if (n.electionEpoch < logicalclock.get()) {                            if (LOG.isDebugEnabled()) {                                                            }                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                            updateProposal(n.leader, n.zxid, n.peerEpoch);                            sendNotifications();                        }                        if (LOG.isDebugEnabled()) {                                                    }                                                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));                        if (voteSet.hasAllQuorums()) {                                                        while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                                    recvqueue.put(n);                                    break;                                }                            }                            /*                             * This predicate is true once we don't read any new                             * relevant message from the reception queue                             */                            if (n == null) {                                setPeerState(proposedLeader, voteSet);                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        break;                    case OBSERVING:                                                break;                    case FOLLOWING:                    case LEADING:                        /*                         * Consider all notifications from the same epoch                         * together.                         */                        if (n.electionEpoch == logicalclock.get()) {                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                            voteSet = getVoteTracker(recvset, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                            if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                                setPeerState(n.leader, voteSet);                                Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        /*                         * Before joining an established ensemble, verify that                         * a majority are following the same leader.                         */                        outofelection.put(n.sid, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        voteSet = getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                            synchronized (this) {                                logicalclock.set(n.electionEpoch);                                setPeerState(n.leader, voteSet);                            }                            Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                            leaveInstance(endVote);                            return endVote;                        }                        break;                    default:                                                break;                }            } else {                if (!validVoter(n.leader)) {                                    }                if (!validVoter(n.sid)) {                                    }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;            }}
1
private boolean validVoter(long sid)
{    return self.getCurrentAndNextConfigVoters().contains(sid);}
0
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
0
public boolean equals(Object o)
{    if (!(o instanceof QuorumHierarchical)) {        return false;    }    QuorumHierarchical qm = (QuorumHierarchical) o;    if (qm.getVersion() == version) {        return true;    }    if ((allMembers.size() != qm.getAllMembers().size()) || (serverWeight.size() != qm.serverWeight.size()) || (groupWeight.size() != qm.groupWeight.size()) || (serverGroup.size() != qm.serverGroup.size())) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    for (Entry<Long, Long> entry : serverWeight.entrySet()) {        if (!entry.getValue().equals(qm.serverWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : groupWeight.entrySet()) {        if (!entry.getValue().equals(qm.groupWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        if (!entry.getValue().equals(qm.serverGroup.get(entry.getKey()))) {            return false;        }    }    return true;}
0
public long getWeight(long id)
{    return serverWeight.get(id);}
0
private void readConfigFile(String filename) throws ConfigException
{    File configFile = new File(filename);        try {        if (!configFile.exists()) {            throw new IllegalArgumentException(configFile.toString() + " file is missing");        }        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parse(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + filename, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + filename, e);    }}
1
private void parse(Properties quorumProp) throws ConfigException
{    for (Entry<Object, Object> entry : quorumProp.entrySet()) {        String key = entry.getKey().toString();        String value = entry.getValue().toString();        if (key.startsWith("server.")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            QuorumServer qs = new QuorumServer(sid, value);            allMembers.put(Long.valueOf(sid), qs);            if (qs.type == LearnerType.PARTICIPANT) {                participatingMembers.put(Long.valueOf(sid), qs);            } else {                observingMembers.put(Long.valueOf(sid), qs);            }        } else if (key.startsWith("group")) {            int dot = key.indexOf('.');            long gid = Long.parseLong(key.substring(dot + 1));            numGroups++;            String[] parts = value.split(":");            for (String s : parts) {                long sid = Long.parseLong(s);                if (serverGroup.containsKey(sid)) {                    throw new ConfigException("Server " + sid + "is in multiple groups");                } else {                    serverGroup.put(sid, gid);                }            }        } else if (key.startsWith("weight")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            serverWeight.put(sid, Long.parseLong(value));        } else if (key.equals("version")) {            version = Long.parseLong(value, 16);        }    }    for (QuorumServer qs : allMembers.values()) {        Long id = qs.id;        if (qs.type == LearnerType.PARTICIPANT) {            if (!serverGroup.containsKey(id)) {                throw new ConfigException("Server " + id + "is not in a group");            }            if (!serverWeight.containsKey(id)) {                serverWeight.put(id, (long) 1);            }        }    }    computeGroupWeight();}
0
public Map<Long, QuorumServer> getAllMembers()
{    return allMembers;}
0
public String toString()
{    StringWriter sw = new StringWriter();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    Map<Long, String> groups = new HashMap<Long, String>();    for (Entry<Long, Long> pair : serverGroup.entrySet()) {        Long sid = pair.getKey();        Long gid = pair.getValue();        String str = groups.get(gid);        if (str == null) {            str = sid.toString();        } else {            str = str.concat(":").concat(sid.toString());        }        groups.put(gid, str);    }    for (Entry<Long, String> pair : groups.entrySet()) {        Long gid = pair.getKey();        String key = "group." + gid.toString();        String value = pair.getValue();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    for (Entry<Long, Long> pair : serverWeight.entrySet()) {        Long sid = pair.getKey();        String key = "weight." + sid.toString();        String value = pair.getValue().toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    sw.append("version=" + Long.toHexString(version));    return sw.toString();}
0
private void computeGroupWeight()
{    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        Long sid = entry.getKey();        Long gid = entry.getValue();        if (!groupWeight.containsKey(gid)) {            groupWeight.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);            groupWeight.put(gid, totalWeight);        }    }    /*         * Do not consider groups with weight zero         */    for (long weight : groupWeight.values()) {                if (weight == ((long) 0)) {            numGroups--;                    }    }}
1
public boolean containsQuorum(Set<Long> set)
{    HashMap<Long, Long> expansion = new HashMap<Long, Long>();    /*         * Adds up weights per group         */        if (set.size() == 0) {        return false;    }    for (long sid : set) {        Long gid = serverGroup.get(sid);        if (gid == null) {            continue;        }        if (!expansion.containsKey(gid)) {            expansion.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + expansion.get(gid);            expansion.put(gid, totalWeight);        }    }    /*         * Check if all groups have majority         */    int majGroupCounter = 0;    for (Entry<Long, Long> entry : expansion.entrySet()) {        Long gid = entry.getKey();                if (entry.getValue() > (groupWeight.get(gid) / 2)) {            majGroupCounter++;        }    }        if ((majGroupCounter > (numGroups / 2))) {                return true;    } else {                return false;    }}
1
public Map<Long, QuorumServer> getVotingMembers()
{    return participatingMembers;}
0
public Map<Long, QuorumServer> getObservingMembers()
{    return observingMembers;}
0
public long getVersion()
{    return version;}
0
public void setVersion(long ver)
{    version = ver;}
0
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
0
public boolean equals(Object o)
{    if (!(o instanceof QuorumMaj)) {        return false;    }    QuorumMaj qm = (QuorumMaj) o;    if (qm.getVersion() == version) {        return true;    }    if (allMembers.size() != qm.getAllMembers().size()) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    return true;}
0
public long getWeight(long id)
{    return 1;}
0
public String toString()
{    StringBuilder sw = new StringBuilder();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    String hexVersion = Long.toHexString(version);    sw.append("version=");    sw.append(hexVersion);    return sw.toString();}
0
public boolean containsQuorum(Set<Long> ackSet)
{    return (ackSet.size() > half);}
0
public Map<Long, QuorumServer> getAllMembers()
{    return allMembers;}
0
public Map<Long, QuorumServer> getVotingMembers()
{    return votingMembers;}
0
public Map<Long, QuorumServer> getObservingMembers()
{    return observingMembers;}
0
public long getVersion()
{    return version;}
0
public void setVersion(long ver)
{    version = ver;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Follower ").append(sock);    sb.append(" lastQueuedZxid:").append(lastQueued);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
0
 void followLeader() throws InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);        self.start_fle = 0;    self.end_fle = 0;    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);    long connectionTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer leaderServer = findLeader();        try {            connectToLeader(leaderServer.addr, leaderServer.hostname);            connectionTime = System.currentTimeMillis();            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }                                    long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);            if (newEpoch < self.getAcceptedEpoch()) {                                throw new IOException("Error: Epoch of leader is lower");            }            long startTime = Time.currentElapsedTime();            try {                self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);                syncWithLeader(newEpochZxid);                self.setZabState(QuorumPeer.ZabState.BROADCAST);                completedSync = true;            } finally {                long syncTime = Time.currentElapsedTime() - startTime;                ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);            }            if (self.getObserverMasterPort() > 0) {                                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());                om.start();            } else {                om = null;            }                        QuorumPacket qp = new QuorumPacket();            while (this.isRunning()) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {                        closeSocket();                        pendingRevalidations.clear();        }    } finally {        if (om != null) {            om.stop();        }        zk.unregisterJMX(this);        if (connectionTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectionTime;                        messageTracker.dumpToLog(leaderAddr.toString());        }    }}
1
protected void processPacket(QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            if (hdr.getZxid() != lastQueued + 1) {                            }            lastQueued = hdr.getZxid();            if (hdr.getType() == OpCode.reconfig) {                SetDataTxn setDataTxn = (SetDataTxn) txn;                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                self.setLastSeenQuorumVerifier(qv, true);            }            fzk.logRequest(hdr, txn);            if (hdr != null) {                /*                 * Request header is created only by the leader, so this is only set                 * for quorum packets. If there is a clock drift, the latency may be                 * negative. Headers use wall time, not CLOCK_MONOTONIC.                 */                long now = Time.currentWallTime();                long latency = now - hdr.getTime();                if (latency >= 0) {                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);                }            }            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalReceived(qp);                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMIT:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            fzk.commit(qp.getZxid());            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalCommitted(qp.getZxid());                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMITANDACTIVATE:                        Request request = fzk.pendingTxns.element();            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            final long zxid = qp.getZxid();            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);                        fzk.commit(zxid);            if (om != null) {                om.informAndActivate(zxid, suggestedLeaderId);            }            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        case Leader.UPTODATE:                        break;        case Leader.REVALIDATE:            if (om == null || !om.revalidateLearnerSession(qp)) {                revalidate(qp);            }            break;        case Leader.SYNC:            fzk.sync();            break;        default:                        break;    }}
1
public long getZxid()
{    try {        synchronized (fzk) {            return fzk.getZxid();        }    } catch (NullPointerException e) {            }    return -1;}
1
protected long getLastQueued()
{    return lastQueued;}
0
public Integer getSyncedObserverSize()
{    return om == null ? null : om.getNumActiveObservers();}
0
public Iterable<Map<String, Object>> getSyncedObserversInfo()
{    if (om != null && om.getNumActiveObservers() > 0) {        return om.getActiveObservers();    }    return Collections.emptySet();}
0
public void resetObserverConnectionStats()
{    if (om != null && om.getNumActiveObservers() > 0) {        om.resetObserverConnectionStats();    }}
0
public void shutdown()
{        super.shutdown();}
1
public String getName()
{    return "Follower";}
0
public String getQuorumAddress()
{    return follower.sock.toString();}
0
public String getLastQueuedZxid()
{    return "0x" + Long.toHexString(follower.getLastQueued());}
0
public int getPendingRevalidationCount()
{    return follower.getPendingRevalidationsCount();}
0
public long getElectionTimeTaken()
{    return follower.self.getElectionTimeTaken();}
0
public int getObserverMasterPacketSizeLimit()
{    return follower.om == null ? -1 : follower.om.getPktsSizeLimit();}
0
public void setObserverMasterPacketSizeLimit(int sizeLimit)
{    ObserverMaster.setPktsSizeLimit(sizeLimit);}
0
public int getMaxConcurrentSnapSyncs()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentSnapSyncs();}
0
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapshots)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);    }}
0
public int getMaxConcurrentDiffSyncs()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentDiffSyncs();}
0
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);    }}
0
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getFollower().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getFollower().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getFollower().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    }
1
public void processRequest(Request request)
{    processRequest(request, true);}
0
 void processRequest(Request request, boolean checkForUpgrade)
{    if (!finished) {        if (checkForUpgrade) {                                                Request upgradeRequest = null;            try {                upgradeRequest = zks.checkUpgradeSession(request);            } catch (KeeperException ke) {                if (request.getHdr() != null) {                    request.getHdr().setType(OpCode.error);                    request.setTxn(new ErrorTxn(ke.code().intValue()));                }                request.setException(ke);                            } catch (IOException ie) {                            }            if (upgradeRequest != null) {                queuedRequests.add(upgradeRequest);            }        }        queuedRequests.add(request);    }}
1
public void shutdown()
{        finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
1
public Follower getFollower()
{    return self.follower;}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new FollowerRequestProcessor(this, commitProcessor);    ((FollowerRequestProcessor) firstProcessor).start();    syncProcessor = new SyncRequestProcessor(this, new SendAckRequestProcessor(getFollower()));    syncProcessor.start();}
0
public void logRequest(TxnHeader hdr, Record txn)
{    Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    if ((request.zxid & 0xffffffffL) != 0) {        pendingTxns.add(request);    }    syncProcessor.processRequest(request);}
0
public void commit(long zxid)
{    if (pendingTxns.size() == 0) {                return;    }    long firstElementZxid = pendingTxns.element().zxid;    if (firstElementZxid != zxid) {                System.exit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());    }    Request request = pendingTxns.remove();    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);    commitProcessor.commit(request);}
1
public synchronized void sync()
{    if (pendingSyncs.size() == 0) {                return;    }    Request r = pendingSyncs.remove();    if (r instanceof LearnerSyncRequest) {        LearnerSyncRequest lsr = (LearnerSyncRequest) r;        lsr.fh.queuePacket(new QuorumPacket(Leader.SYNC, 0, null, null));    }    commitProcessor.commit(r);}
1
public int getGlobalOutstandingLimit()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
0
public String getState()
{    return "follower";}
0
public Learner getLearner()
{    return getFollower();}
0
 void processObserverRequest(Request request)
{    ((FollowerRequestProcessor) firstProcessor).processRequest(request, false);}
0
 boolean registerJMX(LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {            }    return false;}
1
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);}
0
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("synced_observers");}
0
public String toString()
{    return packet.getType() + ", " + packet.getZxid() + ", " + request;}
0
public static void setAckLoggingFrequency(int frequency)
{    ackLoggingFrequency = frequency;}
0
public static int getAckLoggingFrequency()
{    return ackLoggingFrequency;}
0
public BufferStats getProposalStats()
{    return proposalStats;}
0
public List<LearnerHandler> getLearners()
{    synchronized (learners) {        return new ArrayList<LearnerHandler>(learners);    }}
0
public List<LearnerHandler> getForwardingFollowers()
{    synchronized (forwardingFollowers) {        return new ArrayList<LearnerHandler>(forwardingFollowers);    }}
0
public List<LearnerHandler> getNonVotingFollowers()
{    List<LearnerHandler> nonVotingFollowers = new ArrayList<LearnerHandler>();    synchronized (forwardingFollowers) {        for (LearnerHandler lh : forwardingFollowers) {            if (!isParticipant(lh.getSid())) {                nonVotingFollowers.add(lh);            }        }    }    return nonVotingFollowers;}
0
 void addForwardingFollower(LearnerHandler lh)
{    synchronized (forwardingFollowers) {        forwardingFollowers.add(lh);    }}
0
public List<LearnerHandler> getObservingLearners()
{    synchronized (observingLearners) {        return new ArrayList<LearnerHandler>(observingLearners);    }}
0
private void addObserverLearnerHandler(LearnerHandler lh)
{    synchronized (observingLearners) {        observingLearners.add(lh);    }}
0
public Iterable<Map<String, Object>> getObservingLearnersInfo()
{    Set<Map<String, Object>> info = new HashSet<>();    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            info.add(lh.getLearnerHandlerInfo());        }    }    return info;}
0
public void resetObserverConnectionStats()
{    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            lh.resetObserverConnectionStats();        }    }}
0
public synchronized int getNumPendingSyncs()
{    return pendingSyncs.size();}
0
public void addLearnerHandler(LearnerHandler learner)
{    synchronized (learners) {        learners.add(learner);    }}
0
public void removeLearnerHandler(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        forwardingFollowers.remove(peer);    }    synchronized (learners) {        learners.remove(peer);    }    synchronized (observingLearners) {        observingLearners.remove(peer);    }}
0
 boolean isLearnerSynced(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        return forwardingFollowers.contains(peer);    }}
0
public boolean isQuorumSynced(QuorumVerifier qv)
{    HashSet<Long> ids = new HashSet<Long>();    if (qv.getVotingMembers().containsKey(self.getId())) {        ids.add(self.getId());    }    synchronized (forwardingFollowers) {        for (LearnerHandler learnerHandler : forwardingFollowers) {            if (learnerHandler.synced() && qv.getVotingMembers().containsKey(learnerHandler.getSid())) {                ids.add(learnerHandler.getSid());            }        }    }    return qv.containsQuorum(ids);}
0
public void run()
{    try {        while (!stop) {            Socket s = null;            boolean error = false;            try {                s = ss.accept();                                                s.setSoTimeout(self.tickTime * self.initLimit);                s.setTcpNoDelay(nodelay);                BufferedInputStream is = new BufferedInputStream(s.getInputStream());                LearnerHandler fh = new LearnerHandler(s, is, Leader.this);                fh.start();            } catch (SocketException e) {                error = true;                if (stop) {                                                                                                    stop = true;                } else {                    throw e;                }            } catch (SaslException e) {                                error = true;            } catch (Exception e) {                error = true;                throw e;            } finally {                                if (error && s != null && !s.isClosed()) {                    try {                        s.close();                    } catch (IOException e) {                                            }                }            }        }    } catch (Exception e) {                handleException(this.getName(), e);    }}
1
public void halt()
{    stop = true;}
0
public long getUptime()
{    if (leaderStartTime > 0) {        return Time.currentElapsedTime() - leaderStartTime;    }    return 0;}
0
 void lead() throws IOException, InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);        self.start_fle = 0;    self.end_fle = 0;    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        self.tick.set(0);        zk.loadData();        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());                        cnxAcceptor = new LearnerCnxAcceptor();        cnxAcceptor.start();        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));        synchronized (this) {            lastProposed = zk.getZxid();        }        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {                    }        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        QuorumVerifier curQV = self.getQuorumVerifier();        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {                        try {                QuorumVerifier newQV = self.configFromString(curQV.toString());                newQV.setVersion(zk.getZxid());                self.setLastSeenQuorumVerifier(newQV, true);            } catch (Exception e) {                throw new IOException(e);            }        }        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }                                waitForEpochAck(self.getId(), leaderStateSummary);        self.setCurrentEpoch(epoch);        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getId());        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);        try {            waitForNewLeaderAck(self.getId(), zk.getZxid());        } catch (InterruptedException e) {            shutdown("Waiting for a quorum of followers, only synced with sids: [ " + newLeaderProposal.ackSetsToString() + " ]");            HashSet<Long> followerSet = new HashSet<Long>();            for (LearnerHandler f : getLearners()) {                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {                    followerSet.add(f.getSid());                }            }            boolean initTicksShouldBeIncreased = true;            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {                    initTicksShouldBeIncreased = false;                    break;                }            }            if (initTicksShouldBeIncreased) {                            }            return;        }        startZkServer();        /**         * WARNING: do not use this for anything other than QA testing         * on a real cluster. Specifically to enable verification that quorum         * can handle the lower 32bit roll-over issue identified in         * ZOOKEEPER-1277. Without this option it would take a very long         * time (on order of a month say) to see the 4 billion writes         * necessary to cause the roll-over to occur.         *         * This field allows you to override the zxid of the server. Typically         * you'll want to set it to something like 0xfffffff0 and then         * start the quorum, run some operations and see the re-election.         */        String initialZxid = System.getProperty("zookeeper.testingonly.initialZxid");        if (initialZxid != null) {            long zxid = Long.parseLong(initialZxid);            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);        }        if (!System.getProperty("zookeeper.leaderServes", "yes").equals("no")) {            self.setZooKeeperServer(zk);        }        self.setZabState(QuorumPeer.ZabState.BROADCAST);        self.adminServer.setZooKeeperServer(zk);                                                                                boolean tickSkip = true;                String shutdownMessage = null;        while (true) {            synchronized (this) {                long start = Time.currentElapsedTime();                long cur = start;                long end = start + self.tickTime / 2;                while (cur < end) {                    wait(end - cur);                    cur = Time.currentElapsedTime();                }                if (!tickSkip) {                    self.tick.incrementAndGet();                }                                                                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());                }                syncedAckSet.addAck(self.getId());                for (LearnerHandler f : getLearners()) {                    if (f.synced()) {                        syncedAckSet.addAck(f.getSid());                    }                }                                if (!this.isRunning()) {                                        shutdownMessage = "Unexpected internal error";                    break;                }                if (!tickSkip && !syncedAckSet.hasAllQuorums()) {                                                            shutdownMessage = "Not sufficient followers synced, only synced with sids: [ " + syncedAckSet.ackSetsToString() + " ]";                    break;                }                tickSkip = !tickSkip;            }            for (LearnerHandler f : getLearners()) {                f.ping();            }        }        if (shutdownMessage != null) {            shutdown(shutdownMessage);                }    } finally {        zk.unregisterJMX(this);    }}
1
 void shutdown(String reason)
{        if (isShutdown) {        return;    }        if (cnxAcceptor != null) {        cnxAcceptor.halt();    }        self.setZooKeeperServer(null);    self.adminServer.setZooKeeperServer(null);    try {        ss.close();    } catch (IOException e) {            }    self.closeAllConnections();        if (zk != null) {        zk.shutdown();    }    synchronized (learners) {        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {            LearnerHandler f = it.next();            it.remove();            f.shutdown();        }    }    isShutdown = true;}
1
private long getDesignatedLeader(Proposal reconfigProposal, long zxid)
{        Proposal.QuorumVerifierAcksetPair newQVAcksetPair = reconfigProposal.qvAcksetPairs.get(reconfigProposal.qvAcksetPairs.size() - 1);        if (newQVAcksetPair.getQuorumVerifier().getVotingMembers().containsKey(self.getId()) && newQVAcksetPair.getQuorumVerifier().getVotingMembers().get(self.getId()).addr.equals(self.getQuorumAddress())) {        return self.getId();    }                HashSet<Long> candidates = new HashSet<Long>(newQVAcksetPair.getAckset());        candidates.remove(self.getId());    long curCandidate = candidates.iterator().next();            long curZxid = zxid + 1;    Proposal p = outstandingProposals.get(curZxid);    while (p != null && !candidates.isEmpty()) {        for (Proposal.QuorumVerifierAcksetPair qvAckset : p.qvAcksetPairs) {                        candidates.retainAll(qvAckset.getAckset());                        if (candidates.isEmpty()) {                return curCandidate;            }                        curCandidate = candidates.iterator().next();            if (candidates.size() == 1) {                return curCandidate;            }        }        curZxid++;        p = outstandingProposals.get(curZxid);    }    return curCandidate;}
0
public synchronized boolean tryToCommit(Proposal p, long zxid, SocketAddress followerAddr)
{        if (outstandingProposals.containsKey(zxid - 1)) {        return false;    }        if (!p.hasAllQuorums()) {        return false;    }        if (zxid != lastCommitted + 1) {                    }    outstandingProposals.remove(zxid);    if (p.request != null) {        toBeApplied.add(p);    }    if (p.request == null) {            } else if (p.request.getHdr().getType() == OpCode.reconfig) {                                                Long designatedLeader = getDesignatedLeader(p, zxid);                QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);        if (designatedLeader != self.getId()) {            allowedToCommit = false;        }                                commitAndActivate(zxid, designatedLeader);        informAndActivate(p, designatedLeader);        } else {        p.request.logLatency(ServerMetrics.getMetrics().QUORUM_ACK_LATENCY);        commit(zxid);        inform(p);    }    zk.commitProcessor.commit(p.request);    if (pendingSyncs.containsKey(zxid)) {        for (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {            sendSync(r);        }    }    return true;}
1
public synchronized void processAck(long sid, long zxid, SocketAddress followerAddr)
{    if (!allowedToCommit) {                return;    }        if (LOG.isTraceEnabled()) {        LOG.trace("Ack zxid: 0x{}", Long.toHexString(zxid));        for (Proposal p : outstandingProposals.values()) {            long packetZxid = p.packet.getZxid();            LOG.trace("outstanding proposal: 0x{}", Long.toHexString(packetZxid));        }        LOG.trace("outstanding proposals all");    }    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack with this method. However,             * the learner sends an ack back to the leader after it gets             * UPTODATE, so we just ignore the message.             */        return;    }    if (outstandingProposals.size() == 0) {                return;    }    if (lastCommitted >= zxid) {        if (LOG.isDebugEnabled()) {                    }                return;    }    Proposal p = outstandingProposals.get(zxid);    if (p == null) {                return;    }    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));    }    p.addAck(sid);    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {        long curZxid = zxid;        while (allowedToCommit && hasCommitted && p != null) {            curZxid++;            p = outstandingProposals.get(curZxid);            if (p != null) {                hasCommitted = tryToCommit(p, curZxid, null);            }        }    }}
1
public void processRequest(Request request) throws RequestProcessorException
{    next.processRequest(request);        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        Iterator<Proposal> iter = leader.toBeApplied.iterator();        if (iter.hasNext()) {            Proposal p = iter.next();            if (p.request != null && p.request.zxid == zxid) {                iter.remove();                return;            }        }            }}
1
public void shutdown()
{        next.shutdown();}
1
 void sendPacket(QuorumPacket qp)
{    synchronized (forwardingFollowers) {        for (LearnerHandler f : forwardingFollowers) {            f.queuePacket(qp);        }    }}
0
 void sendObserverPacket(QuorumPacket qp)
{    for (LearnerHandler f : getObservingLearners()) {        f.queuePacket(qp);    }}
0
public void commit(long zxid)
{    synchronized (this) {        lastCommitted = zxid;    }    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);    sendPacket(qp);    ServerMetrics.getMetrics().COMMIT_COUNT.add(1);}
0
public void commitAndActivate(long zxid, long designatedLeader)
{    synchronized (this) {        lastCommitted = zxid;    }    byte[] data = new byte[8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    QuorumPacket qp = new QuorumPacket(Leader.COMMITANDACTIVATE, zxid, data, null);    sendPacket(qp);}
0
public void inform(Proposal proposal)
{    QuorumPacket qp = new QuorumPacket(Leader.INFORM, proposal.request.zxid, proposal.packet.getData(), null);    sendObserverPacket(qp);}
0
public static QuorumPacket buildInformAndActivePacket(long zxid, long designatedLeader, byte[] proposalData)
{    byte[] data = new byte[proposalData.length + 8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    buffer.put(proposalData);    return new QuorumPacket(Leader.INFORMANDACTIVATE, zxid, data, null);}
0
public void informAndActivate(Proposal proposal, long designatedLeader)
{    sendObserverPacket(buildInformAndActivePacket(proposal.request.zxid, designatedLeader, proposal.packet.getData()));}
0
public synchronized long getLastProposed()
{    return lastProposed;}
0
public long getEpoch()
{    return ZxidUtils.getEpochFromZxid(lastProposed);}
0
public Proposal propose(Request request) throws XidRolloverException
{    /**     * Address the rollover issue. All lower 32bits set indicate a new leader     * election. Force a re-election instead. See ZOOKEEPER-1277     */    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {        String msg = "zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start";        shutdown(msg);        throw new XidRolloverException(msg);    }    byte[] data = SerializeUtils.serializeRequest(request);    proposalStats.setLastBufferSize(data.length);    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);    Proposal p = new Proposal();    p.packet = pp;    p.request = request;    synchronized (this) {        p.addQuorumVerifier(self.getQuorumVerifier());        if (request.getHdr().getType() == OpCode.reconfig) {            self.setLastSeenQuorumVerifier(request.qv, true);        }        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }                lastProposed = p.packet.getZxid();        outstandingProposals.put(lastProposed, p);        sendPacket(pp);    }    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);    return p;}
1
public synchronized void processSync(LearnerSyncRequest r)
{    if (outstandingProposals.isEmpty()) {        sendSync(r);    } else {        List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);        if (l == null) {            l = new ArrayList<LearnerSyncRequest>();        }        l.add(r);        pendingSyncs.put(lastProposed, l);    }}
0
public void sendSync(LearnerSyncRequest r)
{    QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);    r.fh.queuePacket(qp);}
0
public synchronized long startForwarding(LearnerHandler handler, long lastSeenZxid)
{        if (lastProposed > lastSeenZxid) {        for (Proposal p : toBeApplied) {            if (p.packet.getZxid() <= lastSeenZxid) {                continue;            }            handler.queuePacket(p.packet);                                    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet.getZxid(), null, null);            handler.queuePacket(qp);        }                if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            List<Long> zxids = new ArrayList<Long>(outstandingProposals.keySet());            Collections.sort(zxids);            for (Long zxid : zxids) {                if (zxid <= lastSeenZxid) {                    continue;                }                handler.queuePacket(outstandingProposals.get(zxid).packet);            }        }    }    if (handler.getLearnerType() == LearnerType.PARTICIPANT) {        addForwardingFollower(handler);    } else {        addObserverLearnerHandler(handler);    }    return lastProposed;}
0
public void waitForStartup() throws InterruptedException
{    synchronized (zk) {        while (!zk.isRunning() && !Thread.currentThread().isInterrupted()) {            zk.wait(20);        }    }}
0
public static void setMaxTimeToWaitForEpoch(int maxTimeToWaitForEpoch)
{    Leader.maxTimeToWaitForEpoch = maxTimeToWaitForEpoch;    }
1
private void quitLeading()
{    synchronized (connectingFollowers) {        quitWaitForEpoch = true;        connectingFollowers.notifyAll();    }    ServerMetrics.getMetrics().QUIT_LEADING_DUE_TO_DISLOYAL_VOTER.add(1);    }
1
public void setLeadingVoteSet(SyncedLearnerTracker voteSet)
{    this.voteSet = voteSet;}
0
public void reportLookingSid(long sid)
{    if (maxTimeToWaitForEpoch < 0 || timeStartWaitForEpoch < 0 || !waitingForNewEpoch) {        return;    }    if (voteSet == null || !voteSet.hasSid(sid)) {        return;    }    if (Time.currentElapsedTime() - timeStartWaitForEpoch > maxTimeToWaitForEpoch) {        quitLeading();    }}
0
public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    synchronized (connectingFollowers) {        if (!waitingForNewEpoch) {            return epoch;        }        if (lastAcceptedEpoch >= epoch) {            epoch = lastAcceptedEpoch + 1;        }        if (isParticipant(sid)) {            connectingFollowers.add(sid);        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) {            waitingForNewEpoch = false;            self.setAcceptedEpoch(epoch);            connectingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            if (sid == self.getId()) {                timeStartWaitForEpoch = start;            }            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (waitingForNewEpoch && cur < end && !quitWaitForEpoch) {                connectingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (waitingForNewEpoch) {                throw new InterruptedException("Timeout while waiting for epoch from quorum");            }        }        return epoch;    }}
0
public ZKDatabase getZKDatabase()
{    return zk.getZKDatabase();}
0
public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException
{    synchronized (electingFollowers) {        if (electionFinished) {            return;        }        if (ss.getCurrentEpoch() != -1) {            if (ss.isMoreRecentThan(leaderStateSummary)) {                throw new IOException("Follower is ahead of the leader, leader summary: " + leaderStateSummary.getCurrentEpoch() + " (current epoch), " + leaderStateSummary.getLastZxid() + " (last zxid)");            }            if (ss.getLastZxid() != -1 && isParticipant(id)) {                electingFollowers.add(id);            }        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {            electionFinished = true;            electingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!electionFinished && cur < end) {                electingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!electionFinished) {                throw new InterruptedException("Timeout while waiting for epoch to be acked by quorum");            }        }    }}
0
private String getSidSetString(Set<Long> sidSet)
{    StringBuilder sids = new StringBuilder();    Iterator<Long> iter = sidSet.iterator();    while (iter.hasNext()) {        sids.append(iter.next());        if (!iter.hasNext()) {            break;        }        sids.append(",");    }    return sids.toString();}
0
public void waitForNewLeaderAck(long sid, long zxid) throws InterruptedException
{    synchronized (newLeaderProposal.qvAcksetPairs) {        if (quorumFormed) {            return;        }        long currentZxid = newLeaderProposal.packet.getZxid();        if (zxid != currentZxid) {                        return;        }        /*             * Note that addAck already checks that the learner             * is a PARTICIPANT.             */        newLeaderProposal.addAck(sid);        if (newLeaderProposal.hasAllQuorums()) {            quorumFormed = true;            newLeaderProposal.qvAcksetPairs.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!quorumFormed && cur < end) {                newLeaderProposal.qvAcksetPairs.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!quorumFormed) {                throw new InterruptedException("Timeout while waiting for NEWLEADER to be acked by quorum");            }        }    }}
1
public static String getPacketType(int packetType)
{    switch(packetType) {        case DIFF:            return "DIFF";        case TRUNC:            return "TRUNC";        case SNAP:            return "SNAP";        case OBSERVERINFO:            return "OBSERVERINFO";        case NEWLEADER:            return "NEWLEADER";        case FOLLOWERINFO:            return "FOLLOWERINFO";        case UPTODATE:            return "UPTODATE";        case LEADERINFO:            return "LEADERINFO";        case ACKEPOCH:            return "ACKEPOCH";        case REQUEST:            return "REQUEST";        case PROPOSAL:            return "PROPOSAL";        case ACK:            return "ACK";        case COMMIT:            return "COMMIT";        case COMMITANDACTIVATE:            return "COMMITANDACTIVATE";        case PING:            return "PING";        case REVALIDATE:            return "REVALIDATE";        case SYNC:            return "SYNC";        case INFORM:            return "INFORM";        case INFORMANDACTIVATE:            return "INFORMANDACTIVATE";        default:            return "UNKNOWN";    }}
0
private boolean isRunning()
{    return self.isRunning() && zk.isRunning();}
0
private boolean isParticipant(long sid)
{    return self.getQuorumVerifier().getVotingMembers().containsKey(sid);}
0
public int getCurrentTick()
{    return self.tick.get();}
0
public int syncTimeout()
{    return self.tickTime * self.syncLimit;}
0
public int getTickOfNextAckDeadline()
{    return self.tick.get() + self.syncLimit;}
0
public int getTickOfInitialAckDeadline()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
0
public long getAndDecrementFollowerCounter()
{    return followerCounter.getAndDecrement();}
0
public void touch(long sess, int to)
{    zk.touch(sess, to);}
0
public void submitLearnerRequest(Request si)
{    zk.submitLearnerRequest(si);}
0
public long getQuorumVerifierVersion()
{    return self.getQuorumVerifier().getVersion();}
0
public String getPeerInfo(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
0
public byte[] getQuorumVerifierBytes()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
0
public QuorumAuthServer getQuorumAuthServer()
{    return (self == null) ? null : self.authServer;}
0
public void revalidateSession(QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);    boolean valid = zk.checkIfValidGlobalSession(id, to);    if (valid) {        try {                        zk.setOwner(id, learnerHandler);        } catch (KeeperException.SessionExpiredException e) {                    }    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(id) + " is valid: " + valid);    }    dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    learnerHandler.queuePacket(qp);}
1
public void registerLearnerHandlerBean(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zk.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
0
public void unregisterLearnerHandlerBean(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
0
public String getName()
{    return "Leader";}
0
public String getCurrentZxid()
{    return "0x" + Long.toHexString(zks.getZxid());}
0
public String followerInfo()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getLearners()) {        if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            sb.append(handler.toString()).append("\n");        }    }    return sb.toString();}
0
public String nonVotingFollowerInfo()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getNonVotingFollowers()) {        sb.append(handler.toString()).append("\n");    }    return sb.toString();}
0
public long getElectionTimeTaken()
{    return leader.self.getElectionTimeTaken();}
0
public int getLastProposalSize()
{    return leader.getProposalStats().getLastBufferSize();}
0
public int getMinProposalSize()
{    return leader.getProposalStats().getMinBufferSize();}
0
public int getMaxProposalSize()
{    return leader.getProposalStats().getMaxBufferSize();}
0
public void resetProposalStatistics()
{    leader.getProposalStats().reset();}
0
public int getMaxConcurrentSnapSyncs()
{    return leader.getMaxConcurrentSnapSyncs();}
0
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapshots)
{    leader.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);}
0
public int getMaxConcurrentDiffSyncs()
{    return leader.getMaxConcurrentDiffSyncs();}
0
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{    leader.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);}
0
public String getName()
{    return "LeaderElection";}
0
public boolean isHidden()
{    return false;}
0
public String getStartTime()
{    return startTime.toString();}
0
public void processRequest(Request request) throws RequestProcessorException
{        if (!lzks.authWriteRequest(request)) {        return;    }            Request upgradeRequest = null;    try {        upgradeRequest = lzks.checkUpgradeSession(request);    } catch (KeeperException ke) {        if (request.getHdr() != null) {                        request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(ke.code().intValue()));        }        request.setException(ke);            } catch (IOException ie) {            }    if (upgradeRequest != null) {        nextProcessor.processRequest(upgradeRequest);    }    nextProcessor.processRequest(request);}
1
public void shutdown()
{        nextProcessor.shutdown();}
1
public void removeSession(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionTracker.removeSession(sessionId);}
0
public void start()
{    globalSessionTracker.start();    if (localSessionTracker != null) {        localSessionTracker.start();    }}
0
public void shutdown()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }    globalSessionTracker.shutdown();}
0
public boolean isGlobalSession(long sessionId)
{    return globalSessionTracker.isTrackingSession(sessionId);}
0
public boolean trackSession(long sessionId, int sessionTimeout)
{    boolean tracked = globalSessionTracker.trackSession(sessionId, sessionTimeout);    if (localSessionsEnabled && tracked) {                            }    return tracked;}
1
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    boolean added = globalSessionTracker.commitSession(sessionId, sessionTimeout);    if (added) {            }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    return added;}
1
public boolean touchSession(long sessionId, int sessionTimeout)
{    if (localSessionTracker != null && localSessionTracker.touchSession(sessionId, sessionTimeout)) {        return true;    }    return globalSessionTracker.touchSession(sessionId, sessionTimeout);}
0
public long createSession(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return globalSessionTracker.createSession(sessionTimeout);}
0
public static long getServerIdFromSessionId(long sessionId)
{    return sessionId >> 56;}
0
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException, UnknownSessionException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);                        if (!isGlobalSession(sessionId)) {                return;            }        } catch (UnknownSessionException e) {                }    }    try {        globalSessionTracker.checkSession(sessionId, owner);                return;    } catch (UnknownSessionException e) {        }    /*         * if local session is not enabled or it used to be our local session         * throw sessions expires         */    if (!localSessionsEnabled || (getServerIdFromSessionId(sessionId) == serverId)) {        throw new SessionExpiredException();    }}
0
public void checkGlobalSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    try {        globalSessionTracker.checkSession(sessionId, owner);    } catch (UnknownSessionException e) {                throw new SessionExpiredException();    }}
0
public void setOwner(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                }    }    globalSessionTracker.setOwner(sessionId, owner);}
0
public void dumpSessions(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);        pwriter.print("Global ");    }    globalSessionTracker.dumpSessions(pwriter);}
0
public void setSessionClosing(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }    globalSessionTracker.setSessionClosing(sessionId);}
0
public Map<Long, Set<Long>> getSessionExpiryMap()
{    Map<Long, Set<Long>> sessionExpiryMap;        if (localSessionTracker != null) {        sessionExpiryMap = localSessionTracker.getSessionExpiryMap();    } else {        sessionExpiryMap = new TreeMap<Long, Set<Long>>();    }    sessionExpiryMap.putAll(globalSessionTracker.getSessionExpiryMap());    return sessionExpiryMap;}
0
public Leader getLeader()
{    return self.leader;}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);    setupContainerManager();}
0
private synchronized void setupContainerManager()
{    containerManager = new ContainerManager(getZKDatabase(), prepRequestProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));}
0
public synchronized void startup()
{    super.startup();    if (containerManager != null) {        containerManager.start();    }}
0
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("learners", () -> {        return getLeader().getLearners().size();    });    rootContext.registerGauge("synced_followers", () -> {        return getLeader().getForwardingFollowers().size();    });    rootContext.registerGauge("synced_non_voting_followers", () -> {        return getLeader().getNonVotingFollowers().size();    });    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);    rootContext.registerGauge("pending_syncs", () -> {        return getLeader().getNumPendingSyncs();    });    rootContext.registerGauge("leader_uptime", () -> {        return getLeader().getUptime();    });    rootContext.registerGauge("last_proposal_size", () -> {        return getLeader().getProposalStats().getLastBufferSize();    });    rootContext.registerGauge("max_proposal_size", () -> {        return getLeader().getProposalStats().getMaxBufferSize();    });    rootContext.registerGauge("min_proposal_size", () -> {        return getLeader().getProposalStats().getMinBufferSize();    });}
0
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("learners");    rootContext.unregisterGauge("synced_followers");    rootContext.unregisterGauge("synced_non_voting_followers");    rootContext.unregisterGauge("synced_observers");    rootContext.unregisterGauge("pending_syncs");    rootContext.unregisterGauge("leader_uptime");    rootContext.unregisterGauge("last_proposal_size");    rootContext.unregisterGauge("max_proposal_size");    rootContext.unregisterGauge("min_proposal_size");}
0
public synchronized void shutdown()
{    if (containerManager != null) {        containerManager.stop();    }    super.shutdown();}
0
public int getGlobalOutstandingLimit()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
0
public void createSessionTracker()
{    sessionTracker = new LeaderSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
0
public boolean touch(long sess, int to)
{    return sessionTracker.touchSession(sess, to);}
0
public boolean checkIfValidGlobalSession(long sess, int to)
{    if (self.areLocalSessionsEnabled() && !upgradeableSessionTracker.isGlobalSession(sess)) {        return false;    }    return sessionTracker.touchSession(sess, to);}
0
public void submitLearnerRequest(Request request)
{    /*         * Requests coming from the learner should have gone through         * submitRequest() on each server which already perform some request         * validation, so we don't need to do it again.         *         * Additionally, LearnerHandler should start submitting requests into         * the leader's pipeline only when the leader's server is started, so we         * can submit the request directly into PrepRequestProcessor.         *         * This is done so that requests from learners won't go through         * LeaderRequestProcessor which perform local session upgrade.         */    prepRequestProcessor.processRequest(request);}
0
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
1
public void registerJMX(LeaderBean leaderBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = leaderBean;        MBeanRegistry.getInstance().register(leaderBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
1
 boolean registerJMX(LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {            }    return false;}
1
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
1
protected void unregisterJMX(Leader leader)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
1
public String getState()
{    return "leader";}
0
public long getServerId()
{    return self.getId();}
0
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    super.revalidateSession(cnxn, sessionId, sessionTimeout);    try {                        setOwner(sessionId, ServerCnxn.me);    } catch (SessionExpiredException e) {        }}
0
public Socket getSocket()
{    return sock;}
0
public int getPendingRevalidationsCount()
{    return pendingRevalidations.size();}
0
 void validateSession(ServerCnxn cnxn, long clientId, int timeout) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(clientId);    dos.writeInt(timeout);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    pendingRevalidations.put(clientId, cnxn);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "To validate session 0x" + Long.toHexString(clientId));    }    writePacket(qp, true);}
1
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    synchronized (leaderOs) {        if (pp != null) {            messageTracker.trackSent(pp.getType());            leaderOs.writeRecord(pp, "packet");        }        if (flush) {            bufferedOutput.flush();        }    }}
0
 void readPacket(QuorumPacket pp) throws IOException
{    synchronized (leaderIs) {        leaderIs.readRecord(pp, "packet");        messageTracker.trackReceived(pp.getType());    }    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    if (pp.getType() == Leader.PING) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);    }}
0
 void request(Request request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream oa = new DataOutputStream(baos);    oa.writeLong(request.sessionId);    oa.writeInt(request.cxid);    oa.writeInt(request.type);    if (request.request != null) {        request.request.rewind();        int len = request.request.remaining();        byte[] b = new byte[len];        request.request.get(b);        request.request.rewind();        oa.write(b);    }    oa.close();    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);    writePacket(qp, true);}
0
protected QuorumServer findLeader()
{    QuorumServer leaderServer = null;        Vote current = self.getCurrentVote();    for (QuorumServer s : self.getView().values()) {        if (s.id == current.getId()) {                                    s.recreateSocketAddresses();            leaderServer = s;            break;        }    }    if (leaderServer == null) {            }    return leaderServer;}
1
protected long nanoTime()
{    return System.nanoTime();}
0
protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    sock.connect(addr, timeout);}
0
protected void connectToLeader(InetSocketAddress addr, String hostname) throws IOException, InterruptedException, X509Exception
{    this.sock = createSocket();    this.leaderAddr = addr;        int connectTimeout = self.tickTime * self.initLimit;        if (self.connectToLearnerMasterLimit > 0) {        connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;    }    int remainingTimeout;    long startNanoTime = nanoTime();    for (int tries = 0; tries < 5; tries++) {        try {                        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 0) {                                throw new IOException("connectToLeader exceeded on retries.");            }            sockConnect(sock, addr, Math.min(connectTimeout, remainingTimeout));            if (self.isSslQuorum()) {                ((SSLSocket) sock).startHandshake();            }            sock.setTcpNoDelay(nodelay);            break;        } catch (IOException e) {            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 1000) {                                throw e;            } else if (tries >= 4) {                                throw e;            } else {                                this.sock = createSocket();            }        }        Thread.sleep(leaderConnectDelayDuringRetryMs);    }    self.authLearner.authenticate(sock, hostname);    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);}
1
private Socket createSocket() throws X509Exception, IOException
{    Socket sock;    if (self.isSslQuorum()) {        sock = self.getX509Util().createSSLSocket();    } else {        sock = new Socket();    }    sock.setSoTimeout(self.tickTime * self.initLimit);    return sock;}
0
protected long registerWithLeader(int pktType) throws IOException
{    /*         * Send follower info, including last zxid and sid         */    long lastLoggedZxid = self.getLastLoggedZxid();    QuorumPacket qp = new QuorumPacket();    qp.setType(pktType);    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));    /*         * Add sid to payload         */    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());    ByteArrayOutputStream bsid = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);    boa.writeRecord(li, "LearnerInfo");    qp.setData(bsid.toByteArray());    writePacket(qp, true);    readPacket(qp);    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());    if (qp.getType() == Leader.LEADERINFO) {                leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();        byte[] epochBytes = new byte[4];        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);        if (newEpoch > self.getAcceptedEpoch()) {            wrappedEpochBytes.putInt((int) self.getCurrentEpoch());            self.setAcceptedEpoch(newEpoch);        } else if (newEpoch == self.getAcceptedEpoch()) {                                                            wrappedEpochBytes.putInt(-1);        } else {            throw new IOException("Leaders epoch, " + newEpoch + " is less than accepted epoch, " + self.getAcceptedEpoch());        }        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);        writePacket(ackNewEpoch, true);        return ZxidUtils.makeZxid(newEpoch, 0);    } else {        if (newEpoch > self.getAcceptedEpoch()) {            self.setAcceptedEpoch(newEpoch);        }        if (qp.getType() != Leader.NEWLEADER) {                        throw new IOException("First packet should have been NEWLEADER");        }        return qp.getZxid();    }}
1
protected void syncWithLeader(long newLeaderZxid) throws Exception
{    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);    QuorumPacket qp = new QuorumPacket();    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);    QuorumVerifier newLeaderQV = null;            boolean snapshotNeeded = true;    boolean syncSnapshot = false;    readPacket(qp);    Deque<Long> packetsCommitted = new ArrayDeque<>();    Deque<PacketInFlight> packetsNotCommitted = new ArrayDeque<>();    synchronized (zk) {        if (qp.getType() == Leader.DIFF) {                        self.setSyncMode(QuorumPeer.SyncMode.DIFF);            snapshotNeeded = false;        } else if (qp.getType() == Leader.SNAP) {            self.setSyncMode(QuorumPeer.SyncMode.SNAP);                                                zk.getZKDatabase().deserializeSnapshot(leaderIs);                        if (!QuorumPeerConfig.isReconfigEnabled()) {                                zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());            }            String signature = leaderIs.readString("signature");            if (!signature.equals("BenWasHere")) {                                throw new IOException("Missing signature");            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());                        syncSnapshot = true;        } else if (qp.getType() == Leader.TRUNC) {                        self.setSyncMode(QuorumPeer.SyncMode.TRUNC);                        boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());            if (!truncated) {                                                System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());        } else {                        System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());        }        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());        zk.createSessionTracker();        long lastQueued = 0;                                boolean isPreZAB1_0 = true;                        boolean writeToTxnLog = !snapshotNeeded;                outerLoop: while (self.isRunning()) {            readPacket(qp);            switch(qp.getType()) {                case Leader.PROPOSAL:                    PacketInFlight pif = new PacketInFlight();                    pif.hdr = new TxnHeader();                    pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);                    if (pif.hdr.getZxid() != lastQueued + 1) {                                            }                    lastQueued = pif.hdr.getZxid();                    if (pif.hdr.getType() == OpCode.reconfig) {                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        self.setLastSeenQuorumVerifier(qv, true);                    }                    packetsNotCommitted.add(pif);                    break;                case Leader.COMMIT:                case Leader.COMMITANDACTIVATE:                    pif = packetsNotCommitted.peekFirst();                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData()));                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (!writeToTxnLog) {                        if (pif.hdr.getZxid() != qp.getZxid()) {                                                    } else {                            zk.processTxn(pif.hdr, pif.rec);                            packetsNotCommitted.remove();                        }                    } else {                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.INFORM:                case Leader.INFORMANDACTIVATE:                    PacketInFlight packet = new PacketInFlight();                    packet.hdr = new TxnHeader();                    if (qp.getType() == Leader.INFORMANDACTIVATE) {                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());                        long suggestedLeaderId = buffer.getLong();                        byte[] remainingdata = new byte[buffer.remaining()];                        buffer.get(remainingdata);                        packet.rec = SerializeUtils.deserializeTxn(remainingdata, packet.hdr);                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData()));                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    } else {                        packet.rec = SerializeUtils.deserializeTxn(qp.getData(), packet.hdr);                                                if (packet.hdr.getZxid() != lastQueued + 1) {                                                    }                        lastQueued = packet.hdr.getZxid();                    }                    if (!writeToTxnLog) {                                                zk.processTxn(packet.hdr, packet.rec);                    } else {                        packetsNotCommitted.add(packet);                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.UPTODATE:                                        if (newLeaderQV != null) {                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (isPreZAB1_0) {                        zk.takeSnapshot(syncSnapshot);                        self.setCurrentEpoch(newEpoch);                    }                    self.setZooKeeperServer(zk);                    self.adminServer.setZooKeeperServer(zk);                    break outerLoop;                case                 Leader.NEWLEADER:                                                            if (qp.getData() != null && qp.getData().length > 1) {                        try {                            QuorumVerifier qv = self.configFromString(new String(qp.getData()));                            self.setLastSeenQuorumVerifier(qv, true);                            newLeaderQV = qv;                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                    if (snapshotNeeded) {                        zk.takeSnapshot(syncSnapshot);                    }                    self.setCurrentEpoch(newEpoch);                                        writeToTxnLog = true;                    isPreZAB1_0 = false;                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);                    break;            }        }    }    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));    writePacket(ack, true);    sock.setSoTimeout(self.tickTime * self.syncLimit);    self.setSyncMode(QuorumPeer.SyncMode.NONE);    zk.startup();    /*         * Update the election vote here to ensure that all members of the         * ensemble report the same vote to new servers that start up and         * send leader election notifications to the ensemble.         *         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732         */    self.updateElectionVote(newEpoch);        if (zk instanceof FollowerZooKeeperServer) {        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            fzk.logRequest(p.hdr, p.rec);        }        for (Long zxid : packetsCommitted) {            fzk.commit(zxid);        }    } else if (zk instanceof ObserverZooKeeperServer) {                        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            Long zxid = packetsCommitted.peekFirst();            if (p.hdr.getZxid() != zxid) {                                                                continue;            }            packetsCommitted.remove();            Request request = new Request(null, p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), null, null);            request.setTxn(p.rec);            request.setHdr(p.hdr);            ozk.commitRequest(request);        }    } else {                throw new UnsupportedOperationException("Unknown server type");    }}
1
protected void revalidate(QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long sessionId = dis.readLong();    boolean valid = dis.readBoolean();    ServerCnxn cnxn = pendingRevalidations.remove(sessionId);    if (cnxn == null) {            } else {        zk.finishSessionInit(cnxn, valid);    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + valid);    }}
1
protected void ping(QuorumPacket qp) throws IOException
{        ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    Map<Long, Integer> touchTable = zk.getTouchSnapshot();    for (Entry<Long, Integer> entry : touchTable.entrySet()) {        dos.writeLong(entry.getKey());        dos.writeInt(entry.getValue());    }    qp.setData(bos.toByteArray());    writePacket(qp, true);}
0
public void shutdown()
{    self.setZooKeeperServer(null);    self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);    closeSocket();        if (zk != null) {        zk.shutdown();    }}
0
 boolean isRunning()
{    return self.isRunning() && zk.isRunning();}
0
 void closeSocket()
{    try {        if (sock != null) {            sock.close();        }    } catch (IOException e) {            }}
1
public Socket getSocket()
{    return sock;}
0
 long getSid()
{    return sid;}
0
 String getRemoteAddress()
{    return sock == null ? "<null>" : sock.getRemoteSocketAddress().toString();}
0
 int getVersion()
{    return version;}
0
public synchronized long getLastZxid()
{    return lastZxid;}
0
public Date getEstablished()
{    return (Date) established.clone();}
0
public synchronized void start()
{    started = true;}
0
public synchronized void updateProposal(long zxid, long time)
{    if (!started) {        return;    }    if (currentTime == 0) {        currentTime = time;        currentZxid = zxid;    } else {        nextTime = time;        nextZxid = zxid;    }}
0
public synchronized void updateAck(long zxid)
{    if (currentZxid == zxid) {        currentTime = nextTime;        currentZxid = nextZxid;        nextTime = 0;        nextZxid = 0;    } else if (nextZxid == zxid) {                nextTime = 0;        nextZxid = 0;    }}
1
public synchronized boolean check(long time)
{    if (currentTime == 0) {        return true;    } else {        long msDelay = (time - currentTime) / 1000000;        return (msDelay < learnerMaster.syncTimeout());    }}
0
public int hashCode()
{    return Objects.hash(time);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    MarkerQuorumPacket that = (MarkerQuorumPacket) o;    return time == that.time;}
0
protected void setOutputArchive(BinaryOutputArchive oa)
{    this.oa = oa;}
0
protected void setBufferedOutput(BufferedOutputStream bufferedOutput)
{    this.bufferedOutput = bufferedOutput;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("LearnerHandler ").append(sock);    sb.append(" tickOfNextAckDeadline:").append(tickOfNextAckDeadline());    sb.append(" synced?:").append(synced());    sb.append(" queuedPacketLength:").append(queuedPackets.size());    return sb.toString();}
0
public LearnerType getLearnerType()
{    return learnerType;}
0
private void sendPackets() throws InterruptedException
{    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    while (true) {        try {            QuorumPacket p;            p = queuedPackets.poll();            if (p == null) {                bufferedOutput.flush();                p = queuedPackets.take();            }            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());            if (p instanceof MarkerQuorumPacket) {                MarkerQuorumPacket m = (MarkerQuorumPacket) p;                ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);                continue;            }            queuedPacketsSize.addAndGet(-packetSize(p));            if (p == proposalOfDeath) {                                break;            }            if (p.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (p.getType() == Leader.PROPOSAL) {                syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);            }                        if (p.getZxid() > 0) {                lastZxid = p.getZxid();            }            oa.writeRecord(p, "packet");            packetsSent.incrementAndGet();            messageTracker.trackSent(p.getType());        } catch (IOException e) {            if (!sock.isClosed()) {                                try {                                                                                sock.close();                } catch (IOException ie) {                                    }            }            break;        }    }}
1
public static String packetToString(QuorumPacket p)
{    String type;    String mess = null;    switch(p.getType()) {        case Leader.ACK:            type = "ACK";            break;        case Leader.COMMIT:            type = "COMMIT";            break;        case Leader.FOLLOWERINFO:            type = "FOLLOWERINFO";            break;        case Leader.NEWLEADER:            type = "NEWLEADER";            break;        case Leader.PING:            type = "PING";            break;        case Leader.PROPOSAL:            type = "PROPOSAL";            TxnHeader hdr = new TxnHeader();            try {                SerializeUtils.deserializeTxn(p.getData(), hdr);                        } catch (IOException e) {                            }            break;        case Leader.REQUEST:            type = "REQUEST";            break;        case Leader.REVALIDATE:            type = "REVALIDATE";            ByteArrayInputStream bis = new ByteArrayInputStream(p.getData());            DataInputStream dis = new DataInputStream(bis);            try {                long id = dis.readLong();                mess = " sessionid = " + id;            } catch (IOException e) {                            }            break;        case Leader.UPTODATE:            type = "UPTODATE";            break;        case Leader.DIFF:            type = "DIFF";            break;        case Leader.TRUNC:            type = "TRUNC";            break;        case Leader.SNAP:            type = "SNAP";            break;        case Leader.ACKEPOCH:            type = "ACKEPOCH";            break;        case Leader.SYNC:            type = "SYNC";            break;        case Leader.INFORM:            type = "INFORM";            break;        case Leader.COMMITANDACTIVATE:            type = "COMMITANDACTIVATE";            break;        case Leader.INFORMANDACTIVATE:            type = "INFORMANDACTIVATE";            break;        default:            type = "UNKNOWN" + p.getType();    }    String entry = null;    if (type != null) {        entry = type + " " + Long.toHexString(p.getZxid()) + " " + mess;    }    return entry;}
1
public void run()
{    try {        learnerMaster.addLearnerHandler(this);        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();        ia = BinaryInputArchive.getArchive(bufferedInput);        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());        oa = BinaryOutputArchive.getArchive(bufferedOutput);        QuorumPacket qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {                        return;        }        if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {            throw new IOException("Non observer attempting to connect to ObserverMaster. type = " + qp.getType());        }        byte[] learnerInfoData = qp.getData();        if (learnerInfoData != null) {            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);            if (learnerInfoData.length >= 8) {                this.sid = bbsid.getLong();            }            if (learnerInfoData.length >= 12) {                                this.version = bbsid.getInt();            }            if (learnerInfoData.length >= 20) {                long configVersion = bbsid.getLong();                if (configVersion > learnerMaster.getQuorumVerifierVersion()) {                    throw new IOException("Follower is ahead of the leader (has a later activated configuration)");                }            }        } else {            this.sid = learnerMaster.getAndDecrementFollowerCounter();        }        String followerInfo = learnerMaster.getPeerInfo(this.sid);        if (followerInfo.isEmpty()) {                    } else {                    }        if (qp.getType() == Leader.OBSERVERINFO) {            learnerType = LearnerType.OBSERVER;        }        learnerMaster.registerLearnerHandlerBean(this, sock);        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());        long peerLastZxid;        StateSummary ss = null;        long zxid = qp.getZxid();        long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);        if (this.getVersion() < 0x10000) {                        long epoch = ZxidUtils.getEpochFromZxid(zxid);            ss = new StateSummary(epoch, zxid);                        learnerMaster.waitForEpochAck(this.getSid(), ss);        } else {            byte[] ver = new byte[4];            ByteBuffer.wrap(ver).putInt(0x10000);            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);            oa.writeRecord(newEpochPacket, "packet");            messageTracker.trackSent(Leader.LEADERINFO);            bufferedOutput.flush();            QuorumPacket ackEpochPacket = new QuorumPacket();            ia.readRecord(ackEpochPacket, "packet");            messageTracker.trackReceived(ackEpochPacket.getType());            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {                                return;            }            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());            learnerMaster.waitForEpochAck(this.getSid(), ss);        }        peerLastZxid = ss.getLastZxid();                        boolean needSnap = syncFollower(peerLastZxid, learnerMaster);                                boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;        /* if we are not truncating or sending a diff just send a snapshot */        if (needSnap) {            syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            try {                long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), "packet");                messageTracker.trackSent(Leader.SNAP);                bufferedOutput.flush();                                                learnerMaster.getZKDatabase().serializeSnapshot(oa);                oa.writeString("BenWasHere", "signature");                bufferedOutput.flush();            } finally {                ServerMetrics.getMetrics().SNAP_COUNT.add(1);            }        } else {            syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            ServerMetrics.getMetrics().DIFF_COUNT.add(1);        }                        if (getVersion() < 0x10000) {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);            oa.writeRecord(newLeaderQP, "packet");        } else {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);            queuedPackets.add(newLeaderQP);        }        bufferedOutput.flush();                startSendingPackets();        /*             * Have to wait for the first ACK, wait until             * the learnerMaster is ready, and only then we can             * start processing messages.             */        qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.ACK) {                        return;        }                learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());        syncLimitCheck.start();                syncThrottler.endSync();        syncThrottler = null;                sock.setSoTimeout(learnerMaster.syncTimeout());        /*             * Wait until learnerMaster starts up             */        learnerMaster.waitForStartup();                                                queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));        while (true) {            qp = new QuorumPacket();            ia.readRecord(qp, "packet");            messageTracker.trackReceived(qp.getType());            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;            if (qp.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);            }            tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();            packetsReceived.incrementAndGet();            ByteBuffer bb;            long sessionId;            int cxid;            int type;            switch(qp.getType()) {                case Leader.ACK:                    if (this.learnerType == LearnerType.OBSERVER) {                                            }                    syncLimitCheck.updateAck(qp.getZxid());                    learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());                    break;                case Leader.PING:                                        ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());                    DataInputStream dis = new DataInputStream(bis);                    while (dis.available() > 0) {                        long sess = dis.readLong();                        int to = dis.readInt();                        learnerMaster.touch(sess, to);                    }                    break;                case Leader.REVALIDATE:                    ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);                    learnerMaster.revalidateSession(qp, this);                    break;                case Leader.REQUEST:                    bb = ByteBuffer.wrap(qp.getData());                    sessionId = bb.getLong();                    cxid = bb.getInt();                    type = bb.getInt();                    bb = bb.slice();                    Request si;                    if (type == OpCode.sync) {                        si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());                    } else {                        si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());                    }                    si.setOwner(this);                    learnerMaster.submitLearnerRequest(si);                    requestsReceived.incrementAndGet();                    break;                default:                                        break;            }        }    } catch (IOException e) {        if (sock != null && !sock.isClosed()) {                                    try {                sock.close();            } catch (IOException ie) {                        }        }    } catch (InterruptedException e) {            } catch (SyncThrottleException e) {                syncThrottler = null;    } catch (Exception e) {                throw e;    } finally {        if (syncThrottler != null) {            syncThrottler.endSync();            syncThrottler = null;        }        String remoteAddr = getRemoteAddress();                messageTracker.dumpToLog(remoteAddr);        shutdown();    }}
1
protected void startSendingPackets()
{    if (!sendingThreadStarted) {                new Thread() {            public void run() {                Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());                try {                    sendPackets();                } catch (InterruptedException e) {                                    }            }        }.start();        sendingThreadStarted = true;    } else {            }}
1
public void run()
{    Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());    try {        sendPackets();    } catch (InterruptedException e) {            }}
1
protected boolean shouldSendMarkerPacketForLogging()
{    return true;}
0
 boolean syncFollower(long peerLastZxid, LearnerMaster learnerMaster)
{    /*         * When leader election is completed, the leader will set its         * lastProcessedZxid to be (epoch < 32). There will be no txn associated         * with this zxid.         *         * The learner will set its lastProcessedZxid to the same value if         * it get DIFF or SNAP from the learnerMaster. If the same learner come         * back to sync with learnerMaster using this zxid, we will never find this         * zxid in our history. In this case, we will ignore TRUNC logic and         * always send DIFF if we have old enough history         */    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;        long currentZxid = peerLastZxid;    boolean needSnap = true;    ZKDatabase db = learnerMaster.getZKDatabase();    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();    ReentrantReadWriteLock lock = db.getLogLock();    ReadLock rl = lock.readLock();    try {        rl.lock();        long maxCommittedLog = db.getmaxCommittedLog();        long minCommittedLog = db.getminCommittedLog();        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();                if (db.getCommittedLog().isEmpty()) {            /*                 * It is possible that committedLog is empty. In that case                 * setting these value to the latest txn in learnerMaster db                 * will reduce the case that we need to handle                 *                 * Here is how each case handle by the if block below                 * 1. lastProcessZxid == peerZxid -> Handle by (2)                 * 2. lastProcessZxid < peerZxid -> Handle by (3)                 * 3. lastProcessZxid > peerZxid -> Handle by (5)                 */            minCommittedLog = lastProcessedZxid;            maxCommittedLog = lastProcessedZxid;        }        if (forceSnapSync) {                                } else if (lastProcessedZxid == peerLastZxid) {                                    queueOpPacket(Leader.DIFF, peerLastZxid);            needOpPacket = false;            needSnap = false;        } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {                        if (LOG.isDebugEnabled()) {                            }            queueOpPacket(Leader.TRUNC, maxCommittedLog);            currentZxid = maxCommittedLog;            needOpPacket = false;            needSnap = false;        } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {                                    Iterator<Proposal> itr = db.getCommittedLog().iterator();            currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);            needSnap = false;        } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {                                    long sizeLimit = db.calculateTxnLogSizeLimit();                                    Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);            if (txnLogItr.hasNext()) {                                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);                if (currentZxid < minCommittedLog) {                                        currentZxid = peerLastZxid;                                                            queuedPackets.clear();                    needOpPacket = true;                } else {                    if (LOG.isDebugEnabled()) {                                            }                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);                    needSnap = false;                }            }                        if (txnLogItr instanceof TxnLogProposalIterator) {                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;                txnProposalItr.close();            }        } else {                    }        if (needSnap) {            currentZxid = db.getDataTreeLastProcessedZxid();        }        if (LOG.isDebugEnabled()) {                    }        leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);    } finally {        rl.unlock();    }    if (needOpPacket && !needSnap) {                                needSnap = true;    }    return needSnap;}
1
protected long queueCommittedProposals(Iterator<Proposal> itr, long peerLastZxid, Long maxZxid, Long lastCommittedZxid)
{    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;    long queuedZxid = peerLastZxid;            long prevProposalZxid = -1;    while (itr.hasNext()) {        Proposal propose = itr.next();        long packetZxid = propose.packet.getZxid();                if ((maxZxid != null) && (packetZxid > maxZxid)) {            break;        }                if (packetZxid < peerLastZxid) {            prevProposalZxid = packetZxid;            continue;        }                if (needOpPacket) {                        if (packetZxid == peerLastZxid) {                                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;                continue;            }            if (isPeerNewEpochZxid) {                                                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;            } else if (packetZxid > peerLastZxid) {                                if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {                                                                                                    return queuedZxid;                }                                queueOpPacket(Leader.TRUNC, prevProposalZxid);                needOpPacket = false;            }        }        if (packetZxid <= queuedZxid) {                        continue;        }                        queuePacket(propose.packet);        queueOpPacket(Leader.COMMIT, packetZxid);        queuedZxid = packetZxid;    }    if (needOpPacket && isPeerNewEpochZxid) {                                        queueOpPacket(Leader.DIFF, lastCommittedZxid);        needOpPacket = false;    }    return queuedZxid;}
1
public void shutdown()
{        try {        queuedPackets.clear();        queuedPackets.put(proposalOfDeath);    } catch (InterruptedException e) {            }    try {        if (sock != null && !sock.isClosed()) {            sock.close();        }    } catch (IOException e) {            }    this.interrupt();    learnerMaster.removeLearnerHandler(this);    learnerMaster.unregisterLearnerHandlerBean(this);}
1
public long tickOfNextAckDeadline()
{    return tickOfNextAckDeadline;}
0
public void ping()
{        if (!sendingThreadStarted) {        return;    }    long id;    if (syncLimitCheck.check(System.nanoTime())) {        id = learnerMaster.getLastProposed();        QuorumPacket ping = new QuorumPacket(Leader.PING, id, null, null);        queuePacket(ping);    } else {                shutdown();    }}
1
private void queueOpPacket(int type, long zxid)
{    QuorumPacket packet = new QuorumPacket(type, zxid, null, null);    queuePacket(packet);}
0
 void queuePacket(QuorumPacket p)
{    queuedPackets.add(p);        if (shouldSendMarkerPacketForLogging() && packetCounter.getAndIncrement() % markerPacketInterval == 0) {        queuedPackets.add(new MarkerQuorumPacket(System.nanoTime()));    }    queuedPacketsSize.addAndGet(packetSize(p));}
0
 static long packetSize(QuorumPacket p)
{    /* Approximate base size of QuorumPacket: int + long + byte[] + List */    long size = 4 + 8 + 8 + 8;    byte[] data = p.getData();    if (data != null) {        size += data.length;    }    return size;}
0
public boolean synced()
{    return isAlive() && learnerMaster.getCurrentTick() <= tickOfNextAckDeadline;}
0
public synchronized Map<String, Object> getLearnerHandlerInfo()
{    Map<String, Object> info = new LinkedHashMap<>(9);    info.put("remote_socket_address", getRemoteAddress());    info.put("sid", getSid());    info.put("established", getEstablished());    info.put("queued_packets", queuedPackets.size());    info.put("queued_packets_size", queuedPacketsSize.get());    info.put("packets_received", packetsReceived.longValue());    info.put("packets_sent", packetsSent.longValue());    info.put("requests", requestsReceived.longValue());    info.put("last_zxid", getLastZxid());    return info;}
0
public synchronized void resetObserverConnectionStats()
{    packetsReceived.set(0);    packetsSent.set(0);    requestsReceived.set(0);    lastZxid = -1;}
0
public Queue<QuorumPacket> getQueuedPackets()
{    return queuedPackets;}
0
public void setFirstPacket(boolean value)
{    needOpPacket = value;}
0
public String getName()
{    return MBeanRegistry.getInstance().makeFullPath("Learner_Connections", ObjectName.quote(remoteAddr), String.format("\"id:%d\"", learnerHandler.getSid()));}
0
public boolean isHidden()
{    return false;}
0
public void terminateConnection()
{        learnerHandler.shutdown();}
1
public String toString()
{    return "LearnerHandlerBean{remoteIP=" + remoteAddr + ",ServerId=" + learnerHandler.getSid() + "}";}
0
public int getMaxConcurrentSnapSyncs()
{    return maxConcurrentSnapSyncs;}
0
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapSyncs)
{        this.maxConcurrentSnapSyncs = maxConcurrentSnapSyncs;    learnerSnapSyncThrottler.setMaxConcurrentSyncs(maxConcurrentSnapSyncs);}
1
public int getMaxConcurrentDiffSyncs()
{    return maxConcurrentDiffSyncs;}
0
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{        this.maxConcurrentDiffSyncs = maxConcurrentDiffSyncs;    learnerDiffSyncThrottler.setMaxConcurrentSyncs(maxConcurrentDiffSyncs);}
1
public LearnerSyncThrottler getLearnerSnapSyncThrottler()
{    return learnerSnapSyncThrottler;}
0
public LearnerSyncThrottler getLearnerDiffSyncThrottler()
{    return learnerDiffSyncThrottler;}
0
public void removeSession(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionsWithTimeouts.remove(sessionId);    touchTable.get().remove(sessionId);}
0
public void start()
{    if (localSessionTracker != null) {        localSessionTracker.start();    }}
0
public void shutdown()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }}
0
public boolean isGlobalSession(long sessionId)
{    return globalSessionsWithTimeouts.containsKey(sessionId);}
0
public boolean trackSession(long sessionId, int sessionTimeout)
{        return false;}
0
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    boolean added = globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;    if (added) {                            }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    touchTable.get().put(sessionId, sessionTimeout);    return added;}
1
public boolean touchSession(long sessionId, int sessionTimeout)
{    if (localSessionsEnabled) {        if (localSessionTracker.touchSession(sessionId, sessionTimeout)) {            return true;        }        if (!isGlobalSession(sessionId) && !isUpgradingSession(sessionId)) {            return false;        }    }    touchTable.get().put(sessionId, sessionTimeout);    return true;}
0
public Map<Long, Integer> snapshot()
{    return touchTable.getAndSet(new ConcurrentHashMap<Long, Integer>());}
0
public long createSession(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return nextSessionId.getAndIncrement();}
0
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);            return;        } catch (UnknownSessionException e) {                        if (!isGlobalSession(sessionId)) {                throw new SessionExpiredException();            }        }    }}
0
public void setOwner(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                        if (!isGlobalSession(sessionId)) {                throw e;            }        }    }}
0
public void dumpSessions(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);    }    pwriter.print("Global Sessions(");    pwriter.print(globalSessionsWithTimeouts.size());    pwriter.println("):");    SortedSet<Long> sessionIds = new TreeSet<Long>(globalSessionsWithTimeouts.keySet());    for (long sessionId : sessionIds) {        pwriter.print("0x");        pwriter.print(Long.toHexString(sessionId));        pwriter.print("\t");        pwriter.print(globalSessionsWithTimeouts.get(sessionId));        pwriter.println("ms");    }}
0
public void setSessionClosing(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }}
0
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return new HashMap<Long, Set<Long>>();}
0
protected void beginSync(boolean essential) throws SyncThrottleException, InterruptedException
{    synchronized (countSyncObject) {        if (essential || syncInProgress < maxConcurrentSyncs) {            syncInProgress++;        } else {            throw new SyncThrottleException(syncInProgress + 1, maxConcurrentSyncs, syncType);        }    }}
0
public void endSync()
{    int newCount;    synchronized (countSyncObject) {        syncInProgress--;        newCount = syncInProgress;        countSyncObject.notify();    }    if (newCount < 0) {        String errorMsg = "endSync() called incorrectly; current sync count is " + newCount;            }}
1
public void setMaxConcurrentSyncs(int maxConcurrentSyncs)
{    this.maxConcurrentSyncs = maxConcurrentSyncs;}
0
public int getSyncInProgress()
{    return syncInProgress;}
0
protected Map<Long, Integer> getTouchSnapshot()
{    if (sessionTracker != null) {        return ((LearnerSessionTracker) sessionTracker).snapshot();    }    Map<Long, Integer> map = Collections.emptyMap();    return map;}
0
public long getServerId()
{    return self.getId();}
0
public void createSessionTracker()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
0
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    if (upgradeableSessionTracker.isLocalSession(sessionId)) {        super.revalidateSession(cnxn, sessionId, sessionTimeout);    } else {        getLearner().validateSession(cnxn, sessionId, sessionTimeout);    }}
0
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
1
public void registerJMX(ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
1
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
1
protected void unregisterJMX(Learner peer)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
1
public synchronized void shutdown()
{    if (!canShutdown()) {                return;    }        try {        super.shutdown();    } catch (Exception e) {            }    try {        if (syncProcessor != null) {            syncProcessor.shutdown();        }    } catch (Exception e) {            }}
1
public String getName()
{    return "replica." + peer.getId();}
0
public boolean isHidden()
{    return false;}
0
public int getTickTime()
{    return peer.getTickTime();}
0
public int getMaxClientCnxnsPerHost()
{    return peer.getMaxClientCnxnsPerHost();}
0
public int getMinSessionTimeout()
{    return peer.getMinSessionTimeout();}
0
public int getMaxSessionTimeout()
{    return peer.getMaxSessionTimeout();}
0
public int getInitLimit()
{    return peer.getInitLimit();}
0
public int getSyncLimit()
{    return peer.getSyncLimit();}
0
public void setInitLimit(int initLimit)
{    peer.setInitLimit(initLimit);}
0
public void setSyncLimit(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
0
public int getTick()
{    return peer.getTick();}
0
public String getState()
{    return peer.getServerState();}
0
public String getQuorumAddress()
{    return formatInetAddr(peer.getQuorumAddress());}
0
public int getElectionType()
{    return peer.getElectionType();}
0
public String getElectionAddress()
{    return formatInetAddr(peer.getElectionAddress());}
0
public String getClientAddress()
{    if (null != peer.cnxnFactory) {        return formatInetAddr(peer.cnxnFactory.getLocalAddress());    } else {        return "";    }}
0
public String getLearnerType()
{    return peer.getLearnerType().toString();}
0
public long getConfigVersion()
{    return peer.getQuorumVerifier().getVersion();}
0
public String getQuorumSystemInfo()
{    return peer.getQuorumVerifier().toString();}
0
public boolean isPartOfEnsemble()
{    return peer.getView().containsKey(peer.getId());}
0
public boolean isLeader()
{    return peer.isLeader(peer.getId());}
0
public boolean isLocalSession(long sessionId)
{    return isTrackingSession(sessionId);}
0
public boolean isGlobalSession(long sessionId)
{    return false;}
0
public long createSession(int sessionTimeout)
{    long sessionId = super.createSession(sessionTimeout);    commitSession(sessionId, sessionTimeout);    return sessionId;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Observer ").append(sock);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
0
 void observeLeader() throws Exception
{    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);    long connectTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer master = findLearnerMaster();        try {            connectToLeader(master.addr, master.hostname);            connectTime = System.currentTimeMillis();            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }            self.setLeaderAddressAndId(master.addr, master.getId());            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);            syncWithLeader(newLeaderZxid);            self.setZabState(QuorumPeer.ZabState.BROADCAST);            completedSync = true;            QuorumPacket qp = new QuorumPacket();            while (this.isRunning() && nextLearnerMaster.get() == null) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {                        closeSocket();                        pendingRevalidations.clear();        }    } finally {        currentLearnerMaster = null;        zk.unregisterJMX(this);        if (connectTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectTime;                        messageTracker.dumpToLog(leaderAddr.toString());        }    }}
1
private QuorumServer findLearnerMaster()
{    QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);    if (prescribedLearnerMaster != null && self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {                prescribedLearnerMaster = null;    }    final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null) ? self.findLearnerMaster(findLeader()) : prescribedLearnerMaster;    currentLearnerMaster = master;    if (master == null) {            } else {            }    return master;}
1
protected void processPacket(QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:                        break;        case Leader.COMMIT:                        break;        case Leader.UPTODATE:                        break;        case Leader.REVALIDATE:            revalidate(qp);            break;        case Leader.SYNC:            ((ObserverZooKeeperServer) zk).sync();            break;        case Leader.INFORM:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;            obs.commitRequest(request);            break;        case Leader.INFORMANDACTIVATE:            hdr = new TxnHeader();                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            byte[] remainingdata = new byte[buffer.remaining()];            buffer.get(remainingdata);            txn = SerializeUtils.deserializeTxn(remainingdata, hdr);            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData()));            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            obs = (ObserverZooKeeperServer) zk;            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);            obs.commitRequest(request);            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        default:                        break;    }}
1
public void shutdown()
{        super.shutdown();}
1
 static void waitForReconnectDelay()
{    waitForReconnectDelayHelper(reconnectDelayMs);}
0
 static void waitForObserverElectionDelay()
{    waitForReconnectDelayHelper(observerElectionDelayMs);}
0
private static void waitForReconnectDelayHelper(long delayValueMs)
{    if (delayValueMs > 0) {        long randomDelay = (long) (delayValueMs * Math.random());                try {            Thread.sleep(randomDelay);        } catch (InterruptedException e) {                    }    }}
1
public long getLearnerMasterId()
{    QuorumPeer.QuorumServer current = currentLearnerMaster;    return current == null ? -1 : current.id;}
0
public boolean setLearnerMaster(String learnerMaster)
{    final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);    if (server == null) {        return false;    } else if (server.equals(currentLearnerMaster)) {                return true;    } else {                nextLearnerMaster.set(server);        return true;    }}
1
public QuorumPeer.QuorumServer getCurrentLearnerMaster()
{    return currentLearnerMaster;}
0
public static long getObserverElectionDelayMs()
{    return observerElectionDelayMs;}
0
public static void setObserverElectionDelayMs(long electionDelayMs)
{    observerElectionDelayMs = electionDelayMs;    }
1
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    final Revalidation that = (Revalidation) o;    return sessionId == that.sessionId && timeout == that.timeout && handler.equals(that.handler);}
0
public int hashCode()
{    int result = (int) (sessionId ^ (sessionId >>> 32));    result = 31 * result + timeout;    result = 31 * result + handler.hashCode();    return result;}
0
public void run()
{    for (LearnerHandler lh : activeObservers) {        lh.ping();    }}
0
public void addLearnerHandler(LearnerHandler learnerHandler)
{    if (!listenerRunning) {        throw new RuntimeException(("ObserverMaster is not running"));    }}
0
public void removeLearnerHandler(LearnerHandler learnerHandler)
{    activeObservers.remove(learnerHandler);}
0
public int syncTimeout()
{    return self.getSyncLimit() * self.getTickTime();}
0
public int getTickOfNextAckDeadline()
{    return self.tick.get() + self.syncLimit;}
0
public int getTickOfInitialAckDeadline()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
0
public long getAndDecrementFollowerCounter()
{    return followerCounter.getAndDecrement();}
0
public void waitForEpochAck(long sid, StateSummary ss) throws IOException, InterruptedException
{}
0
public void waitForStartup() throws InterruptedException
{}
0
public synchronized long getLastProposed()
{    return lastProposedZxid;}
0
public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    return self.getCurrentEpoch();}
0
public ZKDatabase getZKDatabase()
{    return zks.getZKDatabase();}
0
public void waitForNewLeaderAck(long sid, long zxid) throws InterruptedException
{}
0
public int getCurrentTick()
{    return self.tick.get();}
0
public void processAck(long sid, long zxid, SocketAddress localSocketAddress)
{    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack by this method. However,             * the learner sends ack back to the leader after it gets UPTODATE             * so we just ignore the message.             */        return;    }    throw new RuntimeException("Observers shouldn't send ACKS ack = " + Long.toHexString(zxid));}
0
public void touch(long sess, int to)
{    zks.getSessionTracker().touchSession(sess, to);}
0
 boolean revalidateLearnerSession(QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    boolean valid = dis.readBoolean();    Iterator<Revalidation> itr = pendingRevalidations.iterator();    if (!itr.hasNext()) {                return false;    }    Revalidation revalidation = itr.next();    if (revalidation.sessionId != id) {                return false;    }    itr.remove();    LearnerHandler learnerHandler = revalidation.handler;        QuorumPacket deepCopy = new QuorumPacket(qp.getType(), qp.getZxid(), Arrays.copyOf(qp.getData(), qp.getData().length), qp.getAuthinfo() == null ? null : new ArrayList<>(qp.getAuthinfo()));    learnerHandler.queuePacket(deepCopy);        if (valid) {        touch(revalidation.sessionId, revalidation.timeout);    }    return true;}
0
public void revalidateSession(QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    synchronized (revalidateSessionLock) {        pendingRevalidations.add(new Revalidation(id, to, learnerHandler));        Learner learner = zks.getLearner();        if (learner != null) {            learner.writePacket(qp, true);        }    }}
0
public void submitLearnerRequest(Request si)
{    zks.processObserverRequest(si);}
0
public synchronized long startForwarding(LearnerHandler learnerHandler, long lastSeenZxid)
{    Iterator<QuorumPacket> itr = committedPkts.iterator();    if (itr.hasNext()) {        QuorumPacket packet = itr.next();        if (packet.getZxid() > lastSeenZxid + 1) {                        learnerHandler.shutdown();            return -1;        } else if (packet.getZxid() == lastSeenZxid + 1) {            learnerHandler.queuePacket(packet);        }        long queueHeadZxid = packet.getZxid();        long queueBytesUsed = LearnerHandler.packetSize(packet);        while (itr.hasNext()) {            packet = itr.next();            if (packet.getZxid() <= lastSeenZxid) {                continue;            }            learnerHandler.queuePacket(packet);            queueBytesUsed += LearnerHandler.packetSize(packet);        }            }    activeObservers.add(learnerHandler);    return lastProposedZxid;}
1
public long getQuorumVerifierVersion()
{    return self.getQuorumVerifier().getVersion();}
0
public String getPeerInfo(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
0
public byte[] getQuorumVerifierBytes()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
0
public QuorumAuthServer getQuorumAuthServer()
{    return (self == null) ? null : self.authServer;}
0
 void proposalReceived(QuorumPacket qp)
{    proposedPkts.add(new QuorumPacket(Leader.INFORM, qp.getZxid(), qp.getData(), null));}
0
private synchronized QuorumPacket removeProposedPacket(long zxid)
{    QuorumPacket pkt = proposedPkts.peek();    if (pkt == null || pkt.getZxid() > zxid) {                return null;    }    if (pkt.getZxid() != zxid) {        final String m = String.format("Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d", zxid, pkt.getZxid());                throw new RuntimeException(m);    }    proposedPkts.remove();    return pkt;}
1
private synchronized void cacheCommittedPacket(final QuorumPacket pkt)
{    committedPkts.add(pkt);    pktsSize += LearnerHandler.packetSize(pkt);        for (int i = 0; pktsSize > pktsSizeLimit * 0.8 && i < 5; i++) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }        while (pktsSize > pktsSizeLimit) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }}
0
private synchronized void sendPacket(final QuorumPacket pkt)
{    for (LearnerHandler lh : activeObservers) {        lh.queuePacket(pkt);    }    lastProposedZxid = pkt.getZxid();}
0
 synchronized void proposalCommitted(long zxid)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }    cacheCommittedPacket(pkt);    sendPacket(pkt);}
0
 synchronized void informAndActivate(long zxid, long suggestedLeaderId)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }        QuorumPacket informAndActivateQP = Leader.buildInformAndActivePacket(zxid, suggestedLeaderId, pkt.getData());    cacheCommittedPacket(informAndActivateQP);    sendPacket(informAndActivateQP);}
0
public synchronized void start() throws IOException
{    if (thread != null && thread.isAlive()) {        return;    }    listenerRunning = true;        int backlog = 10;    if (self.shouldUsePortUnification() || self.isSslQuorum()) {        boolean allowInsecureConnection = self.shouldUsePortUnification();        if (self.getQuorumListenOnAllIPs()) {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog);        } else {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog, self.getQuorumAddress().getAddress());        }    } else {        if (self.getQuorumListenOnAllIPs()) {            ss = new ServerSocket(port, backlog);        } else {            ss = new ServerSocket(port, backlog, self.getQuorumAddress().getAddress());        }    }    thread = new Thread(this, "ObserverMaster");    thread.start();    pinger = Executors.newSingleThreadScheduledExecutor();    pinger.scheduleAtFixedRate(ping, self.tickTime / 2, self.tickTime / 2, TimeUnit.MILLISECONDS);}
0
public void run()
{    ServerSocket ss;    synchronized (this) {        ss = this.ss;    }    while (listenerRunning) {        try {            Socket s = ss.accept();                                    s.setSoTimeout(self.tickTime * self.initLimit);            BufferedInputStream is = new BufferedInputStream(s.getInputStream());            LearnerHandler lh = new LearnerHandler(s, is, this);            lh.start();        } catch (Exception e) {            if (listenerRunning) {                            } else {                            }        }    }/*         * we don't need to close ss because we only got here because listenerRunning is         * false and that is set and then ss is closed() in stop()         */}
1
public synchronized void stop()
{    listenerRunning = false;    if (pinger != null) {        pinger.shutdownNow();    }    if (ss != null) {        try {            ss.close();        } catch (IOException e) {            e.printStackTrace();        }    }    for (LearnerHandler lh : activeObservers) {        lh.shutdown();    }}
0
 int getNumActiveObservers()
{    return activeObservers.size();}
0
public Iterable<Map<String, Object>> getActiveObservers()
{    Set<Map<String, Object>> info = new HashSet<>();    for (LearnerHandler lh : activeObservers) {        info.add(lh.getLearnerHandlerInfo());    }    return info;}
0
public void resetObserverConnectionStats()
{    for (LearnerHandler lh : activeObservers) {        lh.resetObserverConnectionStats();    }}
0
 int getPktsSizeLimit()
{    return pktsSizeLimit;}
0
 static void setPktsSizeLimit(final int sizeLimit)
{    pktsSizeLimit = sizeLimit;}
0
public void registerLearnerHandlerBean(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zks.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
0
public void unregisterLearnerHandlerBean(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
0
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getObserver().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getObserver().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getObserver().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    }
1
public void processRequest(Request request)
{    if (!finished) {        Request upgradeRequest = null;        try {            upgradeRequest = zks.checkUpgradeSession(request);        } catch (KeeperException ke) {            if (request.getHdr() != null) {                request.getHdr().setType(OpCode.error);                request.setTxn(new ErrorTxn(ke.code().intValue()));            }            request.setException(ke);                    } catch (IOException ie) {                    }        if (upgradeRequest != null) {            queuedRequests.add(upgradeRequest);        }        queuedRequests.add(request);    }}
1
public void shutdown()
{        finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
1
public Observer getObserver()
{    return self.observer;}
0
public Learner getLearner()
{    return self.observer;}
0
public void commitRequest(Request request)
{    if (syncRequestProcessorEnabled) {                syncProcessor.processRequest(request);    }    commitProcessor.commit(request);}
0
protected void setupRequestProcessors()
{                RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new ObserverRequestProcessor(this, commitProcessor);    ((ObserverRequestProcessor) firstProcessor).start();    /*         * Observer should write to disk, so that the it won't request         * too old txn from the leader which may lead to getting an entire         * snapshot.         *         * However, this may degrade performance as it has to write to disk         * and do periodic snapshot which may double the memory requirements         */    if (syncRequestProcessorEnabled) {        syncProcessor = new SyncRequestProcessor(this, null);        syncProcessor.start();    }}
0
public synchronized void sync()
{    if (pendingSyncs.size() == 0) {                return;    }    Request r = pendingSyncs.remove();    commitProcessor.commit(r);}
1
public String getState()
{    return "observer";}
0
public synchronized void shutdown()
{    if (!canShutdown()) {                return;    }    super.shutdown();    if (syncRequestProcessorEnabled && syncProcessor != null) {        syncProcessor.shutdown();    }}
1
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("observer_master_id", getObserver().getLearnerMasterId());}
0
public InputStream getInputStream() throws IOException
{    if (pushbackInputStream == null) {        return super.getInputStream();    }    return pushbackInputStream;}
0
public void prependToInputStream(byte[] bytes, int offset, int length) throws IOException
{    if (length == 0) {                return;    }    if (pushbackInputStream != null) {        throw new IOException("prependToInputStream() called more than once");    }    PushbackInputStream pushbackInputStream = new PushbackInputStream(getInputStream(), length);    pushbackInputStream.unread(bytes, offset, length);    this.pushbackInputStream = pushbackInputStream;}
0
public void initialize()
{    syncProcessor.start();}
0
public void processRequest(Request request) throws RequestProcessorException
{    if (request instanceof LearnerSyncRequest) {        zks.getLeader().processSync((LearnerSyncRequest) request);    } else {        nextProcessor.processRequest(request);        if (request.getHdr() != null) {                        try {                zks.getLeader().propose(request);            } catch (XidRolloverException e) {                throw new RequestProcessorException(e.getMessage(), e);            }            syncProcessor.processRequest(request);        }    }}
0
public void shutdown()
{        nextProcessor.shutdown();    syncProcessor.shutdown();}
1
public String getName()
{    return name;}
0
public boolean isHidden()
{    return false;}
0
public int getQuorumSize()
{    return peer.getQuorumSize();}
0
public int getSyncLimit()
{    return peer.getSyncLimit();}
0
public int getInitLimit()
{    return peer.getInitLimit();}
0
public void setInitLimit(int initLimit)
{    peer.setInitLimit(initLimit);}
0
public void setSyncLimit(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
0
public boolean isSslQuorum()
{    return peer.isSslQuorum();}
0
public boolean isPortUnification()
{    return peer.shouldUsePortUnification();}
0
public long getObserverElectionDelayMS()
{    return Observer.getObserverElectionDelayMs();}
0
public void setObserverElectionDelayMS(long delayMS)
{    Observer.setObserverElectionDelayMs(delayMS);}
0
public static InitialMessage parse(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException
{    Long sid;    if (protocolVersion != PROTOCOL_VERSION) {        throw new InitialMessageException("Got unrecognized protocol version %s", protocolVersion);    }    sid = din.readLong();    int remaining = din.readInt();    if (remaining <= 0 || remaining > maxBuffer) {        throw new InitialMessageException("Unreasonable buffer length: %s", remaining);    }    byte[] b = new byte[remaining];    int num_read = din.read(b);    if (num_read != remaining) {        throw new InitialMessageException("Read only %s bytes out of %s sent by server %s", num_read, remaining, sid);    }    String addr = new String(b);    String[] host_port;    try {        host_port = ConfigUtils.getHostAndPort(addr);    } catch (ConfigException e) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    if (host_port.length != 2) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    int port;    try {        port = Integer.parseInt(host_port[1]);    } catch (NumberFormatException e) {        throw new InitialMessageException("Bad port number: %s", host_port[1]);    } catch (ArrayIndexOutOfBoundsException e) {        throw new InitialMessageException("No port number in: %s", addr);    }    return new InitialMessage(sid, new InetSocketAddress(host_port[0], port));}
0
private void initializeAuth(final long mySid, final QuorumAuthServer authServer, final QuorumAuthLearner authLearner, final int quorumCnxnThreadsSize, final boolean quorumSaslAuthEnabled)
{    this.authServer = authServer;    this.authLearner = authLearner;    this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;    if (!this.quorumSaslAuthEnabled) {                return;    }        final AtomicInteger threadIndex = new AtomicInteger(1);    SecurityManager s = System.getSecurityManager();    final ThreadGroup group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();    ThreadFactory daemonThFactory = new ThreadFactory() {        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());            return t;        }    };    this.connectionExecutor = new ThreadPoolExecutor(3, quorumCnxnThreadsSize, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), daemonThFactory);    this.connectionExecutor.allowCoreThreadTimeOut(true);}
1
public Thread newThread(Runnable r)
{    Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());    return t;}
0
public void testInitiateConnection(long sid) throws Exception
{        Socket sock = new Socket();    setSockOpts(sock);    sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);    initiateConnection(sock, sid);}
1
public void initiateConnection(final Socket sock, final Long sid)
{    try {        startConnection(sock, sid);    } catch (IOException e) {                closeSocket(sock);        return;    }}
1
public void initiateConnectionAsync(final Socket sock, final Long sid)
{    if (!inprogressConnections.add(sid)) {                                closeSocket(sock);        return;    }    try {        connectionExecutor.execute(new QuorumConnectionReqThread(sock, sid));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {                                inprogressConnections.remove(sid);                closeSocket(sock);    }}
1
public void run()
{    try {        initiateConnection(sock, sid);    } finally {        inprogressConnections.remove(sid);    }}
0
private boolean startConnection(Socket sock, Long sid) throws IOException
{    DataOutputStream dout = null;    DataInputStream din = null;    try {                        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());        dout = new DataOutputStream(buf);                        dout.writeLong(PROTOCOL_VERSION);        dout.writeLong(self.getId());        String addr = formatInetAddr(self.getElectionAddress());        byte[] addr_bytes = addr.getBytes();        dout.writeInt(addr_bytes.length);        dout.write(addr_bytes);        dout.flush();        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));    } catch (IOException e) {                closeSocket(sock);        return false;    }        QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);    if (qps != null) {                authLearner.authenticate(sock, qps.hostname);    }        if (sid > self.getId()) {                closeSocket(sock);        } else {        SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();        return true;    }    return false;}
1
public void receiveConnection(final Socket sock)
{    DataInputStream din = null;    try {        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));        handleConnection(sock, din);    } catch (IOException e) {                closeSocket(sock);    }}
1
public void receiveConnectionAsync(final Socket sock)
{    try {        connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {                closeSocket(sock);    }}
1
public void run()
{    receiveConnection(sock);}
0
private void handleConnection(Socket sock, DataInputStream din) throws IOException
{    Long sid = null, protocolVersion = null;    InetSocketAddress electionAddr = null;    try {        protocolVersion = din.readLong();        if (protocolVersion >= 0) {                        sid = protocolVersion;        } else {            try {                InitialMessage init = InitialMessage.parse(protocolVersion, din);                sid = init.sid;                electionAddr = init.electionAddr;            } catch (InitialMessage.InitialMessageException ex) {                                closeSocket(sock);                return;            }        }        if (sid == QuorumPeer.OBSERVER_ID) {            /*                 * Choose identifier at random. We need a value to identify                 * the connection.                 */            sid = observerCounter.getAndDecrement();                    }    } catch (IOException e) {                closeSocket(sock);        return;    }        authServer.authenticate(sock, din);        if (sid < self.getId()) {        /*             * This replica might still believe that the connection to sid is             * up, so we have to shut down the workers before trying to open a             * new connection.             */        SendWorker sw = senderWorkerMap.get(sid);        if (sw != null) {            sw.finish();        }        /*             * Now we start a new connection             */                closeSocket(sock);        if (electionAddr != null) {            connectOne(sid, electionAddr);        } else {            connectOne(sid);        }    } else {                SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();    }}
1
public void toSend(Long sid, ByteBuffer b)
{    /*         * If sending message to myself, then simply enqueue it (loopback).         */    if (this.mySid == sid) {        b.position(0);        addToRecvQueue(new Message(b.duplicate(), sid));    /*             * Otherwise send to the corresponding thread to send.             */    } else {        /*             * Start a new connection if doesn't have one already.             */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.computeIfAbsent(sid, serverId -> new ArrayBlockingQueue<>(SEND_CAPACITY));        addToSendQueue(bq, b);        connectOne(sid);    }}
0
 synchronized boolean connectOne(long sid, InetSocketAddress electionAddr)
{    if (senderWorkerMap.get(sid) != null) {                return true;    }    Socket sock = null;    try {                if (self.isSslQuorum()) {            sock = self.getX509Util().createSSLSocket();        } else {            sock = new Socket();        }        setSockOpts(sock);        sock.connect(electionAddr, cnxTO);        if (sock instanceof SSLSocket) {            SSLSocket sslSock = (SSLSocket) sock;            sslSock.startHandshake();                    }                        if (quorumSaslAuthEnabled) {            initiateConnectionAsync(sock, sid);        } else {            initiateConnection(sock, sid);        }        return true;    } catch (UnresolvedAddressException e) {                                                closeSocket(sock);        throw e;    } catch (X509Exception e) {                closeSocket(sock);        return false;    } catch (IOException e) {                closeSocket(sock);        return false;    }}
1
 synchronized void connectOne(long sid)
{    if (senderWorkerMap.get(sid) != null) {                return;    }    synchronized (self.QV_LOCK) {        boolean knownId = false;                        self.recreateSocketAddresses(sid);        Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();        if (lastCommittedView.containsKey(sid)) {            knownId = true;            if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {                return;            }        }        if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {            knownId = true;            if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {                return;            }        }        if (!knownId) {                    }    }}
1
public void connectAll()
{    long sid;    for (Enumeration<Long> en = queueSendMap.keys(); en.hasMoreElements(); ) {        sid = en.nextElement();        connectOne(sid);    }}
0
 boolean haveDelivered()
{    for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {                if (queue.size() == 0) {            return true;        }    }    return false;}
1
public void halt()
{    shutdown = true;        listener.halt();        try {        listener.join();    } catch (InterruptedException ex) {            }    softHalt();        if (connectionExecutor != null) {        connectionExecutor.shutdown();    }    inprogressConnections.clear();    resetConnectionThreadCount();}
1
public void softHalt()
{    for (SendWorker sw : senderWorkerMap.values()) {                sw.finish();    }}
1
private void setSockOpts(Socket sock) throws SocketException
{    sock.setTcpNoDelay(true);    sock.setKeepAlive(tcpKeepAlive);    sock.setSoTimeout(this.socketTimeout);}
0
private void closeSocket(Socket sock)
{    if (sock == null) {        return;    }    try {        sock.close();    } catch (IOException ie) {            }}
1
public long getThreadCount()
{    return threadCnt.get();}
0
public long getConnectionThreadCount()
{    return connectionThreadCnt.get();}
0
private void resetConnectionThreadCount()
{    connectionThreadCnt.set(0);}
0
 void setSocketBindErrorHandler(Runnable errorHandler)
{    this.socketBindErrorHandler = errorHandler;}
0
public void run()
{    int numRetries = 0;    InetSocketAddress addr;    Socket client = null;    Exception exitException = null;    while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {        try {            if (self.shouldUsePortUnification()) {                                ss = new UnifiedServerSocket(self.getX509Util(), true);            } else if (self.isSslQuorum()) {                                ss = new UnifiedServerSocket(self.getX509Util(), false);            } else {                ss = new ServerSocket();            }            ss.setReuseAddress(true);            if (self.getQuorumListenOnAllIPs()) {                int port = self.getElectionAddress().getPort();                addr = new InetSocketAddress(port);            } else {                                                self.recreateSocketAddresses(self.getId());                addr = self.getElectionAddress();            }                        setName(addr.toString());            ss.bind(addr);            while (!shutdown) {                try {                    client = ss.accept();                    setSockOpts(client);                                                            if (quorumSaslAuthEnabled) {                        receiveConnectionAsync(client);                    } else {                        receiveConnection(client);                    }                    numRetries = 0;                } catch (SocketTimeoutException e) {                                    }            }        } catch (IOException e) {            if (shutdown) {                break;            }                        exitException = e;            numRetries++;            try {                ss.close();                Thread.sleep(1000);            } catch (IOException ie) {                            } catch (InterruptedException ie) {                            }            closeSocket(client);        }    }        if (!shutdown) {                if (exitException instanceof SocketException) {                                                socketBindErrorHandler.run();        }    } else if (ss != null) {                try {            ss.close();        } catch (IOException ie) {                                }    }}
1
 void halt()
{    try {                if (ss != null) {                        ss.close();        }    } catch (IOException e) {            }}
1
 synchronized void setRecv(RecvWorker recvWorker)
{    this.recvWorker = recvWorker;}
0
 synchronized RecvWorker getRecvWorker()
{    return recvWorker;}
0
 synchronized boolean finish()
{        if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    closeSocket(sock);    this.interrupt();    if (recvWorker != null) {        recvWorker.finish();    }        senderWorkerMap.remove(sid, this);    threadCnt.decrementAndGet();    return running;}
1
 synchronized void send(ByteBuffer b) throws IOException
{    byte[] msgBytes = new byte[b.capacity()];    try {        b.position(0);        b.get(msgBytes);    } catch (BufferUnderflowException be) {                return;    }    dout.writeInt(b.capacity());    dout.write(b.array());    dout.flush();}
1
public void run()
{    threadCnt.incrementAndGet();    try {        /**         * If there is nothing in the queue to send, then we         * send the lastMessage to ensure that the last message         * was received by the peer. The message could be dropped         * in case self or the peer shutdown their connection         * (and exit the thread) prior to reading/processing         * the last message. Duplicate messages are handled correctly         * by the peer.         *         * If the send queue is non-empty, then we have a recent         * message than that stored in lastMessage. To avoid sending         * stale message, we should send the message in the send queue.         */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);        if (bq == null || isSendQueueEmpty(bq)) {            ByteBuffer b = lastMessageSent.get(sid);            if (b != null) {                                send(b);            }        }    } catch (IOException e) {                this.finish();    }    try {        while (running && !shutdown && sock != null) {            ByteBuffer b = null;            try {                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                if (bq != null) {                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);                } else {                                        break;                }                if (b != null) {                    lastMessageSent.put(sid, b);                    send(b);                }            } catch (InterruptedException e) {                            }        }    } catch (Exception e) {            }    this.finish();    }
1
 synchronized boolean finish()
{    if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    this.interrupt();    threadCnt.decrementAndGet();    return running;}
0
public void run()
{    threadCnt.incrementAndGet();    try {        while (running && !shutdown && sock != null) {            /**             * Reads the first int to determine the length of the             * message             */            int length = din.readInt();            if (length <= 0 || length > PACKETMAXSIZE) {                throw new IOException("Received packet with invalid packet: " + length);            }            /**             * Allocates a new ByteBuffer to receive the message             */            final byte[] msgArray = new byte[length];            din.readFully(msgArray, 0, length);            addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));        }    } catch (Exception e) {            } finally {                sw.finish();        closeSocket(sock);    }}
1
private void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue, ByteBuffer buffer)
{    if (queue.remainingCapacity() == 0) {        try {            queue.remove();        } catch (NoSuchElementException ne) {                                }    }    try {        queue.add(buffer);    } catch (IllegalStateException ie) {                    }}
1
private boolean isSendQueueEmpty(ArrayBlockingQueue<ByteBuffer> queue)
{    return queue.isEmpty();}
0
private ByteBuffer pollSendQueue(ArrayBlockingQueue<ByteBuffer> queue, long timeout, TimeUnit unit) throws InterruptedException
{    return queue.poll(timeout, unit);}
0
public void addToRecvQueue(Message msg)
{    synchronized (recvQLock) {        if (recvQueue.remainingCapacity() == 0) {            try {                recvQueue.remove();            } catch (NoSuchElementException ne) {                                            }        }        try {            recvQueue.add(msg);        } catch (IllegalStateException ie) {                                }    }}
1
public Message pollRecvQueue(long timeout, TimeUnit unit) throws InterruptedException
{    return recvQueue.poll(timeout, unit);}
0
public boolean connectedToPeer(long peerSid)
{    return senderWorkerMap.get(peerSid) != null;}
0
public int getObserverMasterPort()
{    return observerMasterPort;}
0
public void setObserverMasterPort(int observerMasterPort)
{    this.observerMasterPort = observerMasterPort;}
0
public long getId()
{    return id;}
0
public void recreateSocketAddresses()
{    if (this.addr == null) {                return;    }    if (this.electionAddr == null) {                return;    }    String host = this.addr.getHostString();    InetAddress address = null;    try {        address = InetAddress.getByName(host);    } catch (UnknownHostException ex) {                return;    }        int port = this.addr.getPort();    this.addr = new InetSocketAddress(address, port);    port = this.electionAddr.getPort();    this.electionAddr = new InetSocketAddress(address, port);}
1
private void setType(String s) throws ConfigException
{    if (s.toLowerCase().equals("observer")) {        type = LearnerType.OBSERVER;    } else if (s.toLowerCase().equals("participant")) {        type = LearnerType.PARTICIPANT;    } else {        throw new ConfigException("Unrecognised peertype: " + s);    }}
0
private void setMyAddrs()
{    this.myAddrs = new ArrayList<InetSocketAddress>();    this.myAddrs.add(this.addr);    this.myAddrs.add(this.clientAddr);    this.myAddrs.add(this.electionAddr);    this.myAddrs = excludedSpecialAddresses(this.myAddrs);}
0
public static String delimitedHostString(InetSocketAddress addr)
{    String host = addr.getHostString();    if (host.contains(":")) {        return "[" + host + "]";    } else {        return host;    }}
0
public String toString()
{    StringWriter sw = new StringWriter();        if (addr != null) {        sw.append(delimitedHostString(addr));        sw.append(":");        sw.append(String.valueOf(addr.getPort()));    }    if (electionAddr != null) {        sw.append(":");        sw.append(String.valueOf(electionAddr.getPort()));    }    if (type == LearnerType.OBSERVER) {        sw.append(":observer");    } else if (type == LearnerType.PARTICIPANT) {        sw.append(":participant");    }    if (clientAddr != null && !isClientAddrFromStatic) {        sw.append(";");        sw.append(delimitedHostString(clientAddr));        sw.append(":");        sw.append(String.valueOf(clientAddr.getPort()));    }    return sw.toString();}
0
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
0
private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2)
{    return (addr1 != null || addr2 == null) && (addr1 == null || addr2 != null) && (addr1 == null || addr2 == null || addr1.equals(addr2));}
0
public boolean equals(Object o)
{    if (!(o instanceof QuorumServer)) {        return false;    }    QuorumServer qs = (QuorumServer) o;    if ((qs.id != id) || (qs.type != type)) {        return false;    }    if (!checkAddressesEqual(addr, qs.addr)) {        return false;    }    if (!checkAddressesEqual(electionAddr, qs.electionAddr)) {        return false;    }    return checkAddressesEqual(clientAddr, qs.clientAddr);}
0
public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException
{    List<InetSocketAddress> otherAddrs = new ArrayList<InetSocketAddress>();    otherAddrs.add(s.addr);    otherAddrs.add(s.clientAddr);    otherAddrs.add(s.electionAddr);    otherAddrs = excludedSpecialAddresses(otherAddrs);    for (InetSocketAddress my : this.myAddrs) {        for (InetSocketAddress other : otherAddrs) {            if (my.equals(other)) {                String error = String.format("%s of server.%d conflicts %s of server.%d", my, this.id, other, s.id);                throw new BadArgumentsException(error);            }        }    }}
0
private List<InetSocketAddress> excludedSpecialAddresses(List<InetSocketAddress> addrs)
{    List<InetSocketAddress> included = new ArrayList<>();    for (InetSocketAddress addr : addrs) {        if (addr == null) {            continue;        }        InetAddress inetaddr = addr.getAddress();        if (        inetaddr == null || inetaddr.isAnyLocalAddress() || inetaddr.isLoopbackAddress()) {                        continue;        }        included.add(addr);    }    return included;}
0
public LearnerType getLearnerType()
{    return learnerType;}
0
public void setLearnerType(LearnerType p)
{    learnerType = p;}
0
protected synchronized void setConfigFileName(String s)
{    configFilename = s;}
0
public int getQuorumSize()
{    return getVotingView().size();}
0
public void setJvmPauseMonitor(JvmPauseMonitor jvmPauseMonitor)
{    this.jvmPauseMonitor = jvmPauseMonitor;}
0
public long getId()
{    return myid;}
0
 void setId(long id)
{    this.myid = id;}
0
public boolean isSslQuorum()
{    return sslQuorum;}
0
public boolean shouldUsePortUnification()
{    return shouldUsePortUnification;}
0
 QuorumX509Util getX509Util()
{    return x509Util;}
0
public synchronized Vote getCurrentVote()
{    return currentVote;}
0
public synchronized void setCurrentVote(Vote v)
{    currentVote = v;}
0
public void run()
{    try {        byte[] b = new byte[36];        ByteBuffer responseBuffer = ByteBuffer.wrap(b);        DatagramPacket packet = new DatagramPacket(b, b.length);        while (running) {            udpSocket.receive(packet);            if (packet.getLength() != 4) {                            } else {                responseBuffer.clear();                                responseBuffer.getInt();                responseBuffer.putLong(myid);                Vote current = getCurrentVote();                switch(getPeerState()) {                    case LOOKING:                        responseBuffer.putLong(current.getId());                        responseBuffer.putLong(current.getZxid());                        break;                    case LEADING:                        responseBuffer.putLong(myid);                        try {                            long proposed;                            synchronized (leader) {                                proposed = leader.lastProposed;                            }                            responseBuffer.putLong(proposed);                        } catch (NullPointerException npe) {                                                                        }                        break;                    case FOLLOWING:                        responseBuffer.putLong(current.getId());                        try {                            responseBuffer.putLong(follower.getZxid());                        } catch (NullPointerException npe) {                                                                        }                        break;                    case OBSERVING:                                                break;                }                packet.setData(b);                udpSocket.send(packet);            }            packet.setLength(b.length);        }    } catch (RuntimeException e) {            } catch (IOException e) {            } finally {            }}
1
public synchronized void setPeerState(ServerState newState)
{    state = newState;    if (newState == ServerState.LOOKING) {        setLeaderAddressAndId(null, -1);        setZabState(ZabState.ELECTION);    } else {            }}
1
public void setZabState(ZabState zabState)
{    this.zabState.set(zabState);    }
1
public void setSyncMode(SyncMode syncMode)
{    this.syncMode.set(syncMode);    }
1
public ZabState getZabState()
{    return zabState.get();}
0
public SyncMode getSyncMode()
{    return syncMode.get();}
0
public void setLeaderAddressAndId(InetSocketAddress addr, long newId)
{    if (addr != null) {        leaderAddress.set(addr.getHostString());    } else {        leaderAddress.set(null);    }    leaderId.set(newId);}
0
public String getLeaderAddress()
{    return leaderAddress.get();}
0
public long getLeaderId()
{    return leaderId.get();}
0
public String getDetailedPeerState()
{    final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());    final ZabState zabState = getZabState();    if (!ZabState.ELECTION.equals(zabState)) {        sb.append(" - ").append(zabState.toString().toLowerCase());    }    final SyncMode syncMode = getSyncMode();    if (!SyncMode.NONE.equals(syncMode)) {        sb.append(" - ").append(syncMode.toString().toLowerCase());    }    return sb.toString();}
0
public synchronized void reconfigFlagSet()
{    reconfigFlag = true;}
0
public synchronized void reconfigFlagClear()
{    reconfigFlag = false;}
0
public synchronized boolean isReconfigStateChange()
{    return reconfigFlag;}
0
public synchronized ServerState getPeerState()
{    return state;}
0
public void recreateSocketAddresses(long id)
{    QuorumVerifier qv = getQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();            if (id == getId()) {                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);            }        }    }    qv = getLastSeenQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();        }    }}
0
private AddressTuple getAddrs()
{    AddressTuple addrs = myAddrs.get();    if (addrs != null) {        return addrs;    }    try {        synchronized (QV_LOCK) {            addrs = myAddrs.get();            while (addrs == null) {                QV_LOCK.wait();                addrs = myAddrs.get();            }            return addrs;        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw new RuntimeException(e);    }}
0
public InetSocketAddress getQuorumAddress()
{    return getAddrs().quorumAddr;}
0
public InetSocketAddress getElectionAddress()
{    return getAddrs().electionAddr;}
0
public InetSocketAddress getClientAddress()
{    final AddressTuple addrs = myAddrs.get();    return (addrs == null) ? null : addrs.clientAddr;}
0
private void setAddrs(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr)
{    synchronized (QV_LOCK) {        myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));        QV_LOCK.notifyAll();    }}
0
public static QuorumPeer testingQuorumPeer() throws SaslException
{    return new QuorumPeer();}
0
 QuorumX509Util createX509Util()
{    return new QuorumX509Util();}
0
public void initialize() throws SaslException
{        if (isQuorumSaslAuthEnabled()) {        Set<String> authzHosts = new HashSet<String>();        for (QuorumServer qs : getView().values()) {            authzHosts.add(qs.hostname);        }        authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);        authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);    } else {        authServer = new NullQuorumAuthServer();        authLearner = new NullQuorumAuthLearner();    }}
0
 QuorumStats quorumStats()
{    return quorumStats;}
0
public synchronized void start()
{    if (!getView().containsKey(myid)) {        throw new RuntimeException("My id " + myid + " not in the peer list");    }    loadDataBase();    startServerCnxnFactory();    try {        adminServer.start();    } catch (AdminServerException e) {                System.out.println(e);    }    startLeaderElection();    startJvmPauseMonitor();    super.start();}
1
private void loadDataBase()
{    try {        zkDb.loadDataBase();                long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);        try {            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                currentEpoch = epochOfZxid;                        writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);        }        if (epochOfZxid > currentEpoch) {            throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + ", is older than the last zxid, " + lastProcessedZxid);        }        try {            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                acceptedEpoch = epochOfZxid;                        writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);        }        if (acceptedEpoch < currentEpoch) {            throw new IOException("The accepted epoch, " + ZxidUtils.zxidToString(acceptedEpoch) + " is less than the current epoch, " + ZxidUtils.zxidToString(currentEpoch));        }    } catch (IOException ie) {                throw new RuntimeException("Unable to run quorum server ", ie);    }}
1
public synchronized void stopLeaderElection()
{    responder.running = false;    responder.interrupt();}
0
public synchronized void startLeaderElection()
{    try {        if (getPeerState() == ServerState.LOOKING) {            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());        }    } catch (IOException e) {        RuntimeException re = new RuntimeException(e.getMessage());        re.setStackTrace(e.getStackTrace());        throw re;    }    this.electionAlg = createElectionAlgorithm(electionType);}
0
private void startJvmPauseMonitor()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
0
protected static int countParticipants(Map<Long, QuorumServer> peers)
{    int count = 0;    for (QuorumServer q : peers.values()) {        if (q.type == LearnerType.PARTICIPANT) {            count++;        }    }    return count;}
0
private static InetSocketAddress getClientAddress(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort) throws IOException
{    QuorumServer quorumServer = quorumPeers.get(myid);    if (null == quorumServer) {        throw new IOException("No QuorumServer correspoding to myid " + myid);    }    if (null == quorumServer.clientAddr) {        return new InetSocketAddress(clientPort);    }    if (quorumServer.clientAddr.getPort() != clientPort) {        throw new IOException("QuorumServer port " + quorumServer.clientAddr.getPort() + " does not match with given port " + clientPort);    }    return quorumServer.clientAddr;}
0
public long getLastLoggedZxid()
{    if (!zkDb.isInitialized()) {        loadDataBase();    }    return zkDb.getDataTreeLastProcessedZxid();}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));}
0
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));}
0
protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException
{    return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));}
0
protected Election createElectionAlgorithm(int electionAlgorithm)
{    Election le = null;        switch(electionAlgorithm) {        case 1:            le = new AuthFastLeaderElection(this);            break;        case 2:            le = new AuthFastLeaderElection(this, true);            break;        case 3:            QuorumCnxManager qcm = createCnxnManager();            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);            if (oldQcm != null) {                                oldQcm.halt();            }            QuorumCnxManager.Listener listener = qcm.listener;            if (listener != null) {                listener.start();                FastLeaderElection fle = new FastLeaderElection(this, qcm);                fle.start();                le = fle;            } else {                            }            break;        default:            assert false;    }    return le;}
1
protected Election makeLEStrategy()
{        return electionAlg;}
1
protected synchronized void setLeader(Leader newLeader)
{    leader = newLeader;}
0
protected synchronized void setFollower(Follower newFollower)
{    follower = newFollower;}
0
protected synchronized void setObserver(Observer newObserver)
{    observer = newObserver;}
0
public synchronized ZooKeeperServer getActiveServer()
{    if (leader != null) {        return leader.zk;    } else if (follower != null) {        return follower.zk;    } else if (observer != null) {        return observer.zk;    }    return null;}
0
public void run()
{    updateThreadName();        try {        jmxQuorumBean = new QuorumBean(this);        MBeanRegistry.getInstance().register(jmxQuorumBean, null);        for (QuorumServer s : getView().values()) {            ZKMBeanInfo p;            if (getId() == s.id) {                p = jmxLocalPeerBean = new LocalPeerBean(this);                try {                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);                } catch (Exception e) {                                        jmxLocalPeerBean = null;                }            } else {                RemotePeerBean rBean = new RemotePeerBean(this, s);                try {                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);                    jmxRemotePeerBean.put(s.id, rBean);                } catch (Exception e) {                                    }            }        }    } catch (Exception e) {                jmxQuorumBean = null;    }    try {        /*             * Main loop             */        while (running) {            switch(getPeerState()) {                case LOOKING:                                        ServerMetrics.getMetrics().LOOKING_COUNT.add(1);                    if (Boolean.getBoolean("readonlymode.enabled")) {                                                                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);                                                                                                                                                                        Thread roZkMgr = new Thread() {                            public void run() {                                try {                                                                        sleep(Math.max(2000, tickTime));                                    if (ServerState.LOOKING.equals(getPeerState())) {                                        roZk.startup();                                    }                                } catch (InterruptedException e) {                                                                    } catch (Exception e) {                                                                    }                            }                        };                        try {                            roZkMgr.start();                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                                                        setPeerState(ServerState.LOOKING);                        } finally {                                                                                    roZkMgr.interrupt();                            roZk.shutdown();                        }                    } else {                        try {                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                                                        setPeerState(ServerState.LOOKING);                        }                    }                    break;                case OBSERVING:                    try {                                                setObserver(makeObserver(logFactory));                        observer.observeLeader();                    } catch (Exception e) {                                            } finally {                        observer.shutdown();                        setObserver(null);                        updateServerState();                                                if (isRunning()) {                            Observer.waitForObserverElectionDelay();                        }                    }                    break;                case FOLLOWING:                    try {                                                setFollower(makeFollower(logFactory));                        follower.followLeader();                    } catch (Exception e) {                                            } finally {                        follower.shutdown();                        setFollower(null);                        updateServerState();                    }                    break;                case LEADING:                                        try {                        setLeader(makeLeader(logFactory));                        leader.lead();                        setLeader(null);                    } catch (Exception e) {                                            } finally {                        if (leader != null) {                            leader.shutdown("Forcing shutdown");                            setLeader(null);                        }                        updateServerState();                    }                    break;            }        }    } finally {                MBeanRegistry instance = MBeanRegistry.getInstance();        instance.unregister(jmxQuorumBean);        instance.unregister(jmxLocalPeerBean);        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {            instance.unregister(remotePeerBean);        }        jmxQuorumBean = null;        jmxLocalPeerBean = null;        jmxRemotePeerBean = null;    }}
1
public void run()
{    try {                sleep(Math.max(2000, tickTime));        if (ServerState.LOOKING.equals(getPeerState())) {            roZk.startup();        }    } catch (InterruptedException e) {            } catch (Exception e) {            }}
1
private synchronized void updateServerState()
{    if (!reconfigFlag) {        setPeerState(ServerState.LOOKING);                return;    }    if (getId() == getCurrentVote().getId()) {        setPeerState(ServerState.LEADING);            } else if (getLearnerType() == LearnerType.PARTICIPANT) {        setPeerState(ServerState.FOLLOWING);            } else if (getLearnerType() == LearnerType.OBSERVER) {        setPeerState(ServerState.OBSERVING);            } else {                setPeerState(ServerState.LOOKING);            }    reconfigFlag = false;}
1
public void shutdown()
{    running = false;    x509Util.close();    if (leader != null) {        leader.shutdown("quorum Peer shutdown");    }    if (follower != null) {        follower.shutdown();    }    shutdownServerCnxnFactory();    if (udpSocket != null) {        udpSocket.close();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    try {        adminServer.shutdown();    } catch (AdminServerException e) {            }    if (getElectionAlg() != null) {        this.interrupt();        getElectionAlg().shutdown();    }    try {        zkDb.close();    } catch (IOException ie) {            }}
1
public Map<Long, QuorumPeer.QuorumServer> getView()
{    return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());}
0
public Map<Long, QuorumPeer.QuorumServer> getVotingView()
{    return getQuorumVerifier().getVotingMembers();}
0
public Map<Long, QuorumPeer.QuorumServer> getObservingView()
{    return getQuorumVerifier().getObservingMembers();}
0
public synchronized Set<Long> getCurrentAndNextConfigVoters()
{    Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());    if (getLastSeenQuorumVerifier() != null) {        voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());    }    return voterIds;}
0
public boolean viewContains(Long sid)
{    return this.getView().containsKey(sid);}
0
public String[] getQuorumPeers()
{    List<String> l = new ArrayList<String>();    synchronized (this) {        if (leader != null) {            for (LearnerHandler fh : leader.getLearners()) {                if (fh.getSocket() != null) {                    String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());                    if (leader.isLearnerSynced(fh)) {                        s += "*";                    }                    l.add(s);                }            }        } else if (follower != null) {            l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));        }    }    return l.toArray(new String[0]);}
0
public String getServerState()
{    switch(getPeerState()) {        case LOOKING:            return QuorumStats.Provider.LOOKING_STATE;        case LEADING:            return QuorumStats.Provider.LEADING_STATE;        case FOLLOWING:            return QuorumStats.Provider.FOLLOWING_STATE;        case OBSERVING:            return QuorumStats.Provider.OBSERVING_STATE;    }    return QuorumStats.Provider.UNKNOWN_STATE;}
0
public void setMyid(long myid)
{    this.myid = myid;}
0
public void setInitialConfig(String initialConfig)
{    this.initialConfig = initialConfig;}
0
public String getInitialConfig()
{    return initialConfig;}
0
public int getTickTime()
{    return tickTime;}
0
public void setTickTime(int tickTime)
{        this.tickTime = tickTime;}
1
public int getMaxClientCnxnsPerHost()
{    if (cnxnFactory != null) {        return cnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureCnxnFactory != null) {        return secureCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
0
public boolean areLocalSessionsEnabled()
{    return localSessionsEnabled;}
0
public void enableLocalSessions(boolean flag)
{        localSessionsEnabled = flag;}
1
public boolean isLocalSessionsUpgradingEnabled()
{    return localSessionsUpgradingEnabled;}
0
public void enableLocalSessionsUpgrading(boolean flag)
{        localSessionsUpgradingEnabled = flag;}
1
public int getMinSessionTimeout()
{    return minSessionTimeout;}
0
public void setMinSessionTimeout(int min)
{        this.minSessionTimeout = min;}
1
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
0
public void setMaxSessionTimeout(int max)
{        this.maxSessionTimeout = max;}
1
public int getClientPortListenBacklog()
{    return this.clientPortListenBacklog;}
0
public void setClientPortListenBacklog(int backlog)
{    this.clientPortListenBacklog = backlog;}
0
public int getInitLimit()
{    return initLimit;}
0
public void setInitLimit(int initLimit)
{        this.initLimit = initLimit;}
1
public int getTick()
{    return tick.get();}
0
public QuorumVerifier configFromString(String s) throws IOException, ConfigException
{    Properties props = new Properties();    props.load(new StringReader(s));    return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);}
0
public QuorumVerifier getQuorumVerifier()
{    synchronized (QV_LOCK) {        return quorumVerifier;    }}
0
public QuorumVerifier getLastSeenQuorumVerifier()
{    synchronized (QV_LOCK) {        return lastSeenQuorumVerifier;    }}
0
public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW)
{    if (qvOLD == null || !qvOLD.equals(qvNEW)) {                getElectionAlg().shutdown();        shuttingDownLE = false;        startLeaderElection();    }}
1
public String getNextDynamicConfigFilename()
{    if (configFilename == null) {                return null;    }    return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;}
1
private void connectNewPeers(QuorumCnxManager qcm)
{    if (quorumVerifier != null && lastSeenQuorumVerifier != null) {        Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();        for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {            if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {                qcm.connectOne(e.getKey());            }        }    }}
0
public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk)
{                                QuorumCnxManager qcm = qcmRef.get();    Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;    synchronized (outerLockObject) {        synchronized (QV_LOCK) {            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {                            }                        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {                return;            }            lastSeenQuorumVerifier = qv;            if (qcm != null) {                connectNewPeers(qcm);            }            if (writeToDisk) {                try {                    String fileName = getNextDynamicConfigFilename();                    if (fileName != null) {                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);                    }                } catch (IOException e) {                                    }            }        }    }}
1
public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk)
{    synchronized (QV_LOCK) {        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {                                                return quorumVerifier;        }        QuorumVerifier prevQV = quorumVerifier;        quorumVerifier = qv;        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {            lastSeenQuorumVerifier = qv;        }        if (writeToDisk) {                        if (configFilename != null) {                try {                    String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);                    QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());                } catch (IOException e) {                                    }            } else {                            }        }        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {            QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());        }        QuorumServer qs = qv.getAllMembers().get(getId());        if (qs != null) {            setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);        }        updateObserverMasterList();        return prevQV;    }}
1
private String makeDynamicConfigFilename(long version)
{    return configFilename + ".dynamic." + Long.toHexString(version);}
0
private boolean needEraseClientInfoFromStaticConfig()
{    QuorumServer server = quorumVerifier.getAllMembers().get(getId());    return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);}
0
public Election getElectionAlg()
{    return electionAlg;}
0
public int getSyncLimit()
{    return syncLimit;}
0
public void setSyncLimit(int syncLimit)
{        this.syncLimit = syncLimit;}
1
public int getConnectToLearnerMasterLimit()
{    return connectToLearnerMasterLimit;}
0
public void setConnectToLearnerMasterLimit(int connectToLearnerMasterLimit)
{        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;}
1
public boolean getSyncEnabled()
{    if (System.getProperty(SYNC_ENABLED) != null) {                return Boolean.getBoolean(SYNC_ENABLED);    } else {        return syncEnabled;    }}
1
public void setSyncEnabled(boolean syncEnabled)
{    this.syncEnabled = syncEnabled;}
0
public int getElectionType()
{    return electionType;}
0
public void setElectionType(int electionType)
{    this.electionType = electionType;}
0
public boolean getQuorumListenOnAllIPs()
{    return quorumListenOnAllIPs;}
0
public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs)
{    this.quorumListenOnAllIPs = quorumListenOnAllIPs;}
0
public void setCnxnFactory(ServerCnxnFactory cnxnFactory)
{    this.cnxnFactory = cnxnFactory;}
0
public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory)
{    this.secureCnxnFactory = secureCnxnFactory;}
0
public void setSslQuorum(boolean sslQuorum)
{    if (sslQuorum) {            } else {            }    this.sslQuorum = sslQuorum;}
1
public void setUsePortUnification(boolean shouldUsePortUnification)
{        this.shouldUsePortUnification = shouldUsePortUnification;}
1
private void startServerCnxnFactory()
{    if (cnxnFactory != null) {        cnxnFactory.start();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.start();    }}
0
private void shutdownServerCnxnFactory()
{    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }}
0
public void setZooKeeperServer(ZooKeeperServer zks)
{    if (cnxnFactory != null) {        cnxnFactory.setZooKeeperServer(zks);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.setZooKeeperServer(zks);    }}
0
public void closeAllConnections()
{    if (cnxnFactory != null) {        cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }}
0
public int getClientPort()
{    if (cnxnFactory != null) {        return cnxnFactory.getLocalPort();    }    return -1;}
0
public void setTxnFactory(FileTxnSnapLog factory)
{    this.logFactory = factory;}
0
public FileTxnSnapLog getTxnFactory()
{    return this.logFactory;}
0
public void setZKDatabase(ZKDatabase database)
{    this.zkDb = database;}
0
protected ZKDatabase getZkDb()
{    return zkDb;}
0
public synchronized void initConfigInZKDatabase()
{    if (zkDb != null) {        zkDb.initConfigInZKDatabase(getQuorumVerifier());    }}
0
public boolean isRunning()
{    return running;}
0
public QuorumCnxManager getQuorumCnxManager()
{    return qcmRef.get();}
0
private long readLongFromFile(String name) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    BufferedReader br = new BufferedReader(new FileReader(file));    String line = "";    try {        line = br.readLine();        return Long.parseLong(line);    } catch (NumberFormatException e) {        throw new IOException("Found " + line + " in " + file);    } finally {        br.close();    }}
0
private void writeLongToFile(String name, final long value) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    new AtomicFileWritingIdiom(file, new WriterStatement() {        @Override        public void write(Writer bw) throws IOException {            bw.write(Long.toString(value));        }    });}
0
public void write(Writer bw) throws IOException
{    bw.write(Long.toString(value));}
0
public long getCurrentEpoch() throws IOException
{    if (currentEpoch == -1) {        currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);    }    return currentEpoch;}
0
public long getAcceptedEpoch() throws IOException
{    if (acceptedEpoch == -1) {        acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);    }    return acceptedEpoch;}
0
public void setCurrentEpoch(long e) throws IOException
{    currentEpoch = e;    writeLongToFile(CURRENT_EPOCH_FILENAME, e);}
0
public void setAcceptedEpoch(long e) throws IOException
{    acceptedEpoch = e;    writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);}
0
public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE)
{    if (!QuorumPeerConfig.isReconfigEnabled()) {                return false;    }    InetSocketAddress oldClientAddr = getClientAddress();            QuorumVerifier prevQV = setQuorumVerifier(qv, true);                                    initConfigInZKDatabase();    if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {        Map<Long, QuorumServer> newMembers = qv.getAllMembers();        updateRemotePeerMXBeans(newMembers);        if (restartLE) {            restartLeaderElection(prevQV, qv);        }        QuorumServer myNewQS = newMembers.get(getId());        if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {            cnxnFactory.reconfigure(myNewQS.clientAddr);            updateThreadName();        }        boolean roleChange = updateLearnerType(qv);        boolean leaderChange = false;        if (suggestedLeaderId != null) {                        leaderChange = updateVote(suggestedLeaderId, zxid);        } else {            long currentLeaderId = getCurrentVote().getId();            QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);            QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);            leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));                                    reconfigFlagClear();        }        return roleChange || leaderChange;    }    return false;}
1
private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers)
{    Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());    existingMembers.retainAll(jmxRemotePeerBean.keySet());    for (Long id : existingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.get(id);        rBean.setQuorumServer(newMembers.get(id));    }    Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());    joiningMembers.removeAll(jmxRemotePeerBean.keySet());        joiningMembers.remove(getId());    for (Long id : joiningMembers) {        QuorumServer qs = newMembers.get(id);        RemotePeerBean rBean = new RemotePeerBean(this, qs);        try {            MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);            jmxRemotePeerBean.put(qs.id, rBean);        } catch (Exception e) {                    }    }    Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());    leavingMembers.removeAll(newMembers.keySet());    for (Long id : leavingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.remove(id);        try {            MBeanRegistry.getInstance().unregister(rBean);        } catch (Exception e) {                    }    }}
1
private void updateObserverMasterList()
{    if (observerMasterPort <= 0) {                return;    }    observerMasters.clear();    StringBuilder sb = new StringBuilder();    for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {        InetSocketAddress addr = new InetSocketAddress(server.addr.getAddress(), observerMasterPort);        observerMasters.add(new QuorumServer(server.id, addr));        sb.append(addr).append(",");    }        Collections.shuffle(observerMasters);            nextObserverMaster = 0;}
1
private boolean useObserverMasters()
{    return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;}
0
private QuorumServer nextObserverMaster()
{    if (nextObserverMaster >= observerMasters.size()) {        nextObserverMaster = 0;                if (isRunning()) {            Observer.waitForReconnectDelay();        }    }    return observerMasters.get(nextObserverMaster++);}
0
 QuorumServer findLearnerMaster(QuorumServer leader)
{    if (useObserverMasters()) {        return nextObserverMaster();    } else {                if (isRunning()) {            Observer.waitForReconnectDelay();        }        return leader;    }}
0
 QuorumServer validateLearnerMaster(String desiredMaster)
{    if (useObserverMasters()) {        Long sid;        try {            sid = Long.parseLong(desiredMaster);        } catch (NumberFormatException e) {            sid = null;        }        for (QuorumServer server : observerMasters) {            if (sid == null) {                String serverAddr = server.addr.getAddress().getHostAddress() + ':' + server.addr.getPort();                if (serverAddr.startsWith(desiredMaster)) {                    return server;                }            } else {                if (sid.equals(server.id)) {                    return server;                }            }        }        if (sid == null) {                    } else {                    }    } else {            }    return null;}
1
private boolean updateLearnerType(QuorumVerifier newQV)
{        if (newQV.getObservingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.OBSERVER) {            setLearnerType(LearnerType.OBSERVER);                        reconfigFlagSet();            return true;        } else {            return false;        }    } else if (newQV.getVotingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.PARTICIPANT) {            setLearnerType(LearnerType.PARTICIPANT);                        reconfigFlagSet();            return true;        } else {            return false;        }    }        if (getLearnerType() != LearnerType.PARTICIPANT) {        setLearnerType(LearnerType.PARTICIPANT);                reconfigFlagSet();        return true;    }    return false;}
1
private boolean updateVote(long designatedLeader, long zxid)
{    Vote currentVote = getCurrentVote();    if (currentVote != null && designatedLeader != currentVote.getId()) {        setCurrentVote(new Vote(designatedLeader, zxid));        reconfigFlagSet();                return true;    }    return false;}
1
protected void updateElectionVote(long newEpoch)
{    Vote currentVote = getCurrentVote();    if (currentVote != null) {        setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote.getState()));    }}
0
private void updateThreadName()
{    String plain = cnxnFactory != null ? cnxnFactory.getLocalAddress() != null ? formatInetAddr(cnxnFactory.getLocalAddress()) : "disabled" : "disabled";    String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : "disabled";    setName(String.format("QuorumPeer[myid=%d](plain=%s)(secure=%s)", getId(), plain, secure));}
0
 void setElectionTimeTaken(long electionTimeTaken)
{    this.electionTimeTaken = electionTimeTaken;}
0
 long getElectionTimeTaken()
{    return electionTimeTaken;}
0
 void setQuorumServerSaslRequired(boolean serverSaslRequired)
{    quorumServerSaslAuthRequired = serverSaslRequired;    }
1
 void setQuorumLearnerSaslRequired(boolean learnerSaslRequired)
{    quorumLearnerSaslAuthRequired = learnerSaslRequired;    }
1
 void setQuorumSaslEnabled(boolean enableAuth)
{    quorumSaslEnableAuth = enableAuth;    if (!quorumSaslEnableAuth) {            } else {            }}
1
 void setQuorumServicePrincipal(String servicePrincipal)
{    quorumServicePrincipal = servicePrincipal;    }
1
 void setQuorumLearnerLoginContext(String learnerContext)
{    quorumLearnerLoginContext = learnerContext;    }
1
 void setQuorumServerLoginContext(String serverContext)
{    quorumServerLoginContext = serverContext;    }
1
 void setQuorumCnxnThreadsSize(int qCnxnThreadsSize)
{    if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {        quorumCnxnThreadsSize = qCnxnThreadsSize;    }    }
1
 boolean isQuorumSaslAuthEnabled()
{    return quorumSaslEnableAuth;}
0
private boolean isQuorumServerSaslAuthRequired()
{    return quorumServerSaslAuthRequired;}
0
private boolean isQuorumLearnerSaslAuthRequired()
{    return quorumLearnerSaslAuthRequired;}
0
public QuorumCnxManager createCnxnManager()
{    int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;        return new QuorumCnxManager(this, this.getId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());}
1
 boolean isLeader(long id)
{    Vote vote = getCurrentVote();    return vote != null && id == vote.getId();}
0
public Integer getSynced_observers_metric()
{    if (leader != null) {        return leader.getObservingLearners().size();    } else if (follower != null) {        return follower.getSyncedObserverSize();    } else {        return null;    }}
0
public void parse(String path) throws ConfigException
{        try {        File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(path);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);            configFileStr = path;        } finally {            in.close();        }        /* Read entire config file as initial configuration */        initialConfig = new String(Files.readAllBytes(configFile.toPath()));        parseProperties(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + path, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + path, e);    }    if (dynamicConfigFileStr != null) {        try {            Properties dynamicCfg = new Properties();            FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);            try {                dynamicCfg.load(inConfig);                if (dynamicCfg.getProperty("version") != null) {                    throw new ConfigException("dynamic file shouldn't have version inside");                }                String version = getVersionFromFilename(dynamicConfigFileStr);                                if (version != null) {                    dynamicCfg.setProperty("version", version);                }            } finally {                inConfig.close();            }            setupQuorumPeerConfig(dynamicCfg, false);        } catch (IOException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        } catch (IllegalArgumentException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        }        File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);        if (nextDynamicConfigFile.exists()) {            try {                Properties dynamicConfigNextCfg = new Properties();                FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);                try {                    dynamicConfigNextCfg.load(inConfigNext);                } finally {                    inConfigNext.close();                }                boolean isHierarchical = false;                for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {                    String key = entry.getKey().toString().trim();                    if (key.startsWith("group") || key.startsWith("weight")) {                        isHierarchical = true;                        break;                    }                }                lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);            } catch (IOException e) {                            }        }    }}
1
public static String getVersionFromFilename(String filename)
{    int i = filename.lastIndexOf('.');    if (i < 0 || i >= filename.length()) {        return null;    }    String hexVersion = filename.substring(i + 1);    try {        long version = Long.parseLong(hexVersion, 16);        return Long.toHexString(version);    } catch (NumberFormatException e) {        return null;    }}
0
public void parseProperties(Properties zkProp) throws IOException, ConfigException
{    int clientPort = 0;    int secureClientPort = 0;    int observerMasterPort = 0;    String clientPortAddress = null;    String secureClientPortAddress = null;    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();    for (Entry<Object, Object> entry : zkProp.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("dataDir")) {            dataDir = vff.create(value);        } else if (key.equals("dataLogDir")) {            dataLogDir = vff.create(value);        } else if (key.equals("clientPort")) {            clientPort = Integer.parseInt(value);        } else if (key.equals("localSessionsEnabled")) {            localSessionsEnabled = Boolean.parseBoolean(value);        } else if (key.equals("localSessionsUpgradingEnabled")) {            localSessionsUpgradingEnabled = Boolean.parseBoolean(value);        } else if (key.equals("clientPortAddress")) {            clientPortAddress = value.trim();        } else if (key.equals("secureClientPort")) {            secureClientPort = Integer.parseInt(value);        } else if (key.equals("secureClientPortAddress")) {            secureClientPortAddress = value.trim();        } else if (key.equals("observerMasterPort")) {            observerMasterPort = Integer.parseInt(value);        } else if (key.equals("clientPortListenBacklog")) {            clientPortListenBacklog = Integer.parseInt(value);        } else if (key.equals("tickTime")) {            tickTime = Integer.parseInt(value);        } else if (key.equals("maxClientCnxns")) {            maxClientCnxns = Integer.parseInt(value);        } else if (key.equals("minSessionTimeout")) {            minSessionTimeout = Integer.parseInt(value);        } else if (key.equals("maxSessionTimeout")) {            maxSessionTimeout = Integer.parseInt(value);        } else if (key.equals("initLimit")) {            initLimit = Integer.parseInt(value);        } else if (key.equals("syncLimit")) {            syncLimit = Integer.parseInt(value);        } else if (key.equals("connectToLearnerMasterLimit")) {            connectToLearnerMasterLimit = Integer.parseInt(value);        } else if (key.equals("electionAlg")) {            electionAlg = Integer.parseInt(value);            if (electionAlg != 1 && electionAlg != 2 && electionAlg != 3) {                throw new ConfigException("Invalid electionAlg value. Only 1, 2, 3 are supported.");            }        } else if (key.equals("quorumListenOnAllIPs")) {            quorumListenOnAllIPs = Boolean.parseBoolean(value);        } else if (key.equals("peerType")) {            if (value.toLowerCase().equals("observer")) {                peerType = LearnerType.OBSERVER;            } else if (value.toLowerCase().equals("participant")) {                peerType = LearnerType.PARTICIPANT;            } else {                throw new ConfigException("Unrecognised peertype: " + value);            }        } else if (key.equals("syncEnabled")) {            syncEnabled = Boolean.parseBoolean(value);        } else if (key.equals("dynamicConfigFile")) {            dynamicConfigFileStr = value;        } else if (key.equals("autopurge.snapRetainCount")) {            snapRetainCount = Integer.parseInt(value);        } else if (key.equals("autopurge.purgeInterval")) {            purgeInterval = Integer.parseInt(value);        } else if (key.equals("standaloneEnabled")) {            if (value.toLowerCase().equals("true")) {                setStandaloneEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setStandaloneEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for standalone mode. Choose 'true' or 'false.'");            }        } else if (key.equals("reconfigEnabled")) {            if (value.toLowerCase().equals("true")) {                setReconfigEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setReconfigEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for reconfigEnabled flag. Choose 'true' or 'false.'");            }        } else if (key.equals("sslQuorum")) {            sslQuorum = Boolean.parseBoolean(value);        } else if (key.equals("portUnification")) {            shouldUsePortUnification = Boolean.parseBoolean(value);        } else if (key.equals("sslQuorumReloadCertFiles")) {            sslQuorumReloadCertFiles = Boolean.parseBoolean(value);        } else if ((key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight")) && zkProp.containsKey("dynamicConfigFile")) {            throw new ConfigException("parameter: " + key + " must be in a separate dynamic config file");        } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {            quorumEnableSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {            quorumServerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {            quorumLearnerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {            quorumLearnerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {            quorumServerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {            quorumServicePrincipal = value;        } else if (key.equals("quorum.cnxn.threads.size")) {            quorumCnxnThreadsSize = Integer.parseInt(value);        } else if (key.equals(JvmPauseMonitor.INFO_THRESHOLD_KEY)) {            jvmPauseInfoThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.WARN_THRESHOLD_KEY)) {            jvmPauseWarnThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.SLEEP_TIME_MS_KEY)) {            jvmPauseSleepTimeMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY)) {            jvmPauseMonitorToRun = Boolean.parseBoolean(value);        } else if (key.equals("metricsProvider.className")) {            metricsProviderClassName = value;        } else if (key.startsWith("metricsProvider.")) {            String keyForMetricsProvider = key.substring(16);            metricsProviderConfiguration.put(keyForMetricsProvider, value);        } else {            System.setProperty("zookeeper." + key, value);        }    }    if (!quorumEnableSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }    if (!quorumEnableSasl && quorumLearnerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);    }        if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {                snapRetainCount = MIN_SNAP_RETAIN_COUNT;    }    if (dataDir == null) {        throw new IllegalArgumentException("dataDir is not set");    }    if (dataLogDir == null) {        dataLogDir = dataDir;    }    if (clientPort == 0) {                if (clientPortAddress != null) {            throw new IllegalArgumentException("clientPortAddress is set but clientPort is not set");        }    } else if (clientPortAddress != null) {        this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);            } else {        this.clientPortAddress = new InetSocketAddress(clientPort);            }    if (secureClientPort == 0) {                if (secureClientPortAddress != null) {            throw new IllegalArgumentException("secureClientPortAddress is set but secureClientPort is not set");        }    } else if (secureClientPortAddress != null) {        this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);            } else {        this.secureClientPortAddress = new InetSocketAddress(secureClientPort);            }    if (this.secureClientPortAddress != null) {        configureSSLAuth();    }    if (observerMasterPort <= 0) {            } else {        this.observerMasterPort = observerMasterPort;            }    if (tickTime == 0) {        throw new IllegalArgumentException("tickTime is not set");    }    minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;    maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;    if (minSessionTimeout > maxSessionTimeout) {        throw new IllegalArgumentException("minSessionTimeout must not be larger than maxSessionTimeout");    }        try {        Class.forName(metricsProviderClassName, false, Thread.currentThread().getContextClassLoader());    } catch (ClassNotFoundException error) {        throw new IllegalArgumentException("metrics provider class was not found", error);    }        if (dynamicConfigFileStr == null) {        setupQuorumPeerConfig(zkProp, true);        if (isDistributed() && isReconfigEnabled()) {                                    backupOldConfig();        }    }}
1
public static void configureSSLAuth() throws ConfigException
{    try (ClientX509Util clientX509Util = new ClientX509Util()) {        String sslAuthProp = "zookeeper.authProvider." + System.getProperty(clientX509Util.getSslAuthProviderProperty(), "x509");        if (System.getProperty(sslAuthProp) == null) {            if ("zookeeper.authProvider.x509".equals(sslAuthProp)) {                System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");            } else {                throw new ConfigException("No auth provider configured for the SSL authentication scheme '" + System.getProperty(clientX509Util.getSslAuthProviderProperty()) + "'.");            }        }    }}
0
private void backupOldConfig() throws IOException
{    new AtomicFileWritingIdiom(new File(configFileStr + ".bak"), new OutputStreamStatement() {        @Override        public void write(OutputStream output) throws IOException {            InputStream input = null;            try {                input = new FileInputStream(new File(configFileStr));                byte[] buf = new byte[1024];                int bytesRead;                while ((bytesRead = input.read(buf)) > 0) {                    output.write(buf, 0, bytesRead);                }            } finally {                if (input != null) {                    input.close();                }            }        }    });}
0
public void write(OutputStream output) throws IOException
{    InputStream input = null;    try {        input = new FileInputStream(new File(configFileStr));        byte[] buf = new byte[1024];        int bytesRead;        while ((bytesRead = input.read(buf)) > 0) {            output.write(buf, 0, bytesRead);        }    } finally {        if (input != null) {            input.close();        }    }}
0
public static void writeDynamicConfig(final String dynamicConfigFilename, final QuorumVerifier qv, final boolean needKeepVersion) throws IOException
{    new AtomicFileWritingIdiom(new File(dynamicConfigFilename), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            Properties cfg = new Properties();            cfg.load(new StringReader(qv.toString()));            List<String> servers = new ArrayList<String>();            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (!needKeepVersion && key.startsWith("version")) {                    continue;                }                String value = entry.getValue().toString().trim();                servers.add(key.concat("=").concat(value));            }            Collections.sort(servers);            out.write(StringUtils.joinStrings(servers, "\n"));        }    });}
0
public void write(Writer out) throws IOException
{    Properties cfg = new Properties();    cfg.load(new StringReader(qv.toString()));    List<String> servers = new ArrayList<String>();    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (!needKeepVersion && key.startsWith("version")) {            continue;        }        String value = entry.getValue().toString().trim();        servers.add(key.concat("=").concat(value));    }    Collections.sort(servers);    out.write(StringUtils.joinStrings(servers, "\n"));}
0
public static void editStaticConfig(final String configFileStr, final String dynamicFileStr, final boolean eraseClientPortAddress) throws IOException
{        if (configFileStr == null) {        return;    }    File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(configFileStr);    final File dynamicFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(dynamicFileStr);    final Properties cfg = new Properties();    FileInputStream in = new FileInputStream(configFile);    try {        cfg.load(in);    } finally {        in.close();    }    new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                                        continue;                }                String value = entry.getValue().toString().trim();                out.write(key.concat("=").concat(value).concat("\n"));            }                        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());            out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));        }    });}
0
public void write(Writer out) throws IOException
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                        continue;        }        String value = entry.getValue().toString().trim();        out.write(key.concat("=").concat(value).concat("\n"));    }        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());    out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));}
0
public static void deleteFile(String filename)
{    if (filename == null) {        return;    }    File f = new File(filename);    if (f.exists()) {        try {            f.delete();        } catch (Exception e) {                    }    }}
1
private static QuorumVerifier createQuorumVerifier(Properties dynamicConfigProp, boolean isHierarchical) throws ConfigException
{    if (isHierarchical) {        return new QuorumHierarchical(dynamicConfigProp);    } else {                return new QuorumMaj(dynamicConfigProp);    }}
0
 void setupQuorumPeerConfig(Properties prop, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);    setupMyId();    setupClientPort();    setupPeerType();    checkValidity();}
0
public static QuorumVerifier parseDynamicConfig(Properties dynamicConfigProp, int eAlg, boolean warnings, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    boolean isHierarchical = false;    for (Entry<Object, Object> entry : dynamicConfigProp.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("group") || key.startsWith("weight")) {            isHierarchical = true;        } else if (!configBackwardCompatibilityMode && !key.startsWith("server.") && !key.equals("version")) {                        throw new ConfigException("Unrecognised parameter: " + key);        }    }    QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical);    int numParticipators = qv.getVotingMembers().size();    int numObservers = qv.getObservingMembers().size();    if (numParticipators == 0) {        if (!standaloneEnabled) {            throw new IllegalArgumentException("standaloneEnabled = false then " + "number of participants should be >0");        }        if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o participants is an invalid configuration");        }    } else if (numParticipators == 1 && standaloneEnabled) {                                                if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o quorum is an invalid configuration");        }    } else {        if (warnings) {            if (numParticipators <= 2) {                            } else if (numParticipators % 2 == 0) {                            }        }        for (QuorumServer s : qv.getVotingMembers().values()) {            if (s.electionAddr == null) {                throw new IllegalArgumentException("Missing election port for server: " + s.id);            }        }    }    return qv;}
1
private void setupMyId() throws IOException
{    File myIdFile = new File(dataDir, "myid");        if (!myIdFile.isFile()) {        return;    }    BufferedReader br = new BufferedReader(new FileReader(myIdFile));    String myIdString;    try {        myIdString = br.readLine();    } finally {        br.close();    }    try {        serverId = Long.parseLong(myIdString);        MDC.put("myid", myIdString);    } catch (NumberFormatException e) {        throw new IllegalArgumentException("serverid " + myIdString + " is not a number");    }}
0
private void setupClientPort() throws ConfigException
{    if (serverId == UNSET_SERVERID) {        return;    }    QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);    if (clientPortAddress != null && qs != null && qs.clientAddr != null) {        if ((!clientPortAddress.getAddress().isAnyLocalAddress() && !clientPortAddress.equals(qs.clientAddr)) || (clientPortAddress.getAddress().isAnyLocalAddress() && clientPortAddress.getPort() != qs.clientAddr.getPort())) {            throw new ConfigException("client address for this server (id = " + serverId + ") in static config file is " + clientPortAddress + " is different from client address found in dynamic file: " + qs.clientAddr);        }    }    if (qs != null && qs.clientAddr != null) {        clientPortAddress = qs.clientAddr;    }    if (qs != null && qs.clientAddr == null) {        qs.clientAddr = clientPortAddress;        qs.isClientAddrFromStatic = true;    }}
0
private void setupPeerType()
{        LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER : LearnerType.PARTICIPANT;    if (roleByServersList != peerType) {                peerType = roleByServersList;    }}
1
public void checkValidity() throws IOException, ConfigException
{    if (isDistributed()) {        if (initLimit == 0) {            throw new IllegalArgumentException("initLimit is not set");        }        if (syncLimit == 0) {            throw new IllegalArgumentException("syncLimit is not set");        }        if (serverId == UNSET_SERVERID) {            throw new IllegalArgumentException("myid file is missing");        }    }}
0
public InetSocketAddress getClientPortAddress()
{    return clientPortAddress;}
0
public InetSocketAddress getSecureClientPortAddress()
{    return secureClientPortAddress;}
0
public int getObserverMasterPort()
{    return observerMasterPort;}
0
public File getDataDir()
{    return dataDir;}
0
public File getDataLogDir()
{    return dataLogDir;}
0
public String getInitialConfig()
{    return initialConfig;}
0
public int getTickTime()
{    return tickTime;}
0
public int getMaxClientCnxns()
{    return maxClientCnxns;}
0
public int getMinSessionTimeout()
{    return minSessionTimeout;}
0
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
0
public String getMetricsProviderClassName()
{    return metricsProviderClassName;}
0
public Properties getMetricsProviderConfiguration()
{    return metricsProviderConfiguration;}
0
public boolean areLocalSessionsEnabled()
{    return localSessionsEnabled;}
0
public boolean isLocalSessionsUpgradingEnabled()
{    return localSessionsUpgradingEnabled;}
0
public boolean isSslQuorum()
{    return sslQuorum;}
0
public boolean shouldUsePortUnification()
{    return shouldUsePortUnification;}
0
public int getClientPortListenBacklog()
{    return clientPortListenBacklog;}
0
public int getInitLimit()
{    return initLimit;}
0
public int getSyncLimit()
{    return syncLimit;}
0
public int getConnectToLearnerMasterLimit()
{    return connectToLearnerMasterLimit;}
0
public int getElectionAlg()
{    return electionAlg;}
0
public int getElectionPort()
{    return electionPort;}
0
public int getSnapRetainCount()
{    return snapRetainCount;}
0
public int getPurgeInterval()
{    return purgeInterval;}
0
public boolean getSyncEnabled()
{    return syncEnabled;}
0
public QuorumVerifier getQuorumVerifier()
{    return quorumVerifier;}
0
public QuorumVerifier getLastSeenQuorumVerifier()
{    return lastSeenQuorumVerifier;}
0
public Map<Long, QuorumServer> getServers()
{        return Collections.unmodifiableMap(quorumVerifier.getAllMembers());}
0
public long getJvmPauseInfoThresholdMs()
{    return jvmPauseInfoThresholdMs;}
0
public long getJvmPauseWarnThresholdMs()
{    return jvmPauseWarnThresholdMs;}
0
public long getJvmPauseSleepTimeMs()
{    return jvmPauseSleepTimeMs;}
0
public boolean isJvmPauseMonitorToRun()
{    return jvmPauseMonitorToRun;}
0
public long getServerId()
{    return serverId;}
0
public boolean isDistributed()
{    return quorumVerifier != null && (!standaloneEnabled || quorumVerifier.getVotingMembers().size() > 1);}
0
public LearnerType getPeerType()
{    return peerType;}
0
public String getConfigFilename()
{    return configFileStr;}
0
public Boolean getQuorumListenOnAllIPs()
{    return quorumListenOnAllIPs;}
0
public static boolean isStandaloneEnabled()
{    return standaloneEnabled;}
0
public static void setStandaloneEnabled(boolean enabled)
{    standaloneEnabled = enabled;}
0
public static boolean isReconfigEnabled()
{    return reconfigEnabled;}
0
public static void setReconfigEnabled(boolean enabled)
{    reconfigEnabled = enabled;}
0
public static void main(String[] args)
{    QuorumPeerMain main = new QuorumPeerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {                        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {                System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {                System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {                System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {                System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }        System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
1
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException
{    QuorumPeerConfig config = new QuorumPeerConfig();    if (args.length == 1) {        config.parse(args[0]);    }        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());    purgeMgr.start();    if (args.length == 1 && config.isDistributed()) {        runFromConfig(config);    } else {                        ZooKeeperServerMain.main(args);    }}
1
public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {            }        MetricsProvider metricsProvider;    try {        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());    } catch (MetricsProviderLifeCycleException error) {        throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);    }    try {        ServerMetrics.metricsProviderInitialized(metricsProvider);        ServerCnxnFactory cnxnFactory = null;        ServerCnxnFactory secureCnxnFactory = null;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);        }        quorumPeer = getQuorumPeer();        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());                quorumPeer.setElectionType(config.getElectionAlg());        quorumPeer.setMyid(config.getServerId());        quorumPeer.setTickTime(config.getTickTime());        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());        quorumPeer.setInitLimit(config.getInitLimit());        quorumPeer.setSyncLimit(config.getSyncLimit());        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());        quorumPeer.setConfigFileName(config.getConfigFilename());        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);        if (config.getLastSeenQuorumVerifier() != null) {            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);        }        quorumPeer.initConfigInZKDatabase();        quorumPeer.setCnxnFactory(cnxnFactory);        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);        quorumPeer.setSslQuorum(config.isSslQuorum());        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());        quorumPeer.setLearnerType(config.getPeerType());        quorumPeer.setSyncEnabled(config.getSyncEnabled());        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());        if (config.sslQuorumReloadCertFiles) {            quorumPeer.getX509Util().enableCertFileReloading();        }                quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);        if (quorumPeer.isQuorumSaslAuthEnabled()) {            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);        }        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);        quorumPeer.initialize();        if (config.jvmPauseMonitorToRun) {            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));        }        quorumPeer.start();        quorumPeer.join();    } catch (InterruptedException e) {                    } finally {        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                            }        }    }}
1
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer();}
0
public String getServerState()
{    return provider.getServerState();}
0
public String[] getQuorumPeers()
{    return provider.getQuorumPeers();}
0
public String toString()
{    StringBuilder sb = new StringBuilder(super.toString());    String state = getServerState();    if (state.equals(Provider.LEADING_STATE)) {        sb.append("Followers:");        for (String f : getQuorumPeers()) {            sb.append(" ").append(f);        }        sb.append("\n");    } else if (state.equals(Provider.FOLLOWING_STATE) || state.equals(Provider.OBSERVING_STATE)) {        sb.append("Leader: ");        String[] ldr = getQuorumPeers();        if (ldr.length > 0) {            sb.append(ldr[0]);        } else {            sb.append("not connected");        }        sb.append("\n");    }    return sb.toString();}
0
protected void startSessionTracker()
{    upgradeableSessionTracker = (UpgradeableSessionTracker) sessionTracker;    upgradeableSessionTracker.start();}
0
public Request checkUpgradeSession(Request request) throws IOException, KeeperException
{        if ((request.type != OpCode.create && request.type != OpCode.create2 && request.type != OpCode.multi) || !upgradeableSessionTracker.isLocalSession(request.sessionId)) {        return null;    }    if (OpCode.multi == request.type) {        MultiOperationRecord multiTransactionRecord = new MultiOperationRecord();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, multiTransactionRecord);        request.request.rewind();        boolean containsEphemeralCreate = false;        for (Op op : multiTransactionRecord) {            if (op.getType() == OpCode.create || op.getType() == OpCode.create2) {                CreateRequest createRequest = (CreateRequest) op.toRequestRecord();                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                if (createMode.isEphemeral()) {                    containsEphemeralCreate = true;                    break;                }            }        }        if (!containsEphemeralCreate) {            return null;        }    } else {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());        if (!createMode.isEphemeral()) {            return null;        }    }        if (!self.isLocalSessionsUpgradingEnabled()) {        throw new KeeperException.EphemeralOnLocalSessionException();    }    return makeUpgradeRequest(request.sessionId);}
0
private Request makeUpgradeRequest(long sessionId)
{        synchronized (upgradeableSessionTracker) {        if (upgradeableSessionTracker.isLocalSession(sessionId)) {            int timeout = upgradeableSessionTracker.upgradeSession(sessionId);            ByteBuffer to = ByteBuffer.allocate(4);            to.putInt(timeout);            return new Request(null, sessionId, 0, OpCode.createSession, to, null);        }    }    return null;}
0
public void upgrade(long sessionId)
{    Request request = makeUpgradeRequest(sessionId);    if (request != null) {                        submitRequest(request);    }}
1
protected void setLocalSessionFlag(Request si)
{        switch(si.type) {        case OpCode.createSession:            if (self.areLocalSessionsEnabled()) {                                si.setLocalSession(true);            }            break;        case OpCode.closeSession:            String reqType = "global";            if (upgradeableSessionTracker.isLocalSession(si.sessionId)) {                si.setLocalSession(true);                reqType = "local";            }                        break;        default:            break;    }}
1
public void dumpConf(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());    pwriter.println("membership: ");    pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));}
0
protected void setState(State state)
{    this.state = state;}
0
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("quorum_size", () -> {        return self.getQuorumSize();    });}
0
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("quorum_size");}
0
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("peer_state", self.getDetailedPeerState());}
0
public String getName()
{    return "ReadOnlyServer";}
0
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();                        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'R', request, "");            }            if (Request.requestOfDeath == request) {                break;            }                        switch(request.type) {                case OpCode.sync:                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase().getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());                    try {                        request.cnxn.sendResponse(hdr, null, null);                    } catch (IOException e) {                                            }                    continue;            }                        if (nextProcessor != null) {                nextProcessor.processRequest(request);            }        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {                    }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    }
1
public void processRequest(Request request)
{    if (!finished) {        queuedRequests.add(request);    }}
0
public void shutdown()
{    finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor prepProcessor = new PrepRequestProcessor(this, finalProcessor);    ((PrepRequestProcessor) prepProcessor).start();    firstProcessor = new ReadOnlyRequestProcessor(this, prepProcessor);    ((ReadOnlyRequestProcessor) firstProcessor).start();}
0
public synchronized void startup()
{        if (shutdown) {                return;    }    registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);    super.startup();    self.setZooKeeperServer(this);    self.adminServer.setZooKeeperServer(this);    }
1
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
1
public void registerJMX(ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
1
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
1
protected void unregisterJMX(ZooKeeperServer zks)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
1
public String getState()
{    return "read-only";}
0
public long getServerId()
{    return self.getId();}
0
public synchronized void shutdown()
{    if (!canShutdown()) {                return;    }    shutdown = true;    unregisterJMX(this);        self.setZooKeeperServer(null);        self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);        super.shutdown();}
1
public void dumpConf(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());}
0
protected void setState(State state)
{    this.state = state;}
0
public void setQuorumServer(QuorumPeer.QuorumServer peer)
{    this.peer = peer;}
0
public String getName()
{    return "replica." + peer.id;}
0
public boolean isHidden()
{    return false;}
0
public String getQuorumAddress()
{    return peer.addr.getHostString() + ":" + peer.addr.getPort();}
0
public String getElectionAddress()
{    return peer.electionAddr.getHostString() + ":" + peer.electionAddr.getPort();}
0
public String getClientAddress()
{    if (null == peer.clientAddr) {        return "";    }    return peer.clientAddr.getHostString() + ":" + peer.clientAddr.getPort();}
0
public String getLearnerType()
{    return peer.type.toString();}
0
public boolean isLeader()
{    return localPeer.isLeader(peer.getId());}
0
public void processRequest(Request si)
{    if (si.type != OpCode.sync) {        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);        try {            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);            learner.writePacket(qp, false);        } catch (IOException e) {                        try {                if (!learner.sock.isClosed()) {                    learner.sock.close();                }            } catch (IOException e1) {                                            }        }    }}
1
public void flush() throws IOException
{    try {        learner.writePacket(null, true);    } catch (IOException e) {                try {            if (!learner.sock.isClosed()) {                learner.sock.close();            }        } catch (IOException e1) {                                }    }}
1
public void shutdown()
{}
0
public boolean isHidden()
{    return false;}
0
public String getStartTime()
{    return startTime.toString();}
0
public long getCurrentEpoch()
{    return currentEpoch;}
0
public long getLastZxid()
{    return lastZxid;}
0
public boolean isMoreRecentThan(StateSummary ss)
{    return (currentEpoch > ss.currentEpoch) || (currentEpoch == ss.currentEpoch && lastZxid > ss.lastZxid);}
0
public boolean equals(Object obj)
{    if (!(obj instanceof StateSummary)) {        return false;    }    StateSummary ss = (StateSummary) obj;    return currentEpoch == ss.currentEpoch && lastZxid == ss.lastZxid;}
0
public int hashCode()
{    return (int) (currentEpoch ^ lastZxid);}
0
public void addQuorumVerifier(QuorumVerifier qv)
{    qvAcksetPairs.add(new QuorumVerifierAcksetPair(qv, new HashSet<Long>(qv.getVotingMembers().size())));}
0
public boolean addAck(Long sid)
{    boolean change = false;    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            qvAckset.getAckset().add(sid);            change = true;        }    }    return change;}
0
public boolean hasSid(long sid)
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            return false;        }    }    return true;}
0
public boolean hasAllQuorums()
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset())) {            return false;        }    }    return true;}
0
public String ackSetsToString()
{    StringBuilder sb = new StringBuilder();    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        sb.append(qvAckset.getAckset().toString()).append(",");    }    return sb.substring(0, sb.length() - 1);}
0
public QuorumVerifier getQuorumVerifier()
{    return this.qv;}
0
public HashSet<Long> getAckset()
{    return this.ackset;}
0
private static String getMessage(int concurrentSyncNumber, int throttleThreshold, LearnerSyncThrottler.SyncType syncType)
{    return String.format("new %s sync would make %d concurrently in progress; maximum is %d", syncType.toString().toLowerCase(), concurrentSyncNumber, throttleThreshold);}
0
public Socket accept() throws IOException
{    if (isClosed()) {        throw new SocketException("Socket is closed");    }    if (!isBound()) {        throw new SocketException("Socket is not bound yet");    }    final PrependableSocket prependableSocket = new PrependableSocket(null);    implAccept(prependableSocket);    return new UnifiedSocket(x509Util, allowInsecureConnection, prependableSocket);}
0
public boolean isSecureSocket()
{    return mode == Mode.TLS;}
0
public boolean isPlaintextSocket()
{    return mode == Mode.PLAINTEXT;}
0
public boolean isModeKnown()
{    return mode != Mode.UNKNOWN;}
0
private void detectMode() throws IOException
{    byte[] litmus = new byte[5];    int oldTimeout = -1;    int bytesRead = 0;    int newTimeout = x509Util.getSslHandshakeTimeoutMillis();    try {        oldTimeout = prependableSocket.getSoTimeout();        prependableSocket.setSoTimeout(newTimeout);        bytesRead = prependableSocket.getInputStream().read(litmus, 0, litmus.length);    } catch (SocketTimeoutException e) {                    } finally {                try {            if (oldTimeout != -1) {                prependableSocket.setSoTimeout(oldTimeout);            }        } catch (Exception e) {                    }    }    if (bytesRead < 0) {                bytesRead = 0;    }    if (bytesRead == litmus.length && SslHandler.isEncrypted(Unpooled.wrappedBuffer(litmus))) {        try {            sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);        } catch (X509Exception e) {            throw new IOException("failed to create SSL context", e);        }        prependableSocket = null;        mode = Mode.TLS;            } else if (allowInsecureConnection) {        prependableSocket.prependToInputStream(litmus, 0, bytesRead);        mode = Mode.PLAINTEXT;            } else {        prependableSocket.close();        mode = Mode.PLAINTEXT;        throw new IOException("Blocked insecure connection attempt");    }}
1
private Socket getSocketAllowUnknownMode()
{    if (isSecureSocket()) {        return sslSocket;    } else {                return prependableSocket;    }}
0
private Socket getSocket() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (mode == Mode.TLS) {        return sslSocket;    } else {        return prependableSocket;    }}
0
public SSLSocket getSslSocket() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (!isSecureSocket()) {        throw new SocketException("Socket mode is not TLS");    }    return sslSocket;}
0
public void connect(SocketAddress endpoint) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint);}
0
public void connect(SocketAddress endpoint, int timeout) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint, timeout);}
0
public void bind(SocketAddress bindpoint) throws IOException
{    getSocketAllowUnknownMode().bind(bindpoint);}
0
public InetAddress getInetAddress()
{    return getSocketAllowUnknownMode().getInetAddress();}
0
public InetAddress getLocalAddress()
{    return getSocketAllowUnknownMode().getLocalAddress();}
0
public int getPort()
{    return getSocketAllowUnknownMode().getPort();}
0
public int getLocalPort()
{    return getSocketAllowUnknownMode().getLocalPort();}
0
public SocketAddress getRemoteSocketAddress()
{    return getSocketAllowUnknownMode().getRemoteSocketAddress();}
0
public SocketAddress getLocalSocketAddress()
{    return getSocketAllowUnknownMode().getLocalSocketAddress();}
0
public SocketChannel getChannel()
{    return getSocketAllowUnknownMode().getChannel();}
0
public InputStream getInputStream() throws IOException
{    return new UnifiedInputStream(this);}
0
public OutputStream getOutputStream() throws IOException
{    return new UnifiedOutputStream(this);}
0
public void setTcpNoDelay(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setTcpNoDelay(on);}
0
public boolean getTcpNoDelay() throws SocketException
{    return getSocketAllowUnknownMode().getTcpNoDelay();}
0
public void setSoLinger(boolean on, int linger) throws SocketException
{    getSocketAllowUnknownMode().setSoLinger(on, linger);}
0
public int getSoLinger() throws SocketException
{    return getSocketAllowUnknownMode().getSoLinger();}
0
public void sendUrgentData(int data) throws IOException
{    getSocket().sendUrgentData(data);}
0
public void setOOBInline(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setOOBInline(on);}
0
public boolean getOOBInline() throws SocketException
{    return getSocketAllowUnknownMode().getOOBInline();}
0
public synchronized void setSoTimeout(int timeout) throws SocketException
{    getSocketAllowUnknownMode().setSoTimeout(timeout);}
0
public synchronized int getSoTimeout() throws SocketException
{    return getSocketAllowUnknownMode().getSoTimeout();}
0
public synchronized void setSendBufferSize(int size) throws SocketException
{    getSocketAllowUnknownMode().setSendBufferSize(size);}
0
public synchronized int getSendBufferSize() throws SocketException
{    return getSocketAllowUnknownMode().getSendBufferSize();}
0
public synchronized void setReceiveBufferSize(int size) throws SocketException
{    getSocketAllowUnknownMode().setReceiveBufferSize(size);}
0
public synchronized int getReceiveBufferSize() throws SocketException
{    return getSocketAllowUnknownMode().getReceiveBufferSize();}
0
public void setKeepAlive(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setKeepAlive(on);}
0
public boolean getKeepAlive() throws SocketException
{    return getSocketAllowUnknownMode().getKeepAlive();}
0
public void setTrafficClass(int tc) throws SocketException
{    getSocketAllowUnknownMode().setTrafficClass(tc);}
0
public int getTrafficClass() throws SocketException
{    return getSocketAllowUnknownMode().getTrafficClass();}
0
public void setReuseAddress(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setReuseAddress(on);}
0
public boolean getReuseAddress() throws SocketException
{    return getSocketAllowUnknownMode().getReuseAddress();}
0
public synchronized void close() throws IOException
{    getSocketAllowUnknownMode().close();}
0
public void shutdownInput() throws IOException
{    getSocketAllowUnknownMode().shutdownInput();}
0
public void shutdownOutput() throws IOException
{    getSocketAllowUnknownMode().shutdownOutput();}
0
public String toString()
{    return "UnifiedSocket[mode=" + mode.toString() + "socket=" + getSocketAllowUnknownMode().toString() + "]";}
0
public boolean isConnected()
{    return getSocketAllowUnknownMode().isConnected();}
0
public boolean isBound()
{    return getSocketAllowUnknownMode().isBound();}
0
public boolean isClosed()
{    return getSocketAllowUnknownMode().isClosed();}
0
public boolean isInputShutdown()
{    return getSocketAllowUnknownMode().isInputShutdown();}
0
public boolean isOutputShutdown()
{    return getSocketAllowUnknownMode().isOutputShutdown();}
0
public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
{    getSocketAllowUnknownMode().setPerformancePreferences(connectionTime, latency, bandwidth);}
0
public int read() throws IOException
{    return getRealInputStream().read();}
0
public int read(byte[] b) throws IOException
{    return getRealInputStream().read(b);}
0
public int read(byte[] b, int off, int len) throws IOException
{    return getRealInputStream().read(b, off, len);}
0
private InputStream getRealInputStream() throws IOException
{    if (realInputStream == null) {                realInputStream = unifiedSocket.getSocket().getInputStream();    }    return realInputStream;}
0
public long skip(long n) throws IOException
{    return getRealInputStream().skip(n);}
0
public int available() throws IOException
{    return getRealInputStream().available();}
0
public void close() throws IOException
{    getRealInputStream().close();}
0
public synchronized void mark(int readlimit)
{    try {        getRealInputStream().mark(readlimit);    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
public synchronized void reset() throws IOException
{    getRealInputStream().reset();}
0
public boolean markSupported()
{    try {        return getRealInputStream().markSupported();    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
public void write(int b) throws IOException
{    getRealOutputStream().write(b);}
0
public void write(byte[] b) throws IOException
{    getRealOutputStream().write(b);}
0
public void write(byte[] b, int off, int len) throws IOException
{    getRealOutputStream().write(b, off, len);}
0
public void flush() throws IOException
{    getRealOutputStream().flush();}
0
public void close() throws IOException
{    getRealOutputStream().close();}
0
private OutputStream getRealOutputStream() throws IOException
{    if (realOutputStream == null) {                realOutputStream = unifiedSocket.getSocket().getOutputStream();    }    return realOutputStream;}
0
public void start()
{}
0
public void createLocalSessionTracker(SessionExpirer expirer, int tickTime, long id, ZooKeeperServerListener listener)
{    this.localSessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();    this.localSessionTracker = new LocalSessionTracker(expirer, this.localSessionsWithTimeouts, tickTime, id, listener);    this.upgradingSessions = new ConcurrentHashMap<Long, Integer>();}
0
public boolean isTrackingSession(long sessionId)
{    return isLocalSession(sessionId) || isGlobalSession(sessionId);}
0
public boolean isLocalSession(long sessionId)
{    return localSessionTracker != null && localSessionTracker.isTrackingSession(sessionId);}
0
public boolean isLocalSessionsEnabled()
{    return localSessionsEnabled;}
0
public boolean isUpgradingSession(long sessionId)
{    return upgradingSessions != null && upgradingSessions.containsKey(sessionId);}
0
public void finishedUpgrading(long sessionId)
{    if (upgradingSessions != null) {        upgradingSessions.remove(sessionId);    }}
0
public int upgradeSession(long sessionId)
{    if (localSessionsWithTimeouts == null) {        return -1;    }            Integer timeout = localSessionsWithTimeouts.remove(sessionId);    if (timeout != null) {                                                trackSession(sessionId, timeout);                        upgradingSessions.put(sessionId, timeout);        localSessionTracker.removeSession(sessionId);        return timeout;    }    return -1;}
1
protected void removeLocalSession(long sessionId)
{    if (localSessionTracker == null) {        return;    }    localSessionTracker.removeSession(sessionId);}
0
public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    throw new UnsupportedOperationException();}
0
public long getLocalSessionCount()
{    if (localSessionsWithTimeouts == null) {        return 0;    }    return localSessionsWithTimeouts.size();}
0
public int getVersion()
{    return version;}
0
public long getId()
{    return id;}
0
public long getZxid()
{    return zxid;}
0
public long getElectionEpoch()
{    return electionEpoch;}
0
public long getPeerEpoch()
{    return peerEpoch;}
0
public ServerState getState()
{    return state;}
0
public boolean equals(Object o)
{    if (!(o instanceof Vote)) {        return false;    }    Vote other = (Vote) o;    if ((state == ServerState.LOOKING) || (other.state == ServerState.LOOKING)) {        return id == other.id && zxid == other.zxid && electionEpoch == other.electionEpoch && peerEpoch == other.peerEpoch;    } else {        /*             * There are two things going on in the logic below:             *             * 1. skip comparing the zxid and electionEpoch for votes for servers             *    out of election.             *             *    Need to skip those because they can be inconsistent due to             *    scenarios described in QuorumPeer.updateElectionVote.             *             *    And given that only one ensemble can be running at a single point             *    in time and that each epoch is used only once, using only id and             *    epoch to compare the votes is sufficient.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1805}             *             * 2. skip comparing peerEpoch if if we're running with mixed ensemble             *    with (version > 0x0) and without the change (version = 0x0)             *    introduced in ZOOKEEPER-1732.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}             *             *    The server running with and without ZOOKEEPER-1732 will return             *    different peerEpoch. During rolling upgrades, it's possible             *    that 2/5 servers are returning epoch 1, while the other 2/5             *    are returning epoch 2, the other server need to ignore the             *    peerEpoch to be able to join it.             */        if ((version > 0x0) ^ (other.version > 0x0)) {            return id == other.id;        } else {            return (id == other.id && peerEpoch == other.peerEpoch);        }    }}
0
public int hashCode()
{    return (int) (id & zxid);}
0
public String toString()
{    return "(" + id + ", " + Long.toHexString(zxid) + ", " + Long.toHexString(peerEpoch) + ")";}
0
public void flush()
{    if (msg != null && count > 0) {        String log = "";        if (count > 1) {            log = "[" + count + " times] ";        }        log += "Message: " + msg;        if (value != null) {            log += " Last value:" + value;        }            }    msg = null;    value = null;    count = 0;}
1
public void rateLimitLog(String newMsg)
{    rateLimitLog(newMsg, null);}
0
public void rateLimitLog(String newMsg, String value)
{    long now = Time.currentElapsedTime();    if (newMsg.equals(msg)) {        ++count;        this.value = value;        if (now - timestamp >= LOG_INTERVAL) {            flush();            msg = newMsg;            timestamp = now;            this.value = value;        }    } else {        flush();        msg = newMsg;        this.value = value;        timestamp = now;            }}
1
public synchronized Long convertAcls(List<ACL> acls)
{    if (acls == null) {        return OPEN_UNSAFE_ACL_ID;    }        Long ret = aclKeyMap.get(acls);    if (ret == null) {        ret = incrementIndex();        longKeyMap.put(ret, acls);        aclKeyMap.put(acls, ret);    }    addUsage(ret);    return ret;}
0
public synchronized List<ACL> convertLong(Long longVal)
{    if (longVal == null) {        return null;    }    if (longVal == OPEN_UNSAFE_ACL_ID) {        return ZooDefs.Ids.OPEN_ACL_UNSAFE;    }    List<ACL> acls = longKeyMap.get(longVal);    if (acls == null) {                throw new RuntimeException("Failed to fetch acls for " + longVal);    }    return acls;}
1
private long incrementIndex()
{    return ++aclIndex;}
0
public synchronized void deserialize(InputArchive ia) throws IOException
{    clear();    int i = ia.readInt("map");    while (i > 0) {        Long val = ia.readLong("long");        if (aclIndex < val) {            aclIndex = val;        }        List<ACL> aclList = new ArrayList<ACL>();        Index j = ia.startVector("acls");        if (j == null) {            throw new RuntimeException("Incorrent format of InputArchive when deserialize DataTree - missing acls");        }        while (!j.done()) {            ACL acl = new ACL();            acl.deserialize(ia, "acl");            aclList.add(acl);            j.incr();        }        longKeyMap.put(val, aclList);        aclKeyMap.put(aclList, val);        referenceCounter.put(val, new AtomicLongWithEquals(0));        i--;    }}
0
public synchronized void serialize(OutputArchive oa) throws IOException
{    oa.writeInt(longKeyMap.size(), "map");    Set<Map.Entry<Long, List<ACL>>> set = longKeyMap.entrySet();    for (Map.Entry<Long, List<ACL>> val : set) {        oa.writeLong(val.getKey(), "long");        List<ACL> aclList = val.getValue();        oa.startVector(aclList, "acls");        for (ACL acl : aclList) {            acl.serialize(oa, "acl");        }        oa.endVector(aclList, "acls");    }}
0
public int size()
{    return aclKeyMap.size();}
0
private void clear()
{    aclKeyMap.clear();    longKeyMap.clear();    referenceCounter.clear();}
0
public synchronized void addUsage(Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {                return;    }    AtomicLong count = referenceCounter.get(acl);    if (count == null) {        referenceCounter.put(acl, new AtomicLongWithEquals(1));    } else {        count.incrementAndGet();    }}
1
public synchronized void removeUsage(Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {                return;    }    long newCount = referenceCounter.get(acl).decrementAndGet();    if (newCount <= 0) {        referenceCounter.remove(acl);        aclKeyMap.remove(longKeyMap.get(acl));        longKeyMap.remove(acl);    }}
1
public synchronized void purgeUnused()
{    Iterator<Map.Entry<Long, AtomicLongWithEquals>> refCountIter = referenceCounter.entrySet().iterator();    while (refCountIter.hasNext()) {        Map.Entry<Long, AtomicLongWithEquals> entry = refCountIter.next();        if (entry.getValue().get() <= 0) {            Long acl = entry.getKey();            aclKeyMap.remove(longKeyMap.get(acl));            longKeyMap.remove(acl);            refCountIter.remove();        }    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    return equals((AtomicLongWithEquals) o);}
0
public boolean equals(AtomicLongWithEquals that)
{    return get() == that.get();}
0
public int hashCode()
{    return 31 * Long.valueOf(get()).hashCode();}
0
public boolean isLocalSession()
{    return isLocalSession;}
0
public void setLocalSession(boolean isLocalSession)
{    this.isLocalSession = isLocalSession;}
0
public void setLargeRequestSize(int size)
{    largeRequestSize = size;}
0
public int getLargeRequestSize()
{    return largeRequestSize;}
0
public Object getOwner()
{    return owner;}
0
public void setOwner(Object owner)
{    this.owner = owner;}
0
public TxnHeader getHdr()
{    return hdr;}
0
public void setHdr(TxnHeader hdr)
{    this.hdr = hdr;}
0
public Record getTxn()
{    return txn;}
0
public void setTxn(Record txn)
{    this.txn = txn;}
0
public ServerCnxn getConnection()
{    return cnxn;}
0
public static boolean getStaleLatencyCheck()
{    return staleLatencyCheck;}
0
public static void setStaleLatencyCheck(boolean check)
{    staleLatencyCheck = check;}
0
public static boolean getStaleConnectionCheck()
{    return staleConnectionCheck;}
0
public static void setStaleConnectionCheck(boolean check)
{    staleConnectionCheck = check;}
0
public boolean isStale()
{    if (cnxn == null) {        return false;    }        if (type == OpCode.closeSession) {        return false;    }    if (staleConnectionCheck) {                if (cnxn.isStale() || cnxn.isInvalid()) {            return true;        }    }    if (staleLatencyCheck) {                        long currentTime = Time.currentElapsedTime();        return (currentTime - createTime) > cnxn.getSessionTimeout();    }    return false;}
0
public boolean mustDrop()
{    return ((cnxn != null) && cnxn.isInvalid());}
0
 static boolean isValid(int type)
{        switch(type) {        case OpCode.notification:            return false;        case OpCode.check:        case OpCode.closeSession:        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.createSession:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multi:        case OpCode.multiRead:        case OpCode.ping:        case OpCode.reconfig:        case OpCode.setACL:        case OpCode.setData:        case OpCode.setWatches:        case OpCode.sync:        case OpCode.checkWatches:        case OpCode.removeWatches:            return true;        default:            return false;    }}
0
public boolean isQuorum()
{    switch(this.type) {        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multiRead:            return false;        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.error:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setACL:        case OpCode.setData:        case OpCode.check:        case OpCode.multi:        case OpCode.reconfig:            return true;        case OpCode.closeSession:        case OpCode.createSession:            return !this.isLocalSession;        default:            return false;    }}
0
public static String op2String(int op)
{    switch(op) {        case OpCode.notification:            return "notification";        case OpCode.create:            return "create";        case OpCode.delete:            return "delete";        case OpCode.exists:            return "exists";        case OpCode.getData:            return "getData";        case OpCode.setData:            return "setData";        case OpCode.getACL:            return "getACL";        case OpCode.setACL:            return "setACL";        case OpCode.getChildren:            return "getChildren";        case OpCode.sync:            return "sync";        case OpCode.ping:            return "ping";        case OpCode.getChildren2:            return "getChildren2";        case OpCode.check:            return "check";        case OpCode.multi:            return "multi";        case OpCode.create2:            return "create2";        case OpCode.reconfig:            return "reconfig";        case OpCode.checkWatches:            return "checkWatches";        case OpCode.removeWatches:            return "removeWatches";        case OpCode.createContainer:            return "createContainer";        case OpCode.deleteContainer:            return "deleteContainer";        case OpCode.createTTL:            return "createTtl";        case OpCode.multiRead:            return "multiRead";        case OpCode.auth:            return "auth";        case OpCode.setWatches:            return "setWatches";        case OpCode.sasl:            return "sasl";        case OpCode.getEphemerals:            return "getEphemerals";        case OpCode.getAllChildrenNumber:            return "getAllChildrenNumber";        case OpCode.createSession:            return "createSession";        case OpCode.closeSession:            return "closeSession";        case OpCode.error:            return "error";        default:            return "unknown " + op;    }}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("sessionid:0x").append(Long.toHexString(sessionId)).append(" type:").append(op2String(type)).append(" cxid:0x").append(Long.toHexString(cxid)).append(" zxid:0x").append(Long.toHexString(hdr == null ? -2 : hdr.getZxid())).append(" txntype:").append(hdr == null ? "unknown" : "" + hdr.getType());        String path = "n/a";    if (type != OpCode.createSession && type != OpCode.setWatches && type != OpCode.closeSession && request != null && request.remaining() >= 4) {        try {                        ByteBuffer rbuf = request.asReadOnlyBuffer();            rbuf.clear();            int pathLen = rbuf.getInt();                        if (pathLen >= 0 && pathLen < 4096 && rbuf.remaining() >= pathLen) {                byte[] b = new byte[pathLen];                rbuf.get(b);                path = new String(b);            }        } catch (Exception e) {                }    }    sb.append(" reqpath:").append(path);    return sb.toString();}
0
public void setException(KeeperException e)
{    this.e = e;}
0
public KeeperException getException()
{    return e;}
0
public void logLatency(Summary metric)
{    logLatency(metric, Time.currentWallTime());}
0
public void logLatency(Summary metric, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(latency);        }    }}
0
public void logLatency(SummarySet metric, String key, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(key, latency);        }    }}
0
public void logLatency(SummarySet metric, String key)
{    logLatency(metric, key, Time.currentWallTime());}
0
public static int getMaxRequests()
{    return maxRequests;}
0
public static void setMaxRequests(int requests)
{    maxRequests = requests;}
0
public static int getStallTime()
{    return stallTime;}
0
public static void setStallTime(int time)
{    stallTime = time;}
0
public static boolean getDropStaleRequests()
{    return dropStaleRequests;}
0
public static void setDropStaleRequests(boolean drop)
{    dropStaleRequests = drop;}
0
public void run()
{    try {        while (true) {            if (killed) {                break;            }            Request request = submittedRequests.take();            if (Request.requestOfDeath == request) {                break;            }            if (request.mustDrop()) {                continue;            }                        if (maxRequests > 0) {                while (!killed) {                    if (dropStaleRequests && request.isStale()) {                                                dropRequest(request);                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);                        request = null;                        break;                    }                    if (zks.getInProcess() < maxRequests) {                        break;                    }                    throttleSleep(stallTime);                }            }            if (killed) {                break;            }                        if (request != null) {                if (request.isStale()) {                    ServerMetrics.getMetrics().STALE_REQUESTS.add(1);                }                zks.submitRequestNow(request);            }        }    } catch (InterruptedException e) {            }    int dropped = drainQueue();    }
1
private synchronized void throttleSleep(int stallTime)
{    try {        ServerMetrics.getMetrics().REQUEST_THROTTLE_WAIT_COUNT.add(1);        this.wait(stallTime);    } catch (InterruptedException ie) {        return;    }}
0
public synchronized void throttleWake()
{    this.notify();}
0
private int drainQueue()
{                    int dropped = 0;    Request request;        while ((request = submittedRequests.poll()) != null) {        dropped += 1;        dropRequest(request);    }    return dropped;}
1
private void dropRequest(Request request)
{                    ServerCnxn conn = request.getConnection();    if (conn != null) {                conn.setInvalid();    }            zks.requestFinished(request);}
0
public void submitRequest(Request request)
{    if (stopping) {                dropRequest(request);    } else {        submittedRequests.add(request);    }}
1
public int getInflight()
{    return submittedRequests.size();}
0
public void shutdown()
{            stopping = true;    submittedRequests.add(Request.requestOfDeath);    try {        this.join(shutdownTimeout);    } catch (InterruptedException e) {            }            killed = true;    try {        this.join();    } catch (InterruptedException e) {                        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }}
1
public void put(String path, byte[] data, Stat stat)
{    Entry entry = new Entry();    entry.data = data;    entry.stat = stat;    cache.put(path, entry);}
0
public byte[] get(String key, Stat stat)
{    Entry entry = cache.get(key);    if (entry == null) {        return null;    }    if (!stat.equals(entry.stat)) {                cache.remove(key);        return null;    } else {        return entry.data;    }}
0
private static int getResponseCacheSize()
{    return Integer.getInteger("zookeeper.maxResponseCacheSize", DEFAULT_RESPONSE_CACHE_SIZE);}
0
public static boolean isEnabled()
{    return getResponseCacheSize() > 0;}
0
protected boolean removeEldestEntry(Map.Entry<K, V> eldest)
{    return size() >= cacheSize;}
0
public String toDisconnectReasonString()
{    return disconnectReason;}
0
public void incrOutstandingAndCheckThrottle(RequestHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (zkServer.shouldThrottle(outstandingCount.incrementAndGet())) {        disableRecv(false);    }}
0
public void decrOutstandingAndCheckThrottle(ReplyHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (!zkServer.shouldThrottle(outstandingCount.decrementAndGet())) {        enableRecv();    }}
0
public void sendResponse(ReplyHeader h, Record r, String tag) throws IOException
{    sendResponse(h, r, tag, null, null);}
0
protected byte[] serializeRecord(Record record) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream(ZooKeeperServer.intBufferStartingSizeBytes);    BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);    bos.writeRecord(record, null);    return baos.toByteArray();}
0
protected ByteBuffer[] serialize(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{    byte[] header = serializeRecord(h);    byte[] data = null;    if (r != null) {        ResponseCache cache = zkServer.getReadResponseCache();        if (cache != null && stat != null && cacheKey != null && !cacheKey.endsWith(Quotas.statNode)) {                                                            data = cache.get(cacheKey, stat);            if (data == null) {                                data = serializeRecord(r);                cache.put(cacheKey, data, stat);                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_MISSING.add(1);            } else {                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_HITS.add(1);            }        } else {            data = serializeRecord(r);        }    }    int dataLength = data == null ? 0 : data.length;    int packetLength = header.length + dataLength;    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.updateClientResponseSize(packetLength);    }    ByteBuffer lengthBuffer = ByteBuffer.allocate(4).putInt(packetLength);    lengthBuffer.rewind();    int bufferLen = data != null ? 3 : 2;    ByteBuffer[] buffers = new ByteBuffer[bufferLen];    buffers[0] = lengthBuffer;    buffers[1] = ByteBuffer.wrap(header);    if (data != null) {        buffers[2] = ByteBuffer.wrap(data);    }    return buffers;}
0
public List<Id> getAuthInfo()
{    return Collections.unmodifiableList(new ArrayList<>(authInfo));}
0
public void addAuthInfo(Id id)
{    authInfo.add(id);}
0
public boolean removeAuthInfo(Id id)
{    return authInfo.remove(id);}
0
 void disableRecv()
{    disableRecv(true);}
0
public DisconnectReason getReason()
{    return reason;}
0
public String toString()
{    return "EndOfStreamException: " + getMessage();}
0
public DisconnectReason getReason()
{    return reason;}
0
public boolean isStale()
{    return stale;}
0
public void setStale()
{    stale = true;}
0
public boolean isInvalid()
{    return invalid;}
0
public void setInvalid()
{    if (!invalid) {        if (!stale) {            sendCloseSession();        }        invalid = true;    }}
0
protected void packetReceived(long bytes)
{    incrPacketsReceived();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats().incrementPacketsReceived();    }    ServerMetrics.getMetrics().BYTES_RECEIVED_COUNT.add(bytes);}
0
protected void packetSent()
{    incrPacketsSent();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.incrementPacketsSent();    }}
0
public synchronized void resetStats()
{    disconnectReason = DisconnectReason.RESET_COMMAND;    packetsReceived.set(0);    packetsSent.set(0);    minLatency = Long.MAX_VALUE;    maxLatency = 0;    lastOp = "NA";    lastCxid = -1;    lastZxid = -1;    lastResponseTime = 0;    lastLatency = 0;    count = 0;    totalLatency = 0;}
0
protected long incrPacketsReceived()
{    return packetsReceived.incrementAndGet();}
0
protected long incrPacketsSent()
{    return packetsSent.incrementAndGet();}
0
protected synchronized void updateStatsForResponse(long cxid, long zxid, String op, long start, long end)
{        if (cxid >= 0) {        lastCxid = cxid;    }    lastZxid = zxid;    lastOp = op;    lastResponseTime = end;    long elapsed = end - start;    lastLatency = elapsed;    if (elapsed < minLatency) {        minLatency = elapsed;    }    if (elapsed > maxLatency) {        maxLatency = elapsed;    }    count++;    totalLatency += elapsed;}
0
public Date getEstablished()
{    return (Date) established.clone();}
0
public long getOutstandingRequests()
{    return outstandingCount.longValue();}
0
public long getPacketsReceived()
{    return packetsReceived.longValue();}
0
public long getPacketsSent()
{    return packetsSent.longValue();}
0
public synchronized long getMinLatency()
{    return minLatency == Long.MAX_VALUE ? 0 : minLatency;}
0
public synchronized long getAvgLatency()
{    return count == 0 ? 0 : totalLatency / count;}
0
public synchronized long getMaxLatency()
{    return maxLatency;}
0
public synchronized String getLastOperation()
{    return lastOp;}
0
public synchronized long getLastCxid()
{    return lastCxid;}
0
public synchronized long getLastZxid()
{    return lastZxid;}
0
public synchronized long getLastResponseTime()
{    return lastResponseTime;}
0
public synchronized long getLastLatency()
{    return lastLatency;}
0
public String toString()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpConnectionInfo(pwriter, false);    pwriter.flush();    pwriter.close();    return sw.toString();}
0
public synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief)
{    pwriter.print(" ");    pwriter.print(getRemoteSocketAddress());    pwriter.print("[");    int interestOps = getInterestOps();    pwriter.print(interestOps == 0 ? "0" : Integer.toHexString(interestOps));    pwriter.print("](queued=");    pwriter.print(getOutstandingRequests());    pwriter.print(",recved=");    pwriter.print(getPacketsReceived());    pwriter.print(",sent=");    pwriter.print(getPacketsSent());    if (!brief) {        long sessionId = getSessionId();        if (sessionId != 0) {            pwriter.print(",sid=0x");            pwriter.print(Long.toHexString(sessionId));            pwriter.print(",lop=");            pwriter.print(getLastOperation());            pwriter.print(",est=");            pwriter.print(getEstablished().getTime());            pwriter.print(",to=");            pwriter.print(getSessionTimeout());            long lastCxid = getLastCxid();            if (lastCxid >= 0) {                pwriter.print(",lcxid=0x");                pwriter.print(Long.toHexString(lastCxid));            }            pwriter.print(",lzxid=0x");            pwriter.print(Long.toHexString(getLastZxid()));            pwriter.print(",lresp=");            pwriter.print(getLastResponseTime());            pwriter.print(",llat=");            pwriter.print(getLastLatency());            pwriter.print(",minlat=");            pwriter.print(getMinLatency());            pwriter.print(",avglat=");            pwriter.print(getAvgLatency());            pwriter.print(",maxlat=");            pwriter.print(getMaxLatency());        }    }    pwriter.print(")");}
0
public synchronized Map<String, Object> getConnectionInfo(boolean brief)
{    Map<String, Object> info = new LinkedHashMap<String, Object>();    info.put("remote_socket_address", getRemoteSocketAddress());    info.put("interest_ops", getInterestOps());    info.put("outstanding_requests", getOutstandingRequests());    info.put("packets_received", getPacketsReceived());    info.put("packets_sent", getPacketsSent());    if (!brief) {        info.put("session_id", getSessionId());        info.put("last_operation", getLastOperation());        info.put("established", getEstablished());        info.put("session_timeout", getSessionTimeout());        info.put("last_cxid", getLastCxid());        info.put("last_zxid", getLastZxid());        info.put("last_response_time", getLastResponseTime());        info.put("last_latency", getLastLatency());        info.put("min_latency", getMinLatency());        info.put("avg_latency", getAvgLatency());        info.put("max_latency", getMaxLatency());    }    return info;}
0
public void cleanupWriterSocket(PrintWriter pwriter)
{    try {        if (pwriter != null) {            pwriter.flush();            pwriter.close();        }    } catch (Exception e) {            } finally {        try {            close(DisconnectReason.CLOSE_CONNECTION_COMMAND);        } catch (Exception e) {                    }    }}
1
public void addSession(long sessionId, ServerCnxn cnxn)
{    sessionMap.put(sessionId, cnxn);}
0
public void removeCnxnFromSessionMap(ServerCnxn cnxn)
{    long sessionId = cnxn.getSessionId();    if (sessionId != 0) {        sessionMap.remove(sessionId);    }}
0
public boolean closeSession(long sessionId, ServerCnxn.DisconnectReason reason)
{    ServerCnxn cnxn = sessionMap.remove(sessionId);    if (cnxn != null) {        try {            cnxn.close(reason);        } catch (Exception e) {                    }        return true;    }    return false;}
1
public int getNumAliveConnections()
{    return cnxns.size();}
0
public final ZooKeeperServer getZooKeeperServer()
{    return zkServer;}
0
public void configure(InetSocketAddress addr, int maxcc) throws IOException
{    configure(addr, maxcc, -1);}
0
public void configure(InetSocketAddress addr, int maxcc, int backlog) throws IOException
{    configure(addr, maxcc, backlog, false);}
0
public boolean isSecure()
{    return secure;}
0
public void startup(ZooKeeperServer zkServer) throws IOException, InterruptedException
{    startup(zkServer, true);}
0
public final void setZooKeeperServer(ZooKeeperServer zks)
{    this.zkServer = zks;    if (zks != null) {        if (secure) {            zks.setSecureServerCnxnFactory(this);        } else {            zks.setServerCnxnFactory(this);        }    }}
0
public static ServerCnxnFactory createFactory() throws IOException
{    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);    if (serverCnxnFactoryName == null) {        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();    }    try {        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();                return serverCnxnFactory;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + serverCnxnFactoryName, e);        throw ioe;    }}
1
public static ServerCnxnFactory createFactory(int clientPort, int maxClientCnxns) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, -1);}
0
public static ServerCnxnFactory createFactory(int clientPort, int maxClientCnxns, int backlog) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, backlog);}
0
public static ServerCnxnFactory createFactory(InetSocketAddress addr, int maxClientCnxns) throws IOException
{    return createFactory(addr, maxClientCnxns, -1);}
0
public static ServerCnxnFactory createFactory(InetSocketAddress addr, int maxClientCnxns, int backlog) throws IOException
{    ServerCnxnFactory factory = createFactory();    factory.configure(addr, maxClientCnxns, backlog);    return factory;}
0
public void unregisterConnection(ServerCnxn serverCnxn)
{    ConnectionBean jmxConnectionBean = connectionBeans.remove(serverCnxn);    if (jmxConnectionBean != null) {        MBeanRegistry.getInstance().unregister(jmxConnectionBean);    }}
0
public void registerConnection(ServerCnxn serverCnxn)
{    if (zkServer != null) {        ConnectionBean jmxConnectionBean = new ConnectionBean(serverCnxn, zkServer);        try {            MBeanRegistry.getInstance().register(jmxConnectionBean, zkServer.jmxServerBean);            connectionBeans.put(serverCnxn, jmxConnectionBean);        } catch (JMException e) {                    }    }}
1
protected void configureSaslLogin() throws IOException
{    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);        AppConfigurationEntry[] entries = null;    SecurityException securityException = null;    try {        entries = Configuration.getConfiguration().getAppConfigurationEntry(serverSection);    } catch (SecurityException e) {                securityException = e;    }        if (entries == null) {        String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);        String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);        if (securityException != null && (loginContextName != null || jaasFile != null)) {            String errorMessage = "No JAAS configuration section named '" + serverSection + "' was found";            if (jaasFile != null) {                errorMessage += " in '" + jaasFile + "'.";            }            if (loginContextName != null) {                errorMessage += " But " + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + " was set.";            }                        throw new IOException(errorMessage);        }        return;    }        try {        saslServerCallbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration());        login = new Login(serverSection, saslServerCallbackHandler, new ZKConfig());        login.startThreadIfNeeded();    } catch (LoginException e) {        throw new IOException("Could not configure server because SASL configuration did not allow the " + " ZooKeeper server to authenticate itself properly: " + e);    }}
1
public void parse(String[] args)
{    if (args.length < 2 || args.length > 4) {        throw new IllegalArgumentException("Invalid number of arguments:" + Arrays.toString(args));    }    clientPortAddress = new InetSocketAddress(Integer.parseInt(args[0]));    dataDir = new File(args[1]);    dataLogDir = dataDir;    if (args.length >= 3) {        tickTime = Integer.parseInt(args[2]);    }    if (args.length == 4) {        maxClientCnxns = Integer.parseInt(args[3]);    }}
0
public void parse(String path) throws ConfigException
{    QuorumPeerConfig config = new QuorumPeerConfig();    config.parse(path);            readFrom(config);}
0
public void readFrom(QuorumPeerConfig config)
{    clientPortAddress = config.getClientPortAddress();    secureClientPortAddress = config.getSecureClientPortAddress();    dataDir = config.getDataDir();    dataLogDir = config.getDataLogDir();    tickTime = config.getTickTime();    maxClientCnxns = config.getMaxClientCnxns();    minSessionTimeout = config.getMinSessionTimeout();    maxSessionTimeout = config.getMaxSessionTimeout();    jvmPauseMonitorToRun = config.isJvmPauseMonitorToRun();    jvmPauseInfoThresholdMs = config.getJvmPauseInfoThresholdMs();    jvmPauseWarnThresholdMs = config.getJvmPauseWarnThresholdMs();    jvmPauseSleepTimeMs = config.getJvmPauseSleepTimeMs();    metricsProviderClassName = config.getMetricsProviderClassName();    metricsProviderConfiguration = config.getMetricsProviderConfiguration();    listenBacklog = config.getClientPortListenBacklog();    initialConfig = config.getInitialConfig();}
0
public InetSocketAddress getClientPortAddress()
{    return clientPortAddress;}
0
public InetSocketAddress getSecureClientPortAddress()
{    return secureClientPortAddress;}
0
public File getDataDir()
{    return dataDir;}
0
public File getDataLogDir()
{    return dataLogDir;}
0
public int getTickTime()
{    return tickTime;}
0
public int getMaxClientCnxns()
{    return maxClientCnxns;}
0
public int getMinSessionTimeout()
{    return minSessionTimeout;}
0
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
0
public long getJvmPauseInfoThresholdMs()
{    return jvmPauseInfoThresholdMs;}
0
public long getJvmPauseWarnThresholdMs()
{    return jvmPauseWarnThresholdMs;}
0
public long getJvmPauseSleepTimeMs()
{    return jvmPauseSleepTimeMs;}
0
public boolean isJvmPauseMonitorToRun()
{    return jvmPauseMonitorToRun;}
0
public String getMetricsProviderClassName()
{    return metricsProviderClassName;}
0
public Properties getMetricsProviderConfiguration()
{    return metricsProviderConfiguration;}
0
public int getClientPortListenBacklog()
{    return listenBacklog;}
0
public static ServerMetrics getMetrics()
{    return CURRENT;}
0
public static void metricsProviderInitialized(MetricsProvider metricsProvider)
{        CURRENT = new ServerMetrics(metricsProvider);}
1
public void resetAll()
{    metricsProvider.resetAllValues();}
0
public MetricsProvider getMetricsProvider()
{    return metricsProvider;}
0
public long getMinLatency()
{    return requestLatency.getMin();}
0
public double getAvgLatency()
{    return requestLatency.getAvg();}
0
public long getMaxLatency()
{    return requestLatency.getMax();}
0
public long getOutstandingRequests()
{    return provider.getOutstandingRequests();}
0
public long getLastProcessedZxid()
{    return provider.getLastProcessedZxid();}
0
public long getDataDirSize()
{    return provider.getDataDirSize();}
0
public long getLogDirSize()
{    return provider.getLogDirSize();}
0
public long getPacketsReceived()
{    return packetsReceived.get();}
0
public long getPacketsSent()
{    return packetsSent.get();}
0
public String getServerState()
{    return provider.getState();}
0
public int getNumAliveClientConnections()
{    return provider.getNumAliveConnections();}
0
public long getUptime()
{    return Time.currentElapsedTime() - startTime;}
0
public boolean isProviderNull()
{    return provider == null;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Latency min/avg/max: " + getMinLatency() + "/" + getAvgLatency() + "/" + getMaxLatency() + "\n");    sb.append("Received: " + getPacketsReceived() + "\n");    sb.append("Sent: " + getPacketsSent() + "\n");    sb.append("Connections: " + getNumAliveClientConnections() + "\n");    if (provider != null) {        sb.append("Outstanding: " + getOutstandingRequests() + "\n");        sb.append("Zxid: 0x" + Long.toHexString(getLastProcessedZxid()) + "\n");    }    sb.append("Mode: " + getServerState() + "\n");    return sb.toString();}
0
public void updateLatency(Request request, long currentTime)
{    long latency = currentTime - request.createTime;    if (latency < 0) {        return;    }    requestLatency.addDataPoint(latency);    if (request.getHdr() != null) {                ServerMetrics.getMetrics().UPDATE_LATENCY.add(latency);    } else {                ServerMetrics.getMetrics().READ_LATENCY.add(latency);    }}
0
public void resetLatency()
{    requestLatency.reset();}
0
public void resetMaxLatency()
{    requestLatency.resetMax();}
0
public void incrementPacketsReceived()
{    packetsReceived.incrementAndGet();}
0
public void incrementPacketsSent()
{    packetsSent.incrementAndGet();}
0
public void resetRequestCounters()
{    packetsReceived.set(0);    packetsSent.set(0);}
0
public long getFsyncThresholdExceedCount()
{    return fsyncThresholdExceedCount.get();}
0
public void incrementFsyncThresholdExceedCount()
{    fsyncThresholdExceedCount.incrementAndGet();}
0
public void resetFsyncThresholdExceedCount()
{    fsyncThresholdExceedCount.set(0);}
0
public void reset()
{    resetLatency();    resetRequestCounters();    clientResponseStats.reset();    ServerMetrics.getMetrics().resetAll();}
0
public void updateClientResponseSize(int size)
{    clientResponseStats.setLastBufferSize(size);}
0
public BufferStats getClientResponseStats()
{    return clientResponseStats;}
0
public long getSessionId()
{    return sessionId;}
0
public int getTimeout()
{    return timeout;}
0
public boolean isClosing()
{    return isClosing;}
0
public String toString()
{    return "0x" + Long.toHexString(sessionId);}
0
public static long initializeNextSessionId(long id)
{    long nextSid;    nextSid = (Time.currentElapsedTime() << 24) >>> 8;    nextSid = nextSid | (id << 56);    if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {                ++nextSid;    }    return nextSid;}
0
public void dumpSessions(PrintWriter pwriter)
{    pwriter.print("Session ");    sessionExpiryQueue.dump(pwriter);}
0
public synchronized Map<Long, Set<Long>> getSessionExpiryMap()
{        Map<Long, Set<SessionImpl>> expiryMap = sessionExpiryQueue.getExpiryMap();    Map<Long, Set<Long>> sessionExpiryMap = new TreeMap<Long, Set<Long>>();    for (Entry<Long, Set<SessionImpl>> e : expiryMap.entrySet()) {        Set<Long> ids = new HashSet<Long>();        sessionExpiryMap.put(e.getKey(), ids);        for (SessionImpl s : e.getValue()) {            ids.add(s.sessionId);        }    }    return sessionExpiryMap;}
0
public String toString()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpSessions(pwriter);    pwriter.flush();    pwriter.close();    return sw.toString();}
0
public void run()
{    try {        while (running) {            long waitTime = sessionExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (SessionImpl s : sessionExpiryQueue.poll()) {                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(1);                setSessionClosing(s.sessionId);                expirer.expire(s);            }        }    } catch (InterruptedException e) {        handleException(this.getName(), e);    }    }
1
public synchronized boolean touchSession(long sessionId, int timeout)
{    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        logTraceTouchInvalidSession(sessionId, timeout);        return false;    }    if (s.isClosing()) {        logTraceTouchClosingSession(sessionId, timeout);        return false;    }    updateSessionExpiry(s, timeout);    return true;}
0
private void updateSessionExpiry(SessionImpl s, int timeout)
{    logTraceTouchSession(s.sessionId, timeout, "");    sessionExpiryQueue.update(s, timeout);}
0
private void logTraceTouchSession(long sessionId, int timeout, String sessionStatus)
{    if (!LOG.isTraceEnabled()) {        return;    }    String msg = MessageFormat.format("SessionTrackerImpl --- Touch {0}session: 0x{1} with timeout {2}", sessionStatus, Long.toHexString(sessionId), Integer.toString(timeout));    ZooTrace.logTraceMessage(LOG, ZooTrace.CLIENT_PING_TRACE_MASK, msg);}
0
private void logTraceTouchInvalidSession(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "invalid ");}
0
private void logTraceTouchClosingSession(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "closing ");}
0
public int getSessionTimeout(long sessionId)
{    return sessionsWithTimeout.get(sessionId);}
0
public synchronized void setSessionClosing(long sessionId)
{    if (LOG.isTraceEnabled()) {        LOG.trace("Session closing: 0x" + Long.toHexString(sessionId));    }    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        return;    }    s.isClosing = true;}
0
public synchronized void removeSession(long sessionId)
{    if (LOG.isDebugEnabled()) {            }    SessionImpl s = sessionsById.remove(sessionId);    sessionsWithTimeout.remove(sessionId);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- Removing session 0x" + Long.toHexString(sessionId));    }    if (s != null) {        sessionExpiryQueue.remove(s);    }}
1
public void shutdown()
{        running = false;    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "Shutdown SessionTrackerImpl!");    }}
1
public long createSession(int sessionTimeout)
{    long sessionId = nextSessionId.getAndIncrement();    trackSession(sessionId, sessionTimeout);    return sessionId;}
0
public synchronized boolean trackSession(long id, int sessionTimeout)
{    boolean added = false;    SessionImpl session = sessionsById.get(id);    if (session == null) {        session = new SessionImpl(id, sessionTimeout);    }            SessionImpl existedSession = sessionsById.putIfAbsent(id, session);    if (existedSession != null) {        session = existedSession;    } else {        added = true;        if (LOG.isDebugEnabled()) {                    }    }    if (LOG.isTraceEnabled()) {        String actionStr = added ? "Adding" : "Existing";        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- " + actionStr + " session 0x" + Long.toHexString(id) + " " + sessionTimeout);    }    updateSessionExpiry(session, sessionTimeout);    return added;}
1
public synchronized boolean commitSession(long id, int sessionTimeout)
{    return sessionsWithTimeout.put(id, sessionTimeout) == null;}
0
public boolean isTrackingSession(long sessionId)
{    return sessionsById.containsKey(sessionId);}
0
public synchronized void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException
{    if (LOG.isDebugEnabled()) {            }    SessionImpl session = sessionsById.get(sessionId);    if (session == null) {        throw new KeeperException.UnknownSessionException();    }    if (session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    if (session.owner == null) {        session.owner = owner;    } else if (session.owner != owner) {        throw new KeeperException.SessionMovedException();    }}
1
public synchronized void setOwner(long id, Object owner) throws SessionExpiredException
{    SessionImpl session = sessionsById.get(id);    if (session == null || session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    session.owner = owner;}
0
public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    try {        checkSession(sessionId, owner);    } catch (KeeperException.UnknownSessionException e) {        throw new KeeperException.SessionExpiredException();    }}
0
public long getLocalSessionCount()
{    return 0;}
0
public boolean isLocalSessionsEnabled()
{    return false;}
0
public static void main(String[] args) throws Exception
{    String snapshotFile = null;    boolean dumpData = false;    boolean dumpJson = false;    int i;    for (i = 0; i < args.length; i++) {        if (args[i].equals("-d")) {            dumpData = true;        } else if (args[i].equals("-json")) {            dumpJson = true;        } else {            snapshotFile = args[i];            i++;            break;        }    }    if (args.length != i || snapshotFile == null) {        System.err.println("USAGE: SnapshotFormatter [-d|-json] snapshot_file");        System.err.println("       -d dump the data for each znode");        System.err.println("       -json dump znode info in json format");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(snapshotFile);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    if (dumpData && dumpJson) {        System.err.println("Cannot specify both data dump (-d) and json mode (-json) in same call");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new SnapshotFormatter().run(snapshotFile, dumpData, dumpJson);}
0
public void run(String snapshotFileName, boolean dumpData, boolean dumpJson) throws IOException
{    File snapshotFile = new File(snapshotFileName);    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {        InputArchive ia = BinaryInputArchive.getArchive(is);        FileSnap fileSnap = new FileSnap(null);        DataTree dataTree = new DataTree();        Map<Long, Integer> sessions = new HashMap<Long, Integer>();        fileSnap.deserialize(dataTree, sessions, ia);        long fileNameZxid = Util.getZxidFromName(snapshotFile.getName(), SNAPSHOT_FILE_PREFIX);        if (dumpJson) {            printSnapshotJson(dataTree);        } else {            printDetails(dataTree, sessions, dumpData, fileNameZxid);        }    }}
0
private void printDetails(DataTree dataTree, Map<Long, Integer> sessions, boolean dumpData, long fileNameZxid)
{    long dtZxid = printZnodeDetails(dataTree, dumpData);    printSessionDetails(dataTree, sessions);    System.out.println(String.format("----%nLast zxid: 0x%s", Long.toHexString(Math.max(fileNameZxid, dtZxid))));}
0
private long printZnodeDetails(DataTree dataTree, boolean dumpData)
{    System.out.println(String.format("ZNode Details (count=%d):", dataTree.getNodeCount()));    final long zxid = printZnode(dataTree, "/", dumpData);    System.out.println("----");    return zxid;}
0
private long printZnode(DataTree dataTree, String name, boolean dumpData)
{    System.out.println("----");    DataNode n = dataTree.getNode(name);    Set<String> children;    long zxid;    synchronized (n) {                System.out.println(name);        printStat(n.stat);        zxid = Math.max(n.stat.getMzxid(), n.stat.getPzxid());        if (dumpData) {            System.out.println("  data = " + (n.data == null ? "" : Base64.getEncoder().encodeToString(n.data)));        } else {            System.out.println("  dataLength = " + (n.data == null ? 0 : n.data.length));        }        children = n.getChildren();    }    if (children != null) {        for (String child : children) {            long cxid = printZnode(dataTree, name + (name.equals("/") ? "" : "/") + child, dumpData);            zxid = Math.max(zxid, cxid);        }    }    return zxid;}
0
private void printSessionDetails(DataTree dataTree, Map<Long, Integer> sessions)
{    System.out.println("Session Details (sid, timeout, ephemeralCount):");    for (Map.Entry<Long, Integer> e : sessions.entrySet()) {        long sid = e.getKey();        System.out.println(String.format("%#016x, %d, %d", sid, e.getValue(), dataTree.getEphemerals(sid).size()));    }}
0
private void printStat(StatPersisted stat)
{    printHex("cZxid", stat.getCzxid());    System.out.println("  ctime = " + new Date(stat.getCtime()).toString());    printHex("mZxid", stat.getMzxid());    System.out.println("  mtime = " + new Date(stat.getMtime()).toString());    printHex("pZxid", stat.getPzxid());    System.out.println("  cversion = " + stat.getCversion());    System.out.println("  dataVersion = " + stat.getVersion());    System.out.println("  aclVersion = " + stat.getAversion());    printHex("ephemeralOwner", stat.getEphemeralOwner());}
0
private void printHex(String prefix, long value)
{    System.out.println(String.format("  %s = %#016x", prefix, value));}
0
private void printSnapshotJson(final DataTree dataTree)
{    System.out.printf("[1,0,{\"progname\":\"SnapshotFormatter.java\",\"progver\":\"0.01\",\"timestamp\":%d}", System.currentTimeMillis());    printZnodeJson(dataTree, "/");    System.out.print("]");}
0
private void printZnodeJson(final DataTree dataTree, final String fullPath)
{    final DataNode n = dataTree.getNode(fullPath);    if (null == n) {        System.err.println("DataTree Node for " + fullPath + " doesn't exist");        return;    }    final String name = fullPath.equals("/") ? fullPath : fullPath.substring(fullPath.lastIndexOf("/") + 1);    System.out.print(",");    int dataLen;    synchronized (n) {                dataLen = (n.data == null) ? 0 : n.data.length;    }    StringBuilder nodeSB = new StringBuilder();    nodeSB.append("{");    nodeSB.append("\"name\":\"").append(JSONValue.escape(name)).append("\"").append(",");    nodeSB.append("\"asize\":").append(dataLen).append(",");    nodeSB.append("\"dsize\":").append(dataLen).append(",");    nodeSB.append("\"dev\":").append(0).append(",");    nodeSB.append("\"ino\":").append(++INODE_IDX);    nodeSB.append("}");    Set<String> children;    synchronized (n) {                children = n.getChildren();    }    if (children != null && children.size() > 0) {        System.out.print("[" + nodeSB);        for (String child : children) {            printZnodeJson(dataTree, fullPath + (fullPath.equals("/") ? "" : "/") + child);        }        System.out.print("]");    } else {        System.out.print(nodeSB);    }}
0
public static void setSnapCount(int count)
{    snapCount = count;}
0
public static int getSnapCount()
{    return snapCount;}
0
private long getRemainingDelay()
{    long flushDelay = zks.getFlushDelay();    long duration = Time.currentElapsedTime() - lastFlushTime;    if (duration < flushDelay) {        return flushDelay - duration;    }    return 0;}
0
private boolean shouldFlush()
{    long flushDelay = zks.getFlushDelay();    long maxBatchSize = zks.getMaxBatchSize();    if ((flushDelay > 0) && (getRemainingDelay() == 0)) {        return true;    }    return (maxBatchSize > 0) && (toFlush.size() >= maxBatchSize);}
0
public static void setSnapSizeInBytes(long size)
{    snapSizeInBytes = size;}
0
private boolean shouldSnapshot()
{    int logCount = zks.getZKDatabase().getTxnCount();    long logSize = zks.getZKDatabase().getTxnSize();    return (logCount > (snapCount / 2 + randRoll)) || (snapSizeInBytes > 0 && logSize > (snapSizeInBytes / 2 + randSize));}
0
private void resetSnapshotStats()
{    randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2);    randSize = Math.abs(ThreadLocalRandom.current().nextLong() % (snapSizeInBytes / 2));}
0
public void run()
{    try {                        resetSnapshotStats();        lastFlushTime = Time.currentElapsedTime();        while (true) {            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);            if (si == null) {                /* We timed out looking for more writes to batch, go ahead and flush immediately */                flush();                si = queuedRequests.take();            }            if (si == REQUEST_OF_DEATH) {                break;            }            long startProcessTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);                        if (zks.getZKDatabase().append(si)) {                if (shouldSnapshot()) {                    resetSnapshotStats();                                        zks.getZKDatabase().rollLog();                                        if (!snapThreadMutex.tryAcquire()) {                                            } else {                        new ZooKeeperThread("Snapshot Thread") {                            public void run() {                                try {                                    zks.takeSnapshot();                                } catch (Exception e) {                                                                    } finally {                                    snapThreadMutex.release();                                }                            }                        }.start();                    }                }            } else if (toFlush.isEmpty()) {                                if (nextProcessor != null) {                    nextProcessor.processRequest(si);                    if (nextProcessor instanceof Flushable) {                        ((Flushable) nextProcessor).flush();                    }                }                continue;            }            toFlush.add(si);            if (shouldFlush()) {                flush();            }            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);        }    } catch (Throwable t) {        handleException(this.getName(), t);    }    }
1
public void run()
{    try {        zks.takeSnapshot();    } catch (Exception e) {            } finally {        snapThreadMutex.release();    }}
1
private void flush() throws IOException, RequestProcessorException
{    if (this.toFlush.isEmpty()) {        return;    }    ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());    long flushStartTime = Time.currentElapsedTime();    zks.getZKDatabase().commit();    ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);    if (this.nextProcessor == null) {        this.toFlush.clear();    } else {        while (!this.toFlush.isEmpty()) {            final Request i = this.toFlush.remove();            long latency = Time.currentElapsedTime() - i.syncQueueStartTime;            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);            this.nextProcessor.processRequest(i);        }        if (this.nextProcessor instanceof Flushable) {            ((Flushable) this.nextProcessor).flush();        }        lastFlushTime = Time.currentElapsedTime();    }}
0
public void shutdown()
{        queuedRequests.add(REQUEST_OF_DEATH);    try {        this.join();        this.flush();    } catch (InterruptedException e) {                Thread.currentThread().interrupt();    } catch (IOException e) {            } catch (RequestProcessorException e) {            }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
1
public void processRequest(final Request request)
{    Objects.requireNonNull(request, "Request cannot be null");    request.syncQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);    ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUED.add(1);}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("USAGE: TraceFormatter trace_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileChannel fc = new FileInputStream(args[0]).getChannel();    while (true) {        ByteBuffer bb = ByteBuffer.allocate(41);        fc.read(bb);        bb.flip();        byte app = bb.get();        long time = bb.getLong();        long id = bb.getLong();        int cxid = bb.getInt();        long zxid = bb.getLong();        int txnType = bb.getInt();        int type = bb.getInt();        int len = bb.getInt();        bb = ByteBuffer.allocate(len);        fc.read(bb);        bb.flip();        String path = "n/a";        if (bb.remaining() > 0) {            if (type != OpCode.createSession) {                int pathLen = bb.getInt();                byte[] b = new byte[pathLen];                bb.get(b);                path = new String(b);            }        }        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(time)) + ": " + (char) app + " id=0x" + Long.toHexString(id) + " cxid=" + cxid + " op=" + Request.op2String(type) + " zxid=0x" + Long.toHexString(zxid) + " txnType=" + txnType + " len=" + len + " path=" + path);    }}
0
public boolean hasNext()
{    return hasNext;}
0
public Proposal next()
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    Proposal p = new Proposal();    try {        TxnHeader hdr = itr.getHeader();        Record txn = itr.getTxn();        hdr.serialize(boa, "hdr");        if (txn != null) {            txn.serialize(boa, "txn");        }        baos.close();        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, itr.getHeader().getZxid(), baos.toByteArray(), null);        p.packet = pp;        p.request = null;                hasNext = itr.next();    } catch (IOException e) {                hasNext = false;    }    return p;}
1
public void remove()
{    throw new UnsupportedOperationException();}
0
public void close()
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {                    }    }}
1
public void processRequest(Request request) throws RequestProcessorException
{    KeeperException ke = new KeeperException.UnimplementedException();    request.setException(ke);    ReplyHeader rh = new ReplyHeader(request.cxid, request.zxid, ke.code().intValue());    try {        request.cnxn.sendResponse(rh, null, "response");    } catch (IOException e) {        throw new RequestProcessorException("Can't send the response", e);    }    request.cnxn.sendCloseSession();}
0
public void shutdown()
{}
0
public AdHash addDigest(long digest)
{    hash += digest;    return this;}
0
public AdHash removeDigest(long digest)
{    hash -= digest;    return this;}
0
public String toHexString()
{    return Long.toHexString(hash);}
0
public long getHash()
{    return hash;}
0
public boolean equals(Object other)
{    return other instanceof AdHash && ((AdHash) other).hash == this.hash;}
0
public int hashCode()
{    return Long.hashCode(hash);}
0
public String toString()
{    return toHexString();}
0
public synchronized boolean add(Integer elementBit)
{    if (elementBit == null || elementBits.get(elementBit)) {        return false;    }    if (cache.size() < cacheSize) {        cache.add(elementBit);    }    elementBits.set(elementBit);    elementCount++;    return true;}
0
public synchronized int remove(Set<Integer> bitSet, BitSet bits)
{    cache.removeAll(bitSet);    elementBits.andNot(bits);    int elementCountBefore = elementCount;    elementCount = elementBits.cardinality();    return elementCountBefore - elementCount;}
0
public synchronized boolean remove(Integer elementBit)
{    if (elementBit == null || !elementBits.get(elementBit)) {        return false;    }    cache.remove(elementBit);    elementBits.clear(elementBit);    elementCount--;    return true;}
0
public synchronized boolean contains(Integer elementBit)
{    if (elementBit == null) {        return false;    }    return elementBits.get(elementBit);}
0
public synchronized int size()
{    return elementCount;}
0
public Iterator<Integer> iterator()
{        int currentSize = size();    if (cache.size() == currentSize) {        return cache.iterator();    }    return new Iterator<Integer>() {        int returnedCount = 0;        int bitIndex = 0;        @Override        public boolean hasNext() {            return returnedCount < currentSize;        }        @Override        public Integer next() {            int bit = elementBits.nextSetBit(bitIndex);            bitIndex = bit + 1;            returnedCount++;            return bit;        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
0
public boolean hasNext()
{    return returnedCount < currentSize;}
0
public Integer next()
{    int bit = elementBits.nextSetBit(bitIndex);    bitIndex = bit + 1;    returnedCount++;    return bit;}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
public synchronized int cachedSize()
{    return cache.size();}
0
public synchronized boolean isEmpty()
{    return elementCount == 0;}
0
public Integer add(T value)
{    /*         * Optimized for code which will add the same value again and again,         * more specifically this is used to add new bit for watcher, and         * the same watcher may watching thousands or even millions of nodes,         * which will call add the same value of this function, check exist         * using read lock will optimize the performance here.         */    Integer bit = getBit(value);    if (bit != null) {        return bit;    }    rwLock.writeLock().lock();    try {        bit = value2Bit.get(value);        if (bit != null) {            return bit;        }        bit = freedBitSet.nextSetBit(0);        if (bit > -1) {            freedBitSet.clear(bit);        } else {            bit = nextBit++;        }        value2Bit.put(value, bit);        bit2Value.put(bit, value);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
0
public T get(int bit)
{    rwLock.readLock().lock();    try {        return bit2Value.get(bit);    } finally {        rwLock.readLock().unlock();    }}
0
public Integer getBit(T value)
{    rwLock.readLock().lock();    try {        return value2Bit.get(value);    } finally {        rwLock.readLock().unlock();    }}
0
public int remove(T value)
{    /*         * remove only called once when the session is closed, so use write         * lock directly without checking read lock.         */    rwLock.writeLock().lock();    try {        Integer bit = value2Bit.get(value);        if (bit == null) {            return -1;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
0
public T remove(int bit)
{    rwLock.writeLock().lock();    try {        T value = bit2Value.get(bit);        if (value == null) {            return null;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return value;    } finally {        rwLock.writeLock().unlock();    }}
0
public int size()
{    rwLock.readLock().lock();    try {        return value2Bit.size();    } finally {        rwLock.readLock().unlock();    }}
0
public synchronized void write(T element)
{    int newSize = numberOfElements.incrementAndGet();    if (newSize > capacity) {        buffer[oldest] = element;        oldest = ++oldest % capacity;        numberOfElements.decrementAndGet();    } else {        int index = (oldest + numberOfElements.get() - 1) % capacity;        buffer[index] = element;    }}
0
public synchronized T take()
{    int newSize = numberOfElements.decrementAndGet();    if (newSize < 0) {        numberOfElements.incrementAndGet();        return null;    }    T polled = buffer[oldest];    oldest = ++oldest % capacity;    return polled;}
0
public synchronized T peek()
{    if (numberOfElements.get() <= 0) {        return null;    }    return buffer[oldest];}
0
public int size()
{    return numberOfElements.get();}
0
public boolean isEmpty()
{    return numberOfElements.get() <= 0;}
0
public boolean isFull()
{    return numberOfElements.get() >= capacity;}
0
public synchronized void reset()
{    numberOfElements.set(0);}
0
public static String getClientConfigStr(String configData)
{    Properties props = new Properties();    try {        props.load(new StringReader(configData));    } catch (IOException e) {        e.printStackTrace();        return "";    }    StringBuffer sb = new StringBuffer();    boolean first = true;    String version = "";    for (Entry<Object, Object> entry : props.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("version")) {            version = value;        }        if (!key.startsWith("server.")) {            continue;        }        QuorumPeer.QuorumServer qs;        try {            qs = new QuorumPeer.QuorumServer(-1, value);        } catch (ConfigException e) {            e.printStackTrace();            continue;        }        if (!first) {            sb.append(",");        } else {            first = false;        }        if (null != qs.clientAddr) {            sb.append(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort());        }    }    return version + " " + sb.toString();}
0
public static String[] getHostAndPort(String s) throws ConfigException
{    if (s.startsWith("[")) {        int i = s.indexOf("]");        if (i < 0) {            throw new ConfigException(s + " starts with '[' but has no matching ']:'");        }        if (i + 2 == s.length()) {            throw new ConfigException(s + " doesn't have a port after colon");        }        if (i + 2 < s.length()) {            String[] sa = s.substring(i + 2).split(":");            String[] nsa = new String[sa.length + 1];            nsa[0] = s.substring(1, i);            System.arraycopy(sa, 0, nsa, 1, sa.length);            return nsa;        }        return new String[] { s.replaceAll("\\[|\\]", "") };    } else {        return s.split(":");    }}
0
public void serviceStart()
{    monitorThread = new Thread(new JVMMonitor());    monitorThread.setDaemon(true);    monitorThread.start();}
0
public void serviceStop()
{    shouldRun = false;    if (monitorThread != null) {        monitorThread.interrupt();        try {            monitorThread.join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }}
0
public boolean isStarted()
{    return monitorThread != null;}
0
public long getNumGcWarnThresholdExceeded()
{    return numGcWarnThresholdExceeded;}
0
public long getNumGcInfoThresholdExceeded()
{    return numGcInfoThresholdExceeded;}
0
public long getTotalGcExtraSleepTime()
{    return totalGcExtraSleepTime;}
0
private String formatMessage(long extraSleepTime, Map<String, GcTimes> gcTimesAfterSleep, Map<String, GcTimes> gcTimesBeforeSleep)
{    Set<String> gcBeanNames = new HashSet<>(gcTimesAfterSleep.keySet());    gcBeanNames.retainAll(gcTimesBeforeSleep.keySet());    List<String> gcDiffs = new ArrayList<>();    for (String name : gcBeanNames) {        GcTimes diff = gcTimesAfterSleep.get(name).subtract(gcTimesBeforeSleep.get(name));        if (diff.gcCount != 0) {            gcDiffs.add("GC pool '" + name + "' had collection(s): " + diff.toString());        }    }    String ret = String.format("Detected pause in JVM or host machine (eg GC): pause of approximately %d ms, " + "total pause: info level: %d, warn level: %d %n", extraSleepTime, numGcInfoThresholdExceeded, numGcWarnThresholdExceeded);    if (gcDiffs.isEmpty()) {        ret += ("No GCs detected");    } else {        ret += String.join("\n", gcDiffs);    }    return ret;}
0
private Map<String, GcTimes> getGcTimes()
{    Map<String, GcTimes> map = new HashMap<>();    List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();    for (GarbageCollectorMXBean gcBean : gcBeans) {        map.put(gcBean.getName(), new GcTimes(gcBean));    }    return map;}
0
private GcTimes subtract(GcTimes other)
{    return new GcTimes(this.gcCount - other.gcCount, this.gcTimeMillis - other.gcTimeMillis);}
0
public String toString()
{    return "count=" + gcCount + " time=" + gcTimeMillis + "ms";}
0
public void run()
{    Map<String, GcTimes> gcTimesBeforeSleep = getGcTimes();        while (shouldRun) {        long startTime = Instant.now().toEpochMilli();        try {            Thread.sleep(sleepTimeMs);        } catch (InterruptedException ie) {            return;        }        long endTime = Instant.now().toEpochMilli();        long extraSleepTime = (endTime - startTime) - sleepTimeMs;        Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();        if (extraSleepTime > warnThresholdMs) {            ++numGcWarnThresholdExceeded;                    } else if (extraSleepTime > infoThresholdMs) {            ++numGcInfoThresholdExceeded;                    }        totalGcExtraSleepTime += extraSleepTime;        gcTimesBeforeSleep = gcTimesAfterSleep;    }}
1
public static String getDefaultRealm() throws IllegalArgumentException
{    return new KerberosPrincipal("tmp", 1).getRealm();}
0
public static void main(String[] args)
{    ExitCode rc = ExitCode.INVALID_INVOCATION;    if (args.length != 3) {        System.out.println("Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename");        System.out.println("    this program will read the txn_log_to_chop file and copy all the transactions");        System.out.println("    from it up to (and including) the given zxid into chopped_filename.");        System.exit(rc.getValue());    }    String txnLog = args[1];    String choppedLog = args[2];    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLog));        OutputStream os = new BufferedOutputStream(new FileOutputStream(choppedLog))) {        long zxid = Long.decode(args[0]);        if (chop(is, os, zxid)) {            rc = ExitCode.EXECUTION_FINISHED;        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }    System.exit(rc.getValue());}
0
public static boolean chop(InputStream is, OutputStream os, long zxid) throws IOException
{    BinaryInputArchive logStream = BinaryInputArchive.getArchive(is);    BinaryOutputArchive choppedStream = BinaryOutputArchive.getArchive(os);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number in txn log file");        return false;    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    fhdr.serialize(choppedStream, "fileheader");    int count = 0;    boolean hasZxid = false;    long previousZxid = -1;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");                        return false;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");                        return false;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        if (logStream.readByte("EOR") != 'B') {            System.out.println("Last transaction was partial.");            throw new EOFException("Last transaction was partial.");        }        final long txnZxid = hdr.getZxid();        if (txnZxid == zxid) {            hasZxid = true;        }                if (previousZxid != -1 && txnZxid != previousZxid + 1) {            long txnEpoch = ZxidUtils.getEpochFromZxid(txnZxid);            long txnCounter = ZxidUtils.getCounterFromZxid(txnZxid);            long previousEpoch = ZxidUtils.getEpochFromZxid(previousZxid);            if (txnEpoch == previousEpoch) {                System.out.println(String.format("There is intra-epoch gap between %x and %x", previousZxid, txnZxid));            } else if (txnCounter != 1) {                System.out.println(String.format("There is inter-epoch gap between %x and %x", previousZxid, txnZxid));            }        }        previousZxid = txnZxid;        if (txnZxid > zxid) {            if (count == 0 || !hasZxid) {                System.out.println(String.format("This log does not contain zxid %x", zxid));                return false;            }            System.out.println(String.format("Chopping at %x new log has %d records", zxid, count));            return true;        }        choppedStream.writeLong(crcValue, "crcvalue");        choppedStream.writeBuffer(bytes, "txnEntry");        choppedStream.writeByte((byte) 'B', "EOR");        count++;    }}
0
public void trackSent(long timestamp)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(timestamp));    }}
0
public void trackSent(int packetType)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(packetType));    }}
0
public void trackReceived(long timestamp)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(timestamp));    }}
0
public void trackReceived(int packetType)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(packetType));    }}
0
public final BufferedMessage peekSent()
{    return sentBuffer.peek();}
0
public final BufferedMessage peekReceived()
{    return receivedBuffer.peek();}
0
public final long peekSentTimestamp()
{    return enabled ? sentBuffer.peek().getTimestamp() : 0;}
0
public final long peekReceivedTimestamp()
{    return enabled ? receivedBuffer.peek().getTimestamp() : 0;}
0
public void dumpToLog(String serverAddress)
{    if (!enabled) {        return;    }    logMessages(serverAddress, receivedBuffer, Direction.RECEIVED);    logMessages(serverAddress, sentBuffer, Direction.SENT);}
0
private static void logMessages(String serverAddr, CircularBuffer<BufferedMessage> messages, Direction direction)
{    String sentOrReceivedText = direction == Direction.SENT ? "sentBuffer to" : "receivedBuffer from";    if (messages.isEmpty()) {            } else {                while (!messages.isEmpty()) {                    }    }}
1
private long getTimestamp()
{    return timestamp;}
0
public String toString()
{    if (messageType == -1) {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp));    } else {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp)) + " Type: " + Leader.getPacketType(messageType);    }}
0
public boolean getUnix()
{    if (windows) {        return false;    }    return (!ibmvendor || linux);}
0
private Long getOSUnixMXBeanMethod(String mBeanMethodName)
{    Object unixos;    Class<?> classRef;    Method mBeanMethod;    try {        classRef = Class.forName("com.sun.management.UnixOperatingSystemMXBean");        if (classRef.isInstance(osMbean)) {            mBeanMethod = classRef.getDeclaredMethod(mBeanMethodName);            unixos = classRef.cast(osMbean);            return (Long) mBeanMethod.invoke(unixos);        }    } catch (Exception e) {            }    return null;}
1
public long getOpenFileDescriptorCount()
{    Long ofdc;    if (!ibmvendor) {        ofdc = getOSUnixMXBeanMethod("getOpenFileDescriptorCount");        return (ofdc != null ? ofdc.longValue() : -1);    }    try {                RuntimeMXBean rtmbean = ManagementFactory.getRuntimeMXBean();        String rtname = rtmbean.getName();        String[] pidhost = rtname.split("@");                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ls /proc/" + pidhost[0] + "/fdinfo | wc -l" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String openFileDesCount;            if ((openFileDesCount = output.readLine()) != null) {                return Long.parseLong(openFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {            }    return -1;}
1
public long getMaxFileDescriptorCount()
{    Long mfdc;    if (!ibmvendor) {        mfdc = getOSUnixMXBeanMethod("getMaxFileDescriptorCount");        return (mfdc != null ? mfdc.longValue() : -1);    }    try {                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ulimit -n" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String maxFileDesCount;            if ((maxFileDesCount = output.readLine()) != null) {                return Long.parseLong(maxFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {            }    return -1;}
1
 static boolean isWriteOp(int requestType)
{    switch(requestType) {        case ZooDefs.OpCode.sync:        case ZooDefs.OpCode.create:        case ZooDefs.OpCode.create2:        case ZooDefs.OpCode.createContainer:        case ZooDefs.OpCode.delete:        case ZooDefs.OpCode.deleteContainer:        case ZooDefs.OpCode.setData:        case ZooDefs.OpCode.reconfig:        case ZooDefs.OpCode.setACL:        case ZooDefs.OpCode.multi:        case ZooDefs.OpCode.check:            return true;    }    return false;}
0
 static String trimPathDepth(String path, int maxDepth)
{    int count = 0;    StringBuilder sb = new StringBuilder();    StringTokenizer pathTokenizer = new StringTokenizer(path, PATH_SEPERATOR);    while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {        sb.append(PATH_SEPERATOR);        sb.append(pathTokenizer.nextToken());    }    path = sb.toString();    return path;}
0
public void shutdown()
{    if (!enabled) {        return;    }        scheduledExecutor.shutdownNow();}
1
public void registerRequest(int type, String path)
{    if (!enabled) {        return;    }    if (sampler.nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));        if (pathStatsQueue != null) {            pathStatsQueue.registerRequest(path);        } else {                    }    }}
1
public void dumpTopRequestPath(PrintWriter pwriter, String requestTypeName, int queryMaxDepth)
{    if (queryMaxDepth < 1) {        return;    }    PathStatsQueue pathStatsQueue = immutableRequestsMap.get(requestTypeName);    if (pathStatsQueue == null) {        pwriter.println("Can not find path stats for type: " + requestTypeName);        return;    } else {        pwriter.println("The top requests of type: " + requestTypeName);    }    Map<String, Integer> combinedMap;    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    combinedMap = pathStatsQueue.collectStats(maxDepth);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
0
public void dumpTopReadPaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top read requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> !queue.isWriteOperation);}
0
public void dumpTopWritePaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top write requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> queue.isWriteOperation);}
0
public void dumpTopPaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> true);}
0
private void dumpTopAggregatedPaths(PrintWriter pwriter, int queryMaxDepth, final Predicate<PathStatsQueue> predicate)
{    if (!enabled) {        return;    }    final Map<String, Integer> combinedMap = aggregatePaths(queryMaxDepth, predicate);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
0
 Map<String, Integer> aggregatePaths(int queryMaxDepth, Predicate<PathStatsQueue> predicate)
{    final Map<String, Integer> combinedMap = new HashMap<>(REQUEST_PREPROCESS_TOPPATH_MAX);    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    immutableRequestsMap.values().stream().filter(predicate).forEach(pathStatsQueue -> pathStatsQueue.collectStats(maxDepth).forEach((path, count) -> combinedMap.put(path, combinedMap.getOrDefault(path, 0) + count)));    return combinedMap;}
0
 void logTopPaths(Map<String, Integer> combinedMap, final Consumer<Map.Entry<String, Integer>> output)
{    combinedMap.entrySet().stream().sorted(Comparator.comparing(Map.Entry<String, Integer>::getValue).reversed()).limit(REQUEST_PREPROCESS_TOPPATH_MAX).forEach(output);}
0
public void registerRequest(String path)
{    if (!enabled) {        return;    }    currentSlot.get().offer(path);}
0
 ConcurrentLinkedQueue<String> getCurrentSlot()
{    return currentSlot.get();}
0
 Map<String, Integer> mapReducePaths(int maxDepth, Collection<String> tobeProcessedSlot)
{    Map<String, Integer> newSlot = new ConcurrentHashMap<>();    tobeProcessedSlot.stream().filter(path -> path != null).forEach((path) -> {        path = trimPathDepth(path, maxDepth);        newSlot.put(path, newSlot.getOrDefault(path, 0) + 1);    });    return newSlot;}
0
public Map<String, Integer> collectStats(int maxDepth)
{    Map<String, Integer> combinedMap;            Map<String, Integer> snapShot = mapReducePaths(maxDepth, Arrays.asList(currentSlot.get().toArray(new String[0])));        synchronized (accurateMode ? requestPathStats : new Object()) {        combinedMap = requestPathStats.stream().reduce(snapShot, (firstMap, secondMap) -> {            secondMap.forEach((key, value) -> {                String trimmedPath = trimPathDepth(key, maxDepth);                firstMap.put(trimmedPath, firstMap.getOrDefault(trimmedPath, 0) + value);            });            return firstMap;        });    }    return combinedMap;}
0
public void start()
{    if (!enabled) {        return;    }        int delay = sampler.nextInt(REQUEST_STATS_SLOT_DURATION);            scheduledExecutor.scheduleWithFixedDelay(() -> {                ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());        try {                                    Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);            synchronized (accurateMode ? requestPathStats : new Object()) {                if (requestPathStats.remainingCapacity() <= 0) {                    requestPathStats.poll();                }                if (!requestPathStats.offer(latestSlot)) {                                    }            }        } catch (Exception e) {                    }    }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);}
1
 boolean isWriteOperation()
{    return isWriteOperation;}
0
public static Record deserializeTxn(byte[] txnBytes, TxnHeader hdr) throws IOException
{    final ByteArrayInputStream bais = new ByteArrayInputStream(txnBytes);    InputArchive ia = BinaryInputArchive.getArchive(bais);    hdr.deserialize(ia, "hdr");    bais.mark(bais.available());    Record txn = null;    switch(hdr.getType()) {        case OpCode.createSession:                                    txn = new CreateSessionTxn();            break;        case OpCode.closeSession:            txn = ZooKeeperServer.isCloseSessionTxnEnabled() ? new CloseSessionTxn() : null;            break;        case OpCode.create:        case OpCode.create2:            txn = new CreateTxn();            break;        case OpCode.createTTL:            txn = new CreateTTLTxn();            break;        case OpCode.createContainer:            txn = new CreateContainerTxn();            break;        case OpCode.delete:        case OpCode.deleteContainer:            txn = new DeleteTxn();            break;        case OpCode.reconfig:        case OpCode.setData:            txn = new SetDataTxn();            break;        case OpCode.setACL:            txn = new SetACLTxn();            break;        case OpCode.error:            txn = new ErrorTxn();            break;        case OpCode.multi:            txn = new MultiTxn();            break;        default:            throw new IOException("Unsupported Txn with type=%d" + hdr.getType());    }    if (txn != null) {        try {            txn.deserialize(ia, "txn");        } catch (EOFException e) {                        if (hdr.getType() == OpCode.create) {                CreateTxn create = (CreateTxn) txn;                bais.reset();                CreateTxnV0 createv0 = new CreateTxnV0();                createv0.deserialize(ia, "txn");                                                create.setPath(createv0.getPath());                create.setData(createv0.getData());                create.setAcl(createv0.getAcl());                create.setEphemeral(createv0.getEphemeral());                create.setParentCVersion(-1);            } else if (hdr.getType() == OpCode.closeSession) {                                                txn = null;            } else {                throw e;            }        }    }    return txn;}
0
public static void deserializeSnapshot(DataTree dt, InputArchive ia, Map<Long, Integer> sessions) throws IOException
{    int count = ia.readInt("count");    while (count > 0) {        long id = ia.readLong("id");        int to = ia.readInt("timeout");        sessions.put(id, to);        if (LOG.isTraceEnabled()) {            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "loadData --- session in archive: " + id + " with timeout: " + to);        }        count--;    }    dt.deserialize(ia, "tree");}
0
public static void serializeSnapshot(DataTree dt, OutputArchive oa, Map<Long, Integer> sessions) throws IOException
{    HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(sessions);    oa.writeInt(sessSnap.size(), "count");    for (Entry<Long, Integer> entry : sessSnap.entrySet()) {        oa.writeLong(entry.getKey().longValue(), "id");        oa.writeInt(entry.getValue().intValue(), "timeout");    }    dt.serialize(oa, "tree");}
0
public static byte[] serializeRequest(Request request)
{    if (request == null || request.getHdr() == null) {        return null;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    try {        request.getHdr().serialize(boa, "hdr");        if (request.getTxn() != null) {            request.getTxn().serialize(boa, "txn");        }    } catch (IOException e) {            } finally {        IOUtils.cleanup(LOG, baos);    }    return baos.toByteArray();}
1
public File create(String path)
{    File file = new File(path);    return validate(file);}
0
public File validate(File file)
{    if (warnForRelativePath) {        doWarnForRelativePath(file);    }    if (failForNonExistingPath) {        doFailForNonExistingPath(file);    }    return file;}
0
private void doFailForNonExistingPath(File file)
{    if (!file.exists()) {        throw new IllegalArgumentException(file.toString() + " file is missing");    }}
0
private void doWarnForRelativePath(File file)
{    if (file.isAbsolute()) {        return;    }    if (file.getPath().substring(0, 2).equals("." + File.separator)) {        return;    }    }
1
public Builder warnForRelativePath()
{    warnForRelativePathOption = true;    return this;}
0
public Builder failForNonExistingPath()
{    failForNonExistingPathOption = true;    return this;}
0
public VerifyingFileFactory build()
{    return new VerifyingFileFactory(this);}
0
public static long getEpochFromZxid(long zxid)
{    return zxid >> 32L;}
0
public static long getCounterFromZxid(long zxid)
{    return zxid & 0xffffffffL;}
0
public static long makeZxid(long epoch, long counter)
{    return (epoch << 32L) | (counter & 0xffffffffL);}
0
public static String zxidToString(long zxid)
{    return Long.toHexString(zxid);}
0
public void addDeadWatcher(int watcherBit)
{        while (maxInProcessingDeadWatchers > 0 && !stopped && totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {        try {            RATE_LOGGER.rateLimitLog("Waiting for dead watchers cleaning");            long startTime = Time.currentElapsedTime();            synchronized (processingCompletedEvent) {                processingCompletedEvent.wait(100);            }            long latency = Time.currentElapsedTime() - startTime;            ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);        } catch (InterruptedException e) {                        break;        }    }    synchronized (this) {        if (deadWatchers.add(watcherBit)) {            totalDeadWatchers.incrementAndGet();            ServerMetrics.getMetrics().DEAD_WATCHERS_QUEUED.add(1);            if (deadWatchers.size() >= watcherCleanThreshold) {                synchronized (cleanEvent) {                    cleanEvent.notifyAll();                }            }        }    }}
1
public void run()
{    while (!stopped) {        synchronized (cleanEvent) {            try {                                if (!stopped && deadWatchers.size() < watcherCleanThreshold) {                    int maxWaitMs = (watcherCleanIntervalInSeconds + r.nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;                    cleanEvent.wait(maxWaitMs);                }            } catch (InterruptedException e) {                                break;            }        }        if (deadWatchers.isEmpty()) {            continue;        }        synchronized (this) {                                                                        final Set<Integer> snapshot = new HashSet<Integer>(deadWatchers);            deadWatchers.clear();            int total = snapshot.size();                        cleaners.schedule(new WorkRequest() {                @Override                public void doWork() throws Exception {                    long startTime = Time.currentElapsedTime();                    listener.processDeadWatchers(snapshot);                    long latency = Time.currentElapsedTime() - startTime;                                        ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);                    totalDeadWatchers.addAndGet(-total);                    synchronized (processingCompletedEvent) {                        processingCompletedEvent.notifyAll();                    }                }            });        }    }    }
1
public void doWork() throws Exception
{    long startTime = Time.currentElapsedTime();    listener.processDeadWatchers(snapshot);    long latency = Time.currentElapsedTime() - startTime;        ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);    totalDeadWatchers.addAndGet(-total);    synchronized (processingCompletedEvent) {        processingCompletedEvent.notifyAll();    }}
1
public void shutdown()
{    stopped = true;    deadWatchers.clear();    cleaners.stop();    this.interrupt();    if (LOG.isInfoEnabled()) {            }}
1
public boolean contains(Watcher watcher)
{    if (watchers == null) {        return false;    }    return watchers.contains(watcher);}
0
public boolean contains(int watcherBit)
{    if (watcherBits == null) {        return false;    }    return watcherBits.contains(watcherBit);}
0
public int size()
{    if (watchers != null) {        return watchers.size();    }    if (watcherBits != null) {        return watcherBits.size();    }    return 0;}
0
private static Map<String, Set<Long>> deepCopy(Map<String, Set<Long>> m)
{    Map<String, Set<Long>> m2 = new HashMap<String, Set<Long>>();    for (Map.Entry<String, Set<Long>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<Long>(e.getValue()));    }    return m2;}
0
public boolean hasSessions(String path)
{    return path2Ids.containsKey(path);}
0
public Set<Long> getSessions(String path)
{    Set<Long> s = path2Ids.get(path);    return s != null ? Collections.unmodifiableSet(s) : null;}
0
public Map<String, Set<Long>> toMap()
{    return deepCopy(path2Ids);}
0
private static Map<Long, Set<String>> deepCopy(Map<Long, Set<String>> m)
{    Map<Long, Set<String>> m2 = new HashMap<Long, Set<String>>();    for (Map.Entry<Long, Set<String>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<String>(e.getValue()));    }    return m2;}
0
public boolean hasPaths(long sessionId)
{    return id2paths.containsKey(sessionId);}
0
public Set<String> getPaths(long sessionId)
{    Set<String> s = id2paths.get(sessionId);    return s != null ? Collections.unmodifiableSet(s) : null;}
0
public Map<Long, Set<String>> toMap()
{    return deepCopy(id2paths);}
0
public int getNumConnections()
{    return numConnections;}
0
public int getNumPaths()
{    return numPaths;}
0
public int getTotalWatches()
{    return totalWatches;}
0
public Map<String, Object> toMap()
{    Map<String, Object> summary = new LinkedHashMap<String, Object>();    summary.put(KEY_NUM_CONNECTIONS, numConnections);    summary.put(KEY_NUM_PATHS, numPaths);    summary.put(KEY_NUM_TOTAL_WATCHES, totalWatches);    return summary;}
0
public synchronized int size()
{    int result = 0;    for (Set<Watcher> watches : watchTable.values()) {        result += watches.size();    }    return result;}
0
 boolean isDeadWatcher(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
0
public synchronized boolean addWatch(String path, Watcher watcher)
{    if (isDeadWatcher(watcher)) {                return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null) {                                list = new HashSet<Watcher>(4);        watchTable.put(path, list);    }    list.add(watcher);    Set<String> paths = watch2Paths.get(watcher);    if (paths == null) {                paths = new HashSet<String>();        watch2Paths.put(watcher, paths);    }    return paths.add(path);}
1
public synchronized void removeWatcher(Watcher watcher)
{    Set<String> paths = watch2Paths.remove(watcher);    if (paths == null) {        return;    }    for (String p : paths) {        Set<Watcher> list = watchTable.get(p);        if (list != null) {            list.remove(watcher);            if (list.isEmpty()) {                watchTable.remove(p);            }        }    }}
0
public WatcherOrBitSet triggerWatch(String path, EventType type)
{    return triggerWatch(path, type, null);}
0
public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet supress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    Set<Watcher> watchers;    synchronized (this) {        watchers = watchTable.remove(path);        if (watchers == null || watchers.isEmpty()) {            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "No watchers for " + path);            }            return null;        }        for (Watcher w : watchers) {            Set<String> paths = watch2Paths.get(w);            if (paths != null) {                paths.remove(path);            }        }    }    for (Watcher w : watchers) {        if (supress != null && supress.contains(w)) {            continue;        }        w.process(e);    }    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(watchers.size());            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(watchers.size());            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(watchers.size());            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(watchers.size());            break;        default:                        break;    }    return new WatcherOrBitSet(watchers);}
0
public synchronized String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(watch2Paths.size()).append(" connections watching ").append(watchTable.size()).append(" paths\n");    int total = 0;    for (Set<String> paths : watch2Paths.values()) {        total += paths.size();    }    sb.append("Total watches:").append(total);    return sb.toString();}
0
public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {            pwriter.println(e.getKey());            for (Watcher w : e.getValue()) {                pwriter.print("\t0x");                pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                pwriter.print("\n");            }        }    } else {        for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
0
public synchronized boolean containsWatcher(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    return paths != null && paths.contains(path);}
0
public synchronized boolean removeWatcher(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    if (paths == null || !paths.remove(path)) {        return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null || !list.remove(watcher)) {        return false;    }    if (list.isEmpty()) {        watchTable.remove(path);    }    return true;}
0
public synchronized WatchesReport getWatches()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
0
public synchronized WatchesPathReport getWatchesByPath()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {        Set<Long> ids = new HashSet<Long>(e.getValue().size());        path2ids.put(e.getKey(), ids);        for (Watcher watcher : e.getValue()) {            ids.add(((ServerCnxn) watcher).getSessionId());        }    }    return new WatchesPathReport(path2ids);}
0
public synchronized WatchesSummary getWatchesSummary()
{    int totalWatches = 0;    for (Set<String> paths : watch2Paths.values()) {        totalWatches += paths.size();    }    return new WatchesSummary(watch2Paths.size(), watchTable.size(), totalWatches);}
0
public void shutdown()
{/* do nothing */}
0
public static IWatchManager createWatchManager() throws IOException
{    String watchManagerName = System.getProperty(ZOOKEEPER_WATCH_MANAGER_NAME);    if (watchManagerName == null) {        watchManagerName = WatchManager.class.getName();    }    try {        IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();                return watchManager;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + watchManagerName, e);        throw ioe;    }}
1
public boolean addWatch(String path, Watcher watcher)
{    boolean result = false;                        addRemovePathRWLock.readLock().lock();    try {                if (isDeadWatcher(watcher)) {                    } else {            Integer bit = watcherBitIdMap.add(watcher);            BitHashSet watchers = pathWatches.get(path);            if (watchers == null) {                watchers = new BitHashSet();                BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);                                if (existingWatchers != null) {                    watchers = existingWatchers;                }            }            result = watchers.add(bit);        }    } finally {        addRemovePathRWLock.readLock().unlock();    }    return result;}
1
public boolean containsWatcher(String path, Watcher watcher)
{    BitHashSet watchers = pathWatches.get(path);    return watchers != null && watchers.contains(watcherBitIdMap.getBit(watcher));}
0
public boolean removeWatcher(String path, Watcher watcher)
{                        addRemovePathRWLock.writeLock().lock();    try {        BitHashSet list = pathWatches.get(path);        if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {            return false;        }        if (list.isEmpty()) {            pathWatches.remove(path);        }        return true;    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
0
public void removeWatcher(Watcher watcher)
{    Integer watcherBit;            addRemovePathRWLock.writeLock().lock();    try {                watcherBit = watcherBitIdMap.getBit(watcher);        if (watcherBit == null) {            return;        }    } finally {        addRemovePathRWLock.writeLock().unlock();    }                                            watcherCleaner.addDeadWatcher(watcherBit);}
0
public void processDeadWatchers(Set<Integer> deadWatchers)
{                BitSet bits = new BitSet();    for (int dw : deadWatchers) {        bits.set(dw);    }        for (BitHashSet watchers : pathWatches.values()) {        watchers.remove(deadWatchers, bits);    }        for (Integer wbit : deadWatchers) {        watcherBitIdMap.remove(wbit);    }}
0
public WatcherOrBitSet triggerWatch(String path, EventType type)
{    return triggerWatch(path, type, null);}
0
public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet suppress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    BitHashSet watchers = remove(path);    if (watchers == null) {        return null;    }    int triggeredWatches = 0;        synchronized (watchers) {        for (Integer wBit : watchers) {            if (suppress != null && suppress.contains(wBit)) {                continue;            }            Watcher w = watcherBitIdMap.get(wBit);                        if (w == null || isDeadWatcher(w)) {                continue;            }            w.process(e);            triggeredWatches++;        }    }    updateMetrics(type, triggeredWatches);    return new WatcherOrBitSet(watchers);}
0
public int size()
{    int size = 0;    for (BitHashSet watches : pathWatches.values()) {        size += watches.size();    }    return size;}
0
public void shutdown()
{    if (watcherCleaner != null) {        watcherCleaner.shutdown();    }}
0
private BitHashSet remove(String path)
{    addRemovePathRWLock.writeLock().lock();    try {        return pathWatches.remove(path);    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
0
 void updateMetrics(final EventType type, int size)
{    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(size);            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(size);            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(size);            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(size);            break;        default:                        break;    }}
0
 boolean isDeadWatcher(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
0
 int pathSize()
{    return pathWatches.size();}
0
public WatchesSummary getWatchesSummary()
{    return new WatchesSummary(watcherBitIdMap.size(), pathSize(), size());}
0
public WatchesReport getWatches()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
0
public WatchesPathReport getWatchesByPath()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        BitHashSet watchers = e.getValue();        synchronized (watchers) {            Set<Long> ids = new HashSet<Long>(watchers.size());            path2ids.put(e.getKey(), ids);            for (Integer wbit : watchers) {                Watcher watcher = watcherBitIdMap.get(wbit);                if (watcher instanceof ServerCnxn) {                    ids.add(((ServerCnxn) watcher).getSessionId());                }            }        }    }    return new WatchesPathReport(path2ids);}
0
public Map<Watcher, Set<String>> getWatcher2PathesMap()
{    Map<Watcher, Set<String>> watcher2paths = new HashMap<Watcher, Set<String>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        String path = e.getKey();        BitHashSet watchers = e.getValue();                synchronized (watchers) {            for (Integer wbit : watchers) {                Watcher w = watcherBitIdMap.get(wbit);                if (w == null) {                    continue;                }                if (!watcher2paths.containsKey(w)) {                    watcher2paths.put(w, new HashSet<String>());                }                watcher2paths.get(w).add(path);            }        }    }    return watcher2paths;}
0
public void dumpWatches(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {            pwriter.println(e.getKey());            BitHashSet watchers = e.getValue();            synchronized (watchers) {                for (Integer wbit : watchers) {                    Watcher w = watcherBitIdMap.get(wbit);                    if (!(w instanceof ServerCnxn)) {                        continue;                    }                    pwriter.print("\t0x");                    pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                    pwriter.print("\n");                }            }        }    } else {        for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(watcherBitIdMap.size()).append(" connections watching ").append(pathSize()).append(" paths\n");    sb.append("Total watches:").append(size());    return sb.toString();}
0
public void cleanup()
{}
0
public void schedule(WorkRequest workRequest)
{    schedule(workRequest, 0);}
0
public void schedule(WorkRequest workRequest, long id)
{    if (stopped) {        workRequest.cleanup();        return;    }    ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);            int size = workers.size();    if (size > 0) {        try {                        int workerNum = ((int) (id % size) + size) % size;            ExecutorService worker = workers.get(workerNum);            worker.execute(scheduledWorkRequest);        } catch (RejectedExecutionException e) {                        workRequest.cleanup();        }    } else {                        scheduledWorkRequest.run();    }}
1
public void run()
{    try {                if (stopped) {            workRequest.cleanup();            return;        }        workRequest.doWork();    } catch (Exception e) {                workRequest.cleanup();    }}
1
public Thread newThread(Runnable r)
{    Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);    if (!t.isDaemon()) {        t.setDaemon(true);    }    if (t.getPriority() != Thread.NORM_PRIORITY) {        t.setPriority(Thread.NORM_PRIORITY);    }    return t;}
0
public void start()
{    if (numWorkerThreads > 0) {        if (threadsAreAssignable) {            for (int i = 1; i <= numWorkerThreads; ++i) {                workers.add(Executors.newFixedThreadPool(1, new DaemonThreadFactory(threadNamePrefix, i)));            }        } else {            workers.add(Executors.newFixedThreadPool(numWorkerThreads, new DaemonThreadFactory(threadNamePrefix)));        }    }    stopped = false;}
0
public void stop()
{    stopped = true;        for (ExecutorService worker : workers) {        worker.shutdown();    }}
0
public void join(long shutdownTimeoutMS)
{        long now = Time.currentElapsedTime();    long endTime = now + shutdownTimeoutMS;    for (ExecutorService worker : workers) {        boolean terminated = false;        while ((now = Time.currentElapsedTime()) <= endTime) {            try {                terminated = worker.awaitTermination(endTime - now, TimeUnit.MILLISECONDS);                break;            } catch (InterruptedException e) {                        }        }        if (!terminated) {                        worker.shutdownNow();        }    }}
0
public boolean isInitialized()
{    return initialized;}
0
public void clear()
{    minCommittedLog = 0;    maxCommittedLog = 0;    /* to be safe we just create a new         * datatree.         */    dataTree.shutdownWatcher();    dataTree = createDataTree();    sessionsWithTimeouts.clear();    WriteLock lock = logLock.writeLock();    try {        lock.lock();        committedLog.clear();    } finally {        lock.unlock();    }    initialized = false;}
0
public DataTree getDataTree()
{    return this.dataTree;}
0
public long getmaxCommittedLog()
{    return maxCommittedLog;}
0
public long getminCommittedLog()
{    return minCommittedLog;}
0
public ReentrantReadWriteLock getLogLock()
{    return logLock;}
0
public synchronized Collection<Proposal> getCommittedLog()
{    final Collection<Proposal> result;    ReadLock rl = logLock.readLock();        if (logLock.getReadHoldCount() > 0) {        result = this.committedLog;    } else {        rl.lock();        try {            result = new ArrayList<>(this.committedLog);        } finally {            rl.unlock();        }    }    return Collections.unmodifiableCollection(result);}
0
public long getDataTreeLastProcessedZxid()
{    return dataTree.lastProcessedZxid;}
0
public Collection<Long> getSessions()
{    return dataTree.getSessions();}
0
public long getSessionCount()
{    return sessionsWithTimeouts.size();}
0
public ConcurrentHashMap<Long, Integer> getSessionWithTimeOuts()
{    return sessionsWithTimeouts;}
0
public void onTxnLoaded(TxnHeader hdr, Record txn)
{    addCommittedProposal(hdr, txn);}
0
public long loadDataBase() throws IOException
{    long startTime = Time.currentElapsedTime();    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    long loadTime = Time.currentElapsedTime() - startTime;    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);        return zxid;}
1
public long fastForwardDataBase() throws IOException
{    long zxid = snapLog.fastForwardFromEdits(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    return zxid;}
0
private void addCommittedProposal(TxnHeader hdr, Record txn)
{    Request r = new Request(0, hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    addCommittedProposal(r);}
0
public void addCommittedProposal(Request request)
{    WriteLock wl = logLock.writeLock();    try {        wl.lock();        if (committedLog.size() > commitLogCount) {            committedLog.remove();            minCommittedLog = committedLog.peek().packet.getZxid();        }        if (committedLog.isEmpty()) {            minCommittedLog = request.zxid;            maxCommittedLog = request.zxid;        }        byte[] data = SerializeUtils.serializeRequest(request);        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);        Proposal p = new Proposal();        p.packet = pp;        p.request = request;        committedLog.add(p);        maxCommittedLog = p.packet.getZxid();    } finally {        wl.unlock();    }}
0
public boolean isTxnLogSyncEnabled()
{    boolean enabled = snapshotSizeFactor >= 0;    if (enabled) {            } else {            }    return enabled;}
1
public long calculateTxnLogSizeLimit()
{    long snapSize = 0;    try {        File snapFile = snapLog.findMostRecentSnapshot();        if (snapFile != null) {            snapSize = snapFile.length();        }    } catch (IOException e) {            }    return (long) (snapSize * snapshotSizeFactor);}
1
public Iterator<Proposal> getProposalsFromTxnLog(long startZxid, long sizeLimit)
{    if (sizeLimit < 0) {                return TxnLogProposalIterator.EMPTY_ITERATOR;    }    TxnIterator itr = null;    try {        itr = snapLog.readTxnLog(startZxid, false);                if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {                        itr.close();            return TxnLogProposalIterator.EMPTY_ITERATOR;        }        if (sizeLimit > 0) {            long txnSize = itr.getStorageSize();            if (txnSize > sizeLimit) {                                itr.close();                return TxnLogProposalIterator.EMPTY_ITERATOR;            }        }    } catch (IOException e) {                try {            if (itr != null) {                itr.close();            }        } catch (IOException ioe) {                    }        return TxnLogProposalIterator.EMPTY_ITERATOR;    }    return new TxnLogProposalIterator(itr);}
1
public List<ACL> aclForNode(DataNode n)
{    return dataTree.getACL(n);}
0
public void removeCnxn(ServerCnxn cnxn)
{    dataTree.removeCnxn(cnxn);}
0
public void killSession(long sessionId, long zxid)
{    dataTree.killSession(sessionId, zxid);}
0
public void dumpEphemerals(PrintWriter pwriter)
{    dataTree.dumpEphemerals(pwriter);}
0
public Map<Long, Set<String>> getEphemerals()
{    return dataTree.getEphemerals();}
0
public int getNodeCount()
{    return dataTree.getNodeCount();}
0
public Set<String> getEphemerals(long sessionId)
{    return dataTree.getEphemerals(sessionId);}
0
public void setlastProcessedZxid(long zxid)
{    dataTree.lastProcessedZxid = zxid;}
0
public ProcessTxnResult processTxn(TxnHeader hdr, Record txn)
{    return dataTree.processTxn(hdr, txn);}
0
public Stat statNode(String path, ServerCnxn serverCnxn) throws KeeperException.NoNodeException
{    return dataTree.statNode(path, serverCnxn);}
0
public DataNode getNode(String path)
{    return dataTree.getNode(path);}
0
public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getData(path, stat, watcher);}
0
public void setWatches(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    dataTree.setWatches(relativeZxid, dataWatches, existWatches, childWatches, watcher);}
0
public List<ACL> getACL(String path, Stat stat) throws NoNodeException
{    return dataTree.getACL(path, stat);}
0
public List<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getChildren(path, stat, watcher);}
0
public int getAllChildrenNumber(String path) throws KeeperException.NoNodeException
{    return dataTree.getAllChildrenNumber(path);}
0
public boolean isSpecialPath(String path)
{    return dataTree.isSpecialPath(path);}
0
public int getAclSize()
{    return dataTree.aclCacheSize();}
0
public boolean truncateLog(long zxid) throws IOException
{    clear();        boolean truncated = snapLog.truncateLog(zxid);    if (!truncated) {        return false;    }    loadDataBase();    return true;}
0
public void deserializeSnapshot(InputArchive ia) throws IOException
{    clear();    SerializeUtils.deserializeSnapshot(getDataTree(), ia, getSessionWithTimeOuts());    initialized = true;}
0
public void serializeSnapshot(OutputArchive oa) throws IOException, InterruptedException
{    SerializeUtils.serializeSnapshot(getDataTree(), oa, getSessionWithTimeOuts());}
0
public boolean append(Request si) throws IOException
{    txnCount.incrementAndGet();    return this.snapLog.append(si);}
0
public void rollLog() throws IOException
{    this.snapLog.rollLog();    resetTxnCount();}
0
public void commit() throws IOException
{    this.snapLog.commit();}
0
public void close() throws IOException
{    this.snapLog.close();}
0
public synchronized void initConfigInZKDatabase(QuorumVerifier qv)
{    if (qv == null) {                return;    }    try {        if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {                                    this.dataTree.addConfigNode();        }        this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());    } catch (NoNodeException e) {        System.out.println("configuration node missing - should not happen");    }}
1
public void setSnapshotSizeFactor(double snapshotSizeFactor)
{    this.snapshotSizeFactor = snapshotSizeFactor;}
0
public boolean containsWatcher(String path, WatcherType type, Watcher watcher)
{    return dataTree.containsWatcher(path, type, watcher);}
0
public boolean removeWatch(String path, WatcherType type, Watcher watcher)
{    return dataTree.removeWatch(path, type, watcher);}
0
public DataTree createDataTree()
{    return new DataTree();}
0
public void resetTxnCount()
{    txnCount.set(0);    snapLog.setTotalLogSize(0);}
0
public int getTxnCount()
{    return txnCount.get();}
0
public long getTxnSize()
{    return snapLog.getTotalLogSize();}
0
protected void handleException(String threadName, Throwable e)
{        listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue());    ServerMetrics.getMetrics().UNRECOVERABLE_ERROR_COUNT.add(1);}
1
private SaslServer createSaslServer(final Login login)
{    synchronized (login) {        Subject subject = login.getSubject();        return SecurityUtils.createSaslServer(subject, "zookeeper", "zk-sasl-md5", login.callbackHandler, LOG);    }}
0
public byte[] evaluateResponse(byte[] response) throws SaslException
{    return saslServer.evaluateResponse(response);}
0
public boolean isComplete()
{    return saslServer.isComplete();}
0
public String getAuthorizationID()
{    return saslServer.getAuthorizationID();}
0
public static boolean isCloseSessionTxnEnabled()
{    return closeSessionTxnEnabled;}
0
public static void setCloseSessionTxnEnabled(boolean enabled)
{    ZooKeeperServer.closeSessionTxnEnabled = enabled;    }
1
 void removeCnxn(ServerCnxn cnxn)
{    zkDb.removeCnxn(cnxn);}
0
public String getInitialConfig()
{    return initialConfig;}
0
public ServerStats serverStats()
{    return serverStats;}
0
public RequestPathMetricsCollector getRequestPathMetricsCollector()
{    return requestPathMetricsCollector;}
0
public BlueThrottle connThrottle()
{    return connThrottle;}
0
public void dumpConf(PrintWriter pwriter)
{    pwriter.print("clientPort=");    pwriter.println(getClientPort());    pwriter.print("secureClientPort=");    pwriter.println(getSecureClientPort());    pwriter.print("dataDir=");    pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());    pwriter.print("dataDirSize=");    pwriter.println(getDataDirSize());    pwriter.print("dataLogDir=");    pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());    pwriter.print("dataLogSize=");    pwriter.println(getLogDirSize());    pwriter.print("tickTime=");    pwriter.println(getTickTime());    pwriter.print("maxClientCnxns=");    pwriter.println(getMaxClientCnxnsPerHost());    pwriter.print("minSessionTimeout=");    pwriter.println(getMinSessionTimeout());    pwriter.print("maxSessionTimeout=");    pwriter.println(getMaxSessionTimeout());    pwriter.print("clientPortListenBacklog=");    pwriter.println(getClientPortListenBacklog());    pwriter.print("serverId=");    pwriter.println(getServerId());}
0
public ZooKeeperServerConf getConf()
{    return new ZooKeeperServerConf(getClientPort(), zkDb.snapLog.getSnapDir().getAbsolutePath(), zkDb.snapLog.getDataDir().getAbsolutePath(), getTickTime(), serverCnxnFactory.getMaxClientCnxnsPerHost(), getMinSessionTimeout(), getMaxSessionTimeout(), getServerId(), getClientPortListenBacklog());}
0
public ZKDatabase getZKDatabase()
{    return this.zkDb;}
0
public void setZKDatabase(ZKDatabase zkDb)
{    this.zkDb = zkDb;}
0
public void loadData() throws IOException, InterruptedException
{    /*         * When a new leader starts executing Leader#lead, it         * invokes this method. The database, however, has been         * initialized before running leader election so that         * the server could pick its zxid for its initial vote.         * It does it by invoking QuorumPeer#getLastLoggedZxid.         * Consequently, we don't need to initialize it once more         * and avoid the penalty of loading it a second time. Not         * reloading it is particularly important for applications         * that host a large database.         *         * The following if block checks whether the database has         * been initialized or not. Note that this method is         * invoked by at least one other method:         * ZooKeeperServer#startdata.         *         * See ZOOKEEPER-1642 for more detail.         */    if (zkDb.isInitialized()) {        setZxid(zkDb.getDataTreeLastProcessedZxid());    } else {        setZxid(zkDb.loadDataBase());    }        List<Long> deadSessions = new ArrayList<>();    for (Long session : zkDb.getSessions()) {        if (zkDb.getSessionWithTimeOuts().get(session) == null) {            deadSessions.add(session);        }    }    for (long session : deadSessions) {                killSession(session, zkDb.getDataTreeLastProcessedZxid());    }        takeSnapshot();}
0
public void takeSnapshot()
{    takeSnapshot(false);}
0
public void takeSnapshot(boolean syncSnap)
{    long start = Time.currentElapsedTime();    try {        txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), syncSnap);    } catch (IOException e) {                                System.exit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());    }    long elapsed = Time.currentElapsedTime() - start;        ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);}
1
public long getDataDirSize()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getDataDir();    return getDirSize(path);}
0
public long getLogDirSize()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getSnapDir();    return getDirSize(path);}
0
private long getDirSize(File file)
{    long size = 0L;    if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null) {            for (File f : files) {                size += getDirSize(f);            }        }    } else {        size = file.length();    }    return size;}
0
public long getZxid()
{    return hzxid.get();}
0
public SessionTracker getSessionTracker()
{    return sessionTracker;}
0
 long getNextZxid()
{    return hzxid.incrementAndGet();}
0
public void setZxid(long zxid)
{    hzxid.set(zxid);}
0
private void close(long sessionId)
{    Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);    setLocalSessionFlag(si);    submitRequest(si);}
0
public void closeSession(long sessionId)
{                close(sessionId);}
1
protected void killSession(long sessionId, long zxid)
{    zkDb.killSession(sessionId, zxid);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "ZooKeeperServer --- killSession: 0x" + Long.toHexString(sessionId));    }    if (sessionTracker != null) {        sessionTracker.removeSession(sessionId);    }}
0
public void expire(Session session)
{    long sessionId = session.getSessionId();        close(sessionId);}
1
 void touch(ServerCnxn cnxn) throws MissingSessionException
{    if (cnxn == null) {        return;    }    long id = cnxn.getSessionId();    int to = cnxn.getSessionTimeout();    if (!sessionTracker.touchSession(id, to)) {        throw new MissingSessionException("No session with sessionid 0x" + Long.toHexString(id) + " exists, probably expired and removed");    }}
0
protected void registerJMX()
{        try {        jmxServerBean = new ZooKeeperServerBean(this);        MBeanRegistry.getInstance().register(jmxServerBean, null);        try {            jmxDataTreeBean = new DataTreeBean(zkDb.getDataTree());            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);        } catch (Exception e) {                        jmxDataTreeBean = null;        }    } catch (Exception e) {                jmxServerBean = null;    }}
1
public void startdata() throws IOException, InterruptedException
{        if (zkDb == null) {        zkDb = new ZKDatabase(this.txnLogFactory);    }    if (!zkDb.isInitialized()) {        loadData();    }}
0
public synchronized void startup()
{    if (sessionTracker == null) {        createSessionTracker();    }    startSessionTracker();    setupRequestProcessors();    startRequestThrottler();    registerJMX();    startJvmPauseMonitor();    registerMetrics();    setState(State.RUNNING);    requestPathMetricsCollector.start();    localSessionEnabled = sessionTracker.isLocalSessionsEnabled();    notifyAll();}
0
protected void startJvmPauseMonitor()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
0
protected void startRequestThrottler()
{    requestThrottler = new RequestThrottler(this);    requestThrottler.start();}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new PrepRequestProcessor(this, syncProcessor);    ((PrepRequestProcessor) firstProcessor).start();}
0
public ZooKeeperServerListener getZooKeeperServerListener()
{    return listener;}
0
public void setCreateSessionTrackerServerId(int newId)
{    createSessionTrackerServerId = newId;}
0
protected void createSessionTracker()
{    sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(), tickTime, createSessionTrackerServerId, getZooKeeperServerListener());}
0
protected void startSessionTracker()
{    ((SessionTrackerImpl) sessionTracker).start();}
0
protected void setState(State state)
{    this.state = state;        if (zkShutdownHandler != null) {        zkShutdownHandler.handle(state);    } else {            }}
1
protected boolean canShutdown()
{    return state == State.RUNNING || state == State.ERROR;}
0
public boolean isRunning()
{    return state == State.RUNNING;}
0
public void shutdown()
{    shutdown(false);}
0
public synchronized void shutdown(boolean fullyShutDown)
{    if (!canShutdown()) {                return;    }            setState(State.SHUTDOWN);            unregisterMetrics();    if (requestThrottler != null) {        requestThrottler.shutdown();    }        if (sessionTracker != null) {        sessionTracker.shutdown();    }    if (firstProcessor != null) {        firstProcessor.shutdown();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    if (zkDb != null) {        if (fullyShutDown) {            zkDb.clear();        } else {                        try {                                zkDb.fastForwardDataBase();            } catch (IOException e) {                                zkDb.clear();            }        }    }    requestPathMetricsCollector.shutdown();    unregisterJMX();}
1
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;    jmxDataTreeBean = null;}
1
public void incInProcess()
{    requestsInProcess.incrementAndGet();}
0
public void decInProcess()
{    requestsInProcess.decrementAndGet();    if (requestThrottler != null) {        requestThrottler.throttleWake();    }}
0
public int getInProcess()
{    return requestsInProcess.get();}
0
public int getInflight()
{    return requestThrottleInflight();}
0
private int requestThrottleInflight()
{    if (requestThrottler != null) {        return requestThrottler.getInflight();    }    return 0;}
0
 ChangeRecord duplicate(long zxid)
{    StatPersisted stat = new StatPersisted();    if (this.stat != null) {        DataTree.copyStatPersisted(this.stat, stat);    }    return new ChangeRecord(zxid, path, stat, childCount, acl == null ? new ArrayList<>() : new ArrayList<>(acl));}
0
 byte[] generatePasswd(long id)
{    Random r = new Random(id ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    return p;}
0
protected boolean checkPasswd(long sessionId, byte[] passwd)
{    return sessionId != 0 && Arrays.equals(passwd, generatePasswd(sessionId));}
0
 long createSession(ServerCnxn cnxn, byte[] passwd, int timeout)
{    if (passwd == null) {                passwd = new byte[0];    }    long sessionId = sessionTracker.createSession(timeout);    Random r = new Random(sessionId ^ superSecret);    r.nextBytes(passwd);    ByteBuffer to = ByteBuffer.allocate(4);    to.putInt(timeout);    cnxn.setSessionId(sessionId);    Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);    setLocalSessionFlag(si);    submitRequest(si);    return sessionId;}
0
public void setOwner(long id, Object owner) throws SessionExpiredException
{    sessionTracker.setOwner(id, owner);}
0
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + rc);    }    finishSessionInit(cnxn, rc);}
0
public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd, int sessionTimeout) throws IOException
{    if (checkPasswd(sessionId, passwd)) {        revalidateSession(cnxn, sessionId, sessionTimeout);    } else {                finishSessionInit(cnxn, false);    }}
1
public void finishSessionInit(ServerCnxn cnxn, boolean valid)
{        try {        if (valid) {            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {                serverCnxnFactory.registerConnection(cnxn);            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {                secureServerCnxnFactory.registerConnection(cnxn);            }        }    } catch (Exception e) {            }    try {        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0,         valid ? cnxn.getSessionId() : 0,         valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);        bos.writeInt(-1, "len");        rsp.serialize(bos, "connect");        if (!cnxn.isOldClient) {            bos.writeBool(this instanceof ReadOnlyZooKeeperServer, "readOnly");        }        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.remaining() - 4).rewind();        cnxn.sendBuffer(bb);        if (valid) {            if (LOG.isDebugEnabled()) {                            }            cnxn.enableRecv();        } else {                        cnxn.sendBuffer(ServerCnxnFactory.closeConn);        }    } catch (Exception e) {                cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);    }}
1
public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader)
{    closeSession(cnxn.getSessionId());}
0
public long getServerId()
{    return 0;}
0
protected void setLocalSessionFlag(Request si)
{}
0
public void submitRequest(Request si)
{    enqueueRequest(si);}
0
public void enqueueRequest(Request si)
{    if (requestThrottler == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                            }            if (requestThrottler == null) {                throw new RuntimeException("Not started");            }        }    }    requestThrottler.submitRequest(si);}
1
public void submitRequestNow(Request si)
{    if (firstProcessor == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                            }            if (firstProcessor == null || state != State.RUNNING) {                throw new RuntimeException("Not started");            }        }    }    try {        touch(si.cnxn);        boolean validpacket = Request.isValid(si.type);        if (validpacket) {            firstProcessor.processRequest(si);            if (si.cnxn != null) {                incInProcess();            }        } else {                                    requestFinished(si);            new UnimplementedRequestProcessor().processRequest(si);        }    } catch (MissingSessionException e) {        if (LOG.isDebugEnabled()) {                    }                requestFinished(si);    } catch (RequestProcessorException e) {                        requestFinished(si);    }}
1
public static int getSnapCount()
{    String sc = System.getProperty(SNAP_COUNT);    try {        int snapCount = Integer.parseInt(sc);                if (snapCount < 2) {                        snapCount = 2;        }        return snapCount;    } catch (Exception e) {        return 100000;    }}
1
public int getGlobalOutstandingLimit()
{    String sc = System.getProperty(GLOBAL_OUTSTANDING_LIMIT);    int limit;    try {        limit = Integer.parseInt(sc);    } catch (Exception e) {        limit = 1000;    }    return limit;}
0
public void setServerCnxnFactory(ServerCnxnFactory factory)
{    serverCnxnFactory = factory;}
0
public ServerCnxnFactory getServerCnxnFactory()
{    return serverCnxnFactory;}
0
public ServerCnxnFactory getSecureServerCnxnFactory()
{    return secureServerCnxnFactory;}
0
public void setSecureServerCnxnFactory(ServerCnxnFactory factory)
{    secureServerCnxnFactory = factory;}
0
public long getLastProcessedZxid()
{    return zkDb.getDataTreeLastProcessedZxid();}
0
public long getOutstandingRequests()
{    return getInProcess();}
0
public int getNumAliveConnections()
{    int numAliveConnections = 0;    if (serverCnxnFactory != null) {        numAliveConnections += serverCnxnFactory.getNumAliveConnections();    }    if (secureServerCnxnFactory != null) {        numAliveConnections += secureServerCnxnFactory.getNumAliveConnections();    }    return numAliveConnections;}
0
public void truncateLog(long zxid) throws IOException
{    this.zkDb.truncateLog(zxid);}
0
public int getTickTime()
{    return tickTime;}
0
public void setTickTime(int tickTime)
{        this.tickTime = tickTime;}
1
public int getMinSessionTimeout()
{    return minSessionTimeout;}
0
public void setMinSessionTimeout(int min)
{    this.minSessionTimeout = min == -1 ? tickTime * 2 : min;    }
1
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
0
public void setMaxSessionTimeout(int max)
{    this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;    }
1
public int getClientPortListenBacklog()
{    return listenBacklog;}
0
public void setClientPortListenBacklog(int backlog)
{    this.listenBacklog = backlog;    }
1
public int getClientPort()
{    return serverCnxnFactory != null ? serverCnxnFactory.getLocalPort() : -1;}
0
public int getSecureClientPort()
{    return secureServerCnxnFactory != null ? secureServerCnxnFactory.getLocalPort() : -1;}
0
public int getMaxClientCnxnsPerHost()
{    if (serverCnxnFactory != null) {        return serverCnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureServerCnxnFactory != null) {        return secureServerCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
0
public void setTxnLogFactory(FileTxnSnapLog txnLog)
{    this.txnLogFactory = txnLog;}
0
public FileTxnSnapLog getTxnLogFactory()
{    return this.txnLogFactory;}
0
public long getTxnLogElapsedSyncTime()
{    return txnLogFactory.getTxnLogElapsedSyncTime();}
0
public String getState()
{    return "standalone";}
0
public void dumpEphemerals(PrintWriter pwriter)
{    zkDb.dumpEphemerals(pwriter);}
0
public Map<Long, Set<String>> getEphemerals()
{    return zkDb.getEphemerals();}
0
public double getConnectionDropChance()
{    return connThrottle.getDropChance();}
0
public boolean shouldThrottle(long outStandingCount)
{    if (getGlobalOutstandingLimit() < getInflight()) {        return outStandingCount > 0;    }    return false;}
0
 long getFlushDelay()
{    return flushDelay;}
0
 static void setFlushDelay(long delay)
{        flushDelay = delay;}
1
 long getMaxWriteQueuePollTime()
{    return maxWriteQueuePollTime;}
0
 static void setMaxWriteQueuePollTime(long maxTime)
{        maxWriteQueuePollTime = maxTime;}
1
 int getMaxBatchSize()
{    return maxBatchSize;}
0
 static void setMaxBatchSize(int size)
{        maxBatchSize = size;}
1
private void initLargeRequestThrottlingSettings()
{    setLargeRequestMaxBytes(Integer.getInteger("zookeeper.largeRequestMaxBytes", largeRequestMaxBytes));    setLargeRequestThreshold(Integer.getInteger("zookeeper.largeRequestThreshold", -1));}
0
public int getLargeRequestMaxBytes()
{    return largeRequestMaxBytes;}
0
public void setLargeRequestMaxBytes(int bytes)
{    if (bytes <= 0) {                    } else {        largeRequestMaxBytes = bytes;            }}
1
public int getLargeRequestThreshold()
{    return largeRequestThreshold;}
0
public void setLargeRequestThreshold(int threshold)
{    if (threshold == 0 || threshold < -1) {                largeRequestThreshold = -1;    } else {        largeRequestThreshold = threshold;            }}
1
public int getLargeRequestBytes()
{    return currentLargeRequestBytes.get();}
0
private boolean isLargeRequest(int length)
{        if (largeRequestThreshold == -1) {        return false;    }    return length > largeRequestThreshold;}
0
public boolean checkRequestSizeWhenReceivingMessage(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    if (currentLargeRequestBytes.get() + length <= largeRequestMaxBytes) {        return true;    } else {        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }}
0
private boolean checkRequestSizeWhenMessageReceived(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    int bytes = currentLargeRequestBytes.addAndGet(length);    if (bytes > largeRequestMaxBytes) {        currentLargeRequestBytes.addAndGet(-length);        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }    return true;}
0
public void requestFinished(Request request)
{    int largeRequestLength = request.getLargeRequestSize();    if (largeRequestLength != -1) {        currentLargeRequestBytes.addAndGet(-largeRequestLength);    }}
0
public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException
{        InputStream bais = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);    RequestHeader h = new RequestHeader();    h.deserialize(bia, "header");                                        cnxn.incrOutstandingAndCheckThrottle(h);                incomingBuffer = incomingBuffer.slice();    if (h.getType() == OpCode.auth) {                AuthPacket authPacket = new AuthPacket();        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);        String scheme = authPacket.getScheme();        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);        Code authReturn = KeeperException.Code.AUTHFAILED;        if (ap != null) {            try {                                                authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());            } catch (RuntimeException e) {                                authReturn = KeeperException.Code.AUTHFAILED;            }        }        if (authReturn == KeeperException.Code.OK) {                                    ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());            cnxn.sendResponse(rh, null, null);        } else {            if (ap == null) {                            } else {                            }                        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());            cnxn.sendResponse(rh, null, null);                        cnxn.sendBuffer(ServerCnxnFactory.closeConn);            cnxn.disableRecv();        }        return;    } else if (h.getType() == OpCode.sasl) {        processSasl(incomingBuffer, cnxn, h);    } else {        if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0, Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());            cnxn.sendResponse(replyHeader, null, "response");            cnxn.sendCloseSession();            cnxn.disableRecv();        } else {            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), incomingBuffer, cnxn.getAuthInfo());            int length = incomingBuffer.limit();            if (isLargeRequest(length)) {                                checkRequestSizeWhenMessageReceived(length);                si.setLargeRequestSize(length);            }            si.setOwner(ServerCnxn.me);                                    setLocalSessionFlag(si);            submitRequest(si);        }    }}
1
private static boolean shouldAllowSaslFailedClientsConnect()
{    return Boolean.getBoolean(ALLOW_SASL_FAILED_CLIENTS);}
0
private static boolean shouldRequireClientSaslAuth()
{    return Boolean.getBoolean(SESSION_REQUIRE_CLIENT_SASL_AUTH);}
0
private boolean hasCnxSASLAuthenticated(ServerCnxn cnxn)
{    for (Id id : cnxn.getAuthInfo()) {        if (id.getScheme().equals(SASL_AUTH_SCHEME)) {            return true;        }    }    return false;}
0
private void processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn, RequestHeader requestHeader) throws IOException
{        GetSASLRequest clientTokenRecord = new GetSASLRequest();    ByteBufferInputStream.byteBuffer2Record(incomingBuffer, clientTokenRecord);    byte[] clientToken = clientTokenRecord.getToken();        byte[] responseToken = null;    try {        ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;        try {                                                responseToken = saslServer.evaluateResponse(clientToken);            if (saslServer.isComplete()) {                String authorizationID = saslServer.getAuthorizationID();                                cnxn.addAuthInfo(new Id("sasl", authorizationID));                if (System.getProperty("zookeeper.superUser") != null && authorizationID.equals(System.getProperty("zookeeper.superUser"))) {                    cnxn.addAuthInfo(new Id("super", ""));                }            }        } catch (SaslException e) {                        if (shouldAllowSaslFailedClientsConnect() && !shouldRequireClientSaslAuth()) {                            } else {                int error;                if (shouldRequireClientSaslAuth()) {                                        error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();                } else {                                        error = Code.AUTHFAILED.intValue();                }                ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);                cnxn.sendResponse(replyHeader, new SetSASLResponse(null), "response");                cnxn.sendCloseSession();                cnxn.disableRecv();                return;            }        }    } catch (NullPointerException e) {            }    if (responseToken != null) {            }    ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, Code.OK.intValue());    Record record = new SetSASLResponse(responseToken);    cnxn.sendResponse(replyHeader, record, "response");}
1
public ProcessTxnResult processTxn(TxnHeader hdr, Record txn)
{    processTxnForSessionEvents(null, hdr, txn);    return processTxnInDB(hdr, txn);}
0
public ProcessTxnResult processTxn(Request request)
{    TxnHeader hdr = request.getHdr();    processTxnForSessionEvents(request, hdr, request.getTxn());    final boolean writeRequest = (hdr != null);    final boolean quorumRequest = request.isQuorum();        if (!writeRequest && !quorumRequest) {        return new ProcessTxnResult();    }    synchronized (outstandingChanges) {        ProcessTxnResult rc = processTxnInDB(hdr, request.getTxn());                if (writeRequest) {            long zxid = hdr.getZxid();            while (!outstandingChanges.isEmpty() && outstandingChanges.peek().zxid <= zxid) {                ChangeRecord cr = outstandingChanges.remove();                ServerMetrics.getMetrics().OUTSTANDING_CHANGES_REMOVED.add(1);                if (cr.zxid < zxid) {                                    }                if (outstandingChangesForPath.get(cr.path) == cr) {                    outstandingChangesForPath.remove(cr.path);                }            }        }                if (quorumRequest) {            getZKDatabase().addCommittedProposal(request);        }        return rc;    }}
1
private void processTxnForSessionEvents(Request request, TxnHeader hdr, Record txn)
{    int opCode = (request == null) ? hdr.getType() : request.type;    long sessionId = (request == null) ? hdr.getClientId() : request.sessionId;    if (opCode == OpCode.createSession) {        if (hdr != null && txn instanceof CreateSessionTxn) {            CreateSessionTxn cst = (CreateSessionTxn) txn;            sessionTracker.commitSession(sessionId, cst.getTimeOut());        } else if (request == null || !request.isLocalSession()) {                    }    } else if (opCode == OpCode.closeSession) {        sessionTracker.removeSession(sessionId);    }}
1
private ProcessTxnResult processTxnInDB(TxnHeader hdr, Record txn)
{    if (hdr == null) {        return new ProcessTxnResult();    } else {        return getZKDatabase().processTxn(hdr, txn);    }}
0
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return sessionTracker.getSessionExpiryMap();}
0
 void registerServerShutdownHandler(ZooKeeperServerShutdownHandler zkShutdownHandler)
{    this.zkShutdownHandler = zkShutdownHandler;}
0
public boolean isResponseCachingEnabled()
{    return isResponseCachingEnabled;}
0
public void setResponseCachingEnabled(boolean isEnabled)
{    isResponseCachingEnabled = isEnabled;}
0
public ResponseCache getReadResponseCache()
{    return isResponseCachingEnabled ? readResponseCache : null;}
0
protected void registerMetrics()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    final ZKDatabase zkdb = this.getZKDatabase();    final ServerStats stats = this.serverStats();    rootContext.registerGauge("avg_latency", stats::getAvgLatency);    rootContext.registerGauge("max_latency", stats::getMaxLatency);    rootContext.registerGauge("min_latency", stats::getMinLatency);    rootContext.registerGauge("packets_received", stats::getPacketsReceived);    rootContext.registerGauge("packets_sent", stats::getPacketsSent);    rootContext.registerGauge("num_alive_connections", stats::getNumAliveClientConnections);    rootContext.registerGauge("outstanding_requests", stats::getOutstandingRequests);    rootContext.registerGauge("uptime", stats::getUptime);    rootContext.registerGauge("znode_count", zkdb::getNodeCount);    rootContext.registerGauge("watch_count", zkdb.getDataTree()::getWatchCount);    rootContext.registerGauge("ephemerals_count", zkdb.getDataTree()::getEphemeralsCount);    rootContext.registerGauge("approximate_data_size", zkdb.getDataTree()::cachedApproximateDataSize);    rootContext.registerGauge("global_sessions", zkdb::getSessionCount);    rootContext.registerGauge("local_sessions", this.getSessionTracker()::getLocalSessionCount);    OSMXBean osMbean = new OSMXBean();    rootContext.registerGauge("open_file_descriptor_count", osMbean::getOpenFileDescriptorCount);    rootContext.registerGauge("max_file_descriptor_count", osMbean::getMaxFileDescriptorCount);    rootContext.registerGauge("connection_drop_probability", this::getConnectionDropChance);    rootContext.registerGauge("last_client_response_size", stats.getClientResponseStats()::getLastBufferSize);    rootContext.registerGauge("max_client_response_size", stats.getClientResponseStats()::getMaxBufferSize);    rootContext.registerGauge("min_client_response_size", stats.getClientResponseStats()::getMinBufferSize);}
0
protected void unregisterMetrics()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("avg_latency");    rootContext.unregisterGauge("max_latency");    rootContext.unregisterGauge("min_latency");    rootContext.unregisterGauge("packets_received");    rootContext.unregisterGauge("packets_sent");    rootContext.unregisterGauge("num_alive_connections");    rootContext.unregisterGauge("outstanding_requests");    rootContext.unregisterGauge("uptime");    rootContext.unregisterGauge("znode_count");    rootContext.unregisterGauge("watch_count");    rootContext.unregisterGauge("ephemerals_count");    rootContext.unregisterGauge("approximate_data_size");    rootContext.unregisterGauge("global_sessions");    rootContext.unregisterGauge("local_sessions");    rootContext.unregisterGauge("open_file_descriptor_count");    rootContext.unregisterGauge("max_file_descriptor_count");    rootContext.unregisterGauge("connection_drop_probability");    rootContext.unregisterGauge("last_client_response_size");    rootContext.unregisterGauge("max_client_response_size");    rootContext.unregisterGauge("min_client_response_size");}
0
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    ServerStats stats = serverStats();    response.accept("version", Version.getFullVersion());    response.accept("server_state", stats.getServerState());}
0
public void checkACL(ServerCnxn cnxn, List<ACL> acl, int perm, List<Id> ids, String path, List<ACL> setAcls) throws KeeperException.NoAuthException
{    if (skipACL) {        return;    }                if (acl == null || acl.size() == 0) {        return;    }    for (Id authId : ids) {        if (authId.getScheme().equals("super")) {            return;        }    }    for (ACL a : acl) {        Id id = a.getId();        if ((a.getPerms() & perm) != 0) {            if (id.getScheme().equals("world") && id.getId().equals("anyone")) {                return;            }            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap != null) {                for (Id authId : ids) {                    if (authId.getScheme().equals(id.getScheme()) && ap.matches(new ServerAuthenticationProvider.ServerObjs(this, cnxn), new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {                        return;                    }                }            }        }    }    throw new KeeperException.NoAuthException();}
1
public static boolean isDigestEnabled()
{    return digestEnabled;}
0
public static void setDigestEnabled(boolean digestEnabled)
{        ZooKeeperServer.digestEnabled = digestEnabled;}
1
private String parentPath(String path) throws KeeperException.BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || getZKDatabase().isSpecialPath(path)) {        throw new KeeperException.BadArgumentsException(path);    }    return lastSlash == 0 ? "/" : path.substring(0, lastSlash);}
0
private String effectiveACLPath(Request request) throws KeeperException.BadArgumentsException, KeeperException.InvalidACLException
{    boolean mustCheckACL = false;    String path = null;    List<ACL> acl = null;    switch(request.type) {        case OpCode.create:        case OpCode.create2:            {                CreateRequest req = new CreateRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = parentPath(req.getPath());                }                break;            }        case OpCode.delete:            {                DeleteRequest req = new DeleteRequest();                if (buffer2Record(request.request, req)) {                    path = parentPath(req.getPath());                }                break;            }        case OpCode.setData:            {                SetDataRequest req = new SetDataRequest();                if (buffer2Record(request.request, req)) {                    path = req.getPath();                }                break;            }        case OpCode.setACL:            {                SetACLRequest req = new SetACLRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = req.getPath();                }                break;            }    }    if (mustCheckACL) {        /* we ignore the extrapolated ACL returned by fixupACL because             * we only care about it being well-formed (and if it isn't, an             * exception will be raised).             */        PrepRequestProcessor.fixupACL(path, request.authInfo, acl);    }    return path;}
0
private int effectiveACLPerms(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:            return ZooDefs.Perms.CREATE;        case OpCode.delete:            return ZooDefs.Perms.DELETE;        case OpCode.setData:            return ZooDefs.Perms.WRITE;        case OpCode.setACL:            return ZooDefs.Perms.ADMIN;        default:            return ZooDefs.Perms.ALL;    }}
0
public boolean authWriteRequest(Request request)
{    int err;    String pathToCheck;    if (!enableEagerACLCheck) {        return true;    }    err = KeeperException.Code.OK.intValue();    try {        pathToCheck = effectiveACLPath(request);        if (pathToCheck != null) {            checkACL(request.cnxn, zkDb.getACL(pathToCheck, null), effectiveACLPerms(request), request.authInfo, pathToCheck, null);        }    } catch (KeeperException.NoAuthException e) {                err = e.code().intValue();    } catch (KeeperException.InvalidACLException e) {                err = e.code().intValue();    } catch (KeeperException.NoNodeException e) {            } catch (KeeperException.BadArgumentsException e) {            } catch (Throwable t) {                throw t;    } finally {        if (err != KeeperException.Code.OK.intValue()) {            /*  This request has a bad ACL, so we are dismissing it early. */            decInProcess();            ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);            try {                request.cnxn.sendResponse(rh, null, null);            } catch (IOException e) {                            }        }    }    return err == KeeperException.Code.OK.intValue();}
1
private boolean buffer2Record(ByteBuffer request, Record record)
{    boolean rv = false;    try {        ByteBufferInputStream.byteBuffer2Record(request, record);        request.rewind();        rv = true;    } catch (IOException ex) {    }    return rv;}
0
public String getClientPort()
{    return Integer.toString(zks.getClientPort());}
0
public String getName()
{    return name;}
0
public boolean isHidden()
{    return false;}
0
public String getStartTime()
{    return startTime.toString();}
0
public String getVersion()
{    return Version.getFullVersion();}
0
public double getAvgRequestLatency()
{    return zks.serverStats().getAvgLatency();}
0
public long getMaxRequestLatency()
{    return zks.serverStats().getMaxLatency();}
0
public long getMinRequestLatency()
{    return zks.serverStats().getMinLatency();}
0
public long getOutstandingRequests()
{    return zks.serverStats().getOutstandingRequests();}
0
public int getTickTime()
{    return zks.getTickTime();}
0
public void setTickTime(int tickTime)
{    zks.setTickTime(tickTime);}
0
public int getMaxClientCnxnsPerHost()
{    return zks.getMaxClientCnxnsPerHost();}
0
public void setMaxClientCnxnsPerHost(int max)
{    if (zks.serverCnxnFactory != null) {        zks.serverCnxnFactory.setMaxClientCnxnsPerHost(max);    }    if (zks.secureServerCnxnFactory != null) {        zks.secureServerCnxnFactory.setMaxClientCnxnsPerHost(max);    }}
0
public int getMinSessionTimeout()
{    return zks.getMinSessionTimeout();}
0
public void setMinSessionTimeout(int min)
{    zks.setMinSessionTimeout(min);}
0
public int getMaxSessionTimeout()
{    return zks.getMaxSessionTimeout();}
0
public void setMaxSessionTimeout(int max)
{    zks.setMaxSessionTimeout(max);}
0
public long getDataDirSize()
{    return zks.getDataDirSize();}
0
public long getLogDirSize()
{    return zks.getLogDirSize();}
0
public long getPacketsReceived()
{    return zks.serverStats().getPacketsReceived();}
0
public long getPacketsSent()
{    return zks.serverStats().getPacketsSent();}
0
public long getFsyncThresholdExceedCount()
{    return zks.serverStats().getFsyncThresholdExceedCount();}
0
public void resetLatency()
{    zks.serverStats().resetLatency();}
0
public void resetMaxLatency()
{    zks.serverStats().resetMaxLatency();}
0
public void resetFsyncThresholdExceedCount()
{    zks.serverStats().resetFsyncThresholdExceedCount();}
0
public void resetStatistics()
{    ServerStats serverStats = zks.serverStats();    serverStats.resetRequestCounters();    serverStats.resetLatency();    serverStats.resetFsyncThresholdExceedCount();}
0
public long getNumAliveConnections()
{    return zks.getNumAliveConnections();}
0
public String getSecureClientPort()
{    if (zks.secureServerCnxnFactory != null) {        return Integer.toString(zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
0
public String getSecureClientAddress()
{    if (zks.secureServerCnxnFactory != null) {        return String.format("%s:%d", zks.secureServerCnxnFactory.getLocalAddress().getHostString(), zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
0
public long getTxnLogElapsedSyncTime()
{    return zks.getTxnLogElapsedSyncTime();}
0
public int getJuteMaxBufferSize()
{    return BinaryInputArchive.maxBuffer;}
0
public int getLastClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getLastBufferSize();}
0
public int getMinClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getMinBufferSize();}
0
public int getMaxClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getMaxBufferSize();}
0
public boolean getResponseCachingEnabled()
{    return zks.isResponseCachingEnabled();}
0
public void setResponseCachingEnabled(boolean isEnabled)
{    zks.setResponseCachingEnabled(isEnabled);}
0
public int getConnectionMaxTokens()
{    return zks.connThrottle().getMaxTokens();}
0
public void setConnectionMaxTokens(int val)
{    zks.connThrottle().setMaxTokens(val);}
0
public int getConnectionTokenFillTime()
{    return zks.connThrottle().getFillTime();}
0
public void setConnectionTokenFillTime(int val)
{    zks.connThrottle().setFillTime(val);}
0
public int getConnectionTokenFillCount()
{    return zks.connThrottle().getFillCount();}
0
public void setConnectionTokenFillCount(int val)
{    zks.connThrottle().setFillCount(val);}
0
public int getConnectionFreezeTime()
{    return zks.connThrottle().getFreezeTime();}
0
public void setConnectionFreezeTime(int val)
{    zks.connThrottle().setFreezeTime(val);}
0
public double getConnectionDropIncrease()
{    return zks.connThrottle().getDropIncrease();}
0
public void setConnectionDropIncrease(double val)
{    zks.connThrottle().setDropIncrease(val);}
0
public double getConnectionDropDecrease()
{    return zks.connThrottle().getDropDecrease();}
0
public void setConnectionDropDecrease(double val)
{    zks.connThrottle().setDropDecrease(val);}
0
public double getConnectionDecreaseRatio()
{    return zks.connThrottle().getDecreasePoint();}
0
public void setConnectionDecreaseRatio(double val)
{    zks.connThrottle().setDecreasePoint(val);}
0
public int getCommitProcMaxReadBatchSize()
{    return CommitProcessor.getMaxReadBatchSize();}
0
public void setCommitProcMaxReadBatchSize(int size)
{    CommitProcessor.setMaxReadBatchSize(size);}
0
public int getCommitProcMaxCommitBatchSize()
{    return CommitProcessor.getMaxCommitBatchSize();}
0
public void setCommitProcMaxCommitBatchSize(int size)
{    CommitProcessor.setMaxCommitBatchSize(size);}
0
public long getFlushDelay()
{    return zks.getFlushDelay();}
0
public void setFlushDelay(long delay)
{    ZooKeeperServer.setFlushDelay(delay);}
0
public int getRequestThrottleLimit()
{    return RequestThrottler.getMaxRequests();}
0
public void setRequestThrottleLimit(int requests)
{    RequestThrottler.setMaxRequests(requests);}
0
public int getRequestThrottleStallTime()
{    return RequestThrottler.getStallTime();}
0
public void setRequestThrottleStallTime(int time)
{    RequestThrottler.setStallTime(time);}
0
public boolean getRequestThrottleDropStale()
{    return RequestThrottler.getDropStaleRequests();}
0
public void setRequestThrottleDropStale(boolean drop)
{    RequestThrottler.setDropStaleRequests(drop);}
0
public long getMaxWriteQueuePollTime()
{    return zks.getMaxWriteQueuePollTime();}
0
public void setMaxWriteQueuePollTime(long delay)
{    ZooKeeperServer.setMaxWriteQueuePollTime(delay);}
0
public boolean getRequestStaleLatencyCheck()
{    return Request.getStaleLatencyCheck();}
0
public void setRequestStaleLatencyCheck(boolean check)
{    Request.setStaleLatencyCheck(check);}
0
public int getMaxBatchSize()
{    return zks.getMaxBatchSize();}
0
public void setMaxBatchSize(int size)
{    ZooKeeperServer.setMaxBatchSize(size);}
0
public boolean getRequestStaleConnectionCheck()
{    return Request.getStaleConnectionCheck();}
0
public void setRequestStaleConnectionCheck(boolean check)
{    Request.setStaleConnectionCheck(check);}
0
public int getLargeRequestMaxBytes()
{    return zks.getLargeRequestMaxBytes();}
0
public void setLargeRequestMaxBytes(int bytes)
{    zks.setLargeRequestMaxBytes(bytes);}
0
public int getLargeRequestThreshold()
{    return zks.getLargeRequestThreshold();}
0
public void setLargeRequestThreshold(int threshold)
{    zks.setLargeRequestThreshold(threshold);}
0
public int getClientPort()
{    return clientPort;}
0
public String getDataDir()
{    return dataDir;}
0
public String getDataLogDir()
{    return dataLogDir;}
0
public int getTickTime()
{    return tickTime;}
0
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxnsPerHost;}
0
public int getMinSessionTimeout()
{    return minSessionTimeout;}
0
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
0
public long getServerId()
{    return serverId;}
0
public int getClientPortListenBacklog()
{    return clientPortListenBacklog;}
0
public Map<String, Object> toMap()
{    Map<String, Object> conf = new LinkedHashMap<String, Object>();    conf.put(KEY_CLIENT_PORT, clientPort);    conf.put(KEY_DATA_DIR, dataDir);    conf.put(KEY_DATA_LOG_DIR, dataLogDir);    conf.put(KEY_TICK_TIME, tickTime);    conf.put(KEY_MAX_CLIENT_CNXNS, maxClientCnxnsPerHost);    conf.put(KEY_MIN_SESSION_TIMEOUT, minSessionTimeout);    conf.put(KEY_MAX_SESSION_TIMEOUT, maxSessionTimeout);    conf.put(KEY_SERVER_ID, serverId);    conf.put(KEY_CLIENT_PORT_LISTEN_BACKLOG, clientPortListenBacklog);    return conf;}
0
public void notifyStopping(String threadName, int exitCode)
{        zkServer.setState(State.ERROR);}
1
public static void main(String[] args)
{    ZooKeeperServerMain main = new ZooKeeperServerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {                        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {                System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {                System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {                System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {                System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }        System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
1
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {            }    ServerConfig config = new ServerConfig();    if (args.length == 1) {        config.parse(args[0]);    } else {        config.parse(args);    }    runFromConfig(config);}
1
public void runFromConfig(ServerConfig config) throws IOException, AdminServerException
{        FileTxnSnapLog txnLog = null;    try {        try {            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());        } catch (MetricsProviderLifeCycleException error) {            throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);        }        ServerMetrics.metricsProviderInitialized(metricsProvider);                                        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);        JvmPauseMonitor jvmPauseMonitor = null;        if (config.jvmPauseMonitorToRun) {            jvmPauseMonitor = new JvmPauseMonitor(config);        }        final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);        txnLog.setServerStats(zkServer.serverStats());                        final CountDownLatch shutdownLatch = new CountDownLatch(1);        zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));                adminServer = AdminServerFactory.createAdminServer();        adminServer.setZooKeeperServer(zkServer);        adminServer.start();        boolean needStartZKServer = true;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);            cnxnFactory.startup(zkServer);                        needStartZKServer = false;        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);            secureCnxnFactory.startup(zkServer, needStartZKServer);        }        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();                        shutdownLatch.await();        shutdown();        if (cnxnFactory != null) {            cnxnFactory.join();        }        if (secureCnxnFactory != null) {            secureCnxnFactory.join();        }        if (zkServer.canShutdown()) {            zkServer.shutdown(true);        }    } catch (InterruptedException e) {                    } finally {        if (txnLog != null) {            txnLog.close();        }        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                            }        }    }}
1
protected void shutdown()
{    if (containerManager != null) {        containerManager.stop();    }    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }    try {        if (adminServer != null) {            adminServer.shutdown();        }    } catch (AdminServerException e) {            }}
1
 ServerCnxnFactory getCnxnFactory()
{    return cnxnFactory;}
0
 void handle(State state)
{    if (state == State.ERROR || state == State.SHUTDOWN) {        shutdownLatch.countDown();    }}
0
public void uncaughtException(Thread t, Throwable e)
{    handleException(t.getName(), e);}
0
protected void handleException(String thName, Throwable e)
{    }
1
public static synchronized long getTextTraceLevel()
{    return traceMask;}
0
public static synchronized void setTextTraceLevel(long mask)
{    traceMask = mask;    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);    }
1
public static synchronized boolean isTraceEnabled(Logger log, long mask)
{    return log.isTraceEnabled() && (mask & traceMask) != 0;}
0
public static void logTraceMessage(Logger log, long mask, String msg)
{    if (isTraceEnabled(log, mask)) {        log.trace(msg);    }}
0
public static void logQuorumPacket(Logger log, long mask, char direction, QuorumPacket qp)
{    if (isTraceEnabled(log, mask)) {        logTraceMessage(log, mask, direction + " " + LearnerHandler.packetToString(qp));    }}
0
public static void logRequest(Logger log, long mask, char rp, Request request, String header)
{    if (isTraceEnabled(log, mask)) {        log.trace(header + ":" + rp + request.toString());    }}
0
public static void ruok(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("ruok".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
public static void dump(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("dump".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
public static void stat(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("stat".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
public static void kill(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("kill".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
public static void setTraceMask(String host, int port, String traceMaskStr)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        long traceMask = Long.parseLong(traceMaskStr, 8);        req.putInt(ByteBuffer.wrap("stmk".getBytes()).getInt());        req.putLong(traceMask);        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv) + " masks=0" + Long.toOctalString(traceMask));        assert (retv == traceMask);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
public static void getTraceMask(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("gtmk".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv));    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
1
private static void usage()
{    System.out.println("usage: java [-cp CLASSPATH] org.apache.zookeeper.ServerAdminClient " + "host port op (ruok|stat|dump|kill|gettracemask|settracemask) [arguments]");}
0
public static void main(String[] args)
{    if (args.length < 3) {        usage();        return;    }    String host = args[0];    int port = Integer.parseInt(args[1]);    String op = args[2];    if (op.equalsIgnoreCase("gettracemask")) {        getTraceMask(host, port);    } else if (op.equalsIgnoreCase("settracemask")) {        setTraceMask(host, port, args[3]);    } else if (op.equalsIgnoreCase("ruok")) {        ruok(host, port);    } else if (op.equalsIgnoreCase("kill")) {        kill(host, port);    } else if (op.equalsIgnoreCase("stat")) {        stat(host, port);    } else if (op.equalsIgnoreCase("dump")) {        dump(host, port);    } else {        System.out.println("Unrecognized op: " + op);    }}
0
public static String[] getGroupsCommand()
{    return new String[] { "bash", "-c", "groups" };}
0
public static String[] getGroupsForUserCommand(final String user)
{        return new String[] { "bash", "-c", "id -Gn " + user };}
0
public static String[] getGET_PERMISSION_COMMAND()
{        return new String[] { (WINDOWS ? "ls" : "/bin/ls"), "-ld" };}
0
public static String[] getUlimitMemoryCommand(int memoryLimit)
{        if (WINDOWS) {        return null;    }    return new String[] { ULIMIT_COMMAND, "-v", String.valueOf(memoryLimit) };}
0
protected void setEnvironment(Map<String, String> env)
{    this.environment = env;}
0
protected void setWorkingDirectory(File dir)
{    this.dir = dir;}
0
protected void run() throws IOException
{    if (lastTime + interval > Time.currentElapsedTime()) {        return;    }        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    runCommand();}
0
private void runCommand() throws IOException
{    ProcessBuilder builder = new ProcessBuilder(getExecString());    Timer timeOutTimer = null;    ShellTimeoutTimerTask timeoutTimerTask = null;    timedOut = new AtomicBoolean(false);    completed = new AtomicBoolean(false);    if (environment != null) {        builder.environment().putAll(this.environment);    }    if (dir != null) {        builder.directory(this.dir);    }    process = builder.start();    if (timeOutInterval > 0) {        timeOutTimer = new Timer();        timeoutTimerTask = new ShellTimeoutTimerTask(this);                timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);    }    final BufferedReader errReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));    BufferedReader inReader = new BufferedReader(new InputStreamReader(process.getInputStream()));    final StringBuffer errMsg = new StringBuffer();            Thread errThread = new Thread() {        @Override        public void run() {            try {                String line = errReader.readLine();                while ((line != null) && !isInterrupted()) {                    errMsg.append(line);                    errMsg.append(System.getProperty("line.separator"));                    line = errReader.readLine();                }            } catch (IOException ioe) {                            }        }    };    try {        errThread.start();    } catch (IllegalStateException ise) {    }    try {                parseExecResult(inReader);                String line = inReader.readLine();        while (line != null) {            line = inReader.readLine();        }                exitCode = process.waitFor();        try {                        errThread.join();        } catch (InterruptedException ie) {                    }        completed.set(true);                if (exitCode != ExitCode.EXECUTION_FINISHED.getValue()) {            throw new ExitCodeException(exitCode, errMsg.toString());        }    } catch (InterruptedException ie) {        throw new IOException(ie.toString());    } finally {        if ((timeOutTimer != null) && !timedOut.get()) {            timeOutTimer.cancel();        }                try {            inReader.close();        } catch (IOException ioe) {                    }        if (!completed.get()) {            errThread.interrupt();        }        try {            errReader.close();        } catch (IOException ioe) {                    }        process.destroy();        lastTime = Time.currentElapsedTime();    }}
1
public void run()
{    try {        String line = errReader.readLine();        while ((line != null) && !isInterrupted()) {            errMsg.append(line);            errMsg.append(System.getProperty("line.separator"));            line = errReader.readLine();        }    } catch (IOException ioe) {            }}
1
public Process getProcess()
{    return process;}
0
public int getExitCode()
{    return exitCode;}
0
public int getExitCode()
{    return exitCode;}
0
public void execute() throws IOException
{    this.run();}
0
protected String[] getExecString()
{    return command;}
0
protected void parseExecResult(BufferedReader lines) throws IOException
{    output = new StringBuffer();    char[] buf = new char[512];    int nRead;    while ((nRead = lines.read(buf, 0, buf.length)) > 0) {        output.append(buf, 0, nRead);    }}
0
public String getOutput()
{    return (output == null) ? "" : output.toString();}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    String[] args = getExecString();    for (String s : args) {        if (s.indexOf(' ') >= 0) {            builder.append('"').append(s).append('"');        } else {            builder.append(s);        }        builder.append(' ');    }    return builder.toString();}
0
public boolean isTimedOut()
{    return timedOut.get();}
0
private void setTimedOut()
{    this.timedOut.set(true);}
0
public static String execCommand(String... cmd) throws IOException
{    return execCommand(null, cmd, 0L);}
0
public static String execCommand(Map<String, String> env, String[] cmd, long timeout) throws IOException
{    ShellCommandExecutor exec = new ShellCommandExecutor(cmd, null, env, timeout);    exec.execute();    return exec.getOutput();}
0
public static String execCommand(Map<String, String> env, String... cmd) throws IOException
{    return execCommand(env, cmd, 0L);}
0
public void run()
{    Process p = shell.getProcess();    try {        p.exitValue();    } catch (Exception e) {                if (p != null && !shell.completed.get()) {            shell.setTimedOut();            p.destroy();        }    }}
0
public int getCount()
{    return this.count;}
0
public void setCount(int count)
{    this.count = count;}
0
public long getBytes()
{    return this.bytes;}
0
public void setBytes(long bytes)
{    this.bytes = bytes;}
0
public String toString()
{    return countStr + "=" + count + "," + byteStr + "=" + bytes;}
0
public Transaction create(final String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    ops.add(Op.create(path, data, acl, createMode.toFlag()));    return this;}
0
public Transaction delete(final String path, int version)
{    ops.add(Op.delete(path, version));    return this;}
0
public Transaction check(String path, int version)
{    ops.add(Op.check(path, version));    return this;}
0
public Transaction setData(final String path, byte[] data, int version)
{    ops.add(Op.setData(path, data, version));    return this;}
0
public List<OpResult> commit() throws InterruptedException, KeeperException
{    return zk.multi(ops);}
0
public void commit(MultiCallback cb, Object ctx)
{    zk.multi(ops, cb, ctx);}
0
public static KeyStore loadTrustStore(File certificateChainFile) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    for (X509Certificate certificate : certificateChain) {        X500Principal principal = certificate.getSubjectX500Principal();        keyStore.setCertificateEntry(principal.getName("RFC2253"), certificate);    }    return keyStore;}
0
public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    if (certificateChain.isEmpty()) {        throw new CertificateException("Certificate file does not contain any certificates: " + certificateChainFile);    }    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    keyStore.setKeyEntry("key", key, keyPassword.orElse("").toCharArray(), certificateChain.toArray(new Certificate[0]));    return keyStore;}
0
public static List<X509Certificate> readCertificateChain(File certificateChainFile) throws IOException, GeneralSecurityException
{    String contents = new String(Files.readAllBytes(certificateChainFile.toPath()), US_ASCII);    return readCertificateChain(contents);}
0
public static List<X509Certificate> readCertificateChain(String certificateChain) throws CertificateException
{    Matcher matcher = CERT_PATTERN.matcher(certificateChain);    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");    List<X509Certificate> certificates = new ArrayList<>();    int start = 0;    while (matcher.find(start)) {        byte[] buffer = base64Decode(matcher.group(1));        certificates.add((X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(buffer)));        start = matcher.end();    }    return certificates;}
0
public static PrivateKey loadPrivateKey(File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    String privateKey = new String(Files.readAllBytes(privateKeyFile.toPath()), US_ASCII);    return loadPrivateKey(privateKey, keyPassword);}
0
public static PrivateKey loadPrivateKey(String privateKey, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    Matcher matcher = PRIVATE_KEY_PATTERN.matcher(privateKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a private key");    }    byte[] encodedKey = base64Decode(matcher.group(1));    PKCS8EncodedKeySpec encodedKeySpec;    if (keyPassword.isPresent()) {        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(encodedKey);        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());        SecretKey secretKey = keyFactory.generateSecret(new PBEKeySpec(keyPassword.get().toCharArray()));        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName());        cipher.init(DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters());        encodedKeySpec = encryptedPrivateKeyInfo.getKeySpec(cipher);    } else {        encodedKeySpec = new PKCS8EncodedKeySpec(encodedKey);    }        try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePrivate(encodedKeySpec);}
0
public static PublicKey loadPublicKey(File publicKeyFile) throws IOException, GeneralSecurityException
{    String publicKey = new String(Files.readAllBytes(publicKeyFile.toPath()), US_ASCII);    return loadPublicKey(publicKey);}
0
public static PublicKey loadPublicKey(String publicKey) throws GeneralSecurityException
{    Matcher matcher = PUBLIC_KEY_PATTERN.matcher(publicKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a public key");    }    String data = matcher.group(1);    byte[] encodedKey = base64Decode(data);    X509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(encodedKey);    try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePublic(encodedKeySpec);}
0
private static byte[] base64Decode(String base64)
{    return getMimeDecoder().decode(base64.getBytes(US_ASCII));}
0
public SaslServer run()
{    try {        SaslServer saslServer;        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);        return saslServer;    } catch (SaslException e) {                return null;    }}
1
public static String getServerPrincipal(String principalConfig, String hostname)
{    String[] components = getComponents(principalConfig);    if (components == null || components.length != 2 || !components[1].equals(QUORUM_HOSTNAME_PATTERN)) {        return principalConfig;    } else {        return replacePattern(components, hostname);    }}
0
private static String[] getComponents(String principalConfig)
{    if (principalConfig == null) {        return null;    }    return principalConfig.split("[/]");}
0
private static String replacePattern(String[] components, String hostname)
{    return components[0] + "/" + hostname.toLowerCase();}
0
 static void printUsage()
{    System.out.print("Usage:\tjava  -cp <classpath> org.apache.zookeeper." + "version.util.VerGen maj.min.micro[-qualifier] rev buildDate outputDirectory");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
0
public static Version parseVersionString(String input)
{    Version result = new Version();    Pattern p = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)((\\.\\d+)*)(-(.+))?$");    Matcher m = p.matcher(input);    if (!m.matches()) {        return null;    }    result.maj = Integer.parseInt(m.group(1));    result.min = Integer.parseInt(m.group(2));    result.micro = Integer.parseInt(m.group(3));    if (m.groupCount() == 7) {        result.qualifier = m.group(7);    } else {        result.qualifier = null;    }    return result;}
0
public static void main(String[] args)
{    if (args.length != 4) {        printUsage();    }    try {        Version version = parseVersionString(args[0]);        if (version == null) {            System.err.println("Invalid version number format, must be \"x.y.z(-.*)?\"");            System.exit(ExitCode.UNEXPECTED_ERROR.getValue());        }        String rev = args[1];        if (rev == null || rev.trim().isEmpty()) {            rev = "-1";        } else {            rev = rev.trim();        }        generateFile(new File(args[3]), version, rev, args[2]);    } catch (NumberFormatException e) {        System.err.println("All version-related parameters must be valid integers!");        throw e;    }}
0
public static String getRevisionHash()
{    return REVISION_HASH;}
0
public static String getBuildDate()
{    return BUILD_DATE;}
0
public static String getVersion()
{    return MAJOR + "." + MINOR + "." + MICRO + (QUALIFIER == null ? "" : "-" + QUALIFIER);}
0
public static String getVersionRevision()
{    return getVersion() + "-" + getRevisionHash();}
0
public static String getFullVersion()
{    return getVersionRevision() + ", built on " + getBuildDate();}
0
public static void printUsage()
{    System.out.print("Usage:\tjava -cp ... org.apache.zookeeper.Version " + "[--full | --short | --revision],\n\tPrints --full version " + "info if no arg specified.");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
0
public static void main(String[] args)
{    if (args.length > 1) {        printUsage();    }    if (args.length == 0 || (args.length == 1 && args[0].equals("--full"))) {        System.out.println(getFullVersion());        System.exit(ExitCode.EXECUTION_FINISHED.getValue());    }    if (args[0].equals("--short")) {        System.out.println(getVersion());    } else if (args[0].equals("--revision")) {        System.out.println(getVersionRevision());    } else {        printUsage();    }    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
0
public Map<EventType, Set<Watcher>> unregister(int rc) throws KeeperException
{    return zkManager.removeWatcher(clientPath, watcher, watcherType, local, rc);}
0
public String getClientPath()
{    return clientPath;}
0
public KeeperState getState()
{    return keeperState;}
0
public EventType getType()
{    return eventType;}
0
public String getPath()
{    return path;}
0
public String toString()
{    return "WatchedEvent state:" + keeperState + " type:" + eventType + " path:" + path;}
0
public WatcherEvent getWrapper()
{    return new WatcherEvent(eventType.getIntValue(), keeperState.getIntValue(), path);}
0
public int getIntValue()
{    return intValue;}
0
public static KeeperState fromInt(int intValue)
{    switch(intValue) {        case -1:            return KeeperState.Unknown;        case 0:            return KeeperState.Disconnected;        case 1:            return KeeperState.NoSyncConnected;        case 3:            return KeeperState.SyncConnected;        case 4:            return KeeperState.AuthFailed;        case 5:            return KeeperState.ConnectedReadOnly;        case 6:            return KeeperState.SaslAuthenticated;        case -112:            return KeeperState.Expired;        case 7:            return KeeperState.Closed;        default:            throw new RuntimeException("Invalid integer value for conversion to KeeperState");    }}
0
public int getIntValue()
{    return intValue;}
0
public static EventType fromInt(int intValue)
{    switch(intValue) {        case -1:            return EventType.None;        case 1:            return EventType.NodeCreated;        case 2:            return EventType.NodeDeleted;        case 3:            return EventType.NodeDataChanged;        case 4:            return EventType.NodeChildrenChanged;        case 5:            return EventType.DataWatchRemoved;        case 6:            return EventType.ChildWatchRemoved;        default:            throw new RuntimeException("Invalid integer value for conversion to EventType");    }}
0
public int getIntValue()
{    return intValue;}
0
public static WatcherType fromInt(int intValue)
{    switch(intValue) {        case 1:            return WatcherType.Children;        case 2:            return WatcherType.Data;        case 3:            return WatcherType.Any;        default:            throw new RuntimeException("Invalid integer value for conversion to WatcherType");    }}
0
public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot, final int batchSize) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);        return deleteInBatch(zk, tree, batchSize);}
1
private static boolean deleteInBatch(ZooKeeper zk, List<String> tree, int batchSize) throws InterruptedException
{    int rateLimit = 10;    List<Op> ops = new ArrayList<>();    BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit);    MultiCallback cb = (rc, path, ctx, opResults) -> {        ((BatchedDeleteCbContext) ctx).sem.release();        if (rc != Code.OK.intValue()) {            ((BatchedDeleteCbContext) ctx).success.set(false);        }    };        for (int i = tree.size() - 1; i >= 0; --i) {                ops.add(Op.delete(tree.get(i), -1));        if (ops.size() == batchSize || i == 0) {            if (!context.success.get()) {                                break;            }            context.sem.acquire();            zk.multi(ops, cb, context);            ops = new ArrayList<>();        }    }        context.sem.acquire(rateLimit);    return context.success.get();}
0
public static void deleteRecursive(ZooKeeper zk, final String pathRoot, VoidCallback cb, Object ctx) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);        for (int i = tree.size() - 1; i >= 0; --i) {                        zk.delete(tree.get(i), -1, cb, ctx);    }}
1
public static String validateFileInput(String filePath)
{    File file = new File(filePath);    if (!file.exists()) {        return "File '" + file.getAbsolutePath() + "' does not exist.";    }    if (!file.canRead()) {        return "Read permission is denied on the file '" + file.getAbsolutePath() + "'";    }    if (file.isDirectory()) {        return "'" + file.getAbsolutePath() + "' is a direcory. it must be a file.";    }    return null;}
0
public static List<String> listSubTreeBFS(ZooKeeper zk, final String pathRoot) throws KeeperException, InterruptedException
{    Queue<String> queue = new ArrayDeque<>();    List<String> tree = new ArrayList<String>();    queue.add(pathRoot);    tree.add(pathRoot);    while (!queue.isEmpty()) {        String node = queue.poll();        List<String> children = zk.getChildren(node, false);        for (final String child : children) {            final String childPath = node + "/" + child;            queue.add(childPath);            tree.add(childPath);        }    }    return tree;}
0
public static void visitSubTreeDFS(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{    PathUtils.validatePath(path);    zk.getData(path, watch, null);    cb.processResult(Code.OK.intValue(), path, null, path);    visitSubTreeDFSHelper(zk, path, watch, cb);}
0
private static void visitSubTreeDFSHelper(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{        final boolean isRoot = path.length() == 1;    try {        List<String> children = zk.getChildren(path, watch, null);        Collections.sort(children);        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            cb.processResult(Code.OK.intValue(), childPath, null, child);        }        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            visitSubTreeDFSHelper(zk, childPath, watch, cb);        }    } catch (KeeperException.NoNodeException e) {                return;    }}
0
public void updateServerList(String connectString) throws IOException
{    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);    Collection<InetSocketAddress> serverAddresses = connectStringParser.getServerAddresses();    ClientCnxnSocket clientCnxnSocket = cnxn.sendThread.getClientCnxnSocket();    InetSocketAddress currentHost = (InetSocketAddress) clientCnxnSocket.getRemoteSocketAddress();    boolean reconfigMode = hostProvider.updateServerList(serverAddresses, currentHost);        if (reconfigMode) {        clientCnxnSocket.testableCloseSocket();    }}
0
public ZooKeeperSaslClient getSaslClient()
{    return cnxn.zooKeeperSaslClient;}
0
public ZKClientConfig getClientConfig()
{    return clientConfig;}
0
protected List<String> getDataWatches()
{    synchronized (watchManager.dataWatches) {        List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());        return rc;    }}
0
protected List<String> getExistWatches()
{    synchronized (watchManager.existWatches) {        List<String> rc = new ArrayList<String>(watchManager.existWatches.keySet());        return rc;    }}
0
protected List<String> getChildWatches()
{    synchronized (watchManager.childWatches) {        List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());        return rc;    }}
0
private void addTo(Set<Watcher> from, Set<Watcher> to)
{    if (from != null) {        to.addAll(from);    }}
0
public Map<EventType, Set<Watcher>> removeWatcher(String clientPath, Watcher watcher, WatcherType watcherType, boolean local, int rc) throws KeeperException
{            containsWatcher(clientPath, watcher, watcherType);    Map<EventType, Set<Watcher>> removedWatchers = new HashMap<>();    HashSet<Watcher> childWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.ChildWatchRemoved, childWatchersToRem);    HashSet<Watcher> dataWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.DataWatchRemoved, dataWatchersToRem);    boolean removedWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    removedWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                break;            }        case Any:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                synchronized (dataWatches) {                    boolean removedDataWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }            }    }        if (!removedWatcher) {        throw new KeeperException.NoWatcherException(clientPath);    }    return removedWatchers;}
0
private boolean contains(String path, Watcher watcherObj, Map<String, Set<Watcher>> pathVsWatchers)
{    boolean watcherExists = true;    if (pathVsWatchers == null || pathVsWatchers.size() == 0) {        watcherExists = false;    } else {        Set<Watcher> watchers = pathVsWatchers.get(path);        if (watchers == null) {            watcherExists = false;        } else if (watcherObj == null) {            watcherExists = watchers.size() > 0;        } else {            watcherExists = watchers.contains(watcherObj);        }    }    return watcherExists;}
0
 void containsWatcher(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{    boolean containsWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    containsWatcher = contains(path, watcher, dataWatches);                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }                break;            }        case Any:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                synchronized (dataWatches) {                    boolean contains_temp = contains(path, watcher, dataWatches);                    containsWatcher |= contains_temp;                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }            }    }        if (!containsWatcher) {        throw new KeeperException.NoWatcherException(path);    }}
0
protected boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    if (!local && rc != Code.OK.intValue()) {        throw KeeperException.create(KeeperException.Code.get(rc), path);    }    boolean success = false;        if (rc == Code.OK.intValue() || (local && rc != Code.OK.intValue())) {                if (watcher == null) {            Set<Watcher> pathWatchers = pathVsWatcher.remove(path);            if (pathWatchers != null) {                                removedWatchers.addAll(pathWatchers);                success = true;            }        } else {            Set<Watcher> watchers = pathVsWatcher.get(path);            if (watchers != null) {                if (watchers.remove(watcher)) {                                        removedWatchers.add(watcher);                                        if (watchers.size() <= 0) {                        pathVsWatcher.remove(path);                    }                    success = true;                }            }        }    }    return success;}
0
public Set<Watcher> materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath)
{    Set<Watcher> result = new HashSet<Watcher>();    switch(type) {        case None:            result.add(defaultWatcher);            boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected;            synchronized (dataWatches) {                for (Set<Watcher> ws : dataWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    dataWatches.clear();                }            }            synchronized (existWatches) {                for (Set<Watcher> ws : existWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    existWatches.clear();                }            }            synchronized (childWatches) {                for (Set<Watcher> ws : childWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    childWatches.clear();                }            }            return result;        case NodeDataChanged:        case NodeCreated:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }            synchronized (existWatches) {                addTo(existWatches.remove(clientPath), result);            }            break;        case NodeChildrenChanged:            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        case NodeDeleted:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }                        synchronized (existWatches) {                Set<Watcher> list = existWatches.remove(clientPath);                if (list != null) {                    addTo(list, result);                                    }            }            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        default:            String msg = "Unhandled watch event type " + type + " with state " + state + " on path " + clientPath;                        throw new RuntimeException(msg);    }    return result;}
1
public void register(int rc)
{    if (shouldAddWatch(rc)) {        Map<String, Set<Watcher>> watches = getWatches(rc);        synchronized (watches) {            Set<Watcher> watchers = watches.get(clientPath);            if (watchers == null) {                watchers = new HashSet<Watcher>();                watches.put(clientPath, watchers);            }            watchers.add(watcher);        }    }}
0
protected boolean shouldAddWatch(int rc)
{    return rc == 0;}
0
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return rc == 0 ? watchManager.dataWatches : watchManager.existWatches;}
0
protected boolean shouldAddWatch(int rc)
{    return rc == 0 || rc == KeeperException.Code.NONODE.intValue();}
0
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return watchManager.dataWatches;}
0
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return watchManager.childWatches;}
0
public boolean isAlive()
{    return this != CLOSED && this != AUTH_FAILED;}
0
public boolean isConnected()
{    return this == CONNECTED || this == CONNECTEDREADONLY;}
0
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new ClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watchManager, clientCnxnSocket, canBeReadOnly);}
0
private static HostProvider createDefaultHostProvider(String connectString)
{    return new StaticHostProvider(new ConnectStringParser(connectString).getServerAddresses());}
0
public Testable getTestable()
{    return new ZooKeeperTestable(cnxn);}
0
protected ZKWatchManager defaultWatchManager()
{    return new ZKWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));}
0
public long getSessionId()
{    return cnxn.getSessionId();}
0
public byte[] getSessionPasswd()
{    return cnxn.getSessionPasswd();}
0
public int getSessionTimeout()
{    return cnxn.getSessionTimeout();}
0
public void addAuthInfo(String scheme, byte[] auth)
{    cnxn.addAuthInfo(scheme, auth);}
0
public synchronized void register(Watcher watcher)
{    watchManager.defaultWatcher = watcher;}
0
public synchronized void close() throws InterruptedException
{    if (!cnxn.getState().isAlive()) {                return;    }    if (LOG.isDebugEnabled()) {            }    try {        cnxn.close();    } catch (IOException e) {            }    }
1
public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException
{    close();    return testableWaitForShutdown(waitForShutdownTimeoutMs);}
0
private String prependChroot(String clientPath)
{    if (cnxn.chrootPath != null) {                if (clientPath.length() == 1) {            return cnxn.chrootPath;        }        return cnxn.chrootPath + clientPath;    } else {        return clientPath;    }}
0
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
0
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat) throws KeeperException, InterruptedException
{    return create(path, data, acl, createMode, stat, -1);}
0
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat, long ttl) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    ReplyHeader r = cnxn.submitRequest(h, record, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
0
private void setCreateHeader(CreateMode createMode, RequestHeader h)
{    if (createMode.isTTL()) {        h.setType(ZooDefs.OpCode.createTTL);    } else {        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create2);    }}
0
private Record makeCreateRecord(CreateMode createMode, String serverPath, byte[] data, List<ACL> acl, long ttl)
{    Record record;    if (createMode.isTTL()) {        CreateTTLRequest request = new CreateTTLRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        request.setTtl(ttl);        record = request;    } else {        CreateRequest request = new CreateRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        record = request;    }    return record;}
0
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, StringCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    ReplyHeader r = new ReplyHeader();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, null);}
0
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx)
{    create(path, data, acl, createMode, cb, ctx, -1);}
0
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx, long ttl)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    ReplyHeader r = new ReplyHeader();    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    cnxn.queuePacket(h, r, record, response, cb, clientPath, serverPath, ctx, null);}
0
public void delete(final String path, int version) throws InterruptedException, KeeperException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    ReplyHeader r = cnxn.submitRequest(h, request, null, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
0
public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException
{    for (Op op : ops) {        op.validate();    }    return multiInternal(generateMultiTransaction(ops));}
0
public void multi(Iterable<Op> ops, MultiCallback cb, Object ctx)
{    List<OpResult> results = validatePath(ops);    if (results.size() > 0) {        cb.processResult(KeeperException.Code.BADARGUMENTS.intValue(), null, ctx, results);        return;    }    multiInternal(generateMultiTransaction(ops), cb, ctx);}
0
private List<OpResult> validatePath(Iterable<Op> ops)
{    List<OpResult> results = new ArrayList<OpResult>();    boolean error = false;    for (Op op : ops) {        try {            op.validate();        } catch (IllegalArgumentException iae) {                        ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());            results.add(err);            error = true;            continue;        } catch (KeeperException ke) {                        ErrorResult err = new ErrorResult(ke.code().intValue());            results.add(err);            error = true;            continue;        }        ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        results.add(err);    }    if (!error) {        results.clear();    }    return results;}
1
private MultiOperationRecord generateMultiTransaction(Iterable<Op> ops)
{        List<Op> transaction = new ArrayList<Op>();    for (Op op : ops) {        transaction.add(withRootPrefix(op));    }    return new MultiOperationRecord(transaction);}
0
private Op withRootPrefix(Op op)
{    if (null != op.getPath()) {        final String serverPath = prependChroot(op.getPath());        if (!op.getPath().equals(serverPath)) {            return op.withChroot(serverPath);        }    }    return op;}
0
protected void multiInternal(MultiOperationRecord request, MultiCallback cb, Object ctx) throws IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
0
protected List<OpResult> multiInternal(MultiOperationRecord request) throws InterruptedException, KeeperException, IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    List<OpResult> results = response.getResultList();        if (request.getOpKind() == Op.OpKind.READ) {        return results;    }    ErrorResult fatalError = null;    for (OpResult result : results) {        if (result instanceof ErrorResult && ((ErrorResult) result).getErr() != KeeperException.Code.OK.intValue()) {            fatalError = (ErrorResult) result;            break;        }    }    if (fatalError != null) {        KeeperException ex = KeeperException.create(KeeperException.Code.get(fatalError.getErr()));        ex.setMultiResults(results);        throw ex;    }    return results;}
0
public Transaction transaction()
{    return new Transaction(this);}
0
public void delete(final String path, int version, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null);}
0
public Stat exists(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        if (r.getErr() == KeeperException.Code.NONODE.intValue()) {            return null;        }        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat().getCzxid() == -1 ? null : response.getStat();}
0
public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException
{    return exists(path, watch ? watchManager.defaultWatcher : null);}
0
public void exists(final String path, Watcher watcher, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
0
public void exists(String path, boolean watch, StatCallback cb, Object ctx)
{    exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
0
public byte[] getData(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
0
public byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getData(path, watch ? watchManager.defaultWatcher : null, stat);}
0
public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
0
public void getData(String path, boolean watch, DataCallback cb, Object ctx)
{    getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
0
public byte[] getConfig(Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), configZnode);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
0
public void getConfig(Watcher watcher, DataCallback cb, Object ctx)
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, configZnode, configZnode, ctx, wcb);}
0
public byte[] getConfig(boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getConfig(watch ? watchManager.defaultWatcher : null, stat);}
0
public void getConfig(boolean watch, DataCallback cb, Object ctx)
{    getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);}
0
public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
0
public void setData(final String path, byte[] data, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
0
public List<ACL> getACL(final String path, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getAcl();}
0
public void getACL(final String path, Stat stat, ACLCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
0
public Stat setACL(final String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(aclVersion);    SetACLResponse response = new SetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
0
public void setACL(final String path, List<ACL> acl, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(version);    SetACLResponse response = new SetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
0
public List<String> getChildren(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getChildren();}
0
public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null);}
0
public void getChildren(final String path, Watcher watcher, ChildrenCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
0
public void getChildren(String path, boolean watch, ChildrenCallback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
0
public List<String> getChildren(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getChildren();}
0
public List<String> getChildren(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null, stat);}
0
public void getChildren(final String path, Watcher watcher, Children2Callback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
0
public void getChildren(String path, boolean watch, Children2Callback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
0
public int getAllChildrenNumber(final String path) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getTotalNumber();}
0
public void getAllChildrenNumber(final String path, AsyncCallback.AllChildrenNumberCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
0
public List<String> getEphemerals() throws KeeperException, InterruptedException
{    return getEphemerals("/");}
0
public List<String> getEphemerals(String prefixPath) throws KeeperException, InterruptedException
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    return response.getEphemerals();}
0
public void getEphemerals(String prefixPath, AsyncCallback.EphemeralsCallback cb, Object ctx)
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
0
public void getEphemerals(AsyncCallback.EphemeralsCallback cb, Object ctx)
{    getEphemerals("/", cb, ctx);}
0
public void sync(final String path, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.sync);    SyncRequest request = new SyncRequest();    SyncResponse response = new SyncResponse();    request.setPath(serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
0
public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local);}
0
public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local, cb, ctx);}
0
public void removeAllWatches(String path, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local);}
0
public void removeAllWatches(String path, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);}
0
private void validateWatcher(Watcher watcher)
{    if (watcher == null) {        throw new IllegalArgumentException("Invalid Watcher, shouldn't be null!");    }}
0
private void removeWatches(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    ReplyHeader r = cnxn.submitRequest(h, request, null, null, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
0
private void removeWatches(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null, wcb);}
0
private Record getRemoveWatchesRequest(int opCode, WatcherType watcherType, final String serverPath)
{    Record request = null;    switch(opCode) {        case ZooDefs.OpCode.checkWatches:            CheckWatchesRequest chkReq = new CheckWatchesRequest();            chkReq.setPath(serverPath);            chkReq.setType(watcherType.getIntValue());            request = chkReq;            break;        case ZooDefs.OpCode.removeWatches:            RemoveWatchesRequest rmReq = new RemoveWatchesRequest();            rmReq.setPath(serverPath);            rmReq.setType(watcherType.getIntValue());            request = rmReq;            break;        default:                        break;    }    return request;}
1
public States getState()
{    return cnxn.getState();}
0
public String toString()
{    States state = getState();    return ("State:" + state.toString() + (state.isConnected() ? " Timeout:" + getSessionTimeout() + " " : " ") + cnxn);}
0
protected boolean testableWaitForShutdown(int wait) throws InterruptedException
{    cnxn.sendThread.join(wait);    if (cnxn.sendThread.isAlive()) {        return false;    }    cnxn.eventThread.join(wait);    return !cnxn.eventThread.isAlive();}
0
protected SocketAddress testableRemoteSocketAddress()
{    return cnxn.sendThread.getClientCnxnSocket().getRemoteSocketAddress();}
0
protected SocketAddress testableLocalSocketAddress()
{    return cnxn.sendThread.getClientCnxnSocket().getLocalSocketAddress();}
0
private ClientCnxnSocket getClientCnxnSocket() throws IOException
{    String clientCnxnSocketName = getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    if (clientCnxnSocketName == null) {        clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();    }    try {        Constructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);        ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());        return clientCxnSocket;    } catch (Exception e) {        throw new IOException("Couldn't instantiate " + clientCnxnSocketName, e);    }}
0
private void validateACL(List<ACL> acl) throws KeeperException.InvalidACLException
{    if (acl == null || acl.isEmpty() || acl.contains(null)) {        throw new KeeperException.InvalidACLException();    }}
0
public static void printBanner(Logger log)
{    for (String line : BANNER) {            }}
1
public boolean getPrintWatches()
{    return printWatches;}
0
 static void usage()
{    System.err.println("ZooKeeper -server host:port cmd args");    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    for (String cmd : cmdList) {        System.err.println("\t" + cmd + " " + commandMap.get(cmd));    }}
0
public void process(WatchedEvent event)
{    if (getPrintWatches()) {        ZooKeeperMain.printMessage("WATCHER::");        ZooKeeperMain.printMessage(event.toString());    }}
0
public String getOption(String opt)
{    return options.get(opt);}
0
public String getCommand()
{    return command;}
0
public String getCmdArgument(int index)
{    return cmdArgs.get(index);}
0
public int getNumArguments()
{    return cmdArgs.size();}
0
public String[] getArgArray()
{    return cmdArgs.toArray(new String[0]);}
0
public boolean parseOptions(String[] args)
{    List<String> argList = Arrays.asList(args);    Iterator<String> it = argList.iterator();    while (it.hasNext()) {        String opt = it.next();        try {            if (opt.equals("-server")) {                options.put("server", it.next());            } else if (opt.equals("-timeout")) {                options.put("timeout", it.next());            } else if (opt.equals("-r")) {                options.put("readonly", "true");            }        } catch (NoSuchElementException e) {            System.err.println("Error: no argument found for option " + opt);            return false;        }        if (!opt.startsWith("-")) {            command = opt;            cmdArgs = new ArrayList<String>();            cmdArgs.add(command);            while (it.hasNext()) {                cmdArgs.add(it.next());            }            return true;        }    }    return true;}
0
public boolean parseCommand(String cmdstring)
{    Matcher matcher = ARGS_PATTERN.matcher(cmdstring);    List<String> args = new LinkedList<String>();    while (matcher.find()) {        String value = matcher.group(1);        if (QUOTED_PATTERN.matcher(value).matches()) {                        value = value.substring(1, value.length() - 1);        }        args.add(value);    }    if (args.isEmpty()) {        return false;    }    command = args.get(0);    cmdArgs = args;    return true;}
0
protected void addToHistory(int i, String cmd)
{    history.put(i, cmd);}
0
public static List<String> getCommands()
{    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    return cmdList;}
0
protected String getPrompt()
{    return "[zk: " + host + "(" + zk.getState() + ")" + " " + commandCount + "] ";}
0
public static void printMessage(String msg)
{    System.out.println("\n" + msg);}
0
protected void connectToZK(String newHost) throws InterruptedException, IOException
{    if (zk != null && zk.getState().isAlive()) {        zk.close();    }    host = newHost;    boolean readOnly = cl.getOption("readonly") != null;    if (cl.getOption("secure") != null) {        System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");        System.out.println("Secure connection is enabled");    }    zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption("timeout")), new MyWatcher(), readOnly);}
0
public static void main(String[] args) throws CliException, IOException, InterruptedException
{    ZooKeeperMain main = new ZooKeeperMain(args);    main.run();}
0
 void run() throws CliException, IOException, InterruptedException
{    if (cl.getCommand() == null) {        System.out.println("Welcome to ZooKeeper!");        boolean jlinemissing = false;                try {            Class<?> consoleC = Class.forName("jline.console.ConsoleReader");            Class<?> completorC = Class.forName("org.apache.zookeeper.JLineZNodeCompleter");            System.out.println("JLine support is enabled");            Object console = consoleC.getConstructor().newInstance();            Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);            Method addCompletor = consoleC.getMethod("addCompleter", Class.forName("jline.console.completer.Completer"));            addCompletor.invoke(console, completor);            String line;            Method readLine = consoleC.getMethod("readLine", String.class);            while ((line = (String) readLine.invoke(console, getPrompt())) != null) {                executeLine(line);            }        } catch (ClassNotFoundException e) {                        jlinemissing = true;        } catch (NoSuchMethodException e) {                        jlinemissing = true;        } catch (InvocationTargetException e) {                        jlinemissing = true;        } catch (IllegalAccessException e) {                        jlinemissing = true;        } catch (InstantiationException e) {                        jlinemissing = true;        }        if (jlinemissing) {            System.out.println("JLine support is disabled");            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = br.readLine()) != null) {                executeLine(line);            }        }    } else {                processCmd(cl);    }    System.exit(exitCode);}
1
public void executeLine(String line) throws CliException, InterruptedException, IOException
{    if (!line.equals("")) {        cl.parseCommand(line);        addToHistory(commandCount, line);        processCmd(cl);        commandCount++;    }}
0
protected boolean processCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException
{    boolean watch = false;    try {        watch = processZKCmd(co);        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    } catch (CliException ex) {        exitCode = ex.getExitCode();        System.err.println(ex.getMessage());    }    return watch;}
0
protected boolean processZKCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException
{    String[] args = co.getArgArray();    String cmd = co.getCommand();    if (args.length < 1) {        usage();        throw new MalformedCommandException("No command entered");    }    if (!commandMap.containsKey(cmd)) {        usage();        throw new CommandNotFoundException("Command not found " + cmd);    }    boolean watch = false;        if (cmd.equals("quit")) {        zk.close();        System.exit(exitCode);    } else if (cmd.equals("redo") && args.length >= 2) {        Integer i = Integer.decode(args[1]);        if (commandCount <= i || i < 0) {                        throw new MalformedCommandException("Command index out of range");        }        cl.parseCommand(history.get(i));        if (cl.getCommand().equals("redo")) {            throw new MalformedCommandException("No redoing redos");        }        history.put(commandCount, history.get(i));        processCmd(cl);    } else if (cmd.equals("history")) {        for (int i = commandCount - 10; i <= commandCount; ++i) {            if (i < 0) {                continue;            }            System.out.println(i + " - " + history.get(i));        }    } else if (cmd.equals("printwatches")) {        if (args.length == 1) {            System.out.println("printwatches is " + (printWatches ? "on" : "off"));        } else {            printWatches = args[1].equals("on");        }    } else if (cmd.equals("connect")) {        if (args.length >= 2) {            connectToZK(args[1]);        } else {            connectToZK(host);        }    }        if (zk == null || !zk.getState().isAlive()) {        System.out.println("Not connected");        return false;    }        CliCommand cliCmd = commandMapCli.get(cmd);    if (cliCmd != null) {        cliCmd.setZk(zk);        watch = cliCmd.parse(args).exec();    } else if (!commandMap.containsKey(cmd)) {        usage();    }    return watch;}
1
public void injectSessionExpiration()
{        clientCnxn.eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));    clientCnxn.eventThread.queueEventOfDeath();    clientCnxn.state = ZooKeeper.States.CLOSED;    clientCnxn.sendThread.getClientCnxnSocket().onClosing();}
1
public void queueEvent(WatchedEvent event)
{        clientCnxn.eventThread.queueEvent(event);}
1
public static void init()
{    if (!testData.exists()) {        testData.mkdirs();    }}
0
public void testDefaultConfiguration()
{    Map<String, String> properties = new HashMap<>();    properties.put(ZK_SASL_CLIENT_USERNAME, "zookeeper1");    properties.put(LOGIN_CONTEXT_NAME_KEY, "Client1");    properties.put(ENABLE_CLIENT_SASL_KEY, "true");    properties.put(ZOOKEEPER_SERVER_REALM, "zookeeper/hadoop.hadoop.com");    properties.put(DISABLE_AUTO_WATCH_RESET, "true");    properties.put(ZOOKEEPER_CLIENT_CNXN_SOCKET, "ClientCnxnSocketNetty");    properties.put(SECURE_CLIENT, "true");    for (Map.Entry<String, String> e : properties.entrySet()) {        System.setProperty(e.getKey(), e.getValue());    }    /**     * ZKClientConfig should get initialized with system properties     */    ZKClientConfig conf = new ZKClientConfig();    for (Map.Entry<String, String> e : properties.entrySet()) {        assertEquals(e.getValue(), conf.getProperty(e.getKey()));    }    /**     * clear properties     */    for (Map.Entry<String, String> e : properties.entrySet()) {        System.clearProperty(e.getKey());    }    conf = new ZKClientConfig();    /**     * test that all the properties are null     */    for (Map.Entry<String, String> e : properties.entrySet()) {        String result = conf.getProperty(e.getKey());        assertNull(result);    }}
0
public void testSystemPropertyValue()
{    String clientName = "zookeeper1";    System.setProperty(ZK_SASL_CLIENT_USERNAME, clientName);    ZKClientConfig conf = new ZKClientConfig();    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), clientName);    String newClientName = "zookeeper2";    conf.setProperty(ZK_SASL_CLIENT_USERNAME, newClientName);    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), newClientName);}
0
public void testReadConfigurationFile() throws IOException, ConfigException
{    File file = File.createTempFile("clientConfig", ".conf", testData);    file.deleteOnExit();    Properties clientConfProp = new Properties();    clientConfProp.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    clientConfProp.setProperty(ZK_SASL_CLIENT_USERNAME, "ZK");    clientConfProp.setProperty(LOGIN_CONTEXT_NAME_KEY, "MyClient");    clientConfProp.setProperty(ZOOKEEPER_SERVER_REALM, "HADOOP.COM");    clientConfProp.setProperty("dummyProperty", "dummyValue");    OutputStream io = new FileOutputStream(file);    try {        clientConfProp.store(io, "Client Configurations");    } finally {        io.close();    }    ZKClientConfig conf = new ZKClientConfig();    conf.addConfiguration(file.getAbsolutePath());    assertEquals(conf.getProperty(ENABLE_CLIENT_SASL_KEY), "true");    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), "ZK");    assertEquals(conf.getProperty(LOGIN_CONTEXT_NAME_KEY), "MyClient");    assertEquals(conf.getProperty(ZOOKEEPER_SERVER_REALM), "HADOOP.COM");    assertEquals(conf.getProperty("dummyProperty"), "dummyValue");            file.delete();}
0
public void testSetConfiguration()
{    ZKClientConfig conf = new ZKClientConfig();    String defaultValue = conf.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT);    if (defaultValue.equals("true")) {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "false");    } else {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    }    assertTrue(conf.getProperty(ENABLE_CLIENT_SASL_KEY) != defaultValue);}
0
public void testIntegerRetrievalFromProperty()
{    ZKClientConfig conf = new ZKClientConfig();    String prop = "UnSetProperty" + System.currentTimeMillis();    int defaultValue = 100;        int result = conf.getInt(prop, defaultValue);    assertEquals(defaultValue, result);            conf.setProperty(ZKConfig.JUTE_MAXBUFFER, "InvlaidIntValue123");    try {        result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);        fail("NumberFormatException is expected");    } catch (NumberFormatException exception) {        }    assertEquals(defaultValue, result);        int value = ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, Integer.toString(value));    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);        value = 12345;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, " " + value + " ");    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);}
0
public void testClientCanonicalization() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does not appear to have been canonicalized", "zookeeper/zk1.apache.org", principal);}
0
public void testClientNoCanonicalization() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    conf.setProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, "false");    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appears to have been canonicalized incorrectly", "zookeeper/zookeeper.apache.org", principal);}
0
public void testClientCanonicalizationToIp() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("127.0.0.1");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appear to have falled back to the original host name", "zookeeper/zookeeper.apache.org", principal);}
0
public void setUp()
{    ClientCnxnSocketNetty.setTestAllocator(TestByteBufAllocator.getInstance());}
0
public void tearDown()
{    ClientCnxnSocketNetty.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
0
public void testWhenInvalidJuteMaxBufferIsConfiguredIOExceptionIsThrown()
{    ZKClientConfig clientConfig = new ZKClientConfig();    String value = "SomeInvalidInt";    clientConfig.setProperty(ZKConfig.JUTE_MAXBUFFER, value);        try {        new ClientCnxnSocketNIO(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }        try {        new ClientCnxnSocketNetty(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }}
0
 void registerAndConnect(SocketChannel sock, InetSocketAddress addr) throws IOException
{    countDownLatch.countDown();    throw new IOException("failed to register");}
0
 SocketChannel createSock()
{    return sc;}
0
public void testClientReconnect() throws IOException, InterruptedException
{    HostProvider hostProvider = mock(HostProvider.class);    when(hostProvider.size()).thenReturn(1);    InetSocketAddress inaddr = new InetSocketAddress("127.0.0.1", 1111);    when(hostProvider.next(anyLong())).thenReturn(inaddr);    ZooKeeper zk = mock(ZooKeeper.class);    when(zk.getClientConfig()).thenReturn(new ZKClientConfig());    sc = SocketChannel.open();    ClientCnxnSocketNIO nioCnxn = new MockCnxn();    ClientWatchManager watcher = mock(ClientWatchManager.class);    ClientCnxn clientCnxn = new ClientCnxn("tmp", hostProvider, 5000, zk, watcher, nioCnxn, false);    clientCnxn.start();    countDownLatch.await(5000, TimeUnit.MILLISECONDS);    assertTrue(countDownLatch.getCount() == 0);    clientCnxn.close();}
0
public void testClientRequestTimeout() throws Exception
{    int requestTimeOut = 15000;    System.setProperty("zookeeper.request.timeout", Integer.toString(requestTimeOut));    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch1 = new CountdownWatcher();    CustomZooKeeper zk = new CustomZooKeeper(getCxnString(clientPorts), ClientBase.CONNECTION_TIMEOUT, watch1);    watch1.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";        zk.create("/clientHang1", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        dropPacket = true;    dropPacketType = ZooDefs.OpCode.create;        try {        zk.create("/clientHang2", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("KeeperException is expected.");    } catch (KeeperException exception) {        assertEquals(KeeperException.Code.REQUESTTIMEOUT.intValue(), exception.code().intValue());    }        zk.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
private String getCxnString(int[] clientPorts)
{    StringBuffer hostPortBuffer = new StringBuffer();    for (int i = 0; i < clientPorts.length; i++) {        hostPortBuffer.append("127.0.0.1:");        hostPortBuffer.append(clientPorts[i]);        if (i != (clientPorts.length - 1)) {            hostPortBuffer.append(',');        }    }    return hostPortBuffer.toString();}
0
public void finishPacket(Packet p)
{    if (dropPacket && p.requestHeader.getType() == dropPacketType) {                return;    }    super.finishPacket(p);}
0
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new CustomClientCnxn(chrootPath, hostProvider, sessionTimeout, zooKeeper, watcher, clientCnxnSocket, canBeReadOnly);}
0
public static void createTmpDir()
{    tmpdir = new File("build/test/tmp");    tmpdir.mkdirs();}
0
public void testOutputStreamSuccess() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
0
public void testWriterSuccess() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
0
public void write(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
0
public void testOutputStreamFailure() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
0
public void testWriterFailure() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
0
public void testOutputStreamFailureIOException() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
0
public void testWriterFailureIOException() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
0
public void testOutputStreamFailureError() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
0
public void testWriterFailureError() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
0
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
0
public void testOutputStreamSuccessNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });        assertEquals("after", getContent(target));    target.delete();}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
0
public void testWriterSuccessNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
0
public void write(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
0
public void testOutputStreamFailureNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
0
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
0
public void testWriterFailureNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
0
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
0
private String getContent(File file, String encoding) throws IOException
{    StringBuilder result = new StringBuilder();    FileInputStream fis = new FileInputStream(file);    byte[] b = new byte[20];    int nb;    while ((nb = fis.read(b)) != -1) {        result.append(new String(b, 0, nb, encoding));    }    fis.close();    return result.toString();}
0
private String getContent(File file) throws IOException
{    return getContent(file, "ASCII");}
0
private void createFile(File file, String content) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    fos.write(content.getBytes(StandardCharsets.US_ASCII));    fos.close();}
0
public static Collection<Object[]> defaultParams()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (String keyPassword : new String[] { "", "pa$$w0rd" }) {                result.add(new Object[] { caKeyType, certKeyType, keyPassword, paramIndex++ });            }        }    }    return result;}
0
public static void setUpBaseClass() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    cachedTestContexts = new HashMap<>();    tempDir = ClientBase.createEmptyTestDir();}
0
public static void cleanUpBaseClass()
{    Security.removeProvider("BC");    cachedTestContexts.clear();    cachedTestContexts = null;    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
0
public static void createTempFile() throws IOException
{    tempDir = ClientBase.createEmptyTestDir();    tempFile = File.createTempFile("zk_test_", "", tempDir);    tempFile.deleteOnExit();}
0
public static void cleanupTempDir()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
0
public void testCallbackWorksOnFileChanges() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        for (int i = 0; i < 3; i++) {                        FileUtils.writeStringToFile(tempFile, "Hello world " + i + "\n", StandardCharsets.UTF_8, true);            synchronized (events) {                if (events.size() < i + 1) {                    events.wait(3000L);                }                assertEquals("Wrong number of events", i + 1, events.size());                WatchEvent<?> event = events.get(i);                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());                assertEquals(tempFile.getName(), event.context().toString());            }        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
1
public void testCallbackWorksOnFileTouched() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);                FileUtils.touch(tempFile);        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
1
public void testCallbackWorksOnFileAdded() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                        synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        File tempFile2 = File.createTempFile("zk_test_", "", tempDir);        tempFile2.deleteOnExit();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());            assertEquals(tempFile2.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
1
public void testCallbackWorksOnFileDeleted() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        tempFile.delete();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
1
public void testCallbackErrorDoesNotCrashWatcherThread() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final AtomicInteger callCount = new AtomicInteger(0);        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                        int oldValue;            synchronized (callCount) {                oldValue = callCount.getAndIncrement();                callCount.notifyAll();            }            if (oldValue == 0) {                throw new RuntimeException("This error should not crash the watcher thread");            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);                FileUtils.writeStringToFile(tempFile, "Hello world\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            while (callCount.get() == 0) {                callCount.wait(3000L);            }        }                FileUtils.writeStringToFile(tempFile, "Hello world again\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            if (callCount.get() == 1) {                callCount.wait(3000L);            }        }                        assertTrue(callCount.get() > 1);    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
1
public void testGetBuilderForJKSFileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.JKS);    assertTrue(builder instanceof JKSFileLoader.Builder);}
0
public void testGetBuilderForPEMFileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PEM);    assertTrue(builder instanceof PEMFileLoader.Builder);}
0
public void testGetBuilderForPKCS12FileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PKCS12);    assertTrue(builder instanceof PKCS12FileLoader.Builder);}
0
public void testGetBuilderForNullFileType()
{    FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(null);}
0
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
0
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ks = new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
0
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new JKSFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
0
public void testLoadTrustStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
0
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new JKSFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testGetPropertyValue()
{    assertEquals("PEM", KeyStoreFileType.PEM.getPropertyValue());    assertEquals("JKS", KeyStoreFileType.JKS.getPropertyValue());    assertEquals("PKCS12", KeyStoreFileType.PKCS12.getPropertyValue());}
0
public void testFromPropertyValue()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("PEM"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("JKS"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("PKCS12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
0
public void testFromPropertyValueIgnoresCase()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("pem"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("jks"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("pkcs12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
0
public void testFromPropertyValueThrowsOnBadPropertyValue()
{    KeyStoreFileType.fromPropertyValue("foobar");}
0
public void testFromFilename()
{    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("mykey.jks"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.jks"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("mykey.pem"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.pem"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("mykey.p12"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.p12"));}
0
public void testFromFilenameThrowsOnBadFileExtension()
{    KeyStoreFileType.fromFilename("prod.key");}
0
public void testFromPropertyValueOrFileName()
{        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("JKS", "prod.key"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValueOrFileName("PEM", "prod.key"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValueOrFileName("PKCS12", "prod.key"));        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("", "prod.jks"));}
0
public void testFromPropertyValueOrFileNameThrowsOnBadPropertyValue()
{    KeyStoreFileType.fromPropertyValueOrFileName("foobar", "prod.jks");}
0
public void testFromPropertyValueOrFileNameThrowsOnBadFileExtension()
{    KeyStoreFileType.fromPropertyValueOrFileName("", "prod.key");}
0
public void testFormatInetAddrGoodIpv4()
{    InetSocketAddress isa = new InetSocketAddress(v4addr, port);    assertEquals("127.0.0.1:1234", NetUtils.formatInetAddr(isa));}
0
public void testFormatInetAddrGoodIpv6Local()
{        InetSocketAddress isa = new InetSocketAddress("::1", port);    assertEquals(v6local, NetUtils.formatInetAddr(isa));}
0
public void testFormatInetAddrGoodIpv6Ext()
{        InetSocketAddress isa = new InetSocketAddress("2600::", port);    assertEquals(v6ext, NetUtils.formatInetAddr(isa));}
0
public void testFormatInetAddrGoodHostname()
{    InetSocketAddress isa = new InetSocketAddress("localhost", 1234);    assertThat(NetUtils.formatInetAddr(isa), anyOf(equalTo(v4local), equalTo(v6local)));}
0
public void testFormatAddrUnresolved()
{    InetSocketAddress isa = InetSocketAddress.createUnresolved("doesnt.exist.com", 1234);    assertEquals("doesnt.exist.com:1234", NetUtils.formatInetAddr(isa));}
0
public void before()
{    this.pathTrie = new PathTrie();}
0
public void addNullPath()
{    this.pathTrie.addPath(null);}
0
public void addIllegalPath()
{    this.pathTrie.addPath("");}
0
public void addPathToRoot()
{    this.pathTrie.addPath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));}
0
public void addPathToRootLeaves()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
0
public void deleteNullPath()
{    this.pathTrie.deletePath(null);}
0
public void deleteIllegalPath()
{    this.pathTrie.deletePath("");}
0
public void deletePathFromRoot()
{    this.pathTrie.addPath("node1");    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
0
public void deletePathFromRootLeaves()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertFalse(this.pathTrie.existsNode("/node1/node3"));    this.pathTrie.deletePath("node1/node2");    assertTrue(this.pathTrie.existsNode("/node1"));    assertFalse(this.pathTrie.existsNode("/node1/node2"));    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
0
public void deletePathDoesNotExist()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));}
0
public void deleteRootPath()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");        this.pathTrie.deletePath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
0
public void findMaxPrefixNullPath()
{    this.pathTrie.findMaxPrefix(null);}
0
public void findMaxPrefixRootPath()
{    assertEquals("/", this.pathTrie.findMaxPrefix("/"));}
0
public void findMaxPrefixChildren()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1"));    assertEquals("/node1/node2", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1/node3", this.pathTrie.findMaxPrefix("/node1/node3"));}
0
public void findMaxPrefixChildrenPrefix()
{    this.pathTrie.addPath("node1");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node3"));}
0
public void testValidatePath_ValidPath()
{    PathUtils.validatePath("/this is / a valid/path");}
0
public void testValidatePath_Null()
{    PathUtils.validatePath(null);}
0
public void testValidatePath_EmptyString()
{    PathUtils.validatePath("");}
0
public void testValidatePath_NotAbsolutePath()
{    PathUtils.validatePath("not/valid");}
0
public void testValidatePath_EndsWithSlash()
{    PathUtils.validatePath("/ends/with/slash/");}
0
public void testValidatePath_ContainsNullCharacter()
{    PathUtils.validatePath("/test\u0000");}
0
public void testValidatePath_DoubleSlash()
{    PathUtils.validatePath("/double//slash");}
0
public void testValidatePath_SinglePeriod()
{    PathUtils.validatePath("/single/./period");}
0
public void testValidatePath_DoublePeriod()
{    PathUtils.validatePath("/double/../period");}
0
public void testValidatePath_NameContainingPeriod()
{        PathUtils.validatePath("/name/with.period.");}
0
public void testValidatePath_0x01()
{    PathUtils.validatePath("/test\u0001");}
0
public void testValidatePath_0x1F()
{    PathUtils.validatePath("/test\u001F");}
0
public void testValidatePath_0x20()
{    PathUtils.validatePath("/test\u0020");}
0
public void testValidatePath_0x7e()
{        PathUtils.validatePath("/test\u007e");}
0
public void testValidatePath_0x7f()
{    PathUtils.validatePath("/test\u007f");}
0
public void testValidatePath_0x9f()
{    PathUtils.validatePath("/test\u009f");}
0
public void testValidatePath_ud800()
{    PathUtils.validatePath("/test\ud800");}
0
public void testValidatePath_uf8ff()
{    PathUtils.validatePath("/test\uf8ff");}
0
public void testValidatePath_HighestAllowableChar()
{    PathUtils.validatePath("/test\uffef");}
0
public void testValidatePath_SupplementaryChar()
{    PathUtils.validatePath("/test\ufff0");}
0
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
0
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ks = new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
0
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new PEMFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
0
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new PEMFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(0, ts.size());}
0
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
0
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ks = new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
0
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new PKCS12FileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
0
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ts = new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
0
public void testLoadTrustStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
0
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new PKCS12FileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
0
public static void main(String[] args) throws Exception
{    System.out.print("Starting\n");    final TimeTest test = new TimeTest();    System.out.print("After construct\n");    test.setUp();    ZooKeeper zk = test.createClient();    zk.create("/ephemeral", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    while (Time.currentElapsedTime() - nt0 < 100000) {        System.out.printf("%d\t%s\n", discrepancy(), zk.exists("/ephemeral", watchCount.get() == 0 ? createWatcher() : null) != null);        waitByYielding(500);    }}
0
private static Watcher createWatcher()
{    watchCount.incrementAndGet();    return event -> {        watchCount.decrementAndGet();        System.out.printf("%d event = %s\n", discrepancy(), event);    };}
0
private static void waitByYielding(long delay)
{    long t0 = Time.currentElapsedTime();    while (Time.currentElapsedTime() < t0 + delay) {        Thread.yield();    }}
0
private static long discrepancy()
{    return (System.currentTimeMillis() - mt0) - (Time.currentElapsedTime() - nt0);}
0
public void testElapsedTimeToDate() throws Exception
{    long walltime = Time.currentWallTime();    long elapsedTime = Time.currentElapsedTime();    Thread.sleep(200);    Calendar cal = Calendar.getInstance();    cal.setTime(Time.elapsedTimeToDate(elapsedTime));    int calculatedDate = cal.get(Calendar.HOUR_OF_DAY);    cal.setTime(new Date(walltime));    int realDate = cal.get(Calendar.HOUR_OF_DAY);    assertEquals(calculatedDate, realDate);}
0
private X509KeyType keyPairToType(KeyPair keyPair)
{    if (keyPair.getPrivate().getAlgorithm().contains("RSA")) {        return X509KeyType.RSA;    } else {        return X509KeyType.EC;    }}
0
public File getTempDir()
{    return tempDir;}
0
public X509KeyType getTrustStoreKeyType()
{    return trustStoreKeyType;}
0
public KeyPair getTrustStoreKeyPair()
{    return trustStoreKeyPair;}
0
public long getTrustStoreCertExpirationMillis()
{    return trustStoreCertExpirationMillis;}
0
public X509Certificate getTrustStoreCertificate()
{    return trustStoreCertificate;}
0
public String getTrustStorePassword()
{    return trustStorePassword;}
0
public File getTrustStoreFile(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getTrustStoreJksFile();        case PEM:            return getTrustStorePemFile();        case PKCS12:            return getTrustStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid trust store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
0
private File getTrustStoreJksFile() throws IOException
{    if (trustStoreJksFile == null) {        File trustStoreJksFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        trustStoreJksFile.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStoreJksFile)) {            byte[] bytes = X509TestHelpers.certToJavaTrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStoreJksFile = trustStoreJksFile;    }    return trustStoreJksFile;}
0
private File getTrustStorePemFile() throws IOException
{    if (trustStorePemFile == null) {        File trustStorePemFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);        trustStorePemFile.deleteOnExit();        FileUtils.writeStringToFile(trustStorePemFile, X509TestHelpers.pemEncodeX509Certificate(trustStoreCertificate), StandardCharsets.US_ASCII, false);        this.trustStorePemFile = trustStorePemFile;    }    return trustStorePemFile;}
0
private File getTrustStorePkcs12File() throws IOException
{    if (trustStorePkcs12File == null) {        File trustStorePkcs12File = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        trustStorePkcs12File.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certToPKCS12TrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStorePkcs12File = trustStorePkcs12File;    }    return trustStorePkcs12File;}
0
public X509KeyType getKeyStoreKeyType()
{    return keyStoreKeyType;}
0
public KeyPair getKeyStoreKeyPair()
{    return keyStoreKeyPair;}
0
public long getKeyStoreCertExpirationMillis()
{    return keyStoreCertExpirationMillis;}
0
public X509Certificate getKeyStoreCertificate()
{    return keyStoreCertificate;}
0
public String getKeyStorePassword()
{    return keyStorePassword;}
0
public boolean isKeyStoreEncrypted()
{    return keyStorePassword.length() > 0;}
0
public File getKeyStoreFile(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getKeyStoreJksFile();        case PEM:            return getKeyStorePemFile();        case PKCS12:            return getKeyStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid key store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
0
private File getKeyStoreJksFile() throws IOException
{    if (keyStoreJksFile == null) {        File keyStoreJksFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        keyStoreJksFile.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStoreJksFile)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToJavaKeyStoreBytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStoreJksFile = keyStoreJksFile;    }    return keyStoreJksFile;}
0
private File getKeyStorePemFile() throws IOException
{    if (keyStorePemFile == null) {        try {            File keyStorePemFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);            keyStorePemFile.deleteOnExit();            FileUtils.writeStringToFile(keyStorePemFile, X509TestHelpers.pemEncodeCertAndPrivateKey(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword), StandardCharsets.US_ASCII, false);            this.keyStorePemFile = keyStorePemFile;        } catch (OperatorCreationException e) {            throw new IOException(e);        }    }    return keyStorePemFile;}
0
private File getKeyStorePkcs12File() throws IOException
{    if (keyStorePkcs12File == null) {        File keyStorePkcs12File = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        keyStorePkcs12File.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToPKCS12Bytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStorePkcs12File = keyStorePkcs12File;    }    return keyStorePkcs12File;}
0
public void setSystemProperties(X509Util x509Util, KeyStoreFileType keyStoreFileType, KeyStoreFileType trustStoreFileType) throws IOException
{    System.setProperty(x509Util.getSslKeystoreLocationProperty(), this.getKeyStoreFile(keyStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslKeystorePasswdProperty(), this.getKeyStorePassword());    System.setProperty(x509Util.getSslKeystoreTypeProperty(), keyStoreFileType.getPropertyValue());    System.setProperty(x509Util.getSslTruststoreLocationProperty(), this.getTrustStoreFile(trustStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslTruststorePasswdProperty(), this.getTrustStorePassword());    System.setProperty(x509Util.getSslTruststoreTypeProperty(), trustStoreFileType.getPropertyValue());    if (hostnameVerification != null) {        System.setProperty(x509Util.getSslHostnameVerificationEnabledProperty(), hostnameVerification.toString());    } else {        System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());    }}
0
public void clearSystemProperties(X509Util x509Util)
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    System.clearProperty(x509Util.getSslKeystoreTypeProperty());    System.clearProperty(x509Util.getSslTruststoreLocationProperty());    System.clearProperty(x509Util.getSslTruststorePasswdProperty());    System.clearProperty(x509Util.getSslTruststoreTypeProperty());    System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());}
0
public X509TestContext build() throws IOException, GeneralSecurityException, OperatorCreationException
{    KeyPair trustStoreKeyPair = X509TestHelpers.generateKeyPair(trustStoreKeyType);    KeyPair keyStoreKeyPair = X509TestHelpers.generateKeyPair(keyStoreKeyType);    return new X509TestContext(tempDir, trustStoreKeyPair, trustStoreCertExpirationMillis, trustStorePassword, keyStoreKeyPair, keyStoreCertExpirationMillis, keyStorePassword, hostnameVerification);}
0
public Builder setTempDir(File tempDir)
{    this.tempDir = tempDir;    return this;}
0
public Builder setTrustStoreKeyType(X509KeyType keyType)
{    trustStoreKeyType = keyType;    return this;}
0
public Builder setTrustStorePassword(String password)
{    trustStorePassword = password;    return this;}
0
public Builder setTrustStoreCertExpirationMillis(long expirationMillis)
{    trustStoreCertExpirationMillis = expirationMillis;    return this;}
0
public Builder setKeyStoreKeyType(X509KeyType keyType)
{    keyStoreKeyType = keyType;    return this;}
0
public Builder setKeyStorePassword(String password)
{    keyStorePassword = password;    return this;}
0
public Builder setKeyStoreCertExpirationMillis(long expirationMillis)
{    keyStoreCertExpirationMillis = expirationMillis;    return this;}
0
public Builder setHostnameVerification(Boolean hostnameVerification)
{    this.hostnameVerification = hostnameVerification;    return this;}
0
public static Builder newBuilder()
{    return new Builder();}
0
public static X509Certificate newSelfSignedCACert(X500Name subject, KeyPair keyPair, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(    subject, now, new Date(now.getTime() + expirationMillis), subject, keyPair.getPublic());        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(true));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return buildAndSignCertificate(keyPair.getPrivate(), builder);}
0
public static X509Certificate newCert(X509Certificate caCert, KeyPair caKeyPair, X500Name certSubject, PublicKey certPublicKey, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    if (!caKeyPair.getPublic().equals(caCert.getPublicKey())) {        throw new IllegalArgumentException("CA private key does not match the public key in the CA cert");    }    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(new X500Name(caCert.getIssuerDN().getName()), now, new Date(now.getTime() + expirationMillis), certSubject, certPublicKey);        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(false));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    builder.addExtension(Extension.extendedKeyUsage, true, new ExtendedKeyUsage(new KeyPurposeId[] { KeyPurposeId.id_kp_serverAuth, KeyPurposeId.id_kp_clientAuth }));    builder.addExtension(Extension.subjectAlternativeName, false, getLocalhostSubjectAltNames());    return buildAndSignCertificate(caKeyPair.getPrivate(), builder);}
0
private static GeneralNames getLocalhostSubjectAltNames() throws UnknownHostException
{    InetAddress[] localAddresses = InetAddress.getAllByName("localhost");    GeneralName[] generalNames = new GeneralName[localAddresses.length + 1];    for (int i = 0; i < localAddresses.length; i++) {        generalNames[i] = new GeneralName(GeneralName.iPAddress, new DEROctetString(localAddresses[i].getAddress()));    }    generalNames[generalNames.length - 1] = new GeneralName(GeneralName.dNSName, new DERIA5String("localhost"));    return new GeneralNames(generalNames);}
0
private static X509v3CertificateBuilder initCertBuilder(X500Name issuer, Date notBefore, Date notAfter, X500Name subject, PublicKey subjectPublicKey)
{    return new X509v3CertificateBuilder(issuer, new BigInteger(SERIAL_NUMBER_MAX_BITS, PRNG), notBefore, notAfter, subject, SubjectPublicKeyInfo.getInstance(subjectPublicKey.getEncoded()));}
0
private static X509Certificate buildAndSignCertificate(PrivateKey privateKey, X509v3CertificateBuilder builder) throws IOException, OperatorCreationException, CertificateException
{    BcContentSignerBuilder signerBuilder;    if (privateKey.getAlgorithm().contains("RSA")) {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256WithRSAEncryption");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    } else {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256withECDSA");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcECContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    }    AsymmetricKeyParameter privateKeyParam = PrivateKeyFactory.createKey(privateKey.getEncoded());    ContentSigner signer = signerBuilder.build(privateKeyParam);    return toX509Cert(builder.build(signer));}
0
public static KeyPair generateKeyPair(X509KeyType keyType) throws GeneralSecurityException
{    switch(keyType) {        case RSA:            return generateRSAKeyPair();        case EC:            return generateECKeyPair();        default:            throw new IllegalArgumentException("Invalid X509KeyType");    }}
0
public static KeyPair generateRSAKeyPair() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");    RSAKeyGenParameterSpec keyGenSpec = new RSAKeyGenParameterSpec(DEFAULT_RSA_KEY_SIZE_BITS, DEFAULT_RSA_PUB_EXPONENT);    keyGen.initialize(keyGenSpec, PRNG);    return keyGen.generateKeyPair();}
0
public static KeyPair generateECKeyPair() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");    keyGen.initialize(new ECGenParameterSpec(DEFAULT_ELLIPTIC_CURVE_NAME), PRNG);    return keyGen.generateKeyPair();}
0
public static String pemEncodeCertAndPrivateKey(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, OperatorCreationException
{    return pemEncodeX509Certificate(cert) + "\n" + pemEncodePrivateKey(privateKey, keyPassword);}
0
public static String pemEncodePrivateKey(PrivateKey key, String password) throws IOException, OperatorCreationException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    OutputEncryptor encryptor = null;    if (password != null && password.length() > 0) {        encryptor = new JceOpenSSLPKCS8EncryptorBuilder(PKCSObjectIdentifiers.pbeWithSHAAnd3_KeyTripleDES_CBC).setProvider(BouncyCastleProvider.PROVIDER_NAME).setRandom(PRNG).setPasssword(password.toCharArray()).build();    }    pemWriter.writeObject(new JcaPKCS8Generator(key, encryptor));    pemWriter.close();    return stringWriter.toString();}
0
public static String pemEncodeX509Certificate(X509Certificate cert) throws IOException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    pemWriter.writeObject(cert);    pemWriter.close();    return stringWriter.toString();}
0
public static byte[] certToJavaTrustStoreBytes(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
0
public static byte[] certToPKCS12TrustStoreBytes(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance("PKCS12");    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
0
private static byte[] certToTrustStoreBytes(X509Certificate cert, String keyPassword, KeyStore trustStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    trustStore.load(null, keyPasswordChars);    trustStore.setCertificateEntry(cert.getSubjectDN().toString(), cert);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    trustStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
0
public static byte[] certAndPrivateKeyToJavaKeyStoreBytes(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
0
public static byte[] certAndPrivateKeyToPKCS12Bytes(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("PKCS12");    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
0
private static byte[] certAndPrivateKeyToPKCS12Bytes(X509Certificate cert, PrivateKey privateKey, String keyPassword, KeyStore keyStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    keyStore.load(null, keyPasswordChars);    keyStore.setKeyEntry("key", privateKey, keyPasswordChars, new Certificate[] { cert });    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    keyStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
0
public static X509Certificate toX509Cert(X509CertificateHolder certHolder) throws CertificateException
{    return new JcaX509CertificateConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME).getCertificate(certHolder);}
0
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
0
public void setUp() throws Exception
{    try (X509Util x509util = new ClientX509Util()) {        x509TestContext.setSystemProperties(x509util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    }    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    x509Util = new ClientX509Util();}
0
public void cleanUp()
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslOcspEnabledProperty());    System.clearProperty(x509Util.getSslCrlEnabledProperty());    System.clearProperty(x509Util.getCipherSuitesProperty());    System.clearProperty(x509Util.getSslProtocolProperty());    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    System.clearProperty("com.sun.net.ssl.checkRevocation");    System.clearProperty("com.sun.security.enableCRLDP");    Security.setProperty("ocsp.enable", Boolean.FALSE.toString());    Security.setProperty("com.sun.security.enableCRLDP", Boolean.FALSE.toString());    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    x509Util.close();}
0
public void testCreateSSLContextWithoutCustomProtocol() throws Exception
{    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(X509Util.DEFAULT_PROTOCOL, sslContext.getProtocol());}
0
public void testCreateSSLContextWithCustomProtocol() throws Exception
{    final String protocol = "TLSv1.1";    System.setProperty(x509Util.getSslProtocolProperty(), protocol);    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(protocol, sslContext.getProtocol());}
0
public void testCreateSSLContextWithoutKeyStoreLocation() throws Exception
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    x509Util.getDefaultSSLContext();}
0
public void testCreateSSLContextWithoutKeyStorePassword() throws Exception
{    if (!x509TestContext.isKeyStoreEncrypted()) {        throw new X509Exception.SSLContextException("");    }    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    x509Util.getDefaultSSLContext();}
0
public void testCreateSSLContextWithCustomCipherSuites() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
0
public void testCRLEnabled() throws Exception
{    System.setProperty(x509Util.getSslCrlEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
0
public void testCRLDisabled() throws Exception
{    x509Util.getDefaultSSLContext();    assertFalse(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertFalse(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
0
public void testOCSPEnabled() throws Exception
{    System.setProperty(x509Util.getSslOcspEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertTrue(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
0
public void testCreateSSLSocket() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
0
public void testCreateSSLServerSocketWithoutPort() throws Exception
{    setCustomCipherSuites();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket();    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
0
public void testCreateSSLServerSocketWithPort() throws Exception
{    setCustomCipherSuites();    int port = PortAssignment.unique();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket(port);    assertEquals(sslServerSocket.getLocalPort(), port);    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
0
public void testLoadPEMKeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PEM.getPropertyValue());}
0
public void testLoadPEMKeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue());}
0
public void testLoadPEMKeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
0
public void testLoadPEMKeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(),     "wrong password", KeyStoreFileType.PEM.getPropertyValue());}
0
public void testLoadPEMTrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
0
public void testLoadPEMTrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
0
public void testLoadPEMTrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, false, false, true, true);}
0
public void testLoadJKSKeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.JKS.getPropertyValue());}
0
public void testLoadJKSKeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue());}
0
public void testLoadJKSKeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
0
public void testLoadJKSKeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue());}
0
public void testLoadJKSTrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
0
public void testLoadJKSTrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue(), false, false, true, true);}
0
public void testLoadJKSTrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
0
public void testLoadJKSTrustStoreWithWrongPassword() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
0
public void testLoadPKCS12KeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue());}
0
public void testLoadPKCS12KeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue());}
0
public void testLoadPKCS12KeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
0
public void testLoadPKCS12KeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue());}
0
public void testLoadPKCS12TrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
0
public void testLoadPKCS12TrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue(), false, false, true, true);}
0
public void testLoadPKCS12TrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
0
public void testLoadPKCS12TrustStoreWithWrongPassword() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
0
public void testGetSslHandshakeDetectionTimeoutMillisProperty()
{    assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, x509Util.getSslHandshakeTimeoutMillis());        String newPropertyString = Integer.toString(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), newPropertyString);    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "0");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "-1");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }}
0
public void testCreateSSLContext_invalidCustomSSLContextClass() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), String.class.getCanonicalName());    clientX509Util.createSSLContext(zkConfig);}
0
public void testCreateSSLContext_validCustomSSLContextClass() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), SslContextSupplier.class.getName());    final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);    assertEquals(SSLContext.getDefault(), sslContext);}
0
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
public void testClientRenegotiationFails() throws Throwable
{    int port = PortAssignment.unique();    ExecutorService workerPool = Executors.newCachedThreadPool();    final SSLServerSocket listeningSocket = x509Util.createSSLServerSocket();    SSLSocket clientSocket = null;    SSLSocket serverSocket = null;    final AtomicInteger handshakesCompleted = new AtomicInteger(0);    final CountDownLatch handshakeCompleted = new CountDownLatch(1);    try {        InetSocketAddress localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);        listeningSocket.bind(localServerAddress);        Future<SSLSocket> acceptFuture;        acceptFuture = workerPool.submit(new Callable<SSLSocket>() {            @Override            public SSLSocket call() throws Exception {                SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                    @Override                    public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                        handshakesCompleted.getAndIncrement();                        handshakeCompleted.countDown();                    }                });                assertEquals(1, sslSocket.getInputStream().read());                try {                                        sslSocket.getInputStream().read();                    return sslSocket;                } catch (Exception e) {                    forceClose(sslSocket);                    throw e;                }            }        });        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(1);                clientSocket.startHandshake();        clientSocket.getOutputStream().write(1);                try {            serverSocket = acceptFuture.get();        } catch (ExecutionException e) {            throw e.getCause();        }    } finally {        forceClose(serverSocket);        forceClose(clientSocket);        forceClose(listeningSocket);        workerPool.shutdown();                        handshakeCompleted.await(5, TimeUnit.SECONDS);        assertEquals(1, handshakesCompleted.get());    }}
0
public SSLSocket call() throws Exception
{    SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();    sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {        @Override        public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {            handshakesCompleted.getAndIncrement();            handshakeCompleted.countDown();        }    });    assertEquals(1, sslSocket.getInputStream().read());    try {                sslSocket.getInputStream().read();        return sslSocket;    } catch (Exception e) {        forceClose(sslSocket);        throw e;    }}
0
public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent)
{    handshakesCompleted.getAndIncrement();    handshakeCompleted.countDown();}
0
public void testGetDefaultCipherSuitesJava8()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("1.8");        assertTrue(cipherSuites[0].contains("CBC"));}
0
public void testGetDefaultCipherSuitesJava9()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("9");        assertTrue(cipherSuites[0].contains("GCM"));}
0
public void testGetDefaultCipherSuitesJava10()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("10");        assertTrue(cipherSuites[0].contains("GCM"));}
0
public void testGetDefaultCipherSuitesJava11()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("11");        assertTrue(cipherSuites[0].contains("GCM"));}
0
public void testGetDefaultCipherSuitesUnknownVersion()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("notaversion");        assertTrue(cipherSuites[0].contains("CBC"));}
0
public void testGetDefaultCipherSuitesNullVersion()
{    X509Util.getDefaultCipherSuitesForJavaVersion(null);}
0
private void setCustomCipherSuites()
{    System.setProperty(x509Util.getCipherSuitesProperty(), customCipherSuites[0] + "," + customCipherSuites[1]);        x509Util.close();    x509Util = new ClientX509Util();}
0
public SSLContext get()
{    try {        return SSLContext.getDefault();    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
0
public static void createKeyPair() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    keyPair = keyPairGenerator.genKeyPair();}
0
public static void removeBouncyCastleProvider() throws Exception
{    Security.removeProvider("BC");}
0
public void setup() throws Exception
{    mockX509ExtendedTrustManager = mock(X509ExtendedTrustManager.class);    mockInetAddress = mock(InetAddress.class);    when(mockInetAddress.getHostAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return IP_ADDRESS;        }    });    when(mockInetAddress.getHostName()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return HOSTNAME;        }    });    mockSocket = mock(Socket.class);    when(mockSocket.getInetAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return mockInetAddress;        }    });}
0
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return IP_ADDRESS;}
0
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return HOSTNAME;}
0
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return mockInetAddress;}
0
private X509Certificate[] createSelfSignedCertifcateChain(String ipAddress, String hostname) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, "NOT_LOCALHOST");    Date notBefore = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(notBefore);    cal.add(Calendar.YEAR, 1);    Date notAfter = cal.getTime();    BigInteger serialNumber = new BigInteger(128, new Random());    X509v3CertificateBuilder certificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, notBefore, notAfter, nameBuilder.build(), keyPair.getPublic()).addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    List<GeneralName> generalNames = new ArrayList<>();    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(keyPair.getPrivate());    return new X509Certificate[] { new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner)) };}
0
public void testServerHostnameVerificationWithHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
0
public void testServerHostnameVerificationWithHostnameVerificationDisabledAndClientHostnameVerificationEnabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
0
public void testServerHostnameVerificationWithIPAddress() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
0
public void testServerHostnameVerificationWithHostname() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
0
public void testClientHostnameVerificationWithHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
0
public void testClientHostnameVerificationWithClientHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
0
public void testClientHostnameVerificationWithIPAddress() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
0
public void testClientHostnameVerificationWithHostname() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
0
public int size()
{    return 1;}
0
public InetSocketAddress next(long spinDelay)
{    return new InetSocketAddress("127.0.0.1", 2181);}
0
public void onConnected()
{}
0
public boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    counter.decrementAndGet();    return false;}
0
public void testZooKeeperWithCustomHostProvider() throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    final HostProvider specialHostProvider = new SpecialHostProvider();    int expectedCounter = 3;    counter.set(expectedCounter);    ZooKeeper zkDefaults = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false);    ZooKeeper zkSpecial = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false, specialHostProvider);    assertTrue(counter.get() == expectedCounter);    zkDefaults.updateServerList("127.0.0.1:" + PortAssignment.unique());    assertTrue(counter.get() == expectedCounter);    zkSpecial.updateServerList("127.0.0.1:" + PortAssignment.unique());    expectedCounter--;    assertTrue(counter.get() == expectedCounter);}
0
public void process(WatchedEvent event)
{}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
public void testGetAllChildrenNumberSync() throws KeeperException, InterruptedException
{        try {        zk.getAllChildrenNumber(null);        fail("the path for getAllChildrenNumber must not be null.");    } catch (IllegalArgumentException e) {        }    assertEquals(EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE + "/0"));    assertEquals(0, zk.getAllChildrenNumber(BASE + "/0/ephem0"));    assertEquals(0, zk.getAllChildrenNumber(BASE_EXT));    assertEquals(PERSISTENT_CNT + PERSISTENT_CNT * EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE));        assertEquals(13, zk.getAllChildrenNumber("/"));}
0
public void testGetAllChildrenNumberAsync() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    zk.getAllChildrenNumber("/", new AsyncCallback.AllChildrenNumberCallback() {        @Override        public void processResult(int rc, String path, Object ctx, int number) {            if (path == null) {                fail((String.format("the path of getAllChildrenNumber was null.")));            }            assertEquals(13, number);            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getAllChildrenNumber didn't callback within %d seconds", waitForCallbackSecs));    }}
0
public void processResult(int rc, String path, Object ctx, int number)
{    if (path == null) {        fail((String.format("the path of getAllChildrenNumber was null.")));    }    assertEquals(13, number);    doneProcessing.countDown();}
0
private void generatePaths(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    zk.create(BASE, BASE.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create(BASE_EXT, BASE_EXT.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + "/" + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        }    }}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    expected = generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
public void testGetEphemeralsSync() throws KeeperException, InterruptedException
{    List<String> actual = zk.getEphemerals();    assertEquals("Expected ephemeral count for allPaths", actual.size(), expected.length);    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in get All Ephemerals list ", path), actual.contains(path));    }}
0
public void testGetEphemeralsSyncByPath() throws KeeperException, InterruptedException
{    final String prefixPath = BASE + 0;    List<String> actual = zk.getEphemerals(prefixPath);    assertEquals("Expected ephemeral count for allPaths", actual.size(), EPHEMERAL_CNT);    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in getEphemerals(%s) list ", path, prefixPath), actual.contains(path));    }}
0
public void testGetEphemerals() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));            } else if (paths.size() != expected.length) {                unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));            }            for (int i = 0; i < expected.length; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals didn't callback within %d seconds", waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
0
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));    } else if (paths.size() != expected.length) {        unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));    }    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));        }    }    doneProcessing.countDown();}
0
public void testGetEphemeralsByPath() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = BASE + "0";    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));            } else if (paths.size() != EPHEMERAL_CNT) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));            }            for (int i = 0; i < EPHEMERAL_CNT; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
0
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));    } else if (paths.size() != EPHEMERAL_CNT) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));    }    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));        }    }    doneProcessing.countDown();}
0
public void testGetEphemeralsEmpty() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = "/unknownPath";    final int expectedSize = 0;    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));            } else if (paths.size() != expectedSize) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
0
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));    } else if (paths.size() != expectedSize) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));    }    doneProcessing.countDown();}
0
public void testGetEphemeralsErrors() throws KeeperException
{    try {        zk.getEphemerals(null, null, null);        fail("Should have thrown a IllegalArgumentException for a null prefixPath");    } catch (IllegalArgumentException e) {        }    try {        zk.getEphemerals("no leading slash", null, null);        fail("Should have thrown a IllegalArgumentException " + "for a prefix with no leading slash");    } catch (IllegalArgumentException e) {        }}
0
private String[] generatePaths(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    final String[] expected = new String[persistantCnt * ephemeralCnt];    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            expected[p * ephemeralCnt + e] = ephem;        }    }    return expected;}
0
private void checkForUnexpectedBehavior(List<String> unexpectedBehavior)
{    if (unexpectedBehavior.size() > 0) {        StringBuilder b = new StringBuilder("The test failed for the following reasons:");        b.append(NEWLINE);        for (String error : unexpectedBehavior) {            b.append("ERROR: ").append(error).append(NEWLINE);        }        fail(b.toString());    }}
0
public void addSection(String name, String loginModuleName, String... args)
{    Map<String, String> conf = new HashMap<String, String>();        for (int i = 0; i < args.length - 1; i += 2) {        conf.put(args[i], args[i + 1]);    }    addSection(name, loginModuleName, conf);}
0
public void addSection(String name, String loginModuleName, final Map<String, String> conf)
{    AppConfigurationEntry[] entries = new AppConfigurationEntry[1];    entries[0] = new AppConfigurationEntry(loginModuleName, LoginModuleControlFlag.REQUIRED, conf);    this.sections.put(name, entries);}
0
public AppConfigurationEntry[] getAppConfigurationEntry(String appName)
{    return sections.get(appName);}
0
public static List<FrameworkMethod> computeTestMethodsForClass(final Class klass, final List<FrameworkMethod> defaultMethods)
{    List<FrameworkMethod> list = defaultMethods;    String methodName = System.getProperty("test.method");    if (methodName == null) {            } else {                try {            list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));        } catch (NoSuchMethodException nsme) {                    }    }    return list;}
1
protected List<FrameworkMethod> computeTestMethods()
{    return computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
0
public void evaluate() throws Throwable
{        try {        super.evaluate();        Runtime rt = Runtime.getRuntime();        long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;                ThreadGroup tg = Thread.currentThread().getThreadGroup();        while (tg.getParent() != null) {            tg = tg.getParent();        }            } catch (Throwable t) {                                Test annotation = this.method.getAnnotation(Test.class);        if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {                    } else {                    }        throw t;    }    }
1
protected Statement methodInvoker(FrameworkMethod method, Object test)
{    return new LoggedInvokeMethod(method, test);}
0
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{}
0
public void start() throws MetricsProviderLifeCycleException
{}
0
public MetricsContext getRootContext()
{    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
0
public void stop()
{}
0
public void dump(BiConsumer<String, Object> sink)
{}
0
public void resetAllValues()
{}
0
public static void reset()
{    configureCalled.set(false);    startCalled.set(false);    stopCalled.set(false);    getRootContextCalled.set(false);}
0
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    if (!configureCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
0
public void start() throws MetricsProviderLifeCycleException
{    if (!startCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
0
public MetricsContext getRootContext()
{    getRootContextCalled.set(true);    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
0
public void stop()
{    if (!stopCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
0
public void start() throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
0
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
0
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    httpPort.set(Integer.parseInt(prprts.getProperty("httpPort")));}
0
public void stop()
{    stopCalled.set(true);    throw new RuntimeException();}
0
public static Map<String, Object> collect(MetricsProvider metricsProvider)
{    Map<String, Object> res = new HashMap<>();    metricsProvider.dump(res::put);    return res;}
0
public static Map<String, Object> currentServerMetrics()
{    return collect(ServerMetrics.getMetrics().getMetricsProvider());}
0
public ByteBuffer createAndReturnBB()
{    createBB();    return this.bb;}
0
public void testRoundTrip() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    request.add(Op.check("check", 1));    request.add(Op.create("create", "create data".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, ZooDefs.Perms.ALL));    request.add(Op.delete("delete", 17));    request.add(Op.setData("setData", "set data".getBytes(), 19));    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
0
public void testEmptyRoundTrip() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
0
private MultiOperationRecord codeDecode(MultiOperationRecord request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "request");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiOperationRecord decodedRequest = new MultiOperationRecord();    decodedRequest.deserialize(bia, "request");    return decodedRequest;}
0
public void testRoundTrip() throws IOException
{    MultiResponse response = new MultiResponse();    response.add(new OpResult.CheckResult());    response.add(new OpResult.CreateResult("foo-bar"));    response.add(new OpResult.DeleteResult());    Stat s = new Stat();    s.setCzxid(546);    response.add(new OpResult.SetDataResult(s));    MultiResponse decodedResponse = codeDecode(response);    assertEquals(response, decodedResponse);    assertEquals(response.hashCode(), decodedResponse.hashCode());}
0
public void testEmptyRoundTrip() throws IOException
{    MultiResponse result = new MultiResponse();    MultiResponse decodedResult = codeDecode(result);    assertEquals(result, decodedResult);    assertEquals(result.hashCode(), decodedResult.hashCode());}
0
private MultiResponse codeDecode(MultiResponse request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "result");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiResponse decodedRequest = new MultiResponse();    decodedRequest.deserialize(bia, "result");    return decodedRequest;}
0
public static synchronized int unique()
{    if (portRange == null) {        Integer threadId = Integer.getInteger("zookeeper.junit.threadid");        portRange = setupPortRange(System.getProperty("test.junit.threads"), threadId != null ? "threadid=" + threadId : System.getProperty("sun.java.command"));        nextPort = portRange.getMinimum();    }    int candidatePort = nextPort;    for (; ; ) {        ++candidatePort;        if (candidatePort > portRange.getMaximum()) {            candidatePort = portRange.getMinimum();        }        if (candidatePort == nextPort) {            throw new IllegalStateException(String.format("Could not assign port from range %s.  The entire range has been exhausted.", portRange));        }        try {            ServerSocket s = new ServerSocket(candidatePort);            s.close();            nextPort = candidatePort;                        return nextPort;        } catch (IOException e) {                    }    }}
1
 static PortRange setupPortRange(String strProcessCount, String cmdLine)
{    Integer processCount = null;    if (strProcessCount != null && !strProcessCount.isEmpty()) {        try {            processCount = Integer.valueOf(strProcessCount);        } catch (NumberFormatException e) {                    }    }    Integer threadId = null;    if (processCount != null) {        if (cmdLine != null && !cmdLine.isEmpty()) {            Matcher m = Pattern.compile("threadid=(\\d+)").matcher(cmdLine);            if (m.find()) {                try {                    threadId = Integer.valueOf(m.group(1));                } catch (NumberFormatException e) {                                    }            }        }    }    final PortRange newPortRange;    if (processCount != null && processCount > 1 && threadId != null) {                                        int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;        int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);        int maxPort = minPort + portRangeSize - 1;        newPortRange = new PortRange(minPort, maxPort);            } else {                        newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);            }    return newPortRange;}
1
 int getMaximum()
{    return maximum;}
0
 int getMinimum()
{    return minimum;}
0
public String toString()
{    return String.format("%d - %d", minimum, maximum);}
0
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[] { "8", "threadid=1", 11221, 13913 }, new Object[] { "8", "threadid=2", 13914, 16606 }, new Object[] { "8", "threadid=3", 16607, 19299 }, new Object[] { "8", "threadid=4", 19300, 21992 }, new Object[] { "8", "threadid=5", 21993, 24685 }, new Object[] { "8", "threadid=6", 24686, 27378 }, new Object[] { "8", "threadid=7", 27379, 30071 }, new Object[] { "8", "threadid=8", 30072, 32764 }, new Object[] { "1", "threadid=1", 11221, 32767 }, new Object[] { "2", "threadid=1", 11221, 21993 }, new Object[] { "2", "threadid=2", 21994, 32766 }, new Object[] { null, null, 11221, 32767 }, new Object[] { "", "", 11221, 32767 });}
0
public void testSetupPortRange()
{    PortAssignment.PortRange portRange = PortAssignment.setupPortRange(strProcessCount, cmdLine);    assertEquals(buildAssertionMessage("minimum"), expectedMinimumPort, portRange.getMinimum());    assertEquals(buildAssertionMessage("maximum"), expectedMaximumPort, portRange.getMaximum());}
0
private String buildAssertionMessage(String checkType)
{    return String.format("strProcessCount = %s, cmdLine = %s, checking %s", strProcessCount, cmdLine, checkType);}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    zkMain = new ZooKeeperMain(zk);}
0
public void tearDown() throws Exception
{    if (zk != null) {        zk.close();    }    super.tearDown();}
0
public void testRemoveWatchesWithNoPassedOptions() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 2);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.getChildren("/testnode1", myWatcher);    zk.getChildren("/testnode2", myWatcher);        zk.getData("/testnode1", myWatcher, null);    zk.getData("/testnode2", myWatcher, null);    String cmdstring = "removewatches /testnode1";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();        assertTrue("Failed to find child watches for the path testnode2", zk.getChildWatches().contains("/testnode2"));    assertTrue("Failed to find data watches for the path testnode2", zk.getDataWatches().contains("/testnode2"));}
1
public void testRemoveNodeDataChangedWatches() throws Exception
{        List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getData("/testnode1", myWatcher, null);    String cmdstring = "removewatches /testnode1 -d";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();        assertEquals("Data watches are not removed : " + zk.getDataWatches(), 0, zk.getDataWatches().size());}
1
public void testRemoveNodeCreatedWatches() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher1 = new MyWatcher("/testnode1", expectedEvents, 1);    MyWatcher myWatcher2 = new MyWatcher("/testnode1/testnode2", expectedEvents, 1);            zk.exists("/testnode1", myWatcher1);    zk.exists("/testnode1/testnode2", myWatcher2);    String cmdstring1 = "removewatches /testnode1 -d";        zkMain.cl.parseCommand(cmdstring1);    assertTrue("Removewatches cmd fails to remove pre-create watches", zkMain.processZKCmd(zkMain.cl));    myWatcher1.matches();    assertEquals("Failed to remove pre-create watches :" + zk.getExistWatches(), 1, zk.getExistWatches().size());    assertTrue("Failed to remove pre-create watches :" + zk.getExistWatches(), zk.getExistWatches().contains("/testnode1/testnode2"));    String cmdstring2 = "removewatches /testnode1/testnode2 -d";        zkMain.cl.parseCommand(cmdstring2);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));    myWatcher2.matches();    assertEquals("Failed to remove pre-create watches : " + zk.getExistWatches(), 0, zk.getExistWatches().size());}
1
public void testRemoveNodeChildrenChangedWatches() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));    myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 0, zk.getChildWatches().size());}
1
public void testRemoveNodeDeletedWatches() throws Exception
{        List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.NodeDeleted);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode1/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1/testnode2", myWatcher);    zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 1, zk.getChildWatches().size());    assertTrue("Failed to remove child watches :" + zk.getChildWatches(), zk.getChildWatches().contains("/testnode1/testnode2"));        zk.delete("/testnode1/testnode2", -1);    myWatcher.matches();}
1
public void testRemoveAnyWatches() throws Exception
{    verifyRemoveAnyWatches(false);}
0
public void testRemoveWatchesLocallyWhenNoServerConnection() throws Exception
{    verifyRemoveAnyWatches(true);}
0
private void verifyRemoveAnyWatches(boolean local) throws Exception
{    final Map<String, List<EventType>> pathVsEvent = new HashMap<>();        final CountDownLatch watcherLatch = new CountDownLatch(2);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            switch(event.getType()) {                case ChildWatchRemoved:                case DataWatchRemoved:                    addWatchNotifications(pathVsEvent, event);                    watcherLatch.countDown();                    break;                case NodeChildrenChanged:                case NodeDataChanged:                    addWatchNotifications(pathVsEvent, event);                    break;            }        }        private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event) {            pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());        }    };    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1", watcher);    zk.getData("/testnode1", watcher, null);    String cmdstring = "removewatches /testnode1 -a";    if (local) {                stopServer();        cmdstring = "removewatches /testnode1 -a -l";    }        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child/data watches", zkMain.processZKCmd(zkMain.cl));        watcherLatch.await(10, TimeUnit.SECONDS);    assertEquals("Didn't receives WatchRemoved events!", 1, pathVsEvent.size());    assertTrue("Didn't receives DataWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.DataWatchRemoved));    assertTrue("Didn't receives ChildWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.ChildWatchRemoved));}
1
public void process(WatchedEvent event)
{    switch(event.getType()) {        case ChildWatchRemoved:        case DataWatchRemoved:            addWatchNotifications(pathVsEvent, event);            watcherLatch.countDown();            break;        case NodeChildrenChanged:        case NodeDataChanged:            addWatchNotifications(pathVsEvent, event);            break;    }}
0
private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event)
{    pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());}
0
public void process(WatchedEvent event)
{        this.eventPath = event.getPath();    if (expectedEvents.contains(event.getType())) {        latch.countDown();    }}
1
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS)) {                return false;    }        return path.equals(eventPath);}
1
public void setUp() throws Exception
{    super.setUp();    zk1 = createClient();    zk2 = createClient();}
0
public void tearDown() throws Exception
{    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }    super.tearDown();}
0
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
0
private void removeWatches(ZooKeeper zk, String path, Watcher watcher, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{        if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeWatches(path, watcher, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeWatches(path, watcher, watcherType, local);    }}
1
private void removeAllWatches(ZooKeeper zk, String path, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{        if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeAllWatches(path, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeAllWatches(path, watcherType, local);    }}
1
public void testRemoveSingleWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk1.create("/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node2", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node2", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node2", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node2", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w1.getEventsAfterWatchRemoval();    assertFalse("Shouldn't get NodeDeletedEvent after watch removal", events.contains(EventType.NodeDeleted));    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
1
public void testMultipleDataWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node1", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
1
public void testMultipleChildWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);        zk2.getChildren("/node1", w1);    MyWatcher w2 = new MyWatcher("/node1", 1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());        zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        int count = 30;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(100);    }        List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeChildrenChanged event", 0, events.size());}
1
public void testRemoveAllWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());}
1
public void testRemoveAllDataWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove data watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));}
1
public void testRemoveAllChildWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    zk1.setData("/node1", "test".getBytes(), -1);    assertTrue("Didn't remove child watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));}
1
public void testNoWatcherException() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNull("Didn't set data watches", zk2.exists("/node2", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);        MyWatcher w3 = new MyWatcher("/node1", 2);    try {        removeWatches(zk2, "/node1", w3, WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Children, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/nonexists", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
1
public void testRemoveAnyDataWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 2);            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));            zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
1
public void testRemoveAnyChildWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w2);        zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove watchers", w1.matches());}
1
public void testRemoveWatcherWhenNoConnection() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    stopServer();    removeWatches(zk2, "/node1", w2, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertFalse("Shouldn't remove data watcher", w1.matches());    try {        removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.CONNECTIONLOSS);        fail("Should throw exception as last watch removal requires server connection");    } catch (KeeperException.ConnectionLossException nwe) {        }    assertFalse("Shouldn't remove data watcher", w1.matches());            removeWatches(zk2, "/node1", w1, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());}
1
public void testManyPreNodeWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        final String nodePath = path + i;        w = new MyWatcher(nodePath, 1);        wList.add(w);                zk1.exists(nodePath, w);    }    assertEquals("Failed to add watchers!", count, zk1.getExistWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getExistWatches().size());}
1
public void testManyChildWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);                zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Children, false, Code.OK);        assertTrue("Didn't remove child watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());}
1
public void testManyDataWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
1
public void testManyWatchersWhenNoConnection() throws Exception
{    int count = 3;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 2);        wList.add(w);                zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = wList.get(i);                zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    stopServer();    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Any, true, Code.OK);        assertTrue("Didn't remove watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
1
public void testChRootRemoveWatcher() throws Exception
{        String chRoot = "/appsX";    zk1.create("/appsX", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }        zk1 = createClient(this.hostPort + chRoot);    zk2 = createClient(this.hostPort + chRoot);        zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w2);        zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
1
public void testNoWatcherServerException() throws InterruptedException, IOException, TimeoutException
{    CountdownWatcher watcher = new CountdownWatcher();    MyZooKeeper zk = new MyZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    boolean nw = false;    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        zk.removeWatches("/nowatchhere", watcher, WatcherType.Data, false);    } catch (KeeperException nwe) {        if (nwe.code().intValue() == Code.NOWATCHER.intValue()) {            nw = true;        }    }    assertTrue("Server didn't return NOWATCHER", zk.getRemoveWatchesRC() == Code.NOWATCHER.intValue());    assertTrue("NoWatcherException didn't happen", nw);}
0
public void testRemoveAllNoWatcherException() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
0
public void testNullWatcherReference() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        if (useAsync) {            zk1.removeWatches("/node1", null, WatcherType.Data, false, null, null);        } else {            zk1.removeWatches("/node1", null, WatcherType.Data, false);        }        fail("Must throw IllegalArgumentException as watcher is null!");    } catch (IllegalArgumentException iae) {        }}
0
public void testRemoveWhenMultipleDataWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dataWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.DataWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeDataChanged) {            dataWatchCount.countDown();        }    };            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.setData("/node1", "test".getBytes(), -1);        assertTrue("Didn't get data watch notification!", dataWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
1
public void testRemoveWhenMultipleChildWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch childWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.ChildWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeChildrenChanged) {            childWatchCount.countDown();        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue("Didn't get child watch notification!", childWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
1
public void testRemoveAllDataWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));}
1
public void testRemoveAllChildWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch cWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));    removeAllWatches(zk2, "/node1", WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));}
1
public void testRemoveAllWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch watchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(4);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    assertEquals("Received watch notification after removal!", 2, watchCount.getCount());}
1
 void containsWatcher(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{}
0
protected boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    lastrc = rc;    return false;}
0
protected ZKWatchManager defaultWatchManager()
{    myWatchManager = new MyWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));    return myWatchManager;}
0
public int getRemoveWatchesRC()
{    return myWatchManager.lastrc;}
0
public void process(WatchedEvent event)
{        this.eventPath = event.getPath();        if (latch.getCount() == 0) {        if (event.getType() != EventType.None) {            eventsAfterWatchRemoval.add(event.getType());        }    }    if (event.getType() == EventType.ChildWatchRemoved || event.getType() == EventType.DataWatchRemoved) {        latch.countDown();    }}
1
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {                return false;    }        return path.equals(eventPath);}
1
public List<EventType> getEventsAfterWatchRemoval()
{    return eventsAfterWatchRemoval;}
0
public void processResult(int rc, String eventPath, Object ctx)
{    System.out.println("latch:" + path + " " + eventPath);    this.eventPath = eventPath;    this.eventRc = rc;    this.latch.countDown();}
0
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {        return false;    }    return path.equals(eventPath) && rc == eventRc;}
0
private boolean isServerSessionWatcher(long sessionId, String path, WatcherType type)
{    Set<ServerCnxn> cnxns = new HashSet<>();    CollectionUtils.addAll(cnxns, serverFactory.getConnections().iterator());    for (ServerCnxn cnxn : cnxns) {        if (cnxn.getSessionId() == sessionId) {            return serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().containsWatcher(path, type, cnxn);        }    }    return false;}
0
public static void init()
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    try {        File tmpDir = createTmpDir();        File saslConfFile = new File(tmpDir, "jaas.conf");        String jaasContent = getJaasFileContent();        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasContent);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException e) {            }}
0
private static String getJaasFileContent()
{    StringBuilder jaasContent = new StringBuilder();    String newLine = System.getProperty("line.separator");    jaasContent.append("Server {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("user_super=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    jaasContent.append("Client {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("username=\"super\"");    jaasContent.append(newLine);    jaasContent.append("password=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    return jaasContent.toString();}
0
public static void clean()
{    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty("java.security.auth.login.config");}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
0
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } finally {        zk.close();    }}
0
public void testValidSaslIds() throws Exception
{    ZooKeeper zk = createClient();    List<String> validIds = new ArrayList<String>();    validIds.add("user");    validIds.add("service/host.name.com");    validIds.add("user@KERB.REALM");    validIds.add("service/host.name.com@KERB.REALM");    int i = 0;    for (String validId : validIds) {        List<ACL> aclList = new ArrayList<ACL>();        ACL acl = new ACL(0, new Id("sasl", validId));        aclList.add(acl);        zk.create("/valid" + i, null, aclList, CreateMode.PERSISTENT);        i++;    }}
0
public void testInvalidSaslIds() throws Exception
{    ZooKeeper zk = createClient();    List<String> invalidIds = new ArrayList<String>();    invalidIds.add("user@KERB.REALM/server.com");    invalidIds.add("user@KERB.REALM1@KERB.REALM2");    int i = 0;    for (String invalidId : invalidIds) {        List<ACL> aclList = new ArrayList<ACL>();        try {            ACL acl = new ACL(0, new Id("sasl", invalidId));            aclList.add(acl);            zk.create("/invalid" + i, null, aclList, CreateMode.PERSISTENT);            fail("SASLAuthenticationProvider.isValid() failed to catch invalid Id.");        } catch (KeeperException.InvalidACLException e) {                } finally {            i++;        }    }}
0
public void testZKOperationsAfterClientSaslAuthFailure() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        setSaslFailureFlag(zk);                int totalTry = 10;        int tryCount = 0;        boolean success = false;        while (!success && tryCount++ <= totalTry) {            try {                zk.create("/saslAuthFail", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);                success = true;            } catch (KeeperException.ConnectionLossException e) {                Thread.sleep(1000);                        }        }        assertTrue("ZNode creation is failing continuously after Sasl auth failure.", success);    } finally {        zk.close();    }}
0
private void setSaslFailureFlag(ZooKeeper zk) throws Exception
{    Field cnxnField = zk.getClass().getDeclaredField("cnxn");    cnxnField.setAccessible(true);    ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);    Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");    sendThreadField.setAccessible(true);    SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);    Field saslLoginFailedField = sendThread.getClass().getDeclaredField("saslLoginFailed");    saslLoginFailedField.setAccessible(true);    saslLoginFailedField.setBoolean(sendThread, true);}
0
public void testThreadsShutdownOnAuthFailed() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = null;    try {        zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        try {            zk.addAuthInfo("FOO", "BAR".getBytes());            zk.getData("/path1", false, null);            fail("Should get auth state error");        } catch (KeeperException.AuthFailedException e) {            if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {                fail("Should have called my watcher");            }        }        Field cnxnField = zk.getClass().getDeclaredField("cnxn");        cnxnField.setAccessible(true);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);        Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");        sendThreadField.setAccessible(true);        SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);        Field eventThreadField = clientCnxn.getClass().getDeclaredField("eventThread");        eventThreadField.setAccessible(true);        EventThread eventThread = (EventThread) eventThreadField.get(clientCnxn);        sendThread.join(CONNECTION_TIMEOUT);        eventThread.join(CONNECTION_TIMEOUT);        assertFalse("SendThread did not shutdown after authFail", sendThread.isAlive());        assertFalse("EventThread did not shutdown after authFail", eventThread.isAlive());    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void setUp() throws Exception
{    r = new CommandResponse("makemeasandwich", "makeityourself");}
0
public void testGetters()
{    assertEquals("makemeasandwich", r.getCommand());    assertEquals("makeityourself", r.getError());}
0
public void testMap()
{    r.put("missing", "sudo");    Map<String, Object> m = new HashMap<String, Object>();    m.put("origin", "xkcd");    m.put("url", "http://xkcd.com/149/");    r.putAll(m);    Map<String, Object> rmap = r.toMap();    assertEquals(5, rmap.size());    assertEquals("makemeasandwich", rmap.get(CommandResponse.KEY_COMMAND));    assertEquals("makeityourself", rmap.get(CommandResponse.KEY_ERROR));    assertEquals("sudo", rmap.get("missing"));    assertEquals("xkcd", rmap.get("origin"));    assertEquals("http://xkcd.com/149/", rmap.get("url"));}
0
public void testCommand(String cmdName, Map<String, String> kwargs, Field... fields) throws IOException, InterruptedException
{    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    Map<String, Object> result = Commands.runCommand(cmdName, zks, kwargs).toMap();    assertTrue(result.containsKey("command"));        assertEquals(cmdName, result.remove("command"));    assertTrue(result.containsKey("error"));    assertNull("error: " + result.get("error"), result.remove("error"));    for (Field field : fields) {        String k = field.key;        assertTrue("Result from command " + cmdName + " missing field \"" + k + "\"" + "\n" + result, result.containsKey(k));        Class<?> t = field.type;        Object v = result.remove(k);        assertTrue("\"" + k + "\" field from command " + cmdName + " should be of type " + t + ", is actually of type " + v.getClass(), t.isAssignableFrom(v.getClass()));    }    assertTrue("Result from command " + cmdName + " contains extra fields: " + result, result.isEmpty());}
0
public void testCommand(String cmdName, Field... fields) throws IOException, InterruptedException
{    testCommand(cmdName, new HashMap<String, String>(), fields);}
0
public void testConfiguration() throws IOException, InterruptedException
{    testCommand("configuration", new Field("client_port", Integer.class), new Field("data_dir", String.class), new Field("data_log_dir", String.class), new Field("tick_time", Integer.class), new Field("max_client_cnxns", Integer.class), new Field("min_session_timeout", Integer.class), new Field("max_session_timeout", Integer.class), new Field("server_id", Long.class), new Field("client_port_listen_backlog", Integer.class));}
0
public void testConnections() throws IOException, InterruptedException
{    testCommand("connections", new Field("connections", Iterable.class), new Field("secure_connections", Iterable.class));}
0
public void testObservers() throws IOException, InterruptedException
{    testCommand("observers", new Field("synced_observers", Integer.class), new Field("observers", Iterable.class));}
0
public void testObserverConnectionStatReset() throws IOException, InterruptedException
{    testCommand("observer_connection_stat_reset");}
0
public void testConnectionStatReset() throws IOException, InterruptedException
{    testCommand("connection_stat_reset");}
0
public void testDump() throws IOException, InterruptedException
{    testCommand("dump", new Field("expiry_time_to_session_ids", Map.class), new Field("session_id_to_ephemeral_paths", Map.class));}
0
public void testEnvironment() throws IOException, InterruptedException
{    testCommand("environment", new Field("zookeeper.version", String.class), new Field("host.name", String.class), new Field("java.version", String.class), new Field("java.vendor", String.class), new Field("java.home", String.class), new Field("java.class.path", String.class), new Field("java.library.path", String.class), new Field("java.io.tmpdir", String.class), new Field("java.compiler", String.class), new Field("os.name", String.class), new Field("os.arch", String.class), new Field("os.version", String.class), new Field("user.name", String.class), new Field("user.home", String.class), new Field("user.dir", String.class), new Field("os.memory.free", String.class), new Field("os.memory.max", String.class), new Field("os.memory.total", String.class));}
0
public void testGetTraceMask() throws IOException, InterruptedException
{    testCommand("get_trace_mask", new Field("tracemask", Long.class));}
0
public void testIsReadOnly() throws IOException, InterruptedException
{    testCommand("is_read_only", new Field("read_only", Boolean.class));}
0
public void testLastSnapshot() throws IOException, InterruptedException
{    testCommand("last_snapshot", new Field("zxid", String.class), new Field("timestamp", Long.class));}
0
public void testMonitor() throws IOException, InterruptedException
{    ArrayList<Field> fields = new ArrayList<>(Arrays.asList(new Field("version", String.class), new Field("avg_latency", Double.class), new Field("max_latency", Long.class), new Field("min_latency", Long.class), new Field("packets_received", Long.class), new Field("packets_sent", Long.class), new Field("num_alive_connections", Integer.class), new Field("outstanding_requests", Long.class), new Field("server_state", String.class), new Field("znode_count", Integer.class), new Field("watch_count", Integer.class), new Field("ephemerals_count", Integer.class), new Field("approximate_data_size", Long.class), new Field("open_file_descriptor_count", Long.class), new Field("max_file_descriptor_count", Long.class), new Field("last_client_response_size", Integer.class), new Field("max_client_response_size", Integer.class), new Field("min_client_response_size", Integer.class), new Field("uptime", Long.class), new Field("global_sessions", Long.class), new Field("local_sessions", Long.class), new Field("connection_drop_probability", Double.class)));    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    for (String metric : metrics.keySet()) {        boolean alreadyDefined = fields.stream().anyMatch(f -> {            return f.key.equals(metric);        });        if (alreadyDefined) {                        continue;        }        if (metric.startsWith("avg_")) {            fields.add(new Field(metric, Double.class));        } else {            fields.add(new Field(metric, Long.class));        }    }    Field[] fieldsArray = fields.toArray(new Field[0]);    testCommand("monitor", fieldsArray);}
0
public void testRuok() throws IOException, InterruptedException
{    testCommand("ruok");}
0
public void testServerStats() throws IOException, InterruptedException
{    testCommand("server_stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("client_response", BufferStats.class));}
0
public void testSetTraceMask() throws IOException, InterruptedException
{    Map<String, String> kwargs = new HashMap<String, String>();    kwargs.put("traceMask", "1");    testCommand("set_trace_mask", kwargs, new Field("tracemask", Long.class));}
0
public void testStat() throws IOException, InterruptedException
{    testCommand("stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("connections", Iterable.class), new Field("client_response", BufferStats.class));}
0
public void testStatReset() throws IOException, InterruptedException
{    testCommand("stat_reset");}
0
public void testWatches() throws IOException, InterruptedException
{    testCommand("watches", new Field("session_id_to_watched_paths", Map.class));}
0
public void testWatchesByPath() throws IOException, InterruptedException
{    testCommand("watches_by_path", new Field("path_to_session_ids", Map.class));}
0
public void testWatchSummary() throws IOException, InterruptedException
{    testCommand("watch_summary", new Field("num_connections", Integer.class), new Field("num_paths", Integer.class), new Field("num_total_watches", Integer.class));}
0
public void testConsCommandSecureOnly()
{        Commands.ConsCommand cmd = new Commands.ConsCommand();    ZooKeeperServer zkServer = mock(ZooKeeperServer.class);    ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);    when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);        CommandResponse response = cmd.run(zkServer, null);        assertThat(response.toMap().containsKey("connections"), is(true));    assertThat(response.toMap().containsKey("secure_connections"), is(true));}
0
public void enableServer()
{        System.setProperty("zookeeper.admin.enableServer", "true");    System.setProperty("zookeeper.admin.serverPort", "" + jettyAdminPort);}
0
public void setupEncryption()
{    Security.addProvider(new BouncyCastleProvider());    File tmpDir = null;    X509TestContext x509TestContext = null;    try {        tmpDir = ClientBase.createEmptyTestDir();        x509TestContext = X509TestContext.newBuilder().setTempDir(tmpDir).setKeyStorePassword("").setKeyStoreKeyType(X509KeyType.EC).setTrustStorePassword("").setTrustStoreKeyType(X509KeyType.EC).build();        System.setProperty("zookeeper.ssl.quorum.keyStore.location", x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath());        System.setProperty("zookeeper.ssl.quorum.trustStore.location", x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath());    } catch (Exception e) {            }    System.setProperty("zookeeper.ssl.quorum.keyStore.password", "");    System.setProperty("zookeeper.ssl.quorum.keyStore.type", "PEM");    System.setProperty("zookeeper.ssl.quorum.trustStore.password", "");    System.setProperty("zookeeper.ssl.quorum.trustStore.type", "PEM");    System.setProperty("zookeeper.admin.portUnification", "true");        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {        public java.security.cert.X509Certificate[] getAcceptedIssuers() {            return null;        }        public void checkClientTrusted(X509Certificate[] certs, String authType) {        }        public void checkServerTrusted(X509Certificate[] certs, String authType) {        }    } };        SSLContext sc = null;    try {        sc = SSLContext.getInstance("SSL");        sc.init(null, trustAllCerts, new java.security.SecureRandom());    } catch (Exception e) {            }        HostnameVerifier allValid = new HostnameVerifier() {        public boolean verify(String hostname, SSLSession session) {            return true;        }    };            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());    HttpsURLConnection.setDefaultHostnameVerifier(allValid);}
1
public java.security.cert.X509Certificate[] getAcceptedIssuers()
{    return null;}
0
public void checkClientTrusted(X509Certificate[] certs, String authType)
{}
0
public void checkServerTrusted(X509Certificate[] certs, String authType)
{}
0
public boolean verify(String hostname, SSLSession session)
{    return true;}
0
public void cleanUp()
{    Security.removeProvider("BC");    System.clearProperty("zookeeper.admin.enableServer");    System.clearProperty("zookeeper.admin.serverPort");    System.clearProperty("zookeeper.ssl.quorum.keyStore.location");    System.clearProperty("zookeeper.ssl.quorum.keyStore.password");    System.clearProperty("zookeeper.ssl.quorum.keyStore.type");    System.clearProperty("zookeeper.ssl.quorum.trustStore.location");    System.clearProperty("zookeeper.ssl.quorum.trustStore.password");    System.clearProperty("zookeeper.ssl.quorum.trustStore.type");    System.clearProperty("zookeeper.admin.portUnification");}
0
public void testJettyAdminServer() throws AdminServerException, IOException, SSLContextException, GeneralSecurityException
{    JettyAdminServer server = new JettyAdminServer();    try {        server.start();        queryAdminServer(jettyAdminPort);    } finally {        server.shutdown();    }}
0
public void testStandalone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServerMainTest.MainThread main = new ZooKeeperServerMainTest.MainThread(CLIENT_PORT, false, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(jettyAdminPort);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
0
public void testQuorum() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    final int ADMIN_SERVER_PORT1 = PortAssignment.unique();    final int ADMIN_SERVER_PORT2 = PortAssignment.unique();    String quorumCfgSection = String.format("server.1=127.0.0.1:%d:%d;%d\nserver.2=127.0.0.1:%d:%d;%d", PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    QuorumPeerTestBase.MainThread q1 = new QuorumPeerTestBase.MainThread(1, CLIENT_PORT_QP1, ADMIN_SERVER_PORT1, quorumCfgSection, null);    q1.start();                Thread.sleep(500);    QuorumPeerTestBase.MainThread q2 = new QuorumPeerTestBase.MainThread(2, CLIENT_PORT_QP2, ADMIN_SERVER_PORT2, quorumCfgSection, null);    q2.start();    Thread.sleep(500);    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(ADMIN_SERVER_PORT1);    queryAdminServer(ADMIN_SERVER_PORT2);    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
0
private void queryAdminServer(int port) throws IOException, SSLContextException
{    queryAdminServer(String.format(URL_FORMAT, port), false);    queryAdminServer(String.format(HTTPS_URL_FORMAT, port), true);}
0
private void queryAdminServer(String urlStr, boolean encrypted) throws IOException, SSLContextException
{    URL url = new URL(urlStr);    BufferedReader dis;    if (!encrypted) {        dis = new BufferedReader(new InputStreamReader((url.openStream())));    } else {        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();        dis = new BufferedReader(new InputStreamReader(conn.getInputStream()));    }    String line = dis.readLine();    assertTrue(line.length() > 0);}
0
public double nextDouble()
{    if (throttle.getDropChance() > 0) {        flag = 1 - flag;        return flag;    } else {        return 1;    }}
0
public void testThrottleDisabled()
{    BlueThrottle throttler = new BlueThrottle();    assertTrue("Throttle should be disabled by default", throttler.checkLimit(1));}
0
public void testThrottleWithoutRefill()
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(2000);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));}
0
public void testThrottleWithRefill() throws InterruptedException
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(500);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));        Thread.sleep(750);    assertTrue("Third request should be allowed since we've got a new token", throttler.checkLimit(1));}
0
public void testThrottleWithoutRandomDropping() throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(110);    throttler.checkLimit(1);    assertFalse("Dropping probability should still be zero", throttler.getDropChance() > 0);        Thread.sleep(1500);    for (int i = 0; i < maxTokens; i++) {        assertTrue("The first " + maxTokens + " requests should be allowed", throttler.checkLimit(1));    }    for (int i = 0; i < maxTokens; i++) {        assertFalse("The latter " + maxTokens + " requests should be denied", throttler.checkLimit(1));    }}
0
public void testThrottleWithRandomDropping() throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    throttler.setFreezeTime(100);    throttler.setDropIncrease(0.5);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(120);        throttler.checkLimit(1);    assertTrue("Dropping probability should be increased", throttler.getDropChance() > 0);            Thread.sleep(1100);        int accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }        assertTrue("The dropping should be distributed", accepted < maxTokens);    accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }        assertTrue("Later requests should have a chance", accepted > 0);}
1
private int connect(int n) throws Exception
{    String connStr = quorumUtil.getConnectionStringForServer(1);    int connected = 0;    zks = new ZooKeeper[n];    watchers = new ClientBase.CountdownWatcher[n];    for (int i = 0; i < n; i++) {        watchers[i] = new ClientBase.CountdownWatcher();        zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            connected++;        } catch (TimeoutException e) {                        break;        }    }    return connected;}
1
private void shutdownQuorum() throws Exception
{    for (ZooKeeper zk : zks) {        if (zk != null) {            zk.close();        }    }    quorumUtil.shutdownAll();}
0
public void testNoThrottling() throws Exception
{    quorumUtil.startAll();        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(0);    int connected = connect(10);    Assert.assertEquals(10, connected);    shutdownQuorum();}
0
public void testThrottling() throws Exception
{    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();}
0
public void testWeighedThrottling() throws Exception
{            BlueThrottle.setConnectionWeightEnabled(true);    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        int connected = connect(11);    Assert.assertEquals(10, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        connected = connect(11);    Assert.assertEquals(3, connected);    shutdownQuorum();    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(2);    Assert.assertEquals(2, connected);    quorumUtil.shutdown(1);    watchers[0].waitForDisconnected(RAPID_TIMEOUT);    watchers[1].waitForDisconnected(RAPID_TIMEOUT);    quorumUtil.restart(1);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(3);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int reconnected = 0;    for (int i = 0; i < 2; i++) {        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            reconnected++;        } catch (TimeoutException e) {                    }    }            Assert.assertEquals(1, reconnected);    shutdownQuorum();}
1
public static void setUpClass()
{    int len = DATA_BYTES_0.length + 2;    DATA_BYTES = new byte[len];    System.arraycopy(DATA_BYTES_0, 0, DATA_BYTES, 0, DATA_BYTES_0.length);    DATA_BYTES[len - 2] = (byte) 0x0;    DATA_BYTES[len - 1] = (byte) 0xff;}
0
public void setUp() throws Exception
{    bb = ByteBuffer.wrap(DATA_BYTES);    in = new ByteBufferInputStream(bb);    bs = new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4 };}
0
public void testRead() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        int b = in.read();        assertEquals(DATA_BYTES[i], (byte) b);    }    assertEquals(-1, in.read());}
0
public void testReadArrayOffsetLength() throws Exception
{    assertEquals(1, in.read(bs, 2, 1));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[0], (byte) 4 };    assertArrayEquals(expected, bs);}
0
public void testReadArrayOffsetLength_LengthTooLarge() throws Exception
{    in.read(bs, 2, 3);}
0
public void testReadArrayOffsetLength_HitEndOfStream() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1, in.read(bs, 2, 2));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[DATA_BYTES.length - 1], (byte) 4 };    assertArrayEquals(expected, bs);}
0
public void testReadArrayOffsetLength_AtEndOfStream() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(-1, in.read(bs, 2, 2));    assertArrayEquals(expected, bs);}
0
public void testReadArrayOffsetLength_0Length() throws Exception
{    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(0, in.read(bs, 2, 0));    assertArrayEquals(expected, bs);}
0
public void testReadArray() throws Exception
{    byte[] expected = Arrays.copyOf(DATA_BYTES, 4);    assertEquals(4, in.read(bs));    assertArrayEquals(expected, bs);}
0
public void testSkip() throws Exception
{    in.read();    assertEquals(2L, in.skip(2L));    assertEquals(DATA_BYTES[3], in.read());    assertEquals(DATA_BYTES[4], in.read());}
0
public void testSkip2() throws Exception
{    for (int i = 0; i < DATA_BYTES.length / 2; i++) {        in.read();    }    long skipAmount = DATA_BYTES.length / 4;    assertEquals(skipAmount, in.skip(skipAmount));    int idx = DATA_BYTES.length / 2 + (int) skipAmount;    assertEquals(DATA_BYTES[idx++], in.read());    assertEquals(DATA_BYTES[idx++], in.read());}
0
public void testNegativeSkip() throws Exception
{    in.read();    assertEquals(0L, in.skip(-2L));    assertEquals(DATA_BYTES[1], in.read());    assertEquals(DATA_BYTES[2], in.read());}
0
public void testSkip_HitEnd() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1L, in.skip(2L));    assertEquals(-1, in.read());}
0
public void testSkip_AtEnd() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    assertEquals(0L, in.skip(2L));    assertEquals(-1, in.read());}
0
public void testAvailable() throws Exception
{    for (int i = DATA_BYTES.length; i > 0; i--) {        assertEquals(i, in.available());        in.read();    }    assertEquals(0, in.available());}
0
public void testRevalidateCount() throws Exception
{    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);        util.enableLocalSession(false);    util.startAll();    int follower1 = (int) util.getFollowerQuorumPeers().get(0).getId();    int follower2 = (int) util.getFollowerQuorumPeers().get(1).getId();        ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();        ZooKeeper zk = new ZooKeeper(util.getConnectionStringForServer(follower1), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);            zk.updateServerList(util.getConnectionStringForServer(follower2));        util.shutdown(follower1);    watcher.waitForDisconnected(ClientBase.CONNECTION_TIMEOUT);            watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_revalidate_count"));    assertEquals(1L, values.get("revalidate_count"));    zk.close();    util.shutdownAll();}
1
protected boolean isSocketOpen()
{    return true;}
0
public SelectableChannel channel()
{    return null;}
0
public Selector selector()
{    return mock(Selector.class);}
0
public boolean isValid()
{    return true;}
0
public void cancel()
{}
0
public int interestOps()
{    return ops;}
0
public SelectionKey interestOps(int ops)
{    this.ops = ops;    return this;}
0
public int readyOps()
{    return ops;}
0
private NIOServerCnxn createMockNIOCnxn() throws IOException
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddr);    SocketChannel sock = mock(SocketChannel.class);    when(sock.socket()).thenReturn(socket);    when(sock.read(any(ByteBuffer.class))).thenReturn(-1);    return new MockNIOServerCnxn(mock(ZooKeeperServer.class), sock, null, mock(NIOServerCnxnFactory.class), null);}
0
public void testNIOConnectionDropCount() throws Exception
{    ServerMetrics.getMetrics().resetAll();    NIOServerCnxn cnxn = createMockNIOCnxn();    cnxn.doIO(new FakeSK());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
0
public void testNettyConnectionDropCount() throws Exception
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Channel channel = mock(Channel.class);    when(channel.isOpen()).thenReturn(false);    when(channel.remoteAddress()).thenReturn(socketAddr);    EventLoop eventLoop = mock(EventLoop.class);    when(channel.eventLoop()).thenReturn(eventLoop);    ServerMetrics.getMetrics().resetAll();    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    NettyServerCnxn cnxn = new NettyServerCnxn(channel, mock(ZooKeeperServer.class), factory);        factory.cnxns.add(cnxn);    cnxn.close();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
0
public void testSessionlessConnectionsExpired() throws Exception
{    ServerCnxnFactory factory = new NIOServerCnxnFactory();    factory.configure(new InetSocketAddress(PortAssignment.unique()), 1000);    factory.start();    int timeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);    ServerMetrics.getMetrics().resetAll();        ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("sessionless_connections_expired") == null || sleptTime < 2 * timeout) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("sessionless_connections_expired"));    factory.shutdown();}
0
public void testStaleSessionsExpired() throws Exception
{    int tickTime = 1000;    SessionTrackerImpl tracker = new SessionTrackerImpl(mock(ZooKeeperServer.class), new ConcurrentHashMap<>(), tickTime, 1L, null);    tracker.sessionsById.put(1L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.sessionsById.put(2L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.touchSession(1L, tickTime);    tracker.touchSession(2L, tickTime);    ServerMetrics.getMetrics().resetAll();    tracker.start();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("stale_sessions_expired") == null || sleptTime < 2 * tickTime) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("stale_sessions_expired"));    tracker.shutdown();}
0
private void corruptFile(File file) throws IOException
{        RandomAccessFile raf = new RandomAccessFile(file, "rw");    byte[] b = "mahadev".getBytes();    long writeLen = 500L;    raf.seek(writeLen);        raf.write(b);    raf.close();}
0
private boolean getCheckSum(FileSnap snap, File snapFile) throws IOException
{    DataTree dt = new DataTree();    Map<Long, Integer> sessions = new ConcurrentHashMap<Long, Integer>();    InputStream snapIS = new BufferedInputStream(new FileInputStream(snapFile));    CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());    InputArchive ia = BinaryInputArchive.getArchive(crcIn);    try {        snap.deserialize(dt, sessions, ia);    } catch (IOException ie) {                                        snapIS.close();        crcIn.close();        throw ie;    }    long checksum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");    snapIS.close();    crcIn.close();    return (val != checksum);}
0
public void testChecksums() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(150);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/crctest- " + i, ("/crctest- " + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    File versionDir = new File(tmpDir, "version-2");    File[] list = versionDir.listFiles();            File snapFile = null;    File logFile = null;    for (File file : list) {                if (file.getName().startsWith("log")) {            logFile = file;            corruptFile(logFile);        }    }    FileTxnLog flog = new FileTxnLog(versionDir);    TxnIterator itr = flog.read(1);        try {        while (itr.next()) {        }        assertTrue(false);    } catch (IOException ie) {            }    itr.close();        FileSnap snap = new FileSnap(versionDir);    List<File> snapFiles = snap.findNRecentSnapshots(2);    snapFile = snapFiles.get(0);    corruptFile(snapFile);    boolean cfile = false;    try {        cfile = getCheckSum(snap, snapFile);    } catch (IOException ie) {                                snapFile = snapFiles.get(1);        corruptFile(snapFile);        cfile = getCheckSum(snap, snapFile);    }    assertTrue(cfile);}
1
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
public void testCreate() throws KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
0
public void testCreateWithStat() throws KeeperException, InterruptedException
{    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
0
public void testCreateWithNullStat() throws KeeperException, InterruptedException
{    final String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            zk.create(name, name.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
0
public void testSimpleDeletion() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
0
public void testMultiWithContainerSimple() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.multi(Collections.singletonList(createContainer));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);}
0
public void testMultiWithContainer() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    Op createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.multi(Arrays.asList(createContainer, createChild));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));    createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Op deleteChild = Op.delete("/foo/bar", -1);    zk.multi(Arrays.asList(createContainer, createChild, deleteChild));    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
0
public void testSimpleDeletionAsync() throws KeeperException, InterruptedException
{    final CountDownLatch latch = new CountDownLatch(1);    AsyncCallback.Create2Callback cb = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            assertEquals(ctx, "context");            latch.countDown();        }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, cb, "context");    assertTrue(latch.await(5, TimeUnit.SECONDS));    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    assertEquals(ctx, "context");    latch.countDown();}
0
public void testCascadingDeletion() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar/one", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar/one", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo/bar", false));    assertNull("Container should have been deleted", zk.exists("/foo", false));}
0
public void testFalseEmpty() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected Collection<String> getCandidates() {            return Collections.singletonList("/foo");        }    };    containerManager.checkContainers();    Thread.sleep(1000);    assertNotNull("Container should have not been deleted", zk.exists("/foo", false));}
0
protected Collection<String> getCandidates()
{    return Collections.singletonList("/foo");}
0
public void testMaxPerMinute() throws InterruptedException
{    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();    RequestProcessor processor = new RequestProcessor() {        @Override        public void processRequest(Request request) {            queue.add(new String(request.request.array()));        }        @Override        public void shutdown() {        }    };    final ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), processor, 1, 2) {        @Override        protected long getMinIntervalMs() {            return 1000;        }        @Override        protected Collection<String> getCandidates() {            return Arrays.asList("/one", "/two", "/three", "/four");        }    };    Executors.newSingleThreadExecutor().submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            containerManager.checkContainers();            return null;        }    });    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/one");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/two");    assertEquals(queue.size(), 0);    Thread.sleep(500);    assertEquals(queue.size(), 0);    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/three");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/four");}
0
public void processRequest(Request request)
{    queue.add(new String(request.request.array()));}
0
public void shutdown()
{}
0
protected long getMinIntervalMs()
{    return 1000;}
0
protected Collection<String> getCandidates()
{    return Arrays.asList("/one", "/two", "/three", "/four");}
0
public Void call() throws Exception
{    containerManager.checkContainers();    return null;}
0
private void createNoStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
0
private Stat createWithStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
0
private void validateCreateStat(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void setUp() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, disabledTests.contains(getTestName()) ? "false" : "true");    super.setUpWithServerId(254);    zk = createClient();}
0
public void tearDown() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    super.tearDown();    zk.close();}
0
public void testCreate() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
0
public void testBadTTLs() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), -100);    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));    request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue() + 1);    response = new CreateResponse();    r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));}
0
public void testMaxTTLs() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue());    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("EphemeralType.getMaxTTL() should succeed", r.getErr(), Code.OK.intValue());    assertNotNull("Node should exist", zk.exists(path, false));}
0
public void testCreateSequential() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    String path = zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists(path, false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists(path, false));}
0
public void testCreateAsync() throws KeeperException, InterruptedException
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, callback, null, 100);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{}
0
public void testModifying() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    for (int i = 0; i < 10; ++i) {        fakeElapsed.set(50);        zk.setData("/foo", new byte[i + 1], -1);        containerManager.checkContainers();        assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    }    fakeElapsed.set(200);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
0
public void testMulti() throws KeeperException, InterruptedException
{    Op createTtl = Op.create("/a", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 100);    Op createTtlSequential = Op.create("/b", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 200);    Op createNonTtl = Op.create("/c", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> results = zk.multi(Arrays.asList(createTtl, createTtlSequential, createNonTtl));    String sequentialPath = ((OpResult.CreateResult) results.get(1)).getPath();    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("node should not have been deleted yet", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(110);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(210);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNull("node should have been deleted", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));}
0
public void testBadUsage() throws KeeperException, InterruptedException
{    for (CreateMode createMode : CreateMode.values()) {        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, new Stat(), createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    for (CreateMode createMode : CreateMode.values()) {        AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                        }        };        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, callback, null, createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{}
0
public void testDisabled() throws KeeperException, InterruptedException
{        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 100);}
0
private ContainerManager newContainerManager(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
0
protected long getElapsed(DataNode node)
{    return fakeElapsed.get();}
0
public void setUp() throws Exception
{    File dataDir = ClientBase.createTmpDir();    snapDir = dataDir;    dataLogDir = dataDir;}
0
public void testPurgeTask() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 1);    purgeMgr.start();    assertEquals("Data log directory is not set as configured", dataLogDir, purgeMgr.getDataLogDir());    assertEquals("Snapshot directory is not set as configured", snapDir, purgeMgr.getSnapDir());    assertEquals("Snapshot retain count is not set as configured", 3, purgeMgr.getSnapRetainCount());    assertEquals("Purge task is not started", STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is still running after shutdown", COMPLETED, purgeMgr.getPurgeTaskStatus());}
0
public void testWithZeroPurgeInterval() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 0);    purgeMgr.start();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
0
public void testWithNegativePurgeInterval() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, -1);    purgeMgr.start();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
0
public void tearDown() throws Exception
{    if (purgeMgr != null) {        purgeMgr.shutdown();    }}
0
public void testGetChildrenShouldReturnEmptySetWhenThereAreNoChidren()
{        DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        String child = "child";    dataNode.addChild(child);    dataNode.removeChild(child);    children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
0
public void testGetChildrenReturnsImmutableEmptySet()
{    DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
0
public void testDumpEphemerals() throws Exception
{    int count = 1000;    long session = 1000;    long zxid = 2000;    final DataTree dataTree = new DataTree();        createEphemeralNode(session, dataTree, count);    final AtomicBoolean exceptionDuringDumpEphemerals = new AtomicBoolean(false);    final AtomicBoolean running = new AtomicBoolean(true);    Thread thread = new Thread() {        public void run() {            PrintWriter pwriter = new PrintWriter(new StringWriter());            try {                while (running.get()) {                    dataTree.dumpEphemerals(pwriter);                }            } catch (Exception e) {                                exceptionDuringDumpEphemerals.set(true);            }        }    };    thread.start();        killZkClientSession(session, zxid, dataTree, count);    running.set(false);    thread.join();    assertFalse("Should have got exception while dumpEphemerals!", exceptionDuringDumpEphemerals.get());}
1
public void run()
{    PrintWriter pwriter = new PrintWriter(new StringWriter());    try {        while (running.get()) {            dataTree.dumpEphemerals(pwriter);        }    } catch (Exception e) {                exceptionDuringDumpEphemerals.set(true);    }}
1
private void killZkClientSession(long session, long zxid, final DataTree dataTree, int count)
{    for (int i = 0; i < count; i++) {        dataTree.killSession(session + i, zxid);    }}
0
private void createEphemeralNode(long session, final DataTree dataTree, int count) throws NoNodeException, NodeExistsException
{    for (int i = 0; i < count; i++) {        dataTree.createNode("/test" + i, new byte[0], null, session + i, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    }}
0
public void testRootWatchTriggered() throws Exception
{    DataTree dt = new DataTree();    CompletableFuture<Void> fire = new CompletableFuture<>();        dt.getChildren("/", new Stat(), event -> {        if (event.getPath().equals("/")) {            fire.complete(null);        }    });        dt.createNode("/xyz", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);    assertTrue("Root node watch not triggered", fire.isDone());}
0
public void testIncrementCversion() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);        DataNode zk = dt.getNode("/test");        int prevCversion = zk.stat.getCversion();        long prevPzxid = zk.stat.getPzxid();        long digestBefore = dt.getTreeDigest();        dt.setCversionPzxid("/test/", prevCversion + 1, prevPzxid + 1);        int newCversion = zk.stat.getCversion();        long newPzxid = zk.stat.getPzxid();        assertTrue("<cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));        assertNotEquals(digestBefore, dt.getTreeDigest());    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
0
public void testNoCversionRevert() throws Exception
{    DataTree dt = new DataTree();    DataNode parent = dt.getNode("/");    dt.createNode("/test", new byte[0], null, 0, parent.stat.getCversion() + 1, 1, 1);    int currentCversion = parent.stat.getCversion();    long currentPzxid = parent.stat.getPzxid();    dt.createNode("/test1", new byte[0], null, 0, currentCversion - 1, 1, 1);    parent = dt.getNode("/");    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    assertTrue("<cversion, pzxid> verification failed. Expected: <" + currentCversion + ", " + currentPzxid + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion >= currentCversion && newPzxid >= currentPzxid));}
0
public void testPzxidUpdatedWhenDeletingNonExistNode() throws Exception
{    DataTree dt = new DataTree();    DataNode root = dt.getNode("/");    long currentPzxid = root.stat.getPzxid();        long zxid = currentPzxid + 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, zxid);        long prevPzxid = currentPzxid;    zxid = prevPzxid - 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, prevPzxid);}
0
public void testDigestUpdatedWhenReplayCreateTxnForExistNode()
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                                dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 2));                assertEquals(dt.getTreeDigest(), dt.getLastProcessedZxidDigest().digest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
0
public void testPathTrieClearOnDeserialize() throws Exception
{        DataTree dserTree = new DataTree();    dserTree.createNode("/bug", new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaZookeeper + "/bug", null, null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaPath("/bug"), new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.statPath("/bug"), new byte[20], null, -1, 1, 1, 1);        DataTree tree = new DataTree();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    dserTree.deserialize(ia, "test");    Field pfield = DataTree.class.getDeclaredField("pTrie");    pfield.setAccessible(true);    PathTrie pTrie = (PathTrie) pfield.get(dserTree);        assertEquals("/bug is still in pTrie", "/", pTrie.findMaxPrefix("/bug"));}
0
public void testSerializeDoesntLockDataNodeWhileWriting() throws Exception
{    DataTree tree = new DataTree();    tree.createNode("/marker", new byte[] { 42 }, null, -1, 1, 1, 1);    final DataNode markerNode = tree.getNode("/marker");    final AtomicBoolean ranTestCase = new AtomicBoolean();    DataOutputStream out = new DataOutputStream(new ByteArrayOutputStream());    BinaryOutputArchive oa = new BinaryOutputArchive(out) {        @Override        public void writeRecord(Record r, String tag) throws IOException {                        if (r instanceof DataNode) {                DataNode node = (DataNode) r;                if (node.data.length == 1 && node.data[0] == 42) {                    final Semaphore semaphore = new Semaphore(0);                    new Thread(new Runnable() {                        @Override                        public void run() {                            synchronized (markerNode) {                                                                semaphore.release();                            }                        }                    }).start();                    try {                        boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                                        assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);                    } catch (InterruptedException e1) {                        throw new RuntimeException(e1);                    }                    ranTestCase.set(true);                }            }            super.writeRecord(r, tag);        }    };    tree.serialize(oa, "test");        assertTrue("Didn't find the expected node", ranTestCase.get());}
0
public void writeRecord(Record r, String tag) throws IOException
{        if (r instanceof DataNode) {        DataNode node = (DataNode) r;        if (node.data.length == 1 && node.data[0] == 42) {            final Semaphore semaphore = new Semaphore(0);            new Thread(new Runnable() {                @Override                public void run() {                    synchronized (markerNode) {                                                semaphore.release();                    }                }            }).start();            try {                boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);            } catch (InterruptedException e1) {                throw new RuntimeException(e1);            }            ranTestCase.set(true);        }    }    super.writeRecord(r, tag);}
0
public void run()
{    synchronized (markerNode) {                semaphore.release();    }}
0
public void testReconfigACLClearOnDeserialize() throws Exception
{    DataTree tree = new DataTree();            tree.deleteNode(ZooDefs.CONFIG_NODE, 1);    tree.getReferenceCountedAclCache().aclIndex = 0;    assertEquals("expected to have 1 acl in acl cache map", 0, tree.aclCacheSize());        tree.createNode("/bug", new byte[20], ZooDefs.Ids.OPEN_ACL_UNSAFE, -1, 1, 1, 1);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    tree.deserialize(ia, "test");    assertEquals("expected to have 1 acl in acl cache map", 1, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));            tree.addConfigNode();    assertEquals("expected to have 2 acl in acl cache map", 2, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));}
0
public void testCachedApproximateDataSize() throws Exception
{    DataTree dt = new DataTree();    long initialSize = dt.approximateDataSize();    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.createNode("/testApproximateDataSize", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/testApproximateDataSize1", new byte[20], null, -1, 1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.setData("/testApproximateDataSize1", new byte[32], -1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.deleteNode("/testApproximateDataSize", -1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());}
0
public void testGetAllChildrenNumber() throws Exception
{    DataTree dt = new DataTree();        dt.createNode("/all_children_test", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node1", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node2", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node3", new byte[20], null, -1, 1, 1, 1);    assertEquals(4, dt.getAllChildrenNumber("/all_children_test"));    assertEquals(3, dt.getAllChildrenNumber("/all_children_test/nodes"));    assertEquals(0, dt.getAllChildrenNumber("/all_children_test/nodes/node1"));        assertEquals(8, dt.getAllChildrenNumber("/"));}
0
public void testDataTreeMetrics() throws Exception
{    ServerMetrics.getMetrics().resetAll();    long readBytes1 = 0;    long readBytes2 = 0;    long writeBytes1 = 0;    long writeBytes2 = 0;    final String TOP1 = "top1";    final String TOP2 = "ttop2";    final String TOP1PATH = "/" + TOP1;    final String TOP2PATH = "/" + TOP2;    final String CHILD1 = "child1";    final String CHILD2 = "springishere";    final String CHILD1PATH = TOP1PATH + "/" + CHILD1;    final String CHILD2PATH = TOP1PATH + "/" + CHILD2;    final int TOP2_LEN = 50;    final int CHILD1_LEN = 100;    final int CHILD2_LEN = 250;    DataTree dt = new DataTree();    dt.createNode(TOP1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += TOP1PATH.length();    dt.createNode(TOP2PATH, new byte[TOP2_LEN], null, -1, 1, 1, 1);    writeBytes2 += TOP2PATH.length() + TOP2_LEN;    dt.createNode(CHILD1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += CHILD1PATH.length();    dt.setData(CHILD1PATH, new byte[CHILD1_LEN], 1, -1, 1);    writeBytes1 += CHILD1PATH.length() + CHILD1_LEN;    dt.createNode(CHILD2PATH, new byte[CHILD2_LEN], null, -1, 1, 1, 1);    writeBytes1 += CHILD2PATH.length() + CHILD2_LEN;    dt.getData(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getData(TOP2PATH, new Stat(), null);    readBytes2 += TOP2PATH.length() + TOP2_LEN + DataTree.STAT_OVERHEAD_BYTES;    dt.statNode(CHILD2PATH, null);    readBytes1 += CHILD2PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getChildren(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + CHILD1.length() + CHILD2.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.deleteNode(TOP1PATH, 1);    writeBytes1 += TOP1PATH.length();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    System.out.println("values:" + values);    assertEquals(writeBytes1, values.get("sum_" + TOP1 + "_write_per_namespace"));    assertEquals(5L, values.get("cnt_" + TOP1 + "_write_per_namespace"));    assertEquals(writeBytes2, values.get("sum_" + TOP2 + "_write_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_write_per_namespace"));    assertEquals(readBytes1, values.get("sum_" + TOP1 + "_read_per_namespace"));    assertEquals(3L, values.get("cnt_" + TOP1 + "_read_per_namespace"));    assertEquals(readBytes2, values.get("sum_" + TOP2 + "_read_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_read_per_namespace"));}
0
public void testDigest() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();                long previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest", new byte[0], null, -1, 1, 1, 1);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        try {            dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        } catch (NodeExistsException e) {        /* ignore */        }        assertEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.setData("/digesttest/1", "2".getBytes(), 3, 3, 3);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.deleteNode("/digesttest/1", 5);        assertNotEquals(dt.getTreeDigest(), previousDigest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
0
private static void deserializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    BinaryInputArchive ia;    int count;    {        DataTree tree = new DataTree();        SerializationPerfTest.createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);        count = tree.getNodeCount();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        tree.serialize(oa, "test");        baos.flush();        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ia = BinaryInputArchive.getArchive(bais);    }    DataTree dserTree = new DataTree();    System.gc();    long start = System.nanoTime();    dserTree.deserialize(ia, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    assertEquals(count, dserTree.getNodeCount());    }
1
public void testSingleDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(1, 0, 20);}
0
public void testWideDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(2, 10000, 20);}
0
public void testDeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(400, 1, 20);}
0
public void test10Wide5DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 10, 20);}
0
public void test15Wide5DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 15, 20);}
0
public void test25Wide4DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 25, 20);}
0
public void test40Wide4DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 40, 20);}
0
public void test300Wide3DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(3, 300, 20);}
0
public void setUp() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");    System.setProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY, "true");    super.setUp();    zk = createClient();}
0
public void tearDown() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    System.clearProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY);    super.tearDown();    zk.close();}
0
public void testCreate() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
0
public void test353TTL() throws KeeperException, InterruptedException
{    DataTree dataTree = serverFactory.zkServer.getZKDatabase().dataTree;    long ephemeralOwner = EphemeralTypeEmulate353.ttlToEphemeralOwner(100);    dataTree.createNode("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, ephemeralOwner, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
0
public void testEphemeralOwner_emulationTTL()
{    assertThat(EphemeralType.get(-1), equalTo(EphemeralType.TTL));}
0
public void testEphemeralOwner_emulationContainer()
{    assertThat(EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER), equalTo(EphemeralType.CONTAINER));}
0
private ContainerManager newContainerManager(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
0
protected long getElapsed(DataNode node)
{    return fakeElapsed.get();}
0
public void setUp()
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");}
0
public void tearDown()
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);}
0
public void testTtls()
{    long[] ttls = { 100, 1, EphemeralType.TTL.maxValue() };    for (long ttl : ttls) {        long ephemeralOwner = EphemeralType.TTL.toEphemeralOwner(ttl);        assertEquals(EphemeralType.TTL, EphemeralType.get(ephemeralOwner));        assertEquals(ttl, EphemeralType.TTL.getValue(ephemeralOwner));    }    EphemeralType.validateTTL(CreateMode.PERSISTENT_WITH_TTL, 100);    EphemeralType.validateTTL(CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 100);    try {        EphemeralType.validateTTL(CreateMode.EPHEMERAL, 100);        fail("Should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
0
public void testContainerValue()
{    assertEquals(Long.MIN_VALUE, EphemeralType.CONTAINER_EPHEMERAL_OWNER);    assertEquals(EphemeralType.CONTAINER, EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER));}
0
public void testNonSpecial()
{    assertEquals(EphemeralType.VOID, EphemeralType.get(0));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(1));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(Long.MAX_VALUE));}
0
public void testServerIds()
{    for (int i = 0; i <= EphemeralType.MAX_EXTENDED_SERVER_ID; ++i) {        EphemeralType.validateServerId(i);    }    try {        EphemeralType.validateServerId(EphemeralType.MAX_EXTENDED_SERVER_ID + 1);        fail("Should have thrown RuntimeException");    } catch (RuntimeException e) {        }}
0
public void testEphemeralOwner_extendedFeature_TTL()
{            assertThat(EphemeralType.get(0xff00000000000000L), equalTo(EphemeralType.TTL));}
0
public void testEphemeralOwner_extendedFeature_extendedTypeUnsupported()
{            EphemeralType.get(0xff00010000000000L);}
0
public void setUp() throws KeeperException.NoNodeException, IOException
{    testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.ALL, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret")), new ACL(ZooDefs.Perms.READ, new Id("world", "anyone"))));    ZooKeeperServer zks = new ZooKeeperServer();    ZKDatabase db = mock(ZKDatabase.class);    String testPath = "/testPath";    when(db.getNode(eq(testPath))).thenReturn(new DataNode());    when(db.getACL(eq(testPath), any(Stat.class))).thenReturn(testACLs);    when(db.aclForNode(any(DataNode.class))).thenReturn(testACLs);    zks.setZKDatabase(db);    processor = new FinalRequestProcessor(zks);    cnxn = mock(ServerCnxn.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) {            replyHeaders[0] = invocationOnMock.getArgument(0);            responseRecord[0] = invocationOnMock.getArgument(1);            return null;        }    }).when(cnxn).sendResponse(any(), any(), anyString());    GetACLRequest getACLRequest = new GetACLRequest();    getACLRequest.setPath(testPath);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    getACLRequest.serialize(boa, "request");    baos.close();    bb = ByteBuffer.wrap(baos.toByteArray());}
0
public Object answer(InvocationOnMock invocationOnMock)
{    replyHeaders[0] = invocationOnMock.getArgument(0);    responseRecord[0] = invocationOnMock.getArgument(1);    return null;}
0
public void testACLDigestHashHiding_NoAuth_WorldCanRead()
{            Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertMasked(true);}
0
public void testACLDigestHashHiding_NoAuth_NoWorld()
{        testACLs.remove(2);        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertThat(KeeperException.Code.get(replyHeaders[0].getErr()), equalTo(KeeperException.Code.NOAUTH));}
0
public void testACLDigestHashHiding_UserCanRead()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "otheruser:somesecrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(true);}
0
public void testACLDigestHashHiding_UserCanAll()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "user:secrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
0
public void testACLDigestHashHiding_AdminUser()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
0
public void testACLDigestHashHiding_OnlyAdmin()
{        testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret"))));    List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(2));        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));}
0
private void assertMasked(boolean masked)
{    assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(3));        assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getScheme(), equalTo("world"));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getId(), equalTo("anyone"));        assertThat("Original ACL list has been modified", testACLs.get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Original ACL list has been modified", testACLs.get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getId(), equalTo("adminuser:adminsecret"));    assertThat("Original ACL list has been modified", testACLs.get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getScheme(), equalTo("world"));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getId(), equalTo("anyone"));}
0
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    }}
1
public void shutdown()
{    main.shutdown();}
0
public void shutdown()
{    super.shutdown();}
0
public void testInvalidSnapCount() throws Exception
{    final int CLIENT_PORT = 3181;    MainThread main = new MainThread(CLIENT_PORT);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    assertEquals(SyncRequestProcessor.getSnapCount(), 2);    main.shutdown();}
0
public void process(WatchedEvent event)
{}
0
public void testInvalidSnapshot() throws Exception
{    ZooKeeper zk = createClient();    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    NIOServerCnxnFactory factory = (NIOServerCnxnFactory) serverFactory;    stopServer();        File snapFile = factory.zkServer.getTxnLogFactory().findMostRecentSnapshot();        RandomAccessFile raf = new RandomAccessFile(snapFile, "rws");    raf.setLength(3);    raf.close();        startServer();        zk = createClient();    try {        assertTrue("the node should exist", (zk.exists("/invalidsnap-1999", false) != null));    } finally {        zk.close();    }}
1
public void initCounter()
{    testCounterSet = new AvgMinMaxCounterSet("test");}
0
private void addDataPoints()
{    testCounterSet.add("key1", 0);    testCounterSet.add("key1", 1);    testCounterSet.add("key2", 2);    testCounterSet.add("key2", 3);    testCounterSet.add("key2", 4);    testCounterSet.add("key2", 5);}
0
public void testReset()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));}
0
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0.5", 0.5D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =1", 1L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =2", 2L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =1", 1L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =3.5", 3.5, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 2L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 5L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 4L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 14L, values.get("sum_key2_test"));}
0
public void initCounter()
{    testCounterSet = new AvgMinMaxPercentileCounterSet("test");}
0
private void addDataPoints()
{    for (int i = 0; i < 1000; i++) {        testCounterSet.add("key1", i);    }    for (int i = 1000; i < 2000; i++) {        testCounterSet.add("key2", i);    }}
0
public void testReset()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=0", 0L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=0", 0L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=0", 0L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=0", 0L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=0", 0L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=0", 0L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=0", 0L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=0", 0L, values.get("p999_key2_test"));}
0
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 18 values in the set", 18, values.size());    assertEquals("avg_key1_test should =499.5", 999D / 2, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =999", 999L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =1000", 1000L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =999*500", 999 * 500L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=500", 500L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=950", 950L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=990", 990L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=999", 999L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =3.5", 1000 + 999D / 2, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 1000L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 1999L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 1000L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 2999 * 500L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=1500", 1500L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=1950", 1950L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=1990", 1990L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=1999", 1999L, values.get("p999_key2_test"));}
0
public void initCounter()
{    testCounter = new AvgMinMaxPercentileCounter("test");}
0
private void addDataPoints()
{    for (int i = 0; i < 1000; i++) {        testCounter.add(i);    }}
0
public void testReset()
{    addDataPoints();    testCounter.reset();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=0", 0D, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=0", 0L, values.get("max_test"));    assertEquals("should have cnt=0", 0L, values.get("cnt_test"));    assertEquals("should have sum=0", 0L, values.get("sum_test"));    assertEquals("should have p50=0", 0L, values.get("p50_test"));    assertEquals("should have p95=0", 0L, values.get("p95_test"));    assertEquals("should have p99=0", 0L, values.get("p99_test"));    assertEquals("should have p999=0", 0L, values.get("p999_test"));}
0
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=499.5", 999D / 2, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=999", 999L, values.get("max_test"));    assertEquals("should have cnt=1000", 1000L, values.get("cnt_test"));    assertEquals("should have sum=999*500", 999 * 500L, values.get("sum_test"));    assertEquals("should have p50=500", 500L, values.get("p50_test"));    assertEquals("should have p95=950", 950L, values.get("p95_test"));    assertEquals("should have p99=990", 990L, values.get("p99_test"));    assertEquals("should have p999=999", 999L, values.get("p999_test"));}
0
public void doIO(SelectionKey k) throws InterruptedException
{    super.doIO(k);}
0
protected boolean isSocketOpen()
{    return true;}
0
public boolean addInterestOpsUpdateRequest(SelectionKey sk)
{    return super.addInterestOpsUpdateRequest(sk);}
0
 int getSessionTimeout()
{    return 0;}
0
public void close(DisconnectReason reason)
{}
0
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
0
public void sendCloseSession()
{}
0
public void process(WatchedEvent event)
{}
0
public long getSessionId()
{    return 0;}
0
 void setSessionId(long sessionId)
{}
0
public boolean isSecure()
{    return secure;}
0
public Certificate[] getClientCertificateChain()
{    return clientChain;}
0
public void setClientCertificateChain(Certificate[] chain)
{    clientChain = chain;}
0
 void sendBuffer(ByteBuffer... closeConn)
{}
0
 void enableRecv()
{}
0
 void disableRecv(boolean waitDisableRecv)
{}
0
 void setSessionTimeout(int sessionTimeout)
{}
0
protected ServerStats serverStats()
{    return null;}
0
public long getOutstandingRequests()
{    return 0;}
0
public InetSocketAddress getRemoteSocketAddress()
{    return null;}
0
public int getInterestOps()
{    return 0;}
0
public void setUp() throws Exception
{    localSessionsEnabled = true;    localSessionsUpgradingEnabled = true;    super.setUp();}
0
public void ephemeralCreateMultiOpTest() throws KeeperException, InterruptedException, IOException
{    final ZooKeeper zk = createClient();    String data = "test";    String path = "/ephemeralcreatemultiop";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    UpgradeableSessionTracker sessionTracker = (UpgradeableSessionTracker) server.getSessionTracker();    assertFalse("session already global", sessionTracker.isGlobalSession(zk.getSessionId()));    List<OpResult> multi = null;    try {        multi = zk.multi(Arrays.asList(Op.setData(path, data.getBytes(), 0), Op.create(path + "/e", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL), Op.create(path + "/p", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(path + "/q", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));    } catch (KeeperException.SessionExpiredException e) {                fail("received session expired for a session promotion in a multi-op");    }    assertNotNull(multi);    assertEquals(4, multi.size());    assertEquals(data, new String(zk.getData(path + "/e", false, null)));    assertEquals(data, new String(zk.getData(path + "/p", false, null)));    assertEquals(data, new String(zk.getData(path + "/q", false, null)));    assertTrue("session not promoted", sessionTracker.isGlobalSession(zk.getSessionId()));}
0
public void directCheckUpgradeSessionTest() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    String path = "/directcheckupgradesession";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    Request readRequest = makeGetDataRequest(path, zk.getSessionId());    Request createRequest = makeCreateRequest(path + "/e", zk.getSessionId());    assertNull("tried to upgrade on a read", server.checkUpgradeSession(readRequest));    assertNotNull("failed to upgrade on a create", server.checkUpgradeSession(createRequest));    assertNull("tried to upgrade after successful promotion", server.checkUpgradeSession(createRequest));}
0
private Request makeGetDataRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest(path, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.getData, bb, new ArrayList<Id>());}
0
private Request makeCreateRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
0
private QuorumZooKeeperServer getConnectedServer(long sessionId)
{    for (QuorumPeer peer : getPeerList()) {        if (peer.getActiveServer().getSessionTracker().isTrackingSession(sessionId)) {            return (QuorumZooKeeperServer) peer.getActiveServer();        }    }    return null;}
0
public void testRebind() throws Exception
{    InetSocketAddress addr = new InetSocketAddress(PortAssignment.unique());    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(addr);        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
0
public void testRebindIPv4IPv6() throws Exception
{    int randomPort = PortAssignment.unique();    InetSocketAddress addr = new InetSocketAddress("0.0.0.0", randomPort);    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(new InetSocketAddress("[0:0:0:0:0:0:0:0]", randomPort));        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
0
public void setUp() throws Exception
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    NettyServerCnxnFactory.setTestAllocator(TestByteBufAllocator.getInstance());    super.maxCnxns = 1;    super.exceptionOnFailedConnect = true;    super.setUp();}
0
public void tearDown() throws Exception
{    super.tearDown();    NettyServerCnxnFactory.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
0
public void testSendCloseSession() throws Exception
{    assertTrue("Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    final ZooKeeper zk = createClient();    final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();    final String path = "/a";    try {                zk.create(path, "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                assertNotNull("Didn't create znode:" + path, zk.exists(path, true));        assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());        Iterable<ServerCnxn> connections = serverFactory.getConnections();        assertEquals("Mismatch in number of live connections!", 1, serverFactory.getNumAliveConnections());        for (ServerCnxn serverCnxn : connections) {            serverCnxn.sendCloseSession();        }                int timeout = 0;        while (serverFactory.getNumAliveConnections() != 0) {            Thread.sleep(1000);            timeout += 1000;            if (timeout > CONNECTION_TIMEOUT) {                fail("The number of live connections should be 0");            }        }                assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());    } finally {        zk.close();    }}
1
public void testMaxConnectionPerIpSurpased() throws Exception
{    assertTrue("Did not instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    try (final ZooKeeper zk1 = createClient();        final ZooKeeper zk2 = createClient()) {    }}
0
public void testClientResponseStatsUpdate() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
0
public void testServerSideThrottling() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.getChannel().read();                }            }, 1, TimeUnit.SECONDS);                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);                for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
0
public void run()
{    nettyCnxn.getChannel().read();}
0
public void run()
{    nettyCnxn.enableRecv();}
0
public void run()
{    nettyCnxn.enableRecv();}
0
public void testEnableDisableThrottling_secure_random() throws Exception
{    runEnableDisableThrottling(true, true);}
0
public void testEnableDisableThrottling_secure_sequentially() throws Exception
{    runEnableDisableThrottling(true, false);}
0
public void testEnableDisableThrottling_nonSecure_random() throws Exception
{    runEnableDisableThrottling(false, true);}
0
public void testEnableDisableThrottling_nonSecure_sequentially() throws Exception
{    runEnableDisableThrottling(false, false);}
0
private void runEnableDisableThrottling(boolean secure, boolean randomDisableEnable) throws Exception
{    ClientX509Util x509Util = null;    if (secure) {        x509Util = SSLAuthTest.setUpSecure();    }    try {        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;        factory.setAdvancedFlowControlEnabled(true);        if (secure) {            factory.setSecure(true);        }        final String path = "/testEnableDisableThrottling";        try (ZooKeeper zk = createClient()) {            zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                        AtomicBoolean stopped = new AtomicBoolean(false);            Random random = new Random();            Thread enableDisableThread = null;            if (randomDisableEnable) {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                boolean shouldDisableEnable = random.nextBoolean();                                if (shouldDisableEnable) {                                    cnxn.disableRecv();                                } else {                                    cnxn.enableRecv();                                }                            }                            try {                                Thread.sleep(10);                            } catch (InterruptedException e) {                            /* ignore */                            }                        }                                                for (final ServerCnxn cnxn : serverFactory.cnxns) {                            cnxn.enableRecv();                        }                    }                };            } else {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                try {                                    cnxn.disableRecv();                                    Thread.sleep(10);                                    cnxn.enableRecv();                                    Thread.sleep(10);                                } catch (InterruptedException e) {                                /* ignore */                                }                            }                        }                    }                };            }            enableDisableThread.start();                                    int totalRequestsNum = 100000;            AtomicInteger successResponse = new AtomicInteger();            CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);            Thread clientThread = new Thread() {                @Override                public void run() {                    int requestIssued = 0;                    while (requestIssued++ < totalRequestsNum) {                        zk.getData(path, null, new DataCallback() {                            @Override                            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                                if (rc == 0) {                                    successResponse.addAndGet(1);                                } else {                                                                    }                                responseReceivedLatch.countDown();                            }                        }, null);                    }                }            };            clientThread.start();                                    assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));                        stopped.set(true);            enableDisableThread.join();                                                Thread.sleep(1000);            assertEquals(successResponse.get(), totalRequestsNum);        }    } finally {        if (secure) {            SSLAuthTest.clearSecureSetting(x509Util);        }    }}
1
public void run()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            boolean shouldDisableEnable = random.nextBoolean();            if (shouldDisableEnable) {                cnxn.disableRecv();            } else {                cnxn.enableRecv();            }        }        try {            Thread.sleep(10);        } catch (InterruptedException e) {        /* ignore */        }    }        for (final ServerCnxn cnxn : serverFactory.cnxns) {        cnxn.enableRecv();    }}
0
public void run()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            try {                cnxn.disableRecv();                Thread.sleep(10);                cnxn.enableRecv();                Thread.sleep(10);            } catch (InterruptedException e) {            /* ignore */            }        }    }}
0
public void run()
{    int requestIssued = 0;    while (requestIssued++ < totalRequestsNum) {        zk.getData(path, null, new DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                if (rc == 0) {                    successResponse.addAndGet(1);                } else {                                    }                responseReceivedLatch.countDown();            }        }, null);    }}
1
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        successResponse.addAndGet(1);    } else {            }    responseReceivedLatch.countDown();}
1
public void setUp() throws IOException
{    listenAddress = new InetSocketAddress(PortAssignment.unique());    factory = new NIOServerCnxnFactory();    factory.configure(listenAddress, 100);}
0
public void tearDown()
{    if (factory != null) {        factory.shutdown();    }}
0
public void testStartupWithoutStart_SocketAlreadyBound() throws IOException
{    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
0
public void testStartupWithStart_SocketAlreadyBound() throws IOException
{    factory.start();    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
0
public void testShutdownWithoutStart_SocketReleased() throws IOException
{    factory.shutdown();    factory = null;    ServerSocket ss = new ServerSocket(listenAddress.getPort());    ss.close();}
0
public void testOperationsAfterCnxnClose() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    final String path = "/a";    try {                zk.create(path, "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertNotNull("Didn't create znode:" + path, zk.exists(path, false));                        assertTrue("Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!", serverFactory instanceof NIOServerCnxnFactory);        Iterable<ServerCnxn> connections = serverFactory.getConnections();        for (ServerCnxn serverCnxn : connections) {            serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);            try {                serverCnxn.toString();            } catch (Exception e) {                                fail("Shouldn't throw exception while " + "getting connection details!");            }        }    } finally {        zk.close();    }}
1
public void testClientResponseStatsUpdate() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater then zero after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));    }}
0
public void setUp()
{    ZooKeeperServer.setDigestEnabled(true);}
0
public void tearDown()
{    ZooKeeperServer.setDigestEnabled(false);}
0
public void testOperations()
{    NodeHashMapImpl nodes = new NodeHashMapImpl(new DigestCalculator());    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p1 = "p1";    DataNode n1 = new DataNode(p1.getBytes(), 0L, new StatPersisted());    nodes.put(p1, n1);    assertEquals(n1, nodes.get(p1));    assertNotEquals(0L, nodes.getDigest());    assertEquals(1, nodes.size());        String p2 = "p2";    nodes.put(p2, new DataNode(p2.getBytes(), 0L, new StatPersisted()));    Set<Map.Entry<String, DataNode>> entries = nodes.entrySet();    assertEquals(2, entries.size());        nodes.remove(p1);    assertEquals(1, nodes.size());    nodes.remove(p2);    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p3 = "p3";    DataNode n3 = new DataNode(p3.getBytes(), 0L, new StatPersisted());    nodes.put(p3, n3);    long preChangeDigest = nodes.getDigest();    assertNotEquals(0L, preChangeDigest);    nodes.preChange(p3, n3);    assertEquals(0L, nodes.getDigest());    n3.stat.setMzxid(1);    n3.stat.setMtime(1);    n3.stat.setVersion(1);    nodes.postChange(p3, n3);    long postChangeDigest = nodes.getDigest();    assertNotEquals(0, postChangeDigest);    assertNotEquals(preChangeDigest, postChangeDigest);}
0
public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{        assertTrue(snapShot.createNewFile());    throw new IOException("Created empty snapshot file from " + "MockFileSnap::serialize()");}
0
public void testNoEmptySnapshot() throws Exception
{    File tmpFile = File.createTempFile("empty-snapshot-test", ".junit", new File(System.getProperty("build.test.dir", "build")));    File tmpDataDir = new File(tmpFile + ".dir");    assertFalse(tmpDataDir.exists());    assertTrue(tmpDataDir.mkdirs());    FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDataDir, tmpDataDir);    snapLog.snapLog = new MockFileSnap(snapLog.dataDir);    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    DataTree tree = new DataTree();    tree.createNode("/empty-snapshot-test-1", "data".getBytes(), null, -1, -1, 1, 1);    try {        snapLog.save(tree, new ConcurrentHashMap<>(), false);        fail("Should have thrown an IOException");    } catch (IOException e) {        }    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    snapLog.snapLog = new FileSnap(snapLog.dataDir);    snapLog.save(tree, new ConcurrentHashMap<>(), false);    assertEquals(1, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());}
0
public void testInvalidPreallocSize()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 0));    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, -1));}
0
public void testCalculateFileSizeWithPaddingWhenNotToCurrentSize()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(5 * KB, 10 * KB, 10 * KB));}
0
public void testCalculateFileSizeWithPaddingWhenCloseToCurrentSize()
{    assertEquals("file should be padded an additional 10 KB", 20 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 10 * KB));}
0
public void testFileSizeGreaterThanPosition()
{    assertEquals("file should be padded to 40 KB", 40 * KB, FilePadding.calculateFileSizeWithPadding(31 * KB, 10 * KB, 10 * KB));}
0
public void testPreAllocSizeSmallerThanTxnData() throws IOException
{    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);        final int preAllocSize = 500 * KB;    FilePadding.setPreallocSize(preAllocSize);            byte[] data = new byte[2 * preAllocSize];    Arrays.fill(data, (byte) 0xff);            fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData1", data, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.append(new TxnHeader(1, 1, 2, 2, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData2", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.close();        FileTxnLog.FileTxnIterator fileTxnIterator = new FileTxnLog.FileTxnIterator(logDir, 0);        CreateTxn createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), data));        fileTxnIterator.next();    createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), new byte[] {}));}
0
public void testSetPreallocSize()
{    long customPreallocSize = 10101;    FileTxnLog.setPreallocSize(customPreallocSize);    assertThat(FilePadding.getPreAllocSize(), is(equalTo(customPreallocSize)));}
0
public void testSyncThresholdExceedCount() throws IOException
{            java.lang.System.setProperty(FileTxnLog.ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY, "-1");    ServerStats.Provider providerMock = mock(ServerStats.Provider.class);    ServerStats serverStats = new ServerStats(providerMock);    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);    fileTxnLog.setServerStats(serverStats);        assertEquals(0L, serverStats.getFsyncThresholdExceedCount());        for (int i = 0; i < 50; i++) {        fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testFsyncThresholdCountIncreased", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));                fileTxnLog.commit();                assertEquals((long) i + 1, serverStats.getFsyncThresholdExceedCount());    }}
0
public void testGetCurrentLogSize() throws Exception
{    FileTxnLog.setTxnLogSizeLimit(-1);    File tmpDir = ClientBase.createTmpDir();    FileTxnLog log = new FileTxnLog(tmpDir);    FileTxnLog.setPreallocSize(PREALLOCATE);    CreateRequest record = new CreateRequest(null, new byte[NODE_SIZE], ZooDefs.Ids.OPEN_ACL_UNSAFE, 0);    int zxid = 1;    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);            }    log.commit();        assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);            }    log.commit();        assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);}
1
public void testLogSizeLimit() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();                FileTxnLog.setPreallocSize(PREALLOCATE);    FileTxnLog.setTxnLogSizeLimit(LOG_SIZE_LIMIT);    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        HashSet<Long> zxids = new HashSet<>();    byte[] bytes = new byte[NODE_SIZE];    Random random = new Random();    random.nextBytes(bytes);        long txnCount = LOG_SIZE_LIMIT / NODE_SIZE / 2 * 5;        try {        for (long i = 0; i < txnCount; i++) {            Stat stat = new Stat();            zk.create("/node-" + i, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/node-" + i, null, stat);            zxids.add(stat.getCzxid());        }    } finally {        zk.close();    }        f.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] txnLogs = FileTxnLog.getLogFiles(logDir.listFiles(), 0);    assertEquals("Unexpected number of logs", 3, txnLogs.length);        long threshold = LOG_SIZE_LIMIT + NODE_SIZE;        assertTrue("Exceed log size limit: " + txnLogs[0].length(), threshold > txnLogs[0].length());        assertTrue("Exceed log size limit " + txnLogs[1].length(), threshold > txnLogs[1].length());        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();    for (long i = 0; i < txnCount; i++) {        Stat stat = new Stat();        byte[] data = db.getData("/node-" + i, stat, null);        assertArrayEquals("Missmatch data", bytes, data);        assertTrue("Unknown zxid ", zxids.contains(stat.getMzxid()));    }}
1
public void process(WatchedEvent e)
{        allCreatedLatch.countDown();}
1
public void testFileTxnSnapLogMetrics() throws Exception
{    SyncRequestProcessor.setSnapCount(100);    QuorumUtil util = new QuorumUtil(1);    util.startAll();    allCreatedLatch = new CountDownLatch(1);    byte[] data = new byte[500];        ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    for (int i = 0; i < 150; i++) {        zk.create("/path" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    if (null == zk.exists("/path149", new MockWatcher())) {        allCreatedLatch.await();    }    ServerMetrics.getMetrics().resetAll();    int leader = util.getLeaderServer();        util.shutdown(leader);    util.start(leader);    Map<String, Object> values = MetricsUtils.currentServerMetrics();        assertEquals(1L, values.get("cnt_startup_txns_loaded"));    assertThat((long) values.get("max_startup_txns_loaded"), greaterThan(0L));    assertEquals(1L, values.get("cnt_startup_txns_load_time"));    assertThat((long) values.get("max_startup_txns_load_time"), greaterThanOrEqualTo(0L));    assertEquals(1L, values.get("cnt_startup_snap_load_time"));    assertThat((long) values.get("max_startup_snap_load_time"), greaterThan(0L));    util.shutdownAll();}
1
public void setUp() throws Exception
{    tmpDir = ClientBase.createEmptyTestDir();    logDir = new File(tmpDir, "logdir");    snapDir = new File(tmpDir, "snapdir");}
0
public void tearDown() throws Exception
{    if (tmpDir != null) {        TestUtils.deleteFileRecursively(tmpDir);    }    this.tmpDir = null;    this.logDir = null;    this.snapDir = null;    this.logVersionDir = null;    this.snapVersionDir = null;}
0
private File createVersionDir(File parentDir)
{    File versionDir = new File(parentDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    versionDir.mkdirs();    return versionDir;}
0
private void createLogFile(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeLogName(zxid));    file.createNewFile();}
0
private void createSnapshotFile(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeSnapshotName(zxid));    file.createNewFile();}
0
private void twoDirSetupWithCorrectFiles() throws IOException
{    logVersionDir = createVersionDir(logDir);    snapVersionDir = createVersionDir(snapDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);        createSnapshotFile(snapVersionDir, 1);    createSnapshotFile(snapVersionDir, 2);}
0
private void singleDirSetupWithCorrectFiles() throws IOException
{    logVersionDir = createVersionDir(logDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);    createSnapshotFile(logVersionDir, 1);    createSnapshotFile(logVersionDir, 2);}
0
private FileTxnSnapLog createFileTxnSnapLogWithNoAutoCreateDataDir(File logDir, File snapDir) throws IOException
{    return createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");}
0
private FileTxnSnapLog createFileTxnSnapLogWithAutoCreateDataDir(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDirValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, priorAutocreateDirValue);        }    }    return fileTxnSnapLog;}
0
private FileTxnSnapLog createFileTxnSnapLogWithAutoCreateDB(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDBValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDBValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, priorAutocreateDBValue);        }    }    return fileTxnSnapLog;}
0
public void testWithAutoCreateDataDir() throws IOException
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    assertTrue(logDir.exists());    assertTrue(snapDir.exists());    assertTrue(fileTxnSnapLog.getDataDir().exists());    assertTrue(fileTxnSnapLog.getSnapDir().exists());}
0
public void testWithoutAutoCreateDataDir() throws Exception
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    try {        createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");    } catch (FileTxnSnapLog.DatadirException e) {        assertFalse(logDir.exists());        assertFalse(snapDir.exists());                throw e;    }    fail("Expected exception from FileTxnSnapLog");}
0
private void attemptAutoCreateDB(File dataDir, File snapDir, Map<Long, Integer> sessions, String autoCreateValue, long expectedValue) throws IOException
{    sessions.clear();    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDB(dataDir, snapDir, autoCreateValue);    long zxid = fileTxnSnapLog.restore(new DataTree(), sessions, new FileTxnSnapLog.PlayBackListener() {        @Override        public void onTxnLoaded(TxnHeader hdr, Record rec) {                }    });    assertEquals("unexpected zxid", expectedValue, zxid);}
0
public void onTxnLoaded(TxnHeader hdr, Record rec)
{}
0
public void testAutoCreateDB() throws IOException
{    assertTrue("cannot create log directory", logDir.mkdir());    assertTrue("cannot create snapshot directory", snapDir.mkdir());    File initFile = new File(logDir, "initialize");    assertFalse("initialize file already exists", initFile.exists());    Map<Long, Integer> sessions = new ConcurrentHashMap<>();    attemptAutoCreateDB(logDir, snapDir, sessions, "false", -1L);    attemptAutoCreateDB(logDir, snapDir, sessions, "true", 0L);    assertTrue("cannot create initialize file", initFile.createNewFile());    attemptAutoCreateDB(logDir, snapDir, sessions, "false", 0L);}
0
public void testGetTxnLogSyncElapsedTime() throws IOException
{    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        fileTxnSnapLog.append(req);        fileTxnSnapLog.commit();        long syncElapsedTime = fileTxnSnapLog.getTxnLogElapsedSyncTime();        assertNotEquals("Did not update syncElapsedTime!", -1L, syncElapsedTime);    } finally {        fileTxnSnapLog.close();    }}
0
public void testDirCheckWithCorrectFiles() throws IOException
{    twoDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
0
public void testDirCheckWithSingleDirSetup() throws IOException
{    singleDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, logDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
0
public void testDirCheckWithSnapFilesInLogDir() throws IOException
{    twoDirSetupWithCorrectFiles();        createSnapshotFile(logVersionDir, 3);    createSnapshotFile(logVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
0
public void testDirCheckWithLogFilesInSnapDir() throws IOException
{    twoDirSetupWithCorrectFiles();        createLogFile(snapVersionDir, 3);    createLogFile(snapVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
0
public void testACLCreatedDuringFuzzySnapshotSync() throws IOException
{    DataTree leaderDataTree = new DataTree();        File file = File.createTempFile("snapshot", "zk");    FileOutputStream os = new FileOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    leaderDataTree.serializeAcls(oa);        TxnHeader hdr1 = new TxnHeader(1, 2, 2, 2, ZooDefs.OpCode.create);    Record txn1 = new CreateTxn("/a1", "foo".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, false, -1);    leaderDataTree.processTxn(hdr1, txn1);        leaderDataTree.serializeNodes(oa);    os.close();        FileInputStream is = new FileInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    DataTree followerDataTree = new DataTree();    followerDataTree.deserialize(ia, "tree");    followerDataTree.processTxn(hdr1, txn1);    DataNode a1 = leaderDataTree.getNode("/a1");    assertNotNull(a1);    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, leaderDataTree.getACL(a1));    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, followerDataTree.getACL(a1));}
0
public void tearDown()
{    System.clearProperty(SnapStream.ZOOKEEPER_SHAPSHOT_STREAM_MODE);    SnapStream.setStreamMode(StreamMode.DEFAULT_MODE);}
0
public void testStreamMode()
{    assertEquals(StreamMode.CHECKED.getName(), "");    assertEquals(StreamMode.CHECKED.getFileExtension(), "");    assertEquals(StreamMode.CHECKED, StreamMode.fromString("name"));    assertEquals(StreamMode.GZIP.getName(), "gz");    assertEquals(StreamMode.GZIP.getFileExtension(), ".gz");    assertEquals(StreamMode.GZIP, StreamMode.fromString("gz"));    assertEquals(StreamMode.SNAPPY.getName(), "snappy");    assertEquals(StreamMode.SNAPPY.getFileExtension(), ".snappy");    assertEquals(StreamMode.SNAPPY, StreamMode.fromString("snappy"));}
0
public void testGetStreamMode()
{    assertEquals("expected to return un-compressed stream", StreamMode.CHECKED, SnapStream.getStreamMode("snapshot.180000e3a2"));    assertEquals("expected to return snappy stream", StreamMode.SNAPPY, SnapStream.getStreamMode("snapshot.180000e3a2.snappy"));    assertEquals("expected to return gzip stream", StreamMode.GZIP, SnapStream.getStreamMode("snapshot.180000e3a2.gz"));}
0
public void testSerializeDeserializeWithChecked() throws IOException
{    testSerializeDeserialize(StreamMode.CHECKED, "");}
0
public void testSerializeDeserializeWithSNAPPY() throws IOException
{    testSerializeDeserialize(StreamMode.SNAPPY, ".snappy");}
0
public void testSerializeDeserializeWithGZIP() throws IOException
{    testSerializeDeserialize(StreamMode.GZIP, ".gz");}
0
private void testSerializeDeserialize(StreamMode mode, String fileSuffix) throws IOException
{    SnapStream.setStreamMode(mode);        File tmpDir = createTmpDir();    File file = new File(tmpDir, "snapshot.180000e3a2" + fileSuffix);    CheckedOutputStream os = SnapStream.getOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    FileHeader header = new FileHeader(FileSnap.SNAP_MAGIC, 2, 1);    header.serialize(oa, "fileheader");    SnapStream.sealStream(os, oa);    os.flush();    os.close();    assertTrue(SnapStream.isValidSnapshot(file));        CheckedInputStream is = SnapStream.getInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    FileHeader restoredHeader = new FileHeader();    restoredHeader.deserialize(ia, "fileheader");    assertEquals("magic not the same", restoredHeader, header);    SnapStream.checkSealIntegrity(is, ia);}
0
private void checkInvalidSnapshot(String filename) throws IOException
{        SnapStream.setStreamMode(StreamMode.CHECKED);        File tmpDir = createTmpDir();    File file = new File(tmpDir, filename);    OutputStream os = SnapStream.getOutputStream(file);    os.write(1);    os.flush();    os.close();    assertFalse(SnapStream.isValidSnapshot(file));}
0
public void testInvalidSnapshot() throws IOException
{    assertFalse(SnapStream.isValidSnapshot(null));    checkInvalidSnapshot("snapshot.180000e3a2");    checkInvalidSnapshot("snapshot.180000e3a2.gz");    checkInvalidSnapshot("snapshot.180000e3a2.snappy");}
0
public void setUp() throws IOException
{    System.setOut(new PrintStream(outContent));    System.setErr(new PrintStream(errContent));    File snapDir = new File(testData, "invalidsnap");    mySnapDir = ClientBase.createTmpDir();    FileUtils.copyDirectory(snapDir, mySnapDir);}
0
public void tearDown() throws IOException
{    System.setOut(System.out);    System.setErr(System.err);    mySnapDir.setWritable(true);    FileUtils.deleteDirectory(mySnapDir);}
0
public void testDumpMode() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);}
0
public void testInitMissingFile() throws FileNotFoundException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File("this_file_should_not_exists");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);}
0
public void testInitWithRecoveryFileExists() throws IOException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    File recoveryFile = new File(new File(mySnapDir, "version-2"), "log.274.fixed");    recoveryFile.createNewFile();    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);}
0
public void testDumpWithCrcError() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    Pattern p = Pattern.compile("^CRC ERROR.*session 0x8061fac5ddeb0000 cxid 0x0 zxid 0x8800000002 createSession 30000$", Pattern.MULTILINE);    Matcher m = p.matcher(output);    assertTrue("Output doesn't indicate CRC error for the broken session id: " + output, m.find());}
0
public void testRecoveryFixBrokenFile() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    assertThat(output, containsString("CRC FIXED"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
0
public void testRecoveryInteractiveMode() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), false);        lt.dump(new Scanner("y\n"));        String output = outContent.toString();    assertThat(output, containsString("CRC ERROR"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
0
public void setup()
{    System.setProperty(ZooKeeperServer.SKIP_ACL, "true");    zks = spy(new ZooKeeperServer());    zks.sessionTracker = mock(SessionTracker.class);    ZKDatabase db = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(db);    DataNode node = new DataNode(new byte[1], null, mock(StatPersisted.class));    when(db.getNode(anyString())).thenReturn(node);    Set<String> ephemerals = new HashSet<>();    ephemerals.add("/crystalmountain");    ephemerals.add("/stevenspass");    when(db.getEphemerals(anyLong())).thenReturn(ephemerals);    nextProcessor = mock(RequestProcessor.class);    ServerMetrics.getMetrics().resetAll();}
0
public void tearDown() throws Exception
{    System.clearProperty(ZooKeeperServer.SKIP_ACL);}
0
private Request createRequest(Record record, int opCode) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();    return new Request(null, 1L, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), null);}
0
private Request createRequest(String path, int opCode) throws IOException
{    Record record;    switch(opCode) {        case ZooDefs.OpCode.setData:            record = new SetDataRequest(path, new byte[0], -1);            break;        case ZooDefs.OpCode.delete:            record = new DeleteRequest(path, -1);            break;        default:            record = new DeleteRequest(path, -1);            break;    }    return createRequest(record, opCode);}
0
private Request createRequest(long sessionId, int opCode)
{    return new Request(null, sessionId, 0, opCode, null, null);}
0
public void testPrepRequestProcessorMetrics() throws Exception
{    CountDownLatch threeRequests = new CountDownLatch(3);    doAnswer(invocationOnMock -> {        threeRequests.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));    PrepRequestProcessor prepRequestProcessor = new PrepRequestProcessor(zks, nextProcessor);        prepRequestProcessor.processRequest(createRequest("/foo", ZooDefs.OpCode.setData));        prepRequestProcessor.processRequest(createRequest("/foo/bar", ZooDefs.OpCode.delete));        prepRequestProcessor.processRequest(createRequest(2, ZooDefs.OpCode.closeSession));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("prep_processor_request_queued"));        Thread.sleep(20);    prepRequestProcessor.start();    threeRequests.await(500, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_prep_processor_queue_size"));    assertThat((long) values.get("min_prep_processor_queue_time_ms"), greaterThan(20L));    assertEquals(3L, values.get("cnt_prep_processor_queue_time_ms"));    assertEquals(3L, values.get("cnt_prep_process_time"));    assertThat((long) values.get("max_prep_process_time"), greaterThan(0L));    assertEquals(1L, values.get("cnt_close_session_prep_time"));    assertThat((long) values.get("max_close_session_prep_time"), greaterThanOrEqualTo(0L));    assertEquals(5L, values.get("outstanding_changes_queued"));}
0
public void process(WatchedEvent e)
{    created.countDown();}
0
public void testOutstandingChangesRemoved() throws Exception
{        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ServerMetrics.getMetrics().resetAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    zk.create("/test", new byte[50], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    CountDownLatch created = new CountDownLatch(1);    zk.exists("/test", new SimpleWatcher(created));    created.await(200, TimeUnit.MILLISECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat((long) values.get("outstanding_changes_removed"), greaterThan(0L));    util.shutdownAll();}
0
public void setup() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    servcnxnf.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    zks.sessionTracker = new MySessionTracker();}
0
public void teardown() throws Exception
{    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }}
0
public void testPRequest() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Request foo = new Request(null, 1L, 1, OpCode.create, ByteBuffer.allocate(3), null);    processor.pRequest(foo);    assertEquals("Request should have marshalling error", new ErrorTxn(KeeperException.Code.MARSHALLINGERROR.intValue()), outcome.getTxn());    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
0
private Request createRequest(Record record, int opCode) throws IOException
{    return createRequest(record, opCode, 1L);}
0
private Request createRequest(Record record, int opCode, long sessionId) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();        List<Id> ids = Arrays.asList(Ids.ANYONE_ID_UNSAFE);    return new Request(null, sessionId, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), ids);}
0
private void process(List<Op> ops) throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Record record = new MultiOperationRecord(ops);    Request req = createRequest(record, OpCode.multi);    processor.pRequest(req);    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
0
public void testMultiOutstandingChange() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));    process(Arrays.asList(Op.setData("/foo", new byte[0], -1)));    ChangeRecord cr = zks.outstandingChangesForPath.get("/foo");    assertNotNull("Change record wasn't set", cr);    assertEquals("Record zxid wasn't set correctly", 1, cr.zxid);    process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");    assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);        process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");        assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);}
0
public void testMultiRollbackNoLastChange() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    zks.getZKDatabase().dataTree.createNode("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));                process(Arrays.asList(Op.setData("/foo", new byte[0], -1), Op.delete("/foo", -1)));        assertNull(zks.outstandingChangesForPath.get("/foo"));}
0
public void testCloseSessionTxn() throws Exception
{    boolean before = ZooKeeperServer.isCloseSessionTxnEnabled();    ZooKeeperServer.setCloseSessionTxnEnabled(true);    try {                long ephemeralOwner = 1;        DataTree dt = zks.getZKDatabase().dataTree;        dt.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);        dt.createNode("/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);                RequestHeader header = new RequestHeader();        header.setType(OpCode.closeSession);        final FinalRequestProcessor frq = new FinalRequestProcessor(zks);        final CountDownLatch latch = new CountDownLatch(1);        processor = new PrepRequestProcessor(zks, new RequestProcessor() {            @Override            public void processRequest(Request request) {                frq.processRequest(request);                latch.countDown();            }            @Override            public void shutdown() {                        }        });        processor.pRequest(createRequest(header, OpCode.closeSession, ephemeralOwner));        assertTrue(latch.await(3, TimeUnit.SECONDS));                assertEquals(null, dt.getNode("/foo"));        assertEquals(null, dt.getNode("/bar"));    } finally {        ZooKeeperServer.setCloseSessionTxnEnabled(before);    }}
0
public void processRequest(Request request)
{    frq.processRequest(request);    latch.countDown();}
0
public void shutdown()
{}
0
public void testInvalidPath() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    SetDataRequest record = new SetDataRequest("", new byte[0], -1);    Request req = createRequest(record, OpCode.setData);    processor.pRequest(req);    pLatch.await();    assertEquals(outcome.getHdr().getType(), OpCode.error);    assertEquals(outcome.getException().code(), KeeperException.Code.BADARGUMENTS);}
0
public void processRequest(Request request)
{        outcome = request;    pLatch.countDown();}
0
public void shutdown()
{}
0
public boolean trackSession(long id, int to)
{        return false;}
0
public boolean commitSession(long id, int to)
{        return false;}
0
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
0
public long createSession(int sessionTimeout)
{        return 0;}
0
public void dumpSessions(PrintWriter pwriter)
{}
0
public void removeSession(long sessionId)
{}
0
public int upgradeSession(long sessionId)
{        return 0;}
0
public void setOwner(long id, Object owner) throws SessionExpiredException
{}
0
public void shutdown()
{}
0
public boolean touchSession(long sessionId, int sessionTimeout)
{        return false;}
0
public void setSessionClosing(long sessionId)
{}
0
public boolean isTrackingSession(long sessionId)
{        return false;}
0
public void checkGlobalSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
0
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return new HashMap<Long, Set<Long>>();}
0
public long getLocalSessionCount()
{    return 0;}
0
public boolean isLocalSessionsEnabled()
{    return false;}
0
public void teardown()
{    if (null != tmpDir) {        ClientBase.recursiveDelete(tmpDir);    }}
0
public void testPurge() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.getTxnLogFactory().close();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> listLogs = snaplog.findNRecentSnapshots(4);    int numSnaps = 0;    for (File ff : listLogs) {        if (ff.getName().startsWith("snapshot")) {            numSnaps++;        }    }    assertTrue("exactly 3 snapshots ", (numSnaps == 3));    snaplog.close();    zks.shutdown();}
0
public void testPurgeWhenLogRollingInProgress() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(30);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    final ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    final CountDownLatch doPurge = new CountDownLatch(1);    final CountDownLatch purgeFinished = new CountDownLatch(1);    final AtomicBoolean opFailed = new AtomicBoolean(false);    new Thread() {        public void run() {            try {                doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);                PurgeTxnLog.purge(tmpDir, tmpDir, 3);            } catch (IOException ioe) {                                opFailed.set(true);            } catch (InterruptedException ie) {                                opFailed.set(true);            } finally {                purgeFinished.countDown();            }        }    }.start();    final int thCount = 3;    List<String> znodes = manyClientOps(zk, doPurge, thCount, "/invalidsnap");    assertTrue("Purging is not finished!", purgeFinished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    assertFalse("Purging failed!", opFailed.get());    for (String znode : znodes) {        try {            zk.getData(znode, false, null);        } catch (Exception ke) {                        fail("Unexpected exception when visiting znode!");        }    }    zk.close();    f.shutdown();    zks.shutdown();    zks.getTxnLogFactory().close();}
1
public void run()
{    try {        doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    } catch (IOException ioe) {                opFailed.set(true);    } catch (InterruptedException ie) {                opFailed.set(true);    } finally {        purgeFinished.countDown();    }}
1
public void testFindNRecentSnapshots() throws Exception
{        int nRecentSnap = 4;    int nRecentCount = 30;    int offset = 0;    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());        FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> foundSnaps = txnLog.findNRecentSnapshots(1);    assertEquals(0, foundSnaps.size());    List<File> expectedNRecentSnapFiles = new ArrayList<File>();    int counter = offset + (2 * nRecentCount);    for (int i = 0; i < nRecentCount; i++) {                File logFile = new File(version2 + "/log." + Long.toHexString(--counter));        assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());                File snapFile = new File(version2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());                if (i < nRecentSnap) {            expectedNRecentSnapFiles.add(snapFile);        }    }            List<File> nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentSnap);    assertEquals("exactly 4 snapshots ", 4, nRecentSnapFiles.size());    expectedNRecentSnapFiles.removeAll(nRecentSnapFiles);    assertEquals("Didn't get the recent snap files", 0, expectedNRecentSnapFiles.size());            nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentCount + 5);    assertEquals(nRecentCount, nRecentSnapFiles.size());    for (File f : nRecentSnapFiles) {        assertTrue("findNRecentSnapshots() returned a non-snapshot: " + f.getPath(), (Util.getZxidFromName(f.getName(), "snapshot") != -1));    }    txnLog.close();}
0
public void testSnapFilesGreaterThanToRetain() throws Exception
{    int nRecentCount = 4;    int fileAboveRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    List<File> snapsAboveRecentFiles = new ArrayList<File>();    List<File> logsAboveRecentFiles = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    createDataDirFiles(offset, fileAboveRecentCount, false, version2, snapsAboveRecentFiles, logsAboveRecentFiles);    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);    verifyFilesAfterPurge(snapsAboveRecentFiles, true);    verifyFilesAfterPurge(logsAboveRecentFiles, true);}
0
public void testSnapFilesEqualsToRetain() throws Exception
{    internalTestSnapFilesEqualsToRetain(false);}
0
public void testSnapFilesEqualsToRetainWithPrecedingLog() throws Exception
{    internalTestSnapFilesEqualsToRetain(true);}
0
public void internalTestSnapFilesEqualsToRetain(boolean testWithPrecedingLogFile) throws Exception
{    int nRecentCount = 3;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, nRecentCount, testWithPrecedingLogFile, version2, snaps, logs);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
0
public void testSnapFilesLessThanToRetain() throws Exception
{    int nRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
0
public void testPurgeTxnLogWithDataDir() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), dataDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep, dataDirVersion2.listFiles().length);        assertEquals(numberOfSnapFilesToKeep, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
0
public void testPurgeTxnLogWithoutDataDir() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataLogDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep *     2, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
0
public void testPurgeDoesNotDeleteOverlappingLogFile() throws Exception
{        final int SNAP_RETAIN_COUNT = 3;        final int NUM_ZNODES_PER_SNAPSHOT = 100;    /**     * Set a sufficiently high snapCount to ensure that we don't rollover the log.  Normally,     * the default value (100K at time of this writing) would ensure this, but we make that     * dependence explicit here to make the test future-proof.  Not rolling over the log is     * important for this test since we are testing retention of the one and only log file which     * predates each retained snapshot.     */    SyncRequestProcessor.setSnapCount(SNAP_RETAIN_COUNT * NUM_ZNODES_PER_SNAPSHOT * 10);        tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        int unique = 0;    try {        /**         * Create some znodes and take a snapshot.  Repeat this until we have SNAP_RETAIN_COUNT         * snapshots.  Do not rollover the log.         */        for (int snapshotCount = 0; snapshotCount < SNAP_RETAIN_COUNT; snapshotCount++) {            for (int i = 0; i < 100; i++, unique++) {                zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            }            zks.takeSnapshot();        }                for (int i = 0; i < 100; i++, unique++) {            zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, SNAP_RETAIN_COUNT);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    zk = ClientBase.createZKClient(HOSTPORT);    /**     * Verify that the last znode that was created above exists.  This znode's creation was     * captured by the transaction log which was created before any of the above     * SNAP_RETAIN_COUNT snapshots were created, but it's not captured in any of these     * snapshots.  So for it it exist, the (only) existing log file should not have been purged.     */    final String lastZnode = "/snap-" + (unique - 1);    final Stat stat = zk.exists(lastZnode, false);    assertNotNull("Last znode does not exist: " + lastZnode, stat);        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();}
0
private File createDataDirLogFile(File version_2, int Zxid) throws IOException
{    File logFile = new File(version_2 + "/log." + Long.toHexString(Zxid));    assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());    return logFile;}
0
private void createDataDirFiles(AtomicInteger offset, int limit, boolean createPrecedingLogFile, File version_2, List<File> snaps, List<File> logs) throws IOException
{    int counter = offset.get() + (2 * limit);    if (createPrecedingLogFile) {        counter++;    }    offset.set(counter);    for (int i = 0; i < limit; i++) {                logs.add(createDataDirLogFile(version_2, --counter));                File snapFile = new File(version_2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());        snaps.add(snapFile);    }    if (createPrecedingLogFile) {        logs.add(createDataDirLogFile(version_2, --counter));    }}
0
private void verifyFilesAfterPurge(List<File> logs, boolean exists)
{    for (File file : logs) {        assertEquals("After purging, file " + file, exists, file.exists());    }}
0
private List<String> manyClientOps(final ZooKeeper zk, final CountDownLatch doPurge, int thCount, final String prefix)
{    Thread[] ths = new Thread[thCount];    final List<String> znodes = Collections.synchronizedList(new ArrayList<String>());    final CountDownLatch finished = new CountDownLatch(thCount);    for (int indx = 0; indx < thCount; indx++) {        final String myprefix = prefix + "-" + indx;        Thread th = new Thread() {            public void run() {                for (int i = 0; i < 1000; i++) {                    try {                        String mynode = myprefix + "-" + i;                        znodes.add(mynode);                        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (Exception e) {                                            }                    if (i == 200) {                        doPurge.countDown();                    }                }                finished.countDown();            }        };        ths[indx] = th;    }    for (Thread thread : ths) {        thread.start();    }    try {        assertTrue("ZkClient ops is not finished!", finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    } catch (InterruptedException ie) {                fail("Unexpected exception occurred!");    }    return znodes;}
1
public void run()
{    for (int i = 0; i < 1000; i++) {        try {            String mynode = myprefix + "-" + i;            znodes.add(mynode);            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (Exception e) {                    }        if (i == 200) {            doPurge.countDown();        }    }    finished.countDown();}
1
public static void setUpSasl() throws Exception
{    startMiniKdc();}
0
public static void tearDownSasl() throws Exception
{    stopMiniKdc();    FileUtils.deleteQuietly(workDir);}
0
public static void startMiniKdc() throws Exception
{    createTestDir();    createMiniKdcConf();    kdc = new MiniKdc(conf, workDir);    kdc.start();}
0
public static void createTestDir() throws IOException
{    workDir = createTmpDir(new File(System.getProperty("build.test.dir", "build")));}
0
 static File createTmpDir(File parentDir) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());    return tmpDir;}
0
public static void createMiniKdcConf()
{    conf = MiniKdc.createConf();}
0
public static void stopMiniKdc()
{    if (kdc != null) {        kdc.stop();    }}
0
public static MiniKdc getKdc()
{    return kdc;}
0
public static File getWorkDir()
{    return workDir;}
0
public static Properties getConf()
{    return conf;}
0
public static String getRealm()
{    return "EXAMPLE.COM";}
0
public static String getLearnerPrincipal()
{    return "learner@EXAMPLE.COM";}
0
public static String getServerPrincipal()
{    return "zkquorum/localhost@EXAMPLE.COM";}
0
public static String getHostLearnerPrincipal()
{    return "learner/_HOST@EXAMPLE.COM";}
0
public static String getHostServerPrincipal()
{    return "zkquorum/_HOST@EXAMPLE.COM";}
0
public static String getHostNamedLearnerPrincipal(String myHostname)
{    return "learner/" + myHostname + "@EXAMPLE.COM";}
0
public static String getKeytabFile()
{    return keytabFile;}
0
public static String replaceHostPattern(String principal)
{    String[] components = principal.split("[/@]");    if (components == null || components.length < 2 || !components[1].equals(SecurityUtils.QUORUM_HOSTNAME_PATTERN)) {        return principal;    } else {        return replacePattern(components, "localhost");    }}
0
public static String replacePattern(String[] components, String hostname)
{    if (components.length == 3) {        return components[0] + "/" + hostname.toLowerCase() + "@" + components[2];    } else {        return components[0] + "/" + hostname.toLowerCase();    }}
0
public static void main(String[] args) throws Exception
{    if (args.length < 4) {        System.out.println("Arguments: <WORKDIR> <MINIKDCPROPERTIES> " + "<KEYTABFILE> [<PRINCIPALS>]+");        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    File workDir = new File(args[0]);    if (!workDir.exists()) {        throw new RuntimeException("Specified work directory does not exists: " + workDir.getAbsolutePath());    }    Properties conf = createConf();    File file = new File(args[1]);    if (!file.exists()) {        throw new RuntimeException("Specified configuration does not exists: " + file.getAbsolutePath());    }    Properties userConf = new Properties();    InputStreamReader r = null;    try {        r = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);        userConf.load(r);    } finally {        if (r != null) {            r.close();        }    }    for (Map.Entry<?, ?> entry : userConf.entrySet()) {        conf.put(entry.getKey(), entry.getValue());    }    final MiniKdc miniKdc = new MiniKdc(conf, workDir);    miniKdc.start();    File krb5conf = new File(workDir, "krb5.conf");    if (miniKdc.getKrb5conf().renameTo(krb5conf)) {        File keytabFile = new File(args[2]).getAbsoluteFile();        String[] principals = new String[args.length - 3];        System.arraycopy(args, 3, principals, 0, args.length - 3);        miniKdc.createPrincipal(keytabFile, principals);        System.out.println();        System.out.println("Standalone MiniKdc Running");        System.out.println("---------------------------------------------------");        System.out.println("  Realm           : " + miniKdc.getRealm());        System.out.println("  Running at      : " + miniKdc.getHost() + ":" + miniKdc.getHost());        System.out.println("  krb5conf        : " + krb5conf);        System.out.println();        System.out.println("  created keytab  : " + keytabFile);        System.out.println("  with principals : " + Arrays.asList(principals));        System.out.println();        System.out.println(" Do <CTRL-C> or kill <PID> to stop it");        System.out.println("---------------------------------------------------");        System.out.println();        Runtime.getRuntime().addShutdownHook(new Thread() {            @Override            public void run() {                miniKdc.stop();            }        });    } else {        throw new RuntimeException("Cannot rename KDC's krb5conf to " + krb5conf.getAbsolutePath());    }}
0
public void run()
{    miniKdc.stop();}
0
public static Properties createConf()
{    return (Properties) DEFAULT_CONFIG.clone();}
0
public void setTransport(String transport)
{    this.transport = transport;}
0
public int getPort()
{    return port;}
0
public String getHost()
{    return conf.getProperty(KDC_BIND_ADDRESS);}
0
public String getRealm()
{    return realm;}
0
public File getKrb5conf()
{    krb5conf = new File(System.getProperty(JAVA_SECURITY_KRB5_CONF));    return krb5conf;}
0
public synchronized void start() throws Exception
{    if (simpleKdc != null) {        throw new RuntimeException("Already started");    }    simpleKdc = new SimpleKdcServer();    prepareKdcServer();    simpleKdc.init();    resetDefaultRealm();    simpleKdc.start();    }
1
private void resetDefaultRealm() throws IOException
{    InputStream templateResource = new FileInputStream(getKrb5conf().getAbsolutePath());    String content = IOUtil.readInput(templateResource);    content = content.replaceAll("default_realm = .*\n", "default_realm = " + getRealm() + "\n");    IOUtil.writeFile(content, getKrb5conf());}
0
private void prepareKdcServer() throws Exception
{        simpleKdc.setWorkDir(workDir);    simpleKdc.setKdcHost(getHost());    simpleKdc.setKdcRealm(realm);    if (transport == null) {        transport = conf.getProperty(TRANSPORT);    }    if (port == 0) {        port = NetworkUtil.getServerPort();    }    if (transport != null) {        if (transport.trim().equals("TCP")) {            simpleKdc.setKdcTcpPort(port);            simpleKdc.setAllowUdp(false);        } else if (transport.trim().equals("UDP")) {            simpleKdc.setKdcUdpPort(port);            simpleKdc.setAllowTcp(false);        } else {            throw new IllegalArgumentException("Invalid transport: " + transport);        }    } else {        throw new IllegalArgumentException("Need to set transport!");    }    simpleKdc.getKdcConfig().setString(KdcConfigKey.KDC_SERVICE_NAME, conf.getProperty(INSTANCE));    if (conf.getProperty(DEBUG) != null) {        krb5Debug = getAndSet(SUN_SECURITY_KRB5_DEBUG, conf.getProperty(DEBUG));    }}
0
public synchronized void stop()
{    if (simpleKdc != null) {        try {            simpleKdc.stop();        } catch (KrbException e) {            e.printStackTrace();        } finally {            if (conf.getProperty(DEBUG) != null) {                System.setProperty(SUN_SECURITY_KRB5_DEBUG, Boolean.toString(krb5Debug));            }        }    }    delete(workDir);    try {                Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    }
1
private void delete(File f)
{    if (f.isFile()) {        if (!f.delete()) {                    }    } else {        for (File c : f.listFiles()) {            delete(c);        }        if (!f.delete()) {                    }    }}
1
public synchronized void createPrincipal(String principal, String password) throws Exception
{    simpleKdc.createPrincipal(principal, password);}
0
public synchronized void createPrincipal(File keytabFile, String... principals) throws Exception
{    simpleKdc.createPrincipals(principals);    if (keytabFile.exists() && !keytabFile.delete()) {            }    for (String principal : principals) {        simpleKdc.getKadmin().exportKeytab(keytabFile, principal);    }}
1
private boolean getAndSet(String sysprop, String debug)
{    boolean old = Boolean.getBoolean(sysprop);    System.setProperty(sysprop, debug);    return old;}
0
public void testMiniKdcStart()
{    MiniKdc kdc = getKdc();    assertNotSame(0, kdc.getPort());}
0
public void testKeytabGen() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    kdc.createPrincipal(new File(workDir, "keytab"), "foo/bar", "bar/foo");    List<PrincipalName> principalNameList = Keytab.loadKeytab(new File(workDir, "keytab")).getPrincipals();    Set<String> principals = new HashSet<String>();    for (PrincipalName principalName : principalNameList) {        principals.add(principalName.getName());    }    assertEquals(new HashSet<>(Arrays.asList("foo/bar@" + kdc.getRealm(), "bar/foo@" + kdc.getRealm())), principals);}
0
public static Configuration createClientConfig(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, true);}
0
public static Configuration createServerConfig(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, false);}
0
private static String getKrb5LoginModuleName()
{    return System.getProperty("java.vendor").contains("IBM") ? "com.ibm.security.auth.module.Krb5LoginModule" : "com.sun.security.auth.module.Krb5LoginModule";}
0
public AppConfigurationEntry[] getAppConfigurationEntry(String name)
{    Map<String, String> options = new HashMap<String, String>();    options.put("principal", principal);    options.put("refreshKrb5Config", "true");    if (IBM_JAVA) {        options.put("useKeytab", keytab);        options.put("credsType", "both");    } else {        options.put("keyTab", keytab);        options.put("useKeyTab", "true");        options.put("storeKey", "true");        options.put("doNotPrompt", "true");        options.put("useTicketCache", "true");        options.put("renewTGT", "true");        options.put("isInitiator", Boolean.toString(isInitiator));    }    String ticketCache = System.getenv("KRB5CCNAME");    if (ticketCache != null) {        options.put("ticketCache", ticketCache);    }    options.put("debug", "true");    return new AppConfigurationEntry[] { new AppConfigurationEntry(getKrb5LoginModuleName(), AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options) };}
0
public void testKerberosLogin() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    LoginContext loginContext = null;    try {        String principal = "foo";        File keytab = new File(workDir, "foo.keytab");        kdc.createPrincipal(keytab, principal);        Set<Principal> principals = new HashSet<Principal>();        principals.add(new KerberosPrincipal(principal));                Subject subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createClientConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();                subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createServerConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();    } finally {        if (loginContext != null && loginContext.getSubject() != null && !loginContext.getSubject().getPrincipals().isEmpty()) {            loginContext.logout();        }    }}
0
public static void setupJaasConfig(String jaasEntries)
{    try {        jaasConfigDir = ClientBase.createTmpDir();        File saslConfFile = new File(jaasConfigDir, "jaas.conf");        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasEntries);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException ioe) {                    }}
1
public static void cleanupJaasConfig()
{    if (jaasConfigDir != null) {        FileUtils.deleteQuietly(jaasConfigDir);    }}
0
protected String startQuorum(final int serverCount, Map<String, String> authConfigs, int authServerCount) throws IOException
{    StringBuilder connectStr = new StringBuilder();    final int[] clientPorts = startQuorum(serverCount, connectStr, authConfigs, authServerCount);    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT));    }    return connectStr.toString();}
0
protected int[] startQuorum(final int serverCount, StringBuilder connectStr, Map<String, String> authConfigs, int authServerCount) throws IOException
{    final int[] clientPorts = new int[serverCount];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < serverCount; i++) {        clientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=localhost:%d:%d:participant", i, PortAssignment.unique(), PortAssignment.unique());        sb.append(server + "\n");        connectStr.append("127.0.0.1:" + clientPorts[i]);        if (i < serverCount - 1) {            connectStr.append(",");        }    }    String quorumCfg = sb.toString();        int i = 0;    for (; i < authServerCount; i++) {        startServer(authConfigs, clientPorts, quorumCfg, i);    }        for (int j = 0; j < serverCount - authServerCount; j++, i++) {        MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg);        mt.add(mthread);        mthread.start();    }    return clientPorts;}
0
private void startServer(Map<String, String> authConfigs, final int[] clientPorts, String quorumCfg, int i) throws IOException
{    MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg, authConfigs);    mt.add(mthread);    mthread.start();}
0
protected void startServer(MainThread restartPeer, Map<String, String> authConfigs) throws IOException
{    MainThread mthread = new MainThread(restartPeer.getMyid(), restartPeer.getClientPort(), restartPeer.getQuorumCfgSection(), authConfigs);    mt.add(mthread);    mthread.start();}
0
 void shutdownAll()
{    for (int i = 0; i < mt.size(); i++) {        shutdown(i);    }}
0
 MainThread shutdown(int index)
{    MainThread mainThread = mt.get(index);    try {        mainThread.shutdown();    } catch (InterruptedException e) {        } finally {        mt.remove(index);    }    mainThread.deleteBaseDir();    return mainThread;}
0
public void tearDown() throws Exception
{    shutdownAll();}
0
public static void cleanup()
{    cleanupJaasConfig();}
0
public void testNullAuthLearnerServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(2, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
0
public void testAuthLearnerAgainstNullAuthServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 1);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
0
public void testAuthLearnerAgainstNoAuthRequiredServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
0
public void testAuthLearnerServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
0
public void testRollingUpgrade() throws Exception
{                Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(3, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);                authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    MainThread m = shutdown(2);    startServer(m, authConfigs);    assertFalse("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), 5000));}
0
private void restartServer(Map<String, String> authConfigs, int index, ZooKeeper zk, CountdownWatcher watcher) throws IOException, KeeperException, InterruptedException, TimeoutException
{        MainThread m = shutdown(index);    startServer(m, authConfigs);    assertTrue("waiting for server" + index + "being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), ClientBase.CONNECTION_TIMEOUT));    watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
1
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
0
public static void cleanup()
{    cleanupJaasConfig();}
0
public void testValidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
0
public void testSaslNotRequiredWithInvalidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
0
public void testSaslRequiredInvalidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    int serverCount = 2;    final int[] clientPorts = startQuorum(serverCount, new StringBuilder(), authConfigs, serverCount);    for (int i = 0; i < serverCount; i++) {        boolean waitForServerUp = ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], QuorumPeerTestBase.TIMEOUT);        assertFalse("Shouldn't start server with invalid credentials", waitForServerUp);    }}
0
public void testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorumpeer learner is not enabled!");    } catch (ConfigException e) {        }}
0
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
0
public void testEnableQuorumAuthenticationConfigurations() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }}
0
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
0
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
0
public void setUp() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());    String learnerPrincipal = KerberosTestUtils.getLearnerPrincipal();    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    learnerPrincipal = learnerPrincipal.substring(0, learnerPrincipal.lastIndexOf("@"));    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, serverPrincipal);}
0
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
0
public static void cleanup()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
0
public void testValidCredentials() throws Exception
{    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
0
private static void setupJaasConfigEntries(String hostServerPrincipal, String hostLearnerPrincipal, String hostNamedLearnerPrincipal)
{    String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);    String jaasEntries = "QuorumServer {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostServerPrincipal) + "\";\n" + "};\n" + "QuorumLearner {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostLearnerPrincipal) + "\";\n" + "};\n" + "QuorumLearnerMyHost {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + hostNamedLearnerPrincipal + "\";\n" + "};\n";    setupJaasConfig(jaasEntries);}
0
public static void setUp() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());        String learnerPrincipal = hostLearnerPrincipal.substring(0, hostLearnerPrincipal.lastIndexOf("@"));    learnerPrincipal = KerberosTestUtils.replaceHostPattern(learnerPrincipal);    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    serverPrincipal = KerberosTestUtils.replaceHostPattern(serverPrincipal);        String learnerPrincipal2 = hostNamedLearnerPrincipal.substring(0, hostNamedLearnerPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, learnerPrincipal2, serverPrincipal);}
0
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
0
public static void cleanup()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
0
public void testValidCredentials() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
0
public void testConnectBadServer() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    String quorumCfgSection = mt.get(0).getQuorumCfgSection();    StringBuilder sb = new StringBuilder();    sb.append(quorumCfgSection);    int myid = mt.size() + 1;    final int clientPort = PortAssignment.unique();    String server = String.format("server.%d=localhost:%d:%d:participant", myid, PortAssignment.unique(), PortAssignment.unique());    sb.append(server + "\n");    quorumCfgSection = sb.toString();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerMyHost");    MainThread badServer = new MainThread(myid, clientPort, quorumCfgSection, authConfigs);    badServer.start();    watcher = new CountdownWatcher();    connectStr = "127.0.0.1:" + clientPort;    zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT / 3);        fail("Must throw exception as the myHost is not an authorized one!");    } catch (TimeoutException e) {        } finally {        zk.close();        badServer.shutdown();        badServer.deleteBaseDir();    }}
0
public void testSetProposalSizeSetMinMax()
{    BufferStats stats = new BufferStats();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.setLastBufferSize(20);    assertEquals(20, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());    stats.setLastBufferSize(5);    assertEquals(5, stats.getLastBufferSize());    assertEquals(5, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());}
0
public void testReset()
{    BufferStats stats = new BufferStats();    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.reset();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());}
0
public void testCloseSessionTxnCompatile() throws Exception
{            testCloseSessionWithDifferentConfig(false, false);        testCloseSessionWithDifferentConfig(false, true);        testCloseSessionWithDifferentConfig(true, false);        testCloseSessionWithDifferentConfig(true, true);}
0
private void testCloseSessionWithDifferentConfig(boolean closeSessionEnabledOnLeader, boolean closeSessionEnabledOnFollower) throws Exception
{        final int numServers = 3;    servers = LaunchServers(numServers);    int leaderId = servers.findLeader();    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnLeader);                        int followerA = (leaderId + 1) % numServers;    servers.mt[followerA].shutdown();    waitForOne(servers.zk[followerA], States.CONNECTING);        String path = "/testCloseSessionTxnCompatile";    servers.zk[leaderId].create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        servers.restartClient(leaderId, this);    waitForOne(servers.zk[leaderId], States.CONNECTED);            System.setProperty("zookeeper.retainZKDatabase", "true");    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnFollower);        servers.mt[followerA].start();    waitForOne(servers.zk[followerA], States.CONNECTED);        for (int i = 0; i < numServers; i++) {        final CountDownLatch syncedLatch = new CountDownLatch(1);        servers.zk[i].sync(path, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                syncedLatch.countDown();            }        }, null);        Assert.assertTrue(syncedLatch.await(3, TimeUnit.SECONDS));        Assert.assertNull(servers.zk[i].exists(path, false));    }}
0
public void processResult(int rc, String path, Object ctx)
{    syncedLatch.countDown();}
0
public void setUp() throws Exception
{    this.count = 3;    this.peers = new HashMap<Long, QuorumServer>(count);    peerTmpdir = new File[count];    peerQuorumPort = new int[count];    peerClientPort = new int[count];    for (int i = 0; i < count; i++) {        peerQuorumPort[i] = PortAssignment.unique();        peerClientPort[i] = PortAssignment.unique();        peers.put((long) i, new QuorumServer(i, new InetSocketAddress("127.0.0.1", peerQuorumPort[i]), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", peerClientPort[i])));        peerTmpdir[i] = ClientBase.createTmpDir();    }}
0
 ByteBuffer createMsg(int state, long leader, long zxid, long epoch)
{    byte[] requestBytes = new byte[28];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(epoch);    return requestBuffer;}
0
public void run()
{    try {        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);        QuorumCnxManager cnxManager = peer.createCnxnManager();        QuorumCnxManager.Listener listener = cnxManager.listener;        if (listener != null) {            listener.start();        } else {                    }        long sid = 1;        cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));        Message m = null;        int numRetries = 1;        while ((m == null) && (numRetries++ <= THRESHOLD)) {            m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (m == null) {                cnxManager.connectAll();            }        }        if (numRetries > THRESHOLD) {            failed = true;            return;        }        cnxManager.testInitiateConnection(sid);        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            failed = true;        }    } catch (Exception e) {                fail("Unexpected exception");    }}
1
public void testCnxManager() throws Exception
{    CnxManagerThread thread = new CnxManagerThread();    thread.start();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    Message m = null;    int numRetries = 1;    while ((m == null) && (numRetries++ <= THRESHOLD)) {        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            cnxManager.connectAll();        }    }    assertTrue("Exceeded number of retries", numRetries <= THRESHOLD);    thread.join(5000);    if (thread.isAlive()) {        fail("Thread didn't join");    } else {        if (thread.failed) {            fail("Did not receive expected message");        }    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1
public void testCnxManagerTimeout() throws Exception
{    Random rand = new Random();    byte b = (byte) rand.nextInt();    int deadPort = PortAssignment.unique();    String deadAddress = "10.1.1." + b;        peers.put(2L, new QuorumServer(2, new InetSocketAddress(deadAddress, deadPort), new InetSocketAddress(deadAddress, PortAssignment.unique()), new InetSocketAddress(deadAddress, PortAssignment.unique())));    peerTmpdir[2] = ClientBase.createTmpDir();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    long begin = Time.currentElapsedTime();    cnxManager.toSend(2L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    long end = Time.currentElapsedTime();    if ((end - begin) > 6000) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1
public void testCnxManagerSpinLock() throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    InetSocketAddress otherAddr = peers.get(Long.valueOf(2)).electionAddr;    DataOutputStream dout = new DataOutputStream(sc.socket().getOutputStream());    dout.writeLong(QuorumCnxManager.PROTOCOL_VERSION);    dout.writeLong(2);    String addr = otherAddr.getHostString() + ":" + otherAddr.getPort();    byte[] addr_bytes = addr.getBytes();    dout.writeInt(addr_bytes.length);    dout.write(addr_bytes);    dout.flush();    ByteBuffer msgBuffer = ByteBuffer.wrap(new byte[4]);    msgBuffer.putInt(-20);    msgBuffer.position(0);    sc.write(msgBuffer);    Thread.sleep(1000);    try {        /*             * Write a number of times until it             * detects that the socket is broken.             */        for (int i = 0; i < 100; i++) {            msgBuffer.position(0);            sc.write(msgBuffer);        }        fail("Socket has not been closed");    } catch (Exception e) {            }    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1
public void testCnxManagerListenerThreadConfigurableRetry() throws Exception
{    final Map<Long, QuorumServer> unresolvablePeers = new HashMap<>();    final long myid = 1L;    unresolvablePeers.put(myid, new QuorumServer(myid, "unresolvable-domain.org:2182:2183;2181"));    final QuorumPeer peer = new QuorumPeer(unresolvablePeers, ClientBase.createTmpDir(), ClientBase.createTmpDir(), 2181, 3, myid, 1000, 2, 2, 2);    final QuorumCnxManager cnxManager = peer.createCnxnManager();    final QuorumCnxManager.Listener listener = cnxManager.listener;    final AtomicBoolean errorHappend = new AtomicBoolean();    listener.setSocketBindErrorHandler(() -> errorHappend.set(true));    listener.start();                listener.join(15000);    assertFalse(listener.isAlive());    assertTrue(errorHappend.get());    assertFalse(QuorumPeer.class.getSimpleName() + " not stopped after " + "listener thread death", listener.isAlive());}
0
public void testCnxManagerNPE() throws Exception
{        peers.get(2L).type = LearnerType.OBSERVER;    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    /*         * Write id (3.4.6 protocol). This previously caused a NPE in         * QuorumCnxManager.         */    byte[] msgBytes = new byte[8];    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);    msgBuffer.putLong(2L);    msgBuffer.position(0);    sc.write(msgBuffer);    msgBuffer = ByteBuffer.wrap(new byte[8]);        msgBuffer.putInt(4);        msgBuffer.putInt(5);    msgBuffer.position(0);    sc.write(msgBuffer);    Message m = cnxManager.pollRecvQueue(1000, TimeUnit.MILLISECONDS);    assertNotNull(m);    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1
public void testSocketTimeout() throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    Socket sock = new Socket();    sock.connect(peers.get(1L).electionAddr, 5000);    long begin = Time.currentElapsedTime();        cnxManager.receiveConnection(sock);    long end = Time.currentElapsedTime();    if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1
public void testSSLSocketClosedWhenHandshakeTimeout() throws Exception
{    final CountDownLatch closeLatch = new CountDownLatch(1);    QuorumX509Util mockedX509Util = new QuorumX509Util() {        @Override        public SSLSocket createSSLSocket() {            return new SSLSocket() {                @Override                public void connect(SocketAddress endpoint, int timeout) {                }                @Override                public void startHandshake() throws IOException {                    throw new IOException();                }                @Override                public void close() {                    closeLatch.countDown();                }                public String[] getSupportedCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getSupportedProtocols() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledProtocols() {                    throw new UnsupportedOperationException();                }                public SSLSession getSession() {                    throw new UnsupportedOperationException();                }                public void setEnabledCipherSuites(String[] suites) {                }                public void setEnabledProtocols(String[] protocols) {                }                public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void setUseClientMode(boolean mode) {                }                public boolean getUseClientMode() {                    return true;                }                public void setNeedClientAuth(boolean need) {                }                public boolean getNeedClientAuth() {                    return true;                }                public void setWantClientAuth(boolean want) {                }                public boolean getWantClientAuth() {                    return true;                }                public void setEnableSessionCreation(boolean flag) {                }                public boolean getEnableSessionCreation() {                    return true;                }            };        }    };    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 2000, 2, 2, 2) {        @Override        public QuorumX509Util createX509Util() {            return mockedX509Util;        }    };    peer.setSslQuorum(true);    QuorumCnxManager cnxManager = peer.createCnxnManager();    cnxManager.connectOne(1, peers.get(1L).electionAddr);    assertTrue(closeLatch.await(1, TimeUnit.SECONDS));}
0
public SSLSocket createSSLSocket()
{    return new SSLSocket() {        @Override        public void connect(SocketAddress endpoint, int timeout) {        }        @Override        public void startHandshake() throws IOException {            throw new IOException();        }        @Override        public void close() {            closeLatch.countDown();        }        public String[] getSupportedCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getEnabledCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getSupportedProtocols() {            throw new UnsupportedOperationException();        }        public String[] getEnabledProtocols() {            throw new UnsupportedOperationException();        }        public SSLSession getSession() {            throw new UnsupportedOperationException();        }        public void setEnabledCipherSuites(String[] suites) {        }        public void setEnabledProtocols(String[] protocols) {        }        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void setUseClientMode(boolean mode) {        }        public boolean getUseClientMode() {            return true;        }        public void setNeedClientAuth(boolean need) {        }        public boolean getNeedClientAuth() {            return true;        }        public void setWantClientAuth(boolean want) {        }        public boolean getWantClientAuth() {            return true;        }        public void setEnableSessionCreation(boolean flag) {        }        public boolean getEnableSessionCreation() {            return true;        }    };}
0
public void connect(SocketAddress endpoint, int timeout)
{}
0
public void startHandshake() throws IOException
{    throw new IOException();}
0
public void close()
{    closeLatch.countDown();}
0
public String[] getSupportedCipherSuites()
{    throw new UnsupportedOperationException();}
0
public String[] getEnabledCipherSuites()
{    throw new UnsupportedOperationException();}
0
public String[] getSupportedProtocols()
{    throw new UnsupportedOperationException();}
0
public String[] getEnabledProtocols()
{    throw new UnsupportedOperationException();}
0
public SSLSession getSession()
{    throw new UnsupportedOperationException();}
0
public void setEnabledCipherSuites(String[] suites)
{}
0
public void setEnabledProtocols(String[] protocols)
{}
0
public void addHandshakeCompletedListener(HandshakeCompletedListener listener)
{}
0
public void removeHandshakeCompletedListener(HandshakeCompletedListener listener)
{}
0
public void setUseClientMode(boolean mode)
{}
0
public boolean getUseClientMode()
{    return true;}
0
public void setNeedClientAuth(boolean need)
{}
0
public boolean getNeedClientAuth()
{    return true;}
0
public void setWantClientAuth(boolean want)
{}
0
public boolean getWantClientAuth()
{    return true;}
0
public void setEnableSessionCreation(boolean flag)
{}
0
public boolean getEnableSessionCreation()
{    return true;}
0
public QuorumX509Util createX509Util()
{    return mockedX509Util;}
0
public void testWorkerThreads() throws Exception
{    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    try {        for (int sid = 0; sid < 3; sid++) {            QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);                        peer.start();            peerList.add(sid, peer);        }        String failure = verifyThreadCount(peerList, 4);        assertNull(failure, failure);        for (int myid = 0; myid < 3; myid++) {            for (int i = 0; i < 5; i++) {                                QuorumPeer peer = peerList.get(myid);                                peer.shutdown();                peerList.remove(myid);                failure = verifyThreadCount(peerList, 2);                assertNull(failure, failure);                                peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);                                peer.start();                peerList.add(myid, peer);                failure = verifyThreadCount(peerList, 4);                assertNull(failure, failure);            }        }    } finally {        for (QuorumPeer quorumPeer : peerList) {            quorumPeer.shutdown();        }    }}
1
public String verifyThreadCount(ArrayList<QuorumPeer> peerList, long ecnt) throws InterruptedException
{    String failure = null;    for (int i = 0; i < 480; i++) {        Thread.sleep(500);        failure = _verifyThreadCount(peerList, ecnt);        if (failure == null) {            return null;        }    }    return failure;}
0
public String _verifyThreadCount(ArrayList<QuorumPeer> peerList, long ecnt)
{    for (int myid = 0; myid < peerList.size(); myid++) {        QuorumPeer peer = peerList.get(myid);        QuorumCnxManager cnxManager = peer.getQuorumCnxManager();        long cnt = cnxManager.getThreadCount();        if (cnt != ecnt) {            return new Date() + " Incorrect number of Worker threads for sid=" + myid + " expected " + ecnt + " found " + cnt;        }    }    return null;}
0
public void testInitialMessage() throws Exception
{    InitialMessage msg;    ByteArrayOutputStream bos;    DataInputStream din;    DataOutputStream dout;    String hostport;        try {                hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(-65530L, din);        fail("bad protocol version accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = createLongString(1048576);        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("long message accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "what's going on here?";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("bad hostport accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);    } catch (InitialMessage.InitialMessageException ex) {        fail(ex.toString());    }}
0
private String createLongString(int size)
{    StringBuilder sb = new StringBuilder(size);    for (int i = 0; i < size; i++) {        sb.append('x');    }    return sb.toString();}
0
public void setUp() throws Exception
{    processedRequests = new LinkedBlockingQueue<Request>();    processor = new MockCommitProcessor();    CommitProcessor.setMaxReadBatchSize(-1);    CommitProcessor.setMaxCommitBatchSize(1);}
0
public void tearDown() throws Exception
{    processor.shutdown();}
0
public Request poll()
{    readReqId++;    try {        return newRequest(new GetDataRequest("/", false), OpCode.getData, readReqId % 50, readReqId);    } catch (IOException e) {        e.printStackTrace();    }    return null;}
0
public int size()
{    return 42;}
0
public void processRequest(Request request) throws RequestProcessorException
{    processedRequests.offer(request);}
0
public void shutdown()
{}
0
public void notifyStopping(String threadName, int errorCode)
{    fail("Commit processor crashed " + errorCode);}
0
public void initThreads(int poolSize)
{    this.stopped = false;    this.workerPool = new WorkerService("CommitProcWork", poolSize, true);}
0
private Request newRequest(Record rec, int type, int sessionId, int xid) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    rec.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, xid, type, bb, new ArrayList<Id>());}
0
public void committedAndUncommittedOfTheSameSessionRaceTest() throws Exception
{    final String path = "/testCvsUCRace";    Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x0, 0);    Request writeReq = newRequest(new SetDataRequest(path, new byte[16], -1), OpCode.setData, 0x0, 1);    processor.committedRequests.add(writeReq);    processor.queuedRequests.add(readReq);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    processor.initThreads(1);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Request was not processed " + readReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(readReq));    processedRequests.poll();    assertTrue("Request was not processed " + writeReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(writeReq));}
0
public void processAsMuchUncommittedRequestsAsPossibleTest() throws Exception
{    final String path = "/testAsMuchAsPossible";    List<Request> shouldBeProcessed = new LinkedList<Request>();    Set<Request> shouldNotBeProcessed = new HashSet<Request>();    for (int sessionId = 1; sessionId <= 5; ++sessionId) {        for (int readReqId = 1; readReqId <= sessionId; ++readReqId) {            Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, readReqId);            shouldBeProcessed.add(readReq);            processor.queuedRequests.add(readReq);        }        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionId, sessionId + 1);        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, sessionId + 2);        processor.queuedRequests.add(writeReq);        processor.queuedWriteRequests.add(writeReq);        processor.queuedRequests.add(readReq);        shouldNotBeProcessed.add(writeReq);        shouldNotBeProcessed.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    Thread.sleep(1000);    shouldBeProcessed.removeAll(processedRequests);    for (Request r : shouldBeProcessed) {            }    assertTrue("Not all requests were processed", shouldBeProcessed.isEmpty());    assertFalse("Processed a wrong request", shouldNotBeProcessed.removeAll(processedRequests));}
1
public void processAllFollowingUncommittedAfterFirstCommitTest() throws Exception
{    final String path = "/testUncommittedFollowingCommited";    Set<Request> shouldBeInPending = new HashSet<Request>();    Set<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    shouldBeInPending.add(writeReq);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        processor.queuedRequests.add(readReq);        shouldBeInPending.add(readReq);        shouldBeProcessedAfterPending.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    shouldBeInPending.removeAll(processor.pendingRequests.get(writeReq.sessionId));    for (Request r : shouldBeInPending) {            }    assertTrue("Not all requests moved to pending from queuedRequests", shouldBeInPending.isEmpty());    processor.committedRequests.add(writeReq);    processor.stoppedMainLoop = true;    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
1
public void processAllWritesMaxBatchSize() throws Exception
{    final String path = "/processAllWritesMaxBatchSize";    HashSet<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path + "_1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    Request writeReq2 = newRequest(new CreateRequest(path + "_2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 1);    processor.queuedRequests.add(writeReq2);    processor.queuedWriteRequests.add(writeReq2);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        Request readReq2 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x2, readReqId);        processor.queuedRequests.add(readReq);        shouldBeProcessedAfterPending.add(readReq);        processor.queuedRequests.add(readReq2);        shouldBeProcessedAfterPending.add(readReq2);    }    Request writeReq3 = newRequest(new CreateRequest(path + "_3", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 6);    processor.queuedRequests.add(writeReq3);    processor.queuedWriteRequests.add(writeReq3);    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(2);    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    assertTrue("Missing session 1 in pending queue", processor.pendingRequests.containsKey(writeReq.sessionId));    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq2.sessionId));    processor.committedRequests.add(writeReq);    processor.committedRequests.add(writeReq2);    processor.committedRequests.add(writeReq3);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed committed request", !processor.committedRequests.isEmpty());    assertTrue("Removed commit for write req 3", processor.committedRequests.peek() == writeReq3);    assertTrue("Processed committed request", !processor.pendingRequests.isEmpty());    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq3.sessionId));    assertTrue("Missing write 3 in pending queue", processor.pendingRequests.get(writeReq3.sessionId).peek() == writeReq3);    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 3 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq3);    Request readReq3 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 7);    processor.queuedRequests.add(readReq3);    shouldBeProcessedAfterPending.add(readReq3);    Request writeReq4 = newRequest(new CreateRequest(path + "_4", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 7);    processor.queuedRequests.add(writeReq4);    processor.queuedWriteRequests.add(writeReq4);    processor.committedRequests.add(writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed unexpected committed request", !processor.committedRequests.isEmpty());    assertTrue("Unexpected pending request", processor.pendingRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 4 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
0
public void noStarvationOfNonLocalCommittedRequestsTest() throws Exception
{    final String path = "/noStarvationOfCommittedRequests";    processor.queuedRequests = new MockRequestsQueue();    Set<Request> nonLocalCommits = new HashSet<Request>();    for (int i = 0; i < 10; i++) {        Request nonLocalCommitReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 51, i + 1);        processor.committedRequests.add(nonLocalCommitReq);        nonLocalCommits.add(nonLocalCommitReq);    }    for (int i = 0; i < 10; i++) {        processor.initThreads(defaultSizeOfThreadPool);        processor.stoppedMainLoop = true;        processor.run();    }    assertTrue("commit request was not processed", processedRequests.containsAll(nonLocalCommits));}
0
public void noStarvationOfReadRequestsTest() throws Exception
{    final String path = "/noStarvationOfReadRequests";        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x3, 1);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    processor.committedRequests.add(firstCommittedReq);    Set<Request> allReads = new HashSet<Request>();        Request firstRead = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 0);    allReads.add(firstRead);    processor.queuedRequests.add(firstRead);        Request secondCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x99, 2);    processor.committedRequests.add(secondCommittedReq);    Set<Request> waitingCommittedRequests = new HashSet<Request>();        for (int writeReqId = 3; writeReqId < 102; ++writeReqId) {        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x8, writeReqId);        processor.committedRequests.add(writeReq);        waitingCommittedRequests.add(writeReq);    }        for (int readReqId = 1; readReqId <= 50; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x5, readReqId);        allReads.add(readReq);        processor.queuedRequests.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Did not process the first write request", processedRequests.contains(firstCommittedReq));    for (Request r : allReads) {        assertTrue("Processed read request", !processedRequests.contains(r));    }    processor.run();    assertTrue("did not processed all reads", processedRequests.containsAll(allReads));    assertTrue("Did not process the second write request", processedRequests.contains(secondCommittedReq));    for (Request r : waitingCommittedRequests) {        assertTrue("Processed additional committed request", !processedRequests.contains(r));    }}
0
public void noCrashOnCommittedRequestsOfUnseenRequestTest() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnseenRequestTest";    final int numberofReads = 10;    final int sessionid = 0x123456;    final int firstCXid = 0x100;    int readReqId = firstCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, readReqId++);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    localRequests.add(firstCommittedReq);        for (; readReqId <= numberofReads + firstCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        assertTrue(processor.queuedRequests.containsAll(localRequests));    processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request preSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, firstCXid - 2);    processor.committedRequests.add(preSessionCommittedReq);    processor.committedRequests.add(firstCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.peek() == preSessionCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
0
public void noCrashOnOutofOrderCommittedRequestTest() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnSeenRequestTest";    final int sessionid = 0x123456;    final int lastCXid = 0x100;    final int numberofReads = 10;    int readReqId = lastCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request orphanCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid);    processor.queuedRequests.add(orphanCommittedReq);    processor.queuedWriteRequests.add(orphanCommittedReq);    localRequests.add(orphanCommittedReq);        for (; readReqId <= numberofReads + lastCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request otherSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid + 10);    processor.committedRequests.add(otherSessionCommittedReq);    processor.committedRequests.add(orphanCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.size() == 1);    assertTrue(processedRequests.contains(otherSessionCommittedReq));    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
0
public void setup()
{        ServerMetrics.getMetrics().resetAll();        System.clearProperty("zookeeper.commitProcessor.maxReadBatchSize");    System.clearProperty("zookeeper.commitProcessor.maxCommitBatchSize");}
1
public void setupProcessors(int commitWorkers, int finalProcTime)
{    finalProcessor = new DummyFinalProcessor(finalProcTime);    commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);    commitProcessor.start();}
0
public void tearDown() throws Exception
{        commitProcessor.shutdown();    commitProcessor.join();}
1
public void start()
{    super.workerPool = new TestWorkerService(numWorkerThreads);    super.start();                                                        Thread.State state = super.getState();    while (state != State.WAITING) {        try {            Thread.sleep(50);        } catch (Exception e) {        }        state = super.getState();    }    }
1
protected void endOfIteration()
{    if (requestProcessed != null) {        requestProcessed.countDown();    }}
0
protected void waitForEmptyPool() throws InterruptedException
{    if (commitSeen != null) {        commitSeen.countDown();    }    super.waitForEmptyPool();    if (poolEmpytied != null) {        poolEmpytied.countDown();    }}
0
public void schedule(WorkRequest workRequest, long id)
{    super.schedule(workRequest, id);    if (requestScheduled != null) {        requestScheduled.countDown();    }}
0
public void processRequest(Request request)
{    if (processTime > 0) {        try {            if (commitSeen != null) {                commitSeen.await(5, TimeUnit.SECONDS);            }            Thread.sleep(processTime);        } catch (Exception e) {        }    }}
0
public void shutdown()
{}
0
private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals("expected min is " + min, min, values.get("min_" + metricName));    assertEquals("expected max is: " + max, max, values.get("max_" + metricName));    assertEquals("expected avg is: " + avg, avg, (Double) values.get("avg_" + metricName), 0.001);    assertEquals("expected cnt is: " + cnt, cnt, values.get("cnt_" + metricName));    assertEquals("expected sum is: " + sum, sum, values.get("sum_" + metricName));}
0
private void checkTimeMetric(long actual, long lBoundrary, long hBoundrary)
{    assertThat(actual, greaterThanOrEqualTo(lBoundrary));    assertThat(actual, lessThanOrEqualTo(hBoundrary));}
0
private Request createReadRequest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.getData, ByteBuffer.wrap(new byte[10]), null);}
0
private Request createWriteRequest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
0
private void processRequestWithWait(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.processRequest(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
0
private void commitWithWait(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.commit(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
0
public void testRequestsInSessionQueue() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 1L, 1D, 1L, 1L);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    checkMetrics("requests_in_session_queue", 1L, 3L, 2D, 3L, 6);    commitWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 3L, 2.25D, 4L, 9);}
0
public void testWriteFinalProcTime() throws Exception
{    setupProcessors(0, 1000);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(0L, values.get("cnt_write_final_proc_time_ms"));    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_write_final_proc_time_ms"), 1000L, 2000L);}
0
public void testReadFinalProcTime() throws Exception
{    setupProcessors(0, 1000);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_read_final_proc_time_ms"), 1000L, 2000L);}
0
public void testCommitProcessTime() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_commit_process_time"));    checkTimeMetric((long) values.get("max_commit_process_time"), 0L, 1000L);}
0
public void testServerWriteCommittedTime() throws Exception
{    setupProcessors(0, 0);        commitWithWait(createWriteRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_server_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_server_write_committed_time_ms"), 0L, 1000L);}
0
public void testLocalWriteCommittedTime() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);}
0
public void testWriteCommitProcTime() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);        Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 1000L, 2000L);}
0
public void testReadCommitProcTime() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 0L, 1000L);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    processRequestWithWait(createReadRequest(1L, 3));        Thread.sleep(1000);    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 1000L, 2000L);}
0
public void testTimeWaitingEmptyPoolInCommitProcessorRead() throws Exception
{    setupProcessors(1, 1000);        requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(0L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(2L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);    long actual = (long) MetricsUtils.currentServerMetrics().get("max_time_waiting_empty_pool_in_commit_processor_read_ms");        checkTimeMetric(actual, 2500L, 3500L);}
0
public void testConcurrentRequestProcessingInCommitProcessor() throws Exception
{    setupProcessors(3, 1000);        commitSeen = new CountDownLatch(1);    requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(1L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(1L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_concurrent_request_processing_in_commit_processor"));}
0
public void testReadsAfterWriteInSessionQueue() throws Exception
{    setupProcessors(0, 0);        processRequestWithWait(createReadRequest(1L, 1));        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    processRequestWithWait(createReadRequest(1L, 4));        commitWithWait(req1);    checkMetrics("reads_after_write_in_session_queue", 3L, 3L, 3d, 1, 3);}
0
public void testReadsQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    processRequestWithWait(createReadRequest(1L, 2));        checkMetrics("read_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
0
public void testWritesQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req1);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.6667d, 3, 5);    commitWithWait(req2);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 4, 6);            processRequestWithWait(createReadRequest(1L, 1));    checkMetrics("write_commit_proc_req_queued", 0L, 2L, 1.2d, 5, 6);}
0
public void testCommitsQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));        checkMetrics("commit_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
0
public void testCommitsQueued() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) values.get("request_commit_queued"));}
0
public void testPendingSessionQueueSize() throws Exception
{    setupProcessors(0, 0);        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        Request req2 = createWriteRequest(2L, 2);    processRequestWithWait(req2);    Request req3 = createWriteRequest(2L, 3);    processRequestWithWait(req3);    commitWithWait(req1);        checkMetrics("pending_session_queue_size", 2L, 2L, 2d, 1, 2);    commitWithWait(req2);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req3);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.333d, 3, 4);}
0
public void setUp(int numCommitThreads, int numClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < numClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }}
0
public void setUp(int numCommitThreads, int numReadOnlyClientThreads, int mixWorkloadClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < mixWorkloadClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }    for (int i = 0; i < numReadOnlyClientThreads; ++i) {        TestClientThread client = new TestClientThread(0);        testClients.add(client);        client.start();    }}
0
public void tearDown() throws Exception
{        stopped = true;    zks.shutdown();    for (TestClientThread client : testClients) {        client.interrupt();        client.join();    }    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), ClientBase.recursiveDelete(tmpDir));    }    processedReadRequests.set(0);    processedWriteRequests.set(0);    testClients.clear();    commitProcessor.join();}
1
public void sendWriteRequest() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createReq = new CreateRequest("/session" + Long.toHexString(sessionId) + "-" + (++nodeId), new byte[0], Ids.OPEN_ACL_UNSAFE, 1);    createReq.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.create, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
0
public void sendReadRequest() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest("/session" + Long.toHexString(sessionId) + "-" + nodeId, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.getData, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
0
public void run()
{    Random rand = new Random(Thread.currentThread().getId());    try {        sendWriteRequest();        while (!stopped) {            if (rand.nextInt(100) < writePercent) {                sendWriteRequest();            } else {                sendReadRequest();            }            Thread.sleep(5 + rand.nextInt(95));        }    } catch (Exception e) {            }}
1
public void testNoCommitWorkersReadOnlyWorkload() throws Exception
{    int numClients = 10;        setUp(0, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
1
public void testNoCommitWorkersMixedWorkload() throws Exception
{    int numClients = 10;        setUp(0, numClients, 25);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
1
public void testOneCommitWorkerReadOnlyWorkload() throws Exception
{    int numClients = 10;        setUp(1, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
1
public void testOneCommitWorkerMixedWorkload() throws Exception
{    setUp(1, 10, 25);        synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
1
public void testManyCommitWorkersReadOnly() throws Exception
{    int numClients = 10;        setUp(10, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
1
public void testManyCommitWorkersMixedWorkload() throws Exception
{    setUp(16, 8, 8, 25);        synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
1
private void checkProcessedRequest()
{    assertTrue("No read requests processed", processedReadRequests.get() > 0);    assertTrue("No write requests processed", processedWriteRequests.get() > 0);}
0
private synchronized void failTest(String reason)
{    fail = true;    notifyAll();    fail(reason);}
0
public PrepRequestProcessor getFirstProcessor()
{    return (PrepRequestProcessor) firstProcessor;}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(zks);            ValidateProcessor validateProcessor = new ValidateProcessor(finalProcessor);    commitProcessor = new CommitProcessor(validateProcessor, "1", true, null);    validateProcessor.setCommitProcessor(commitProcessor);    commitProcessor.start();    MockProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(commitProcessor);    proposalProcessor.start();    firstProcessor = new PrepRequestProcessor(zks, proposalProcessor);    getFirstProcessor().start();}
0
public void run()
{    Random rand = new Random(Thread.currentThread().getId());    try {        while (true) {                        if (!proposals.isEmpty()) {                Request request = proposals.take();                Thread.sleep(5 + rand.nextInt(95));                commitProcessor.commit(request);            }        }    } catch (InterruptedException e) {        }}
0
public void processRequest(Request request) throws RequestProcessorException
{    commitProcessor.processRequest(request);    if (request.getHdr() != null) {                proposals.add(request);    }}
0
public void shutdown()
{        proposals.clear();    if (commitProcessor != null) {        commitProcessor.shutdown();    }}
1
public void setCommitProcessor(CommitProcessor commitProcessor)
{    this.commitProcessor = commitProcessor;}
0
public void processRequest(Request request) throws RequestProcessorException
{    if (stopped) {        return;    }    if (request.type == OpCode.closeSession) {                nextProcessor.processRequest(request);        return;    }    boolean isWriteRequest = commitProcessor.needCommit(request);    if (isWriteRequest) {        outstandingWriteRequests.incrementAndGet();        validateWriteRequestVariant(request);            } else {                outstandingReadRequests.incrementAndGet();        validateReadRequestVariant(request);    }        try {        Thread.sleep(5 + rand.nextInt(25));    } catch (InterruptedException e) {        }    nextProcessor.processRequest(request);    /*             * The commit workers will have to execute this line before they             * wake up the commit processor. So this value is up-to-date when             * variant check is performed             */    if (isWriteRequest) {        outstandingWriteRequests.decrementAndGet();                processedWriteRequests.incrementAndGet();    } else {        outstandingReadRequests.decrementAndGet();                processedReadRequests.incrementAndGet();    }    validateRequest(request);}
1
private void validateWriteRequestVariant(Request request)
{    if (stopped) {        return;    }    long zxid = request.getHdr().getZxid();    int readRequests = outstandingReadRequests.get();    if (readRequests != 0) {        failTest("There are " + readRequests + " outstanding" + " read requests while issuing a write request zxid=" + zxid);    }    int writeRequests = outstandingWriteRequests.get();    if (writeRequests > 1) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a write request zxid=" + zxid + " (expected one)");    }}
0
private void validateReadRequestVariant(Request request)
{    int writeRequests = outstandingWriteRequests.get();    if (writeRequests != 0) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a read request cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId));    }}
0
private void validateRequest(Request request)
{    if (LOG.isDebugEnabled()) {            }        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        if (!expectedZxid.compareAndSet(zxid, zxid + 1)) {            failTest("Write request, expected_zxid=" + expectedZxid.get() + "; req_zxid=" + zxid);        }    }        AtomicInteger sessionCxid = cxidMap.get(request.sessionId);    if (sessionCxid == null) {        sessionCxid = new AtomicInteger(request.cxid + 1);        AtomicInteger existingSessionCxid = cxidMap.putIfAbsent(request.sessionId, sessionCxid);        if (existingSessionCxid != null) {            failTest("Race condition adding cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId) + " with other_cxid=" + existingSessionCxid.get());        }    } else {        if (!sessionCxid.compareAndSet(request.cxid, request.cxid + 1)) {            failTest("Expected_cxid=" + sessionCxid.get() + "; req_cxid=" + request.cxid);        }    }}
1
public void shutdown()
{        cxidMap.clear();    expectedZxid = new AtomicLong(1);    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
1
public void processRequest(Request request) throws RequestProcessorException
{    if (blocking) {        incomingRequests.add(request);    } else {        next.processRequest(request);    }}
0
public void submitRequest(Request request) throws RequestProcessorException
{    next.processRequest(request);}
0
public void shutdown()
{}
0
public void unblockQueue() throws RequestProcessorException
{    if (blocking) {        for (Request request : incomingRequests) {            next.processRequest(request);        }        blocking = false;    }}
0
public static DelayRequestProcessor injectDelayRequestProcessor(FollowerZooKeeperServer zooKeeperServer)
{    RequestProcessor finalRequestProcessor = zooKeeperServer.commitProcessor.nextProcessor;    DelayRequestProcessor delayRequestProcessor = new DelayRequestProcessor(finalRequestProcessor);    zooKeeperServer.commitProcessor.nextProcessor = delayRequestProcessor;    return delayRequestProcessor;}
0
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING, true }, { ServerState.LEADING, false }, { ServerState.FOLLOWING, true }, { ServerState.FOLLOWING, false }, { ServerState.OBSERVING, true }, { ServerState.OBSERVING, false } });}
0
public void setUp() throws Exception
{    ensureCheck(checkEnabled);    CountdownWatcher clientWatch = new CountdownWatcher();    CountdownWatcher clientWatchB = new CountdownWatcher();    super.setUp(true);    String hostPort = getPeersMatching(serverState).split(",")[0];    int clientPort = Integer.parseInt(hostPort.split(":")[1]);    zkLeader = getPeerList().get(getLeaderIndex());    connectedServer = getPeerByClientPort(clientPort).getActiveServer();    zkClient = createClient(clientWatch, hostPort);    zkClientB = createClient(clientWatchB, hostPort);    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    zkClientB.addAuthInfo(AUTH_PROVIDER, AUTHB);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);    clientWatchB.waitForConnected(CONNECTION_TIMEOUT);}
0
public void tearDown() throws Exception
{    if (zkClient != null) {        zkClient.close();    }    if (zkClientB != null) {        zkClientB.close();    }    super.tearDown();}
0
private void ensureCheck(boolean enabled)
{    if (enabled) {        System.setProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK, "true");    } else {        System.clearProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK);    }}
0
private void assertTransactionState(String condition, long lastxid)
{    String assertion = String.format("Server State: %s Check Enabled: %s %s", serverState, checkEnabled, condition);    if (checkEnabled) {        assertEquals(assertion, lastxid, zkLeader.getLastLoggedZxid());    } else {        assertNotSame(assertion, lastxid, zkLeader.getLastLoggedZxid());    }}
0
public void testCreateOK() throws Exception
{    ensureCheck(true);    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
0
public void testCreate2OK() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
0
public void testCreateFail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create", lastxid);}
0
public void testCreate2Fail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create2", lastxid);}
0
public void testDeleteOK() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.delete(PARENT_PATH, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
0
public void testDeleteFail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    zkClient.create(CHILD_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.delete(CHILD_PATH, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed delete", lastxid);}
0
public void testSetDataOK() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setData(PARENT_PATH, DATA, -1);}
0
public void testSetDataFail() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setData(PARENT_PATH, DATA, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setData", lastxid);}
0
public void testSetACLOK() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
0
public void testSetACLFail() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setACL", lastxid);}
0
public void testBadACL() throws Exception
{    CountdownWatcher cw = new CountdownWatcher();    TestableZooKeeper zk = createClient(cw, getPeersMatching(serverState));    long lastxid;    cw.waitForConnected(CONNECTION_TIMEOUT);    lastxid = zkLeader.getLastLoggedZxid();    try {        zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have received an invalid acl error");    } catch (KeeperException.InvalidACLException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("zxid after invalid ACL", lastxid);}
0
public void testEphemeralNodeDeletion() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[1], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    /**     * now the problem scenario starts     */    Stat firstEphemeralNode = new Stat();        String nodePath = "/e1";    zk.create(nodePath, "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, firstEphemeralNode);    assertEquals("Current session and ephemeral owner should be same", zk.getSessionId(), firstEphemeralNode.getEphemeralOwner());        CustomQuorumPeer follower = (CustomQuorumPeer) getByServerState(mt, ServerState.FOLLOWING);    follower.setInjectError(true);        zk.close();        follower.setInjectError(false);    assertTrue("Faulted Follower should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + follower.getClientPort(), CONNECTION_TIMEOUT));    QuorumPeer leader = getByServerState(mt, ServerState.LEADING);    assertNotNull("Leader should not be null", leader);    assertTrue("Leader must be running", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    watch = new CountdownWatcher();    zk = new ZooKeeper("127.0.0.1:" + leader.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat exists = zk.exists(nodePath, false);    assertNull("Node must have been deleted from leader", exists);    CountdownWatcher followerWatch = new CountdownWatcher();    ZooKeeper followerZK = new ZooKeeper("127.0.0.1:" + follower.getClientPort(), ClientBase.CONNECTION_TIMEOUT, followerWatch);    followerWatch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat nodeAtFollower = followerZK.exists(nodePath, false);        assertNull("ephemeral node must not exist", nodeAtFollower);        Stat currentEphemeralNode = new Stat();    zk.create(nodePath, "2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, currentEphemeralNode);        zk.close();    SyncCallback cb = new SyncCallback();    followerZK.sync(nodePath, cb, null);    cb.sync.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    nodeAtFollower = followerZK.exists(nodePath, false);                assertNull("After session close ephemeral node must be deleted", nodeAtFollower);    followerZK.close();}
0
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
0
public void tearDown()
{        for (int i = 0; i < mt.length; i++) {        try {            mt[i].shutdown();        } catch (InterruptedException e) {                    }    }}
1
private QuorumPeer getByServerState(MainThread[] mt, ServerState state)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && state == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void readPacket(QuorumPacket pp) throws IOException {            /**             * In real scenario got SocketTimeoutException while reading             * the packet from leader because of network problem, but             * here throwing SocketTimeoutException based on whether             * error is injected or not             */            super.readPacket(pp);            if (injectError && pp.getType() == Leader.PROPOSAL) {                String type = LearnerHandler.packetToString(pp);                throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);            }        }    };}
0
 void readPacket(QuorumPacket pp) throws IOException
{    /**     * In real scenario got SocketTimeoutException while reading     * the packet from leader because of network problem, but     * here throwing SocketTimeoutException based on whether     * error is injected or not     */    super.readPacket(pp);    if (injectError && pp.getType() == Leader.PROPOSAL) {        String type = LearnerHandler.packetToString(pp);        throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);    }}
0
public void setInjectError(boolean injectError)
{    this.injectError = injectError;}
0
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer();}
0
public void processResult(int rc, String path, Object ctx)
{    sync.countDown();}
0
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];    cnxManagers = new QuorumCnxManager[count - 1];}
0
public void tearDown() throws Exception
{    for (int i = 0; i < (count - 1); i++) {        if (cnxManagers[i] != null) {            cnxManagers[i].halt();        }    }}
0
public void testBackwardElectionRound() throws Exception
{        for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    ByteBuffer initialMsg0 = getMsg();    ByteBuffer initialMsg1 = getMsg();    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Start mock server 1         */    QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    cnxManagers[0] = mockPeer.createCnxnManager();    cnxManagers[0].listener.start();    cnxManagers[0].toSend(0L, initialMsg0);    /*         * Start mock server 2         */    mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2, 2);    cnxManagers[1] = mockPeer.createCnxnManager();    cnxManagers[1].listener.start();    cnxManagers[1].toSend(0L, initialMsg1);    /*         * Run another instance of leader election.         */    thread.join(5000);    thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Send the same messages, this time should not make 0 the leader.         */    cnxManagers[0].toSend(0L, initialMsg0);    cnxManagers[1].toSend(0L, initialMsg1);    thread.join(5000);    if (!thread.isAlive()) {        fail("Should not have joined");    }}
1
private ByteBuffer getMsg()
{    return FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 0, 0, 1);}
0
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];}
0
public void tearDown() throws Exception
{    cnxManager.halt();}
0
public void testLostMessage() throws Exception
{        for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 1);    thread.start();    /*         * Start mock server 1         */    mockServer();    thread.join(5000);    if (thread.isAlive()) {        fail("Threads didn't join");    }}
1
 void mockServer() throws InterruptedException, IOException
{    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    cnxManager = peer.createCnxnManager();    cnxManager.listener.start();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.LOOKING.ordinal(), 0, 0, 0));    cnxManager.recvQueue.take();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 1, 0, 0));}
0
public void setUp() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    for (int i = 0; i < 5; i++) {        peers.put(Long.valueOf(i), new QuorumServer(Long.valueOf(i), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir, tmpdir, PortAssignment.unique(), 3, 3, 1000, 2, 2, 2);    fle = new FastLeaderElection(peer, peer.createCnxnManager());}
0
public void testIgnoringZxidElectionEpoch()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 2, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 2), 1, 2, ServerState.FOLLOWING));    votes.put(3L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
0
public void testElectionWIthDifferentVersion()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
0
public void testLookingNormal()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING)).hasAllQuorums());}
0
public void testLookingDiffRounds()
{    HashMap<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LEADING));    assertFalse(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING)).hasAllQuorums());}
0
public void testOutofElection()
{    HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();    outofelection.put(1L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(2L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(4L, new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.FOLLOWING));    Vote vote = new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.LEADING);    outofelection.put(5L, vote);    Notification n = new Notification();    n.version = vote.getVersion();    n.leader = vote.getId();    n.zxid = vote.getZxid();    n.electionEpoch = vote.getElectionEpoch();    n.state = vote.getState();    n.peerEpoch = vote.getPeerEpoch();    n.sid = 5L;        fle.logicalclock.set(0x1);    assertTrue("Quorum check failed", fle.getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state)).hasAllQuorums());    assertTrue("Leader check failed", fle.checkLeader(outofelection, n.leader, n.electionEpoch));}
0
public void run()
{    try {        Vote v = null;        peer.setPeerState(ServerState.LOOKING);                v = peer.getElectionAlg().lookForLeader();        if (v == null) {            fail("Thread " + i + " got a null vote");        }        /*                 * A real zookeeper would take care of setting the current vote. Here                 * we do it manually.                 */        peer.setCurrentVote(v);                assertTrue("State is not leading.", peer.getPeerState() == ServerState.LEADING);    } catch (Exception e) {        e.printStackTrace();    }    }
1
 static ByteBuffer createMsg(int state, long leader, long zxid, long epoch)
{    return FastLeaderElection.buildMsg(state, leader, zxid, 1, epoch);}
0
public void setup() throws Exception
{        final int ENSEMBLE_SERVERS = 3;    clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        mt = new MainThread[ENSEMBLE_SERVERS];    zk = new ZooKeeper[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain();            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    QuorumPeerMainTest.waitForAll(zk, States.CONNECTED);        leaderId = -1;    followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }}
1
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain();}
0
public void tearDown() throws Exception
{    if (mt != null) {        for (MainThread t : mt) {            t.shutdown();        }    }    if (zk != null) {        for (ZooKeeper z : zk) {            z.close();        }    }}
0
public void testMultiOpConsistency() throws Exception
{        final String path = "/testMultiOpConsistency";    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);        CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();    final ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    String node1 = path + "/1";    String node2 = path + "/2";    dt.addNodeCreateListener(node2, new NodeCreateListener() {        @Override        public void process(String path) {                        zkServer.takeSnapshot(true);        }    });        zk[followerA].multi(Arrays.asList(Op.create(node1, node1.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(node2, node2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        assertEquals(new String(zk[leaderId].getData(node2, null, null)), new String(zk[followerA].getData(node2, null, null)));}
1
public void process(String path)
{        zkServer.takeSnapshot(true);}
1
public void testPZxidUpdatedDuringSnapSyncing() throws Exception
{        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");    final String parent = "/testPZxidUpdatedWhenDeletingNonExistNode";    final String child = parent + "/child";    createEmptyNode(zk[leaderId], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[leaderId], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);        addSerializeListener(leaderId, parent, child);        mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        compareStat(parent, leaderId, followerA);}
1
public void testPZxidUpdatedWhenLoadingSnapshot() throws Exception
{    final String parent = "/testPZxidUpdatedDuringTakingSnapshot";    final String child = parent + "/child";    createEmptyNode(zk[followerA], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[followerA], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);        addSerializeListener(followerA, parent, child);        ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    zkServer.takeSnapshot(true);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CLOSED);    mt[followerA].start();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        compareStat(parent, leaderId, followerA);}
1
private void addSerializeListener(int sid, String parent, String child)
{    final ZooKeeper zkClient = zk[sid];    CustomDataTree dt = (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();    dt.addListener(parent, new NodeSerializeListener() {        @Override        public void nodeSerialized(String path) {            try {                zkClient.delete(child, -1);                zkClient.close();                            } catch (Exception e) {                            }        }    });}
1
public void nodeSerialized(String path)
{    try {        zkClient.delete(child, -1);        zkClient.close();            } catch (Exception e) {            }}
1
private void compareStat(String path, int sid, int compareWithSid) throws Exception
{    ZooKeeper[] compareZk = new ZooKeeper[2];    compareZk[0] = new ZooKeeper("127.0.0.1:" + clientPorts[sid], ClientBase.CONNECTION_TIMEOUT, this);    compareZk[1] = new ZooKeeper("127.0.0.1:" + clientPorts[compareWithSid], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForAll(compareZk, States.CONNECTED);    try {        Stat stat1 = new Stat();        compareZk[0].getData(path, null, stat1);        Stat stat2 = new Stat();        compareZk[1].getData(path, null, stat2);        assertEquals(stat1, stat2);    } finally {        for (ZooKeeper z : compareZk) {            z.close();        }    }}
0
public void testGlobalSessionConsistency() throws Exception
{        CustomizedQPMain followerAMain = (CustomizedQPMain) mt[followerA].main;    final ZooKeeperServer zkServer = followerAMain.quorumPeer.getActiveServer();        final AtomicBoolean shouldTakeSnapshot = new AtomicBoolean(true);    followerAMain.setCommitSessionListener(new CommitSessionListener() {        @Override        public void process(long sessionId) {                        if (shouldTakeSnapshot.getAndSet(false)) {                zkServer.takeSnapshot(true);            }        }    });        ZooKeeper globalClient = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(globalClient, States.CONNECTED);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        Map<Long, Integer> globalSessionsOnLeader = mt[leaderId].main.quorumPeer.getZkDb().getSessionWithTimeOuts();    Map<Long, Integer> globalSessionsOnFollowerA = mt[followerA].main.quorumPeer.getZkDb().getSessionWithTimeOuts();        assertTrue(globalSessionsOnFollowerA.keySet().containsAll(globalSessionsOnLeader.keySet()));}
1
public void process(long sessionId)
{        if (shouldTakeSnapshot.getAndSet(false)) {        zkServer.takeSnapshot(true);    }}
1
private void createEmptyNode(ZooKeeper zk, String path, CreateMode mode) throws Exception
{    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, mode);}
0
public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException
{    super.serializeNodeData(oa, path, node);    NodeSerializeListener listener = listeners.get(path);    if (listener != null) {        listener.nodeSerialized(path);    }}
0
public void addListener(String path, NodeSerializeListener listener)
{    listeners.put(path, listener);}
0
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws NoNodeException, NodeExistsException
{    NodeCreateListener listener = nodeCreateListeners.get(path);    if (listener != null) {        listener.process(path);    }    super.createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, outputStat);}
0
public void addNodeCreateListener(String path, NodeCreateListener listener)
{    nodeCreateListeners.put(path, listener);}
0
public void setCommitSessionListener(CommitSessionListener listener)
{    this.commitSessionListener = listener;}
0
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer() {        @Override        public void setZKDatabase(ZKDatabase database) {            super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {                @Override                public DataTree createDataTree() {                    return new CustomDataTree();                }            });        }        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {                @Override                public void createSessionTracker() {                    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                            if (commitSessionListener != null) {                                commitSessionListener.process(sessionId);                            }                            return super.commitSession(sessionId, sessionTimeout);                        }                    };                }            });        }    };}
0
public void setZKDatabase(ZKDatabase database)
{    super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {        @Override        public DataTree createDataTree() {            return new CustomDataTree();        }    });}
0
public DataTree createDataTree()
{    return new CustomDataTree();}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        public void createSessionTracker() {            sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                    if (commitSessionListener != null) {                        commitSessionListener.process(sessionId);                    }                    return super.commitSession(sessionId, sessionTimeout);                }            };        }    });}
0
public void createSessionTracker()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {            if (commitSessionListener != null) {                commitSessionListener.process(sessionId);            }            return super.commitSession(sessionId, sessionTimeout);        }    };}
0
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    if (commitSessionListener != null) {        commitSessionListener.process(sessionId);    }    return super.commitSession(sessionId, sessionTimeout);}
0
public void setUp() throws IOException, X509Exception
{    qp = new QuorumPeer();    long myId = qp.getId();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    quorumVerifierMock = mock(QuorumVerifier.class);    when(quorumVerifierMock.getAllMembers()).thenReturn(peersView);    qp.setQuorumVerifier(quorumVerifierMock, false);    File tmpDir = ClientBase.createEmptyTestDir();    fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZKDatabase zkDb = new ZKDatabase(fileTxnSnapLog);    zks = new LeaderZooKeeperServer(fileTxnSnapLog, qp, zkDb);    leader = new Leader(qp, zks);    leaderBean = new LeaderBean(leader, zks);}
0
public void tearDown() throws IOException
{    fileTxnSnapLog.close();}
0
public void testGetName()
{    assertEquals("Leader", leaderBean.getName());}
0
public void testGetCurrentZxid()
{        zks.setZxid(1);        assertEquals("0x1", leaderBean.getCurrentZxid());}
0
public void testGetElectionTimeTaken()
{        qp.setElectionTimeTaken(1);        assertEquals(1, leaderBean.getElectionTimeTaken());}
0
public void testGetProposalSize() throws IOException, Leader.XidRolloverException
{        Request req = createMockRequest();        leader.propose(req);        byte[] data = SerializeUtils.serializeRequest(req);    assertEquals(data.length, leaderBean.getLastProposalSize());    assertEquals(data.length, leaderBean.getMinProposalSize());    assertEquals(data.length, leaderBean.getMaxProposalSize());}
0
public void testResetProposalStats() throws IOException, Leader.XidRolloverException
{        int initialProposalSize = leaderBean.getLastProposalSize();    Request req = createMockRequest();        leader.propose(req);        assertNotEquals(initialProposalSize, leaderBean.getLastProposalSize());    leaderBean.resetProposalStatistics();    assertEquals(initialProposalSize, leaderBean.getLastProposalSize());    assertEquals(initialProposalSize, leaderBean.getMinProposalSize());    assertEquals(initialProposalSize, leaderBean.getMaxProposalSize());}
0
private Request createMockRequest() throws IOException
{    TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    return new Request(1, 2, 3, header, txn, 4);}
0
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
0
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
0
public void testFollowerInfo() throws IOException
{    Map<Long, QuorumServer> votingMembers = new HashMap<Long, QuorumServer>();    votingMembers.put(1L, null);    votingMembers.put(2L, null);    votingMembers.put(3L, null);    when(quorumVerifierMock.getVotingMembers()).thenReturn(votingMembers);    LearnerHandler follower = mock(LearnerHandler.class);    when(follower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(follower.toString()).thenReturn("1");    when(follower.getSid()).thenReturn(1L);    leader.addLearnerHandler(follower);    leader.addForwardingFollower(follower);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler observer = mock(LearnerHandler.class);    when(observer.getLearnerType()).thenReturn(LearnerType.OBSERVER);    when(observer.toString()).thenReturn("2");    leader.addLearnerHandler(observer);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler nonVotingFollower = mock(LearnerHandler.class);    when(nonVotingFollower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(nonVotingFollower.toString()).thenReturn("5");    when(nonVotingFollower.getSid()).thenReturn(5L);    leader.addLearnerHandler(nonVotingFollower);    leader.addForwardingFollower(nonVotingFollower);    String followerInfo = leaderBean.followerInfo();    assertTrue(followerInfo.contains("1"));    assertTrue(followerInfo.contains("5"));    assertEquals("5\n", leaderBean.nonVotingFollowerInfo());}
0
public void process(WatchedEvent e)
{    createdLatch.countDown();}
0
public void setup()
{    oldLoggingFeq = Leader.getAckLoggingFrequency();}
0
public void teardown()
{    Leader.setAckLoggingFrequency(oldLoggingFeq);}
0
public void testLeaderMetrics() throws Exception
{        Leader.setAckLoggingFrequency(1);    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    createdLatch = new CountDownLatch(1);    zk.exists("/test", new MyWatcher());    zk.create("/test", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    createdLatch.await();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("proposal_count"));        assertEquals(2L, values.get("cnt_quorum_ack_latency"));    assertThat((long) values.get("min_quorum_ack_latency"), greaterThan(0L));    int numberOfAckServers = 0;        for (int sid = 1; sid <= 3; sid++) {        String metricName = "min_" + sid + "_ack_latency";        if (values.get(metricName) != null) {            numberOfAckServers++;            assertThat((long) values.get("min_" + sid + "_ack_latency"), greaterThanOrEqualTo(0L));        }    }        assertThat(numberOfAckServers, greaterThanOrEqualTo(2));    zk.close();    util.shutdownAll();}
0
public void setUp() throws Exception
{    tmpDir = ClientBase.createTmpDir();    peer = createQuorumPeer(tmpDir);    participantId = 1;    Map<Long, QuorumPeer.QuorumServer> peers = peer.getQuorumVerifier().getAllMembers();    observerId = peers.size();    leader = createLeader(tmpDir, peer);    peer.leader = leader;    peers.put(observerId, new QuorumPeer.QuorumServer(observerId, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), QuorumPeer.LearnerType.OBSERVER));        peer.tickTime = 1;}
0
public void tearDown()
{    leader.shutdown("end of test");    tmpDir.delete();}
0
public void testGetEpochToPropose() throws Exception
{    long lastAcceptedEpoch = 5;    peer.setAcceptedEpoch(5);    assertEquals("Unexpected vote in connectingFollowers", 0, leader.connectingFollowers.size());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(peer.getId(), lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch until quorum of participants is in connectingFollowers", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                leader.getEpochToPropose(observerId, lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch after observer asks for epoch", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(participantId, lastAcceptedEpoch);    } catch (Exception e) {        fail("Timed out in getEpochToPropose");    }    assertEquals("Unexpected vote in connectingFollowers", 2, leader.connectingFollowers.size());    assertEquals("Leader should record next epoch", lastAcceptedEpoch + 1, peer.getAcceptedEpoch());    assertFalse(leader.waitingForNewEpoch);}
0
public void testWaitForEpochAck() throws Exception
{        leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());    assertEquals("Unexpected vote in electingFollowers", 0, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(peer.getId(), new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(observerId, new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(participantId, new StateSummary(0, 0));        assertEquals("Unexpected vote in electingFollowers", 2, leader.electingFollowers.size());        assertTrue(leader.electionFinished);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
0
public void testWaitForNewLeaderAck() throws Exception
{    long zxid = leader.zk.getZxid();        leader.newLeaderProposal.packet = new QuorumPacket(0, zxid, null, null);    leader.newLeaderProposal.addQuorumVerifier(peer.getQuorumVerifier());    Set<Long> ackSet = leader.newLeaderProposal.qvAcksetPairs.get(0).getAckset();    assertEquals("Unexpected vote in ackSet", 0, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(peer.getId(), zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(observerId, zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(participantId, zxid);        assertEquals("Unexpected vote in ackSet", 2, ackSet.size());        assertTrue(leader.quorumFormed);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
0
public void setup() throws IOException
{    Leader leader = mock(Leader.class);    when(leader.getQuorumAuthServer()).thenReturn(null);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(new InetSocketAddress(32));        BinaryOutputArchive oa = mock(BinaryOutputArchive.class);    doAnswer(invocationOnMock -> {        Thread.sleep(5);        return null;    }).when(oa).writeRecord(any(QuorumPacket.class), anyString());    BufferedOutputStream bos = mock(BufferedOutputStream.class);        doAnswer(invocationOnMock -> {        if (allSentLatch != null) {            allSentLatch.countDown();        }        return null;    }).when(bos).flush();    learnerHandler = new MockLearnerHandler(socket, leader);    learnerHandler.setOutputArchive(oa);    learnerHandler.setBufferedOutput(bos);    learnerHandler.sid = sid;}
0
public void testMetrics() throws InterruptedException
{    ServerMetrics.getMetrics().resetAll();        for (int i = 0; i < 1001; i++) {        learnerHandler.queuePacket(new QuorumPacket());    }    allSentLatch = new CountDownLatch(1);    learnerHandler.startSendingPackets();    allSentLatch.await(8, TimeUnit.SECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    String sidStr = Long.toString(sid);        assertEquals(2L, values.get("cnt_" + sidStr + "_learner_handler_qp_time_ms"));            assertThat((long) values.get("max_" + sidStr + "_learner_handler_qp_time_ms"), greaterThan(5000L));        assertEquals(1003L, values.get("cnt_" + sidStr + "_learner_handler_qp_size"));        assertEquals(1002L, values.get("max_" + sidStr + "_learner_handler_qp_size"));        assertEquals(0L, values.get("min_" + sidStr + "_learner_handler_qp_size"));}
0
protected void startSendingPackets()
{    threadStarted = true;}
0
protected boolean shouldSendMarkerPacketForLogging()
{    return false;}
0
public long getDataTreeLastProcessedZxid()
{    return lastProcessedZxid;}
0
public long getmaxCommittedLog()
{    if (!committedLog.isEmpty()) {        return committedLog.getLast().packet.getZxid();    }    return 0;}
0
public long getminCommittedLog()
{    if (!committedLog.isEmpty()) {        return committedLog.getFirst().packet.getZxid();    }    return 0;}
0
public List<Proposal> getCommittedLog()
{    return committedLog;}
0
public ReentrantReadWriteLock getLogLock()
{    return lock;}
0
public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit)
{    if (peerZxid >= txnLog.peekFirst().packet.getZxid()) {        return txnLog.iterator();    } else {        return Collections.emptyIterator();    }}
0
public long calculateTxnLogSizeLimit()
{    return 1;}
0
public void setUp() throws Exception
{    db = new MockZKDatabase(null);    sock = mock(Socket.class);        leader = mock(Leader.class);    when(leader.startForwarding(ArgumentMatchers.any(LearnerHandler.class), ArgumentMatchers.anyLong())).thenAnswer(new Answer<Long>() {        public Long answer(InvocationOnMock invocation) {            currentZxid = invocation.getArgument(1);            return 0L;        }    });    when(leader.getZKDatabase()).thenReturn(db);    learnerHandler = new MockLearnerHandler(sock, leader);}
0
public Long answer(InvocationOnMock invocation)
{    currentZxid = invocation.getArgument(1);    return 0L;}
0
 Proposal createProposal(long zxid)
{    Proposal p = new Proposal();    p.packet = new QuorumPacket();    p.packet.setZxid(zxid);    p.packet.setType(Leader.PROPOSAL);    return p;}
0
public void queuedPacketMatches(long[] zxids)
{    int index = 0;    for (QuorumPacket qp : learnerHandler.getQueuedPackets()) {        if (qp.getType() == Leader.PROPOSAL) {            assertZxidEquals(zxids[index++], qp.getZxid());        }    }}
0
 void reset()
{    learnerHandler.getQueuedPackets().clear();    learnerHandler.threadStarted = false;    learnerHandler.setFirstPacket(true);}
0
public void assertOpType(int type, long zxid, long currentZxid)
{    Queue<QuorumPacket> packets = learnerHandler.getQueuedPackets();    assertTrue(packets.size() > 0);    assertEquals(type, packets.peek().getType());    assertZxidEquals(zxid, packets.peek().getZxid());    assertZxidEquals(currentZxid, this.currentZxid);}
0
 void assertZxidEquals(long expected, long value)
{    assertEquals("Expected 0x" + Long.toHexString(expected) + " but was 0x" + Long.toHexString(value), expected, value);}
0
public void testEmptyCommittedLog() throws Exception
{    long peerZxid;        peerZxid = 3;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, db.lastProcessedZxid, db.lastProcessedZxid);    reset();        peerZxid = 1;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);    assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();            peerZxid = 0;    db.setSnapshotSizeFactor(-1);    db.lastProcessedZxid = 1;    db.committedLog.clear();        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
0
public void testCommittedLog() throws Exception
{    long peerZxid;            db.lastProcessedZxid = 6;    db.committedLog.add(createProposal(2));    db.committedLog.add(createProposal(3));    db.committedLog.add(createProposal(5));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, 5);        assertEquals(3, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5 });    reset();        peerZxid = 1;    db.setSnapshotSizeFactor(-1);        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
0
public void testTxnLog() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));    db.txnLog.add(createProposal(9));    db.lastProcessedZxid = 9;    db.committedLog.add(createProposal(6));    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();        peerZxid = 3;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();}
0
public void testTxnLogProposalIteratorClosure() throws Exception
{    long peerZxid;        db = new MockZKDatabase(null) {        @Override        public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit) {            return TxnLogProposalIterator.EMPTY_ITERATOR;        }    };    db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    when(leader.getZKDatabase()).thenReturn(db);        peerZxid = 4;    assertTrue("Couldn't identify snapshot transfer!", learnerHandler.syncFollower(peerZxid, leader));    reset();}
0
public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit)
{    return TxnLogProposalIterator.EMPTY_ITERATOR;}
0
public void testTxnLogOnly() throws Exception
{    long peerZxid;        db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));            assertOpType(Leader.TRUNC, 3, db.lastProcessedZxid);        assertEquals(7, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5, 6, 7 });    reset();        peerZxid = 1;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));        assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
0
 long getZxid(long epoch, long counter)
{    return ZxidUtils.makeZxid(epoch, counter);}
0
public void testTxnLogWithNegativeZxid() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0xf, 2)));    db.txnLog.add(createProposal(getZxid(0xf, 3)));    db.txnLog.add(createProposal(getZxid(0xf, 5)));    db.txnLog.add(createProposal(getZxid(0xf, 6)));    db.txnLog.add(createProposal(getZxid(0xf, 7)));    db.txnLog.add(createProposal(getZxid(0xf, 8)));    db.txnLog.add(createProposal(getZxid(0xf, 9)));    db.lastProcessedZxid = getZxid(0xf, 9);    db.committedLog.add(createProposal(getZxid(0xf, 6)));    db.committedLog.add(createProposal(getZxid(0xf, 7)));    db.committedLog.add(createProposal(getZxid(0xf, 8)));        peerZxid = getZxid(0xf, 4);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, getZxid(0xf, 3), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();        peerZxid = getZxid(0xf, 3);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();}
0
public void testNewEpochZxid() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(0, 0);                assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();        peerZxid = getZxid(2, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(2, 0), getZxid(2, 0));        assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();}
0
public void testDuplicatedTxn() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();}
0
public void testCrossEpochTrunc() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(2, 1)));    db.txnLog.add(createProposal(getZxid(2, 2)));    db.txnLog.add(createProposal(getZxid(4, 1)));        db.lastProcessedZxid = getZxid(6, 0);        peerZxid = getZxid(3, 1);    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
0
public void testTxnLogGap() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(4));    db.lastProcessedZxid = 8;    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 3;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    reset();}
0
public void testLearnerMetricsTest() throws Exception
{    ServerMetrics.getMetrics().resetAll();    ClientBase.setupTestEnv();    final String path = "/zk-testLeanerMetrics";    final byte[] data = new byte[512];    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    int observer = 0;    clientPorts[observer] = PortAssignment.unique();    sb.append("server." + observer + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer\n");    for (int i = 1; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\n");    }        String quorumCfgSection = sb.toString();    for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();    }        Map<String, String> observerConfig = new HashMap<>();    observerConfig.put("peerType", "observer");    mt[observer] = new QuorumPeerTestBase.MainThread(observer, clientPorts[observer], quorumCfgSection, observerConfig);    mt[observer].start();            zk_client = new ZooKeeper("127.0.0.1:" + clientPorts[observer], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk_client, ZooKeeper.States.CONNECTED);        zk_client.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            waitForMetric("learner_proposal_received_count", is(4L));    waitForMetric("cnt_proposal_latency", is(4L));    waitForMetric("min_proposal_latency", greaterThanOrEqualTo(0L));        waitForMetric("cnt_proposal_ack_creation_latency", is(6L));    waitForMetric("min_proposal_ack_creation_latency", greaterThanOrEqualTo(0L));            waitForMetric("learner_commit_received_count", is(6L));    waitForMetric("cnt_commit_propagation_latency", is(6L));    waitForMetric("min_commit_propagation_latency", greaterThanOrEqualTo(0L));}
0
private void waitForMetric(final String metricKey, final Matcher<Long> matcher) throws InterruptedException
{    final String errorMessage = String.format("unable to match on metric: %s", metricKey);    waitFor(errorMessage, () -> {        long actual = (long) MetricsUtils.currentServerMetrics().get(metricKey);        if (!matcher.matches(actual)) {                        return false;        }        return true;    }, TIMEOUT_SECONDS);}
1
public void tearDown() throws Exception
{    zk_client.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public static Collection syncTypes()
{    return Arrays.asList(new Object[][] { { LearnerSyncThrottler.SyncType.DIFF }, { LearnerSyncThrottler.SyncType.SNAP } });}
0
public void testTooManySyncsNonessential() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    for (int i = 0; i < 6; i++) {        throttler.beginSync(false);    }}
0
public void testTooManySyncsEssential() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    throttler.beginSync(false);}
0
public void testNoThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    for (int i = 0; i < 5; i++) {        throttler.endSync();        throttler.beginSync(false);    }    assertTrue("should get here without exception", true);}
0
public void testTryWithResourceNoThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    for (int i = 0; i < 3; i++) {        throttler.beginSync(false);        try {            assertEquals(1, throttler.getSyncInProgress());        } finally {            throttler.endSync();        }    }}
0
public void testTryWithResourceThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    try {        throttler.beginSync(true);        try {            throttler.beginSync(false);            fail("shouldn't be able to have both syncs open");        } catch (SyncThrottleException e) {        }        throttler.endSync();    } catch (SyncThrottleException e) {        fail("First sync shouldn't be throttled");    }}
0
public void testParallelNoThrottle()
{    final int numThreads = 50;    final LearnerSyncThrottler throttler = new LearnerSyncThrottler(numThreads, syncType);    ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);    final CountDownLatch threadStartLatch = new CountDownLatch(numThreads);    final CountDownLatch syncProgressLatch = new CountDownLatch(numThreads);    List<Future<Boolean>> results = new ArrayList<Future<Boolean>>(numThreads);    for (int i = 0; i < numThreads; i++) {        results.add(threadPool.submit(new Callable<Boolean>() {            @Override            public Boolean call() {                threadStartLatch.countDown();                try {                    threadStartLatch.await();                    throttler.beginSync(false);                    syncProgressLatch.countDown();                    syncProgressLatch.await();                    throttler.endSync();                } catch (Exception e) {                    return false;                }                return true;            }        }));    }    try {        for (Future<Boolean> result : results) {            assertTrue(result.get());        }    } catch (Exception e) {    } finally {        threadPool.shutdown();    }}
0
public Boolean call()
{    threadStartLatch.countDown();    try {        threadStartLatch.await();        throttler.beginSync(false);        syncProgressLatch.countDown();        syncProgressLatch.await();        throttler.endSync();    } catch (Exception e) {        return false;    }    return true;}
0
public Learner getLearner()
{    return learner;}
0
public void setTimeMultiplier(long multiplier)
{    timeMultiplier = multiplier;}
0
public void setPassConnectAttempt(int num)
{    passSocketConnectOnAttempt = num;}
0
protected long nanoTime()
{    return socketConnectAttempt * timeMultiplier;}
0
protected int getSockConnectAttempt()
{    return socketConnectAttempt;}
0
protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    if (++socketConnectAttempt < passSocketConnectOnAttempt) {        throw new IOException("Test injected Socket.connect() error.");    }}
0
public void connectionRetryTimeoutTest() throws Exception
{    Learner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.connectToLeader(addr, "");}
0
public void connectionInitLimitTimeoutTest() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);        try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {                assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
0
public void connectToLearnerMasterLimitTest() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(2);    learner.self.setSyncLimit(2);    learner.self.setConnectToLearnerMasterLimit(5);    InetSocketAddress addr = new InetSocketAddress(1111);    learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);    try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {        assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
0
public void syncTest() throws Exception
{    File tmpFile = File.createTempFile("test", ".dir", testData);    tmpFile.delete();    try {        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpFile, tmpFile);        SimpleLearner sl = new SimpleLearner(ftsl);        long startZxid = sl.zk.getLastProcessedZxid();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        sl.leaderOs = BinaryOutputArchive.getArchive(new ByteArrayOutputStream());                sl.bufferedOutput = new BufferedOutputStream(System.out);        sl.sock = new Socket();                QuorumPacket qp = new QuorumPacket(Leader.SNAP, 0, null, null);        oa.writeRecord(qp, null);        sl.zk.getZKDatabase().serializeSnapshot(oa);        oa.writeString("BenWasHere", "signature");        TxnHeader hdr = new TxnHeader(0, 0, 0, 0, ZooDefs.OpCode.create);        CreateTxn txn = new CreateTxn("/foo", new byte[0], new ArrayList<ACL>(), false, sl.zk.getZKDatabase().getNode("/").stat.getCversion());        ByteArrayOutputStream tbaos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(tbaos);        hdr.serialize(boa, "hdr");        txn.serialize(boa, "txn");        tbaos.close();        qp = new QuorumPacket(Leader.PROPOSAL, 1, tbaos.toByteArray(), null);        oa.writeRecord(qp, null);                sl.leaderIs = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));        try {            sl.syncWithLeader(3);        } catch (EOFException e) {        }        sl.zk.shutdown();        sl = new SimpleLearner(ftsl);        assertEquals(startZxid, sl.zk.getLastProcessedZxid());    } finally {        TestUtils.deleteFileRecursively(tmpFile);    }}
0
public void testClientAddress() throws Exception
{    QuorumPeer quorumPeer = new QuorumPeer();    LocalPeerBean remotePeerBean = new LocalPeerBean(quorumPeer);    /**     * Case 1: When cnxnFactory is null     */    String result = remotePeerBean.getClientAddress();    assertNotNull(result);    assertEquals(0, result.length());    /**     * Case 2: When only client port is configured     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int clientPort = PortAssignment.unique();    InetSocketAddress address = new InetSocketAddress(clientPort);    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String ipv4 = "0.0.0.0:" + clientPort;    String ipv6 = "[0:0:0:0:0:0:0:0]:" + clientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();    /**     * Case 3: When both client port and client address is configured     */    clientPort = PortAssignment.unique();    InetAddress clientIP = InetAddress.getLoopbackAddress();    address = new InetSocketAddress(clientIP, clientPort);    cnxnFactory = ServerCnxnFactory.createFactory();    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String expectedResult = clientIP.getHostAddress() + ":" + clientPort;    assertEquals(expectedResult, result);        cnxnFactory.shutdown();}
0
public void testLocalPeerIsLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(true);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertTrue(localPeerBean.isLeader());}
0
public void testLocalPeerIsNotLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(false);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertFalse(localPeerBean.isLeader());}
0
public void testGetNameProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    when(qpMock.getId()).thenReturn(1L);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("getName property should return Bean name in the right format", qb.getName(), equalTo("ReplicatedServer_id1"));}
0
public void testIsHiddenProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("isHidden should return false", qb.isHidden(), equalTo(false));}
0
public void testGetQuorumSizeProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.getQuorumSize()).thenReturn(5);    assertThat("getQuorumSize property should return value of peet.getQuorumSize()", qb.getQuorumSize(), equalTo(5));}
0
public void testSslQuorumProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.isSslQuorum()).thenReturn(true);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(true));    when(qpMock.isSslQuorum()).thenReturn(false);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(false));}
0
public void testPortUnificationProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.shouldUsePortUnification()).thenReturn(true);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(true));    when(qpMock.shouldUsePortUnification()).thenReturn(false);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(false));}
0
public void testErrorMessageWhensecureClientPortNotSetButsecureClientPortAddressSet() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("secureClientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "secureClientPortAddress is set but secureClientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
0
public void testErrorMessageWhenclientPortNotSetButclientPortAddressSet() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("clientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "clientPortAddress is set but clientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
0
public void testConfigureSSLAuthGetsConfiguredIfSecurePortConfigured() throws IOException, ConfigException
{    String sslAuthProp = "zookeeper.authProvider.x509";    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("secureClientPort", "12345");    quorumPeerConfig.parseProperties(zkProp);    String expected = "org.apache.zookeeper.server.auth.X509AuthenticationProvider";    String result = System.getProperty(sslAuthProp);    assertEquals(expected, result);}
0
public void testCustomSSLAuth() throws IOException
{    try (ClientX509Util x509Util = new ClientX509Util()) {        System.setProperty(x509Util.getSslAuthProviderProperty(), "y509");        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();        try {            Properties zkProp = getDefaultZKProperties();            zkProp.setProperty("secureClientPort", "12345");            quorumPeerConfig.parseProperties(zkProp);            fail("ConfigException is expected");        } catch (ConfigException e) {            assertNotNull(e.getMessage());        }    }}
0
public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("server.1", "localhost:2888:2888");    quorumPeerConfig.parseProperties(zkProp);}
0
public void testClientAddrFromClientPort() throws IOException, ConfigException
{    long serverId = 1;    QuorumPeerConfig quorumPeerConfig = new MockQuorumPeerConfig(serverId);    Properties zkProp = getDefaultZKProperties();    int clientPort = 12345;    zkProp.setProperty("clientPort", Integer.toString(clientPort));    zkProp.setProperty("server.1", "127.0.0.1:2889:3889:participant");    quorumPeerConfig.parseProperties(zkProp);    QuorumServer qs = quorumPeerConfig.getQuorumVerifier().getAllMembers().get(serverId);    InetSocketAddress expectedAddress = new InetSocketAddress("0.0.0.0", clientPort);    assertEquals(expectedAddress, quorumPeerConfig.getClientPortAddress());    assertEquals(quorumPeerConfig.getClientPortAddress(), qs.clientAddr);}
0
public void testJvmPauseMonitorConfigured() throws IOException, ConfigException
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    zkProp.setProperty("jvm.pause.monitor", "true");    zkProp.setProperty("jvm.pause.sleep.time.ms", sleepTime.toString());    zkProp.setProperty("jvm.pause.warn-threshold.ms", warnTH.toString());    zkProp.setProperty("jvm.pause.info-threshold.ms", infoTH.toString());    quorumPeerConfig.parseProperties(zkProp);    assertEquals(sleepTime, Long.valueOf(quorumPeerConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(quorumPeerConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(quorumPeerConfig.getJvmPauseInfoThresholdMs()));    assertTrue(quorumPeerConfig.isJvmPauseMonitorToRun());}
0
private Properties getDefaultZKProperties()
{    Properties zkProp = new Properties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    return zkProp;}
0
public void testQuorumInternal(String addr) throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String server1 = String.format("server.1=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1);    String server2 = String.format("server.2=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    String quorumCfgSection = server1 + "\n" + server2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    int tickTime = quorumPeer.getTickTime();    assertEquals("Default value of minimumSessionTimeOut is not considered", tickTime * 2, quorumPeer.getMinSessionTimeout());    assertEquals("Default value of maximumSessionTimeOut is not considered", tickTime * 20, quorumPeer.getMaxSessionTimeout());    ZooKeeper zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q2", "foobar2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q2", null, null)), "foobar2");    zk.close();    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
0
public void testQuorum() throws Exception
{    testQuorumInternal("127.0.0.1");}
0
public void testQuorumV6() throws Exception
{    testQuorumInternal("[::1]");}
0
public void testEarlyLeaderAbandonment() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();                zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);            int leader = -1;    Map<Long, Proposal> outstanding = null;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader == null) {            mt[i].shutdown();        } else {            leader = i;            outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;        }    }    try {        zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }            assertTrue(outstanding.size() == 1);    assertTrue(outstanding.values().iterator().next().request.getHdr().getType() == OpCode.create);        Thread.sleep(1000);    mt[leader].shutdown();    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            mt[i].start();        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);            waitForOne(zk[i], States.CONNECTED);            zk[i].create("/zk" + i, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    mt[leader].start();    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        for (int j = 0; j < SERVER_COUNT; j++) {            if (i == leader) {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " should not have /zk" + i, zk[j].exists("/zk" + i, false) == null);            } else {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " does not have /zk" + i, zk[j].exists("/zk" + i, false) != null);            }        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public void testHighestZxidJoinLate() throws Exception
{    numServers = 3;    servers = LaunchServers(numServers);    String path = "/hzxidtest";    int leader = servers.findLeader();        assertTrue("There should be a leader", leader >= 0);    int nonleader = (leader + 1) % numServers;    byte[] input = new byte[1];    input[0] = 1;    byte[] output;        servers.zk[leader].create(path + leader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    servers.zk[leader].create(path + nonleader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            output = servers.zk[leader].getData(path + nonleader, false, null);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }    input[0] = 2;        servers.zk[leader].setData(path + leader, input, -1, null, null);        Thread.sleep(500);        servers.mt[leader].shutdown();    System.gc();    waitForAll(servers.zk, States.CONNECTING);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        waitForOne(servers.zk[nonleader], States.CONNECTED);        output = servers.zk[nonleader].getData(path + leader, false, null);    assertEquals("Expecting old value 1 since 2 isn't committed yet", output[0], 1);            servers.zk[nonleader].setData(path + nonleader, input, -1);        servers.mt[leader].start();        waitForOne(servers.zk[leader], States.CONNECTED);        output = servers.zk[leader].getData(path + leader, false, null);    assertEquals("Validating that the deposed leader has rolled back that change it had written", output[0], 1);        output = servers.zk[leader].getData(path + nonleader, false, null);    assertEquals("Validating that the deposed leader caught up on changes it missed", output[0], 2);}
0
public void testElectionFraud() throws IOException, InterruptedException
{        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger(QuorumPeer.class);    qlogger.addAppender(appender);    numServers = 3;        boolean foundLeading = false;    boolean foundLooking = false;    boolean foundFollowing = false;    try {                servers = LaunchServers(numServers, 500);                int trueLeader = servers.findLeader();        assertTrue("There should be a leader", trueLeader >= 0);                int falseLeader = (trueLeader + 1) % numServers;        assertTrue("All servers should join the quorum", servers.mt[falseLeader].main.quorumPeer.follower != null);                        servers.mt[falseLeader].main.quorumPeer.electionAlg.shutdown();        servers.mt[falseLeader].main.quorumPeer.follower.getSocket().close();                waitForOne(servers.zk[falseLeader], States.CONNECTING);                servers.mt[falseLeader].main.quorumPeer.setPeerState(QuorumPeer.ServerState.LEADING);                        Thread.sleep(2 * servers.mt[falseLeader].main.quorumPeer.initLimit * servers.mt[falseLeader].main.quorumPeer.tickTime);                servers.mt[falseLeader].main.quorumPeer.startLeaderElection();                servers.zk[falseLeader] = new ZooKeeper("127.0.0.1:" + servers.mt[falseLeader].getClientPort(), ClientBase.CONNECTION_TIMEOUT, this);                waitForOne(servers.zk[falseLeader], States.CONNECTED);                assertTrue(servers.mt[trueLeader].main.quorumPeer.leader != null);                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=" + falseLeader + ".*LEADING.*");        Pattern looking = Pattern.compile(".*myid=" + falseLeader + ".*LOOKING.*");        Pattern following = Pattern.compile(".*myid=" + falseLeader + ".*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null) {            if (!foundLeading) {                foundLeading = leading.matcher(line).matches();            } else if (!foundLooking) {                foundLooking = looking.matcher(line).matches();            } else if (following.matcher(line).matches()) {                foundFollowing = true;                break;            }        }    } finally {        qlogger.removeAppender(appender);    }    assertTrue("falseLeader never attempts to become leader", foundLeading);    assertTrue("falseLeader never gives up on leadership", foundLooking);    assertTrue("falseLeader never rejoins the quorum", foundFollowing);}
0
public void testBadPeerAddressInQuorum() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=fee.fii.foo.fum:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Cannot open channel to .* at election address .*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about host", found);}
0
public void testInconsistentPeerType() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);        try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        final int CLIENT_PORT_QP3 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer" + ";" + CLIENT_PORT_QP3;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgSection);        q1.start();        q2.start();        q3.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP3, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean warningPresent = false;    boolean defaultedToObserver = false;    Pattern pWarn = Pattern.compile(".*Peer type from servers list.* doesn't match peerType.*");    Pattern pObserve = Pattern.compile(".*OBSERVING.*");    while ((line = r.readLine()) != null) {        if (pWarn.matcher(line).matches()) {            warningPresent = true;        }        if (pObserve.matcher(line).matches()) {            defaultedToObserver = true;        }        if (warningPresent && defaultedToObserver) {            break;        }    }    assertTrue("Should warn about inconsistent peer type", warningPresent && defaultedToObserver);}
0
public void testBadPackets() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    int electionPort1 = PortAssignment.unique();    int electionPort2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort1 + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort2 + ";" + CLIENT_PORT_QP2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    byte[] b = new byte[4];    int length = 1024 * 1024 * 1024;    ByteBuffer buff = ByteBuffer.wrap(b);    buff.putInt(length);    buff.position(0);    SocketChannel s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort1));    s.write(buff);    s.close();    buff.position(0);    s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort2));    s.write(buff);    s.close();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    q1.shutdown();    q2.shutdown();}
0
public void testQuorumDefaults() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    appender.setImmediateFlush(true);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        q1.start();        q2.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*FastLeaderElection.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("fastleaderelection used", found);}
0
public void testQuorumPeerExitTime() throws Exception
{    long maxwait = 3000;    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + PortAssignment.unique();    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();        Thread.sleep(30000);    long start = Time.currentElapsedTime();    q1.shutdown();    long end = Time.currentElapsedTime();    if ((end - start) > maxwait) {        fail("QuorumPeer took " + (end - start) + " to shutdown, expected " + maxwait);    }}
0
public void testMinMaxSessionTimeOut() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 10000;    final int maxSessionTimeOut = 15000;    final String configs = "maxSessionTimeout=" + maxSessionTimeOut + "\n" + "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is not considered", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
0
public void testWithOnlyMinSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 15000;    final String configs = "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    final int maxSessionTimeOut = quorumPeer.tickTime * 20;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is wrong", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
0
public void testFailedTxnAsPartOfQuorumLoss() throws Exception
{    final int LEADER_TIMEOUT_MS = 10_000;        ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    servers = LaunchServers(SERVER_COUNT);    waitForAll(servers, States.CONNECTED);            servers.shutDownAllServers();    waitForAll(servers, States.CONNECTING);    servers.restartAllServersAndClients(this);    waitForAll(servers, States.CONNECTED);        int leader = servers.findLeader();    Map<Long, Proposal> outstanding = servers.mt[leader].main.quorumPeer.leader.outstandingProposals;        int previousTick = servers.mt[leader].main.quorumPeer.tickTime;    servers.mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;        Thread.sleep(previousTick);        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        servers.restartClient(i, this);            waitForOne(servers.zk[i], States.CONNECTED);        }    }        try {        servers.zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }                assertTrue(outstanding.size() > 0);    Proposal p = findProposalOfType(outstanding, OpCode.create);        assertNotNull("Old leader doesn't have 'create' proposal", p);        int sleepTime = 0;    Long longLeader = Long.valueOf(leader);    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {        if (sleepTime > 2000) {            fail("Transaction not synced to disk within 1 second " + p.qvAcksetPairs.get(0).getAckset() + " expected " + leader);        }        Thread.sleep(100);        sleepTime += 100;    }            sleepTime = 0;    Follower f = servers.mt[leader].main.quorumPeer.follower;    while (f == null || !f.isRunning()) {        if (sleepTime > LEADER_TIMEOUT_MS * 2) {            fail("Took too long for old leader to time out " + servers.mt[leader].main.quorumPeer.getPeerState());        }        Thread.sleep(100);        sleepTime += 100;        f = servers.mt[leader].main.quorumPeer.follower;    }    int newLeader = servers.findLeader();        assertNotEquals(leader, newLeader);        servers.mt[leader].shutdown();    servers.mt[leader].start();        servers.restartClient(leader, this);    waitForAll(servers, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        assertNull("server " + i + " should not have /zk" + leader, servers.zk[i].exists("/zk" + leader, false));    }}
1
public void testLeaderOutOfView() throws Exception
{    ClientBase.setupTestEnv();    int numServers = 3;        boolean foundLeading = false;    boolean foundFollowing = false;        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.DEBUG);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        Servers svrs = new Servers();        svrs.clientPorts = new int[numServers];        for (int i = 0; i < numServers; i++) {            svrs.clientPorts[i] = PortAssignment.unique();        }        String quorumCfgIncomplete = getUniquePortCfgForId(1) + "\n" + getUniquePortCfgForId(2);        String quorumCfgComplete = quorumCfgIncomplete + "\n" + getUniquePortCfgForId(3);        svrs.mt = new MainThread[3];                svrs.mt[0] = new MainThread(1, svrs.clientPorts[0], quorumCfgIncomplete);        for (int i = 1; i < numServers; i++) {            svrs.mt[i] = new MainThread(i + 1, svrs.clientPorts[i], quorumCfgComplete);        }                svrs.mt[0].start();        QuorumPeer quorumPeer1 = waitForQuorumPeer(svrs.mt[0], CONNECTION_TIMEOUT);        assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);                int highestServerIndex = numServers - 1;        svrs.mt[highestServerIndex].start();        QuorumPeer quorumPeer3 = waitForQuorumPeer(svrs.mt[highestServerIndex], CONNECTION_TIMEOUT);        assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);                for (int i = 1; i < highestServerIndex; i++) {            svrs.mt[i].start();        }                for (int i = 1; i < numServers; i++) {            assertTrue("waiting for server to start", ClientBase.waitForServerUp("127.0.0.1:" + svrs.clientPorts[i], CONNECTION_TIMEOUT));        }        assertTrue(svrs.mt[0].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);        assertTrue(svrs.mt[highestServerIndex].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);        for (int i = 1; i < highestServerIndex; i++) {            assertTrue(svrs.mt[i].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);        }                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=1.*QuorumPeer.*LEADING.*");        Pattern following = Pattern.compile(".*myid=1.*QuorumPeer.*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null && !foundLeading && !foundFollowing) {            foundLeading = leading.matcher(line).matches();            foundFollowing = following.matcher(line).matches();        }    } finally {        qlogger.removeAppender(appender);    }    assertFalse("Corrupt peer should never become leader", foundLeading);    assertFalse("Corrupt peer should not attempt connection to out of view leader", foundFollowing);}
0
public void testDataDirAndDataLogDir() throws Exception
{    File dataDir = createEmptyTestDir();    File dataLogDir = createEmptyTestDir();        try {        QuorumPeerConfig configMock = mock(QuorumPeerConfig.class);        when(configMock.getDataDir()).thenReturn(dataDir);        when(configMock.getDataLogDir()).thenReturn(dataLogDir);        when(configMock.getMetricsProviderClassName()).thenReturn(NullMetricsProvider.class.getName());        QuorumPeer qpMock = mock(QuorumPeer.class);        doCallRealMethod().when(qpMock).setTxnFactory(any(FileTxnSnapLog.class));        when(qpMock.getTxnFactory()).thenCallRealMethod();        InjectableQuorumPeerMain qpMain = new InjectableQuorumPeerMain(qpMock);                qpMain.runFromConfig(configMock);                FileTxnSnapLog txnFactory = qpMain.getQuorumPeer().getTxnFactory();        assertEquals(Paths.get(dataLogDir.getAbsolutePath(), "version-2").toString(), txnFactory.getDataDir().getAbsolutePath());        assertEquals(Paths.get(dataDir.getAbsolutePath(), "version-2").toString(), txnFactory.getSnapDir().getAbsolutePath());    } finally {        FileUtils.deleteDirectory(dataDir);        FileUtils.deleteDirectory(dataLogDir);    }}
0
protected QuorumPeer getQuorumPeer()
{    return qp;}
0
private WriterAppender getConsoleAppender(ByteArrayOutputStream os, Level level)
{    String loggingPattern = ((PatternLayout) Logger.getRootLogger().getAppender("CONSOLE").getLayout()).getConversionPattern();    WriterAppender appender = new WriterAppender(new PatternLayout(loggingPattern), os);    appender.setThreshold(level);    return appender;}
0
private String getUniquePortCfgForId(int id)
{    return String.format("server.%d=127.0.0.1:%d:%d", id, PortAssignment.unique(), PortAssignment.unique());}
0
private QuorumPeer waitForQuorumPeer(MainThread mainThread, int timeout) throws TimeoutException
{    long start = Time.currentElapsedTime();    while (true) {        QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;        if (quorumPeer != null) {            return quorumPeer;        }        if (Time.currentElapsedTime() > start + timeout) {                        throw new TimeoutException();        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }}
1
private Proposal findProposalOfType(Map<Long, Proposal> proposals, int type)
{    for (Proposal proposal : proposals.values()) {        if (proposal.request.getHdr().getType() == type) {            return proposal;        }    }    return null;}
0
public void testInconsistentDueToNewLeaderOrder() throws Exception
{        final int ENSEMBLE_SERVERS = 3;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];    Context[] contexts = new Context[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        final Context context = new Context();        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);        String nodePath = "/testInconsistentDueToNewLeader";    int leaderId = -1;    int followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }        mt[followerA].shutdown();    waitForOne(zk[followerA], States.CONNECTING);    try {                        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");                String initialValue = "1";        final ZooKeeper leaderZk = zk[leaderId];        leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;                                        leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {            @Override            public void start() {                if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {                    return;                }                final String value = "2";                                                try {                    leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {                        public void processResult(int rc, String path, Object ctx, Stat stat) {                        }                    }, null);                                        Thread.sleep(1000);                } catch (Exception e) {                                    }            }        });                                leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {            @Override            public void start() {                String value = "3";                                try {                    leaderZk.setData(nodePath, value.getBytes(), -1);                                    } catch (Exception e) {                                    }            }        });                CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);                contexts[followerA].exitWhenAckNewLeader = true;        CountDownLatch latch = new CountDownLatch(1);        final MainThread followerAMT = mt[followerA];        contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {            @Override            public void start() {                try {                    latch.countDown();                    followerAMT.shutdown();                } catch (Exception e) {                }            }        };                        mt[followerA].start();        assertTrue(latch.await(30, TimeUnit.SECONDS));                        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "false");        contexts[followerA].exitWhenAckNewLeader = true;        contexts[followerA].newLeaderAckCallback = null;                mt[followerA].start();        zk[followerA].close();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);                        waitForOne(zk[followerA], States.CONNECTED);        assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));    } finally {        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {            mt[i].shutdown();            zk[i].close();        }    }}
1
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain(context);}
0
public void start()
{    if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {        return;    }    final String value = "2";            try {        leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {            }        }, null);                Thread.sleep(1000);    } catch (Exception e) {            }}
1
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
0
public void start()
{    String value = "3";        try {        leaderZk.setData(nodePath, value.getBytes(), -1);            } catch (Exception e) {            }}
1
public void start()
{    try {        latch.countDown();        followerAMT.shutdown();    } catch (Exception e) {    }}
0
public void testLeaderElectionWithDisloyalVoter() throws IOException
{    testLeaderElection(5, 3, 1000, 10000);}
0
public void testLeaderElectionWithDisloyalVoter_stillHasMajority() throws IOException
{    testLeaderElection(5, 5, 3000, 20000);}
0
 void testLeaderElection(int totalServers, int serversToStart, int maxTimeToWaitForEpoch, int maxTimeWaitForServerUp) throws IOException
{    Leader.setMaxTimeToWaitForEpoch(maxTimeToWaitForEpoch);        servers = new Servers();    int ENSEMBLE_SERVERS = totalServers;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        int SERVERS_TO_START = serversToStart;    MainThread[] mt = new MainThread[SERVERS_TO_START];    Context[] contexts = new Context[SERVERS_TO_START];    servers.mt = mt;    numServers = SERVERS_TO_START;    for (int i = 0; i < SERVERS_TO_START; i++) {                        final Context context = new Context();        if (i == 0) {            context.quitFollowing = true;        }        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();    }        for (int i = 0; i < SERVERS_TO_START; i++) {        assertTrue("Server " + i + " should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], maxTimeWaitForServerUp));    }}
0
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain(context);}
0
public void testMetricsProviderLifecycle() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
0
public void testMetricsProviderConfiguration() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.set(0);        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertEquals(1234, BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.get());}
0
public void testFaultyMetricsProviderOnStop() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStop.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderWithErrorInStop.stopCalled.get());    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Error while stopping metrics.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
0
public void testInvalidMetricsProvider() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=BadClass\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*BadClass.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
0
public void testFaultyMetricsProviderOnStart() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStart.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
0
public void testFaultyMetricsProviderOnConfigure() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInConfigure.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
0
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer(context);}
0
public void setStartForwardingListener(StartForwardingListener startForwardingListener)
{    this.startForwardingListener = startForwardingListener;}
0
public void setBeginSnapshotListener(BeginSnapshotListener beginSnapshotListener)
{    this.beginSnapshotListener = beginSnapshotListener;}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void followLeader() throws InterruptedException {            if (context.quitFollowing) {                                context.quitFollowing = false;                                return;            } else {                super.followLeader();            }        }        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {                if (context.newLeaderAckCallback != null) {                    context.newLeaderAckCallback.start();                }            }            super.writePacket(pp, flush);        }    };}
1
 void followLeader() throws InterruptedException
{    if (context.quitFollowing) {                context.quitFollowing = false;                return;    } else {        super.followLeader();    }}
1
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {        if (context.newLeaderAckCallback != null) {            context.newLeaderAckCallback.start();        }    }    super.writePacket(pp, flush);}
0
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        public long startForwarding(LearnerHandler handler, long lastSeenZxid) {            if (startForwardingListener != null) {                startForwardingListener.start();            }            return super.startForwarding(handler, lastSeenZxid);        }        @Override        public LearnerSyncThrottler getLearnerSnapSyncThrottler() {            if (throttler == null) {                throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {                    @Override                    public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                        if (beginSnapshotListener != null) {                            beginSnapshotListener.start();                        }                        super.beginSync(essential);                    }                };            }            return throttler;        }    };}
0
public long startForwarding(LearnerHandler handler, long lastSeenZxid)
{    if (startForwardingListener != null) {        startForwardingListener.start();    }    return super.startForwarding(handler, lastSeenZxid);}
0
public LearnerSyncThrottler getLearnerSnapSyncThrottler()
{    if (throttler == null) {        throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {            @Override            public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                if (beginSnapshotListener != null) {                    beginSnapshotListener.start();                }                super.beginSync(essential);            }        };    }    return throttler;}
0
public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException
{    if (beginSnapshotListener != null) {        beginSnapshotListener.start();    }    super.beginSync(essential);}
0
public void testQuorumPeerListendOnSpecifiedClientIP() throws IOException
{    long myId = 1;    File dataDir = ClientBase.createTmpDir();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    /**     * QuorumPeer constructor without QuorumVerifier     */    QuorumPeer peer1 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString1 = peer1.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString1);        peer1.shutdown();    /**     * QuorumPeer constructor with QuorumVerifier     */    peersView.clear();    clientPort = PortAssignment.unique();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    QuorumPeer peer2 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString2 = peer2.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString2);        peer2.shutdown();}
0
public void testLocalPeerIsLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsLeader = new Vote(localPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsLeader);    assertTrue(peer.isLeader(localPeerId));}
0
public void testLocalPeerIsNotLeader() throws Exception
{    long localPeerId = 7;    long otherPeerId = 17;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsNotLeader = new Vote(otherPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsNotLeader);    assertFalse(peer.isLeader(localPeerId));}
0
public void testIsNotLeaderBecauseNoVote() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    peer.setCurrentVote(null);    assertFalse(peer.isLeader(localPeerId));}
0
public void tearDown() throws Exception
{    if (servers == null || servers.mt == null) {                return;    }    for (int i = 0; i < numServers; i++) {        if (i < servers.mt.length) {            servers.mt[i].shutdown();        }    }}
1
public void process(WatchedEvent event)
{}
0
public void shutdown()
{        if (quorumPeer != null) {        QuorumBase.shutdown(quorumPeer);    }}
0
private String createDynamicFile(String quorumCfgSection, String version) throws IOException
{    String filename = "zoo.cfg.dynamic";    if (version != null) {        filename = filename + "." + version;    }    File dynamicConfigFile = new File(tmpDir, filename);    String dynamicConfigFilename = PathUtils.normalizeFileSystemPath(dynamicConfigFile.toString());    FileWriter fDynamicConfigWriter = new FileWriter(dynamicConfigFile);    fDynamicConfigWriter.write(quorumCfgSection);    fDynamicConfigWriter.flush();    fDynamicConfigWriter.close();    return dynamicConfigFilename;}
0
public File[] getDynamicFiles()
{    return getFilesWithPrefix("zoo.cfg.dynamic");}
0
public File[] getFilesWithPrefix(final String prefix)
{    return tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith(prefix);        }    });}
0
public boolean accept(File dir, String name)
{    return name.startsWith(prefix);}
0
public File getFileByName(String filename)
{    File f = new File(tmpDir.getPath(), filename);    return f.isFile() ? f : null;}
0
public void writeTempDynamicConfigFile(String nextQuorumCfgSection, String version) throws IOException
{    File nextDynamicConfigFile = new File(tmpDir, "zoo.cfg" + QuorumPeerConfig.nextDynamicConfigFileSuffix);    FileWriter fwriter = new FileWriter(nextDynamicConfigFile);    fwriter.write(nextQuorumCfgSection + "\n" + "version=" + version);    fwriter.flush();    fwriter.close();}
0
public synchronized void start()
{    main = getTestQPMain();    currentThread = new Thread(this);    currentThread.start();}
0
public TestQPMain getTestQPMain()
{    return new TestQPMain();}
0
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    } finally {        currentThread = null;    }}
1
public void shutdown() throws InterruptedException
{    Thread t = currentThread;    if (t != null && t.isAlive()) {        main.shutdown();        t.join(500);    }}
0
public void join(long timeout) throws InterruptedException
{    Thread t = currentThread;    if (t != null) {        t.join(timeout);    }}
0
public boolean isAlive()
{    Thread t = currentThread;    return t != null && t.isAlive();}
0
public void reinitialize() throws IOException
{    File dataDir = main.quorumPeer.getTxnFactory().getDataDir();    ClientBase.recursiveDelete(dataDir);    ClientBase.createInitializeFile(dataDir.getParentFile());}
0
public boolean isQuorumPeerRunning()
{    return main.quorumPeer != null;}
0
public String getPropFromStaticFile(String key) throws IOException
{    Properties props = new Properties();    props.load(new FileReader(confFile));    return props.getProperty(key, "");}
0
public QuorumPeer getQuorumPeer()
{    return main.quorumPeer;}
0
public void deleteBaseDir()
{    ClientBase.recursiveDelete(baseDir);}
0
public int getMyid()
{    return myid;}
0
public int getClientPort()
{    return clientPort;}
0
public String getQuorumCfgSection()
{    return quorumCfgSection;}
0
public Map<String, String> getOtherConfigs()
{    return otherConfigs;}
0
public File getConfFile()
{    return confFile;}
0
public void shutDownAllServers() throws InterruptedException
{    for (MainThread t : mt) {        t.shutdown();    }}
0
public void restartAllServersAndClients(Watcher watcher) throws IOException, InterruptedException
{    for (MainThread t : mt) {        if (!t.isAlive()) {            t.start();        }    }    for (int i = 0; i < zk.length; i++) {        restartClient(i, watcher);    }}
0
public void restartClient(int clientIndex, Watcher watcher) throws IOException, InterruptedException
{    if (zk[clientIndex] != null) {        zk[clientIndex].close();    }    zk[clientIndex] = new ZooKeeper("127.0.0.1:" + clientPorts[clientIndex], ClientBase.CONNECTION_TIMEOUT, watcher);}
0
public int findLeader()
{    for (int i = 0; i < mt.length; i++) {        if (mt[i].main.quorumPeer.leader != null) {            return i;        }    }    return -1;}
0
protected Servers LaunchServers(int numServers) throws IOException, InterruptedException
{    return LaunchServers(numServers, null);}
0
protected Servers LaunchServers(int numServers, Integer tickTime) throws IOException, InterruptedException
{    int SERVER_COUNT = numServers;    QuorumPeerMainTest.Servers svrs = new QuorumPeerMainTest.Servers();    svrs.clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        svrs.clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + svrs.clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    svrs.mt = new MainThread[SERVER_COUNT];    svrs.zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (tickTime != null) {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection, new HashMap<String, String>(), tickTime);        } else {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection);        }        svrs.mt[i].start();        svrs.restartClient(i, this);    }    waitForAll(svrs, ZooKeeper.States.CONNECTED);    return svrs;}
0
public static void waitForOne(ZooKeeper zk, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (zk.getState() != state) {        if (iterations-- == 0) {            throw new RuntimeException("Waiting too long " + zk.getState() + " != " + state);        }        Thread.sleep(500);    }}
0
protected void waitForAll(Servers servers, ZooKeeper.States state) throws InterruptedException
{    waitForAll(servers.zk, state);}
0
public static void waitForAll(ZooKeeper[] zks, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 1000;    boolean someoneNotConnected = true;    while (someoneNotConnected) {        if (iterations-- == 0) {            logStates(zks);            ClientBase.logAllStackTraces();            throw new RuntimeException("Waiting too long");        }        someoneNotConnected = false;        for (ZooKeeper zk : zks) {            if (zk.getState() != state) {                someoneNotConnected = true;                break;            }        }        Thread.sleep(1000);    }}
0
public static void logStates(ZooKeeper[] zks)
{    StringBuilder sbBuilder = new StringBuilder("Connection States: {");    for (int i = 0; i < zks.length; i++) {        sbBuilder.append(i + " : " + zks[i].getState() + ", ");    }    sbBuilder.append('}');    }
1
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING }, { ServerState.FOLLOWING }, { ServerState.OBSERVING } });}
0
public void setUp() throws Exception
{    CountdownWatcher clientWatch = new CountdownWatcher();    super.setUp(true);    zkClient = createClient(clientWatch, getPeersMatching(serverState));    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);}
0
public void tearDown() throws Exception
{    zkClient.close();    super.tearDown();}
0
private Stat create2EmptyNode(TestableZooKeeper zkClient, String path) throws Exception
{    Stat stat = new Stat();    zkClient.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    return stat;}
0
public void testCreate() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertArrayEquals(String.format("%s Node created (create) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
0
public void testCreate2() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertArrayEquals(String.format("%s Node created (create2) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
0
public void testDelete() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.delete(PARENT_PATH, -1);    assertNull(String.format("%s Node no longer exists", serverState), zkClient.exists(PARENT_PATH, false));}
0
public void testExists() throws Exception
{    Stat stat = create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Exists returns correct node stat", serverState), stat, zkClient.exists(PARENT_PATH, false));}
0
public void testSetAndGetData() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.setData(PARENT_PATH, DATA, -1);    assertArrayEquals(String.format("%s Node updated with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
0
public void testSetAndGetACL() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Node has open ACL", serverState), Ids.OPEN_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));    zkClient.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals(String.format("%s Node has world read-only ACL", serverState), Ids.READ_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));}
0
public void testSetAndGetChildren() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false)));}
0
public void testSetAndGetChildren2() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false, null)));}
0
public void testSync() throws Exception
{    complete = false;    create2EmptyNode(zkClient, PARENT_PATH);    VoidCallback onSync = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            complete = true;            callComplete.countDown();        }    };    zkClient.sync(PARENT_PATH, onSync, null);    callComplete.await(30, TimeUnit.SECONDS);    assertTrue(String.format("%s Sync completed", serverState), complete);}
0
public void processResult(int rc, String path, Object ctx)
{    complete = true;    callComplete.countDown();}
0
public void testToString() throws ConfigException
{    String provided = ipv4config + ":participant;0.0.0.0:1237";    String expected = ipv4config + ":participant;0.0.0.0:1237";    QuorumServer qs = new QuorumServer(0, provided);    assertEquals("Use IP address", expected, qs.toString());    provided = ipv4config + ";0.0.0.0:1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Type unspecified", expected, qs.toString());    provided = ipv4config + ":observer;0.0.0.0:1237";    expected = ipv4config + ":observer;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Observer type", expected, qs.toString());    provided = ipv4config + ":participant;1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address unspecified", expected, qs.toString());    provided = ipv4config + ":participant;1.2.3.4:1237";    expected = ipv4config + ":participant;1.2.3.4:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address specified", expected, qs.toString());    provided = "example.com:1234:1236:participant;1237";    expected = "example.com:1234:1236:participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Use hostname", expected, qs.toString());}
0
public void constructionUnderstandsIpv6LiteralsInServerConfig() throws ConfigException
{    String config = "[::1]:1234:1236:participant";    QuorumServer qs = new QuorumServer(0, config);    assertEquals("[0:0:0:0:0:0:0:1]:1234:1236:participant", qs.toString());}
0
public void constructionUnderstandsIpv6LiteralsInClientConfig() throws ConfigException
{    String config = ipv4config + ":participant;[::1]:1237";    QuorumServer qs = new QuorumServer(0, config);    assertEquals(ipv4config + ":participant;[0:0:0:0:0:0:0:1]:1237", qs.toString());}
0
public void unbalancedIpv6LiteralsInServerConfigFailToBeParsed() throws ConfigException
{    new QuorumServer(0, "[::1:1234:1236:participant");}
0
public void unbalancedIpv6LiteralsInClientConfigFailToBeParsed() throws ConfigException
{    new QuorumServer(0, ipv4config + ":participant;[::1:1237");}
0
public void testWildcard() throws KeeperException.BadArgumentsException
{    String[] addrs = new String[] { "127.0.0.1", "[0:0:0:0:0:0:0:1]", "0.0.0.0", "[::]" };    for (int i = 0; i < addrs.length; i++) {        for (int j = i; j < addrs.length; j++) {            QuorumPeer.QuorumServer server1 = new             QuorumPeer.QuorumServer(            1,             new InetSocketAddress(ipv6n1, 1234),             new InetSocketAddress(ipv6n1, 1236),             new InetSocketAddress(addrs[i], 1237));            QuorumPeer.QuorumServer server2 = new             QuorumPeer.QuorumServer(            2,             new InetSocketAddress(ipv6n2, 1234),             new InetSocketAddress(ipv6n2, 1236),             new InetSocketAddress(addrs[j], 1237));            server1.checkAddressDuplicate(server2);        }    }}
0
public void testDuplicate() throws KeeperException.BadArgumentsException
{    QuorumPeer.QuorumServer server1 = new     QuorumPeer.QuorumServer(    1,     new InetSocketAddress(ipv6n1, 1234),     new InetSocketAddress(ipv6n1, 1236),     new InetSocketAddress(ipv6n1, 1237));    QuorumPeer.QuorumServer server2 = new     QuorumPeer.QuorumServer(    2,     new InetSocketAddress(ipv6n2, 1234),     new InetSocketAddress(ipv6n2, 1236),     new InetSocketAddress(ipv6n1, 1237));    server1.checkAddressDuplicate(server2);}
0
public void setup() throws Exception
{    quorumX509Util = new QuorumX509Util();    ClientBase.setupTestEnv();    tmpDir = createTmpDir().getAbsolutePath();    clientPortQp1 = PortAssignment.unique();    clientPortQp2 = PortAssignment.unique();    clientPortQp3 = PortAssignment.unique();    validKeystorePath = tmpDir + "/valid.jks";    truststorePath = tmpDir + "/truststore.jks";    quorumConfiguration = generateQuorumConfiguration();    Security.addProvider(new BouncyCastleProvider());    certStartTime = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(certStartTime);    cal.add(Calendar.YEAR, 1);    certEndTime = cal.getTime();    rootKeyPair = createKeyPair();    contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(rootKeyPair.getPrivate());    rootCertificate = createSelfSignedCertifcate(rootKeyPair);        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    trustStore.load(null, PASSWORD);    trustStore.setCertificateEntry(rootCertificate.getSubjectDN().toString(), rootCertificate);    FileOutputStream outputStream = new FileOutputStream(truststorePath);    trustStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();    defaultKeyPair = createKeyPair();    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, "127.0.0.1", null, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    setSSLSystemProperties();}
0
private void writeKeystore(X509Certificate certificate, KeyPair entityKeyPair, String path) throws Exception
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    keyStore.load(null, PASSWORD);    keyStore.setKeyEntry("alias", entityKeyPair.getPrivate(), PASSWORD, new Certificate[] { certificate });    FileOutputStream outputStream = new FileOutputStream(path);    keyStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();}
0
public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException
{    byte[] responseBytes;    try {        InputStream request = httpExchange.getRequestBody();        byte[] requestBytes = new byte[10000];        request.read(requestBytes);        OCSPReq ocspRequest = new OCSPReq(requestBytes);        Req[] requestList = ocspRequest.getRequestList();        DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);        BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);        for (Req req : requestList) {            CertificateID certId = req.getCertID();            CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());            CertificateStatus certificateStatus;            if (revokedCertId.equals(certId)) {                certificateStatus = new UnknownStatus();            } else {                certificateStatus = CertificateStatus.GOOD;            }            responseBuilder.addResponse(certId, certificateStatus, null);        }        X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };        ContentSigner signer = new JcaContentSignerBuilder("SHA1withRSA").setProvider("BC").build(rootKeyPair.getPrivate());        BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());        responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();    } catch (OperatorException | CertificateEncodingException | OCSPException exception) {        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();    }    Headers rh = httpExchange.getResponseHeaders();    rh.set("Content-Type", "application/ocsp-response");    httpExchange.sendResponseHeaders(200, responseBytes.length);    OutputStream os = httpExchange.getResponseBody();    os.write(responseBytes);    os.close();}
0
private X509Certificate createSelfSignedCertifcate(KeyPair keyPair) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, HOSTNAME);    BigInteger serialNumber = new BigInteger(128, new Random());    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, certStartTime, certEndTime, nameBuilder.build(), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner));}
0
private void buildCRL(X509Certificate x509Certificate, String crlPath) throws Exception
{    X509v2CRLBuilder builder = new JcaX509v2CRLBuilder(x509Certificate.getIssuerX500Principal(), certStartTime);    builder.addCRLEntry(x509Certificate.getSerialNumber(), certStartTime, CRLReason.cACompromise);    builder.setNextUpdate(certEndTime);    builder.addExtension(Extension.authorityKeyIdentifier, false, new JcaX509ExtensionUtils().createAuthorityKeyIdentifier(rootCertificate));    builder.addExtension(Extension.cRLNumber, false, new CRLNumber(new BigInteger("1000")));    X509CRLHolder cRLHolder = builder.build(contentSigner);    PemWriter pemWriter = new PemWriter(new FileWriter(crlPath));    pemWriter.writeObject(new MiscPEMGenerator(cRLHolder));    pemWriter.flush();    pemWriter.close();}
0
public X509Certificate buildEndEntityCert(KeyPair keyPair, X509Certificate caCert, PrivateKey caPrivateKey, String hostname, String ipAddress, String crlPath, Integer ocspPort) throws Exception
{    X509CertificateHolder holder = new JcaX509CertificateHolder(caCert);    ContentSigner signer = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(caPrivateKey);    List<GeneralName> generalNames = new ArrayList<>();    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    SubjectPublicKeyInfo entityKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(PublicKeyFactory.createKey(keyPair.getPublic().getEncoded()));    X509ExtensionUtils extensionUtils = new BcX509ExtensionUtils();    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(holder.getSubject(), new BigInteger(128, new Random()), certStartTime, certEndTime, new X500Name("CN=Test End Entity Certificate"), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.authorityKeyIdentifier, false, extensionUtils.createAuthorityKeyIdentifier(holder)).addExtension(Extension.subjectKeyIdentifier, false, extensionUtils.createSubjectKeyIdentifier(entityKeyInfo)).addExtension(Extension.basicConstraints, true, new BasicConstraints(false)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    if (crlPath != null) {        DistributionPointName distPointOne = new DistributionPointName(new GeneralNames(new GeneralName(GeneralName.uniformResourceIdentifier, "file://" + crlPath)));        certificateBuilder.addExtension(Extension.cRLDistributionPoints, false, new CRLDistPoint(new DistributionPoint[] { new DistributionPoint(distPointOne, null, null) }));    }    if (ocspPort != null) {        certificateBuilder.addExtension(Extension.authorityInfoAccess, false, new AuthorityInformationAccess(X509ObjectIdentifiers.ocspAccessMethod, new GeneralName(GeneralName.uniformResourceIdentifier, "http://" + hostname + ":" + ocspPort)));    }    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(signer));}
0
private KeyPair createKeyPair() throws NoSuchProviderException, NoSuchAlgorithmException
{    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    KeyPair keyPair = keyPairGenerator.genKeyPair();    return keyPair;}
0
private String generateQuorumConfiguration()
{    int portQp1 = PortAssignment.unique();    int portQp2 = PortAssignment.unique();    int portQp3 = PortAssignment.unique();    int portLe1 = PortAssignment.unique();    int portLe2 = PortAssignment.unique();    int portLe3 = PortAssignment.unique();    return "server.1=127.0.0.1:" + (portQp1) + ":" + (portLe1) + ";" + clientPortQp1 + "\n" + "server.2=127.0.0.1:" + (portQp2) + ":" + (portLe2) + ";" + clientPortQp2 + "\n" + "server.3=127.0.0.1:" + (portQp3) + ":" + (portLe3) + ";" + clientPortQp3;}
0
public void setSSLSystemProperties()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), validKeystorePath);    System.setProperty(quorumX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(quorumX509Util.getSslTruststoreLocationProperty(), truststorePath);    System.setProperty(quorumX509Util.getSslTruststorePasswdProperty(), "testpass");}
0
public void cleanUp() throws Exception
{    clearSSLSystemProperties();    if (q1 != null) {        q1.shutdown();    }    if (q2 != null) {        q2.shutdown();    }    if (q3 != null) {        q3.shutdown();    }    Security.removeProvider("BC");    quorumX509Util.close();}
0
private void clearSSLSystemProperties()
{    System.clearProperty(quorumX509Util.getSslKeystoreLocationProperty());    System.clearProperty(quorumX509Util.getSslKeystorePasswdProperty());    System.clearProperty(quorumX509Util.getSslTruststoreLocationProperty());    System.clearProperty(quorumX509Util.getSslTruststorePasswdProperty());    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    System.clearProperty(quorumX509Util.getSslOcspEnabledProperty());    System.clearProperty(quorumX509Util.getSslCrlEnabledProperty());    System.clearProperty(quorumX509Util.getCipherSuitesProperty());    System.clearProperty(quorumX509Util.getSslProtocolProperty());}
0
public void testQuorumSSL() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    clearSSLSystemProperties();        q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
0
public void testRollingUpgrade() throws Exception
{        q1 = new MainThread(1, clientPortQp1, quorumConfiguration);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration);    q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    Map<Integer, MainThread> members = new HashMap<>();    members.put(clientPortQp1, q1);    members.put(clientPortQp2, q2);    members.put(clientPortQp3, q3);    for (MainThread member : members.values()) {        member.start();    }    for (int clientPort : members.keySet()) {        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }        setSSLSystemProperties();    stopAppendConfigRestartAll(members, PORT_UNIFICATION_ENABLED);    stopAppendConfigRestartAll(members, SSL_QUORUM_ENABLED);    stopAppendConfigRestartAll(members, PORT_UNIFICATION_DISABLED);}
0
private void stopAppendConfigRestartAll(Map<Integer, MainThread> members, String config) throws Exception
{    for (Map.Entry<Integer, MainThread> entry : members.entrySet()) {        int clientPort = entry.getKey();        MainThread member = entry.getValue();        member.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));        FileWriter fileWriter = new FileWriter(member.getConfFile(), true);        fileWriter.write(config);        fileWriter.flush();        fileWriter.close();        member.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }}
0
public void testHostnameVerificationWithInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", null, null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
0
public void testHostnameVerificationWithInvalidIPAddress() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), null, "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
0
public void testHostnameVerificationWithInvalidIpAddressAndInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
0
public void testHostnameVerificationWithInvalidIpAddressAndValidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "localhost", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
0
public void testHostnameVerificationWithValidIpAddressAndInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "127.0.0.1", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
0
private void testHostnameVerification(String keystorePath, boolean expectSuccess) throws Exception
{    System.setProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty(), "false");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);    q3.start();    assertEquals(expectSuccess, ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
0
public void testCertificateRevocationList() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInCRLKeystorePath = tmpDir + "/crl_revoked.jks";    String crlPath = tmpDir + "/crl.pem";    X509Certificate revokedInCRLCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(revokedInCRLCert, defaultKeyPair, revokedInCRLKeystorePath);    buildCRL(revokedInCRLCert, crlPath);    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.setProperty(quorumX509Util.getSslCrlEnabledProperty(), "true");    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
0
public void testOCSP() throws Exception
{    Integer ocspPort = PortAssignment.unique();    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInOCSPKeystorePath = tmpDir + "/ocsp_revoked.jks";    X509Certificate revokedInOCSPCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);    writeKeystore(revokedInOCSPCert, defaultKeyPair, revokedInOCSPKeystorePath);    HttpServer ocspServer = HttpServer.create(new InetSocketAddress(ocspPort), 0);    try {        ocspServer.createContext("/", new OCSPHandler(revokedInOCSPCert));        ocspServer.start();        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);                q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);        q3.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        setSSLSystemProperties();        System.setProperty(quorumX509Util.getSslOcspEnabledProperty(), "true");        X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);        writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);        q1.start();        q2.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);        q3.start();        assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    } finally {        ocspServer.stop(0);    }}
0
public void testCipherSuites() throws Exception
{        SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();    List<String> defaultCiphers = new ArrayList<String>();    for (String cipher : ssf.getDefaultCipherSuites()) {        if (!cipher.matches(".*EMPTY.*") && cipher.startsWith("TLS") && cipher.contains("RSA")) {            defaultCiphers.add(cipher);        }    }    if (defaultCiphers.size() < 2) {        fail("JDK has to support at least 2 valid (RSA) cipher suites for this test to run");    }        String suitesOfEnsemble = String.join(",", defaultCiphers.subList(1, defaultCiphers.size()));    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suitesOfEnsemble);    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        String suiteOfClient = defaultCiphers.get(0);    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suiteOfClient);            q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
0
public void testProtocolVersion() throws Exception
{    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.2");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.1");        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
0
public void testRaceConditionBetweenLeaderAndAckRequestProcessor() throws Exception
{    mt = startQuorum();        QuorumPeer leader = getLeader(mt);    long oldLeaderCurrentEpoch = leader.getCurrentEpoch();    assertNotNull("Leader should not be null", leader);            shutdownFollowers(mt);    /**     * <pre>     * Verify that there is no deadlock in following ways:     * 1) If leader is in LOOKING or FOLLOWING, we are sure there is no deadlock.     * 2) If leader in in LEADING state then we have to check that this LEADING state is     * after the leader election, not the old LEADING state.     * </pre>     */    boolean leaderStateChanged = ClientBase.waitForServerState(leader, 15000, QuorumStats.Provider.LOOKING_STATE, QuorumStats.Provider.FOLLOWING_STATE);        assertTrue("Failed to bring up the old leader server", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    assertTrue("Leader failed to transition to new state. Current state is " + leader.getServerState(), leaderStateChanged || (leader.getCurrentEpoch() > oldLeaderCurrentEpoch));}
0
public void tearDown()
{        if (null != mt) {        for (int i = 0; i < SERVER_COUNT; i++) {            try {                                                mt[i].shutdown();            } catch (InterruptedException e) {                            }        }    }}
1
private MainThread[] startQuorum() throws IOException
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    return mt;}
0
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
0
private QuorumPeer getLeader(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
0
private void shutdownFollowers(MainThread[] mt)
{    for (int i = 0; i < mt.length; i++) {        CustomQuorumPeer quorumPeer = (CustomQuorumPeer) mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.FOLLOWING == quorumPeer.getPeerState()) {            quorumPeer.setStopPing(true);        }    }}
0
public void setStopPing(boolean stopPing)
{    this.stopPing = stopPing;}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void processPacket(QuorumPacket qp) throws Exception {            if (stopPing && qp.getType() == Leader.PING) {                                throw new SocketException("Socket time out while sending the ping response");            } else {                super.processPacket(qp);            }        }    };}
1
protected void processPacket(QuorumPacket qp) throws Exception
{    if (stopPing && qp.getType() == Leader.PING) {                throw new SocketException("Socket time out while sending the ping response");    } else {        super.processPacket(qp);    }}
1
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        protected void setupRequestProcessors() {            /**             * This method is overridden to make a place to inject             * MockSyncRequestProcessor             */            RequestProcessor finalProcessor = new FinalRequestProcessor(this);            RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());            commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());            commitProcessor.start();            ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);            proposalProcessor.initialize();            prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);            prepRequestProcessor.start();            firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);        }    };    return new Leader(this, zk);}
0
protected void setupRequestProcessors()
{    /**     * This method is overridden to make a place to inject     * MockSyncRequestProcessor     */    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);}
0
public void shutdown()
{    /**     * Add a request so that something is there for SyncRequestProcessor     * to process, while we are in shutdown flow     */    Request request = new Request(null, 0, 0, ZooDefs.OpCode.delete, ByteBuffer.wrap("/deadLockIssue".getBytes()), null);    processRequest(request);    super.shutdown();}
0
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer();}
0
public static String getVersionFromConfigStr(String config) throws IOException
{    Properties props = new Properties();    props.load(new StringReader(config));    return props.getProperty("version", "");}
0
public static String getFileContent(File file) throws FileNotFoundException
{    Scanner sc = new Scanner(file);    StringBuilder sb = new StringBuilder();    while (sc.hasNextLine()) {        sb.append(sc.nextLine() + "\n");    }    return sb.toString();}
0
public void setup()
{    ClientBase.setupTestEnv();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
0
public void testBackupStatic() throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    String[] staticFileContent = new String[SERVER_COUNT];    String[] staticBackupContent = new String[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);                assertNull("static file backup shouldn't exist before bootup", mt[i].getFileByName("zoo.cfg.bak"));        staticFileContent[i] = getFileContent(mt[i].confFile);        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        File backupFile = mt[i].getFileByName("zoo.cfg.bak");        assertNotNull("static file backup should exist", backupFile);        staticBackupContent[i] = getFileContent(backupFile);        assertEquals(staticFileContent[i], staticBackupContent[i]);    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public void testReconfigCreateNewVersionFile() throws Exception
{    final int SERVER_COUNT = 3;    final int NEW_SERVER_COUNT = 5;    final int[] clientPorts = new int[NEW_SERVER_COUNT];    final int[] quorumPorts = new int[NEW_SERVER_COUNT];    final int[] electionPorts = new int[NEW_SERVER_COUNT];    final String[] servers = new String[NEW_SERVER_COUNT];    StringBuilder sb = new StringBuilder();    ArrayList<String> oldServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < NEW_SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        servers[i] = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant;localhost:" + clientPorts[i];        newServers.add(servers[i]);        if (i >= SERVER_COUNT) {            continue;        }        oldServers.add(servers[i]);        sb.append(servers[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[NEW_SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[NEW_SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[NEW_SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, "reconfigEnabled=true\n");        mt[i].start();    }    String firstVersion = null, secondVersion = null;        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], oldServers, null);        String configVersion = getVersionFromConfigStr(configStr);                        assertEquals(version, configVersion);        if (i == 0) {            firstVersion = version;        } else {            assertEquals(firstVersion, version);        }    }    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection + servers[i]);        mt[i].start();    }        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);    }        for (int i = 0; i < NEW_SERVER_COUNT; i++) {        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], newServers, null);        String quorumVersion = getVersionFromConfigStr(configStr);        assertEquals(version, quorumVersion);        if (i == 0) {            secondVersion = version;            assertTrue(Long.parseLong(secondVersion, 16) > Long.parseLong(firstVersion, 16));        } else {            assertEquals(secondVersion, version);        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
0
public void testVersionOfDynamicFilename() throws Exception
{    final int SERVER_COUNT = 5;    final int oldServerCount = 3;    final int lagOffServerId = 0;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    StringBuilder oldSb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        allServers.add(server);        if (i < oldServerCount) {                        oldSb.append(server + "\n");        }    }    String currentQuorumCfgSection = sb.toString();    String oldQuorumCfg = oldSb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (i == lagOffServerId) {            mt[i] = new MainThread(i, clientPorts[i], oldQuorumCfg, true, "100000000");        } else {            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "200000000");        }                if (i == lagOffServerId) {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.100000000"));            assertNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".100000000"));        } else {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));        }        mt[i].start();    }    String dynamicFileContent = null;    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);                        String configStr = ReconfigTest.testServerHasConfig(zk, allServers, null);        assertEquals("200000000", getVersionFromConfigStr(configStr));        List<String> configLines = Arrays.asList(configStr.split("\n"));        Collections.sort(configLines);        String sortedConfigStr = StringUtils.joinStrings(configLines, "\n");        File dynamicConfigFile = mt[i].getFileByName("zoo.cfg.dynamic.200000000");        assertNotNull(dynamicConfigFile);                if (i == 0) {            dynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(sortedConfigStr, dynamicFileContent + "version=200000000");        } else {            String otherDynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(dynamicFileContent, otherDynamicFileContent);        }        zk.close();    }            assertTrue(mt[lagOffServerId].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
0
public void testDuringLeaderSync() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT + 1];    StringBuilder sb = new StringBuilder();    String[] serverConfig = new String[SERVER_COUNT + 1];    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        serverConfig[i] = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(serverConfig[i] + "\n");    }    String currentQuorumCfgSection = sb.toString();    mt = new MainThread[SERVER_COUNT + 1];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeperAdmin preReconfigClient = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watch);    preReconfigClient.addAuthInfo("digest", "super:test".getBytes());    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        int joinerId = SERVER_COUNT;    clientPorts[joinerId] = PortAssignment.unique();    serverConfig[joinerId] = "server." + joinerId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[joinerId];        int leaderId = -1;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;            break;        }    }    assertFalse(leaderId == -1);        sb = new StringBuilder();    sb.append(serverConfig[leaderId] + "\n").append(serverConfig[joinerId] + "\n");    /**     * This server will delay the response to a NEWLEADER message, and run     * reconfig command so that message at this processed in bellow order     *     * <pre>     * NEWLEADER     * reconfig's PROPOSAL     * reconfig's COMMITANDACTIVATE     * UPTODATE     * </pre>     */    mt[joinerId] = new MainThread(joinerId, clientPorts[joinerId], sb.toString(), false) {        @Override        public TestQPMain getTestQPMain() {            return new MockTestQPMain();        }    };    mt[joinerId].start();    CustomQuorumPeer qp = getCustomQuorumPeer(mt[joinerId]);        String nextDynamicConfigFilename = qp.getNextDynamicConfigFilename();    File nextDynaFile = new File(nextDynamicConfigFilename);    nextDynaFile.delete();        while (true) {        if (qp.isNewLeaderMessage()) {            preReconfigClient.reconfigure(serverConfig[joinerId], null, null, -1, null, null);            break;        } else {                        Thread.sleep(10);        }    }    watch = new CountdownWatcher();    ZooKeeper postReconfigClient = new ZooKeeper("127.0.0.1:" + clientPorts[joinerId], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        postReconfigClient.create("/reconfigIssue", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("zoo.cfg.dynamic.next is not deleted.", nextDynaFile.exists());        for (long j = 0; j <= SERVER_COUNT; j++) {        assertNotNull("server " + j + " is not present in the new quorum", qp.getQuorumVerifier().getVotingMembers().get(j));    }        preReconfigClient.close();    postReconfigClient.close();}
0
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
0
private static CustomQuorumPeer getCustomQuorumPeer(MainThread mt)
{    while (true) {        QuorumPeer quorumPeer = mt.getQuorumPeer();        if (null != quorumPeer) {            return (CustomQuorumPeer) quorumPeer;        } else {            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}
0
public void tearDown()
{        if (null != mt) {        for (int i = 0; i < mt.length; i++) {            try {                mt[i].shutdown();            } catch (InterruptedException e) {                            }        }    }}
1
public boolean isNewLeaderMessage()
{    return newLeaderMessage;}
0
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK) {                newLeaderMessage = true;                try {                    /**                     * Delaying the ACK message, a follower sends as                     * response to a NEWLEADER message, so that the                     * leader has a chance to send the reconfig and only                     * then the UPTODATE message.                     */                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            super.writePacket(pp, flush);        }    };}
0
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK) {        newLeaderMessage = true;        try {            /**             * Delaying the ACK message, a follower sends as             * response to a NEWLEADER message, so that the             * leader has a chance to send the reconfig and only             * then the UPTODATE message.             */            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    super.writePacket(pp, flush);}
0
public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException
{    quorumPeer = new CustomQuorumPeer(config.getQuorumVerifier().getAllMembers(), config.getDataDir(), config.getDataLogDir(), config.getClientPortAddress().getPort(), config.getElectionAlg(), config.getServerId(), config.getTickTime(), config.getInitLimit(), config.getSyncLimit(), config.getConnectToLearnerMasterLimit());    quorumPeer.setConfigFileName(config.getConfigFilename());    quorumPeer.start();    try {        quorumPeer.join();    } catch (InterruptedException e) {            }}
1
public void setup()
{    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
0
public void tearDown() throws Exception
{    if (qu != null) {        qu.tearDown();    }}
0
public void testIncrementalReconfigInvokedOnHiearchicalQS() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    ArrayList<String> members = new ArrayList<String>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }        ReconfigTest.reconfig(zkAdminArr[1], null, null, members, -1);    ReconfigTest.testNormalOperation(zkArr[1], zkArr[2]);        List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config isn't Majority QS");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
0
public void testTooFewRemainingPariticipants() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("2");    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
0
public void testReconfigVersionConditionFails() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, 8, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadVersionException e) {        } catch (Exception e) {        fail("Should have been BadVersionException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
0
public void testObserverToParticipantConversionFails() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = ReconfigRecoveryTest.generatePorts(SERVER_COUNT);        Set<Integer> observers = new HashSet<Integer>();    observers.add(3);    StringBuilder sb = ReconfigRecoveryTest.generateConfig(SERVER_COUNT, ports, observers);    String currentQuorumCfgSection = sb.toString();    String nextQuorumCfgSection = currentQuorumCfgSection.replace("observer", "participant");    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfgSection, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());    }    for (int i = 1; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }    try {        zkAdmin[1].reconfigure("", "", nextQuorumCfgSection, -1, new Stat());        fail("Reconfig should have failed with NewConfigNoQuorum");    } catch (NewConfigNoQuorum e) {            } catch (Exception e) {        fail("Reconfig should have failed with NewConfigNoQuorum");    }        ArrayList<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    ReconfigTest.reconfig(zkAdmin[1], null, leavingServers, null, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    ReconfigTest.testServerHasConfig(zk[3], null, leavingServers);        List<String> newMembers = Arrays.asList(nextQuorumCfgSection.split("\n"));    ReconfigTest.reconfig(zkAdmin[1], null, null, newMembers, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    for (int i = 1; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newMembers, null);    }    for (int i = 1; i < SERVER_COUNT; i++) {        zk[i].close();        zkAdmin[i].close();        mt[i].shutdown();    }}
0
public void setup()
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
0
public void testConfigFileBackwardCompatibility() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, "participant", false);                assertEquals(mt[i].getDynamicFiles().length, 0);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        File[] dynamicFiles = mt[i].getDynamicFiles();        assertTrue(dynamicFiles.length == 1);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);                                Properties cfg = readPropertiesFromFile(mt[i].confFile);        for (int j = 0; j < SERVER_COUNT; j++) {            assertFalse(cfg.containsKey("server." + j));        }        assertFalse(cfg.containsKey("peerType"));        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertFalse(cfg.containsKey("clientPort"));                cfg = readPropertiesFromFile(dynamicFiles[0]);        for (int j = 0; j < SERVER_COUNT; j++) {            String serverLine = cfg.getProperty("server." + j, "");            assertEquals(allServers.get(j), "server." + j + "=" + serverLine);        }        assertFalse(cfg.containsKey("dynamicConfigFile"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
0
public void testReconfigRemoveClientFromStatic() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    final int[] quorumPorts = new int[SERVER_COUNT];    final int[] electionPorts = new int[SERVER_COUNT];    final int changedServerId = 0;    final int newClientPort = PortAssignment.unique();    StringBuilder sb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant";        allServers.add(server);        sb.append(server + "\n");        if (i == changedServerId) {            newServers.add(server + ";0.0.0.0:" + newClientPort);        } else {            newServers.add(server);        }    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        ReconfigTest.testServerHasConfig(zk[i], allServers, null);        Properties cfg = readPropertiesFromFile(mt[i].confFile);        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertTrue(cfg.containsKey("clientPort"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);    ReconfigTest.testNormalOperation(zk[0], zk[1]);        Thread.sleep(1000);    for (int i = 0; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newServers, null);        Properties staticCfg = readPropertiesFromFile(mt[i].confFile);        if (i == changedServerId) {            assertFalse(staticCfg.containsKey("clientPort"));        } else {            assertTrue(staticCfg.containsKey("clientPort"));        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
0
public static Properties readPropertiesFromFile(File file) throws IOException
{    Properties cfg = new Properties();    FileInputStream in = new FileInputStream(file);    try {        cfg.load(in);    } finally {        in.close();    }    return cfg;}
0
public void testRestartZooKeeperServer() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    String zNodePath = "/serverRestartTest";    String data = "originalData";    zk.create(zNodePath, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    /**     * stop two servers out of three and again start them     */    mt[0].shutdown();    mt[1].shutdown();    mt[0].start();    mt[1].start();        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    byte[] dataBytes = zk.getData(zNodePath, null, null);    String receivedData = new String(dataBytes);    assertEquals(data, receivedData);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public void setup()
{    QuorumPeerConfig.setReconfigEnabled(true);}
0
public void testNextConfigCompletion() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();                MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT - 1; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    assertTrue("waiting for server 0 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], CONNECTION_TIMEOUT));    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[1], CONNECTION_TIMEOUT));    int leader = mt[0].main.quorumPeer.leader == null ? 1 : 0;        sb = new StringBuilder();    sb.append(allServers.get(leader) + "\n");    sb.append(allServers.get(2) + "\n");        String newServerInitialConfig = sb.toString();    mt[2] = new MainThread(2, clientPorts[2], newServerInitialConfig);    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + clientPorts[2], ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[2], CONNECTION_TIMEOUT));    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testServerHasConfig(zk[2], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[2], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
0
public void testCurrentServersAreObserversInNextConfig() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    final int[] oldClientPorts = new int[2];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfg, nextQuorumCfgSection;    ArrayList<String> allServersNext = new ArrayList<String>();    for (int i = 0; i < 2; i++) {        oldClientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + oldClientPorts[i];        sb.append(server + "\n");    }    currentQuorumCfg = sb.toString();    sb = new StringBuilder();    String role;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        if (i < 2) {            role = "observer";        } else {            role = "participant";        }        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + role + ";localhost:" + clientPorts[i];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, oldClientPorts[i], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + oldClientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < 2; i++) {        mt[i].shutdown();        zk[i].close();    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerDown("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    for (int i = 0; i < 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfg + allServersNext.get(i));        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
0
public void testNextConfigUnreachable() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    Thread.sleep(CONNECTION_TIMEOUT * 2);        for (int i = 0; i < 2; i++) {        assertFalse("server " + i + " is up but shouldn't be", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT / 10));    }    for (int i = 0; i < 2; i++) {        zk[i].close();        mt[i].shutdown();    }}
0
public void testNextConfigAlreadyActive() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], nextQuorumCfgSection, true, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ReconfigTest.testNormalOperation(zk[2], zk[3]);    long epoch = mt[2].main.quorumPeer.getAcceptedEpoch();        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));    }        assertEquals(epoch, mt[0].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[1].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[2].main.quorumPeer.getAcceptedEpoch());    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
0
public void testObserverConvertedToParticipantDuringFLE() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfgSection, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfgSection = sb.toString();        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        mt[2] = new MainThread(2, ports[2][2], currentQuorumCfgSection, true, "100000000");    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + ports[2][2], ClientBase.CONNECTION_TIMEOUT, this);        mt[3] = new MainThread(3, ports[3][2], nextQuorumCfgSection, true, "200000000");    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    ReconfigTest.testNormalOperation(zk[2], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[2]);    for (int i = 2; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
0
public void testCurrentObserverIsParticipantInNewConfig() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfg, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfg = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i <= 2; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    for (int i = 0; i <= 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }        for (int i = 0; i <= 2; i++) {        mt[i].shutdown();        zk[i].close();    }        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();        for (int i = 0; i <= 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }            mt[3] = new MainThread(3, ports[3][2], currentQuorumCfg + allServersNext.get(1));    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 3));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[1]);    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
0
public static int[][] generatePorts(int numServers)
{    int[][] ports = new int[numServers][];    for (int i = 0; i < numServers; i++) {        ports[i] = new int[3];        for (int j = 0; j < 3; j++) {            ports[i][j] = PortAssignment.unique();        }    }    return ports;}
0
public static StringBuilder generateConfig(int numServers, int[][] ports, Set<Integer> observerIds)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < numServers; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":" + (observerIds.contains(i) ? "observer" : "participant") + ";localhost:" + ports[i][2];        sb.append(server + "\n");    }    return sb;}
0
private String generateNewQuorumConfig(int serverCount)
{    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < serverCount; i++) {        clientPorts.put(i, PortAssignment.unique());        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(i);        serverAddress.put(i, server);        sb.append(server + "\n");    }    return sb.toString();}
0
private String updateExistingQuorumConfig(List<Integer> sidsToAdd, List<Integer> sidsToRemove)
{    StringBuilder sb = new StringBuilder();    for (Integer sid : sidsToAdd) {        clientPorts.put(sid, PortAssignment.unique());        serverAddress.put(sid, "server." + sid + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(sid));    }    for (Integer sid : sidsToRemove) {        clientPorts.remove(sid);        serverAddress.remove(sid);    }    for (String server : serverAddress.values()) {        sb.append(server + "\n");    }    return sb.toString();}
0
public void testNoLocalDynamicConfigAndBackupFiles() throws InterruptedException, IOException
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    String[] staticFileContent = new String[serverCount];    for (int i = 0; i < serverCount; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();    }    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        assertNull("static file backup (zoo.cfg.bak) shouldn't exist!", mt[i].getFileByName(ZOO_CFG_BAK_FILE));        assertNull("dynamic configuration file (zoo.cfg.dynamic.*) shouldn't exist!", mt[i].getFileByName(mt[i].getQuorumPeer().getNextDynamicConfigFilename()));        staticFileContent[i] = Files.readAllLines(mt[i].confFile.toPath(), StandardCharsets.UTF_8).toString();        assertTrue("static config file should contain server entry " + serverAddress.get(i), staticFileContent[i].contains(serverAddress.get(i)));    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
0
public void testRollingRestartWithoutMembershipChange() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    List<String> joiningServers = new ArrayList<>();    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();        mt[i].start();        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
0
public void testRollingRestartWithMembershipChange() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    List<String> joiningServers = new ArrayList<>();    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    Map<Integer, String> oldServerAddress = new HashMap<>(serverAddress);    List<String> newServers = new ArrayList<>(joiningServers);    config = updateExistingQuorumConfig(Arrays.asList(3, 4), new ArrayList<Integer>());    newServers.add(serverAddress.get(3));    newServers.add(serverAddress.get(4));    serverCount = serverAddress.size();    assertEquals("Server count should be 5 after config update.", serverCount, 5);                    mt = Arrays.copyOf(mt, mt.length + 2);    for (int i = 3; i < 5; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        verifyQuorumConfig(i, newServers, null);        verifyQuorumMembers(mt[i]);    }    Set<String> expectedConfigs = new HashSet<>();    for (String conf : oldServerAddress.values()) {                expectedConfigs.add(conf.substring(conf.indexOf('=') + 1));    }    for (int i = 0; i < 3; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i], expectedConfigs);    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();    }}
0
private void verifyQuorumConfig(int sid, List<String> joiningServers, List<String> leavingServers) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts.get(sid));    ReconfigTest.testNormalOperation(zk, zk);    ReconfigTest.testServerHasConfig(zk, joiningServers, leavingServers);    zk.close();}
0
private void verifyQuorumMembers(QuorumPeerTestBase.MainThread mt)
{    Set<String> expectedConfigs = new HashSet<>();    for (String config : serverAddress.values()) {        expectedConfigs.add(config.substring(config.indexOf('=') + 1));    }    verifyQuorumMembers(mt, expectedConfigs);}
0
private void verifyQuorumMembers(QuorumPeerTestBase.MainThread mt, Set<String> expectedConfigs)
{    Map<Long, QuorumPeer.QuorumServer> members = mt.getQuorumPeer().getQuorumVerifier().getAllMembers();    assertTrue("Quorum member should not change.", members.size() == expectedConfigs.size());    for (QuorumPeer.QuorumServer qs : members.values()) {        String actualConfig = qs.toString();        assertTrue("Unexpected config " + actualConfig + " found!", expectedConfigs.contains(actualConfig));    }}
0
public void testGetClientAddressShouldReturnEmptyStringWhenClientAddressIsNull()
{    InetSocketAddress peerCommunicationAddress = null;        QuorumServer peer = new QuorumServer(1, peerCommunicationAddress);    RemotePeerBean remotePeerBean = new RemotePeerBean(null, peer);    String clientAddress = remotePeerBean.getClientAddress();    assertNotNull(clientAddress);    assertEquals(0, clientAddress.length());}
0
public void testIsLeader()
{    long peerId = 7;    QuorumPeer.QuorumServer quorumServerMock = mock(QuorumPeer.QuorumServer.class);    when(quorumServerMock.getId()).thenReturn(peerId);    QuorumPeer peerMock = mock(QuorumPeer.class);    RemotePeerBean remotePeerBean = new RemotePeerBean(peerMock, quorumServerMock);    when(peerMock.isLeader(eq(peerId))).thenReturn(true);    assertTrue(remotePeerBean.isLeader());    when(peerMock.isLeader(eq(peerId))).thenReturn(false);    assertFalse(remotePeerBean.isLeader());}
0
public void setUp() throws Exception
{            ClientBase.setupTestEnv();    mt = new MainThread[SERVER_COUNT];    clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server.").append(i).append("=127.0.0.1:").append(PortAssignment.unique()).append(":").append(PortAssignment.unique()).append("\n");    }    sb.append("localSessionsEnabled=true\n");    sb.append("localSessionsUpgradingEnabled=true\n");    String cfg = sb.toString();        qpMain = new TestQPMainDropSessionUpgrading[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();        qpMain[i] = qp;        mt[i] = new MainThread(i, clientPorts[i], cfg, false) {            @Override            public TestQPMain getTestQPMain() {                return qp;            }        };        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }}
1
public TestQPMain getTestQPMain()
{    return qp;}
0
public void tearDown() throws Exception
{        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
1
public void testLocalSessionUpgradeSnapshot() throws IOException, InterruptedException
{        int leader = -1;    int followerA = -1;    for (int i = SERVER_COUNT - 1; i >= 0; i--) {        if (mt[i].main.quorumPeer.leader != null) {            leader = i;        } else if (followerA == -1) {            followerA = i;        }    }        qpMain[followerA].setDropCreateSession(true);            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);        long sessionId = zk.getSessionId();        try {        zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("expect to failed to upgrade session due to the " + "TestQPMainDropSessionUpgrading is being used");    } catch (KeeperException e) {            }        qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);        Thread.sleep(500);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    ArrayList<States> waitStates = new ArrayList<States>();    waitStates.add(States.CONNECTING);    waitStates.add(States.CLOSED);    waitForOne(zk, waitStates);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        for (int i = 0; i < SERVER_COUNT; i++) {        ConcurrentHashMap<Long, Integer> sessions = mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();        assertFalse("server " + i + " should not have global " + "session " + sessionId, sessions.containsKey(sessionId));    }    zk.close();}
1
public void testOnlyUpgradeSessionOnce() throws IOException, InterruptedException, KeeperException
{            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    long sessionId = zk.getSessionId();    QuorumZooKeeperServer server = (QuorumZooKeeperServer) mt[0].main.quorumPeer.getActiveServer();    Request create1 = createEphemeralRequest("/data-1", sessionId);    Request create2 = createEphemeralRequest("/data-2", sessionId);    assertNotNull("failed to upgrade on a ephemeral create", server.checkUpgradeSession(create1));    assertNull("tried to upgrade again", server.checkUpgradeSession(create2));        zk.close();}
0
public void setDropCreateSession(boolean dropCreateSession)
{    shouldDrop = dropCreateSession;}
0
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer() {        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {                @Override                protected void request(Request request) throws IOException {                    if (!shouldDrop) {                        super.request(request);                        return;                    }                                        if (request.type == ZooDefs.OpCode.createSession) {                                                return;                    }                    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                        CreateRequest createRequest = new CreateRequest();                        request.request.rewind();                        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                        request.request.rewind();                        try {                            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                            if (createMode.isEphemeral()) {                                request.cnxn.sendCloseSession();                            }                        } catch (KeeperException e) {                        }                        return;                    }                    super.request(request);                }            };        }    };}
1
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void request(Request request) throws IOException {            if (!shouldDrop) {                super.request(request);                return;            }                        if (request.type == ZooDefs.OpCode.createSession) {                                return;            }            if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                CreateRequest createRequest = new CreateRequest();                request.request.rewind();                ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                request.request.rewind();                try {                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                    if (createMode.isEphemeral()) {                        request.cnxn.sendCloseSession();                    }                } catch (KeeperException e) {                }                return;            }            super.request(request);        }    };}
1
protected void request(Request request) throws IOException
{    if (!shouldDrop) {        super.request(request);        return;    }        if (request.type == ZooDefs.OpCode.createSession) {                return;    }    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        try {            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());            if (createMode.isEphemeral()) {                request.cnxn.sendCloseSession();            }        } catch (KeeperException e) {        }        return;    }    super.request(request);}
1
private void waitForOne(ZooKeeper zk, ArrayList<States> states) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (!states.contains(zk.getState())) {        if (iterations-- == 0) {                        throw new RuntimeException("Waiting too long");        }        Thread.sleep(500);    }}
1
private Request createEphemeralRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
0
public void startSingleServerTest() throws Exception
{    setUpData();        startServer(leaderId, serverStrings.get(leaderId) + "\n");    ReconfigTest.testServerHasConfig(zkHandles[leaderId], null, null);            startFollowers();    testReconfig(leaderId, true, reconfigServers);            shutDownServer(leaderId);    ReconfigTest.testNormalOperation(zkHandles[follower1], zkHandles[follower2]);            reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        ReconfigTest.reconfig(zkAdminHandles[follower1], null, reconfigServers, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }            reconfigServers.clear();    reconfigServers.add(Integer.toString(leaderId));    reconfigServers.add(Integer.toString(follower1));    testReconfig(follower2, false, reconfigServers);            shutDownServer(follower1);        reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        zkAdminHandles[follower2].reconfigure(null, reconfigServers, null, -1, new Stat());        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }            ArrayList<String> observerStrings = new ArrayList<String>();    startObservers(observerStrings);        testReconfig(follower2, true, reconfigServers);        testReconfig(follower2, true, observerStrings);        shutDownData();}
1
private void setUpData() throws Exception
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setStandaloneEnabled(false);    QuorumPeerConfig.setReconfigEnabled(true);    peers = new MainThread[NUM_SERVERS];    zkHandles = new ZooKeeper[NUM_SERVERS];    zkAdminHandles = new ZooKeeperAdmin[NUM_SERVERS];    clientPorts = new int[NUM_SERVERS];    serverStrings = buildServerStrings();    reconfigServers = new ArrayList<String>();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
0
private void shutDownData() throws Exception
{    for (int i = 0; i < NUM_SERVERS; i++) {        zkHandles[i].close();        zkAdminHandles[i].close();    }    for (int i = 1; i < NUM_SERVERS; i++) {        peers[i].shutdown();    }}
0
private ArrayList<String> buildServerStrings()
{    ArrayList<String> serverStrings = new ArrayList<String>();    for (int i = 0; i < NUM_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;" + "localhost:" + clientPorts[i];        serverStrings.add(server);    }    return serverStrings;}
0
private void startServer(int id, String config) throws Exception
{    peers[id] = new MainThread(id, clientPorts[id], config);    peers[id].start();    assertTrue("Server " + id + " is not up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT));    assertTrue("Error- Server started in Standalone Mode!", peers[id].isQuorumPeerRunning());    zkHandles[id] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[id]);    zkAdminHandles[id] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT, this);    zkAdminHandles[id].addAuthInfo("digest", "super:test".getBytes());    String statCommandOut = FourLetterWordMain.send4LetterWord("127.0.0.1", clientPorts[id], "stat");    }
1
private void shutDownServer(int id) throws Exception
{    peers[id].shutdown();    ClientBase.waitForServerDown("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT);    TimeUnit.SECONDS.sleep(25);}
0
private void startFollowers() throws Exception
{    reconfigServers.clear();    for (int i = 1; i <= 2; i++) {        String config = serverStrings.get(leaderId) + "\n" + serverStrings.get(i) + "\n" + serverStrings.get(i % 2 + 1) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));    }}
0
private void startObservers(ArrayList<String> observerStrings) throws Exception
{    reconfigServers.clear();    for (int i = observer1; i <= observer2; i++) {        String config = serverStrings.get(follower2) + "\n" + serverStrings.get(i) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));        observerStrings.add(serverStrings.get(i).replace("participant", "observer"));    }}
0
private void testReconfig(int id, boolean adding, ArrayList<String> servers) throws Exception
{    if (adding) {        ReconfigTest.reconfig(zkAdminHandles[id], servers, null, null, -1);        for (String server : servers) {                        int id2 = Integer.parseInt(server.substring(7, 8));            ReconfigTest.testNormalOperation(zkHandles[id], zkHandles[id2]);        }        ReconfigTest.testServerHasConfig(zkHandles[id], servers, null);    } else {        ReconfigTest.reconfig(zkAdminHandles[id], null, servers, null, -1);        ReconfigTest.testServerHasConfig(zkHandles[id], null, servers);    }}
0
public void startObserver() throws Exception
{    int clientPort = PortAssignment.unique();    String config = "server." + observer1 + "=localhost:" + PortAssignment.unique() + ":" + clientPort + ":observer;" + "localhost:" + PortAssignment.unique();    MainThread observer = new MainThread(observer1, clientPort, config);    observer.start();    assertFalse("Observer was able to start by itself!", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
0
public void setUp()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    LeaderZooKeeperServer zks = mock(LeaderZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    providerMock = mock(ServerStats.Provider.class);    when(zks.serverStats()).thenReturn(new ServerStats(providerMock));    ZKDatabase zkDatabaseMock = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(zkDatabaseMock);    Leader leaderMock = mock(Leader.class);    when(leaderMock.getProposalStats()).thenReturn(new BufferStats());    when(zks.getLeader()).thenReturn(leaderMock);    ServerCnxnFactory serverCnxnFactory = mock(ServerCnxnFactory.class);    ServerCnxn serverCnxn = mock(ServerCnxn.class);    List<ServerCnxn> connections = new ArrayList<>();    connections.add(serverCnxn);    when(serverCnxnFactory.getConnections()).thenReturn(connections);    statCommand = new StatCommand(new PrintWriter(outputWriter), serverCnxnMock, FourLetterCommands.statCmd);    statCommand.setZkServer(zks);    statCommand.setFactory(serverCnxnFactory);}
0
public void testLeaderStatCommand()
{        when(providerMock.getState()).thenReturn("leader");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: leader"));    assertThat(output, containsString("Proposal sizes last/min/max:"));}
0
public void testFollowerStatCommand()
{        when(providerMock.getState()).thenReturn("follower");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: follower"));}
0
private void assertCommonStrings(String output)
{    assertThat(output, containsString("Clients:"));    assertThat(output, containsString("Zookeeper version:"));    assertThat(output, containsString("Node count:"));}
0
public void setUp()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    zks = mock(ZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    serverStats = mock(ServerStats.class);    when(zks.serverStats()).thenReturn(serverStats);    statResetCommand = new StatResetCommand(new PrintWriter(outputWriter), serverCnxnMock);    statResetCommand.setZkServer(zks);}
0
public void testStatResetWithZKNotRunning()
{        when(zks.isRunning()).thenReturn(false);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals(ZK_NOT_SERVING + "\n", output);}
0
public void testStatResetWithFollower()
{        when(zks.isRunning()).thenReturn(true);    when(serverStats.getServerState()).thenReturn("follower");        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();}
0
public void testStatResetWithLeader()
{        LeaderZooKeeperServer leaderZks = mock(LeaderZooKeeperServer.class);    when(leaderZks.isRunning()).thenReturn(true);    when(leaderZks.serverStats()).thenReturn(serverStats);    Leader leader = mock(Leader.class);    when(leaderZks.getLeader()).thenReturn(leader);    statResetCommand.setZkServer(leaderZks);    when(serverStats.getServerState()).thenReturn("leader");    BufferStats bufferStats = mock(BufferStats.class);    when(leader.getProposalStats()).thenReturn(bufferStats);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();    verify(bufferStats, times(1)).reset();}
0
public void setup() throws Exception
{    ZKDatabase db = mock(ZKDatabase.class);    when(db.append(any(Request.class))).thenReturn(true);    doAnswer(invocation -> {        Thread.sleep(100);        return null;    }).when(db).commit();    zks = mock(ZooKeeperServer.class);    when(zks.getZKDatabase()).thenReturn(db);    nextProcessor = mock(RequestProcessor.class);    doAnswer(invocationOnMock -> {        allRequestsFlushed.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));}
0
private Request createRquest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
0
public void testSyncProcessorMetrics() throws Exception
{    SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, nextProcessor);    for (int i = 0; i < 500; i++) {        syncProcessor.processRequest(createRquest(1, i));    }    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(500L, values.get("sync_processor_request_queued"));    allRequestsFlushed = new CountDownLatch(500);    syncProcessor.start();    allRequestsFlushed.await(5000, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(501L, values.get("cnt_sync_processor_queue_size"));    assertEquals(500L, values.get("max_sync_processor_queue_size"));    assertEquals(0L, values.get("min_sync_processor_queue_size"));    assertEquals(500L, values.get("cnt_sync_processor_queue_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_processor_queue_and_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_and_flush_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_process_time"));    assertThat((long) values.get("max_sync_process_time"), greaterThan(0L));    assertEquals(500L, values.get("max_sync_processor_batch_size"));    assertEquals(1L, values.get("cnt_sync_processor_queue_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_flush_time_ms"), greaterThanOrEqualTo(100L));    syncProcessor.shutdown();}
0
public static Collection<Object[]> params()
{    ArrayList<Object[]> result = new ArrayList<>();    result.add(new Object[] { true });    result.add(new Object[] { false });    return result;}
0
public static void setUpClass() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    tempDir = ClientBase.createEmptyTestDir();    x509TestContext = X509TestContext.newBuilder().setTempDir(tempDir).setKeyStoreKeyType(X509KeyType.EC).setTrustStoreKeyType(X509KeyType.EC).build();}
0
public static void tearDownClass()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);}
0
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
public void setUp() throws Exception
{    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "100");    workerPool = Executors.newCachedThreadPool();    port = PortAssignment.unique();    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);    listeningSocket = new UnifiedServerSocket(x509Util, true);    listeningSocket.bind(localServerAddress);    Future<UnifiedServerSocket.UnifiedSocket> acceptFuture;    acceptFuture = workerPool.submit(new Callable<UnifiedServerSocket.UnifiedSocket>() {        @Override        public UnifiedServerSocket.UnifiedSocket call() throws Exception {            try {                return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();            } catch (IOException e) {                                throw e;            }        }    });    if (useSecureClient) {        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);    } else {        clientSocket = new Socket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(new byte[] { 1, 2, 3, 4, 5 });    }    serverSideSocket = acceptFuture.get();}
1
public UnifiedServerSocket.UnifiedSocket call() throws Exception
{    try {        return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();    } catch (IOException e) {                throw e;    }}
1
public void tearDown() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    forceClose(listeningSocket);    forceClose(serverSideSocket);    forceClose(clientSocket);    workerPool.shutdown();    workerPool.awaitTermination(1000, TimeUnit.MILLISECONDS);    x509Util.close();}
0
public void testGetInetAddress()
{    serverSideSocket.getInetAddress();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetLocalAddress()
{    serverSideSocket.getLocalAddress();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetPort()
{    serverSideSocket.getPort();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetLocalPort()
{    serverSideSocket.getLocalPort();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetRemoteSocketAddress()
{    serverSideSocket.getRemoteSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetLocalSocketAddress()
{    serverSideSocket.getLocalSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetInputStream() throws IOException
{    serverSideSocket.getInputStream();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetOutputStream() throws IOException
{    serverSideSocket.getOutputStream();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetTcpNoDelay() throws IOException
{    serverSideSocket.getTcpNoDelay();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetTcpNoDelay() throws IOException
{    boolean tcpNoDelay = serverSideSocket.getTcpNoDelay();    tcpNoDelay = !tcpNoDelay;    serverSideSocket.setTcpNoDelay(tcpNoDelay);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(tcpNoDelay, serverSideSocket.getTcpNoDelay());}
0
public void testGetSoLinger() throws IOException
{    serverSideSocket.getSoLinger();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetSoLinger() throws IOException
{    int soLinger = serverSideSocket.getSoLinger();    if (soLinger == -1) {                serverSideSocket.setSoLinger(true, 1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(1, serverSideSocket.getSoLinger());    } else {                serverSideSocket.setSoLinger(false, -1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(-1, serverSideSocket.getSoLinger());    }}
0
public void testGetSoTimeout() throws IOException
{    serverSideSocket.getSoTimeout();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetSoTimeout() throws IOException
{    int timeout = serverSideSocket.getSoTimeout();    timeout = timeout + 10;    serverSideSocket.setSoTimeout(timeout);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(timeout, serverSideSocket.getSoTimeout());}
0
public void testGetSendBufferSize() throws IOException
{    serverSideSocket.getSendBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetSendBufferSize() throws IOException
{    serverSideSocket.setSendBufferSize(serverSideSocket.getSendBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetReceiveBufferSize() throws IOException
{    serverSideSocket.getReceiveBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetReceiveBufferSize() throws IOException
{    serverSideSocket.setReceiveBufferSize(serverSideSocket.getReceiveBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetKeepAlive() throws IOException
{    serverSideSocket.getKeepAlive();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetKeepAlive() throws IOException
{    boolean keepAlive = serverSideSocket.getKeepAlive();    keepAlive = !keepAlive;    serverSideSocket.setKeepAlive(keepAlive);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(keepAlive, serverSideSocket.getKeepAlive());}
0
public void testGetTrafficClass() throws IOException
{    serverSideSocket.getTrafficClass();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetTrafficClass() throws IOException
{    serverSideSocket.setTrafficClass(SocketOptions.IP_TOS);    assertFalse(serverSideSocket.isModeKnown());}
0
public void testGetReuseAddress() throws IOException
{    serverSideSocket.getReuseAddress();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testSetReuseAddress() throws IOException
{    boolean reuseAddress = serverSideSocket.getReuseAddress();    reuseAddress = !reuseAddress;    serverSideSocket.setReuseAddress(reuseAddress);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(reuseAddress, serverSideSocket.getReuseAddress());}
0
public void testClose() throws IOException
{    serverSideSocket.close();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testShutdownInput() throws IOException
{    serverSideSocket.shutdownInput();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testShutdownOutput() throws IOException
{    serverSideSocket.shutdownOutput();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testIsConnected()
{    serverSideSocket.isConnected();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testIsBound()
{    serverSideSocket.isBound();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testIsClosed()
{    serverSideSocket.isClosed();    assertFalse(serverSideSocket.isModeKnown());}
0
public void testIsInputShutdown() throws IOException
{    serverSideSocket.isInputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownInput();    assertTrue(serverSideSocket.isInputShutdown());}
0
public void testIsOutputShutdown() throws IOException
{    serverSideSocket.isOutputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownOutput();    assertTrue(serverSideSocket.isOutputShutdown());}
0
public static Collection<Object[]> params()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (Boolean hostnameVerification : new Boolean[] { true, false }) {                result.add(new Object[] { caKeyType, certKeyType, hostnameVerification, paramIndex++ });            }        }    }    return result;}
0
public void setUp() throws Exception
{    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), PortAssignment.unique());    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);}
0
public void tearDown() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    x509Util.close();}
0
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
0
public void run()
{    try {        Random rnd = new Random();        while (true) {            final Socket unifiedSocket = serverSocket.accept();            final boolean tcpNoDelay = rnd.nextBoolean();            unifiedSocket.setTcpNoDelay(tcpNoDelay);            unifiedSocket.setSoTimeout(TIMEOUT);            final boolean keepAlive = rnd.nextBoolean();            unifiedSocket.setKeepAlive(keepAlive);                        BufferedInputStream bis = new BufferedInputStream(unifiedSocket.getInputStream());            workerPool.submit(new Runnable() {                @Override                public void run() {                    try {                        byte[] buf = new byte[1024];                        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                                                                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());                        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());                        assertEquals(keepAlive, unifiedSocket.getKeepAlive());                        if (bytesRead > 0) {                            byte[] dataFromClient = new byte[bytesRead];                            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);                            synchronized (dataFromClients) {                                dataFromClients.add(dataFromClient);                            }                        }                        unifiedSocket.getOutputStream().write(dataToClient);                        unifiedSocket.getOutputStream().flush();                    } catch (IOException e) {                        throw new RuntimeException(e);                    } finally {                        forceClose(unifiedSocket);                    }                }            });        }    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(serverSocket);        workerPool.shutdown();    }}
0
public void run()
{    try {        byte[] buf = new byte[1024];        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());        assertEquals(keepAlive, unifiedSocket.getKeepAlive());        if (bytesRead > 0) {            byte[] dataFromClient = new byte[bytesRead];            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);            synchronized (dataFromClients) {                dataFromClients.add(dataFromClient);            }        }        unifiedSocket.getOutputStream().write(dataToClient);        unifiedSocket.getOutputStream().flush();    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(unifiedSocket);    }}
0
public void shutdown(long millis) throws InterruptedException
{        forceClose(serverSocket);    workerPool.awaitTermination(millis, TimeUnit.MILLISECONDS);    this.join(millis);}
0
 synchronized byte[] getDataFromClient(int index)
{    return dataFromClients.get(index);}
0
 synchronized boolean receivedAnyDataFromClient()
{    return !dataFromClients.isEmpty();}
0
private SSLSocket connectWithSSL() throws IOException, X509Exception, InterruptedException
{    SSLSocket sslSocket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            sslSocket = x509Util.createSSLSocket();            sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                @Override                public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                    synchronized (handshakeCompletedLock) {                        handshakeCompleted = true;                        handshakeCompletedLock.notifyAll();                    }                }            });            sslSocket.setSoTimeout(TIMEOUT);            sslSocket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(sslSocket);            sslSocket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server with SSL", sslSocket);    return sslSocket;}
0
public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent)
{    synchronized (handshakeCompletedLock) {        handshakeCompleted = true;        handshakeCompletedLock.notifyAll();    }}
0
private Socket connectWithoutSSL() throws IOException, InterruptedException
{    Socket socket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            socket = new Socket();            socket.setSoTimeout(TIMEOUT);            socket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(socket);            socket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server without SSL", socket);    return socket;}
0
public void testConnectWithSSLToNonStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testConnectWithSSLToStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testConnectWithoutSSLToNonStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {        socket.getOutputStream().write(DATA_FROM_CLIENT);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testConnectWithoutSSLToNonStrictServerPartialWrite() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {                                socket.getOutputStream().write(DATA_FROM_CLIENT, 0, 2);        socket.getOutputStream().flush();        Thread.sleep(TIMEOUT / 2);        socket.getOutputStream().write(DATA_FROM_CLIENT, 2, DATA_FROM_CLIENT.length - 2);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testConnectWithoutSSLToStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    socket.getOutputStream().write(DATA_FROM_CLIENT);    socket.getOutputStream().flush();    byte[] buf = new byte[DATA_TO_CLIENT.length];    try {        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        if (bytesRead == -1) {                        return;        }    } catch (SocketException e) {                return;    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);                        assertFalse("The strict server accepted connection without SSL.", serverThread.receivedAnyDataFromClient());    }    fail("Expected server to hang up the connection. Read from server succeeded unexpectedly.");}
0
public void testTLSDetectionNonBlockingNonStrictServerIdleClient() throws Exception
{    Socket badClientSocket = null;    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(badClientSocket);        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testTLSDetectionNonBlockingStrictServerIdleClient() throws Exception
{    Socket badClientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(badClientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testTLSDetectionNonBlockingNonStrictServerDisconnectedClient() throws Exception
{    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void testTLSDetectionNonBlockingStrictServerDisconnectedClient() throws Exception
{    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
0
public void setUp()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
0
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
0
public void testWatchesLeak() throws Exception
{    NIOServerCnxnFactory serverCnxnFactory = mock(NIOServerCnxnFactory.class);    final SelectionKey sk = new FakeSK();    MockSelectorThread selectorThread = mock(MockSelectorThread.class);    when(selectorThread.addInterestOpsUpdateRequest(any(SelectionKey.class))).thenAnswer(new Answer<Boolean>() {        @Override        public Boolean answer(InvocationOnMock invocation) throws Throwable {            SelectionKey sk = (SelectionKey) invocation.getArguments()[0];            NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();            sk.interestOps(nioSrvCnx.getInterestOps());            return true;        }    });    ZKDatabase database = new ZKDatabase(null);    database.setlastProcessedZxid(2L);    QuorumPeer quorumPeer = mock(QuorumPeer.class);    FileTxnSnapLog logfactory = mock(FileTxnSnapLog.class);        when(logfactory.getDataDir()).thenReturn(new File(""));    when(logfactory.getSnapDir()).thenReturn(new File(""));    FollowerZooKeeperServer fzks = null;    try {                fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);        fzks.startup();        fzks.setServerCnxnFactory(serverCnxnFactory);        quorumPeer.follower = new MyFollower(quorumPeer, fzks);                        final SocketChannel socketChannel = createClientSocketChannel();                final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);        sk.attach(nioCnxn);                nioCnxn.doIO(sk);                        QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);        quorumPeer.follower.processPacket(qp);                                nioCnxn.doIO(sk);                Thread.sleep(1000L);                        int watchCount = database.getDataTree().getWatchCount();        if (sessionTimedout) {                                    assertEquals("Session is not valid so there should be no watches", 0, watchCount);        } else {                                    assertEquals("Session is valid so the watch should be there", 1, watchCount);        }    } finally {        if (fzks != null) {            fzks.shutdown();        }    }}
1
public Boolean answer(InvocationOnMock invocation) throws Throwable
{    SelectionKey sk = (SelectionKey) invocation.getArguments()[0];    NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();    sk.interestOps(nioSrvCnx.getInterestOps());    return true;}
0
public SelectableChannel channel()
{    return null;}
0
public Selector selector()
{    return mock(Selector.class);}
0
public boolean isValid()
{    return true;}
0
public void cancel()
{}
0
public int interestOps()
{    return ops;}
0
public SelectionKey interestOps(int ops)
{    this.ops = ops;    return this;}
0
public int readyOps()
{    boolean reading = (ops & OP_READ) != 0;    boolean writing = (ops & OP_WRITE) != 0;    if (reading && writing) {            } else if (reading) {            } else if (writing) {            }    return ops;}
1
private ByteBuffer createWatchesMessage()
{    List<String> dataWatches = new ArrayList<String>(1);    dataWatches.add("/");    List<String> existWatches = Collections.emptyList();    List<String> childWatches = Collections.emptyList();    SetWatches sw = new SetWatches(1L, dataWatches, existWatches, childWatches);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setWatches);    h.setXid(-8);    MockPacket p = new MockPacket(h, new ReplyHeader(), sw, null, null);    return p.createAndReturnBB();}
0
private ByteBuffer createConnRequest()
{    Random r = new Random(SESSION_ID ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    ConnectRequest conReq = new ConnectRequest(0, 1L, 30000, SESSION_ID, p);    MockPacket packet = new MockPacket(null, null, conReq, null, null, false);    return packet.createAndReturnBB();}
0
private SocketChannel createClientSocketChannel() throws IOException
{    SocketChannel socketChannel = mock(SocketChannel.class);    Socket socket = mock(Socket.class);    InetSocketAddress socketAddress = new InetSocketAddress(1234);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddress);    when(socketChannel.socket()).thenReturn(socket);        final ByteBuffer connRequest = createConnRequest();    final ByteBuffer watchesMessage = createWatchesMessage();    final ByteBuffer request = ByteBuffer.allocate(connRequest.limit() + watchesMessage.limit());    request.put(connRequest);    request.put(watchesMessage);    Answer<Integer> answer = new Answer<Integer>() {        int i = 0;        @Override        public Integer answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            ByteBuffer bb = (ByteBuffer) args[0];            for (int k = 0; k < bb.limit(); k++) {                bb.put(request.get(i));                i = i + 1;            }            return bb.limit();        }    };    when(socketChannel.read(any(ByteBuffer.class))).thenAnswer(answer);    return socketChannel;}
0
public Integer answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    ByteBuffer bb = (ByteBuffer) args[0];    for (int k = 0; k < bb.limit(); k++) {        bb.put(request.get(i));        i = i + 1;    }    return bb.limit();}
0
private QuorumPacket createValidateSessionPacketResponse(boolean valid) throws Exception
{    QuorumPacket qp = createValidateSessionPacket();    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);        dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    return qp;}
0
private QuorumPacket createValidateSessionPacket() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(SESSION_ID);    dos.writeInt(3000);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    return qp;}
0
public void setUp()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
0
public void run()
{    try {        leader.lead();    } catch (InterruptedException e) {            } catch (Exception e) {            } finally {        leader.shutdown("lead ended");    }}
1
public void run()
{    if (onlyGetEpochToPropose) {        try {            epoch = leader.getEpochToPropose(followerSid, 0);        } catch (Exception e) {        }    } else {        try {            leader.waitForEpochAck(followerSid, new StateSummary(0, 0));            msg = "FollowerMockThread (id = " + followerSid + ")  returned from waitForEpochAck";        } catch (Exception e) {        }    }}
0
public void testLeaderInConnectingFollowers() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        FollowerMockThread f1 = new FollowerMockThread(1, leader, true);        FollowerMockThread f2 = new FollowerMockThread(2, leader, true);        f1.start();        f2.start();                                f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                try {            long epoch = leader.getEpochToPropose(leader.self.getId(), leader.self.getAcceptedEpoch());            assertEquals("leader got wrong epoch from getEpochToPropose", 6, epoch);        } catch (Exception e) {            fail("leader timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public void testLastAcceptedEpoch() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    LeadThread leadThread = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createMockLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        leadThread = new LeadThread(leader);        leadThread.start();        while (((MockLeader) leader).getCurrentEpochToPropose() != 6) {            Thread.sleep(20);        }        try {            long epoch = leader.getEpochToPropose(1, 6);            assertEquals("New proposed epoch is wrong", 7, epoch);        } catch (Exception e) {            fail("Timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public void testLeaderInElectingFollowers() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        FollowerMockThread f1 = new FollowerMockThread(1, leader, false);        FollowerMockThread f2 = new FollowerMockThread(2, leader, false);                leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());        f1.start();        f2.start();                        f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                assertTrue(f1.msg + " without waiting for leader", f1.msg == null);        assertTrue(f2.msg + " without waiting for leader", f2.msg == null);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
 static Socket[] getSocketPair() throws IOException
{    ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));    InetSocketAddress endPoint = (InetSocketAddress) ss.getLocalSocketAddress();    Socket s = new Socket(endPoint.getAddress(), endPoint.getPort());    return new Socket[] { s, ss.accept() };}
0
 static void readPacketSkippingPing(InputArchive ia, QuorumPacket qp) throws IOException
{    while (true) {        ia.readRecord(qp, null);        if (qp.getType() != Leader.PING) {            return;        }    }}
0
public void testLeaderConversation(LeaderConversation conversation) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversation, int ops) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {                FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);        ZKDatabase zkDb = new ZKDatabase(snapLog);        assertTrue(ops >= 1);        long zxid = ZxidUtils.makeZxid(1, 0);        for (int i = 1; i <= ops; i++) {            zxid = ZxidUtils.makeZxid(1, i);            String path = "/foo-" + i;            zkDb.processTxn(new TxnHeader(13, 1000 + i, zxid, 30 + i, ZooDefs.OpCode.create), new CreateTxn(path, "fpjwasalsohere".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));            Stat stat = new Stat();            assertEquals("fpjwasalsohere", new String(zkDb.getData(path, stat, null)));        }        assertTrue(zxid > ZxidUtils.makeZxid(1, 0));                snapLog.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), false);        snapLog.close();        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;                peer.setAcceptedEpoch(1);        peer.setCurrentEpoch(1);        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader, zxid);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public void testFollowerConversation(FollowerConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread followerThread = null;    ConversableFollower follower = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        follower = createFollower(tmpDir, peer);        peer.follower = follower;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        follower.setLeaderQuorumServer(leaderQS);        final Follower followerForThread = follower;        followerThread = new Thread() {            public void run() {                try {                    followerForThread.followLeader();                } catch (InterruptedException e) {                                    } catch (Exception e) {                                    }            }        };        followerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithFollower(ia, oa, follower);    } finally {        if (follower != null) {            follower.shutdown();        }        if (followerThread != null) {            followerThread.interrupt();            followerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
1
public void run()
{    try {        followerForThread.followLeader();    } catch (InterruptedException e) {            } catch (Exception e) {            }}
1
public void testObserverConversation(ObserverConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread observerThread = null;    ConversableObserver observer = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        peer.setSyncEnabled(true);        observer = createObserver(tmpDir, peer);        peer.observer = observer;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        observer.setLeaderQuorumServer(leaderQS);        final Observer observerForThread = observer;        observerThread = new Thread() {            public void run() {                try {                    observerForThread.observeLeader();                } catch (Exception e) {                    e.printStackTrace();                }            }        };        observerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithObserver(ia, oa, observer);    } finally {        if (observer != null) {            observer.shutdown();        }        if (observerThread != null) {            observerThread.interrupt();            observerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public void run()
{    try {        observerForThread.observeLeader();    } catch (Exception e) {        e.printStackTrace();    }}
0
public void testUnnecessarySnap() throws Exception
{    testPopulatedLeaderConversation(new PopulatedLeaderConversation() {        @Override        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception {            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(2, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            byte[] epochBytes = new byte[4];            final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);            wrappedEpochBytes.putInt(1);            qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());        }    }, 2);}
0
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception
{    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(2, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    byte[] epochBytes = new byte[4];    final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);    wrappedEpochBytes.putInt(1);    qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());}
0
 synchronized void waitForChange() throws InterruptedException
{    while (!changed) {        wait();    }}
0
public void process(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        synchronized (this) {            changed = true;            notifyAll();        }    }}
0
public synchronized boolean changed()
{    return changed;}
0
public void testNormalFollowerRun() throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                                Thread.sleep(10);                                verify(f.zk, never()).takeSnapshot();                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                verify(f.zk).takeSnapshot(true);                assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(firstZxid, lastZxid);                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                TrackerWatcher watcher = new TrackerWatcher();                                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(proposalZxid, qp.getZxid());                watcher.waitForChange();                assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(proposalZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
0
public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);                Thread.sleep(10);                verify(f.zk, never()).takeSnapshot();        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                verify(f.zk).takeSnapshot(true);        assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(firstZxid, lastZxid);                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, proposalZxid, "data2", 2);        oa.writeRecord(qp, null);        TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(proposalZxid, qp.getZxid());        watcher.waitForChange();        assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(proposalZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
0
private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
0
public void testNormalFollowerRunWithDiff() throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.DIFF);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                final long createSessionZxid = ZxidUtils.makeZxid(1, 2);                proposeNewSession(qp, createSessionZxid, 0x333);                oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);                qp.setZxid(createSessionZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                qp.setData(null);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                                long start = System.currentTimeMillis();                while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                }                assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                start = System.currentTimeMillis();                zkDb2.loadDataBase();                while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                    zkDb2.loadDataBase();                }                                                assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                                verify(f.zk, never()).takeSnapshot();            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);            CreateSessionTxn cst = new CreateSessionTxn(30000);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(cst, null);            qp.setData(baos.toByteArray());        }    });}
1
public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.DIFF);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        final long createSessionZxid = ZxidUtils.makeZxid(1, 2);        proposeNewSession(qp, createSessionZxid, 0x333);        oa.writeRecord(qp, null);        qp.setType(Leader.COMMIT);        qp.setZxid(createSessionZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        qp.setData(null);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                        long start = System.currentTimeMillis();        while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);        }        assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        start = System.currentTimeMillis();        zkDb2.loadDataBase();        while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);            zkDb2.loadDataBase();        }                        assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                verify(f.zk, never()).takeSnapshot();    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
1
private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);    CreateSessionTxn cst = new CreateSessionTxn(30000);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(cst, null);    qp.setData(baos.toByteArray());}
0
public void testNormalRun() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
0
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
0
public void testTxnTimeout() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());            long zxid = l.zk.getZxid();            l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));            readPacketSkippingPing(ia, qp);            assertEquals(Leader.PROPOSAL, qp.getType());                        for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {                try {                    ia.readRecord(qp, null);                                        qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);                    oa.writeRecord(qp, null);                } catch (EOFException e) {                    return;                }            }            fail("Connection hasn't been closed by leader after transaction times out.");        }    });}
1
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());    long zxid = l.zk.getZxid();    l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));    readPacketSkippingPing(ia, qp);    assertEquals(Leader.PROPOSAL, qp.getType());        for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {        try {            ia.readRecord(qp, null);                        qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);            oa.writeRecord(qp, null);        } catch (EOFException e) {            return;        }    }    fail("Connection hasn't been closed by leader after transaction times out.");}
1
private void deserializeSnapshot(InputArchive ia) throws IOException
{    ZKDatabase zkdb = new ZKDatabase(null);    zkdb.deserializeSnapshot(ia);    String signature = ia.readString("signature");    assertEquals("BenWasHere", signature);}
0
public void testNormalObserverRun() throws Exception
{    testObserverConversation(new ObserverConversation() {        @Override        public void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();            try {                assertEquals(0, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long foo1Zxid = ZxidUtils.makeZxid(1, 1);                final long foo2Zxid = ZxidUtils.makeZxid(1, 2);                zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));                assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.OBSERVERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(1, o.self.getCurrentEpoch());                assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals(foo2Zxid, lastZxid);                                TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                                long informZxid = ZxidUtils.makeZxid(1, 1001);                proposeSetData(qp, "/foo2", informZxid, "data2", 2);                qp.setType(Leader.INFORM);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                watcher.waitForChange();                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                                                o.zk.shutdown();                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));                assertEquals(informZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
0
public void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();    try {        assertEquals(0, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long foo1Zxid = ZxidUtils.makeZxid(1, 1);        final long foo2Zxid = ZxidUtils.makeZxid(1, 2);        zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));        assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.OBSERVERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(1, o.self.getCurrentEpoch());        assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals(foo2Zxid, lastZxid);                TrackerWatcher watcher = new TrackerWatcher();        assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);        oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);                long informZxid = ZxidUtils.makeZxid(1, 1001);        proposeSetData(qp, "/foo2", informZxid, "data2", 2);        qp.setType(Leader.INFORM);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                watcher.waitForChange();        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                        o.zk.shutdown();        zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));        assertEquals(informZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
0
private void proposeSetData(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
0
public void testLeaderBehind() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            /* we are going to say we last acked epoch 20 */            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
0
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    /* we are going to say we last acked epoch 20 */    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
0
public void testAbandonBeforeACKEpoch() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);                        assertEquals(0, l.self.getCurrentEpoch());        }    });}
0
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);        assertEquals(0, l.self.getCurrentEpoch());}
0
public void setLeaderQuorumServer(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
0
protected QuorumServer findLeader()
{    return leaderQuorumServer;}
0
private ConversableFollower createFollower(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    FollowerZooKeeperServer zk = new FollowerZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableFollower(peer, zk);}
0
public void setLeaderQuorumServer(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
0
protected QuorumServer findLeader()
{    return leaderQuorumServer;}
0
private ConversableObserver createObserver(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    ObserverZooKeeperServer zk = new ObserverZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableObserver(peer, zk);}
0
private String readContentsOfFile(File f) throws IOException
{    return new BufferedReader(new FileReader(f)).readLine();}
0
public void testInitialAcceptedCurrent() throws Exception
{    File tmpDir = File.createTempFile("test", ".dir", testData);    tmpDir.delete();    tmpDir.mkdir();    try {        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);        File version2 = new File(tmpDir, "version-2");        version2.mkdir();        logFactory.save(new DataTree(), new ConcurrentHashMap<Long, Integer>(), false);        long zxid = ZxidUtils.makeZxid(3, 3);        logFactory.append(new Request(1, 1, ZooDefs.OpCode.error, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.error), new ErrorTxn(1), zxid));        logFactory.commit();        ZKDatabase zkDb = new ZKDatabase(logFactory);        QuorumPeer peer = QuorumPeer.testingQuorumPeer();        peer.setZKDatabase(zkDb);        peer.setTxnFactory(logFactory);        peer.getLastLoggedZxid();        assertEquals(3, peer.getAcceptedEpoch());        assertEquals(3, peer.getCurrentEpoch());        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.CURRENT_EPOCH_FILENAME))));        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.ACCEPTED_EPOCH_FILENAME))));    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
0
public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException
{    HashMap<Long, QuorumPeer.QuorumServer> peers = new HashMap<Long, QuorumPeer.QuorumServer>();    QuorumPeer peer = QuorumPeer.testingQuorumPeer();    peer.syncLimit = SYNC_LIMIT;    peer.initLimit = 2;    peer.tickTime = 2000;    peers.put(0L, new QuorumPeer.QuorumServer(0, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(1L, new QuorumPeer.QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(2L, new QuorumPeer.QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peer.setQuorumVerifier(new QuorumMaj(peers), false);    peer.setCnxnFactory(new NullServerCnxnFactory());    File version2 = new File(tmpDir, "version-2");    version2.mkdir();    ClientBase.createInitializeFile(tmpDir);    FileOutputStream fos = new FileOutputStream(new File(version2, "currentEpoch"));    fos.write("0\n".getBytes());    fos.close();    fos = new FileOutputStream(new File(version2, "acceptedEpoch"));    fos.write("0\n".getBytes());    fos.close();    return peer;}
0
public static Leader createLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new Leader(peer, zk);}
0
public static Leader createMockLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new MockLeader(peer, zk);}
0
private static LeaderZooKeeperServer prepareLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, peer, zkDb);    return zk;}
0
public void startup(ZooKeeperServer zkServer, boolean startServer) throws IOException, InterruptedException
{}
0
public void start()
{}
0
public void shutdown()
{}
0
public void setMaxClientCnxnsPerHost(int max)
{}
0
public void join() throws InterruptedException
{}
0
public int getMaxClientCnxnsPerHost()
{    return 0;}
0
public int getSocketListenBacklog()
{    return -1;}
0
public int getLocalPort()
{    return 0;}
0
public InetSocketAddress getLocalAddress()
{    return null;}
0
public Iterable<ServerCnxn> getConnections()
{    return null;}
0
public void configure(InetSocketAddress addr, int maxcc, int listenBacklog, boolean secure) throws IOException
{}
0
public boolean closeSession(long sessionId, ServerCnxn.DisconnectReason reason)
{    return false;}
0
public void closeAll(ServerCnxn.DisconnectReason reason)
{}
0
public int getNumAliveConnections()
{    return 0;}
0
public void reconfigure(InetSocketAddress addr)
{}
0
public void resetAllConnectionStats()
{}
0
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    return null;}
0
public long getCurrentEpochToPropose()
{    return epoch;}
0
public void testSameACLGivesSameID()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));}
0
public void testWhetherOrderingMatters()
{    List<ACL> testACL = new ArrayList<ACL>();    testACL.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    testACL.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = new ArrayList<ACL>();    testACL2.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    testACL2.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    assertFalse(aclId.equals(cache.convertAcls(testACL2)));}
0
public void testBidirectionality()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(testACL, cache.convertLong(aclId));}
0
public void testCacheSize()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));    assertEquals(1, cache.size());    List<ACL> testACL3 = createACL("differentId");    Long aclId3 = cache.convertAcls(testACL3);    assertFalse(aclId3.equals(aclId));    assertEquals(2, cache.size());}
0
public void testAddThenRemove()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
0
public void testMultipleAddsAndRemove()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("anotherId");    cache.convertAcls(testACL2);    cache.removeUsage(aclId);    assertEquals(2, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    Long newId = cache.convertAcls(testACL);    assertFalse(aclId.equals(newId));}
0
public void testAddUsage()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.addUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
0
public void testAddNonExistentUsage()
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    cache.addUsage(1L);    assertEquals(0, cache.size());/*        On startup, it's possible that we'll try calling addUsage of an ID not in the cache.  This is safe to ignore        as it'll be added later when we traverse the tranlog.  See discussion here:        http://mail-archives.apache.org/mod_mbox/zookeeper-user/201507.mbox/%3CCAB5oV2_ujhvBA1sEkCG2WRakPjCy%2BNR10620WK2G1GGgmEO44g%40mail.gmail.com%3E        This test makes sure that we don't add the ID to the cache in this case as that would result in dupes later        and consequently incorrect counts and entries that will never be cleaned out.         */}
0
public void testSerializeDeserialize() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    callAddUsageNTimes(deserializedCache, aclId3, 3);    callAddUsageNTimes(deserializedCache, aclId4, 4);    callAddUsageNTimes(deserializedCache, aclId5, 5);    assertCachesEqual(cache, deserializedCache);}
0
public void testNPEInDeserialize() throws IOException
{    ReferenceCountedACLCache serializeCache = new ReferenceCountedACLCache() {        @Override        public synchronized void serialize(OutputArchive oa) throws IOException {            oa.writeInt(1, "map");            oa.writeLong(1, "long");            oa.startVector(null, "acls");            oa.endVector(null, "acls");        }    };    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    serializeCache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    try {        deserializedCache.deserialize(inArchive);    } catch (NullPointerException e) {        fail("should not throw NPE while do deserialized");    } catch (RuntimeException e) {        }}
0
public synchronized void serialize(OutputArchive oa) throws IOException
{    oa.writeInt(1, "map");    oa.writeLong(1, "long");    oa.startVector(null, "acls");    oa.endVector(null, "acls");}
0
private void assertCachesEqual(ReferenceCountedACLCache expected, ReferenceCountedACLCache actual)
{    assertEquals(expected.aclIndex, actual.aclIndex);    assertEquals(expected.aclKeyMap, actual.aclKeyMap);    assertEquals(expected.longKeyMap, actual.longKeyMap);    assertEquals(expected.referenceCounter, actual.referenceCounter);}
0
public void testPurgeUnused() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    deserializedCache.purgeUnused();    assertEquals(2, deserializedCache.size());    assertEquals(aclId1, deserializedCache.convertAcls(acl1));    assertEquals(aclId2, deserializedCache.convertAcls(acl2));    assertFalse(acl3.equals(deserializedCache.convertAcls(acl3)));    assertFalse(acl4.equals(deserializedCache.convertAcls(acl4)));    assertFalse(acl5.equals(deserializedCache.convertAcls(acl5)));}
0
private void callAddUsageNTimes(ReferenceCountedACLCache deserializedCache, Long aclId, int num)
{    for (int i = 0; i < num; i++) {        deserializedCache.addUsage(aclId);    }}
0
private Long convertACLsNTimes(ReferenceCountedACLCache cache, List<ACL> acl, int num)
{    if (num <= 0) {        return -1L;    }    for (int i = 0; i < num - 1; i++) {        cache.convertAcls(acl);    }    return cache.convertAcls(acl);}
0
private List<ACL> createACL(String id)
{    List<ACL> acl1 = new ArrayList<ACL>();    acl1.add(new ACL(ZooDefs.Perms.ADMIN, new Id("scheme", id)));    return acl1;}
0
public void setup() throws Exception
{        File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    resumeProcess = null;    submitted = null;    zk = ClientBase.createZKClient(HOSTPORT);}
1
public void tearDown() throws Exception
{        if (null != zk) {        zk.close();    }    if (null != f) {        f.shutdown();    }    if (null != zks) {        zks.shutdown();    }}
0
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new TestPrepRequestProcessor(this, syncProcessor);    ((TestPrepRequestProcessor) firstProcessor).start();}
0
public void submitRequest(Request si)
{    if (null != submitted) {        submitted.countDown();    }    super.submitRequest(si);}
0
public void requestFinished(Request request)
{    if (null != finished) {        finished.countDown();    }    super.requestFinished(request);}
0
protected void pRequest(Request request) throws RequestProcessorException
{        if (resumeProcess != null) {        try {            resumeProcess.await(20, TimeUnit.SECONDS);        } catch (Exception e) {        }    }    if (entered != null) {        entered.countDown();    }    super.pRequest(request);}
0
public void testRequestThrottler() throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(false);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);    entered = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));            resumeProcess.countDown();    entered.await(STALL_TIME, TimeUnit.MILLISECONDS);    metrics = MetricsUtils.currentServerMetrics();    assertEquals(TOTAL_REQUESTS, (long) metrics.get("prep_processor_request_queued"));}
0
public void testDropStaleRequests() throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(true);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));    for (ServerCnxn cnxn : f.cnxns) {        cnxn.setStale();    }    zk = null;    resumeProcess.countDown();        while (zks.getInflight() > 0) {        Thread.sleep(50);    }            metrics = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1, (long) metrics.get("stale_requests_dropped"));}
1
public void testLargeRequestThrottling() throws Exception
{    ServerMetrics.getMetrics().resetAll();    AsyncCallback.StringCallback createCallback = (rc, path, ctx, name) -> {        if (KeeperException.Code.get(rc) == KeeperException.Code.CONNECTIONLOSS) {            disconnected.countDown();            connectionLossCount++;        }    };        RequestThrottler.setMaxRequests(5);        zks.setLargeRequestThreshold(150);    zks.setLargeRequestMaxBytes(400);        resumeProcess = new CountDownLatch(1);            disconnected = new CountDownLatch(TOTAL_REQUESTS);        byte[] data = new byte[100];        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createCallback, null);    }        disconnected.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();            Assert.assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    Assert.assertEquals(1L, (long) metrics.get("large_requests_rejected"));    Assert.assertEquals(5, connectionLossCount);    finished = new CountDownLatch(2);        resumeProcess.countDown();    finished.await(5, TimeUnit.SECONDS);        metrics = MetricsUtils.currentServerMetrics();    Assert.assertEquals(2, (long) metrics.get("stale_replies"));}
0
public void write(int b)
{}
0
 static int createNodes(DataTree tree, String path, int depth, int childcount, int parentCVersion, byte[] data) throws KeeperException.NodeExistsException, KeeperException.NoNodeException
{    path += "node" + depth;    tree.createNode(path, data, null, -1, ++parentCVersion, 1, 1);    if (--depth == 0) {        return 1;    }    path += "/";    int count = 1;    for (int i = 0; i < childcount; i++) {        count += createNodes(tree, path + i, depth, childcount, 1, data);    }    return count;}
0
private static void serializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    DataTree tree = new DataTree();    createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);    int count = tree.getNodeCount();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream());    System.gc();    long start = System.nanoTime();    tree.serialize(oa, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    }
1
public void testSingleSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(1, 0, 20);}
0
public void testWideSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(2, 10000, 20);}
0
public void testDeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(400, 1, 20);}
0
public void test10Wide5DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 10, 20);}
0
public void test15Wide5DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 15, 20);}
0
public void test25Wide4DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 25, 20);}
0
public void test40Wide4DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 40, 20);}
0
public void test300Wide3DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(3, 300, 20);}
0
public static List<TestType> data()
{    List<TestType> testTypes = new ArrayList<>();    for (boolean ttlsEnabled : new boolean[] { true, false }) {        for (int serverId = 0; serverId <= 255; ++serverId) {            testTypes.add(new TestType(ttlsEnabled, serverId));        }    }    return testTypes;}
0
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.extendedTypesEnabled");}
0
public void setUp() throws Exception
{    System.setProperty("zookeeper.extendedTypesEnabled", Boolean.toString(testType.ttlsEnabled));        try {        super.setUpWithServerId(testType.serverId);    } catch (RuntimeException e) {        if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {                        return;        }        throw e;    }}
1
public void doTest() throws Exception
{    if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {        return;    }    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo", -1);        if (testType.ttlsEnabled) {                        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);        } else {            try {                zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);                fail("Should have thrown KeeperException.UnimplementedException");            } catch (KeeperException.UnimplementedException e) {                        }        }    } finally {        if (zk != null) {            zk.close();        }    }}
0
private long[] generateRandomValues(int size)
{        final long[] values = new long[size];    if (size == 0) {        return values;    }    final long rangeMin = Long.MIN_VALUE / size;    final long rangeMax = Long.MAX_VALUE / size;    for (int i = 0; i < size; ++i) {        values[i] = ThreadLocalRandom.current().nextLong(rangeMin, rangeMax);    }    return values;}
0
public void testAvgMinMaxCounter()
{    final AvgMinMaxCounter metric = new AvgMinMaxCounter("test");    testAvgMinMaxCounter(metric, 0);    testAvgMinMaxCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testAvgMinMaxCounter(metric, RANDOM_SIZE);    }}
0
private void testAvgMinMaxCounter(AvgMinMaxCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedMin = Arrays.stream(values).min().orElse(0);    long expectedMax = Arrays.stream(values).max().orElse(0);    long expectedSum = Arrays.stream(values).sum();    long expectedCnt = values.length;    double expectedAvg = expectedSum / Math.max(1, expectedCnt);    assertEquals(expectedAvg, metric.getAvg(), 200);    assertEquals(expectedMin, metric.getMin());    assertEquals(expectedMax, metric.getMax());    assertEquals(expectedCnt, metric.getCount());    assertEquals(expectedSum, metric.getTotal());    final Map<String, Object> results = metric.values();    assertEquals(expectedMax, (long) results.get("max_test"));    assertEquals(expectedMin, (long) results.get("min_test"));    assertEquals(expectedCnt, (long) results.get("cnt_test"));    assertEquals(expectedAvg, (double) results.get("avg_test"), 200);    metric.reset();}
0
public void testSimpleCounter()
{    SimpleCounter metric = new SimpleCounter("test");    testSimpleCounter(metric, 0);    testSimpleCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testSimpleCounter(metric, RANDOM_SIZE);    }}
0
private void testSimpleCounter(SimpleCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedCount = Arrays.stream(values).sum();    assertEquals(expectedCount, metric.get());    final Map<String, Object> results = metric.values();    assertEquals(expectedCount, (long) results.get("test"));    metric.reset();}
0
public void setUp()
{    providerMock = mock(ServerStats.Provider.class);}
0
public void testPacketsMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 20;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementPacketsSent();        serverStats.incrementPacketsReceived();        serverStats.incrementPacketsReceived();    }        assertEquals(incrementCount, serverStats.getPacketsSent());    assertEquals(incrementCount * 2, serverStats.getPacketsReceived());        serverStats.resetRequestCounters();        assertAllPacketsZero(serverStats);}
0
public void testLatencyMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 2000);        assertThat("Max latency check", 2000L, lessThanOrEqualTo(serverStats.getMaxLatency()));    assertThat("Min latency check", 1000L, lessThanOrEqualTo(serverStats.getMinLatency()));    assertEquals(1500, serverStats.getAvgLatency(), 200);        serverStats.resetLatency();        assertAllLatencyZero(serverStats);}
0
public void testFsyncThresholdExceedMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 30;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementFsyncThresholdExceedCount();    }        assertEquals(incrementCount, serverStats.getFsyncThresholdExceedCount());        serverStats.resetFsyncThresholdExceedCount();        assertFsyncThresholdExceedCountZero(serverStats);}
0
public void testReset()
{        ServerStats serverStats = new ServerStats(providerMock);    assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.incrementPacketsSent();    serverStats.incrementPacketsReceived();    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.reset();        assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);}
0
private void assertAllPacketsZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getPacketsSent());    assertEquals(0L, serverStats.getPacketsReceived());}
0
private void assertAllLatencyZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getMaxLatency());    assertEquals(0L, serverStats.getMinLatency());    assertEquals(0, serverStats.getAvgLatency(), 0.00001);}
0
private void assertFsyncThresholdExceedCountZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getFsyncThresholdExceedCount());}
0
public void testAddSessionAfterSessionExpiry() throws Exception
{    RequestThrottler.setMaxRequests(0);    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);                sessionTrackerImpl.trackSession(sessionId, sessionTimeout);    try {        sessionTrackerImpl.checkSession(sessionId, sessionOwner);        fail("Should throw session expiry exception " + "as the session has expired and closed");    } catch (KeeperException.SessionExpiredException e) {        }    assertTrue("Session didn't expired", sessionImpl.isClosing());    assertFalse("Session didn't expired", sessionTrackerImpl.touchSession(sessionId, sessionTimeout));    assertEquals("Duplicate session expiry request has been generated", 1, firstProcessor.getCountOfCloseSessionReq());}
0
public void testCloseSessionRequestAfterSessionExpiry() throws Exception
{    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);            sessionTrackerImpl.removeSession(sessionId);    SessionImpl actualSession = sessionTrackerImpl.sessionsById.get(sessionId);    assertNull("Session:" + sessionId + " still exists after removal", actualSession);}
0
private ZooKeeperServer setupSessionTracker() throws IOException
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.setupRequestProcessors();    firstProcessor = new FirstProcessor(zks, null);    zks.firstProcessor = firstProcessor;        zks.createSessionTracker();    zks.startSessionTracker();    zks.startRequestThrottler();    return zks;}
0
public void processRequest(Request request)
{        if (request.type == OpCode.closeSession) {        countOfCloseSessionReq++;        latch.countDown();    }}
0
 int getCountOfCloseSessionReq()
{    return countOfCloseSessionReq;}
0
public void setUp() throws Exception
{    super.setUp();    server = serverFactory.getZooKeeperServer();    zk = createClient();}
0
public void tearDown() throws Exception
{        super.tearDown();    if (zk != null) {        zk.close();    }}
0
public void setupCustomizedEnv()
{    ZooKeeperServer.setDigestEnabled(true);    System.setProperty(ZooKeeperServer.SNAP_COUNT, "100");}
0
public void cleanUpCustomizedEnv()
{    ZooKeeperServer.setDigestEnabled(false);    System.clearProperty(ZooKeeperServer.SNAP_COUNT);}
0
public void testSnapshotDigest() throws Exception
{            server.takeSnapshot();    reloadSnapshotAndCheckDigest();        String pathPrefix = "/testSnapshotDigest";    for (int i = 0; i < 1000; i++) {        String path = pathPrefix + i;        zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        String firstNode = pathPrefix + 0;    zk.setData(firstNode, "new_setdata".getBytes(), -1);        zk.delete(firstNode, -1);        List<Op> subTxns = new ArrayList<Op>();    for (int i = 0; i < 3; i++) {        String path = pathPrefix + "-m" + i;        subTxns.add(Op.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    }    zk.multi(subTxns);    reloadSnapshotAndCheckDigest();        server = serverFactory.getZooKeeperServer();    server.takeSnapshot();    reloadSnapshotAndCheckDigest();}
0
public void testDifferentDigestVersion() throws Exception
{        int currentVersion = new DigestCalculator().getDigestVersion();        String path = "/testDifferentDigestVersion";    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();        int newVersion = currentVersion + 1;    DigestCalculator newVersionDigestCalculator = Mockito.spy(DigestCalculator.class);    Mockito.when(newVersionDigestCalculator.getDigestVersion()).thenReturn(newVersion);    assertEquals(newVersion, newVersionDigestCalculator.getDigestVersion());            FileTxnSnapLog txnSnapLog = new FileTxnSnapLog(tmpDir, tmpDir);    DataTree dataTree = Mockito.spy(new DataTree(newVersionDigestCalculator));    Mockito.when(dataTree.getTreeDigest()).thenReturn(0L);    txnSnapLog.restore(dataTree, new ConcurrentHashMap<>(), Mockito.mock(FileTxnSnapLog.PlayBackListener.class));        Mockito.verify(dataTree, Mockito.never()).reportDigestMismatch(Mockito.anyLong());}
0
public void testBackwardCompatible() throws Exception
{    testCompatibleHelper(false, true);    testCompatibleHelper(true, false);}
0
private void testCompatibleHelper(Boolean enabledBefore, Boolean enabledAfter) throws Exception
{    ZooKeeperServer.setDigestEnabled(enabledBefore);        reloadSnapshotAndCheckDigest();        String path = "/testCompatible" + "-" + enabledBefore + "-" + enabledAfter;    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();    ZooKeeperServer.setDigestEnabled(enabledAfter);    reloadSnapshotAndCheckDigest();    assertEquals(path, new String(zk.getData(path, false, null)));}
0
private void reloadSnapshotAndCheckDigest() throws Exception
{    stopServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTING);    ((SimpleCounter) ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT).reset();    startServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTED);        assertEquals(0L, ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.get());        assertNull(server.getZKDatabase().getDataTree().getDigestFromLoadedSnapshot());}
0
public void testJuteToString()
{    SetDataRequest req = new SetDataRequest(null, null, 0);    assertNotSame("ERROR", req.toString());}
0
private static List<Long> generateRandomHashes(int count)
{    ArrayList<Long> list = new ArrayList<>(count);    for (int i = 0; i < count; i++) {        list.add(rand.nextLong());    }    return list;}
0
private static void addListOfDigests(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.addDigest(b);    }}
0
private static void removeListOfDigests(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.removeDigest(b);    }}
0
public void testAdHash() throws Exception
{    List<Long> bucket1 = generateRandomHashes(50);    List<Long> bucket2 = generateRandomHashes(3);    List<Long> bucket3 = generateRandomHashes(30);    List<Long> bucket4 = generateRandomHashes(10);    List<Long> bucket5 = generateRandomHashes(5);        AdHash hash12 = new AdHash();    addListOfDigests(hash12, bucket1);    addListOfDigests(hash12, bucket2);    AdHash hash21 = new AdHash();    addListOfDigests(hash21, bucket2);    addListOfDigests(hash21, bucket1);    assertEquals(hash12, hash21);    AdHash hashall = new AdHash();    addListOfDigests(hashall, bucket1);    addListOfDigests(hashall, bucket2);    addListOfDigests(hashall, bucket3);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertFalse("digest of different set not different", hashall.equals(hash21));    removeListOfDigests(hashall, bucket4);    removeListOfDigests(hashall, bucket5);    addListOfDigests(hash21, bucket3);    assertEquals("hashall with 4 & 5 removed should match hash21 with 3 added", hashall, hash21);    removeListOfDigests(hashall, bucket3);    removeListOfDigests(hashall, bucket2);    removeListOfDigests(hashall, bucket1);    assertEquals("empty hashall's digest should be 0", hashall.toHexString(), "0");    AdHash hash45 = new AdHash();    addListOfDigests(hash45, bucket4);    addListOfDigests(hash45, bucket5);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertEquals("empty hashall + 4&5 should equal hash45", hashall, hash45);}
0
public void testAddWatchBit()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    assertTrue(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1 }, actualBits.toArray(new Integer[actualBits.size()]));        assertFalse(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());        assertTrue(ws.add(2));    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    assertTrue(ws.contains(1));    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1, 2 }, actualBits.toArray(new Integer[actualBits.size()]));}
0
public void testRemoveWatchBit()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    ws.add(1);    ws.add(2);    assertTrue(ws.contains(1));    assertTrue(ws.contains(2));    ws.remove(1);    assertFalse(ws.contains(1));    assertEquals(1, ws.size());    assertEquals(0, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.add(3);    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2, 3 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.remove(2);    ws.remove(3);    assertEquals(0, ws.size());    assertEquals(0, ws.cachedSize());}
0
public void testAddAndRemove()
{    BitMap<String> bitMap = new BitMap<String>();    String v1 = "v1";    Integer bit = bitMap.add(v1);    assertEquals(1, bitMap.size());    assertTrue(bit >= 0);    assertEquals(v1, bitMap.get(bit));    assertEquals(bit, bitMap.getBit(v1));        Integer newBit = bitMap.add(v1);    assertEquals(bit, newBit);    assertEquals(1, bitMap.size());    String v2 = "v2";    Integer v2Bit = bitMap.add(v2);    assertEquals(2, bitMap.size());    assertNotEquals(v2Bit, bit);        bitMap.remove(v1);    assertEquals(1, bitMap.size());    assertNull(bitMap.get(bit));    assertNull(bitMap.getBit(v1));        bitMap.remove(v2Bit);    assertEquals(0, bitMap.size());    assertNull(bitMap.get(v2Bit));    assertNull(bitMap.getBit(v2));}
0
public void testBitReuse()
{    BitMap<String> bitMap = new BitMap<String>();    int v1Bit = bitMap.add("v1");    int v2Bit = bitMap.add("v2");    int v3Bit = bitMap.add("v3");    bitMap.remove(v2Bit);    int v4Bit = bitMap.add("v4");    assertEquals(v4Bit, v2Bit);}
0
public void testCircularBuffer()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("C");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("A", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("B", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("C", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("1");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("2");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("3");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("4");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("2", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("3", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("4", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("a");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("b");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("c");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("d");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("e");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("f");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("g");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("e", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("f", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("g", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
0
public void testCircularBufferWithCapacity1()
{    final int capacity = 1;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("B", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
0
public void testCircularBufferReset()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(1, buffer.size());    Assert.assertEquals("A", buffer.peek());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(2, buffer.size());    Assert.assertEquals("A", buffer.peek());        buffer.reset();    Assert.assertNull(buffer.peek());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(0, buffer.size());}
0
public void testCircularBufferIllegalCapacity()
{    try {        CircularBuffer<String> buffer = new CircularBuffer<>(String.class, 0);        Assert.fail();    } catch (IllegalArgumentException e) {        Assert.assertEquals("CircularBuffer capacity should be greater than 0", e.getMessage());    }}
0
public void testGetHostAndPortWithIPv6() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443");    assertEquals(nsa[0], "2001:db8:85a3:8d3:1319:8a2e:370:7348");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:2888:3888");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
0
public void testGetHostAndPortWithIPv4() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1:443");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("127.0.0.1:2888:3888");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
0
public void testGetHostAndPortWithoutBracket() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348");}
0
public void testGetHostAndPortWithoutPortAfterColon() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:");}
0
public void testGetHostAndPortWithoutPort() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa.length, 1);    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa.length, 1);}
0
public void testJvmPauseMonitorExceedInfoThreshold() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));    while (pauseMonitor.getNumGcInfoThresholdExceeded() == 0) {        Thread.sleep(200);    }}
0
public void testJvmPauseMonitorExceedWarnThreshold() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));    while (pauseMonitor.getNumGcWarnThresholdExceeded() == 0) {        Thread.sleep(200);    }}
0
public void teardown()
{    pauseMonitor.serviceStop();}
0
public void setup()
{    System.setProperty(MessageTracker.MESSAGE_TRACKER_ENABLED, "true");}
0
public void tearDown() throws Exception
{    System.clearProperty(MessageTracker.MESSAGE_TRACKER_ENABLED);}
0
public void testTrackSend() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackSent(timestamp2);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);}
0
public void testTrackReceived() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackReceived(timestamp2);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);}
0
public void testMessageTrackerFull() throws InterruptedException
{    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        long timestampSent = 0;    long timestampReceived = 0;    for (int i = 0; i <= BUFFERED_MESSAGE_SIZE; i++) {        if (i == 1) {            timestampSent = System.currentTimeMillis();            messageTracker.trackSent(timestampSent);            Thread.sleep(2);            timestampReceived = System.currentTimeMillis();            messageTracker.trackReceived(timestampReceived);        } else {            messageTracker.trackSent(System.currentTimeMillis());            messageTracker.trackReceived(System.currentTimeMillis());        }        Thread.sleep(1);    }    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestampSent);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestampReceived);}
0
public void testDumpToLog()
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);    String sid = "127.0.0.1";        messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertNull(messageTracker.peekReceived());    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());}
0
public void run()
{    Thread.currentThread().setName(toClose.toString() + "-->" + toClose2.toString());    byte[] buf = new byte[1024];    try {        while (true) {            try {                int read = this.in.read(buf);                if (read > 0) {                    try {                        this.out.write(buf, 0, read);                    } catch (IOException e) {                                                break;                    }                } else if (read < 0) {                    throw new IOException("read " + read);                }            } catch (SocketTimeoutException e) {                            }        }        Thread.sleep(1);    } catch (InterruptedException e) {            } catch (SocketException e) {        if (!"Socket closed".equals(e.getMessage())) {                    }    } catch (IOException e) {            } finally {        shutdown();    }        isFinished = true;}
1
 boolean waitForShutdown(long timeoutMs) throws InterruptedException
{    synchronized (this) {        if (!isFinished) {            this.wait(timeoutMs);        }    }    return isFinished;}
0
public void shutdown()
{    try {        toClose.close();    } catch (IOException ex) {        }    try {        toClose2.close();    } catch (IOException ex) {        }}
0
public void run()
{    try {        while (!stopped) {            Socket sock = null;            try {                                sock = serverSocket.accept();                                Socket target = null;                int retry = 10;                while (sock.isConnected()) {                    try {                        target = new Socket("localhost", to);                        break;                    } catch (IOException e) {                        if (retry == 0) {                            throw e;                        }                                            }                    Thread.sleep(TimeUnit.SECONDS.toMillis(1));                    retry--;                }                                sock.setSoTimeout(30000);                target.setSoTimeout(30000);                workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));                workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));                for (PortForwardWorker worker : workers) {                    workerExecutor.submit(worker);                }            } catch (SocketTimeoutException e) {                            } catch (ConnectException e) {                                sock.close();            } catch (IOException e) {                if (!"Socket closed".equals(e.getMessage())) {                                        throw e;                }            }        }    } catch (IOException e) {            } catch (InterruptedException e) {            }}
1
public void shutdown() throws Exception
{    this.stopped = true;    this.serverSocket.close();    this.join();    this.workerExecutor.shutdownNow();    for (PortForwardWorker worker : workers) {        worker.shutdown();    }    for (PortForwardWorker worker : workers) {        if (!worker.waitForShutdown(5000)) {            throw new Exception("Failed to stop forwarding within 5 seconds");        }    }}
0
public void setUp()
{    System.setProperty("zookeeper.pathStats.enabled", "true");    System.setProperty("zookeeper.pathStats.slotCapacity", "60");    System.setProperty("zookeeper.pathStats.slotDuration", "1");    System.setProperty("zookeeper.pathStats.maxDepth", "6");    System.setProperty("zookeeper.pathStats.sampleRate", "1.0");}
0
public void tearDown()
{    System.clearProperty("zookeeper.pathStats.enabled");    System.clearProperty("zookeeper.pathStats.slotCapacity");    System.clearProperty("zookeeper.pathStats.slotDuration");    System.clearProperty("zookeeper.pathStats.maxDepth");    System.clearProperty("zookeeper.pathStats.sampleRate");}
0
public void testTrimPath()
{        String trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 1);    assertTrue(trimedPath.equalsIgnoreCase("/p1"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 4);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));        trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 6);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));}
0
public void testQueueMapReduce() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(create2);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 1000000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i);        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 1; i < 100000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i);        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1);    assertTrue(newSlot.get("/path1").compareTo(1111111) == 0);        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 12);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2").compareTo(1111100) == 0);        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 112);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2/path3").compareTo(1111000) == 0);        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1112);    assertTrue(newSlot.get("/path1/path2/path3/path4").compareTo(1110000) == 0);        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 11112);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5").compareTo(1100000) == 0);        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 111111);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5/path6").compareTo(1000001) == 0);        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1111111);}
0
public void testCollectEmptyStats() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    Thread.sleep(5000);    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.isEmpty());    pathStatsQueue.start();    Thread.sleep(15000);    newSlot = pathStatsQueue.collectStats(1);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(2);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(5);    assertTrue(newSlot.size() == 0);}
0
public void testCollectStats() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    pathStatsQueue.start();    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(500);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.collectStats(1);    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1").intValue(), 1111112);        newSlot = pathStatsQueue.collectStats(2);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = pathStatsQueue.collectStats(3);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = pathStatsQueue.collectStats(4);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = pathStatsQueue.collectStats(5);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = pathStatsQueue.collectStats(6);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);}
0
public void testAggregate() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(2, queue -> true);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> true);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(5, queue -> true);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = requestPathMetricsCollector.aggregatePaths(6, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);        newSlot = requestPathMetricsCollector.aggregatePaths(7, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);            newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> !queue.isWriteOperation());    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 1111);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1000);}
0
public void testTopPath() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    StringBuilder sb1 = new StringBuilder();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb1.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb1.toString().startsWith("/path1/path2/path3 : 1000"));    StringBuilder sb2 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> !queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb2.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb2.toString().startsWith("/path1/path2/path3 : 1110001"));    StringBuilder sb3 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb3.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb3.toString().startsWith("/path1/path2/path3/path4 : 1110001"));}
0
public void testMultiThreadPerf() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    Random rand = new Random(System.currentTimeMillis());    Long startTime = System.currentTimeMillis();    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();        for (int i = 0; i < 100000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(create2, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 40000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path" + rand.nextInt(10))));    }    executor.shutdown();        executor.awaitTermination(10, TimeUnit.MILLISECONDS);    assertTrue(executor.isTerminated());    Long endTime = System.currentTimeMillis();        assertTrue(TimeUnit.MILLISECONDS.toSeconds(endTime - startTime) < 3);}
0
public void testSerializeRequestRequestIsNull()
{    byte[] data = SerializeUtils.serializeRequest(null);    assertNull(data);}
0
public void testSerializeRequestRequestHeaderIsNull()
{    Request request = new Request(0, 0, 0, null, null, 0);    byte[] data = SerializeUtils.serializeRequest(request);    assertNull(data);}
0
public void testSerializeRequestWithoutTxn() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, null, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    verify(header).serialize(any(OutputArchive.class), eq("hdr"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
0
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
0
public void testSerializeRequestWithTxn() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, txn, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    InOrder inOrder = inOrder(header, txn);    inOrder.verify(header).serialize(any(OutputArchive.class), eq("hdr"));    inOrder.verify(txn).serialize(any(OutputArchive.class), eq("txn"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    boa.writeString("record", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
0
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
0
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
0
public void setUp()
{    log = LoggerFactory.getLogger("TODO: Mock Logging");}
0
public void testForWarningOnRelativePath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("a/relative/path");}
0
public void testForNoWarningOnIntendedRelativePath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("./an/intended/relative/path");}
0
public void testForFailForNonExistingPath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).failForNonExistingPath().build();    vff.create("/I/H0p3/this/path/d035/n0t/ex15t");}
0
public void testFileHasCorrectPath()
{    File file = new File("/some/path");    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).build();    assertEquals(file, vff.create(file.getPath()));}
0
public void setCountDownLatch(CountDownLatch latch)
{    this.latch = latch;}
0
public void setDelayMs(int delayMs)
{    this.delayMs = delayMs;}
0
public void processDeadWatchers(Set<Integer> deadWatchers)
{    if (delayMs > 0) {        try {            Thread.sleep(delayMs);        } catch (InterruptedException e) {        }    }    this.deadWatchers.clear();    this.deadWatchers.addAll(deadWatchers);    latch.countDown();}
0
public Set<Integer> getDeadWatchers()
{    return deadWatchers;}
0
public boolean wait(int maxWaitMs)
{    try {        return latch.await(maxWaitMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {    }    return false;}
0
public void testProcessDeadWatchersBasedOnThreshold()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int threshold = 3;    WatcherCleaner cleaner = new WatcherCleaner(listener, threshold, 60, 1, 10);    cleaner.start();    int i = 0;    while (i++ < threshold - 1) {        cleaner.addDeadWatcher(i);    }        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));        cleaner.addDeadWatcher(i);    assertTrue(listener.wait(1000));    assertEquals(threshold, listener.getDeadWatchers().size());}
0
public void testProcessDeadWatchersBasedOnTime()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 10, 1, 1, 10);    cleaner.start();    cleaner.addDeadWatcher(1);        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));    assertTrue(listener.wait(2000));    assertEquals(1, listener.getDeadWatchers().size());        listener.setCountDownLatch(new CountDownLatch(1));    assertFalse(listener.wait(2000));}
0
public void testMaxInProcessingDeadWatchers()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int delayMs = 1000;    listener.setDelayMs(delayMs);    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 60, 1, 1);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(2));    long startTime = Time.currentElapsedTime();    cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    long time = Time.currentElapsedTime() - startTime;    System.out.println("time used " + time);    assertTrue(Time.currentElapsedTime() - startTime >= delayMs);    assertTrue(listener.wait(5000));}
0
public void testDeadWatcherMetrics()
{    ServerMetrics.getMetrics().resetAll();    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 1, 1, 1);    listener.setDelayMs(20);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(3));            cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    cleaner.addDeadWatcher(3);    assertTrue(listener.wait(5000));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat("Adding dead watcher should be stalled twice", (Long) values.get("add_dead_watcher_stall_time"), greaterThan(0L));    assertEquals("Total dead watchers added to the queue should be 3", 3L, values.get("dead_watchers_queued"));    assertEquals("Total dead watchers cleared should be 3", 3L, values.get("dead_watchers_cleared"));    assertEquals(3L, values.get("cnt_dead_watchers_cleaner_latency"));        assertEquals(20D, (Double) values.get("avg_dead_watchers_cleaner_latency"), 5);    assertEquals(20D, ((Long) values.get("min_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("max_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p50_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p95_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p99_dead_watchers_cleaner_latency")).doubleValue(), 5);}
0
public void testWatcherSet()
{    Set<Watcher> wset = new HashSet<Watcher>();    WatcherOrBitSet hashSet = new WatcherOrBitSet(wset);    assertEquals(0, hashSet.size());    DumbWatcher w1 = new DumbWatcher();    assertFalse(hashSet.contains(w1));    wset.add(w1);    assertTrue(hashSet.contains(w1));    assertEquals(1, hashSet.size());    assertFalse(hashSet.contains(1));}
0
public void testBitSet()
{    BitHashSet bset = new BitHashSet(0);    WatcherOrBitSet bitSet = new WatcherOrBitSet(bset);    assertEquals(0, bitSet.size());    Integer bit = 1;    assertFalse(bitSet.contains(1));    assertFalse(bitSet.contains(bit));    bset.add(bit);    assertTrue(bitSet.contains(1));    assertTrue(bitSet.contains(bit));    assertEquals(1, bitSet.size());}
0
public void setUp()
{    m = new HashMap<String, Set<Long>>();    Set<Long> s = new HashSet<Long>();    s.add(101L);    s.add(102L);    m.put("path1", s);    s = new HashSet<Long>();    s.add(201L);    m.put("path2", s);    r = new WatchesPathReport(m);}
0
public void testHasSessions()
{    assertTrue(r.hasSessions("path1"));    assertTrue(r.hasSessions("path2"));    assertFalse(r.hasSessions("path3"));}
0
public void testGetSessions()
{    Set<Long> s = r.getSessions("path1");    assertEquals(2, s.size());    assertTrue(s.contains(101L));    assertTrue(s.contains(102L));    s = r.getSessions("path2");    assertEquals(1, s.size());    assertTrue(s.contains(201L));    assertNull(r.getSessions("path3"));}
0
public void testToMap()
{    assertEquals(m, r.toMap());}
0
public void setUp()
{    m = new HashMap<Long, Set<String>>();    Set<String> s = new HashSet<String>();    s.add("path1a");    s.add("path1b");    m.put(1L, s);    s = new HashSet<String>();    s.add("path2a");    m.put(2L, s);    r = new WatchesReport(m);}
0
public void testHasPaths()
{    assertTrue(r.hasPaths(1L));    assertTrue(r.hasPaths(2L));    assertFalse(r.hasPaths(3L));}
0
public void testGetPaths()
{    Set<String> s = r.getPaths(1L);    assertEquals(2, s.size());    assertTrue(s.contains("path1a"));    assertTrue(s.contains("path1b"));    s = r.getPaths(2L);    assertEquals(1, s.size());    assertTrue(s.contains("path2a"));    assertNull(r.getPaths(3L));}
0
public void testToMap()
{    assertEquals(m, r.toMap());}
0
public void setUp()
{    s = new WatchesSummary(1, 2, 3);}
0
public void testGetters()
{    assertEquals(1, s.getNumConnections());    assertEquals(2, s.getNumPaths());    assertEquals(3, s.getTotalWatches());}
0
public void testToMap()
{    Map<String, Object> m = s.toMap();    assertEquals(3, m.size());    assertEquals(Integer.valueOf(1), m.get(WatchesSummary.KEY_NUM_CONNECTIONS));    assertEquals(Integer.valueOf(2), m.get(WatchesSummary.KEY_NUM_PATHS));    assertEquals(Integer.valueOf(3), m.get(WatchesSummary.KEY_NUM_TOTAL_WATCHES));}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { WatchManager.class.getName() }, { WatchManagerOptimized.class.getName() } });}
0
public void setUp()
{    ServerMetrics.getMetrics().resetAll();    watchers = new ConcurrentHashMap<Integer, DumbWatcher>();    r = new Random(System.nanoTime());}
0
public IWatchManager getWatchManager() throws IOException
{    System.setProperty(WatchManagerFactory.ZOOKEEPER_WATCH_MANAGER_NAME, className);    return WatchManagerFactory.createWatchManager();}
0
public DumbWatcher createOrGetWatcher(int watcherId)
{    if (!watchers.containsKey(watcherId)) {        DumbWatcher watcher = new DumbWatcher(watcherId);        watchers.putIfAbsent(watcherId, watcher);    }    return watchers.get(watcherId);}
0
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.addWatch(path, watcher)) {            watchesAdded.addAndGet(1);        }    }}
0
public void shutdown()
{    stopped = true;}
0
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        WatcherOrBitSet s = manager.triggerWatch(path, EventType.NodeDeleted);        if (s != null) {            triggeredCount.addAndGet(s.size());        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
0
public void shutdown()
{    stopped = true;}
0
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.removeWatcher(path, watcher)) {            watchesRemoved.addAndGet(1);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
0
public void shutdown()
{    stopped = true;}
0
public void run()
{    while (!stopped) {        DumbWatcher watcher = createOrGetWatcher(r.nextInt(watchers));        watcher.setStale();        manager.removeWatcher(watcher);        synchronized (removedWatchers) {            removedWatchers.add(watcher);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
0
public void shutdown()
{    stopped = true;}
0
public void testAddAndTriggerWatcher() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 10000;            AtomicInteger watchTriggered = new AtomicInteger();    List<WatcherTriggerWorker> triggerWorkers = new ArrayList<WatcherTriggerWorker>();    for (int i = 0; i < 5; i++) {        WatcherTriggerWorker worker = new WatcherTriggerWorker(manager, paths, watchTriggered);        triggerWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        for (WatcherTriggerWorker worker : triggerWorkers) {        worker.shutdown();    }        assertTrue(watchesAdded.get() > 0);    assertEquals(watchesAdded.get(), watchTriggered.get());}
0
public void testRemoveWatcherOnPath() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 10;    int watchers = 10000;            AtomicInteger watchesRemoved = new AtomicInteger();    List<RemoveWatcherWorker> removeWorkers = new ArrayList<RemoveWatcherWorker>();    for (int i = 0; i < 5; i++) {        RemoveWatcherWorker worker = new RemoveWatcherWorker(manager, paths, watchers, watchesRemoved);        removeWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (RemoveWatcherWorker worker : removeWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        assertTrue(watchesAdded.get() > 0);    assertTrue(watchesRemoved.get() > 0);    assertTrue(manager.size() > 0);    assertEquals(watchesAdded.get(), watchesRemoved.get() + manager.size());}
0
public void testDeadWatchers() throws IOException
{    System.setProperty("zookeeper.watcherCleanThreshold", "10");    System.setProperty("zookeeper.watcherCleanIntervalInSeconds", "1");    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 100000;            Set<Watcher> deadWatchers = new HashSet<Watcher>();    List<CreateDeadWatchersWorker> deadWorkers = new ArrayList<CreateDeadWatchersWorker>();    for (int i = 0; i < 5; i++) {        CreateDeadWatchersWorker worker = new CreateDeadWatchersWorker(manager, watchers, deadWatchers);        deadWorkers.add(worker);        worker.start();    }        AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 50000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (CreateDeadWatchersWorker worker : deadWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(2000);    } catch (InterruptedException e) {    }        WatchesReport existingWatchers = manager.getWatches();    for (Watcher w : deadWatchers) {        assertFalse(existingWatchers.hasPaths(((ServerCnxn) w).getSessionId()));    }}
0
private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(min, values.get("min_" + metricName));    assertEquals(max, values.get("max_" + metricName));    assertEquals(avg, (Double) values.get("avg_" + metricName), 0.000001);    assertEquals(cnt, values.get("cnt_" + metricName));    assertEquals(sum, values.get("sum_" + metricName));}
0
public void testWatcherMetrics() throws IOException
{    IWatchManager manager = getWatchManager();    ServerMetrics.getMetrics().resetAll();    DumbWatcher watcher1 = new DumbWatcher(1);    DumbWatcher watcher2 = new DumbWatcher(2);    final String path1 = "/path1";    final String path2 = "/path2";    final String path3 = "/path3";        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path3, EventType.NodeCreated);        checkMetrics("node_created_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.triggerWatch(path1, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 2L, 2L, 2D, 1L, 2L);        manager.triggerWatch(path2, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);        manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 2L, 2L, 2D, 1L, 2L);    manager.triggerWatch(path2, EventType.NodeDeleted);    checkMetrics("node_deleted_watch_count", 1L, 1L, 1D, 1L, 1L);        checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);}
0
public void processRequest(Request request) throws RequestProcessorException
{        throw new RequestProcessorException("test", new Exception());}
0
public void shutdown()
{}
0
public void run()
{    super.run();    processed.countDown();}
0
public void testUnrecoverableErrorCountFromRequestProcessor() throws Exception
{    ServerMetrics.getMetrics().resetAll();    processed = new CountDownLatch(1);    PrepRequestProcessor processor = new MyPrepRequestProcessor();    processor.start();    processor.processRequest(new Request(null, 1L, 1, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null));    processed.await();    processor.shutdown();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
0
public void testUnrecoverableErrorCount()
{    ServerMetrics.getMetrics().resetAll();    ZooKeeperServer zks = new ZooKeeperServer();    ZooKeeperCriticalThread thread = new ZooKeeperCriticalThread("test", zks.getZooKeeperServerListener());    thread.handleException("test", new Exception());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
0
public void setup()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");}
0
public void teardown() throws Exception
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
0
public void testTxnLogElapsedSyncTime() throws IOException
{    File tmpDir = ClientBase.createEmptyTestDir();    FileTxnSnapLog fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZooKeeperServer zks = new ZooKeeperServer();    zks.setTxnLogFactory(fileTxnSnapLog);    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    long elapsedTime = serverBean.getTxnLogElapsedSyncTime();    assertEquals(-1, elapsedTime);    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        zks.getTxnLogFactory().append(req);        zks.getTxnLogFactory().commit();        elapsedTime = serverBean.getTxnLogElapsedSyncTime();        assertNotEquals(-1, elapsedTime);        assertEquals(elapsedTime, serverBean.getTxnLogElapsedSyncTime());    } finally {        fileTxnSnapLog.close();    }}
0
public void testGetSecureClientPort() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured GetSecureClientPort     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured GetSecureClientPort should     * return configured port     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientPort();    assertEquals(Integer.toString(secureClientPort), result);        cnxnFactory.shutdown();}
0
public void testGetSecureClientAddress() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured getSecureClientAddress     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured getSecureClientAddress     * should return configured SecureClientAddress     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientAddress();    String ipv4 = "0.0.0.0:" + secureClientPort;    String ipv6 = "0:0:0:0:0:0:0:0:" + secureClientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();}
0
public void setUp()
{    c = new ZooKeeperServerConf(1, "a", "b", 2, 3, 4, 5, 6L, 7);}
0
public void testGetters()
{    assertEquals(1, c.getClientPort());    assertEquals("a", c.getDataDir());    assertEquals("b", c.getDataLogDir());    assertEquals(2, c.getTickTime());    assertEquals(3, c.getMaxClientCnxnsPerHost());    assertEquals(4, c.getMinSessionTimeout());    assertEquals(5, c.getMaxSessionTimeout());    assertEquals(6L, c.getServerId());    assertEquals(7, c.getClientPortListenBacklog());}
0
public void testToMap()
{    Map<String, Object> m = c.toMap();    assertEquals(9, m.size());    assertEquals(Integer.valueOf(1), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT));    assertEquals("a", m.get(ZooKeeperServerConf.KEY_DATA_DIR));    assertEquals("b", m.get(ZooKeeperServerConf.KEY_DATA_LOG_DIR));    assertEquals(Integer.valueOf(2), m.get(ZooKeeperServerConf.KEY_TICK_TIME));    assertEquals(Integer.valueOf(3), m.get(ZooKeeperServerConf.KEY_MAX_CLIENT_CNXNS));    assertEquals(Integer.valueOf(4), m.get(ZooKeeperServerConf.KEY_MIN_SESSION_TIMEOUT));    assertEquals(Integer.valueOf(5), m.get(ZooKeeperServerConf.KEY_MAX_SESSION_TIMEOUT));    assertEquals(Long.valueOf(6L), m.get(ZooKeeperServerConf.KEY_SERVER_ID));    assertEquals(Integer.valueOf(7), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT_LISTEN_BACKLOG));}
0
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    }}
1
public void shutdown() throws IOException
{    main.shutdown();}
0
 void deleteDirs() throws IOException
{    delete(tmpDir);}
0
 void delete(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            delete(c);        }    }    if (!f.delete()) {                if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
0
 ServerCnxnFactory getCnxnFactory()
{    return main.getCnxnFactory();}
0
public void shutdown()
{    super.shutdown();}
0
public void testNonRecoverableError() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/foo1", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo1", null, null)), "foobar");        ZooKeeperServer zooKeeperServer = main.getCnxnFactory().getZooKeeperServer();    FileTxnSnapLog snapLog = zooKeeperServer.getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    zooKeeperServer.setZKDatabase(newDB);    try {                zk.create("/foo2", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected as error is injected in transaction log commit funtionality");    } catch (Exception e) {        }    zk.close();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    fileTxnSnapLogWithError.close();    main.shutdown();    main.deleteDirs();}
0
public void commit() throws IOException
{    throw new IOException("Input/output error");}
0
public void testReadOnlySnapshotDir() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File snapDir = new File(main.dataDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    snapDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    snapDir.setWritable(true);    main.deleteDirs();}
0
public void testReadOnlyTxnLogDir() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File logDir = new File(main.logDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    logDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    logDir.setWritable(true);    main.deleteDirs();}
0
public void testStandalone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
0
public void testWithMinSessionTimeoutGreaterThanMaxSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;        final int minSessionTimeout = 20 * tickTime + 1000;        final int maxSessionTimeout = tickTime * 2 - 100;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as " + "minsessiontimeout > maxsessiontimeout");    } catch (ConfigException iae) {        }}
0
public void testInvalidMetricsProvider() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=BadClass\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is not " + "well configured");    } catch (ConfigException iae) {        }}
0
public void testFaultyMetricsProviderOnStart() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStart.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider cannot boot");    } catch (IOException iae) {        }}
0
public void testFaultyMetricsProviderOnConfigure() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInConfigure.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is cannot boot");    } catch (IOException iae) {        }}
0
public void testFaultyMetricsProviderOnStop() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithErrorInStop.stopCalled.set(false);    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStop.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue(MetricsProviderWithErrorInStop.stopCalled.get());}
0
public void testMetricsProviderConfiguration() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithConfiguration.httpPort.set(0);    final String configs = "metricsProvider.className=" + MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertEquals(1234, MetricsProviderWithConfiguration.httpPort.get());}
0
public void testMetricsProviderLifecycle() throws Exception
{    ClientBase.setupTestEnv();    MetricsProviderCapturingLifecycle.reset();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderCapturingLifecycle.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
0
public void testWithOnlyMinSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    int maxSessionTimeout = 20 * tickTime;    final String configs = "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
0
public void testMinMaxSessionTimeOut() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    final int maxSessionTimeout = 20 * tickTime + 1000;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
0
private void verifySessionTimeOut(int sessionTimeout, int expectedSessionTimeout, String HOSTPORT) throws IOException, KeeperException, InterruptedException
{    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper(HOSTPORT, sessionTimeout, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(sessionTimeout, TimeUnit.MILLISECONDS));    assertEquals("Not able to configure the sessionTimeout values", expectedSessionTimeout, zk.getSessionTimeout());    zk.close();}
0
public void testJMXRegistrationWithNIO() throws Exception
{    ClientBase.setupTestEnv();    File tmpDir_1 = ClientBase.createTmpDir();    ServerCnxnFactory server_1 = startServer(tmpDir_1);    File tmpDir_2 = ClientBase.createTmpDir();    ServerCnxnFactory server_2 = startServer(tmpDir_2);    server_1.shutdown();    server_2.shutdown();    deleteFile(tmpDir_1);    deleteFile(tmpDir_2);}
0
public void testJMXRegistrationWithNetty() throws Exception
{    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    try {        ClientBase.setupTestEnv();        File tmpDir_1 = ClientBase.createTmpDir();        ServerCnxnFactory server_1 = startServer(tmpDir_1);        File tmpDir_2 = ClientBase.createTmpDir();        ServerCnxnFactory server_2 = startServer(tmpDir_2);        server_1.shutdown();        server_2.shutdown();        deleteFile(tmpDir_1);        deleteFile(tmpDir_2);    } finally {                if (originalServerCnxnFactory == null || originalServerCnxnFactory.isEmpty()) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);        } else {            System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);        }    }}
0
private void deleteFile(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            deleteFile(c);        }    }    if (!f.delete()) {        if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
0
private ServerCnxnFactory startServer(File tmpDir) throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertNotNull("JMX initialization failed!", zks.jmxServerBean);    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    return f;}
0
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
0
public void teardown() throws Exception
{            startupDelayLatch.countDown();    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }    if (zks.getZKDatabase() != null) {        zks.getZKDatabase().close();    }    ClientBase.recursiveDelete(tmpDir);}
0
public void testClientConnectionRequestDuringStartupWithNIOServerCnxn() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    startSimpleZKServer(startupDelayLatch);    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;    assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);    assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));        startupDelayLatch.countDown();    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zkClient.close();}
1
public void testClientConnectionRequestDuringStartupWithNettyServerCnxn() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    try {        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());        startSimpleZKServer(startupDelayLatch);        SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;        assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);        assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));                startupDelayLatch.countDown();        assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        zkClient.close();    } finally {                if (originalServerCnxnFactory == null) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);            return;        }        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);    }}
1
public void testFourLetterWords() throws Exception
{    startSimpleZKServer(startupDelayLatch);    verify("conf", ZK_NOT_SERVING);    verify("crst", ZK_NOT_SERVING);    verify("cons", ZK_NOT_SERVING);    verify("dirs", ZK_NOT_SERVING);    verify("dump", ZK_NOT_SERVING);    verify("mntr", ZK_NOT_SERVING);    verify("stat", ZK_NOT_SERVING);    verify("srst", ZK_NOT_SERVING);    verify("wchp", ZK_NOT_SERVING);    verify("wchc", ZK_NOT_SERVING);    verify("wchs", ZK_NOT_SERVING);    verify("isro", "null");}
0
private void verify(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue("Unexpected response", resp.contains(expected));}
1
private String sendRequest(String cmd) throws IOException, SSLContextException
{    return send4LetterWord(HOST, PORT, cmd);}
0
private void startSimpleZKServer(CountDownLatch startupDelayLatch) throws IOException
{    zks = new SimpleZooKeeperServer(tmpDir, tmpDir, 3000, startupDelayLatch);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    Thread startupThread = new Thread() {        public void run() {            try {                servcnxnf.startup(zks);            } catch (IOException e) {                                                    } catch (InterruptedException e) {                                                    }        }    };        startupThread.start();}
1
public void run()
{    try {        servcnxnf.startup(zks);    } catch (IOException e) {                    } catch (InterruptedException e) {                    }}
1
public synchronized void startup()
{    try {        startupInvokedLatch.countDown();                                                        startupDelayLatch.await();    } catch (InterruptedException e) {        fail("Unexpected InterruptedException while startinng up!");    }    super.startup();}
0
 long createSession(ServerCnxn cnxn, byte[] passwd, int timeout)
{    createSessionInvokedLatch.countDown();    return super.createSession(cnxn, passwd, timeout);}
0
 boolean waitForStartupInvocation(long timeout) throws InterruptedException
{    return startupInvokedLatch.await(timeout, TimeUnit.SECONDS);}
0
 boolean waitForSessionCreation(long timeout) throws InterruptedException
{    return createSessionInvokedLatch.await(timeout, TimeUnit.SECONDS);}
0
public void testSortDataDirAscending()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", true);    assertEquals(orig[2], filelist.get(0));    assertEquals(orig[3], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[1], filelist.get(3));    assertEquals(orig[4], filelist.get(4));}
0
public void testSortDataDirDescending()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", false);    assertEquals(orig[4], filelist.get(0));    assertEquals(orig[1], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[3], filelist.get(3));    assertEquals(orig[2], filelist.get(4));}
0
public void testGetLogFiles()
{    File[] files = new File[5];    files[0] = new File("log.10027c6de");    files[1] = new File("log.10027c6df");    files[2] = new File("snapshot.10027c6dd");    files[3] = new File("log.10027c6dc");    files[4] = new File("log.20027c6dc");    File[] orig = files.clone();    File[] filelist = FileTxnLog.getLogFiles(files, Long.parseLong("10027c6de", 16));    assertEquals(3, filelist.length);    assertEquals(orig[0], filelist[0]);    assertEquals(orig[1], filelist[1]);    assertEquals(orig[4], filelist[2]);}
0
public void testForceSyncDefaultEnabled()
{    File file = new File("foo.10027c6de");    FileTxnLog log = new FileTxnLog(file);    assertTrue(log.isForceSync());}
0
public void testForceSyncDefaultDisabled()
{    try {        File file = new File("foo.10027c6de");        System.setProperty("zookeeper.forceSync", "no");        FileTxnLog log = new FileTxnLog(file);        assertFalse(log.isForceSync());    } finally {                System.setProperty("zookeeper.forceSync", "yes");    }}
0
public void testInvalidSnapshot()
{    File f = null;    File tmpFileDir = null;    try {        tmpFileDir = ClientBase.createTmpDir();        f = new File(tmpFileDir, "snapshot.0");        if (!f.exists()) {            f.createNewFile();        }        assertFalse("Snapshot file size is greater than 9 bytes", SnapStream.isValidSnapshot(f));        assertTrue("Can't delete file", f.delete());    } catch (IOException e) {    } finally {        if (null != tmpFileDir) {            ClientBase.recursiveDelete(tmpFileDir);        }    }}
0
public void run()
{    throw new Error();}
0
protected void handleException(String thName, Throwable e)
{    runningLatch.countDown();}
0
public void notifyStopping(String threadName, int erroCode)
{}
0
public void run()
{    throw new Error();}
0
protected void handleException(String thName, Throwable e)
{    runningLatch.countDown();}
0
public void testUncaughtException() throws Exception
{    MyThread t1 = new MyThread("Test-Thread");    t1.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));    runningLatch = new CountDownLatch(1);    MyCriticalThread t2 = new MyCriticalThread("Test-Critical-Thread");    t2.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));}
0
private ZooKeeper getClient(int idx)
{    return zkClients[idx - 1];}
0
public void setUp() throws Exception
{    System.setProperty("zookeeper.admin.enableServer", "false");            SyncRequestProcessor.setSnapCount(7);    qu = new QuorumUtil(1);    startAll();    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i] = new CountdownWatcher();        PeerStruct peer = qu.getPeer(i + 1);        zkClients[i] = new ZooKeeper("127.0.0.1:" + peer.clientPort, ClientTest.CONNECTION_TIMEOUT, zkClientWatchers[i]);    }    waitForClientsConnected();}
0
private void waitForClientsConnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i].waitForConnected(ClientTest.CONNECTION_TIMEOUT);        zkClientWatchers[i].reset();    }}
0
private void checkClientsConnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientConnected(i + 1);    }}
0
private void checkClientConnected(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-connected", false));    } catch (ConnectionLossException e) {                                                                        PeerStruct peer = qu.getPeer(idx);        assertTrue("Waiting for server down", ClientBase.waitForServerUp("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        assertNull(zk.exists("/foofoofoo-connected", false));    }}
0
private void checkClientsDisconnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientDisconnected(i + 1);    }}
0
private void checkClientDisconnected(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-disconnected", false));        fail("expected client to be disconnected");    } catch (KeeperException e) {        }}
0
private void startAll() throws Exception
{    qu.startAll();    checkLeader();        checkClientsConnected();}
0
private void start(int idx) throws Exception
{    qu.start(idx);    for (String hp : qu.getConnString().split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientTest.CONNECTION_TIMEOUT));    }    checkLeader();        checkClientsConnected();}
0
private void checkLeader()
{    idxLeader = 1;    while (qu.getPeer(idxLeader).peer.leader == null) {        idxLeader++;    }    idxFollower = (idxLeader == 1 ? 2 : 1);    zksLeader = qu.getPeer(idxLeader).peer.getActiveServer();}
0
private void shutdownAll() throws Exception
{    qu.shutdownAll();        checkClientsDisconnected();}
0
private void shutdown(int idx) throws Exception
{    qu.shutdown(idx);        PeerStruct peer = qu.getPeer(idx);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        if (idx == idxLeader) {        checkClientDisconnected(idx);        try {            checkClientsDisconnected();        } catch (AssertionError e) {                        }    } else {        checkClientDisconnected(idx);    }}
0
private void adjustEpochNearEnd()
{    zksLeader.setZxid((zksLeader.getZxid() & 0xffffffff00000000L) | 0xfffffffcL);}
0
public void tearDown() throws Exception
{        for (int i = 0; i < zkClients.length; i++) {        zkClients[i].close();    }    qu.shutdownAll();}
1
private int createNodes(ZooKeeper zk, int start, int count) throws Exception
{        int j = 0;    try {        for (int i = start; i < start + count; i++) {            zk.create("/foo" + i, new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.EPHEMERAL);            j++;        }    } catch (ConnectionLossException e) {                waitForClientsConnected();    }    return j;}
1
private void checkNodes(ZooKeeper zk, int start, int count) throws Exception
{        for (int i = start; i < start + count; i++) {        assertNotNull(zk.exists("/foo" + i, false));            }    assertNull(zk.exists("/foo" + (start + count), false));}
1
public void testSimpleRolloverFollower() throws Exception
{    adjustEpochNearEnd();    ZooKeeper zk = getClient((idxLeader == 1 ? 2 : 1));    int countCreated = createNodes(zk, 0, 10);    checkNodes(zk, 0, countCreated);}
0
public void testRolloverThenRestart() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
0
public void testRolloverThenFollowerRestart() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
0
public void testRolloverThenLeaderRestart() throws Exception
{    ZooKeeper zk = getClient(idxLeader);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 50);}
0
public void testMultipleRollover() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 70);}
0
public void setUp()
{    serverConfig = new ServerConfig();}
0
public void testFewArguments()
{    String[] args = { "2181" };    serverConfig.parse(args);}
0
public void testValidArguments()
{    String[] args = { "2181", "/data/dir", "60000", "10000" };    serverConfig.parse(args);    assertEquals(2181, serverConfig.getClientPortAddress().getPort());    assertTrue(checkEquality("/data/dir", serverConfig.getDataDir()));    assertEquals(60000, serverConfig.getTickTime());    assertEquals(10000, serverConfig.getMaxClientCnxns());}
0
public void testTooManyArguments()
{    String[] args = { "2181", "/data/dir", "60000", "10000", "9999" };    serverConfig.parse(args);}
0
public void testJvmPauseMonitorConfigured()
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.isJvmPauseMonitorToRun()).thenReturn(true);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    serverConfig.readFrom(qpConfig);    assertEquals(sleepTime, Long.valueOf(serverConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(serverConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(serverConfig.getJvmPauseInfoThresholdMs()));    assertTrue(serverConfig.isJvmPauseMonitorToRun());}
0
 boolean checkEquality(String a, String b)
{    assertNotNull(a);    assertNotNull(b);    return a.equals(b);}
0
 boolean checkEquality(String a, File b)
{    assertNotNull(a);    assertNotNull(b);    return new File(a).equals(b);}
0
public void testAclCount() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    final ArrayList<ACL> CREATOR_ALL_AND_WORLD_READABLE = new ArrayList<ACL>() {        {            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));        }    };    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        String path = "/path";        try {            assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());        } catch (Exception e) {                        throw e;        }        zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL("/path", new Stat());        assertEquals(2, acls.size());    } catch (Exception e) {                assertTrue(false);    }    f.shutdown();    zks.shutdown();}
1
public void testRootAcl() throws Exception
{    ZooKeeper zk = createClient();    try {                zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getData("/", false, null);        zk.close();                zk = createClient();        try {            zk.getData("/", false, null);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.addAuthInfo("digest", "world:anyone".getBytes());        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.getData("/", false, null);        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.delete("/apps", -1);                zk.setACL("/", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/", false, null);        zk.create("/apps", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.delete("/apps", -1);        zk.addAuthInfo("digest", "world:anyone".getBytes());        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.delete("/apps", -1);    } finally {        zk.close();    }}
0
public void testIPAuthenticationIsValidCIDR() throws Exception
{    IPAuthenticationProvider prov = new IPAuthenticationProvider();    assertTrue("testing no netmask", prov.isValid("127.0.0.1"));    assertTrue("testing single ip netmask", prov.isValid("127.0.0.1/32"));    assertTrue("testing lowest netmask possible", prov.isValid("127.0.0.1/0"));    assertFalse("testing netmask too high", prov.isValid("127.0.0.1/33"));    assertFalse("testing netmask too low", prov.isValid("10.0.0.1/-1"));}
0
public void testNettyIpAuthDefault() throws Exception
{    String HOSTPORT = "127.0.0.1:" + PortAssignment.unique();    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    ClientBase.setupTestEnv();    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ClientBase.createZKClient(HOSTPORT);        for (ServerCnxn cnxn : f.getConnections()) {            boolean foundID = false;            for (Id id : cnxn.getAuthInfo()) {                if (id.getScheme().equals("ip")) {                    foundID = true;                    break;                }            }            assertTrue(foundID);        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    }}
1
public void testDisconnectedAddAuth() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        try {            zk.addAuthInfo("digest", "pat:test".getBytes());            zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        } finally {            zk.close();        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
1
public void testAcls() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    String path;    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);                for (int i = 0; i < 100; i++) {            path = "/" + i;            zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        int size = zks.getZKDatabase().getAclSize();        assertTrue("size of the acl map ", (2 == zks.getZKDatabase().getAclSize()));        for (int j = 100; j < 200; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            List<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("size of the acl map ", (102 == zks.getZKDatabase().getAclSize()));    } finally {                f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        assertTrue("acl map ", (102 == zks.getZKDatabase().getAclSize()));        for (int j = 200; j < 205; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            ArrayList<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("acl map ", (107 == zks.getZKDatabase().getAclSize()));        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
1
public void process(WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected) {        if (startSignal != null && startSignal.getCount() > 0) {                        startSignal.countDown();        } else {                    }    }}
1
public void testNullACL() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", null, 0);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
0
public void testNullValueACL() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        List<ACL> acls = new ArrayList<ACL>();        acls.add(null);                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", acls, -1);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
0
public void setUp(boolean withObservers) throws Exception
{    qb.setUp(withObservers);}
0
protected void restart() throws Exception
{        qb.tearDown();        JMXEnv.setUp();    qb.startServers();}
1
public void tearDown() throws Exception
{        qb.tearDown();}
1
public void run()
{    try {        CountdownWatcher watcher = new CountdownWatcher();        zk = new TestableZooKeeper(qb.hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        while (bang) {                        incOutstanding();            zk.create("/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, this, null);        }    } catch (InterruptedException e) {        if (bang) {                                    return;        }    } catch (Exception e) {                return;    } finally {        if (zk != null) {            try {                if (!zk.close(CONNECTION_TIMEOUT)) {                    failed = true;                                    }            } catch (InterruptedException e) {                            }        }    }}
1
private synchronized void incOutstanding() throws InterruptedException
{    outstanding++;    while (outstanding > MAX_OUTSTANDING) {        wait();    }}
0
private synchronized void decOutstanding()
{    outstanding--;    assertTrue("outstanding >= 0", outstanding >= 0);    notifyAll();}
0
public void process(WatchedEvent event)
{}
0
public void processResult(int rc, String path, Object ctx, String name)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;                    }        decOutstanding();        return;    }    try {        decOutstanding();        zk.delete(name, -1, this, null);    } catch (Exception e) {        if (bang) {            failed = true;                    }    }}
1
public void processResult(int rc, String path, Object ctx)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;                    }    }}
1
public void testHammer() throws Exception
{    setUp(false);    bang = true;        HammerThread[] hammers = new HammerThread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }            Thread.sleep(5000);    bang = false;        for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);        assertFalse(hammers[i].failed);    }            qb.verifyRootOfAllServersMatch(qb.hostPort);    restart();            qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
1
public void testObserversHammer() throws Exception
{    setUp(true);    bang = true;    Thread[] hammers = new Thread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }        Thread.sleep(5000);    bang = false;    for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);    }        qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
0
public void processResult(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void setRC(Code rc)
{    this.rc = rc;}
0
public void setPath(String path)
{    this.path = path;}
0
public void processResult(Code rc, String path, Object ctx)
{    this.rc = rc;    this.path = path;    this.expected = (String) ctx;    latch.countDown();}
0
public String toString()
{    return rc + ":" + path + ":";}
0
protected void verify()
{    try {        latch.await(defaultTimeoutMillis, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }        assertSame(0L, latch.getCount());    String actual = toString();    assertEquals(expected, actual);}
0
public void setPath(String path)
{    super.setPath(path);    this.name = path;}
0
public String nodeName()
{    return path.substring(path.lastIndexOf('/') + 1);}
0
public void processResult(int rc, String path, Object ctx, String name)
{    this.name = name;    super.processResult(Code.get(rc), path, ctx);}
0
public AsyncCB create()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
0
public AsyncCB createEphemeral()
{    zk.create(path, data, acl, CreateMode.EPHEMERAL, this, toString());    return this;}
0
public void verifyCreate()
{    create();    verify();}
0
public void verifyCreateEphemeral()
{    createEphemeral();    verify();}
0
public void verifyCreateFailure_NodeExists()
{    new StringCB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public void verifyCreateFailure_NoNode()
{    rc = Code.NONODE;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public void verifyCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public String toString()
{    return super.toString() + name;}
0
public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    this.acl = acl;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
0
public void verifyGetACL()
{    new StringCB(zk).verifyCreate();    zk.getACL(path, stat, this, toString());    verify();}
0
public void verifyGetACLFailure_NoNode()
{    rc = Code.NONODE;    stat = null;    acl = null;    zk.getACL(path, stat, this, toString());    verify();}
0
public String toString(List<ACL> acls)
{    if (acls == null) {        return "";    }    StringBuilder result = new StringBuilder();    for (ACL acl : acls) {        result.append(acl.getPerms()).append("::");    }    return result.toString();}
0
public String toString()
{    return super.toString() + toString(acl) + ":" + ":" + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
0
public void processResult(int rc, String path, Object ctx, List<String> children)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
0
public StringCB createNode()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
0
public StringCB createNode(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
0
public StringCB createNode(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
0
public void verifyGetChildrenEmpty()
{    StringCB parent = createNode();    path = parent.path;    verify();}
0
public void verifyGetChildrenSingle()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
0
public void verifyGetChildrenTwo()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
0
public void verifyGetChildrenFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    verify();}
0
public void verify()
{    zk.getChildren(path, false, this, toString());    super.verify();}
0
public String toString()
{    return super.toString() + children.toString();}
0
public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
0
public StringCB createNode()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
0
public StringCB createNode(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
0
public StringCB createNode(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
0
public void verifyGetChildrenEmpty()
{    StringCB parent = createNode();    path = parent.path;    verify();}
0
public void verifyGetChildrenSingle()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
0
public void verifyGetChildrenTwo()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
0
public void verifyGetChildrenFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    verify();}
0
public void verify()
{    zk.getChildren(path, false, this, toString());    super.verify();}
0
public String toString()
{    return super.toString() + children.toString();}
0
public void setPath(String path)
{    super.setPath(path);    this.name = path;}
0
public String nodeName()
{    return path.substring(path.lastIndexOf('/') + 1);}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    this.name = name;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
0
public AsyncCB create()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
0
public void verifyCreate()
{    create();    verify();}
0
public void verifyCreateFailure_NodeExists()
{    new Create2CB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    stat = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public void verifyCreateFailure_NoNode()
{    rc = Code.NONODE;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public void verifyCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
0
public String toString()
{    return super.toString() + name + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    this.data = data;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
0
public void verifyGetData()
{    new StringCB(zk).verifyCreate();    zk.getData(path, false, this, toString());    verify();}
0
public void verifyGetDataFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    data = null;    stat = null;    zk.getData(path, false, this, toString());    verify();}
0
public String toString()
{    return super.toString() + ":" + (data == null ? "null" : new String(data)) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
0
public void verifySetACL()
{    stat.setAversion(1);    new StringCB(zk).verifyCreate();    zk.setACL(path, acl, version, this, toString());    verify();}
0
public void verifySetACLFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setACL(path, acl, version, this, toString());    verify();}
0
public void verifySetACLFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setACL(path, acl, version + 1, this, toString());    verify();}
0
public void setData()
{    zk.setData(path, data, version, this, toString());}
0
public void verifySetData()
{    stat.setVersion(1);    new StringCB(zk).verifyCreate();    setData();    verify();}
0
public void verifySetDataFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setData(path, data, version, this, toString());    verify();}
0
public void verifySetDataFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setData(path, data, version + 1, this, toString());    verify();}
0
public void verifyExists()
{    new StringCB(zk).verifyCreate();    zk.exists(path, false, this, toString());    verify();}
0
public void verifyExistsFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.exists(path, false, this, toString());    verify();}
0
public String toString()
{    return super.toString() + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
0
public void processResult(int rc, String path, Object ctx)
{    super.processResult(Code.get(rc), path, ctx);}
0
public void delete()
{    zk.delete(path, version, this, toString());}
0
public void verifyDelete()
{    new StringCB(zk).verifyCreate();    delete();    verify();}
0
public void verifyDeleteFailure_NoNode()
{    rc = Code.NONODE;    zk.delete(path, version, this, toString());    verify();}
0
public void verifyDeleteFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    zk.delete(path, version + 1, this, toString());    verify();}
0
public void verifyDeleteFailure_NotEmpty()
{    StringCB scb = new StringCB(zk);    scb.create();    scb.setPath(path + "/bar");    scb.create();    rc = Code.NOTEMPTY;    zk.delete(path, version, this, toString());    verify();}
0
public void sync()
{    zk.sync(path, this, toString());}
0
public void verifySync()
{    sync();    verify();}
0
public String toString()
{    return super.toString() + version;}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    this.rc = rc;    this.opResults = opResults;    latch.countDown();}
0
 void latch_await()
{    try {        latch.await(10000, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }    assertSame(0L, latch.getCount());}
0
public void verifyMulti()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", -1));    zk.multi(ops, this, null);    latch_await();    assertEquals(this.rc, KeeperException.Code.OK.intValue());    assertTrue(this.opResults.get(0) instanceof OpResult.CreateResult);    assertTrue(this.opResults.get(1) instanceof OpResult.DeleteResult);}
0
public void verifyMultiFailure_AllErrorResult()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1), Op.setData("/multi", "test".getBytes(), -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(1) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(2) instanceof OpResult.ErrorResult);}
0
public void verifyMultiFailure_NoSideEffect() throws KeeperException, InterruptedException
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertNull(zk.exists("/multi", false));}
0
public void verifyMultiSequential_NoSideEffect() throws Exception
{    StringCB scb = new StringCB(zk);    scb.verifyCreate();    String path = scb.path + "-";    String seqPath = path + "0000000002";    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(path + "0000000001", false));    List<Op> ops = Arrays.asList(Op.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.delete("/nonexist", -1));    zk.multi(ops, this, null);    latch_await();    assertNull(zk.exists(seqPath, false));    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(seqPath, false));}
0
public void setUp() throws Exception
{    super.setUp();        zk = createClient();    zk.addAuthInfo("digest", "ben:passwd".getBytes());}
1
public void tearDown() throws Exception
{    zk.close();    super.tearDown();    }
1
public void testAsyncCreate()
{    new StringCB(zk).verifyCreate();}
0
public void testAsyncCreate2()
{    new Create2CB(zk).verifyCreate();}
0
public void testAsyncCreateThree()
{    CountDownLatch latch = new CountDownLatch(3);    StringCB op1 = new StringCB(zk, latch);    op1.setPath("/op1");    StringCB op2 = new StringCB(zk, latch);    op2.setPath("/op2");    StringCB op3 = new StringCB(zk, latch);    op3.setPath("/op3");    op1.create();    op2.create();    op3.create();    op1.verify();    op2.verify();    op3.verify();}
0
public void testAsyncCreateFailure_NodeExists()
{    new StringCB(zk).verifyCreateFailure_NodeExists();}
0
public void testAsyncCreateFailure_NoNode()
{    new StringCB(zk).verifyCreateFailure_NoNode();}
0
public void testAsyncCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateFailure_NoChildForEphemeral();}
0
public void testAsyncCreate2Failure_NodeExists()
{    new Create2CB(zk).verifyCreateFailure_NodeExists();}
0
public void testAsyncCreate2Failure_NoNode()
{    new Create2CB(zk).verifyCreateFailure_NoNode();}
0
public void testAsyncCreate2Failure_NoChildForEphemeral()
{    new Create2CB(zk).verifyCreateFailure_NoChildForEphemeral();}
0
public void testAsyncDelete()
{    new VoidCB(zk).verifyDelete();}
0
public void testAsyncDeleteFailure_NoNode()
{    new VoidCB(zk).verifyDeleteFailure_NoNode();}
0
public void testAsyncDeleteFailure_BadVersion()
{    new VoidCB(zk).verifyDeleteFailure_BadVersion();}
0
public void testAsyncDeleteFailure_NotEmpty()
{    new VoidCB(zk).verifyDeleteFailure_NotEmpty();}
0
public void testAsyncSync()
{    new VoidCB(zk).verifySync();}
0
public void testAsyncSetACL()
{    new StatCB(zk).verifySetACL();}
0
public void testAsyncSetACLFailure_NoNode()
{    new StatCB(zk).verifySetACLFailure_NoNode();}
0
public void testAsyncSetACLFailure_BadVersion()
{    new StatCB(zk).verifySetACLFailure_BadVersion();}
0
public void testAsyncSetData()
{    new StatCB(zk).verifySetData();}
0
public void testAsyncSetDataFailure_NoNode()
{    new StatCB(zk).verifySetDataFailure_NoNode();}
0
public void testAsyncSetDataFailure_BadVersion()
{    new StatCB(zk).verifySetDataFailure_BadVersion();}
0
public void testAsyncExists()
{    new StatCB(zk).verifyExists();}
0
public void testAsyncExistsFailure_NoNode()
{    new StatCB(zk).verifyExistsFailure_NoNode();}
0
public void testAsyncGetACL()
{    new ACLCB(zk).verifyGetACL();}
0
public void testAsyncGetACLFailure_NoNode()
{    new ACLCB(zk).verifyGetACLFailure_NoNode();}
0
public void testAsyncGetChildrenEmpty()
{    new ChildrenCB(zk).verifyGetChildrenEmpty();}
0
public void testAsyncGetChildrenSingle()
{    new ChildrenCB(zk).verifyGetChildrenSingle();}
0
public void testAsyncGetChildrenTwo()
{    new ChildrenCB(zk).verifyGetChildrenTwo();}
0
public void testAsyncGetChildrenFailure_NoNode()
{    new ChildrenCB(zk).verifyGetChildrenFailure_NoNode();}
0
public void testAsyncGetChildren2Empty()
{    new Children2CB(zk).verifyGetChildrenEmpty();}
0
public void testAsyncGetChildren2Single()
{    new Children2CB(zk).verifyGetChildrenSingle();}
0
public void testAsyncGetChildren2Two()
{    new Children2CB(zk).verifyGetChildrenTwo();}
0
public void testAsyncGetChildren2Failure_NoNode()
{    new Children2CB(zk).verifyGetChildrenFailure_NoNode();}
0
public void testAsyncGetData()
{    new DataCB(zk).verifyGetData();}
0
public void testAsyncGetDataFailure_NoNode()
{    new DataCB(zk).verifyGetDataFailure_NoNode();}
0
public void testAsyncMulti()
{    new MultiCB(zk).verifyMulti();}
0
public void testAsyncMultiFailure_AllErrorResult()
{    new MultiCB(zk).verifyMultiFailure_AllErrorResult();}
0
public void testAsyncMultiFailure_NoSideEffect() throws Exception
{    new MultiCB(zk).verifyMultiFailure_NoSideEffect();}
0
public void testAsyncMultiSequential_NoSideEffect() throws Exception
{    new MultiCB(zk).verifyMultiSequential_NoSideEffect();}
0
public void setUp() throws Exception
{    qb.setUp();}
0
public void tearDown() throws Exception
{        qb.tearDown();}
1
private ZooKeeper createClient() throws Exception
{    return createClient(qb.hostPort);}
0
private ZooKeeper createClient(String hp) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient(hp);    return zk;}
0
public void testAsync() throws Exception
{    ZooKeeper zk = null;    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.create("/ben", new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT, this, results);        zk.create("/ben/2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.delete("/ben", -1, this, results);        zk.create("/ben2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.getData("/ben2", false, this, results);        synchronized (results) {            while (results.size() < 5) {                results.wait();            }        }        assertEquals(0, (int) results.get(0));        assertEquals(Code.NOAUTH, Code.get(results.get(1)));        assertEquals(0, (int) results.get(2));        assertEquals(0, (int) results.get(3));        assertEquals(0, (int) results.get(4));    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        try {            zk.getData("/ben2", false, new Stat());            fail("Should have received a permission error");        } catch (KeeperException e) {            assertEquals(Code.NOAUTH, e.code());        }    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/ben2", false, new Stat());    } finally {        zk.close();    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void setupTestDir() throws IOException
{    testDir = ClientBase.createEmptyTestDir();    dstFile = new File(testDir, "test.txt");}
0
public void cleanupTestDir() throws IOException
{    ClientBase.recursiveDelete(testDir);}
0
public void testWriteNewFile() throws IOException
{    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertFalse(dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();    assertFalse(dstFile.exists());    fos.close();    assertTrue(dstFile.exists());    String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
0
public void testOverwriteFile() throws IOException
{    assertTrue("Creating empty dst file", dstFile.createNewFile());    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertTrue("Empty file still exists", dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();        assertEquals("", ClientBase.readFile(dstFile));    fos.close();        String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
0
public void testFailToFlush() throws IOException
{        FileOutputStream fos = new FileOutputStream(dstFile);    fos.write(TEST_STRING_2.getBytes());    fos.close();    OutputStream failingStream = createFailingStream();    failingStream.write(TEST_STRING.getBytes());    try {        failingStream.close();        fail("Close didn't throw exception");    } catch (IOException ioe) {        }        assertEquals(TEST_STRING_2, ClientBase.readFile(dstFile));    assertEquals("Temporary file should have been cleaned up", dstFile.getName(), ClientBase.join(",", testDir.list()));}
0
private OutputStream createFailingStream() throws FileNotFoundException
{    return new AtomicFileOutputStream(dstFile) {        @Override        public void flush() throws IOException {            throw new IOException("injected failure");        }    };}
0
public void flush() throws IOException
{    throw new IOException("injected failure");}
0
public void testAbortNewFile() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.abort();    assertEquals(0, testDir.list().length);}
0
public void testAbortNewFileAfterFlush() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.write(TEST_STRING.getBytes());    fos.flush();    fos.abort();    assertEquals(0, testDir.list().length);}
0
public void testAbortExistingFile() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
0
public void testAbortExistingFileAfterFlush() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.write(TEST_STRING_2.getBytes());    fos2.flush();    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
0
public void testBadAuthNotifiesWatch() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("FOO", "BAR".getBytes());        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
0
public void testBadAuthThenSendOtherCommands() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("INVALID", "BAR".getBytes());        zk.exists("/foobar", false);        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
0
public void testSuper() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:pass2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);    } finally {        zk.close();    }}
0
public void testSuperACL() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);        zk.setACL("/path1", Ids.READ_ACL_UNSAFE, -1);        zk.create("/path1/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setACL("/path1", Ids.OPEN_ACL_UNSAFE, -1);    } finally {        zk.close();    }}
0
public void setMaxBuffer() throws IOException, InterruptedException
{    System.setProperty("jute.maxbuffer", "" + TEST_MAXBUFFER);    assertEquals("Can't set jute.maxbuffer!", TEST_MAXBUFFER, BinaryInputArchive.maxBuffer);    zk = createClient();}
0
public void testCreatesReqs() throws Exception
{    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    });}
0
public void execute(byte[] data) throws Exception
{    zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
0
public void testSetReqs() throws Exception
{    final String path = "/set_test";    zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.setData(path, data, -1);        }    });}
0
public void execute(byte[] data) throws Exception
{    zk.setData(path, data, -1);}
0
private void testRequests(ClientOp clientOp) throws Exception
{    clientOp.execute(new byte[TEST_MAXBUFFER - 60]);    try {                clientOp.execute(new byte[TEST_MAXBUFFER]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }    try {        clientOp.execute(new byte[TEST_MAXBUFFER + 10]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }}
0
public void testStartup() throws Exception
{    final String path = "/test_node";    zk.create(path, new byte[TEST_MAXBUFFER - 60], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.setData(path, new byte[TEST_MAXBUFFER - 50], -1);    stopServer();    startServer();}
0
public void testStartupFailureCreate() throws Exception
{        testStartupFailure(new File(TEST_DATA, "create"), "Server started despite create exceeding jute.maxbuffer!");}
0
public void testStartupFailureSet() throws Exception
{        testStartupFailure(new File(TEST_DATA, "set"), "Server started despite set exceeding jute.maxbuffer!");}
0
public void testStartupFailureSnapshot() throws Exception
{        testStartupFailure(new File(TEST_DATA, "snapshot"), "Server started despite znode exceeding jute.maxbuffer!");}
0
private void testStartupFailure(File testDir, String failureMsg) throws Exception
{    stopServer();        File oldTmpDir = tmpDir;    tmpDir = testDir;    try {        startServer();        fail(failureMsg);    } catch (IOException e) {            } finally {        tmpDir = oldTmpDir;    }}
1
public void setUp() throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootasynctest";    super.setUp();        ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootasynctest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
1
public void setUp() throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootclienttest";    System.out.println(hostPort);    super.setUp();        ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootclienttest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
1
public void testPing() throws Exception
{}
0
public void process(WatchedEvent event)
{    System.out.println("latch:" + path + " " + event.getPath());    this.eventPath = event.getPath();    latch.countDown();}
0
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("No watch received within timeout period " + path);    }    return path.equals(eventPath);}
0
public void testChrootSynchronous() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = createClient();    try {        zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk1 != null) {            zk1.close();        }    }    ZooKeeper zk2 = createClient(hostPort + "/ch1");    try {        assertEquals("/ch2", zk2.create("/ch2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    } finally {        if (zk2 != null) {            zk2.close();        }    }    zk1 = createClient();    zk2 = createClient(hostPort + "/ch1");    try {                MyWatcher w1 = new MyWatcher("/ch1");        assertNotNull(zk1.exists("/ch1", w1));        MyWatcher w2 = new MyWatcher("/ch1/ch2");        assertNotNull(zk1.exists("/ch1/ch2", w2));        MyWatcher w3 = new MyWatcher("/ch2");        assertNotNull(zk2.exists("/ch2", w3));                MyWatcher w4 = new MyWatcher("/ch1");        zk1.getChildren("/ch1", w4);        MyWatcher w5 = new MyWatcher("/");        zk2.getChildren("/", w5);                zk1.setData("/ch1", "1".getBytes(), -1);        zk2.setData("/ch2", "2".getBytes(), -1);                assertTrue(w1.matches());        assertTrue(w2.matches());        assertTrue(w3.matches());                try {            zk2.setData("/ch3", "3".getBytes(), -1);        } catch (KeeperException.NoNodeException e) {            assertEquals("/ch3", e.getPath());        }        assertTrue(Arrays.equals("1".getBytes(), zk1.getData("/ch1", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk1.getData("/ch1/ch2", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk2.getData("/ch2", false, null)));                zk2.delete("/ch2", -1);        assertTrue(w4.matches());        assertTrue(w5.matches());        zk1.delete("/ch1", -1);        assertNull(zk1.exists("/ch1", false));        assertNull(zk1.exists("/ch1/ch2", false));        assertNull(zk2.exists("/ch2", false));    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
0
public synchronized void reset()
{    clientConnected = new CountDownLatch(1);    connected = false;    syncConnected = false;    readOnlyConnected = false;}
0
public synchronized void process(WatchedEvent event)
{    KeeperState state = event.getState();    if (state == KeeperState.SyncConnected) {        connected = true;        syncConnected = true;        readOnlyConnected = false;    } else if (state == KeeperState.ConnectedReadOnly) {        connected = true;        syncConnected = false;        readOnlyConnected = true;    } else {        connected = false;        syncConnected = false;        readOnlyConnected = false;    }    notifyAll();    if (connected) {        clientConnected.countDown();    }}
0
public synchronized boolean isConnected()
{    return connected;}
0
public synchronized void waitForConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!connected) {        throw new TimeoutException("Failed to connect to ZooKeeper server.");    }}
0
public synchronized void waitForSyncConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!syncConnected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!syncConnected) {        throw new TimeoutException("Failed to connect to read-write ZooKeeper server.");    }}
0
public synchronized void waitForReadOnlyConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = System.currentTimeMillis() + timeout;    long left = timeout;    while (!readOnlyConnected && left > 0) {        wait(left);        left = expire - System.currentTimeMillis();    }    if (!readOnlyConnected) {        throw new TimeoutException("Failed to connect in read-only mode to ZooKeeper server.");    }}
0
public synchronized void waitForDisconnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (connected) {        throw new TimeoutException("Did not disconnect");    }}
0
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
0
protected TestableZooKeeper createClient(CountdownWatcher watcher) throws IOException, InterruptedException
{    return createClient(watcher, hostPort);}
0
protected TestableZooKeeper createClient(CountdownWatcher watcher, String hp) throws IOException, InterruptedException
{    return createClient(watcher, hp, CONNECTION_TIMEOUT);}
0
protected TestableZooKeeper createClient(CountdownWatcher watcher, String hp, int timeout) throws IOException, InterruptedException
{    watcher.reset();    TestableZooKeeper zk = new TestableZooKeeper(hp, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        if (exceptionOnFailedConnect) {            throw new ProtocolException("Unable to connect to server");        }        fail("Unable to connect to server");    }    synchronized (this) {        if (!allClientsSetup) {                        fail("allClients never setup");        }        if (allClients != null) {            allClients.add(zk);            JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));        } else {                        zk.close();        }    }    return zk;}
1
public static List<HostPort> parseHostPortList(String hplist)
{    ArrayList<HostPort> alist = new ArrayList<HostPort>();    for (String hp : hplist.split(",")) {        int idx = hp.lastIndexOf(':');        String host = hp.substring(0, idx);        int port;        try {            port = Integer.parseInt(hp.substring(idx + 1));        } catch (RuntimeException e) {            throw new RuntimeException("Problem parsing " + hp + e.toString());        }        alist.add(new HostPort(host, port));    }    return alist;}
0
public static boolean waitForServerUp(String hp, long timeout)
{    return waitForServerUp(hp, timeout, false);}
0
public static boolean waitForServerUp(String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {                        HostPort hpobj = parseHostPortList(hp).get(0);            String result = send4LetterWord(hpobj.host, hpobj.port, "stat", secure);            if (result.startsWith("Zookeeper version:") && !result.contains("READ-ONLY")) {                return true;            }        } catch (ConnectException e) {                                } catch (IOException e) {                                } catch (SSLContextException e) {                    }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
1
public static boolean waitForServerDown(String hp, long timeout)
{    return waitForServerDown(hp, timeout, false);}
0
public static boolean waitForServerDown(String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {            HostPort hpobj = parseHostPortList(hp).get(0);            send4LetterWord(hpobj.host, hpobj.port, "stat", secure);        } catch (IOException e) {            return true;        } catch (SSLContextException e) {            return true;        }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
0
public static boolean waitForServerState(QuorumPeer qp, int timeout, String... serverStates)
{    long start = Time.currentElapsedTime();    while (true) {        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }        for (String state : serverStates) {            if (qp.getServerState().equals(state)) {                return true;            }        }        if (Time.currentElapsedTime() > start + timeout) {            return false;        }    }}
0
 static void verifyThreadTerminated(Thread thread, long millis) throws InterruptedException
{    thread.join(millis);    if (thread.isAlive()) {                assertFalse("thread " + thread.getName() + " still alive after join", true);    }}
1
public static File createEmptyTestDir() throws IOException
{    return createTmpDir(BASETEST, false);}
0
public static File createTmpDir() throws IOException
{    return createTmpDir(BASETEST, true);}
0
 static File createTmpDir(File parentDir, boolean createInitFile) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());        if (createInitFile) {        createInitializeFile(tmpDir);    }    return tmpDir;}
0
public static void createInitializeFile(File dir) throws IOException
{    File initFile = new File(dir, "initialize");    if (!initFile.exists()) {        assertTrue(initFile.createNewFile());    }}
0
private static int getPort(String hostPort)
{    String[] split = hostPort.split(":");    String portstr = split[split.length - 1];    String[] pc = portstr.split("/");    if (pc.length > 1) {        portstr = pc[0];    }    return Integer.parseInt(portstr);}
0
public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort, int serverId) throws IOException, InterruptedException
{    final int port = getPort(hostPort);        ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);    zks.setCreateSessionTrackerServerId(serverId);    factory.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure()));}
1
public static ServerCnxnFactory createNewServerInstance(ServerCnxnFactory factory, String hostPort, int maxCnxns) throws IOException, InterruptedException
{    final int port = getPort(hostPort);        if (factory == null) {        factory = ServerCnxnFactory.createFactory(port, maxCnxns);    }    return factory;}
1
 static void shutdownServerInstance(ServerCnxnFactory factory, String hostPort)
{    if (factory != null) {        ZKDatabase zkDb = null;        {            ZooKeeperServer zs = factory.getZooKeeperServer();            if (zs != null) {                zkDb = zs.getZKDatabase();            }        }        factory.shutdown();        try {            if (zkDb != null) {                zkDb.close();            }        } catch (IOException ie) {                    }        final int PORT = getPort(hostPort);        assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT, factory.isSecure()));    }}
1
public static void setupTestEnv()
{                    System.setProperty("zookeeper.preAllocSize", "100");    FilePadding.setPreallocSize(100 * 1024);}
0
protected void setUpAll() throws Exception
{    allClients = new LinkedList<ZooKeeper>();    allClientsSetup = true;}
0
public void setUp() throws Exception
{    setUpWithServerId(1);}
0
protected void setUpWithServerId(int serverId) throws Exception
{    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        initialFdCount = osMbean.getOpenFileDescriptorCount();            }    setupTestEnv();    setupCustomizedEnv();    JMXEnv.setUp();    setUpAll();    tmpDir = createTmpDir(BASETEST, true);    startServer(serverId);    }
1
protected void startServer() throws Exception
{    startServer(1);}
0
public void setupCustomizedEnv()
{/* do nothing by default */}
0
private void startServer(int serverId) throws Exception
{        serverFactory = createNewServerInstance(serverFactory, hostPort, maxCnxns);    startServerInstance(tmpDir, serverFactory, hostPort, serverId);        Set<ObjectName> children = JMXEnv.ensureParent("InMemoryDataTree", "StandaloneServer_port");                    verifyUnexpectedBeans(children);}
1
private void verifyUnexpectedBeans(Set<ObjectName> children)
{    if (allClients != null) {        for (ZooKeeper zkc : allClients) {            Iterator<ObjectName> childItr = children.iterator();            while (childItr.hasNext()) {                ObjectName clientBean = childItr.next();                if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {                                        childItr.remove();                }            }        }    }    for (ObjectName bean : children) {            }    assertEquals("Unexpected bean exists!", 0, children.size());}
1
protected static String getHexSessionId(long sessionId)
{    return "0x" + Long.toHexString(sessionId);}
0
protected void stopServer() throws Exception
{        shutdownServerInstance(serverFactory, hostPort);    serverFactory = null;        JMXEnv.ensureOnly();}
1
protected void tearDownAll() throws Exception
{    synchronized (this) {        if (allClients != null) {            for (ZooKeeper zk : allClients) {                try {                    if (zk != null) {                        zk.close();                    }                } catch (InterruptedException e) {                                    }            }        }        allClients = null;    }}
1
public void tearDown() throws Exception
{        tearDownAll();    stopServer();    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), recursiveDelete(tmpDir));    }        serverFactory = null;    JMXEnv.tearDown();    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        long fdCount = osMbean.getOpenFileDescriptorCount();        String message = "fdcount after test is: " + fdCount + " at start it was " + initialFdCount;                if (fdCount > initialFdCount) {                                    }    }    cleanUpCustomizedEnv();}
1
public void cleanUpCustomizedEnv()
{/* do nothing by default */}
0
public static MBeanServerConnection jmxConn() throws IOException
{    return JMXEnv.conn();}
0
public static boolean recursiveDelete(File d)
{    return TestUtils.deleteFileRecursively(d, true);}
0
public static void logAllStackTraces()
{    StringBuilder sb = new StringBuilder();    sb.append("Starting logAllStackTraces()\n");    Map<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();    for (Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {        sb.append("Thread " + e.getKey().getName() + "\n");        for (StackTraceElement elem : e.getValue()) {            sb.append("\tat " + elem + "\n");        }    }    sb.append("Ending logAllStackTraces()\n");    }
1
 void verifyRootOfAllServersMatch(String hostPort) throws InterruptedException, KeeperException, IOException
{    String[] parts = hostPort.split(",");            int[] counts = new int[parts.length];    int failed = 0;    for (int j = 0; j < 100; j++) {        int[] newcounts = new int[parts.length];        int i = 0;        for (String hp : parts) {            try {                ZooKeeper zk = createClient(hp);                try {                    newcounts[i++] = zk.getChildren("/", false).size();                } finally {                    zk.close();                }            } catch (Throwable t) {                failed++;                                                logAllStackTraces();            }        }        if (Arrays.equals(newcounts, counts)) {                        counts = newcounts;            break;        } else {            counts = newcounts;            Thread.sleep(10000);        }                if (failed > 10) {            break;        }    }        String logmsg = "node count not consistent{} {}";    for (int i = 1; i < parts.length; i++) {        if (counts[i - 1] != counts[i]) {                    } else {                    }    }}
1
public static String readFile(File file) throws IOException
{    ByteArrayOutputStream os = new ByteArrayOutputStream();    BufferedInputStream is = new BufferedInputStream(new FileInputStream(file));    try {        IOUtils.copyBytes(is, os, 1024, true);    } finally {        is.close();    }    return os.toString();}
0
public static String join(String separator, Object[] parts)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (Object part : parts) {        if (!first) {            sb.append(separator);            first = false;        }        sb.append(part);    }    return sb.toString();}
0
public static ZooKeeper createZKClient(String cxnString) throws Exception
{    return createZKClient(cxnString, CONNECTION_TIMEOUT);}
0
public static ZooKeeper createZKClient(String cxnString, int sessionTimeout) throws IOException
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(cxnString, sessionTimeout, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper client can not connect to " + cxnString);    }    return zk;}
0
public void run()
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {                        Thread.sleep(HAMMERTHREAD_LATENCY);            zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } catch (Throwable t) {            } finally {        try {            zk.close();        } catch (InterruptedException e) {                    }    }}
1
public void run()
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {            ZooKeeper zk = parent.createClient();            try {                zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            } finally {                try {                    zk.close();                } catch (InterruptedException e) {                                    }            }        }    } catch (Throwable t) {            }}
1
public void testHammerBasic() throws Throwable
{    runHammer(10, 1000);}
0
public void runHammer(final int threadCount, final int childCount) throws Throwable
{    try {        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            ZooKeeper zk = createClient();            String prefix = "/test-" + i;            zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            prefix += "/";            HammerThread thread = new BasicHammerThread("BasicHammerThread-" + i, zk, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {                throw t;    }}
1
public void testHammerSuper() throws Throwable
{    try {        final int threadCount = 5;        final int childCount = 10;        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            String prefix = "/test-" + i;            {                ZooKeeper zk = createClient();                try {                    zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                } finally {                    zk.close();                }            }            prefix += "/";            HammerThread thread = new SuperHammerThread("SuperHammerThread-" + i, this, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {                throw t;    }}
1
public void verifyHammer(long start, HammerThread[] threads, int childCount) throws IOException, InterruptedException, KeeperException
{            int workingCount = threads.length;    for (int i = 0; i < 120; i++) {        Thread.sleep(10000);        for (HammerThread h : threads) {            if (!h.isAlive() || h.current == h.count) {                workingCount--;            }        }        if (workingCount == 0) {            break;        }        workingCount = threads.length;    }    if (workingCount > 0) {        for (HammerThread h : threads) {                    }    } else {            }    for (HammerThread h : threads) {        final int safetyFactor = 3;        verifyThreadTerminated(h, (long) threads.length * (long) childCount * HAMMERTHREAD_LATENCY * (long) safetyFactor);    }        ZooKeeper zk = createClient();    try {                for (int i = 0; i < threads.length; i++) {                        List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }        for (int i = 0; i < threads.length; i++) {            List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }    } finally {        zk.close();    }}
1
public void testBindByAddress() throws Exception
{    String bindAddress = null;    Enumeration<NetworkInterface> intfs = NetworkInterface.getNetworkInterfaces();        while (intfs.hasMoreElements()) {        NetworkInterface i = intfs.nextElement();        try {            if (i.isLoopback()) {                Enumeration<InetAddress> addrs = i.getInetAddresses();                while (addrs.hasMoreElements()) {                    InetAddress a = addrs.nextElement();                    if (a.isLoopbackAddress()) {                        bindAddress = a.getHostAddress();                        if (a instanceof Inet6Address) {                            bindAddress = "[" + bindAddress + "]";                        }                        break;                    }                }            }        } catch (SocketException se) {                    }    }    if (bindAddress == null) {                return;    }    final int PORT = PortAssignment.unique();        final String HOSTPORT = bindAddress + ":" + PORT;        File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(new InetSocketAddress(bindAddress, PORT), -1);    f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }}
1
public void setUp() throws Exception
{    maxCnxns = 1;    super.setUp();}
0
public void testClientRetry() throws IOException, InterruptedException, TimeoutException
{    CountdownWatcher cdw1 = new CountdownWatcher();    CountdownWatcher cdw2 = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, cdw1);    try {        cdw1.waitForConnected(CONNECTION_TIMEOUT);        ZooKeeper zk2 = new ZooKeeper(hostPort, 10000, cdw2);        try {            States s1 = zk.getState();            States s2 = zk2.getState();            assertSame(s1, States.CONNECTED);            assertSame(s2, States.CONNECTING);            cdw1.reset();            zk.close();            cdw1.waitForDisconnected(CONNECTION_TIMEOUT);            cdw2.waitForConnected(CONNECTION_TIMEOUT);            assertSame(zk2.getState(), States.CONNECTED);        } finally {            zk2.close();        }    } finally {        zk.close();    }}
0
public static void setup()
{    System.setProperty("zookeeper.skipACL", "yes");}
0
public static void teardown()
{    System.clearProperty("zookeeper.skipACL");}
0
public void setup()
{    System.setProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY, Boolean.TRUE.toString());    clientX509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(clientX509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(clientX509Util.getSslTruststorePasswdProperty(), "testpass");}
0
public void teardown()
{    System.clearProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY);    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    clientX509Util.close();}
0
public void testClientServerUnifiedPort() throws Exception
{    testClientServerSSL(false);}
0
public void testClientServerSSL() throws Exception
{    testClientServerSSL(true);}
0
public void testClientServerSSL(boolean useSecurePort) throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    final Integer[] secureClientPorts = new Integer[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        secureClientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=127.0.0.1:%d:%d:participant;127.0.0.1:%d%n", i, PortAssignment.unique(), PortAssignment.unique(), clientPorts[i]);        sb.append(server);    }    String quorumCfg = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (useSecurePort) {            mt[i] = new MainThread(i, quorumCfg, secureClientPorts[i], true);        } else {            mt[i] = new MainThread(i, quorumCfg, true);        }        mt[i].start();    }            ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], 2 * TIMEOUT);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], TIMEOUT));        final int port = useSecurePort ? secureClientPorts[i] : clientPorts[i];        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + port, TIMEOUT);                zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/test", -1);        zk.close();    }    for (int i = 0; i < mt.length; i++) {        mt[i].shutdown();    }}
0
public void testSecureStandaloneServer() throws Exception
{    Integer secureClientPort = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, "", secureClientPort, false);    mt.start();    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + secureClientPort, TIMEOUT);    zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/test", -1);    zk.close();    mt.shutdown();}
0
public void testPing() throws Exception
{    ZooKeeper zkIdle = null;    ZooKeeper zkWatchCreator = null;    try {        CountdownWatcher watcher = new CountdownWatcher();        zkIdle = createClient(watcher, hostPort, 10000);        zkWatchCreator = createClient();        for (int i = 0; i < 10; i++) {            zkWatchCreator.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        for (int i = 0; i < 10; i++) {            zkIdle.exists("/" + i, true);        }        for (int i = 0; i < 10; i++) {            Thread.sleep(1000);            zkWatchCreator.delete("/" + i, -1);        }                zkIdle.exists("/0", false);    } finally {        if (zkIdle != null) {            zkIdle.close();        }        if (zkWatchCreator != null) {            zkWatchCreator.close();        }    }}
0
public void testClientwithoutWatcherObj() throws IOException, InterruptedException, KeeperException
{    performClientTest(false);}
0
public void testClientWithWatcherObj() throws IOException, InterruptedException, KeeperException
{    performClientTest(true);}
0
public void testTestability() throws Exception
{    TestableZooKeeper zk = createClient();    try {                            } finally {        zk.close(CONNECTION_TIMEOUT);                            }}
1
public void testACLs() throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        try {            zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id("ip", "127.0.0.1/8")));            zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));            zk.create("/nullidtest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", "")));        testACL.add(new ACL(Perms.WRITE, new Id("ip", "127.0.0.1")));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);                acls = zk.getACL("/acltest", null);        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);        zk.close();    } finally {        if (zk != null) {            zk.close();        }    }}
1
public void testNullAuthId() throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", null)));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
1
public void testMutipleWatcherObjs() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = createClient(new CountdownWatcher(), hostPort);    try {        MyWatcher[] watchers = new MyWatcher[100];        MyWatcher[] watchers2 = new MyWatcher[watchers.length];        for (int i = 0; i < watchers.length; i++) {            watchers[i] = new MyWatcher();            watchers2[i] = new MyWatcher();            zk.create("/foo-" + i, ("foodata" + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        Stat stat = new Stat();                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));        }        for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata2-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata3-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata4-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata5-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers2[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata6-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata7-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());                        WatchedEvent event2 = watchers2[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event2.getPath());            assertEquals(EventType.NodeDataChanged, event2.getType());            assertEquals(KeeperState.SyncConnected, event2.getState());                                                assertEquals(0, watchers2[i].events.size());        }    } finally {        if (zk != null) {            zk.close();        }    }}
0
private void performClientTest(boolean withWatcherObj) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);                zk.create("/benwashere", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                try {            zk.setData("/benwashere", "hi".getBytes(), 57);            fail("Should have gotten BadVersion exception");        } catch (KeeperException.BadVersionException e) {                } catch (KeeperException e) {            fail("Should have gotten BadVersion exception");        }                zk.delete("/benwashere", 0);                zk.close();                Thread.sleep(2000);        zk = createClient(watcher, hostPort);                        try {            zk.delete("/", -1);            fail("deleted root!");        } catch (KeeperException.BadArgumentsException e) {                }        Stat stat = new Stat();                zk.create("/pat", "Pat was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.create("/pat/ben", "Ben was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                List<String> children = zk.getChildren("/pat", false);        assertEquals(1, children.size());        assertEquals("ben", children.get(0));        List<String> children2 = zk.getChildren("/pat", false, null);        assertEquals(children, children2);        String value = new String(zk.getData("/pat/ben", false, stat));        assertEquals("Ben was here", value);        try {            if (withWatcherObj) {                assertEquals(null, zk.exists("/frog", watcher));            } else {                assertEquals(null, zk.exists("/frog", true));            }                    } catch (KeeperException.NoNodeException e) {                }        zk.create("/frog", "hi".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                        WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/frog", event.getPath());        assertEquals(EventType.NodeCreated, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());                zk.getChildren("/pat/ben", true);        for (int i = 0; i < 10; i++) {            zk.create("/pat/ben/" + i + "-", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren("/pat/ben", false);        Collections.sort(children);        assertEquals(10, children.size());        for (int i = 0; i < 10; i++) {            final String name = children.get(i);            assertTrue("starts with -", name.startsWith(i + "-"));            byte[] b;            if (withWatcherObj) {                b = zk.getData("/pat/ben/" + name, watcher, stat);            } else {                b = zk.getData("/pat/ben/" + name, true, stat);            }            assertEquals(Integer.toString(i), new String(b));            zk.setData("/pat/ben/" + name, "new".getBytes(), stat.getVersion());            if (withWatcherObj) {                stat = zk.exists("/pat/ben/" + name, watcher);            } else {                stat = zk.exists("/pat/ben/" + name, true);            }            zk.delete("/pat/ben/" + name, stat.getVersion());        }        event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/pat/ben", event.getPath());        assertEquals(EventType.NodeChildrenChanged, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());        for (int i = 0; i < 10; i++) {            event = watcher.events.poll(10, TimeUnit.SECONDS);            final String name = children.get(i);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDeleted, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());        }        zk.create("/good\u0040path", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("duplicate create allowed");        } catch (KeeperException.NodeExistsException e) {                }    } finally {        if (zk != null) {            zk.close();        }    }}
1
public void testSequentialNodeNames() throws IOException, InterruptedException, KeeperException
{    String path = "/SEQUENCE";    String file = "TEST";    String filepath = path + "/" + file;    ZooKeeper zk = null;    try {        zk = createClient();        zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(path, false);        assertEquals(1, children.size());        assertEquals(file + "0000000000", children.get(0));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(2, children.size());        assertTrue("contains child 1", children.contains(file + "0000000001"));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(3, children.size());        assertTrue("contains child 2", children.contains(file + "0000000002"));                for (int i = children.size(); i < 105; i++) {            zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren(path, false);        assertTrue("contains child 104", children.contains(file + "0000000104"));    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void testSequentialNodeData() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/queue";    try {        zk = createClient();        zk.create(queue_handle, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(queue_handle + "/element", "0".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        zk.create(queue_handle + "/element", "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(queue_handle, true);        assertEquals(children.size(), 2);        String child1 = children.get(0);        String child2 = children.get(1);        int compareResult = child1.compareTo(child2);        assertNotSame(compareResult, 0);        if (compareResult < 0) {        } else {            String temp = child1;            child1 = child2;            child2 = temp;        }        String child1data = new String(zk.getData(queue_handle + "/" + child1, false, null));        String child2data = new String(zk.getData(queue_handle + "/" + child2, false, null));        assertEquals(child1data, "0");        assertEquals(child2data, "1");    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void testLargeNodeData() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/large";    try {        zk = createClient();        zk.create(queue_handle, new byte[500000], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk != null) {            zk.close();        }    }}
0
private void verifyCreateFails(String path, ZooKeeper zk) throws Exception
{    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (IllegalArgumentException e) {                return;    }    fail("bad path \"" + path + "\" not caught");}
0
public void testPathValidation() throws Exception
{    ZooKeeper zk = createClient();    verifyCreateFails(null, zk);    verifyCreateFails("", zk);    verifyCreateFails("//", zk);    verifyCreateFails("///", zk);    verifyCreateFails("////", zk);    verifyCreateFails("/.", zk);    verifyCreateFails("/..", zk);    verifyCreateFails("/./", zk);    verifyCreateFails("/../", zk);    verifyCreateFails("/foo/./", zk);    verifyCreateFails("/foo/../", zk);    verifyCreateFails("/foo/.", zk);    verifyCreateFails("/foo/..", zk);    verifyCreateFails("/./.", zk);    verifyCreateFails("/../..", zk);    verifyCreateFails("/\u0001foo", zk);    verifyCreateFails("/foo/bar/", zk);    verifyCreateFails("/foo//bar", zk);    verifyCreateFails("/foo/bar//", zk);    verifyCreateFails("foo", zk);    verifyCreateFails("a", zk);    zk.create("/createseqpar", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    try {        zk.create("/createseqpar//", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/./", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/../", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        PrepRequestProcessor.setFailCreate(true);    try {        zk.create("/m", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (KeeperException.BadArgumentsException be) {        }    PrepRequestProcessor.setFailCreate(false);    zk.create("/.foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/.f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f.c", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f\u0040f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f./f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
0
public void testDeleteWithChildren() throws Exception
{    ZooKeeper zk = createClient();    zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/parent/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        zk.delete("/parent", -1);        fail("Should have received a not equals message");    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NOTEMPTY, e.code());    }    zk.delete("/parent/child", -1);    zk.delete("/parent", -1);    zk.close();}
0
public void run()
{    try {        for (; current < count; current++) {            TestableZooKeeper zk = createClient();                                                zk.close(CONNECTION_TIMEOUT);        }    } catch (Throwable t) {            }}
1
public void testClientCleanup() throws Throwable
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {                return;    }    final int threadCount = 3;    final int clientCount = 10;    /* Log the number of fds used before and after a test is run. Verifies         * we are freeing resources correctly. Unfortunately this only works         * on unix systems (the only place sun has implemented as part of the         * mgmt bean api).         */    long initialFdCount = osMbean.getOpenFileDescriptorCount();    VerifyClientCleanup[] threads = new VerifyClientCleanup[threadCount];    for (int i = 0; i < threads.length; i++) {        threads[i] = new VerifyClientCleanup("VCC" + i, clientCount);        threads[i].start();    }    for (int i = 0; i < threads.length; i++) {        threads[i].join(CONNECTION_TIMEOUT);        assertTrue(threads[i].current == threads[i].count);    }            long currentCount = osMbean.getOpenFileDescriptorCount();    final String logmsg = "open fds after test ({}) are not significantly higher than before ({})";    if (currentCount > initialFdCount + 10) {                    } else {            }}
1
public void testNonExistingOpCode() throws Exception
{    final CountDownLatch clientDisconnected = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public synchronized void process(WatchedEvent event) {            if (event.getState() == KeeperState.Disconnected) {                clientDisconnected.countDown();            }        }    };    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    final String path = "/m1";    RequestHeader h = new RequestHeader();        h.setType(888);    ExistsRequest request = new ExistsRequest();    request.setPath(path);    request.setWatch(false);    ExistsResponse response = new ExistsResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals(r.getErr(), Code.UNIMPLEMENTED.intValue());        assertTrue("failed to disconnect", clientDisconnected.await(5000, TimeUnit.MILLISECONDS));    zk.close();}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        clientDisconnected.countDown();    }}
0
public void testTryWithResources() throws Exception
{    ZooKeeper zooKeeper;    try (ZooKeeper zk = createClient()) {        zooKeeper = zk;        assertTrue(zooKeeper.getState().isAlive());    }    assertFalse(zooKeeper.getState().isAlive());}
0
public void testCXidRollover() throws Exception
{    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.setXid(Integer.MAX_VALUE - 10);        zk.create("/testnode", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < 20; ++i) {            final CountDownLatch latch = new CountDownLatch(1);            final AtomicInteger rc = new AtomicInteger(0);            zk.setData("/testnode", "".getBytes(), -1, new AsyncCallback.StatCallback() {                @Override                public void processResult(int retcode, String path, Object ctx, Stat stat) {                    rc.set(retcode);                    latch.countDown();                }            }, null);            assertTrue("setData should complete within 5s", latch.await(zk.getSessionTimeout(), TimeUnit.MILLISECONDS));            assertEquals("setData should have succeeded", Code.OK.intValue(), rc.get());        }        zk.delete("/testnode", -1);        assertTrue("xid should be positive", zk.checkXid() > 0);    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void processResult(int retcode, String path, Object ctx, Stat stat)
{    rc.set(retcode);    latch.countDown();}
0
public void testSingleServerChrootPath()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
0
public void testMultipleServersChrootPath()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1,10.10.10.2";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]:2181,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
0
public void testParseServersWithoutPort()
{    String servers = "10.10.10.1,10.10.10.2";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2],[2001:db8:85a3:8d3:1319:8a2e:370:7348]";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());}
0
public void testParseServersWithPort()
{    String servers = "10.10.10.1:112,10.10.10.2:110";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(112, parser.getServerAddresses().get(0).getPort());    assertEquals(110, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2]:1234,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(1234, parser.getServerAddresses().get(0).getPort());    assertEquals(5678, parser.getServerAddresses().get(1).getPort());}
0
private void assertChrootPath(String expected, ConnectStringParser parser)
{    assertEquals(expected, parser.getChrootPath());}
0
public void testBasicCreateMode()
{    CreateMode cm = CreateMode.PERSISTENT;    assertEquals(cm.toFlag(), 0);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL;    assertEquals(cm.toFlag(), 1);    assertTrue(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.PERSISTENT_SEQUENTIAL;    assertEquals(cm.toFlag(), 2);    assertFalse(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL_SEQUENTIAL;    assertEquals(cm.toFlag(), 3);    assertTrue(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.CONTAINER;    assertEquals(cm.toFlag(), 4);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertTrue(cm.isContainer());}
0
public void testFlagConversion() throws KeeperException
{        EnumSet<CreateMode> allModes = EnumSet.allOf(CreateMode.class);    for (CreateMode cm : allModes) {        assertEquals(cm, CreateMode.fromFlag(cm.toFlag()));    }}
0
public void testInvalidFlagConversion() throws KeeperException
{    try {        CreateMode.fromFlag(99);        fail("Shouldn't be able to convert 99 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }    try {        CreateMode.fromFlag(-1);        fail("Shouldn't be able to convert -1 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
public void testCreate() throws IOException, KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
0
public void testCreateWithStat() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
0
public void testCreateWithNullStat() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            String path = zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
0
private void createNoStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(path, newName);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
0
private Stat createWithStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertEquals(path, newName);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
0
private void validateCreateStat(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void disconnect() throws IOException
{    cnxn.disconnect();}
0
public void dontReconnect() throws Exception
{    java.lang.reflect.Field f = cnxn.getClass().getDeclaredField("closing");    f.setAccessible(true);    f.setBoolean(cnxn, true);}
0
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
1
public void setUp() throws Exception
{    super.setUp();    watcher1 = new CountdownWatcher();    zk1 = createClient(watcher1);    watcher2 = new MyWatcher();}
0
public void tearDown() throws Exception
{    if (zk2 != null) {        zk2.close();    }    if (zk1 != null) {        zk1.close();    }    super.tearDown();}
0
public void testChildWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
0
public void testDefaultWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    zk2.getChildren("/", true);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
0
public void testDeepChildWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we/are", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1/here/we");    zk2.getChildren("/are", true);        zk1.create("/ch1/here/we/are/now", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/are", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/here/we/are/again", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());}
0
public void testManyChildWatchersAutoReset() throws Exception
{    zk2 = createClient(watcher2);        String pathBase = "/long-path-000000000-111111111-222222222-333333333-444444444-" + "555555555-666666666-777777777-888888888-999999999";    zk1.create(pathBase, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            List<String> paths = new ArrayList<String>();    for (int i = 0; i < 10000; i++) {        String path = zk1.create(pathBase + "/ch-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        paths.add(path);    }        MyWatcher childWatcher = new MyWatcher();        int i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk2.getChildren(path, childWatcher);        } else if (i % 3 == 1) {            zk2.exists(path + "/foo", childWatcher);        } else if (i % 3 == 2) {            zk2.getData(path, childWatcher, null);        }        i++;    }    stopServer();    watcher2.waitForDisconnected(30000);    startServer();    watcher2.waitForConnected(30000);    watcher1.waitForConnected(30000);        i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk1.create(path + "/ch", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeChildrenChanged, e.getType());            assertEquals(path, e.getPath());        } else if (i % 3 == 1) {            zk1.create(path + "/foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeCreated, e.getType());            assertEquals(path + "/foo", e.getPath());        } else if (i % 3 == 2) {            zk1.setData(path, new byte[] { 1, 2, 3 }, -1);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeDataChanged, e.getType());            assertEquals(path, e.getPath());        }        i++;    }}
1
public void setUp() throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
1
public void tearDown() throws Exception
{        qb.tearDown();}
1
public void testLocalSessionUpgradeOnFollower() throws Exception
{    testLocalSessionUpgrade(false);}
0
public void testLocalSessionUpgradeOnLeader() throws Exception
{    testLocalSessionUpgrade(true);}
0
private void testLocalSessionUpgrade(boolean testLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    final String firstPath = "/first";    final String secondPath = "/ephemeral";        zk.create(firstPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.create(secondPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat firstStat = zk.exists(firstPath, null);    assertNotNull(firstStat);    Stat secondStat = zk.exists(secondPath, null);    assertNotNull(secondStat);    long zxidDiff = secondStat.getCzxid() - firstStat.getCzxid();                assertEquals(2L, zxidDiff);}
0
public void runTest(boolean leaveEmptyFile, boolean trustEmptySnap) throws Exception
{    File tmpSnapDir = ClientBase.createTmpDir();    File tmpLogDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    SyncRequestProcessor.setSnapCount(SNAP_COUNT);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);    try {        for (int i = 0; i < N_TRANSACTIONS; i++) {            zk.create("/node-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    zks.startdata();    long zxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        assertTrue("zxid > 0", zxid > 0);    zks.shutdown();        FileTxnSnapLog txnLogFactory = zks.getTxnLogFactory();    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);    assertTrue("We have a snapshot to corrupt", snapshots.size() > 0);    for (File file : snapshots) {        if (leaveEmptyFile) {            new PrintWriter(file).close();        } else {            file.delete();        }    }    if (trustEmptySnap) {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, "true");    }        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    try {        zks.startdata();        zxid = zks.getZKDatabase().loadDataBase();        if (!trustEmptySnap) {            fail("Should have gotten exception for corrupted database");        }    } catch (IOException e) {                if (trustEmptySnap) {            fail("Should not get exception for empty database");        }    } finally {        if (trustEmptySnap) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);        }    }    zks.shutdown();}
1
public void testRestoreWithEmptySnapFiles() throws Exception
{    runTest(true, false);}
0
public void testRestoreWithNoSnapFiles() throws Exception
{    runTest(false, false);}
0
public void testRestoreWithTrustedEmptySnapFiles() throws Exception
{    runTest(false, true);}
0
public void process(WatchedEvent event)
{}
0
public void setUp() throws Exception
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    super.setUp();}
0
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    ProviderRegistry.removeProvider("ensemble");}
0
public void noAuth() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble(null);}
0
public void emptyAuth() throws Exception
{    resetEnsembleAuth(null, true);    connectToEnsemble("foo");}
0
public void skipAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble(null);}
0
public void passAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("woo");}
0
public void passAuthCSV() throws Exception
{    resetEnsembleAuth(" foo,bar, baz ", true);    connectToEnsemble("foo");    connectToEnsemble("bar");    connectToEnsemble("baz");}
0
public void failAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("goo");}
0
public void removeEnsembleAuthProvider() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble("goo");}
0
private void connectToEnsemble(final String auth) throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {                if (auth != null) {            zk.addAuthInfo("ensemble", auth.getBytes());        }        zk.getData("/", false, null);    }}
0
private void resetEnsembleAuth(final String auth, final boolean useAuth) throws Exception
{    stopServer();    if (auth == null) {        System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    } else {        System.setProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY, auth);    }    if (useAuth) {        System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    } else {        System.clearProperty("zookeeper.authProvider.1");    }    ProviderRegistry.removeProvider("ensemble");    ProviderRegistry.initialize();    startServer();}
0
public void testIntConversion()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    for (EventType et : allTypes) {        assertEquals(et, EventType.fromInt(et.getIntValue()));    }}
0
public void testInvalidIntConversion()
{    try {        EventType.fromInt(324242);        fail("Was able to create an invalid EventType via an integer");    } catch (RuntimeException re) {        }}
0
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    tmpdir = new File[count];    port = new int[count];    round = new int[3];    round[0] = 0;    round[1] = 0;    round[2] = 0;    start0 = new Semaphore(0);    finish0 = new Semaphore(0);    finish3 = new Semaphore(0);}
0
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        threads.get(i).peer.getElectionAlg().shutdown();    }}
0
public void run()
{    boolean flag = true;    try {        while (flag) {            Vote v = null;            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                fail("Thread " + i + " got a null vote");            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        switch(i) {                case 0:                                        if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {                                                                        flag = false;                    }                    break;                case 1:                                        if (round[1] != 0) {                        finish0.release();                        flag = false;                    } else {                        finish3.acquire();                        start0.release();                    }                                        round[1]++;                    break;                case 2:                                        QuorumBase.shutdown(peer);                    flag = false;                    round[2] = 1;                    finish3.release();                                        break;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
1
public void testLENewEpoch() throws Exception
{        for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 1; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }    if (!start0.tryAcquire(4000, java.util.concurrent.TimeUnit.MILLISECONDS)) {        fail("First leader election failed");    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    LEThread thread = new LEThread(peer, 0);    thread.start();    threads.add(thread);        for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(10000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
1
 boolean predicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    return this.totalOrderPredicate(newId, newZxid, newEpoch, curId, curZxid, curEpoch);}
0
public void testPredicate() throws IOException
{    peers = new HashMap<Long, QuorumServer>(3);    /*         * Creates list of peers.         */    for (int i = 0; i < 3; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    /*         * Creating peer.         */    try {        File tmpDir = ClientBase.createTmpDir();        QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir, PortAssignment.unique(), 3, 0, 1000, 2, 2, 2);        MockFLE mock = new MockFLE(peer);        mock.start();        /*             * Lower epoch must return false             */        assertFalse(mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));        /*             * Later epoch             */        assertTrue(mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));        /*             * Higher zxid             */        assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));        /*             * Higher id             */        assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));    } catch (IOException e) {                fail("Exception while creating quorum peer");    }}
1
 int countVotes(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
0
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    restartThreads = new ArrayList<FLERestartThread>(count);    tmpdir = new File[count];    port = new int[count];    finish = new Semaphore(0);}
0
public void tearDown() throws Exception
{    for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).peer.getElectionAlg().shutdown();    }}
0
public void run()
{    try {        Vote v = null;        while (true) {            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                break;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        switch(i) {                case 0:                    if (peerRound == 0) {                                                QuorumBase.shutdown(peer);                        restartThreads.get(i).peer.getElectionAlg().shutdown();                        peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);                        peer.startLeaderElection();                        peerRound++;                    } else {                        finish.release(2);                        return;                    }                    break;                case 1:                                        finish.acquire();                                                            return;                case 2:                                        finish.acquire();                                                            return;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
1
public void testLERestart() throws Exception
{        for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        FLERestartThread thread = new FLERestartThread(peer, i);        thread.start();        restartThreads.add(thread);    }        for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).join(10000);        if (restartThreads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
1
 int countVotes(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
0
public void setUp() throws Exception
{    count = 7;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    voteMap = new HashMap<Integer, HashSet<TestVote>>();    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    successCount = 0;    joinedThreads = new HashSet<Long>();}
0
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        leThread = threads.get(i);        QuorumBase.shutdown(leThread.peer);    }}
0
public void run()
{    try {        Vote v = null;        while (true) {            /*                     * Set the state of the peer to LOOKING and look for leader                     */            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                break;            }            /*                     * Done with the election round, so now we set the vote in                     * the peer. A real zookeeper would take care of setting the                     * current vote. Here we do it manually.                     */            peer.setCurrentVote(v);                        votes[i] = v;            /*                     * Get the current value of the logical clock for this peer                     * so that we know in which round this peer has executed.                     */            int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();            /*                     * The leader executes the following block, which essentially shuts down                     * the peer if it is not the last round.                     */            if (v.getId() == i) {                                if (lc < this.totalRounds) {                                        FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();                    election.shutdown();                                        assertEquals(-1, election.getVote().getId());                                        break;                }            }            /*                     * If the peer has done enough rounds, then consider joining. The thread                     * will only join if it is part of a quorum supporting the current                     * leader. Otherwise it will try again.                     */            if (lc >= this.totalRounds) {                /*                         * quora keeps the supporters of a given leader, so                         * we first update it with the vote of this peer.                         */                if (quora.get(v.getId()) == null) {                    quora.put(v.getId(), new HashSet<Integer>());                }                quora.get(v.getId()).add(i);                /*                         * we now wait until a quorum supports the same leader.                         */                if (waitForQuorum(v.getId())) {                    synchronized (self) {                        /*                                 * Assert that the state of the thread is the one expected.                                 */                        if (v.getId() == i) {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.LEADING);                            leader = i;                        } else {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.FOLLOWING);                        }                        /*                                 * Global variable keeping track of                                 * how many peers have successfully                                 * joined.                                 */                        successCount++;                        joinedThreads.add((long) i);                        self.notify();                    }                    /*                             * I'm done so joining.                             */                    break;                } else {                    quora.get(v.getId()).remove(i);                }            }            /*                     * This sleep time represents the time a follower                     * would take to declare the leader dead and start                     * a new leader election.                     */            Thread.sleep(100);        }            } catch (InterruptedException e) {        fail(e.toString());    }}
1
 boolean waitForQuorum(long id) throws InterruptedException
{    int loopCounter = 0;    while ((quora.get(id).size() <= count / 2) && (loopCounter < MAX_LOOP_COUNTER)) {        Thread.sleep(100);        loopCounter++;    }    return (loopCounter < MAX_LOOP_COUNTER) || (quora.get(id).size() > count / 2);}
0
public void testSingleElection() throws Exception
{    try {        runElection(1);    } catch (Exception e) {        fail(e.toString());    }}
0
public void testDoubleElection() throws Exception
{    try {        runElection(2);    } catch (Exception e) {        fail(e.toString());    }}
0
public void testTripleElection() throws Exception
{    try {        runElection(3);    } catch (Exception e) {        fail(e.toString());    }}
0
private void runElection(int rounds) throws Exception
{    ConcurrentHashMap<Long, HashSet<Integer>> quora = new ConcurrentHashMap<Long, HashSet<Integer>>();        /*         * Creates list of peers.         */    for (int i = 0; i < count; i++) {        port[i] = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[i])));        tmpdir[i] = ClientBase.createTmpDir();    }    /*         * Start one LEThread for each peer we want to run.         */    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(this, peer, i, rounds, quora);        thread.start();        threads.add(thread);    }        int waitCounter = 0;    synchronized (this) {        while (((successCount <= count / 2) || (leader == -1)) && (waitCounter < MAX_LOOP_COUNTER)) {            this.wait(200);            waitCounter++;        }    }        /*         * Lists what threads haven't joined. A thread doesn't join if         * it hasn't decided upon a leader yet. It can happen that a         * peer is slow or disconnected, and it can take longer to         * nominate and connect to the current leader.         */    for (int i = 0; i < threads.size(); i++) {        if (threads.get(i).isAlive()) {                    }    }    /*         * If we have a majority, then we are good to go.         */    if (successCount <= count / 2) {        fail("Fewer than a a majority has joined");    }    /*         * I'm done so joining.         */    if (!joinedThreads.contains(leader)) {        fail("Leader hasn't joined: " + leader);    }}
1
public void run()
{    setName("VerifyState-" + peer.getId());    while (true) {        if (peer.getPeerState() == ServerState.FOLLOWING) {                        success = true;            break;        } else if (peer.getPeerState() == ServerState.LEADING) {                        success = false;            break;        }        try {            Thread.sleep(250);        } catch (Exception e) {                    }    }}
1
public boolean isSuccess()
{    return success;}
0
public void testJoin() throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        port[sid] = PortAssignment.unique();        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[sid])));        tmpdir[sid] = ClientBase.createTmpDir();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);                peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);        peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    } else if (!v1.isSuccess()) {        fail("Incorrect LEADING state for peer " + peer.getId());    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
1
public void testJoinInconsistentEnsemble() throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[sid] = ClientBase.createTmpDir();        port[sid] = PortAssignment.unique();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);                peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        long leaderSid = peer.getCurrentVote().getId();    long zxid = peer.getCurrentVote().getZxid();    long electionEpoch = peer.getCurrentVote().getElectionEpoch();    ServerState state = peer.getCurrentVote().getState();    long peerEpoch = peer.getCurrentVote().getPeerEpoch();    Vote newVote = new Vote(leaderSid, zxid + 100, electionEpoch + 100, peerEpoch, state);    peer.setCurrentVote(newVote);        peer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 2000, 2, 2, 2);        peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
1
public void testElectionTimeUnit() throws Exception
{    assertEquals("MS", QuorumPeer.FLE_TIME_UNIT);}
0
public void setUp() throws Exception
{    count = 9;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    String config = "group.1=0:1:2\n" + "group.2=3:4:5\n" + "group.3=6:7:8\n" + "weight.0=1\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=0\n" + "weight.4=0\n" + "weight.5=0\n" + "weight.6=0\n" + "weight.7=0\n" + "weight.8=0";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);}
0
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        LEThread leThread = threads.get(i);                                QuorumBase.shutdown(leThread.peer);    }}
0
public void run()
{    try {        Vote v = null;        fail = false;        while (true) {                        peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                return;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        votes[i] = v;            if ((peer.getPeerState() == ServerState.LEADING) && (peer.getId() > 2)) {                fail = true;            }            if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {                break;            }        }            } catch (InterruptedException e) {        e.printStackTrace();    }}
1
public void testZeroWeightQuorum() throws Exception
{        for (int i = 0; i < count; i++) {        InetSocketAddress addr1 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr2 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr3 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        port[i] = addr3.getPort();        qp.setProperty("server." + i, "127.0.0.1:" + addr1.getPort() + ":" + addr2.getPort() + ";" + port[i]);        peers.put(Long.valueOf(i), new QuorumServer(i, addr1, addr2, addr3));        tmpdir[i] = ClientBase.createTmpDir();    }    for (int i = 0; i < count; i++) {        QuorumHierarchical hq = new QuorumHierarchical(qp);        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2, hq);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }        for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(15000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        } else {            if (threads.get(i).fail) {                fail("Elected zero-weight server");            }        }    }}
1
public void setUp() throws Exception
{    pending.set(0);    errors.set(0);    counter.set(0);}
0
public void tearDown() throws Exception
{    }
1
public void testLaggingFollowerResyncsUnderNewEpoch() throws Exception
{    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    QuorumUtil qu = new QuorumUtil(1);    qu.shutdownAll();    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    ZooKeeper zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);        final String resyncPath = "/resyncundernewepoch";    zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.close();    qu.shutdown(1);    qu.shutdown(2);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(3);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT));    zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);        assertNotNull("zk1 has data", zk1.exists(resyncPath, false));    final ZooKeeper zk2 = createClient(qu.getPeer(2).peer.getClientPort(), watcher2);        assertNotNull("zk2 has data", zk2.exists(resyncPath, false));    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        assertNotNull("zk3 has data", zk3.exists(resyncPath, false));    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
1
public void testResyncBySnapThenDiffAfterFollowerCrashes() throws Throwable
{    followerResyncCrashTest(false);}
0
public void testResyncByTxnlogThenDiffAfterFollowerCrashes() throws Throwable
{    followerResyncCrashTest(true);}
0
public void followerResyncCrashTest(boolean useTxnLogResync) throws Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    if (useTxnLogResync) {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(1000);    } else {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(-1);    }    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;        qu.shutdown(index);    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    qu.restart(index);    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);        final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);        zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            for (int i = 0; i < 3000; i++) {                                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                    @Override                    public void processResult(int rc, String path, Object ctx, String name) {                        pending.decrementAndGet();                        counter.incrementAndGet();                        if (rc != 0) {                            errors.incrementAndGet();                        }                        if (counter.get() == 16200) {                            sem.release();                        }                    }                }, null);                pending.incrementAndGet();                if (i % 10 == 0) {                    try {                        Thread.sleep(100);                    } catch (Exception e) {                    }                }            }        }    });        for (int i = 0; i < 13000; i++) {                zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 5000) {            qu.shutdown(index);                    }        if (i == 12000) {                                                            mytestfooThread.start();                        qu.restart(index);            Thread.sleep(300);                        qu.shutdown(index);            Thread.sleep(300);                        qu.restart(index);                    }        if ((i % 1000) == 0) {            Thread.sleep(1000);        }        if (i % 50 == 0) {            zk2.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() == 16200) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {            }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));    verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
1
public void run()
{    for (int i = 0; i < 3000; i++) {                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i % 10 == 0) {            try {                Thread.sleep(100);            } catch (Exception e) {            }        }    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
0
public void testResyncByDiffAfterFollowerCrashes() throws IOException, InterruptedException, KeeperException, Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;        final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);        final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);        final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    final AtomicBoolean runNow = new AtomicBoolean(false);    Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            int inSyncCounter = 0;            while (inSyncCounter < 400) {                if (runNow.get()) {                    zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                        @Override                        public void processResult(int rc, String path, Object ctx, String name) {                            pending.decrementAndGet();                            counter.incrementAndGet();                            if (rc != 0) {                                errors.incrementAndGet();                            }                            if (counter.get() > 7300) {                                sem.release();                            }                        }                    }, null);                    pending.incrementAndGet();                    try {                        Thread.sleep(10);                    } catch (Exception e) {                    }                    inSyncCounter++;                } else {                    Thread.yield();                }            }        }    });    mytestfooThread.start();    for (int i = 0; i < 5000; i++) {        zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() > 7300) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 1000) {            qu.shutdown(index);            Thread.sleep(1100);                    }        if (i == 1100 || i == 1150 || i == 1200) {            Thread.sleep(1000);        }        if (i == 1200) {            qu.startThenShutdown(index);            runNow.set(true);            qu.restart(index);                    }        if (i >= 1000 && i % 2 == 0) {            zk3.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }        if (i == 1050 || i == 1100 || i == 1150) {            Thread.sleep(1000);        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {            }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));        verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
1
public void run()
{    int inSyncCounter = 0;    while (inSyncCounter < 400) {        if (runNow.get()) {            zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();            try {                Thread.sleep(10);            } catch (Exception e) {            }            inSyncCounter++;        } else {            Thread.yield();        }    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
0
private static DisconnectableZooKeeper createClient(int port, CountdownWatcher watcher) throws IOException, TimeoutException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper("127.0.0.1:" + port, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
0
private boolean waitForPendingRequests(int timeout) throws InterruptedException
{        for (int i = 0; i < timeout; ++i) {        Thread.sleep(1000);        if (pending.get() == 0) {            return true;        }    }        return false;}
1
private boolean waitForSync(QuorumUtil qu, int index, int timeout) throws InterruptedException
{        int leaderIndex = (index == 1) ? 2 : 1;    ZKDatabase restartedDb = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase cleanDb = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase leadDb = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    long leadZxid = 0;    long cleanZxid = 0;    long restartedZxid = 0;    for (int i = 0; i < timeout; ++i) {        leadZxid = leadDb.getDataTreeLastProcessedZxid();        cleanZxid = cleanDb.getDataTreeLastProcessedZxid();        restartedZxid = restartedDb.getDataTreeLastProcessedZxid();        if (leadZxid == cleanZxid && leadZxid == restartedZxid) {            return true;        }        Thread.sleep(1000);    }        return false;}
1
private static TestableZooKeeper createTestableClient(String hp) throws IOException, TimeoutException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createTestableClient(watcher, hp);}
0
private static TestableZooKeeper createTestableClient(CountdownWatcher watcher, String hp) throws IOException, TimeoutException, InterruptedException
{    TestableZooKeeper zk = new TestableZooKeeper(hp, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
0
private void verifyState(QuorumUtil qu, int index, Leader leader)
{        assertTrue("Not following", qu.getPeer(index).peer.follower != null);    long epochF = (qu.getPeer(index).peer.getActiveServer().getZxid() >> 32L);    long epochL = (leader.getEpoch() >> 32L);    assertTrue("Zxid: " + qu.getPeer(index).peer.getActiveServer().getZKDatabase().getDataTreeLastProcessedZxid() + "Current epoch: " + epochF, epochF == epochL);    int leaderIndex = (index == 1) ? 2 : 1;    Collection<Long> sessionsRestarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase().getSessions();    Collection<Long> sessionsNotRestarted = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase().getSessions();    for (Long l : sessionsRestarted) {        assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));    }    assertEquals("Should have same number of sessions", sessionsNotRestarted.size(), sessionsRestarted.size());    ZKDatabase restarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase clean = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    for (Long l : sessionsRestarted) {                assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));        Set<String> ephemerals = restarted.getEphemerals(l);        Set<String> cleanEphemerals = clean.getEphemerals(l);        for (String o : cleanEphemerals) {            if (!ephemerals.contains(o)) {                            }        }        for (String o : ephemerals) {            if (!cleanEphemerals.contains(o)) {                            }        }        Set<String> leadEphemerals = lead.getEphemerals(l);        for (String o : leadEphemerals) {            if (!cleanEphemerals.contains(o)) {                            }        }        for (String o : cleanEphemerals) {            if (!leadEphemerals.contains(o)) {                            }        }        assertEquals("Should have same number of ephemerals in both followers", ephemerals.size(), cleanEphemerals.size());        assertEquals("Leader should equal follower", lead.getEphemerals(l).size(), cleanEphemerals.size());    }}
1
public void testFollowerSendsLastZxid() throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }        TestableZooKeeper zk = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    assertEquals(0L, zk.testableLastZxid());    zk.exists("/", false);    long lzxid = zk.testableLastZxid();    assertTrue("lzxid:" + lzxid + " > 0", lzxid > 0);    zk.close();    qu.shutdownAll();}
1
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
1
public void testFollowerWatcherResync() throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }        TestableZooKeeper zk1 = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    zk1.create("/foo", "foo".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher watcher = new MyWatcher();    TestableZooKeeper zk2 = createTestableClient(watcher, "localhost:" + qu.getPeer(index).peer.getClientPort());    zk2.exists("/foo", true);    watcher.reset();    zk2.testableConnloss();    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    assertArrayEquals("foo".getBytes(), zk2.getData("/foo", false, null));    assertNull(watcher.events.poll(5, TimeUnit.SECONDS));    zk1.close();    zk2.close();    qu.shutdownAll();}
1
public void testFourLetterWords() throws Exception
{    String[] servers = hostPort.split(",");    for (String hp : servers) {        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watches");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        TestableZooKeeper zk = createClient(hp);        String sid = getHexSessionId(zk.getSessionId());        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "dirs", "size");        zk.getData("/", true, null);        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "wchs", "watching 1");        verify(hp, "wchp", sid);        verify(hp, "wchc", sid);        verify(hp, "dirs", "size");        zk.close();        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watch");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "dirs", "size");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "mntr", "zk_version\t");    }}
0
private void verify(String hp, String cmd, String expected) throws IOException, SSLContextException
{    for (HostPort hpobj : parseHostPortList(hp)) {        String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);                if (cmd.equals("dump")) {            assertTrue(resp.contains(expected) || resp.contains("Sessions with Ephemerals"));        } else {            assertTrue(resp.contains(expected));        }    }}
1
public void testFourLetterWords() throws Exception
{    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watches");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("gtmk", "306");    verify("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("dirs", "size");    zk.getData("/", true, null);    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("wchs", "watching 1");    verify("wchp", sid);    verify("wchc", sid);    verify("dirs", "size");    zk.close();    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watch");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("mntr", "zk_server_state\tstandalone");    verify("mntr", "num_alive_connections");    verify("stat", "Connections");    verify("srvr", "Connections");    verify("dirs", "size");}
0
private String sendRequest(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
0
private String sendRequest(String cmd, int timeout) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, false, timeout);}
0
private void verify(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue(resp.contains(expected));}
1
public void testValidateStatOutput() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("stat");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;        line = in.readLine();    assertTrue(Pattern.matches("^.*\\s\\d+\\.\\d+\\.\\d+-.*$", line));    assertTrue(Pattern.matches("^Clients:$", in.readLine()));    int count = 0;    while ((line = in.readLine()).length() > 0) {        count++;        assertTrue(Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+\\)$", line));    }        assertTrue(count >= 2);    line = in.readLine();    assertTrue(Pattern.matches("^Latency min/avg/max: \\d+/-?[0-9]*.?[0-9]*/\\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Received: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Sent: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Connections: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Outstanding: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Zxid: 0x[\\da-fA-F]+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Mode: .*$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Node count: \\d+$", line));    zk1.close();    zk2.close();}
0
public void testValidateConsOutput() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("cons");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;    int count = 0;    while ((line = in.readLine()) != null && line.length() > 0) {        count++;        assertTrue(line, Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+.*\\)$", line));    }        assertTrue(count >= 2);    zk1.close();    zk2.close();}
0
public void testValidateSocketTimeout() throws Exception
{    /**     * testing positive scenario that even with timeout parameter the     * functionality works fine     */    String resp = sendRequest("isro", 2000);    assertTrue(resp.contains("rw"));}
0
public void testSetTraceMask() throws Exception
{    String gtmkResp = sendRequest("gtmk");    assertNotNull(gtmkResp);    gtmkResp = gtmkResp.trim();    assertFalse(gtmkResp.isEmpty());    long formerMask = Long.valueOf(gtmkResp);    try {        verify(buildSetTraceMaskRequest(0), "0");        verify("gtmk", "0");    } finally {                sendRequest(buildSetTraceMaskRequest(formerMask));    }}
0
private String buildSetTraceMaskRequest(long mask) throws IOException
{    ByteArrayOutputStream baos = null;    DataOutputStream dos = null;    try {        baos = new ByteArrayOutputStream();        dos = new DataOutputStream(baos);        dos.writeBytes("stmk");        dos.writeLong(mask);    } finally {        IOUtils.closeStream(dos);        IOUtils.closeStream(baos);    }    return new String(baos.toByteArray());}
0
public void testFourLetterWordsAllDisabledByDefault() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    startServer();        verifyAllCommandsFail();    TestableZooKeeper zk = createClient();    verifyAllCommandsFail();    zk.getData("/", true, null);    verifyAllCommandsFail();    zk.close();    verifyFuzzyMatch("stat", "Outstanding");    verifyAllCommandsFail();}
0
public void testFourLetterWordsEnableSomeCommands() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat, ruok, isro");    startServer();        verifyFuzzyMatch("stat", "Outstanding");    verifyExactMatch("ruok", "imok");    verifyExactMatch("isro", "rw");        verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));}
0
public void testISROEnabledWhenReadOnlyModeEnabled() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    System.setProperty("readonlymode.enabled", "true");    startServer();    verifyExactMatch("isro", "rw");    System.clearProperty("readonlymode.enabled");}
0
public void testFourLetterWordsInvalidConfiguration() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "foo bar" + " foo,,, " + "bar :.,@#$%^&*() , , , , bar, bar, stat,        ");    startServer();        verifyAllCommandsFail();        verifyFuzzyMatch("stat", "Outstanding");}
0
public void testFourLetterWordsEnableAllCommandsThroughAsterisk() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "*");    startServer();    verifyAllCommandsSuccess();}
0
public void testFourLetterWordsEnableAllCommandsThroughExplicitList() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "ruok, envi, conf, stat, srvr, cons, dump," + "wchs, wchp, wchc, srst, crst, " + "dirs, mntr, gtmk, isro, stmk");    startServer();    verifyAllCommandsSuccess();}
0
private void verifyAllCommandsSuccess() throws Exception
{    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watches");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("gtmk", "306");    verifyFuzzyMatch("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("dirs", "size");    zk.getData("/", true, null);    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("wchs", "watching 1");    verifyFuzzyMatch("wchp", sid);    verifyFuzzyMatch("wchc", sid);    verifyFuzzyMatch("dirs", "size");    zk.close();    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watch");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("mntr", "zk_server_state\tstandalone");    verifyFuzzyMatch("mntr", "num_alive_connections");    verifyFuzzyMatch("stat", "Connections");    verifyFuzzyMatch("srvr", "Connections");    verifyFuzzyMatch("dirs", "size");}
0
private void verifyAllCommandsFail() throws Exception
{    verifyExactMatch("ruok", generateExpectedMessage("ruok"));    verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));    verifyExactMatch("isro", generateExpectedMessage("isro"));        verifyFuzzyMatch("srvr", "Outstanding");}
0
private String sendRequest(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
0
private void verifyFuzzyMatch(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue(resp.contains(expected));}
1
private String generateExpectedMessage(String command)
{    return command + " is not executed because it is not in the whitelist.";}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
public void testChild() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat = new Stat();    List<String> s = zk.getChildren(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());    s = zk.getChildren(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());}
0
public void testChildren() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = new ArrayList<String>();    List<String> children_s = new ArrayList<String>();    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        String childname_s = "bar" + i;        children.add(childname);        children_s.add(childname_s);    }    for (int i = 0; i < children.size(); i++) {        String childname = children.get(i);        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat = new Stat();        List<String> s = zk.getChildren(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());        assertEquals(s.size(), stat.getNumChildren());    }    List<String> p = zk.getChildren(name, false, null);    List<String> c_a = children_s;    List<String> c_b = p;    Collections.sort(c_a);    Collections.sort(c_b);    assertEquals(c_a.size(), 10);    assertEquals(c_a, c_b);}
0
public void testGetProposalFromTxn() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        Long[] zxids = new Long[MSG_COUNT];    try {        String data = "data";        byte[] bytes = data.getBytes();        for (int i = 0; i < MSG_COUNT; i++) {            Stat stat = new Stat();            zk.create("/invalidsnap-" + i, bytes, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/invalidsnap-" + i, null, stat);            zxids[i] = stat.getCzxid();        }    } finally {        zk.close();    }        f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();            Iterator<Proposal> itr = db.getProposalsFromTxnLog(zxids[0], 10000000);    int createCount = 0;    ArrayList<Long> retrievedZxids = new ArrayList<Long>(MSG_COUNT);        while (itr.hasNext()) {        Proposal proposal = itr.next();        TxnHeader hdr = new TxnHeader();        Record rec = SerializeUtils.deserializeTxn(proposal.packet.getData(), hdr);        if (hdr.getType() == OpCode.create) {            retrievedZxids.add(hdr.getZxid());            createCount++;        }    }        assertTrue("Zxids missmatches", Arrays.equals(zxids, retrievedZxids.toArray(new Long[0])));        assertTrue("create proposal count == " + MSG_COUNT, (createCount == MSG_COUNT));            db.setSnapshotSizeFactor(0.33);    long sizeLimit = db.calculateTxnLogSizeLimit();    itr = db.getProposalsFromTxnLog(zxids[MSG_COUNT / 2], sizeLimit);    assertFalse("Expect empty proposal", (itr.hasNext()));    f.shutdown();    zks.shutdown();}
0
public void setUp() throws Exception
{    setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    leport1 = PortAssignment.unique();    leport2 = PortAssignment.unique();    leport3 = PortAssignment.unique();    leport4 = PortAssignment.unique();    leport5 = PortAssignment.unique();    clientport1 = PortAssignment.unique();    clientport2 = PortAssignment.unique();    clientport3 = PortAssignment.unique();    clientport4 = PortAssignment.unique();    clientport5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + clientport1 + ",127.0.0.1:" + clientport2 + ",127.0.0.1:" + clientport3 + ",127.0.0.1:" + clientport4 + ",127.0.0.1:" + clientport5;        s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    String config = "group.1=1:2:3\n" + "group.2=4:5\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=1\n" + "weight.4=0\n" + "weight.5=0\n" + "server.1=127.0.0.1:" + port1 + ":" + leport1 + ";" + clientport1 + "\n" + "server.2=127.0.0.1:" + port2 + ":" + leport2 + ";" + clientport2 + "\n" + "server.3=127.0.0.1:" + port3 + ":" + leport3 + ";" + clientport3 + "\n" + "server.4=127.0.0.1:" + port4 + ":" + leport4 + ";" + clientport4 + "\n" + "server.5=127.0.0.1:" + port5 + ":" + leport5 + ";" + clientport5 + "\n";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);    startServers();    cht.hostPort = hostPort;    cht.setUpAll();    }
1
 void startServers() throws Exception
{    startServers(false);}
0
 void startServers(boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    HashMap<Long, QuorumServer> peers = new HashMap<>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", port1), new InetSocketAddress("127.0.0.1", leport1), new InetSocketAddress("127.0.0.1", clientport1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", port2), new InetSocketAddress("127.0.0.1", leport2), new InetSocketAddress("127.0.0.1", clientport2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", port3), new InetSocketAddress("127.0.0.1", leport3), new InetSocketAddress("127.0.0.1", clientport3)));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress("127.0.0.1", port4), new InetSocketAddress("127.0.0.1", leport4), new InetSocketAddress("127.0.0.1", clientport4), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress("127.0.0.1", port5), new InetSocketAddress("127.0.0.1", leport5), new InetSocketAddress("127.0.0.1", clientport5), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));        if (withObservers) {        qp.setProperty("server.4", "127.0.0.1:" + port4 + ":" + leport4 + ":observer" + ";" + clientport4);        qp.setProperty("server.5", "127.0.0.1:" + port5 + ":" + leport5 + ":observer" + ";" + clientport5);    }    QuorumHierarchical hq1 = new QuorumHierarchical(qp);    s1 = new QuorumPeer(peers, s1dir, s1dir, clientport1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq1);    assertEquals(clientport1, s1.getClientPort());        QuorumHierarchical hq2 = new QuorumHierarchical(qp);    s2 = new QuorumPeer(peers, s2dir, s2dir, clientport2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq2);    assertEquals(clientport2, s2.getClientPort());        QuorumHierarchical hq3 = new QuorumHierarchical(qp);    s3 = new QuorumPeer(peers, s3dir, s3dir, clientport3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq3);    assertEquals(clientport3, s3.getClientPort());        QuorumHierarchical hq4 = new QuorumHierarchical(qp);    s4 = new QuorumPeer(peers, s4dir, s4dir, clientport4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq4);    if (withObservers) {        s4.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport4, s4.getClientPort());        QuorumHierarchical hq5 = new QuorumHierarchical(qp);    s5 = new QuorumPeer(peers, s5dir, s5dir, clientport5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq5);    if (withObservers) {        s5.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport5, s5.getClientPort());        s1.start();        s2.start();        s3.start();        s4.start();        s5.start();            for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));            }    final int numberOfPeers = 5;        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    for (int i = 1; i <= numberOfPeers; i++) {                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + i;        JMXEnv.ensureBeanAttribute(bean, "ConfigVersion");        JMXEnv.ensureBeanAttribute(bean, "LearnerType");        JMXEnv.ensureBeanAttribute(bean, "ClientAddress");        JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");        JMXEnv.ensureBeanAttribute(bean, "QuorumSystemInfo");        JMXEnv.ensureBeanAttribute(bean, "Leader");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            if (j != i) {                                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + j;                JMXEnv.ensureBeanAttribute(bean, "Name");                JMXEnv.ensureBeanAttribute(bean, "LearnerType");                JMXEnv.ensureBeanAttribute(bean, "ClientAddress");                JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");                JMXEnv.ensureBeanAttribute(bean, "QuorumAddress");                JMXEnv.ensureBeanAttribute(bean, "Leader");            }        }    }}
1
public void tearDown() throws Exception
{        cht.tearDownAll();        shutdown(s1);        shutdown(s2);        shutdown(s3);        shutdown(s4);        shutdown(s5);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }    JMXEnv.tearDown();}
1
protected void shutdown(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
0
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
0
public void testHierarchicalQuorum() throws Throwable
{    cht.runHammer(5, 10);}
0
 synchronized void incOutstanding()
{    outstanding++;}
0
 synchronized void decOutstanding()
{    outstanding--;    notifyAll();}
0
 synchronized void waitOutstanding() throws InterruptedException
{    while (outstanding > 0) {        wait();    }}
0
public void run() throws InterruptedException, KeeperException
{    try {                doCreate();                while (true) {                        doPopulate();            waitOutstanding();                        readAll();            waitOutstanding();        }    } finally {            }}
1
 void readAll()
{    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.getData(cpath, false, this, null);        incOutstanding();    }}
0
 void doCreate() throws InterruptedException, KeeperException
{        try {        zk.create(path, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {        }    iteration++;    byte[] v = ("" + iteration).getBytes();        for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        try {            if (i % 10 == 0) {                            }            zk.create(cpath, v, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException e) {                }        lastValue.put(cpath, v);    }}
1
 void doPopulate()
{    iteration++;    byte[] v = ("" + iteration).getBytes();    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.setData(cpath, v, -1, this, v);        incOutstanding();    }}
0
 synchronized void ensureConnected()
{    while (zk.getState() != ZooKeeper.States.CONNECTED) {        try {            wait();        } catch (InterruptedException e) {            return;        }    }}
0
public static void main(String[] args)
{    if (args.length < 3) {        System.err.println("USAGE: IntegrityCheck zookeeperHostPort znode #children");        return;    }    int childrenCount = 0;    try {        childrenCount = Integer.parseInt(args[2]);    } catch (NumberFormatException e) {        e.printStackTrace();        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    try {        final IntegrityCheck ctest = new IntegrityCheck(args[0], args[1], childrenCount);        Runtime.getRuntime().addShutdownHook(new Thread() {            public void run() {                System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);            }        });        while (true) {            try {                ctest.ensureConnected();                ctest.run();            } catch (Exception e) {                e.printStackTrace();            }        }    } catch (Exception e) {        e.printStackTrace();        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }}
0
public void run()
{    System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc == 0) {        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        String string = new String(data);        String lastString = null;        byte[] v = lastValue.get(path);        if (v != null) {            lastString = new String(v);        }        if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {                        errorCount++;        }        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
1
public void testLogFormatter() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File logfile = new File(new File(snapDir, "version-2"), "log.274");    String[] args = { logfile.getCanonicalFile().toString() };    org.apache.zookeeper.server.LogFormatter.main(args);}
0
public void testSnapshotFormatter() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.272");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
0
public void testSnapshotFormatterWithNull() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.273");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
0
public void testSnapshot() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    ZooKeeperServer zks = new ZooKeeperServer(snapDir, snapDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                        assertTrue(zk.exists("/9/9/8", false) != null);    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
1
public static void setUp() throws IOException
{    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();    JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://127.0.0.1");    cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);    cs.start();    JMXServiceURL addr = cs.getAddress();    cc = JMXConnectorFactory.connect(addr);}
0
public static void tearDown()
{    try {        if (cc != null) {            cc.close();        }    } catch (IOException e) {            }    cc = null;    try {        if (cs != null) {            cs.stop();        }    } catch (IOException e) {            }    cs = null;}
1
public static MBeanServerConnection conn() throws IOException
{    return cc.getMBeanServerConnection();}
0
public static Set<ObjectName> ensureAll(String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    Set<ObjectName> found;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found = new HashSet<ObjectName>();        for (String name : expectedNames) {                        for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                                        found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while ((expectedNames.length != found.size()) && (nTry < 600));    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
1
public static Set<ObjectName> ensureOnly(String... expectedNames) throws IOException, InterruptedException
{        Set<ObjectName> beans = ensureAll(expectedNames);    for (ObjectName bean : beans) {            }    assertEquals(0, beans.size());    return beans;}
1
public static void ensureNone(String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    int nTry = 0;    boolean foundUnexpected = false;    String unexpectedName = "";    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        foundUnexpected = false;        for (String name : expectedNames) {            for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                                        foundUnexpected = true;                    unexpectedName = name + " " + bean.toString();                    break;                }            }            if (foundUnexpected) {                break;            }        }    } while ((foundUnexpected) && (nTry < 600));    if (foundUnexpected) {                for (ObjectName bean : beans) {                    }        fail(unexpectedName);    }}
1
public static void dump() throws IOException
{        Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {            }}
1
public static Set<ObjectName> ensureParent(String... expectedNames) throws IOException, InterruptedException
{        Set<ObjectName> beans;    int nTry = 0;    Set<ObjectName> found = new HashSet<ObjectName>();    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found.clear();        for (String name : expectedNames) {                        for (ObjectName bean : beans) {                                if (compare(bean.toString(), name)) {                                        found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while (expectedNames.length != found.size() && nTry < 120);    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
1
public static Object ensureBeanAttribute(String expectedName, String expectedAttribute) throws Exception
{    String value = "";        Set<ObjectName> beans;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }                for (ObjectName bean : beans) {                        if (bean.toString().equals(expectedName)) {                                return conn().getAttribute(bean, expectedAttribute);            }        }    } while (nTry < 120);    fail("Failed to find bean:" + expectedName + ", attribute:" + expectedAttribute);    return value;}
1
private static boolean compare(String bean, String name)
{    String[] names = bean.split("=");    return names.length > 0 && names[names.length - 1].contains(name);}
0
public static List<ObjectName> getServerBeans() throws IOException
{    ArrayList<ObjectName> serverBeans = new ArrayList<>();    Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {        String name = bean.toString();                for (Pattern pattern : beanPatterns) {            if (pattern.matcher(name).find()) {                serverBeans.add(bean);            }        }    }    return serverBeans;}
1
public static ObjectName getServerBean() throws Exception
{    List<ObjectName> serverBeans = getServerBeans();    if (serverBeans.size() != 1) {        throw new RuntimeException("Unable to find one and only one server bean");    }    return serverBeans.get(0);}
0
public void testIntConversion()
{        EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    for (KeeperState as : allStates) {        assertEquals(as, KeeperState.fromInt(as.getIntValue()));    }}
0
public void testInvalidIntConversion()
{    try {        KeeperState.fromInt(324142);        fail("Was able to create an invalid KeeperState via an integer");    } catch (RuntimeException re) {        }}
0
public void testDeprecatedCodeOkInSwitch()
{    int test = 1;    switch(test) {        case Code.Ok:            assertTrue(true);            break;    }}
0
public void testCodeOKInSwitch()
{    Code test = Code.OK;    switch(test) {        case OK:            assertTrue(true);            break;    }}
0
public void createNodePrintAcl(ZooKeeper zk, String path, String testName)
{    try {                zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL(path, null);                for (ACL acl : acls) {                    }    } catch (Exception e) {            }}
1
public void preAuth() throws Exception
{    ZooKeeper zk = createClient();    zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/pre", "testPreAuth");        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getChildren("/", false);        zk.create("/abc", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/abc", "testData1".getBytes(), -1);        zk.create("/key", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/key", "5".getBytes(), -1);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void missingAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getData("/abc", false, null);        fail("Should not be able to get data");    } catch (KeeperException correct) {        }    try {        zk.setData("/abc", "testData2".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException correct) {        } finally {        zk.close();    }}
0
public void validAuth() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/valid", "testValidAuth");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void validAuth2() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "125".getBytes());    try {        createNodePrintAcl(zk, "/valid2", "testValidAuth2");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void testAuth() throws Exception
{            preAuth();    missingAuth();    validAuth();    validAuth2();}
0
public void setUp() throws Exception
{    qu = new QuorumUtil(1);}
0
public void tearDown() throws Exception
{    qu.shutdownAll();}
0
public void testExpiredSessionWithLocalSession() throws Exception
{    testCreateEphemeral(true);}
0
public void testExpiredSessionWithoutLocalSession() throws Exception
{    testCreateEphemeral(false);}
0
public void testCreateEphemeral(boolean localSessionEnabled) throws Exception
{    if (localSessionEnabled) {        qu.enableLocalSession(true);    }    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/impossible", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long fakeSessionId = (sid << 56) + 1;        Request request = new Request(null, fakeSessionId, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/impossible", null);    assertEquals("Node from fake session get created", null, stat);}
1
public void testCreatePersistent() throws Exception
{    qu.enableLocalSession(true);    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/success", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long locallSession = (sid << 56) + 1;        Request request = new Request(null, locallSession, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/success", null);    assertTrue("Request from local sesson failed", stat != null);}
1
public void testTxnFailure() throws Exception
{    try {        ZooKeeperServer.setDigestEnabled(true);        long count = 1;        File tmpDir = ClientBase.createTmpDir();        FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, -1, 1, 1);        for (count = 1; count <= 3; count++) {            dt.createNode("/test/" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());        }        long digestBefore = dt.getTreeDigest();        DataNode zk = dt.getNode("/test");                        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());                    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
1
private void doOp(FileTxnSnapLog logFile, int type, String path, DataTree dt, DataNode parent, int cversion) throws Exception
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    int prevCversion = parent.stat.getCversion();    long prevPzxid = parent.stat.getPzxid();    List<String> child = dt.getChildren(parentName, null, null);    StringBuilder childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }            Record txn = null;    TxnHeader txnHeader = null;    if (type == ZooDefs.OpCode.delete) {        txn = new DeleteTxn(path);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.delete);    } else if (type == ZooDefs.OpCode.create) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);    } else if (type == ZooDefs.OpCode.multi) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);        List<Txn> txnList = new ArrayList<Txn>();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        txn.serialize(boa, "request");        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        Txn txact = new Txn(ZooDefs.OpCode.create, bb.array());        txnList.add(txact);        txn = new MultiTxn(txnList);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.multi);    }    logFile.processTransaction(txnHeader, dt, null, txn);    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    child = dt.getChildren(parentName, null, null);    childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }            assertTrue(type + " <cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));}
1
public void testPad() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create);    Record txn = new CreateTxn("/Test", new byte[0], null, false, 1);    txnLog.append(txnHeader, txn);    FileInputStream in = new FileInputStream(tmpDir.getPath() + "/log." + Long.toHexString(txnHeader.getZxid()));    BinaryInputArchive ia = BinaryInputArchive.getArchive(in);    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");        assertTrue("Missing magic number ", header.getMagic() == FileTxnLog.TXNLOG_MAGIC);}
1
public void setUp() throws Exception
{    SyncRequestProcessor.setSnapCount(50);    super.setUp();}
0
public void testLoad() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    stopServer();        File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(0);        FileTxnIterator fileItr = (FileTxnIterator) itr;    long storageSize = fileItr.getStorageSize();        assertTrue("Storage size is greater than zero ", (storageSize > 0));    long expectedZxid = 0;    long lastZxid = 0;    TxnHeader hdr;    do {        hdr = itr.getHeader();        expectedZxid++;        assertTrue("not the same transaction. lastZxid=" + lastZxid + ", zxid=" + hdr.getZxid(), lastZxid != hdr.getZxid());        assertTrue("excepting next transaction. expected=" + expectedZxid + ", retrieved=" + hdr.getZxid(), (hdr.getZxid() == expectedZxid));        lastZxid = hdr.getZxid();    } while (itr.next());    assertTrue("processed all transactions. " + expectedZxid + " == " + TOTAL_TRANSACTIONS, (expectedZxid == TOTAL_TRANSACTIONS));}
1
public void testLoadFailure() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/data-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    stopServer();    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] logFiles = FileTxnLog.getLogFiles(logDir.listFiles(), 0);        assertTrue(logFiles.length > NUM_MESSAGES / 100);        assertTrue("delete the first log file", logFiles[0].delete());        long secondStartZxid = Util.getZxidFromName(logFiles[1].getName(), "log");    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(1, false);            assertEquals(secondStartZxid, itr.getHeader().getZxid());    itr = txnLog.read(secondStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());            long nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());            long thirdStartZxid = Util.getZxidFromName(logFiles[2].getName(), "log");    itr = txnLog.read(thirdStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());    nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());}
0
public void testRestore() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    String lastPath = null;    try {        zk.create("/invalidsnap", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < NUM_MESSAGES; i++) {            lastPath = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    String[] tokens = lastPath.split("-");    String expectedPath = "/invalidsnap/test-" + String.format("%010d", (Integer.parseInt(tokens[1])) + 1);    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    long eZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);            zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();    zks = serverFactory.getZooKeeperServer();    long fZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        assertTrue("Restore failed expected zxid=" + eZxid + " found=" + fZxid, fZxid == eZxid);    zk = createZKClient(hostPort);            String[] children;    String path;    try {        children = zk.getChildren("/invalidsnap", false).toArray(new String[0]);        path = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    } finally {        zk.close();    }        assertTrue("Error in sequential znode creation expected " + expectedPath + " found " + path, path.equals(expectedPath));    assertTrue("Unexpected number of children " + children.length + " expected " + NUM_MESSAGES, (children.length == NUM_MESSAGES));}
1
public void testRestoreWithTransactionErrors() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            try {                zk.create("/invaliddir/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            } catch (NoNodeException e) {                        }        }    } finally {        zk.close();    }        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);            zks.takeSnapshot();    zks.shutdown();    stopServer();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    startServer();}
1
public void testDatadirAutocreate() throws Exception
{    stopServer();    try {                System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, "false");        tmpDir = createTmpDir();        startServer();        fail("Server should not have started without datadir");    } catch (IOException e) {            } finally {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT);    }}
1
public void testReloadSnapshotWithMissingParent() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    zk.create("/a", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/a", false);    long createZxId = stat.getMzxid();    zk.create("/a/b", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/a/b", -1);    zk.delete("/a", -1);        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(createZxId);            zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();}
1
public void setUp() throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
1
public void tearDown() throws Exception
{        qb.tearDown();}
1
public void testLocalSessionsOnFollower() throws Exception
{    testOpenCloseSession(false);}
0
public void testLocalSessionsOnLeader() throws Exception
{    testOpenCloseSession(true);}
0
private void validateRequestLog(long sessionId, int peerId)
{    String session = Long.toHexString(sessionId);        String peerType = peerId == qb.getLeaderIndex() ? "leader" : "follower";    QuorumPeer peer = qb.getPeerList().get(peerId);    ZKDatabase db = peer.getActiveServer().getZKDatabase();    for (Proposal p : db.getCommittedLog()) {        assertFalse("Should not see " + Request.op2String(p.request.type) + " request from local session 0x" + session + " on the " + peerType, p.request.sessionId == sessionId);    }}
1
public void testOpenCloseSession(boolean onLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = onLeader ? leaderIdx : followerIdx;    int verifyPeerIdx = onLeader ? followerIdx : leaderIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper client = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId1 = client.getSessionId();            client.dontReconnect();    client.disconnect();    watcher.reset();        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId2 = zk.getSessionId();        zk.close();    watcher.reset();                    Thread.sleep(CONNECTION_TIMEOUT * 2);        validateRequestLog(localSessionId1, verifyPeerIdx);        validateRequestLog(localSessionId2, verifyPeerIdx);    qb.shutdownServers();}
0
public void setUp() throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = false;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
1
public void tearDown() throws Exception
{        qb.tearDown();}
1
public void testLocalSessionsOnFollower() throws Exception
{    testLocalSessions(false);}
0
public void testLocalSessionsOnLeader() throws Exception
{    testLocalSessions(true);}
0
private void testLocalSessions(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId = zk.getSessionId();        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        try {        zk.create(nodePrefix + "ephemeral", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Ephemeral node creation should fail.");    } catch (KeeperException.EphemeralOnLocalSessionException e) {    }        zk.close();        Map<String, Integer> peers = new HashMap<String, Integer>();    peers.put("leader", leaderIdx);    peers.put("follower", followerIdx);    for (Entry<String, Integer> entry : peers.entrySet()) {        watcher.reset();                        zk = qb.createClient(watcher, hostPorts[entry.getValue()], CONNECTION_TIMEOUT);        watcher.waitForConnected(CONNECTION_TIMEOUT);        long newSessionId = zk.getSessionId();        assertFalse(newSessionId == localSessionId);        for (int i = 0; i < 5; i++) {            assertNotNull("Data not exists in " + entry.getKey(), zk.exists(nodePrefix + i, null));        }                assertNull("Data exists in " + entry.getKey(), zk.exists(nodePrefix + "ephemeral", null));        zk.close();    }    qb.shutdownServers();}
0
public V1 getFirst()
{    return v1;}
0
public V2 getSecond()
{    return v2;}
0
 void rmr(File dir) throws IOException
{    Files.walkFileTree(dir.toPath(), new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {            Files.delete(dir);            return FileVisitResult.CONTINUE;        }    });}
0
public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
0
public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException
{    Files.delete(dir);    return FileVisitResult.CONTINUE;}
0
 Pair<Long, Long> getFirstLastZxid(File logFile) throws IOException
{    File tmp = createTmpDir();    Files.copy(logFile.toPath(), new File(tmp, "log.0").toPath());    FileTxnLog txnLog = new FileTxnLog(tmp);    TxnLog.TxnIterator it = txnLog.read(0);    long firstZxid = it.getHeader().getZxid();    long lastZxid = firstZxid;    while (it.next()) {        lastZxid = it.getHeader().getZxid();    }    txnLog.close();    rmr(tmp);    return new Pair<Long, Long>(firstZxid, lastZxid);}
0
public void testChopper() throws IOException
{    long clientId = 17;    int cxid = 77;    long zxid = 1000;    long time = 1;    int type = ZooDefs.OpCode.delete;    DeleteTxn txn = new DeleteTxn("/foo");    File tmpDir = createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    for (int i = 0; i < 100; i++) {        TxnHeader hdr = new TxnHeader(clientId, cxid, ++zxid, ++time, type);        txnLog.append(hdr, txn);    }        TxnHeader hdr = new TxnHeader(clientId, cxid, zxid + 10, ++time, type);    txnLog.append(hdr, txn);    txnLog.commit();        final File logFile = new File(tmpDir, "log." + Integer.toHexString(1001));    Pair<Long, Long> firstLast = getFirstLastZxid(logFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1110, (long) firstLast.getSecond());    File choppedFile = new File(tmpDir, "chopped_failed");    assertFalse(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1107));    choppedFile = new File(tmpDir, "chopped");    assertTrue(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1017));    firstLast = getFirstLastZxid(choppedFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1017, (long) firstLast.getSecond());}
0
public void setUp() throws Exception
{    maxCnxns = numCnxns;    super.setUp();}
0
public void run()
{    SocketChannel sChannel = null;    try {        /*                 * For future unwary socket programmers: although connect 'blocks' it                 * does not require an accept on the server side to return. Therefore                 * you can not assume that all the sockets are connected at the end of                 * this for loop.                 */        sChannel = SocketChannel.open();        sChannel.connect(new InetSocketAddress(host, port));                ConnectRequest conReq = new ConnectRequest(0, 0, 10000, 0, "password".getBytes());        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        boa.writeInt(-1, "len");        conReq.serialize(boa, "connect");        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.capacity() - 4);        bb.rewind();        /* Send a connect request. Any socket that has been closed (or at least                 * not added to the cnxn list on the server) will not have any bytes to                 * read and get an eof.                 *                 *  The trick here was finding a call that caused the server to put                 *  bytes in the input stream without closing the cnxn. None of                 *  the four letter commands do that, so we actually try to create                 *  a session which should send us something back, while maintaining                 *  the connection.                 */        int eof = sChannel.write(bb);                        sChannel.socket().setSoTimeout(10000);        if (!sChannel.socket().isClosed()) {            eof = sChannel.socket().getInputStream().read();            if (eof != -1) {                numConnected.incrementAndGet();            }        }    } catch (IOException io) {        } finally {        if (sChannel != null) {            try {                sChannel.close();            } catch (Exception e) {                        }        }    }}
0
public void testMaxCnxns() throws IOException, InterruptedException
{    String[] split = hostPort.split(":");    host = split[0];    port = Integer.parseInt(split[1]);    int numThreads = numCnxns + 5;    CnxnThread[] threads = new CnxnThread[numThreads];    for (int i = 0; i < numCnxns; ++i) {        threads[i] = new CnxnThread(i);    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].start();    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].join();    }    assertSame(numCnxns, numConnected.get());}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    pendingOps.set(0);}
0
private void finishPendingOps()
{    if (pendingOps.decrementAndGet() == 0) {        synchronized (pendingOps) {            pendingOps.notifyAll();        }    }}
0
private void waitForPendingOps(int timeout) throws Exception
{    synchronized (pendingOps) {        while (pendingOps.get() > 0) {            pendingOps.wait(timeout);        }    }}
0
public void testSequentialNodeCreateInAsyncMulti() throws Exception
{    final int iteration = 4;    final List<MultiResult> results = new ArrayList<MultiResult>();    pendingOps.set(iteration);    List<Op> ops = Arrays.asList(Op.create("/node-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.create("/dup", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    for (int i = 0; i < iteration; ++i) {        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                MultiResult result = new MultiResult();                result.results = opResults;                result.rc = rc;                results.add(result);                finishPendingOps();            }        }, null);    }    waitForPendingOps(CONNECTION_TIMEOUT);        assertEquals(KeeperException.Code.OK.intValue(), results.get(0).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(1).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(2).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(3).rc);        assertTrue(results.get(0).results.get(0) instanceof CreateResult);    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(1).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(2).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(3).results.get(0)).getErr());        assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(1).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(2).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(3).results.get(1)).getErr());}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    MultiResult result = new MultiResult();    result.results = opResults;    result.rc = rc;    results.add(result);    finishPendingOps();}
0
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
0
public void setUp() throws Exception
{    SyncRequestProcessor.setSnapCount(150);    super.setUp();    zk = createClient();}
0
private List<OpResult> multi(ZooKeeper zk, Iterable<Op> ops) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }                if (KeeperException.Code.OK.intValue() != res.rc && ops.iterator().next().getKind() != Op.OpKind.READ) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return zk.multi(ops);    }}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
0
private void multiHavingErrors(ZooKeeper zk, Iterable<Op> ops, List<Integer> expectedResultCodes, String expectedErr) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        for (int i = 0; i < res.results.size(); i++) {            OpResult opResult = res.results.get(i);            assertTrue("Did't receive proper error response", opResult instanceof ErrorResult);            ErrorResult errRes = (ErrorResult) opResult;            assertEquals("Did't receive proper error code", expectedResultCodes.get(i).intValue(), errRes.getErr());        }    } else {        try {            zk.multi(ops);            fail("Shouldn't have validated in ZooKeeper client!");        } catch (KeeperException e) {            assertEquals("Wrong exception", expectedErr, e.code().name());        } catch (IllegalArgumentException e) {            assertEquals("Wrong exception", expectedErr, e.getMessage());        }    }}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
0
private List<OpResult> commit(Transaction txn) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        txn.commit(new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        if (KeeperException.Code.OK.intValue() != res.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return txn.commit();    }}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
0
public void testInvalidPath() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL.toFlag()), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    expectedErr = "Path must start with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.check("/multi0", -1), Op.check("/multi1/", 100), Op.check("/multi2", 5));    expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete("/multi1/", 100), Op.delete("/multi2", 5));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        opList = Arrays.asList(Op.setData("/multi0", new byte[0], -1), Op.setData("/multi1/", new byte[0], -1), Op.setData("/multi2", new byte[0], -1), Op.setData("multi3", new byte[0], -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
0
public void testMultiRollback() throws Exception
{    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeper epheZk = createClient();    epheZk.create("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    List<Op> opList = Arrays.asList(Op.delete("/foo", -1));    try {        zk.multi(opList);        fail("multi delete should failed for not empty directory");    } catch (KeeperException.NotEmptyException e) {    }    final CountDownLatch latch = new CountDownLatch(1);    zk.exists("/foo/bar", event -> {        if (event.getType() == Watcher.Event.EventType.NodeDeleted) {            latch.countDown();        }    });    epheZk.close();    latch.await();    try {        zk.getData("/foo/bar", false, null);        fail("ephemeral node should have been deleted");    } catch (KeeperException.NoNodeException e) {    }    zk.multi(opList);    try {        zk.getData("/foo", false, null);        fail("persistent node should have been deleted after multi");    } catch (KeeperException.NoNodeException e) {    }}
0
public void testBlankPath() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        String expectedErr = "Path cannot be null";    List<Op> opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete(null, 100), Op.delete("/multi2", 5), Op.delete("", -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
0
public void testInvalidCreateModeFlag() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    int createModeFlag = 6789;    List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, createModeFlag), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = KeeperException.Code.BADARGUMENTS.name();    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
0
public void testChRootCreateDelete() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    Op createChild = Op.create("/myid", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk_chroot, Arrays.asList(createChild));    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists("/myid", false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists("/myid", false));        Op deleteChild = Op.delete("/myid", 0);    multi(zk_chroot, Arrays.asList(deleteChild));    assertNull("zNode exists under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNull("zNode exists under chroot:" + chRoot, zk_chroot.exists("/myid", false));}
0
public void testChRootSetData() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk_chroot, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals("zNode data not matching", names[i].getBytes(), zk_chroot.getData(names[i], false, null));    }}
0
public void testChRootCheck() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        zk.create(chRoot + names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    for (int i = 0; i < names.length; i++) {        ops.add(Op.check(names[i], 0));    }    multi(zk_chroot, ops);}
0
public void testChRootTransaction() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String childPath = "/myid";    Transaction transaction = zk_chroot.transaction();    transaction.create(childPath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    transaction.check(childPath, 0);    transaction.setData(childPath, childPath.getBytes(), 0);    commit(transaction);    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + childPath, false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists(childPath, false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists(childPath, false));    assertArrayEquals("zNode data not matching", childPath.getBytes(), zk_chroot.getData(childPath, false, null));    transaction = zk_chroot.transaction();        transaction.delete(childPath, 1);    commit(transaction);    assertNull("chroot:" + chRoot + " exists after delete", zk.exists(chRoot + "/myid", false));    assertNull("chroot:" + chRoot + " exists after delete", zk_chroot.exists("/myid", false));}
0
private String createNameSpace() throws InterruptedException, KeeperException
{        String chRoot = "/appsX";    Op createChRoot = Op.create(chRoot, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk, Arrays.asList(createChRoot));    return chRoot;}
0
public void testCreate() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);}
0
public void testCreateDelete() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi", null));}
0
public void testInvalidVersion() throws Exception
{    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 1)));        fail("delete /multi should have failed");    } catch (KeeperException e) {    /* PASS */    }}
0
public void testNestedCreate() throws Exception
{    multi(zk, Arrays.asList(/* Create */    Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a/1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), /* Delete */    Op.delete("/multi/a/1", 0), Op.delete("/multi/a", 0), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi/a/1", null));    assertNull(zk.exists("/multi/a", null));    assertNull(zk.exists("/multi", null));}
0
public void testSetData() throws Exception
{    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals(names[i].getBytes(), zk.getData(names[i], false, null));    }}
0
public void testUpdateConflict() throws Exception
{    assertNull(zk.exists("/multi", null));    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("Should have thrown a KeeperException for invalid version");    } catch (KeeperException e) {                    }    assertNull(zk.exists("/multi", null));        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 1)));    assertArrayEquals(zk.getData("/multi", false, null), "Y".getBytes());}
1
public void testDeleteUpdateConflict() throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("/multi should have been deleted so setData should have failed");    } catch (KeeperException e) {    /* PASS */    }        assertNull(zk.exists("/multi", null));}
0
public void testGetResults() throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    Iterable<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0), Op.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    List<OpResult> results = null;    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        assertFalse("/multi should have been deleted so setData should have failed", KeeperException.Code.OK.intValue() == res.rc);        assertNull(zk.exists("/multi", null));        results = res.results;    } else {        try {            zk.multi(ops);            fail("/multi should have been deleted so setData should have failed");        } catch (KeeperException e) {                        assertNull(zk.exists("/multi", null));            results = e.getResults();        }    }    assertNotNull(results);    for (OpResult r : results) {                if (r instanceof ErrorResult) {            ErrorResult er = (ErrorResult) r;                    }    }}
1
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
0
public void testOpResultEquals()
{    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("nope"));    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("nope", new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo"));    opEquals(new CheckResult(), new CheckResult(), null);    opEquals(new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));    opEquals(new DeleteResult(), new DeleteResult(), null);    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));}
0
private void opEquals(OpResult expected, OpResult value, OpResult near)
{    assertEquals(value, value);    assertFalse(value.equals(new Object()));    assertFalse(value.equals(near));    assertFalse(value.equals(value instanceof CreateResult ? new ErrorResult(1) : new CreateResult("nope2")));    assertTrue(value.equals(expected));}
0
public void testWatchesTriggered() throws KeeperException, InterruptedException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/t", -1)));    assertTrue(watcher.triggered.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
0
public void testNoWatchesTriggeredForFailedMultiRequest() throws InterruptedException, KeeperException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    try {        multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexisting", -1)));        fail("expected previous multi op to fail!");    } catch (KeeperException.NoNodeException e) {        }    SyncCallback cb = new SyncCallback();    zk.sync("/", cb, null);        cb.done.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(1, watcher.triggered.getCount());}
0
public void testTransactionBuilder() throws Exception
{    List<OpResult> results = commit(zk.transaction().create("/t1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t1/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL));    assertEquals(3, results.size());    for (OpResult r : results) {        CreateResult c = (CreateResult) r;        assertTrue(c.getPath().startsWith("/t"));        assertNotNull(c.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNotNull(zk.exists("/t1/child", false));    assertNotNull(zk.exists("/t2", false));    results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    for (OpResult r : results) {        CheckResult c = (CheckResult) r;        assertNotNull(c.toString());    }    try {        results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 1));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 0).setData("/t1", new byte[0], 0));    assertEquals(2, results.size());    for (OpResult r : results) {        assertNotNull(r.toString());    }    try {        results = commit(zk.transaction().check("/t1", 1).setData("/t1", new byte[0], 2));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 1).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    results = commit(zk.transaction().delete("/t2", -1).delete("/t1/child", -1));    assertEquals(2, results.size());    for (OpResult r : results) {        DeleteResult d = (DeleteResult) r;        assertNotNull(d.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNull(zk.exists("/t1/child", false));    assertNull(zk.exists("/t2", false));}
0
public void testMultiGetChildren() throws Exception
{    List<String> topLevelNodes = new ArrayList<String>();    Map<String, List<String>> childrenNodes = new HashMap<String, List<String>>();        for (int i = 0; i < 10; i++) {        String name = "/foo" + i;        zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        topLevelNodes.add(name);        childrenNodes.put(name, new ArrayList<>());        for (int j = 0; j < 10; j++) {            String childname = name + "/bar" + i + j;            String childname_s = "bar" + i + j;            zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            childrenNodes.get(name).add(childname_s);        }    }        List<OpResult> multiChildrenList = multi(zk, topLevelNodes.stream().map(Op::getChildren).collect(Collectors.toList()));    for (int i = 0; i < topLevelNodes.size(); i++) {        String nodeName = topLevelNodes.get(i);        assertTrue(multiChildrenList.get(i) instanceof OpResult.GetChildrenResult);        List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(i)).getChildren();                assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(childrenNodes.get(nodeName)));        List<String> children = zk.getChildren(nodeName, false);        assertEquals(childrenList, children);    }}
0
public void testMultiGetChildrenSameNode() throws Exception
{    List<String> childrenNodes = new ArrayList<String>();        String topLevelNode = "/foo";    zk.create(topLevelNode, topLevelNode.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = topLevelNode + "/bar" + i;        String childname_s = "bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        childrenNodes.add(childname_s);    }        List<OpResult> sameChildrenList = multi(zk, Arrays.asList(Op.getChildren(topLevelNode), Op.getChildren(topLevelNode)));        assertEquals(sameChildrenList.size(), 2);    assertEquals(sameChildrenList.get(0), sameChildrenList.get(1));        assertTrue(sameChildrenList.get(0) instanceof OpResult.GetChildrenResult);    OpResult.GetChildrenResult gcr = (OpResult.GetChildrenResult) sameChildrenList.get(0);        assertEquals(new TreeSet<String>(gcr.getChildren()), new TreeSet<String>(childrenNodes));}
0
public void testMultiGetChildrenAuthentication() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);        List<OpResult> multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());}
0
public void testMultiGetChildrenMixedAuthenticationErrorFirst() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);    List<OpResult> multiChildrenList;        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth"), Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());    assertTrue(multiChildrenList.get(1) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(1)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");}
0
public void testMultiGetChildrenMixedAuthenticationCorrectFirst() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);            List<OpResult> multiChildrenList;    multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth"), Op.getChildren("/foo_no_auth")));    assertSame(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");    assertTrue(multiChildrenList.get(1) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(1)).getErr(), KeeperException.Code.NOAUTH.intValue());}
0
public void testMultiGetData() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiData = multi(zk, Arrays.asList(Op.getData("/node1"), Op.getData("/node2")));    assertEquals(multiData.size(), 2);    assertArrayEquals(((OpResult.GetDataResult) multiData.get(0)).getData(), "data1".getBytes());    assertArrayEquals(((OpResult.GetDataResult) multiData.get(1)).getData(), "data2".getBytes());}
0
public void testMultiRead() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.create("/node1/node1", "data11".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node1/node2", "data12".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiRead = multi(zk, Arrays.asList(Op.getChildren("/node1"), Op.getData("/node1"), Op.getChildren("/node2"), Op.getData("/node2")));    assertEquals(multiRead.size(), 4);    assertTrue(multiRead.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiRead.get(0)).getChildren();    assertEquals(childrenList.size(), 2);    assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(Arrays.asList("node1", "node2")));    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(1)).getData(), "data1".getBytes());    Stat stat = ((OpResult.GetDataResult) multiRead.get(1)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(2, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(2, stat.getNumChildren());    assertTrue(multiRead.get(2) instanceof OpResult.GetChildrenResult);    childrenList = ((OpResult.GetChildrenResult) multiRead.get(2)).getChildren();    assertTrue(childrenList.isEmpty());    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(3)).getData(), "data2".getBytes());    stat = ((OpResult.GetDataResult) multiRead.get(3)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getMzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void testMixedReadAndTransaction() throws Exception
{    zk.create("/node", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        List<OpResult> multiRead = multi(zk, Arrays.asList(Op.setData("/node1", "data1".getBytes(), -1), Op.getData("/node1")));        fail("Mixed kind of operations are not allowed");    } catch (IllegalArgumentException e) {        }}
0
public void process(WatchedEvent event)
{    triggered.countDown();}
0
public void processResult(int rc, String path, Object ctx)
{    done.countDown();}
0
public static void setUp()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ClientCnxnSocketNetty.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
0
public static void tearDown()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);}
0
public void setUpTest() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
0
public void tearDownTest() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
0
public void testFileDescriptorLeak() throws Exception
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {                return;    }    long startFdCount = osMbean.getOpenFileDescriptorCount();        for (int i = 0; i < 50; ++i) {        NIOServerCnxnFactory factory = new NIOServerCnxnFactory();        factory.configure(new InetSocketAddress("127.0.0.1", PortAssignment.unique()), 10);        factory.start();        Thread.sleep(100);        factory.shutdown();    }    long endFdCount = osMbean.getOpenFileDescriptorCount();            assertTrue("Possible fd leakage", ((endFdCount - startFdCount) < 50));}
1
public static void setUp()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
0
public static void tearDown()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
0
public void setUpTest() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
0
public void tearDownTest() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
0
public void testZooKeeperServiceAvailableOnLeader() throws Exception
{    int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";    zk.create(NODE_PATH, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        QuorumPeer leader = getLeaderQuorumPeer(mt);    assertNotNull("Leader must have been elected by now", leader);        FileTxnSnapLog snapLog = leader.getActiveServer().getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase originalZKDatabase = leader.getActiveServer().getZKDatabase();    long leaderCurrentEpoch = leader.getCurrentEpoch();    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    leader.getActiveServer().setZKDatabase(newDB);    try {                zk.create(uniqueZnode(), data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected due to error injected to transaction log commit");    } catch (Exception e) {        }                watcher.reset();    waitForNewLeaderElection(leader, leaderCurrentEpoch);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        leader.getActiveServer().setZKDatabase(originalZKDatabase);        leader = getLeaderQuorumPeer(mt);    assertNotNull("New leader must have been elected by now", leader);    String uniqueNode = uniqueZnode();    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String createNode = zk.create(uniqueNode, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            assertEquals("Failed to create znode", uniqueNode, createNode);    zk.close();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0
public void commit() throws IOException
{    throw new IOException("Input/output error");}
0
private void waitForNewLeaderElection(QuorumPeer peer, long leaderCurrentEpoch) throws IOException, InterruptedException
{            int count = 100;    while (count > 0) {        if (leaderCurrentEpoch == peer.getCurrentEpoch()) {            Thread.sleep(100);        }        count--;    }    assertNotEquals("New LE cycle must have triggered", leaderCurrentEpoch, peer.getCurrentEpoch());}
1
private QuorumPeer getLeaderQuorumPeer(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
0
private String uniqueZnode()
{    UUID randomUUID = UUID.randomUUID();    String node = NODE_PATH + "/" + randomUUID.toString();    return node;}
0
public void setUp() throws Exception
{        snapCount = System.getProperty("zookeeper.snapCount", "1024");    System.setProperty("zookeeper.snapCount", "10");    super.setUp();}
0
public void tearDown() throws Exception
{    System.setProperty("zookeeper.snapCount", snapCount);    super.tearDown();}
0
public void testNullData() throws IOException, InterruptedException, KeeperException
{    String path = "/SIZE";    ZooKeeper zk = null;    zk = createClient();    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.exists(path, false);        zk.exists(path, false, this, null);        cn.await(10, TimeUnit.SECONDS);        assertSame(0L, cn.getCount());    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    cn.countDown();}
0
 void startServers() throws Exception
{    startServers(true);}
0
protected void shutdown(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
0
public void testHierarchicalQuorum() throws Throwable
{    cht.runHammer(5, 10);}
0
public void establishThreeParticipantOneObserverEnsemble() throws Exception
{    qb.setUp(true);    ct.hostPort = qb.hostPort;    ct.setUpAll();    qb.s5.shutdown();}
0
public void shutdownQuorum() throws Exception
{    ct.tearDownAll();    qb.tearDown();}
0
public void testLEWithObserver() throws Exception
{    QuorumPeer leader = null;    for (QuorumPeer server : Arrays.asList(qb.s1, qb.s2, qb.s3)) {        if (server.getServerState().equals(QuorumStats.Provider.FOLLOWING_STATE)) {            server.shutdown();            assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + server.getClientPort(), ClientBase.CONNECTION_TIMEOUT));        } else {            assertNull("More than one leader found", leader);            leader = server;        }    }    assertTrue("Leader is not in Looking state", ClientBase.waitForServerState(leader, ClientBase.CONNECTION_TIMEOUT, QuorumStats.Provider.LOOKING_STATE));}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } });}
0
private PortForwarder setUp(final int omProxyPort) throws IOException
{    ClientBase.setupTestEnv();    final int PORT_QP1 = PortAssignment.unique();    final int PORT_QP2 = PortAssignment.unique();    final int PORT_OBS = PortAssignment.unique();    final int PORT_QP_LE1 = PortAssignment.unique();    final int PORT_QP_LE2 = PortAssignment.unique();    final int PORT_OBS_LE = PortAssignment.unique();    CLIENT_PORT_QP1 = PortAssignment.unique();    CLIENT_PORT_QP2 = PortAssignment.unique();    CLIENT_PORT_OBS = PortAssignment.unique();    OM_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PORT_QP1) + ":" + (PORT_QP_LE1) + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + (PORT_QP2) + ":" + (PORT_QP_LE2) + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + (PORT_OBS) + ":" + (PORT_OBS_LE) + ":observer" + ";" + CLIENT_PORT_OBS;    String extraCfgs = testObserverMaster ? String.format("observerMasterPort=%d%n", OM_PORT) : "";    String extraCfgsObs = testObserverMaster ? String.format("observerMasterPort=%d%n", omProxyPort <= 0 ? OM_PORT : omProxyPort) : "";    PortForwarder forwarder = null;    if (testObserverMaster && omProxyPort >= 0) {        forwarder = new PortForwarder(omProxyPort, OM_PORT);    }    q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, extraCfgs);    q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, extraCfgs);    q3 = new MainThread(3, CLIENT_PORT_OBS, quorumCfgSection, extraCfgsObs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    return forwarder;}
0
private void shutdown() throws InterruptedException
{        zk.close();    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue("Waiting for server 1 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 3 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT));}
1
public void testLaggingObserverMaster() throws Exception
{    final int OM_PROXY_PORT = PortAssignment.unique();    PortForwarder forwarder = setUp(OM_PROXY_PORT);        int leaderPort;    MainThread leader;    MainThread follower;    if (q1.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP1;        leader = q1;        follower = q2;    } else if (q2.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP2;        leader = q2;        follower = q1;    } else {        throw new RuntimeException("No leader");    }        zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long lastLoggedZxid = leader.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);        if (forwarder != null) {        forwarder.shutdown();    }    for (int i = 0; i < 10; i++) {        zk.create("/basic" + i, "second".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    DelayRequestProcessor delayRequestProcessor = null;    if (testObserverMaster) {        FollowerZooKeeperServer followerZooKeeperServer = (FollowerZooKeeperServer) follower.getQuorumPeer().getActiveServer();        delayRequestProcessor = DelayRequestProcessor.injectDelayRequestProcessor(followerZooKeeperServer);    }    zk.create("/target1", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/target2", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            forwarder = testObserverMaster ? new PortForwarder(OM_PROXY_PORT, OM_PORT) : null;    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    assertNotNull("Leader switched", leader.getQuorumPeer().leader);    if (delayRequestProcessor != null) {        delayRequestProcessor.unblockQueue();    }    latch = new CountDownLatch(1);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/finalop", "fourth".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("first", new String(obsZk.getData("/init", null, null)));    assertEquals("third", new String(obsZk.getData("/target1", null, null)));    obsZk.close();    shutdown();    try {        if (forwarder != null) {            forwarder.shutdown();        }    } catch (Exception e) {        }}
1
public boolean evaluate()
{    return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();}
0
public void testObserver() throws Exception
{        latch = new CountDownLatch(2);    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    if (testObserverMaster) {        int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();                assertEquals("observer failed to connect to observer master", masterPort, OM_PORT);    }    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertEquals(new String(zk.getData("/obstest", null, null)), "test");        zk.sync("/", null, null);    zk.setData("/obstest", "test2".getBytes(), -1);    zk.getChildren("/", false);    assertEquals(zk.getState(), States.CONNECTED);            q2.shutdown();    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));            latch.await();    assertNotSame("Client is still connected to non-quorate cluster", KeeperState.SyncConnected, lastEvent.getState());        try {        assertNotEquals("Shouldn't get a response when cluster not quorate!", "test", new String(zk.getData("/obstest", null, null)));    } catch (ConnectionLossException c) {            }    latch = new CountDownLatch(1);                q2.start();        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        latch.await();            assertTrue("Client didn't reconnect to quorate ensemble (state was" + lastEvent.getState() + ")", (KeeperState.SyncConnected == lastEvent.getState() || KeeperState.Expired == lastEvent.getState()));        int leaderProxyPort = PortAssignment.unique();    int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    ZooKeeper client = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    client.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", client.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(client.getData("/revalidtest", null, null)), "test");    client.close();    obsPF.shutdown();    shutdown();}
1
public void testRevalidation() throws Exception
{    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final int leaderProxyPort = PortAssignment.unique();    final int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    zk = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", zk.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(zk.getData("/revalidtest", null, null)), "test");    obsPF.shutdown();    shutdown();}
0
public void testInOrderCommits() throws Exception
{    setUp(-1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, null);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("Initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long zxid = q1.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return zxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    int followerPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP1 : CLIENT_PORT_QP2;    ZooKeeper fZk = new ZooKeeper("127.0.0.1:" + followerPort, ClientBase.CONNECTION_TIMEOUT, this);    final int numTransactions = 10001;    CountDownLatch gate = new CountDownLatch(1);    CountDownLatch oAsyncLatch = new CountDownLatch(numTransactions);    Thread oAsyncWriteThread = new Thread(new AsyncWriter(obsZk, numTransactions, true, oAsyncLatch, "/obs", gate));    CountDownLatch fAsyncLatch = new CountDownLatch(numTransactions);    Thread fAsyncWriteThread = new Thread(new AsyncWriter(fZk, numTransactions, true, fAsyncLatch, "/follower", gate));        oAsyncWriteThread.start();    fAsyncWriteThread.start();    gate.countDown();    oAsyncLatch.await();    fAsyncLatch.await();    oAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (oAsyncWriteThread.isAlive()) {            }    fAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (fAsyncWriteThread.isAlive()) {            }    obsZk.close();    fZk.close();    shutdown();}
1
public boolean evaluate()
{    return zxid == q3.getQuorumPeer().getLastLoggedZxid();}
0
public void testAdminCommands() throws IOException, MBeanException, InstanceNotFoundException, ReflectionException, InterruptedException, MalformedObjectNameException, AttributeNotFoundException, InvalidAttributeValueException, KeeperException
{        for (ZKMBeanInfo beanInfo : MBeanRegistry.getInstance().getRegisteredBeans()) {        MBeanRegistry.getInstance().unregister(beanInfo);    }    JMXEnv.setUp();    setUp(-1);    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));        zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/obstest", null, null)), "test");        final Map<String, String> emptyMap = Collections.emptyMap();    Map<String, Object> stats = Commands.runCommand("mntr", q3.getQuorumPeer().getActiveServer(), emptyMap).toMap();    assertTrue("observer not emitting observer_master_id", stats.containsKey("observer_master_id"));        if (testObserverMaster) {        if (q1.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q1.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q1.getQuorumPeer().leader == null) {            assertNull(q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        }    }        if (testObserverMaster) {        if (q2.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q2.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q2.getQuorumPeer().leader == null) {            assertNull(q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        }    }        ObjectName connBean = null;    for (ObjectName bean : JMXEnv.conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null)) {        if (bean.getCanonicalName().contains("Learner_Connections") && bean.getCanonicalName().contains("id:" + q3.getQuorumPeer().getId())) {            connBean = bean;            break;        }    }    assertNotNull("could not find connection bean", connBean);    latch = new CountDownLatch(1);    JMXEnv.conn().invoke(connBean, "terminateConnection", new Object[0], null);    assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT / 2, TimeUnit.MILLISECONDS));    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final String obsBeanName = String.format("org.apache.ZooKeeperService:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Observer", q3.getQuorumPeer().getId(), q3.getQuorumPeer().getId());    Set<ObjectName> names = JMXEnv.conn().queryNames(new ObjectName(obsBeanName), null);    assertEquals("expecting singular observer bean", 1, names.size());    ObjectName obsBean = names.iterator().next();    if (testObserverMaster) {                long observerMasterId = q3.getQuorumPeer().observer.getLearnerMasterId();        latch = new CountDownLatch(1);        JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - observerMasterId)));        assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    } else {                final long leaderId = q1.getQuorumPeer().leader == null ? 2 : 1;        try {            JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - leaderId)));            fail("should have seen an exception on previous command");        } catch (RuntimeMBeanException e) {            assertEquals("mbean failed for the wrong reason", IllegalArgumentException.class, e.getCause().getClass());        }    }    shutdown();    JMXEnv.tearDown();}
0
private String createServerString(String type, long serverId, int clientPort)
{    return "server." + serverId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + type + ";" + clientPort;}
0
private void waitServerUp(int clientPort)
{    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
0
private ZooKeeperAdmin createAdmin(int clientPort) throws IOException
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);    ZooKeeperAdmin admin = new ZooKeeperAdmin("127.0.0.1:" + clientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    admin.addAuthInfo("digest", "super:test".getBytes());    return admin;}
0
public void testDynamicReconfig() throws InterruptedException, IOException, KeeperException
{    if (!testObserverMaster) {        return;    }    ClientBase.setupTestEnv();                            int clientPort1 = PortAssignment.unique();    int clientPort2 = PortAssignment.unique();    int omPort1 = PortAssignment.unique();    int omPort2 = PortAssignment.unique();    String quorumCfgSection = createServerString("participant", 1, clientPort1) + "\n" + createServerString("participant", 2, clientPort2);    MainThread s1 = new MainThread(1, clientPort1, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort1));    MainThread s2 = new MainThread(2, clientPort2, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort2));    s1.start();    s2.start();    waitServerUp(clientPort1);    waitServerUp(clientPort2);        long nonLeaderOMPort = s1.getQuorumPeer().leader == null ? omPort1 : omPort2;    int observerClientPort = PortAssignment.unique();    int observerId = 10;    MainThread observer = new MainThread(observerId, observerClientPort, quorumCfgSection + "\n" + createServerString("observer", observerId, observerClientPort), String.format("observerMasterPort=%d%n", nonLeaderOMPort));        observer.start();    waitServerUp(observerClientPort);        final LinkedBlockingQueue<KeeperState> states = new LinkedBlockingQueue<KeeperState>();    ZooKeeper observerClient = new ZooKeeper("127.0.0.1:" + observerClientPort, ClientBase.CONNECTION_TIMEOUT, event -> {        try {            states.put(event.getState());        } catch (InterruptedException ignore) {        }    });        KeeperState state = states.poll(1000, TimeUnit.MILLISECONDS);    assertEquals(KeeperState.SyncConnected, state);        ArrayList<String> newServers = new ArrayList<String>();    String server = "server.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + PortAssignment.unique();    newServers.add(server);    ZooKeeperAdmin admin = createAdmin(clientPort1);    ReconfigTest.reconfig(admin, newServers, null, null, -1);        ReconfigTest.testServerHasConfig(observerClient, newServers, null);            state = states.poll(1000, TimeUnit.MILLISECONDS);    assertNull(state);    admin.close();    observerClient.close();    observer.shutdown();    s2.shutdown();    s1.shutdown();}
1
public void process(WatchedEvent event)
{    lastEvent = event;    if (latch != null) {        latch.countDown();    }    }
1
public void run()
{    if (gate != null) {        try {            gate.await();        } catch (InterruptedException e) {                        return;        }    }    for (int i = 0; i < numTransactions; i++) {        final boolean pleaseLog = i % 100 == 0;        client.create(root + i, "inner thread".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                writerLatch.countDown();                if (pleaseLog) {                                    }            }        }, null);        if (pleaseLog) {                        if (issueSync) {                client.sync(root + "0", null, null);            }        }    }}
1
public void processResult(int rc, String path, Object ctx, String name)
{    writerLatch.countDown();    if (pleaseLog) {            }}
1
public void setUp() throws Exception
{    qb.setUp(true);    cht.hostPort = qb.hostPort;    cht.setUpAll();}
0
public void testHammerBasic() throws Throwable
{    cht.testHammerBasic();}
0
public void testObserverOnly() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer;" + CLIENT_PORT_QP1 + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
0
public void testObserverWithStandlone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer\n" + "server.2=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + "\npeerType=observer\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
0
public void testOOM() throws IOException, InterruptedException, KeeperException
{    File tmpDir = ClientBase.createTmpDir();            List<byte[]> hog = new ArrayList<>();    while (true) {        try {            hog.add(new byte[1024 * 1024 * 2]);        } catch (OutOfMemoryError e) {            hog.remove(0);            break;        }    }    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = PortAssignment.unique();    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));    System.err.println("OOM Stage 0");    utestPrep(PORT);    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 1");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestExists(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 2");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestGet(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 3");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestChildren(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    hog.get(0)[0] = (byte) 1;    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));}
0
private void utestExists(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.exists("/this/path/doesnt_exist!", true);    }    zk.close();}
0
private void utestPrep(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.create("/" + i, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
0
private void utestGet(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        Stat stat = new Stat();        zk.getData("/" + i, true, stat);    }    zk.close();}
0
private void utestChildren(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.getChildren("/" + i, true);    }    zk.close();}
0
public void initialize()
{    this.osMbean = new OSMXBean();    assertNotNull("Could not initialize OSMXBean object!", osMbean);}
0
public final void testGetUnix()
{    boolean isUnix = osMbean.getUnix();    if (!isUnix) {            } else {            }}
1
public final void testGetOpenFileDescriptorCount()
{    if (osMbean != null && osMbean.getUnix()) {        ofdc = osMbean.getOpenFileDescriptorCount();            }    assertFalse("The number of open file descriptor is negative", (ofdc < 0));}
1
public final void testGetMaxFileDescriptorCount()
{    if (osMbean != null && osMbean.getUnix()) {        mfdc = osMbean.getMaxFileDescriptorCount();            }    assertFalse("The max file descriptor number is negative", (mfdc < 0));}
1
public void testNull()
{}
0
public void setUp() throws Exception
{    setUp(false);}
0
protected void setUp(boolean withObservers) throws Exception
{        setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    portLE1 = PortAssignment.unique();    portLE2 = PortAssignment.unique();    portLE3 = PortAssignment.unique();    portLE4 = PortAssignment.unique();    portLE5 = PortAssignment.unique();    portClient1 = PortAssignment.unique();    portClient2 = PortAssignment.unique();    portClient3 = PortAssignment.unique();    portClient4 = PortAssignment.unique();    portClient5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + portClient1 + ",127.0.0.1:" + portClient2 + ",127.0.0.1:" + portClient3 + ",127.0.0.1:" + portClient4 + ",127.0.0.1:" + portClient5;        s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    startServers(withObservers);    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    }
1
 void startServers() throws Exception
{    startServers(false);}
0
 void startServers(boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    if (withObservers) {        peers.get(Long.valueOf(4)).type = LearnerType.OBSERVER;        peers.get(Long.valueOf(5)).type = LearnerType.OBSERVER;    }        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient1, s1.getClientPort());        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient2, s2.getClientPort());        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient3, s3.getClientPort());        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient4, s4.getClientPort());        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient5, s5.getClientPort());    if (withObservers) {        s4.setLearnerType(LearnerType.OBSERVER);        s5.setLearnerType(LearnerType.OBSERVER);    }                        s1.enableLocalSessions(localSessionsEnabled);    s2.enableLocalSessions(localSessionsEnabled);    s3.enableLocalSessions(localSessionsEnabled);    s4.enableLocalSessions(localSessionsEnabled);    s5.enableLocalSessions(localSessionsEnabled);    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s3.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s4.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s5.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);        s1.start();        s2.start();        s3.start();        s4.start();        s5.start();            for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));            }        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= 5; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= 5; i++) {        for (int j = 1; j <= 5; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));}
1
public int getLeaderIndex()
{    if (s1.getPeerState() == ServerState.LEADING) {        return 0;    } else if (s2.getPeerState() == ServerState.LEADING) {        return 1;    } else if (s3.getPeerState() == ServerState.LEADING) {        return 2;    } else if (s4.getPeerState() == ServerState.LEADING) {        return 3;    } else if (s5.getPeerState() == ServerState.LEADING) {        return 4;    }    return -1;}
0
public String getPeersMatching(ServerState state)
{    StringBuilder hosts = new StringBuilder();    for (QuorumPeer p : getPeerList()) {        if (p.getPeerState() == state) {            hosts.append(String.format("%s:%d,", LOCALADDR, p.getClientAddress().getPort()));        }    }        return hosts.toString();}
1
public ArrayList<QuorumPeer> getPeerList()
{    ArrayList<QuorumPeer> peers = new ArrayList<QuorumPeer>();    peers.add(s1);    peers.add(s2);    peers.add(s3);    peers.add(s4);    peers.add(s5);    return peers;}
0
public QuorumPeer getPeerByClientPort(int clientPort)
{    for (QuorumPeer p : getPeerList()) {        if (p.getClientAddress().getPort() == clientPort) {            return p;        }    }    return null;}
0
public void setupServers() throws IOException
{    setupServer(1);    setupServer(2);    setupServer(3);    setupServer(4);    setupServer(5);}
0
public void setupServer(int i) throws IOException
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    if (peers == null) {        peers = new HashMap<Long, QuorumServer>();        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    }    switch(i) {        case 1:                        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient1, s1.getClientPort());            break;        case 2:                        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient2, s2.getClientPort());            break;        case 3:                        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient3, s3.getClientPort());            break;        case 4:                        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient4, s4.getClientPort());            break;        case 5:                        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient5, s5.getClientPort());    }}
1
public void tearDown() throws Exception
{        OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    shutdownServers();    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }    JMXEnv.tearDown();}
1
public void shutdownServers()
{    shutdown(s1);    shutdown(s2);    shutdown(s3);    shutdown(s4);    shutdown(s5);}
0
public static void shutdown(QuorumPeer qp)
{    if (qp == null) {        return;    }    try {                qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {                        e.shutdown();        } else {                    }                long readTimeout = qp.getTickTime() * qp.getInitLimit();        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();        long maxTimeout = Math.max(readTimeout, connectTimeout);        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);        qp.join(maxTimeout * 2);        if (qp.isAlive()) {            fail("QP failed to shutdown in " + (maxTimeout * 2) + " seconds: " + qp.getName());        }    } catch (InterruptedException e) {            }}
1
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
0
protected TestableZooKeeper createClient(CountdownWatcher watcher, ServerState state) throws IOException, InterruptedException
{    return createClient(watcher, getPeersMatching(state));}
0
public void setUp() throws Exception
{    qb.setUp();    cht.hostPort = qb.hostPort;    cht.setUpAll();}
0
public void tearDown() throws Exception
{    cht.tearDownAll();    qb.tearDown();}
0
public void testHammerBasic() throws Throwable
{    cht.testHammerBasic();}
0
public void testMajQuorums() throws Throwable
{        ArrayList<QuorumPeer> peers = getPeerList();    for (int i = 1; i <= peers.size(); i++) {        QuorumPeer qp = peers.get(i - 1);        Long electionTimeTaken = -1L;        String bean = "";        if (qp.getPeerState() == ServerState.FOLLOWING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower", MBeanRegistry.DOMAIN, i, i);        } else if (qp.getPeerState() == ServerState.LEADING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader", MBeanRegistry.DOMAIN, i, i);        }        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, "ElectionTimeTaken");        assertTrue("Wrong electionTimeTaken value!", electionTimeTaken >= 0);    }        setUp(false);    Proposal p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    p.addAck(Long.valueOf(2));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(3));    assertEquals(true, p.hasAllQuorums());        setUp(true);    p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(4));    p.addAck(Long.valueOf(5));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(2));    assertEquals(true, p.hasAllQuorums());}
1
public void testQuotaWithQuorum() throws Exception
{    ZooKeeper zk = createClient();    zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int i = 0;    for (i = 0; i < 300; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    SetQuotaCommand.createQuota(zk, "/a", 1000L, 5000);    String statPath = Quotas.quotaZookeeper + "/a" + "/" + Quotas.statNode;    byte[] data = zk.getData(statPath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 1204L);    assertTrue("num count is set", st.getCount() == 301);    for (i = 300; i < 600; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    data = zk.getData(statPath, false, new Stat());    st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 2404L);    assertTrue("num count is set", st.getCount() == 601);}
0
public void setUp() throws Exception
{    qb.setUp();    ct.hostPort = qb.hostPort;    ct.setUpAll();}
0
public void tearDown() throws Exception
{    ct.tearDownAll();    qb.tearDown();    if (qu != null) {        qu.tearDown();    }}
0
public void testDeleteWithChildren() throws Exception
{    ct.testDeleteWithChildren();}
0
public void testPing() throws Exception
{    ct.testPing();}
0
public void testSequentialNodeNames() throws IOException, InterruptedException, KeeperException
{    ct.testSequentialNodeNames();}
0
public void testACLs() throws Exception
{    ct.testACLs();}
0
public void testClientwithoutWatcherObj() throws IOException, InterruptedException, KeeperException
{    ct.testClientwithoutWatcherObj();}
0
public void testClientWithWatcherObj() throws IOException, InterruptedException, KeeperException
{    ct.testClientWithWatcherObj();}
0
public void testGetView()
{    assertEquals(5, qb.s1.getView().size());    assertEquals(5, qb.s2.getView().size());    assertEquals(5, qb.s3.getView().size());    assertEquals(5, qb.s4.getView().size());    assertEquals(5, qb.s5.getView().size());}
0
public void testViewContains()
{        assertTrue(qb.s1.viewContains(qb.s1.getId()));        assertTrue(qb.s1.viewContains(qb.s2.getId()));        assertFalse(qb.s1.viewContains(-1L));}
0
public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new DisconnectableZooKeeper(qb.hostPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/blah/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Leader leader = qb.s1.leader;    if (leader == null) {        leader = qb.s2.leader;    }    if (leader == null) {        leader = qb.s3.leader;    }    if (leader == null) {        leader = qb.s4.leader;    }    if (leader == null) {        leader = qb.s5.leader;    }    assertNotNull(leader);    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }    for (LearnerHandler f : leader.getForwardingFollowers()) {        f.getSocket().shutdownInput();    }    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }        assertTrue(qb.s1.isAlive());    assertTrue(qb.s2.isAlive());    assertTrue(qb.s3.isAlive());    assertTrue(qb.s4.isAlive());    assertTrue(qb.s5.isAlive());    zk.close();}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
0
public void testMultipleWatcherObjs() throws IOException, InterruptedException, KeeperException
{    ct.testMutipleWatcherObjs();}
0
public void testSessionMoved() throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());        zknew.setData("/", new byte[1], -1);        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }                assertTrue(result[0] == KeeperException.Code.OK.intValue());        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {        }        zk = zknew;    }    zk.close();}
1
public void processResult(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
0
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        zkDisco = true;    }}
0
public void testSessionMovedWithMultiOp() throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        ZooKeeper zknew = new ZooKeeper(hostPorts[1], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());    zknew.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        try {        zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-Failed", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {    }    zk.close();    zknew.close();}
0
public void testSessionMove() throws Exception
{    String[] hps = qb.hostPort.split(",");    DiscoWatcher oldWatcher = new DiscoWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hps[0], ClientBase.CONNECTION_TIMEOUT, oldWatcher);    zk.create("/t1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.dontReconnect();        DiscoWatcher watcher = new DiscoWatcher();    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, watcher, zk.getSessionId(), zk.getSessionPasswd());    zknew.create("/t2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    try {        zk.create("/t3", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {                for (int i = 0; i < 30; i++) {            if (oldWatcher.zkDisco) {                break;            }            Thread.sleep(1000);        }        assertTrue(oldWatcher.zkDisco);    }    ArrayList<ZooKeeper> toClose = new ArrayList<ZooKeeper>();    toClose.add(zknew);        for (int i = 0; i < 10; i++) {        zknew.dontReconnect();        zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, new DiscoWatcher(), zk.getSessionId(), zk.getSessionPasswd());        toClose.add(zknew);        zknew.create("/t-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }    for (ZooKeeper z : toClose) {        z.close();    }    zk.close();}
0
public void testFollowersStartAfterLeader() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }        qu.shutdown(index);        qu.start(index);            ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (TimeoutException e) {        fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");    }    zk.close();}
0
public void testMultiToFollower() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.multi(Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);    zk.close();}
0
public PeerStruct getPeer(int id)
{    return peers.get(id);}
0
public void enableLocalSession(boolean localSessionEnabled)
{    this.localSessionEnabled = localSessionEnabled;}
0
public void startAll() throws IOException
{    shutdownAll();    for (int i = 1; i <= ALL; ++i) {        start(i);            }        for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT));            }        if (disableJMXTest) {        return;    }        try {        JMXEnv.dump();                Set<String> ensureNames = new LinkedHashSet<String>();        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("InMemoryDataTree");        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");        }        for (int i = 1; i <= ALL; ++i) {            for (int j = 1; j <= ALL; ++j) {                ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);            }        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i);        }        JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    } catch (IOException e) {            } catch (InterruptedException e) {            }}
1
public void startQuorum() throws IOException
{    shutdownAll();    for (int i = 1; i <= N + 1; ++i) {        start(i);    }    for (int i = 1; i <= N + 1; ++i) {        assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(i).clientPort, ClientBase.CONNECTION_TIMEOUT));    }}
0
public void restart(int id) throws IOException
{    start(id);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT));}
0
public void shutdownAll()
{    for (int i = 1; i <= ALL; ++i) {        shutdown(i);    }    for (String hp : hostPort.split(",")) {        assertTrue("Waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }}
1
public void shutdown(int id)
{    QuorumPeer qp = getPeer(id).peer;    try {                qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {                        e.shutdown();        } else {                    }                qp.join(30000);        if (qp.isAlive()) {            fail("QP failed to shutdown in 30 seconds: " + qp.getName());        }    } catch (InterruptedException e) {            }}
1
public String getConnString()
{    return hostPort;}
0
public String getConnectString(QuorumPeer peer)
{    return "127.0.0.1:" + peer.getClientPort();}
0
public QuorumPeer getLeaderQuorumPeer()
{    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader != null) {            return ps.peer;        }    }    throw new RuntimeException("Unable to find a leader peer");}
0
public List<QuorumPeer> getFollowerQuorumPeers()
{    List<QuorumPeer> peerList = new ArrayList<QuorumPeer>(ALL - 1);    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader == null) {            peerList.add(ps.peer);        }    }    return Collections.unmodifiableList(peerList);}
0
public void tearDown() throws Exception
{        OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    shutdownAll();    JMXEnv.tearDown();}
1
public int getLeaderServer()
{    int index = 0;    for (int i = 1; i <= ALL; i++) {        if (getPeer(i).peer.leader != null) {            index = i;            break;        }    }    assertTrue("Leader server not found.", index > 0);    return index;}
0
public String getConnectionStringForServer(final int index)
{    return "127.0.0.1:" + getPeer(index).clientPort;}
0
public void validateAllMXBeanAreUnregistered() throws IOException
{    QuorumUtil qU = new QuorumUtil(1);        qU.startAll();        int leaderIndex = qU.getLeaderServer();    int firstFollowerIndex = 0;    int secondFollowerIndex = 0;    switch(leaderIndex) {        case 1:            firstFollowerIndex = 2;            secondFollowerIndex = 3;            break;        case 2:            firstFollowerIndex = 1;            secondFollowerIndex = 3;            break;        case 3:            firstFollowerIndex = 1;            secondFollowerIndex = 2;            break;        default:            fail("Unexpected leaderIndex value: " + leaderIndex);            break;    }        qU.shutdown(firstFollowerIndex);        qU.shutdown(secondFollowerIndex);        qU.restart(firstFollowerIndex);        qU.restart(secondFollowerIndex);    qU.shutdownAll();    Set<ZKMBeanInfo> pending = MBeanRegistry.getInstance().getRegisteredBeans();    assertTrue("The following beans should have been unregistered: " + pending, pending.isEmpty());}
1
public void setUp() throws Exception
{    qb.setUp();}
0
public void testBehindLeader() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    cleanAndInitializeDataDir(qb.s1dir);    cleanAndInitializeDataDir(qb.s2dir);    cleanAndInitializeDataDir(qb.s3dir);    cleanAndInitializeDataDir(qb.s4dir);    qb.setupServers();    qb.s1.start();    qb.s2.start();    qb.s3.start();    qb.s4.start();    assertTrue("Servers didn't come up", ClientBase.waitForServerUp(qb.hostPort, 10000));    qb.s5.start();    String hostPort = "127.0.0.1:" + qb.s5.getClientPort();    assertFalse("Servers came up, but shouldn't have since it's ahead of leader", ClientBase.waitForServerUp(hostPort, 10000));}
0
private void cleanAndInitializeDataDir(File f) throws IOException
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        c.delete();    }    ClientBase.createInitializeFile(f);}
0
public void testLateLogs() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    deleteLogs(qb.s1dir);    deleteLogs(qb.s2dir);    deleteLogs(qb.s3dir);    deleteLogs(qb.s4dir);    deleteLogs(qb.s5dir);    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    boolean saw2 = false;    for (String child : zk.getChildren("/", false)) {        if (child.equals("2")) {            saw2 = true;        }    }    zk.close();    assertTrue("Didn't see /2 (went back in time)", saw2);}
0
private void deleteLogs(File f)
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        if (c.getName().startsWith("log")) {            c.delete();        }    }}
0
public void tearDown() throws Exception
{    qb.tearDown();}
0
public void setUp() throws Exception
{    System.setProperty("readonlymode.enabled", "true");    qu.startQuorum();}
0
public void tearDown() throws Exception
{    System.setProperty("readonlymode.enabled", "false");    qu.tearDown();}
0
public void testMultiTransaction() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node1 = "/tnode1";    final String node2 = "/tnode2";    zk.create(node1, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in r-o mode", States.CONNECTEDREADONLY, zk.getState());        String remoteData = new String(zk.getData(node1, false, null));    assertEquals("Failed to read data in r-o mode", data, remoteData);    try {        Transaction transaction = zk.transaction();        transaction.setData(node1, "no way".getBytes(), -1);        transaction.create(node2, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        transaction.commit();        fail("Write operation using multi-transaction" + " api has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    assertNull("Should have created the znode:" + node2, zk.exists(node2, false));}
0
public void testReadOnlyClient() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node = "/tnode";    zk.create(node, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    zk.close();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);        String remoteData = new String(zk.getData(node, false, null));    assertEquals(data, remoteData);    try {        zk.setData(node, "no way".getBytes(), -1);        fail("Write operation has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));    zk.close();    watcher.reset();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.setData(node, "We're in the quorum now".getBytes(), -1);    zk.close();}
0
public void testConnectionEvents() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    boolean success = false;    for (int i = 0; i < 30; i++) {        try {            zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            success = true;            break;        } catch (KeeperException.ConnectionLossException e) {            Thread.sleep(1000);        }    }    assertTrue("Did not succeed in connecting in 30s", success);    assertFalse("The connection should not be read-only yet", watcher.readOnlyConnected);            qu.shutdown(2);            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    long start = Time.currentElapsedTime();    while (!(zk.getState() == States.CONNECTEDREADONLY)) {        Thread.sleep(200);                assertTrue("Can't connect to the server", Time.currentElapsedTime() - start < 30000);    }    watcher.waitForReadOnlyConnected(5000);    zk.close();}
0
public void testSessionEstablishment() throws Exception
{    qu.shutdown(2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertSame("should be in r/o mode", States.CONNECTEDREADONLY, zk.getState());    long fakeId = zk.getSessionId();        watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));                                watcher.waitForSyncConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in read-write mode", States.CONNECTED, zk.getState());        zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("fake session and real session have same id", zk.getSessionId() == fakeId);    zk.close();}
1
public void testSeekForRwServer() throws Exception
{        Layout layout = Logger.getRootLogger().getAppender("CONSOLE").getLayout();    ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = new WriterAppender(layout, os);    appender.setImmediateFlush(true);    appender.setThreshold(Level.INFO);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        qu.shutdown(2);        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);                qu.getPeer(1).peer.suspend();                        watcher.reset();        qu.start(2);        qu.start(3);        ClientBase.waitForServerUp(qu.getConnString(), 2000);        watcher.waitForConnected(CONNECTION_TIMEOUT);        zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                qu.getPeer(1).peer.resume();    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    Pattern p = Pattern.compile(".*Majority server found.*");    boolean found = false;    while ((line = r.readLine()) != null) {        if (p.matcher(line).matches()) {            found = true;            break;        }    }    assertTrue("Majority server wasn't found while connected to r/o server", found);}
0
public void setup() throws InterruptedException
{    System.setProperty(authProvider, superDigest);    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    resetZKAdmin();}
0
public void tearDown() throws Exception
{    System.clearProperty(authProvider);    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
0
public void testReconfigDisabled() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(false);    try {        reconfigPort();        fail("Reconfig should be disabled.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.RECONFIGDISABLED);    }}
0
public void testReconfigFailWithoutAuth() throws InterruptedException
{    try {        reconfigPort();        fail("Reconfig should fail without auth.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
0
public void testReconfigEnabledWithSuperUser() throws InterruptedException
{    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
0
public void testReconfigFailWithAuthWithNoACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail without a valid ACL associated with user.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
0
public void testReconfigEnabledWithAuthAndWrongACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());                ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail with an ACL that is read only!");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
0
public void testReconfigEnabledWithAuthAndACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
0
private void resetZKAdmin() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        if (zkAdmin != null) {            zkAdmin.close();        }        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
0
private boolean reconfigPort() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
0
public void setup() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    instantiateZKAdmin();}
0
public void tearDown() throws Exception
{    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
0
public void testReconfigFailWithoutSuperuserPasswordConfiguredOnServer() throws InterruptedException
{        try {        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }    try {        zkAdmin.addAuthInfo("digest", "super:".getBytes());        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
0
private void instantiateZKAdmin() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
0
private boolean reconfigPort() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
0
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
0
public void tearDown() throws Exception
{    closeAllHandles(zkArr, zkAdminArr);    if (qu != null) {        qu.tearDown();    }}
0
public static String reconfig(ZooKeeperAdmin zkAdmin, List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig) throws KeeperException, InterruptedException
{    byte[] config = null;    String failure = null;    for (int j = 0; j < 30; j++) {        try {            config = zkAdmin.reconfigure(joiningServers, leavingServers, newMembers, fromConfig, new Stat());            failure = null;            break;        } catch (KeeperException.ConnectionLossException e) {            failure = "client could not connect to reestablished quorum: giving up after 30+ seconds.";        } catch (KeeperException.ReconfigInProgress e) {            failure = "reconfig still in progress: giving up after 30+ seconds.";        }        Thread.sleep(1000);    }    if (failure != null) {        fail(failure);    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
0
public static String testServerHasConfig(ZooKeeper zk, List<String> joiningServers, List<String> leavingServers) throws KeeperException, InterruptedException
{    boolean testNodeExists = false;    byte[] config = null;    for (int j = 0; j < 30; j++) {        try {            if (!testNodeExists) {                createZNode(zk, "/dummy", "dummy");                testNodeExists = true;            }                                    zk.setData("/dummy", "dummy".getBytes(), -1);            config = zk.getConfig(false, new Stat());            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
0
public static void testNormalOperation(ZooKeeper writer, ZooKeeper reader) throws KeeperException, InterruptedException
{    boolean testReaderNodeExists = false;    boolean testWriterNodeExists = false;    for (int j = 0; j < 30; j++) {        try {            if (!testWriterNodeExists) {                createZNode(writer, "/test", "test");                testWriterNodeExists = true;            }            if (!testReaderNodeExists) {                createZNode(reader, "/dummy", "dummy");                testReaderNodeExists = true;            }            String data = "test" + j;            writer.setData("/test", data.getBytes(), -1);                                    reader.setData("/dummy", "dummy".getBytes(), -1);            byte[] res = reader.getData("/test", null, new Stat());            assertEquals(data, new String(res));            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }}
0
private static void createZNode(ZooKeeper zk, String path, String data) throws KeeperException, InterruptedException
{    try {        zk.create(path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {    }}
0
private int getLeaderId(QuorumUtil qu)
{    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    return leaderId;}
0
public static ZooKeeper[] createHandles(QuorumUtil qu) throws IOException
{            ZooKeeper[] zkArr = new ZooKeeper[qu.ALL + 1];        zkArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkArr[i] = new ZooKeeper("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    }    return zkArr;}
0
public static ZooKeeperAdmin[] createAdminHandles(QuorumUtil qu) throws IOException
{            ZooKeeperAdmin[] zkAdminArr = new ZooKeeperAdmin[qu.ALL + 1];        zkAdminArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkAdminArr[i] = new ZooKeeperAdmin("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[i].addAuthInfo("digest", "super:test".getBytes());    }    return zkAdminArr;}
0
public static void closeAllHandles(ZooKeeper[] zkArr, ZooKeeperAdmin[] zkAdminArr) throws InterruptedException
{    if (zkArr != null) {        for (ZooKeeper zk : zkArr) {            if (zk != null) {                zk.close();            }        }    }    if (zkAdminArr != null) {        for (ZooKeeperAdmin zkAdmin : zkAdminArr) {            if (zkAdmin != null) {                zkAdmin.close();            }        }    }}
0
public void testRemoveAddOne() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);            int leavingIndex = (leaderIndex == 1) ? 2 : 1;    for (int i = 0; i < 2; i++) {                                                        ZooKeeper zk1 = (leavingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeper zk2 = (leavingIndex == leaderIndex) ? zkArr[(leaderIndex % qu.ALL) + 1] : zkArr[leaderIndex];        ZooKeeperAdmin zkAdmin1 = (leavingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin2 = (leavingIndex == leaderIndex) ? zkAdminArr[(leaderIndex % qu.ALL) + 1] : zkAdminArr[leaderIndex];        leavingServers.add(Integer.toString(leavingIndex));                joiningServers.add("server." + leavingIndex + "=localhost:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex).peer.getClientPort());        String configStr = reconfig(zkAdmin1, null, leavingServers, null, -1);        testServerHasConfig(zk2, null, leavingServers);        testNormalOperation(zk2, zk1);        QuorumVerifier qv = qu.getPeer(1).peer.configFromString(configStr);        long version = qv.getVersion();                try {            reconfig(zkAdmin2, joiningServers, null, null, version + 1);            fail("reconfig succeeded even though version condition was incorrect!");        } catch (KeeperException.BadVersionException e) {        }        reconfig(zkAdmin2, joiningServers, null, null, version);        testNormalOperation(zk1, zk2);        testServerHasConfig(zk1, joiningServers, null);                        leavingIndex = leaderIndex = getLeaderId(qu);        leavingServers.clear();        joiningServers.clear();    }}
0
public void testRemoveAddTwo() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);        int leavingIndex1 = leaderIndex;    int leavingIndex2 = (leaderIndex == 1) ? 2 : 1;        int stayingIndex1 = 1, stayingIndex2 = 1, stayingIndex3 = 1;    while (stayingIndex1 == leavingIndex1 || stayingIndex1 == leavingIndex2) {        stayingIndex1++;    }    while (stayingIndex2 == leavingIndex1 || stayingIndex2 == leavingIndex2 || stayingIndex2 == stayingIndex1) {        stayingIndex2++;    }    while (stayingIndex3 == leavingIndex1 || stayingIndex3 == leavingIndex2 || stayingIndex3 == stayingIndex1 || stayingIndex3 == stayingIndex2) {        stayingIndex3++;    }    leavingServers.add(Integer.toString(leavingIndex1));    leavingServers.add(Integer.toString(leavingIndex2));        joiningServers.add("server." + leavingIndex1 + "=localhost:" + qu.getPeer(leavingIndex1).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex1).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex1).peer.getClientPort());        joiningServers.add("server." + leavingIndex2 + "=localhost:" + qu.getPeer(leavingIndex2).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex2).peer.getElectionAddress().getPort() + ":observer;localhost:" + qu.getPeer(leavingIndex2).peer.getClientPort());    qu.shutdown(leavingIndex1);    qu.shutdown(leavingIndex2);        reconfig(zkAdminArr[stayingIndex2], null, leavingServers, null, -1);    qu.shutdown(stayingIndex2);                testServerHasConfig(zkArr[stayingIndex1], null, leavingServers);    testServerHasConfig(zkArr[stayingIndex3], null, leavingServers);    testNormalOperation(zkArr[stayingIndex1], zkArr[stayingIndex3]);                        Thread.sleep(10000);    try {        reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }        qu.restart(stayingIndex2);    reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);    testNormalOperation(zkArr[stayingIndex2], zkArr[stayingIndex3]);    testServerHasConfig(zkArr[stayingIndex2], joiningServers, null);                qu.restart(leavingIndex2);    assertTrue(qu.getPeer(leavingIndex2).peer.getPeerState() == ServerState.OBSERVING);    testNormalOperation(zkArr[stayingIndex2], zkArr[leavingIndex2]);    testServerHasConfig(zkArr[leavingIndex2], joiningServers, null);}
0
public void testBulkReconfig() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            ArrayList<String> newServers = new ArrayList<String>();    for (int i = 1; i <= 5; i++) {        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + ((i == 4 || i == 5) ? "observer" : "participant") + ";localhost:" + qu.getPeer(i).peer.getClientPort();        newServers.add(server);    }    qu.shutdown(3);    qu.shutdown(6);    qu.shutdown(7);    reconfig(zkAdminArr[1], null, null, newServers, -1);    testNormalOperation(zkArr[1], zkArr[2]);    testServerHasConfig(zkArr[1], newServers, null);    testServerHasConfig(zkArr[2], newServers, null);    testServerHasConfig(zkArr[4], newServers, null);    testServerHasConfig(zkArr[5], newServers, null);    qu.shutdown(5);    qu.shutdown(4);    testNormalOperation(zkArr[1], zkArr[2]);}
0
public void testRemoveOneAsynchronous() throws Exception
{    qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();        leavingServers.add(getLeaderId(qu) == 5 ? "4" : "5");    List<Integer> results = new LinkedList<Integer>();    zkAdminArr[1].reconfigure(null, leavingServers, null, -1, this, results);    synchronized (results) {        while (results.size() < 1) {            results.wait();        }    }    assertEquals(0, (int) results.get(0));    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 5; i++) {        testServerHasConfig(zkArr[i], null, leavingServers);    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
0
public void testRoleChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);                    int changingIndex = (leaderIndex == 1) ? 2 : 1;            String newRole = "observer";    for (int i = 0; i < 4; i++) {                                                        ZooKeeper zk1 = (changingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin1 = (changingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];                joiningServers.add("server." + changingIndex + "=localhost:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";localhost:" + qu.getPeer(changingIndex).peer.getClientPort());        reconfig(zkAdmin1, joiningServers, null, null, -1);        testNormalOperation(zkArr[changingIndex], zk1);        if (newRole.equals("observer")) {            assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);        } else {            assertTrue(qu.getPeer(changingIndex).peer.observer == null && (qu.getPeer(changingIndex).peer.follower != null || qu.getPeer(changingIndex).peer.leader != null));            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.FOLLOWING || qu.getPeer(changingIndex).peer.getPeerState() == ServerState.LEADING);        }        joiningServers.clear();        if (newRole.equals("observer")) {            newRole = "participant";        } else {                        newRole = "observer";            leaderIndex = getLeaderId(qu);            changingIndex = leaderIndex;        }    }}
0
public void testPortChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;        int quorumPort = qu.getPeer(followerIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(followerIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(followerIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    joiningServers.add("server." + followerIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);            testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    reconfig(zkAdminArr[followerIndex], joiningServers, null, null, -1);    try {        for (int i = 0; i < 20; i++) {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);        }    } catch (KeeperException.ConnectionLossException e) {        fail("Existing client disconnected when client port changed!");    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    for (int i = 0; i < 10; i++) {        try {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to old client port!");        } catch (KeeperException.ConnectionLossException e) {        }    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    testServerHasConfig(zkArr[followerIndex], joiningServers, null);    assertEquals(newClientPort, qu.getPeer(followerIndex).peer.getClientPort());    joiningServers.clear();        int newQuorumPort = PortAssignment.unique();    joiningServers.add("server." + leaderIndex + "=localhost:" + newQuorumPort + ":" + qu.getPeer(leaderIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leaderIndex).peer.getClientPort());    reconfig(zkAdminArr[leaderIndex], joiningServers, null, null, -1);    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    assertTrue(qu.getPeer(leaderIndex).peer.getQuorumAddress().getPort() == newQuorumPort);    joiningServers.clear();    for (int i = 1; i <= 3; i++) {        joiningServers.add("server." + i + "=localhost:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + PortAssignment.unique() + ":participant;localhost:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], joiningServers, null, null, -1);    leaderIndex = getLeaderId(qu);    int follower1 = leaderIndex == 1 ? 2 : 1;    int follower2 = 1;    while (follower2 == leaderIndex || follower2 == follower1) {        follower2++;    }        qu.shutdown(getLeaderId(qu));    testNormalOperation(zkArr[follower2], zkArr[follower1]);    testServerHasConfig(zkArr[follower1], joiningServers, null);    testServerHasConfig(zkArr[follower2], joiningServers, null);}
0
public void testPortChangeToBlockedPortFollower() throws Exception
{    testPortChangeToBlockedPort(false);}
0
public void testPortChangeToBlockedPortLeader() throws Exception
{    testPortChangeToBlockedPort(true);}
0
private void testPortChangeToBlockedPort(boolean testLeader) throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;    int serverIndex = testLeader ? leaderIndex : followerIndex;    int reconfigIndex = testLeader ? followerIndex : leaderIndex;        int quorumPort = qu.getPeer(serverIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(serverIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(serverIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    try (ServerSocket ss = new ServerSocket()) {        ss.bind(new InetSocketAddress(getLoopbackAddress(), newClientPort));        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);                        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);                reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        Thread.sleep(1000);                zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[serverIndex].close();        zkAdminArr[serverIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        try {            Thread.sleep(1000);            zkArr[serverIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to new client port!");        } catch (KeeperException.ConnectionLossException e) {                }        try (ServerSocket ss2 = new ServerSocket()) {            ss2.bind(new InetSocketAddress(getLoopbackAddress(), oldClientPort));        }                joiningServers.clear();        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + oldClientPort);        reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);        testServerHasConfig(zkArr[serverIndex], joiningServers, null);        assertEquals(oldClientPort, qu.getPeer(serverIndex).peer.getClientPort());    }}
0
public void testUnspecifiedClientAddress() throws Exception
{    int[] ports = { PortAssignment.unique(), PortAssignment.unique(), PortAssignment.unique() };    String server = "server.0=localhost:" + ports[0] + ":" + ports[1] + ";" + ports[2];    QuorumServer qs = new QuorumServer(0, server);    assertEquals(qs.clientAddr.getHostString(), "0.0.0.0");    assertEquals(qs.clientAddr.getPort(), ports[2]);}
0
public void testQuorumSystemChange() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    ArrayList<String> members = new ArrayList<>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[2], zkArr[3]);    testNormalOperation(zkArr[4], zkArr[5]);    for (int i = 1; i <= 5; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumHierarchical)) {            fail("peer " + i + " doesn't think the quorum system is Hieararchical!");        }    }    qu.shutdown(1);    qu.shutdown(2);    qu.shutdown(3);    qu.shutdown(7);    qu.shutdown(6);        testNormalOperation(zkArr[4], zkArr[5]);    qu.restart(1);    qu.restart(2);    members.clear();    for (int i = 1; i <= 3; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[1], zkArr[2]);    qu.shutdown(4);    qu.shutdown(5);        testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 2; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumMaj)) {            fail("peer " + i + " doesn't think the quorum system is a majority quorum system!");        }    }}
0
public void testInitialConfigHasPositiveVersion() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i < 4; i++) {        String configStr = testServerHasConfig(zkArr[i], null, null);        QuorumVerifier qv = qu.getPeer(i).peer.configFromString(configStr);        long version = qv.getVersion();        assertTrue(version == 0x100000000L);    }}
0
public void testJMXBeanAfterRemoveAddOne() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();        int leavingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);    ZooKeeper zk = zkArr[leavingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[leavingIndex];    leavingServers.add(Integer.toString(leavingIndex));        joiningServers.add("server." + leavingIndex + "=127.0.0.1:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;127.0.0.1:" + qu.getPeer(leavingIndex).peer.getClientPort());        reconfig(zkAdmin, null, leavingServers, null, -1);        QuorumPeer removedPeer = qu.getPeer(leavingIndex).peer;    String localPeerBean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + leavingIndex + ",name1=replica." + leavingIndex;    assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, false);        JMXEnv.ensureNone(remotePeerBean2);        JMXEnv.ensureNone(remotePeerBean3);        reconfig(zkAdmin, joiningServers, null, null, -1);        assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, true);        leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);}
0
public void testJMXBeanAfterRoleChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();        int changingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);    String newRole = "observer";    ZooKeeper zk = zkArr[changingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[changingIndex];        joiningServers.add("server." + changingIndex + "=127.0.0.1:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";127.0.0.1:" + qu.getPeer(changingIndex).peer.getClientPort());    reconfig(zkAdmin, joiningServers, null, null, -1);    testNormalOperation(zkArr[changingIndex], zk);    assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);    assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);    QuorumPeer qp = qu.getPeer(changingIndex).peer;    String localPeerBeanName = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + changingIndex + ",name1=replica." + changingIndex;        assertLocalPeerMXBeanAttributes(qp, localPeerBeanName, true);        changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);}
0
private void assertLocalPeerMXBeanAttributes(QuorumPeer qp, String beanName, Boolean isPartOfEnsemble) throws Exception
{    assertEquals("Mismatches LearnerType!", qp.getLearnerType().name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", qp.getClientAddress().getHostString() + ":" + qp.getClientAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ClientAddress"));    assertEquals("Mismatches LearnerType!", qp.getElectionAddress().getHostString() + ":" + qp.getElectionAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ElectionAddress"));    assertEquals("Mismatches PartOfEnsemble!", isPartOfEnsemble, JMXEnv.ensureBeanAttribute(beanName, "PartOfEnsemble"));    assertEquals("Mismatches ConfigVersion!", qp.getQuorumVerifier().getVersion(), JMXEnv.ensureBeanAttribute(beanName, "ConfigVersion"));    assertEquals("Mismatches QuorumSystemInfo!", qp.getQuorumVerifier().toString(), JMXEnv.ensureBeanAttribute(beanName, "QuorumSystemInfo"));}
0
 String getAddrPortFromBean(String beanName, String attribute) throws Exception
{    String name = (String) JMXEnv.ensureBeanAttribute(beanName, attribute);    if (!name.contains(":")) {        return name;    }    return getNumericalAddrPort(name);}
0
 String getNumericalAddrPort(String name) throws UnknownHostException
{    String port = name.split(":")[1];    String addr = name.split(":")[0];    addr = InetAddress.getByName(addr).getHostAddress();    return addr + ":" + port;}
0
private void assertRemotePeerMXBeanAttributes(QuorumServer qs, String beanName) throws Exception
{    assertEquals("Mismatches LearnerType!", qs.type.name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", getNumericalAddrPort(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort()), getAddrPortFromBean(beanName, "ClientAddress"));    assertEquals("Mismatches ElectionAddress!", getNumericalAddrPort(qs.electionAddr.getHostString() + ":" + qs.electionAddr.getPort()), getAddrPortFromBean(beanName, "ElectionAddress"));    assertEquals("Mismatches QuorumAddress!", getNumericalAddrPort(qs.addr.getHostString() + ":" + qs.addr.getPort()), getAddrPortFromBean(beanName, "QuorumAddress"));}
0
public void testRecovery() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    int oldSnapCount = SyncRequestProcessor.getSnapCount();    SyncRequestProcessor.setSnapCount(1000);    try {        final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);        f.startup(zks);                assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal = new CountDownLatch(1);        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        String path;                for (int i = 0; i < 10; i++) {            path = "/" + i;            zk.create(path, (path + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                zk.create(subpath, (subpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    zk.create(subsubpath, (subsubpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        Stat stat = new Stat();        for (int i = 0; i < 10; i++) {            path = "/" + i;                        assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        stat = new Stat();                for (int i = 0; i < 10; i++) {            path = "/" + i;            assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    } finally {        SyncRequestProcessor.setSnapCount(oldSnapCount);    }}
1
public void process(WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
1
public void testFail() throws Exception
{    QuorumBase qb = new QuorumBase();    qb.setUp();    System.out.println("Comment: the servers are at " + qb.hostPort);    ZooKeeper zk = qb.createClient();    zk.create("/test", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    QuorumBase.shutdown(qb.s1);    QuorumBase.shutdown(qb.s2);    QuorumBase.shutdown(qb.s3);    QuorumBase.shutdown(qb.s4);    QuorumBase.shutdown(qb.s5);    String hp = qb.hostPort.split(",")[0];    ZooKeeperServer zks = new ZooKeeperServer(qb.s1.getTxnFactory().getSnapDir(), qb.s1.getTxnFactory().getDataDir(), 3000);    final int PORT = Integer.parseInt(hp.split(":")[1]);    ServerCnxnFactory factory = ServerCnxnFactory.createFactory(PORT, -1);    factory.startup(zks);    System.out.println("Comment: starting factory");    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    factory.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    System.out.println("Comment: shutting down standalone");}
0
public void testResponseCache() throws Exception
{    ZooKeeper zk = createClient();    try {        performCacheTest(zk, "/cache", true);        performCacheTest(zk, "/nocache", false);    } finally {        zk.close();    }}
0
private void checkCacheStatus(long expectedHits, long expectedMisses)
{    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    assertEquals(expectedHits, metrics.get("response_packet_cache_hits"));    assertEquals(expectedMisses, metrics.get("response_packet_cache_misses"));}
0
public void performCacheTest(ZooKeeper zk, String path, boolean useCache) throws Exception
{    ServerMetrics.getMetrics().resetAll();    Stat writeStat = new Stat();    Stat readStat = new Stat();    byte[] readData = null;    int reads = 10;    long expectedHits = 0;    long expectedMisses = 0;    serverFactory.getZooKeeperServer().setResponseCachingEnabled(useCache);        byte[] writeData = "test1".getBytes();    zk.create(path, writeData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, writeStat);    for (int i = 0; i < reads; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);    writeData = "test2".getBytes();    writeStat = zk.setData(path, writeData, -1);    for (int i = 0; i < 10; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);                    zk.create(path + "/child", "child".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    readData = zk.getData(path, false, readStat);    if (useCache) {        expectedMisses++;    }    assertArrayEquals(writeData, readData);    assertNotSame(writeStat, readStat);    checkCacheStatus(expectedHits, expectedMisses);}
1
public void testRestoreCommittedLogWithSnapSize() throws Exception
{    final int minExpectedSnapshots = 5;    final int minTxnsToSnap = 256;    final int numTransactions = minExpectedSnapshots * minTxnsToSnap;    final StringBuilder sb = new StringBuilder();    for (int i = 0; i < 4 * 1024; i++) {        sb.append("0");    }    final byte[] data = sb.toString().getBytes();    SyncRequestProcessor.setSnapCount(numTransactions * 1000);                SyncRequestProcessor.setSnapSizeInBytes(minTxnsToSnap * data.length);    testRestoreCommittedLog(numTransactions, data, minExpectedSnapshots);}
0
public void testRestoreCommittedLogWithSnapCount() throws Exception
{    final int minExpectedSnapshots = 30;    final int snapCount = 100;    SyncRequestProcessor.setSnapCount(snapCount);    SyncRequestProcessor.setSnapSizeInBytes(4294967296L);    testRestoreCommittedLog(minExpectedSnapshots * snapCount, new byte[0], minExpectedSnapshots);}
0
private void testRestoreCommittedLog(int totalTransactions, byte[] data, int minExpectedSnapshots) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < totalTransactions; i++) {            zk.create("/invalidsnap-" + i, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    final int numSnaps = zks.getTxnLogFactory().findNRecentSnapshots(10 * minExpectedSnapshots).size();        f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    assertTrue("too few snapshot files", numSnaps > minExpectedSnapshots);    assertTrue("too many snapshot files", numSnaps <= minExpectedSnapshots * 2);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    Collection<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();    int logsize = committedLog.size();        assertTrue("log size != 0", (logsize != 0));    zks.shutdown();}
1
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void testSaslConfig() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getChildren("/", false);        assertFalse(zk.getSaslClient().clientTunneledAuthenticationInProgress());        assertEquals(zk.getSaslClient().getSaslState(), ZooKeeperSaslClient.SaslState.COMPLETE);        assertNotNull(javax.security.auth.login.Configuration.getConfiguration().getAppConfigurationEntry("MyZookeeperClient"));        assertSame(zk.getSaslClient().getLoginContext(), "MyZookeeperClient");    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void testReadAccessUser() throws Exception
{    System.setProperty("zookeeper.letAnySaslUserDoX", "anyone");    ZooKeeper zk = createClient();    List<ACL> aclList = new ArrayList<ACL>();    ACL acl = new ACL(Perms.ADMIN | Perms.CREATE | Perms.WRITE | Perms.DELETE, new Id("sasl", "fakeuser"));    ACL acl1 = new ACL(Perms.READ, new Id("sasl", "anyone"));    aclList.add(acl);    aclList.add(acl1);    try {        zk.create("/abc", "testData".getBytes(), aclList, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Unable to create znode");    }    zk.close();    Thread.sleep(100);        zk = createClient();    try {        zk.setData("/abc", "testData1".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException.NoAuthException e) {        }    try {        byte[] bytedata = zk.getData("/abc", null, null);        String data = new String(bytedata);        assertTrue("testData".equals(data));    } catch (KeeperException e) {        fail("failed to get data");    }    zk.close();    Thread.sleep(100);        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "false");    try {        zk = createClient();        try {            zk.getData("/abc", null, null);            fail("Should not be able to read data when not authenticated");        } catch (KeeperException.NoAuthException e) {                }        zk.close();    } finally {                System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "true");    }}
0
public synchronized void reset()
{    authCompleted = new CountDownLatch(1);    super.reset();}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();        authCompleted.countDown();    } else if (event.getState() == KeeperState.SaslAuthenticated) {        authCompleted.countDown();    } else {        super.process(event);    }}
0
public void testAuth() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = createClient(watcher);    watcher.authCompleted.await(AUTHENTICATION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(authFailed.get(), 0);    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
0
public void testAuth() throws Exception
{            CountdownWatcher watcher = new CountdownWatcher();    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                    } finally {        zk.close();    }}
1
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
0
public void testAuthFail()
{    try (ZooKeeper zk = createClient()) {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (Exception e) {                    }}
1
public void testBadSaslAuthNotifiesWatch() throws Exception
{    try (ZooKeeper ignored = createClient(new MyWatcher(), hostPort)) {                authFailed.await();    }}
0
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                    } finally {        zk.close();    }}
1
public void setup()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");}
0
public void tearDown() throws Exception
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);}
0
public void testClientOpWithoutSASLConfigured() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client is not configured with SASL authentication, so zk.create operation should fail.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH);                        watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
0
public static void setUpBeforeClass()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas_wrong.conf", "test1"));}
0
public static void tearDownAfterClass()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
0
public void testClientOpWithFailedSASLAuth() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/bar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client with wrong SASL config should not pass SASL authentication.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.AUTHFAILED);                watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
0
public static void setUpBeforeClass()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas.conf", "test"));}
0
public static void tearDownAfterClass()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
0
public void testClientOpWithValidSASLAuth() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foobar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Client operation should succeed with valid SASL configuration.");    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void setUp()
{    existingPropertyValue = System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);}
0
public void tearDown()
{        if (existingPropertyValue != null) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, existingPropertyValue);    }}
0
public void testSaslClientDisabled()
{    System.clearProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);    assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    for (String value : Arrays.asList("true", "TRUE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }    for (String value : Arrays.asList("false", "FALSE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertFalse("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }}
0
public static void setupStatic() throws Exception
{    oldAuthProvider = System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    File tmpDir = createTmpDir();    File saslConfFile = new File(tmpDir, "jaas.conf");    FileWriter fwriter = new FileWriter(saslConfFile);    fwriter.write("" + "Server {\n" + "          org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "          user_super_duper=\"test\";\n" + "};\n" + "Client {\n" + "       org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "       username=\"super_duper\"\n" + "       password=\"test\";\n" + "};" + "\n");    fwriter.close();    oldLoginConfig = System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    oldSuperUser = System.setProperty("zookeeper.superUser", "super_duper");    otherDigestUser = new Id("digest", DigestAuthenticationProvider.generateDigest("jack:jack"));}
0
public static void cleanupStatic()
{    if (oldAuthProvider != null) {        System.setProperty("zookeeper.authProvider.1", oldAuthProvider);    } else {        System.clearProperty("zookeeper.authProvider.1");    }    oldAuthProvider = null;    if (oldLoginConfig != null) {        System.setProperty("java.security.auth.login.config", oldLoginConfig);    } else {        System.clearProperty("java.security.auth.login.config");    }    oldLoginConfig = null;    if (oldSuperUser != null) {        System.setProperty("zookeeper.superUser", oldSuperUser);    } else {        System.clearProperty("zookeeper.superUser");    }    oldSuperUser = null;}
0
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
0
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();    } else {        super.process(event);    }}
0
public void testSuperIsSuper() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/digest_read", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/digest_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.delete("/digest_read/sub", -1);        zk.delete("/digest_read", -1);        zk.delete("/sasl_read/sub", -1);        zk.delete("/sasl_read", -1);                assertEquals(authFailed.get(), 0);    } finally {        zk.close();    }}
0
 static String createJAASConfigFile(String fileName, String password)
{    String ret = null;    try {        File tmpDir = createTmpDir();        File jaasFile = new File(tmpDir, fileName);        FileWriter fwriter = new FileWriter(jaasFile);        fwriter.write("" + "Server {\n" + "          " + digestLoginModule + " required\n" + "          user_super=\"test\";\n" + "};\n" + "Client {\n" + "       " + digestLoginModule + " required\n" + "       username=\"super\"\n" + "       password=\"" + password + "\";\n" + "};" + "\n");        fwriter.close();        ret = jaasFile.getAbsolutePath();    } catch (IOException e) {        fail("Unable to create JaaS configuration file!");    }    return ret;}
0
public void setUp() throws Exception
{    System.setProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, Integer.toString(cnxnTimeout));    super.setUp();}
0
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT);}
0
public void testServerCnxnExpiry() throws Exception
{    verify("ruok", "imok");                String resp = sendRequest("ruok", 2 * cnxnTimeout + 1000);    assertEquals("Connection should have closed", "", resp);}
0
private void verify(String cmd, String expected) throws IOException
{    String resp = sendRequest(cmd, 0);        assertTrue(resp.contains(expected));}
1
private String sendRequest(String cmd, int delay) throws IOException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, delay);}
0
private static String send4LetterWord(String host, int port, String cmd, int delay) throws IOException
{        Socket sock = new Socket(host, port);    BufferedReader reader = null;    try {        try {                        Thread.sleep(delay);        } catch (InterruptedException e) {                }        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                sock.shutdownOutput();        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = readLine(reader);        return sb.toString();    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
1
private static StringBuilder readLine(BufferedReader reader)
{    StringBuilder sb = new StringBuilder();    String line;    try {        while ((line = reader.readLine()) != null) {            sb.append(line + "\n");        }    } catch (IOException ioe) {                                            }    return sb;}
1
public void testCreateAfterCloseShouldFail() throws Exception
{    for (int i = 0; i < 10; i++) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(44, "len");        ConnectRequest conReq = new ConnectRequest(0, 0, 30000, 0, new byte[16]);        conReq.serialize(boa, "connect");                boa.writeInt(8, "len");        RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.closeSession);        h.serialize(boa, "header");                        boa.writeInt(52, "len");        RequestHeader header = new RequestHeader(2, OpCode.create);        header.serialize(boa, "header");        CreateRequest createReq = new CreateRequest("/foo" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, 1);        createReq.serialize(boa, "request");        baos.close();        System.out.println("Length:" + baos.toByteArray().length);        String[] hp = hostPort.split(":");        Socket sock = new Socket(hp[0], Integer.parseInt(hp[1]));        InputStream resultStream = null;        try {            OutputStream outstream = sock.getOutputStream();            byte[] data = baos.toByteArray();            outstream.write(data);            outstream.flush();            resultStream = sock.getInputStream();            byte[] b = new byte[10000];            int len;            while ((len = resultStream.read(b)) >= 0) {                                System.out.println("gotlen:" + len);            }        } finally {            if (resultStream != null) {                resultStream.close();            }            sock.close();        }    }    ZooKeeper zk = createClient();    assertEquals(1, zk.getChildren("/", false).size());    zk.close();}
0
public void setUp() throws Exception
{    if (tmpDir == null) {        tmpDir = ClientBase.createTmpDir();    }    ClientBase.setupTestEnv();    zs = new ZooKeeperServer(tmpDir, tmpDir, TICK_TIME);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    serverFactory = ServerCnxnFactory.createFactory(PORT, -1);    serverFactory.startup(zs);    assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));}
0
public void tearDown() throws Exception
{    serverFactory.shutdown();    zs.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
0
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
0
private DisconnectableZooKeeper createClient() throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(CONNECTION_TIMEOUT, watcher);}
0
private DisconnectableZooKeeper createClient(int timeout) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(timeout, watcher);}
0
private DisconnectableZooKeeper createClient(int timeout, CountdownWatcher watcher) throws IOException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
0
public void process(WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
1
public void testSession() throws IOException, InterruptedException, KeeperException
{    DisconnectableZooKeeper zk = createClient();    zk.create("/e", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);                    zk.disconnect();    Stat stat = new Stat();    startSignal = new CountDownLatch(1);    zk = new DisconnectableZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, new MyWatcher("testSession"), zk.getSessionId(), zk.getSessionPasswd());    startSignal.await();        zk.getData("/e", false, stat);        zk.close();    zk = createClient();    assertEquals(null, zk.exists("/e", false));        zk.close();    try {        zk.getData("/e", false, stat);        fail("Should have received a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {    }    AsyncCallback.DataCallback cb = new AsyncCallback.DataCallback() {        String status = "not done";        public void processResult(int rc, String p, Object c, byte[] b, Stat s) {            synchronized (this) {                status = KeeperException.Code.get(rc).toString();                this.notify();            }        }        public String toString() {            return status;        }    };    zk.getData("/e", false, cb, null);    synchronized (cb) {        if (cb.toString().equals("not done")) {            cb.wait(1000);        }    }    assertEquals(KeeperException.Code.SESSIONEXPIRED.toString(), cb.toString());}
1
public void processResult(int rc, String p, Object c, byte[] b, Stat s)
{    synchronized (this) {        status = KeeperException.Code.get(rc).toString();        this.notify();    }}
0
public String toString()
{    return status;}
0
public void testSessionMove() throws Exception
{    String[] hostPorts = HOSTPORT.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], CONNECTION_TIMEOUT, new MyWatcher("0"));    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }                assertTrue(result[0] == KeeperException.Code.OK.intValue());        zknew.setData("/", new byte[1], -1);        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {                    }                zk = zknew;    }    zk.close();}
1
public void processResult(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
0
public void testSessionStateNoDupStateReporting() throws IOException, InterruptedException, KeeperException
{    final int TIMEOUT = 3000;    DupWatcher watcher = new DupWatcher();    ZooKeeper zk = createClient(TIMEOUT, watcher);        serverFactory.shutdown();    try {        Thread.sleep(10000);    } catch (InterruptedException e) {        }                    assertEquals(2, watcher.states.size());    zk.close();}
0
public void testSessionTimeoutAccess() throws Exception
{        DisconnectableZooKeeper zk = createClient(TICK_TIME * 4);    assertEquals(TICK_TIME * 4, zk.getSessionTimeout());            zk.close();            zk = createClient(TICK_TIME);    assertEquals(TICK_TIME * 2, zk.getSessionTimeout());        zk.close();            zk = createClient(TICK_TIME * 30);    assertEquals(TICK_TIME * 20, zk.getSessionTimeout());        zk.close();    }
1
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() == EventType.None) {        states.add(event);    }}
0
public void testMinMaxSessionTimeout() throws Exception
{        final int MINSESS = 20000;    final int MAXSESS = 240000;    {        ZooKeeperServer zs = serverFactory.getZooKeeperServer();        zs.setMinSessionTimeout(MINSESS);        zs.setMaxSessionTimeout(MAXSESS);    }        int timeout = 120000;    DisconnectableZooKeeper zk = createClient(timeout);    assertEquals(timeout, zk.getSessionTimeout());            zk.close();            zk = createClient(MINSESS / 2);    assertEquals(MINSESS, zk.getSessionTimeout());        zk.close();            zk = createClient(MAXSESS * 2);    assertEquals(MAXSESS, zk.getSessionTimeout());        zk.close();    }
1
public void testMaximumCnxnPerIP() throws Exception
{    final int maxClientCnxnsPerIP = 3;    serverFactory.setMaxClientCnxnsPerHost(maxClientCnxnsPerIP);    ZooKeeper[] clients = new ZooKeeper[maxClientCnxnsPerIP + 1];    for (int i = 0; i < clients.length; i++) {        CountdownWatcher watcher = new CountdownWatcher();                int timeout = 3000;        clients[i] = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);        boolean result = watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS);        if (i >= maxClientCnxnsPerIP) {            assertFalse(result);        } else {            assertTrue(result);        }    }}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
0
public void testSessionExpiration() throws InterruptedException, KeeperException
{    final CountDownLatch expirationLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getState() == Watcher.Event.KeeperState.Expired) {            expirationLatch.countDown();        }    };    zk.exists("/foo", watcher);    zk.getTestable().injectSessionExpiration();    assertTrue(expirationLatch.await(5, TimeUnit.SECONDS));    boolean gotException = false;    try {        zk.exists("/foo", false);        fail("Should have thrown a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {                gotException = true;    }    assertTrue(gotException);}
0
public void testQueueEvent() throws InterruptedException, KeeperException
{    final CountDownLatch eventLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/foo/bar")) {                eventLatch.countDown();            }        }    };    zk.exists("/foo/bar", watcher);    WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.NodeDataChanged, Watcher.Event.KeeperState.SyncConnected, "/foo/bar");    zk.getTestable().queueEvent(event);    assertTrue(eventLatch.await(5, TimeUnit.SECONDS));}
0
public void testSessionDisconnect() throws KeeperException, InterruptedException, IOException
{    zk.create("/sdisconnect", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdisconnect", null));    zk.close();    zk = createClient();    assertNull("Ephemeral node shouldn't exist after client disconnect", zk.exists("/sdisconnect", null));}
0
public void testSessionRestore() throws KeeperException, InterruptedException, IOException
{    zk.create("/srestore", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/srestore", null));    zk.disconnect();    zk.close();    zk = createClient();    assertNotNull("Ephemeral node should be present when session is restored", zk.exists("/srestore", null));}
0
public void testSessionSurviveServerRestart() throws Exception
{    zk.create("/sdeath", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdeath", null));    zk.disconnect();    stopServer();    startServer();    zk = createClient();    assertNotNull("Ephemeral node should be present when server restarted", zk.exists("/sdeath", null));}
0
public void expire(Session session)
{}
0
public long getServerId()
{    return sid;}
0
public void setUp() throws Exception
{    sessionsWithTimeouts.clear();}
0
public void tearDown() throws Exception
{}
0
public void testLearnerSessionTracker() throws Exception
{    Expirer expirer = new Expirer(1);        LearnerSessionTracker tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = 0xb100ded;    try {        tracker.checkSession(sessionId, null);        fail("Unknown session should have failed");    } catch (SessionExpiredException e) {        }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session should not fail");    }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }        tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Should not get any exception");    }}
0
public void testLeaderSessionTracker() throws Exception
{    Expirer expirer = new Expirer(2);        LeaderSessionTracker tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = ((expirer.sid + 1) << 56) + 1;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("local session from other server should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session on the leader should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = ((expirer.sid + 1) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from other server should fail");    } catch (SessionExpiredException e) {        }        sessionId = ((expirer.sid) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from the leader should fail");    } catch (SessionExpiredException e) {        }}
0
 ZooKeeperServerListener testZKSListener()
{    return new ZooKeeperServerListener() {        @Override        public void notifyStopping(String errMsg, int exitCode) {        }    };}
0
public void notifyStopping(String errMsg, int exitCode)
{}
0
public void setUp() throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
1
public void tearDown() throws Exception
{        qb.tearDown();}
1
public void testLocalSessionsWithoutEphemeralOnFollower() throws Exception
{    testLocalSessionsWithoutEphemeral(false);}
0
public void testLocalSessionsWithoutEphemeralOnLeader() throws Exception
{    testLocalSessionsWithoutEphemeral(true);}
0
private void testLocalSessionsWithoutEphemeral(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();        try {        watcher.reset();        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Connection on the same session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    } catch (KeeperException.ConnectionLossException e) {    }        if (!testLeader) {        try {            watcher.reset();            DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[leaderIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);            zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("Connection on the same session ID should fail.");        } catch (KeeperException.SessionExpiredException e) {        } catch (KeeperException.ConnectionLossException e) {        }    }                zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.create(nodePrefix + "6", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.create(nodePrefix + "7", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }}
0
public void testUpgradeWithEphemeralOnFollower() throws Exception
{    testUpgradeWithEphemeral(false);}
0
public void testUpgradeWithEphemeralOnLeader() throws Exception
{    testUpgradeWithEphemeral(true);}
0
private void testUpgradeWithEphemeral(boolean testLeader) throws Exception
{    String nodePrefix = "/testUpgrade-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }            long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();    zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        assertNotNull(zk.exists(nodePrefix + i, null));    }            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.exists(nodePrefix + "0", null);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }    watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    for (int i = 0; i < 5; i++) {        assertNull(zk.exists(nodePrefix + i, null));    }}
0
public void run()
{    try {        Stat stat = new Stat();        String path = zk.create("/hammers/hammer-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        byte[] tag = (path + " was here!").getBytes();        synchronized (this) {            String startPath = "/hammers/start";            System.out.println("Waiting for " + startPath);            while (zk.exists(startPath, true) == null) {                wait();            }            System.out.println("Running");        }        for (int i = 0; i < count; i++) {            try {                System.out.print(i + "\r");                List<String> childs = zk.getChildren("/hammers", false);                Collections.shuffle(childs);                for (String s : childs) {                    if (s.startsWith("hammer-")) {                        s = "/hammers/" + s;                        zk.setData(s, tag, -1);                        for (int j = 0; j < readsPerWrite; j++) {                            zk.getData(s, false, stat);                        }                        break;                    }                }            } catch (KeeperException.ConnectionLossException e) {                        } catch (KeeperException e) {                e.printStackTrace();            }        }        System.out.println();        zk.close();    } catch (RuntimeException e) {        e.printStackTrace();    } catch (InterruptedException e) {        e.printStackTrace();    } catch (KeeperException e) {        e.printStackTrace();    }}
0
public static void main(String[] args) throws Exception
{    if (args.length != 3) {        System.err.println("USAGE: SledgeHammer zookeeper_server reps reads_per_rep");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    }    SledgeHammer h = new SledgeHammer(args[0], Integer.parseInt(args[1]), Integer.parseInt(args[2]));    h.start();    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
0
public static ClientX509Util setUpSecure() throws Exception
{    ClientX509Util x509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(x509Util.getSslAuthProviderProperty(), "x509");    System.setProperty(x509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(x509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(x509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(x509Util.getSslTruststorePasswdProperty(), "testpass");    System.setProperty("javax.net.debug", "ssl");    System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");    return x509Util;}
0
public static void clearSecureSetting(ClientX509Util clientX509Util)
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    System.clearProperty("javax.net.debug");    System.clearProperty("zookeeper.authProvider.x509");    clientX509Util.close();}
0
public void setUp() throws Exception
{    clientX509Util = setUpSecure();    String host = "localhost";    int port = PortAssignment.unique();    hostPort = host + ":" + port;    serverFactory = ServerCnxnFactory.createFactory();    serverFactory.configure(new InetSocketAddress(host, port), maxCnxns, -1, true);    super.setUp();}
0
public void teardown() throws Exception
{    clearSecureSetting(clientX509Util);}
0
public void testRejection() throws Exception
{    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");        System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testUntrustedKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    CountdownWatcher watcher = new CountdownWatcher();        new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Untrusted certificate should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
0
public void testMisconfiguration() throws Exception
{    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    CountdownWatcher watcher = new CountdownWatcher();    new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Missing SSL configuration should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
0
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
0
public void testNoDynamicConfig() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, CLIENT_PORT, "", false);    verifyStandalone(mt, CLIENT_PORT);}
0
public void testClientPortInDynamicFile() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection);    verifyStandalone(mt, CLIENT_PORT);}
0
public void testClientPortInStaticFile() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection, false);    verifyStandalone(mt, CLIENT_PORT);}
0
 void verifyStandalone(MainThread mt, int clientPort) throws InterruptedException
{    mt.start();    try {        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    } finally {        assertFalse("Error- MainThread started in Quorum Mode!", mt.isQuorumPeerRunning());        mt.shutdown();    }}
0
public void testStandaloneReconfigFails() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, watcher);    ZooKeeperAdmin zkAdmin = new ZooKeeperAdmin(HOSTPORT, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    List<String> joiners = new ArrayList<String>();    joiners.add("server.2=localhost:1234:1235;1236");        try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        zkAdmin.reconfigure(joiners, null, null, -1, new Stat());        fail("Reconfiguration in standalone should trigger " + "UnimplementedException");    } catch (KeeperException.UnimplementedException ex) {        }    zk.close();    zks.shutdown();    f.shutdown();    assertTrue("waiting for server being down ", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
0
public void testNextGoesRound()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    hostProvider.next(0);    assertEquals(first, hostProvider.next(0));}
0
public void testNextGoesRoundAndSleeps()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(1000);    long stop = Time.currentElapsedTime();    assertTrue(900 <= stop - start);}
0
public void testNextDoesNotSleepForZero()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(0);    long stop = Time.currentElapsedTime();    assertTrue(5 > stop - start);}
0
public void testEmptyServerAddressesList()
{    HostProvider hp = new StaticHostProvider(new ArrayList<>());}
0
public void testInvalidHostAddresses()
{        final List<InetSocketAddress> invalidAddresses = new ArrayList<>();    InetSocketAddress unresolved = InetSocketAddress.createUnresolved("a", 1234);    invalidAddresses.add(unresolved);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) throws UnknownHostException {            throw new UnknownHostException();        }    };    StaticHostProvider sp = new StaticHostProvider(invalidAddresses, resolver);        InetSocketAddress n1 = sp.next(0);    assertTrue("Provider should return unresolved address is host is unresolvable", n1.isUnresolved());    assertSame("Provider should return original address is host is unresolvable", unresolved, n1);}
0
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    throw new UnknownHostException();}
0
public void testTwoConsequitiveCallsToNextReturnDifferentElement()
{    HostProvider hostProvider = getHostProvider((byte) 2);    assertNotSame(hostProvider.next(0), hostProvider.next(0));}
0
public void testOnConnectDoesNotReset()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    hostProvider.onConnected();    InetSocketAddress second = hostProvider.next(0);    assertNotSame(first, second);}
0
public void testUpdateClientMigrateOrNot() throws UnknownHostException
{        HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = getServerAddresses((byte) 3);    InetSocketAddress myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 3 }), 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();        disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();                newList = getServerAddresses((byte) 2);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();            disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();        newList = new ArrayList<InetSocketAddress>(3);    for (byte i = 4; i > 1; i--) {                newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();                        HostProvider[] hostProviderArray = new HostProvider[numClients];    newList = getServerAddresses((byte) 10);    int numDisconnects = 0;    for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            numDisconnects++;        }    }    hostProvider.onConnected();        assertTrue(numDisconnects < upperboundCPS(numClients, 10));}
0
public void testUpdateMigrationGoesRound() throws UnknownHostException
{    HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 2; i--) {                        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> oldStaying = new ArrayList<InetSocketAddress>(2);    for (byte i = 4; i > 2; i--) {                oldStaying.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> newComing = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 4; i--) {                newComing.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }                    boolean disconnectRequired = hostProvider.updateServerList(newList, new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235));    assertTrue(disconnectRequired);                ArrayList<InetSocketAddress> seen = new ArrayList<InetSocketAddress>();    for (int i = 0; i < newComing.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(newComing.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }        seen.clear();    for (int i = 0; i < oldStaying.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(oldStaying.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }            InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    for (int i = 0; i < newList.size() - 1; i++) {        hostProvider.next(0);    }    assertEquals(first, hostProvider.next(0));    hostProvider.onConnected();}
0
public void testUpdateLoadBalancing() throws UnknownHostException
{        boolean disconnectRequired;    HostProvider[] hostProviderArray = new HostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));                numClientsPerHost[i] = 0;    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 6);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 6; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 6));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 6));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[6] == 0);    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);            newList = new ArrayList<InetSocketAddress>(8);    for (byte i = 9; i > 1; i--) {        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    assertTrue(numClientsPerHost[0] == 0);    for (int i = 1; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }        newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
0
public void testNoCurrentHostDuringNormalMode() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        if (i >= (numClients / 2)) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = null;        }    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else if (curHostForEachClient[i] == null) {                        curHostForEachClient[i] = hostProviderArray[i].getServerAtIndex(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;                hostProviderArray[i].onConnected();    }    for (int i = 0; i < 7; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 7));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 7));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));    }}
0
public void testReconfigDuringReconfigMode() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);    }            newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                                        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = hostProviderArray[i].getServerAtCurrentIndex();        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
0
private StaticHostProvider getHostProvider(byte size)
{    return new StaticHostProvider(getServerAddresses(size), r.nextLong());}
0
private Collection<InetSocketAddress> getServerAddresses(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        try {            list.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, size }), 1234 + size));        } catch (UnknownHostException e) {                        e.printStackTrace();        }        --size;    }    return list;}
0
public void testUpdateServerList_UnresolvedHostnames_NoDisconnection1()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(4);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
0
public void testUpdateServerList_UnresolvedHostnames_NoDisconnection2()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
0
public void testUpdateServerList_UnresolvedHostnames_Disconnection1()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(2);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
0
public void testUpdateServerList_UnresolvedHostnames_Disconnection2()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-4.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
0
public void testUpdateServerList_ResolvedWithUnResolvedAddress_ForceDisconnect()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(false));}
0
public void testUpdateServerList_ResolvedWithResolvedAddress_NoDisconnect() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), currentHost.getAddress().getAddress()), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
0
public void testUpdateServerList_UnResolvedWithUnResolvedAddress_ForceDisconnect()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is not resolvable in this test case", currentHost.isUnresolved(), is(true));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(true));}
0
public void testUpdateServerList_UnResolvedWithResolvedAddress_ForceDisconnect() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost not resolvable in this test case", currentHost.isUnresolved(), is(true));        byte[] addr = new byte[] { 10, 0, 0, 1 };    InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), addr), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
0
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    if (name.contains("resolvable")) {        byte[] addr = new byte[] { 10, 0, 0, (byte) (counter++ % 10) };        return new InetAddress[] { InetAddress.getByAddress(name, addr) };    }    throw new UnknownHostException();}
0
private double lowerboundCPS(int numClients, int numServers)
{    return (1 - slackPercent / 100.0) * numClients / numServers;}
0
private double upperboundCPS(int numClients, int numServers)
{    return (1 + slackPercent / 100.0) * numClients / numServers;}
0
public void testLiteralIPNoReverseNS()
{    byte size = 30;    HostProvider hostProvider = getHostProviderUnresolved(size);    for (int i = 0; i < size; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat(next, instanceOf(InetSocketAddress.class));        assertFalse(next.isUnresolved());        assertTrue(next.toString().startsWith("/"));                String hostname = next.getHostString();                assertEquals(next.getAddress().getHostAddress(), hostname);    }}
0
public void testReResolvingSingle() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("issues.apache.org", 1234));    final InetAddress issuesApacheOrg = mock(InetAddress.class);    when(issuesApacheOrg.getHostAddress()).thenReturn("192.168.1.1");    when(issuesApacheOrg.toString()).thenReturn("issues.apache.org");    when(issuesApacheOrg.getHostName()).thenReturn("issues.apache.org");    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return new InetAddress[] { issuesApacheOrg };        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertEquals(issuesApacheOrg, next.getAddress());    }                verify(spyResolver, times(10)).getAllByName("issues.apache.org");}
0
public InetAddress[] getAllByName(String name)
{    return new InetAddress[] { issuesApacheOrg };}
0
public void testReResolvingMultiple() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    final InetAddress apacheOrg2 = mock(InetAddress.class);    when(apacheOrg2.getHostAddress()).thenReturn("192.168.1.2");    when(apacheOrg2.toString()).thenReturn("www.apache.org");    when(apacheOrg2.getHostName()).thenReturn("www.apache.org");    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    resolvedAddresses.add(apacheOrg1);    resolvedAddresses.add(apacheOrg2);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        assertEquals(1, hostProvider.size());    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat("Bad IP address returned", next.getAddress().getHostAddress(), anyOf(equalTo(apacheOrg1.getHostAddress()), equalTo(apacheOrg2.getHostAddress())));                assertEquals(1, hostProvider.size());    }            verify(spyResolver, times(10)).getAllByName("www.apache.org");}
0
public InetAddress[] getAllByName(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
0
public void testReResolveMultipleOneFailing() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final List<String> ipList = new ArrayList<String>();    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    for (int i = 0; i < 3; i++) {        ipList.add(String.format("192.168.1.%d", i + 1));        final InetAddress apacheOrg = mock(InetAddress.class);        when(apacheOrg.getHostAddress()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.toString()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.getHostName()).thenReturn("www.apache.org");        resolvedAddresses.add(apacheOrg);    }    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        InetSocketAddress resolvedFirst = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedFirst.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedFirst.getAddress().getHostAddress()));        hostProvider.onConnected();    InetSocketAddress resolvedSecond = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedSecond.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedSecond.getAddress().getHostAddress()));            InetSocketAddress resolvedThird = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedThird.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedThird.getAddress().getHostAddress()));        verify(spyResolver, times(3)).getAllByName("www.apache.org");}
0
public InetAddress[] getAllByName(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
0
public void testEmptyResolution() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    list.add(InetSocketAddress.createUnresolved("www.google.com", 1234));    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    resolvedAddresses.add(apacheOrg1);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            if ("www.apache.org".equalsIgnoreCase(name)) {                return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);            } else {                return new InetAddress[0];            }        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        for (int i = 0; i < 10; i++) {        InetSocketAddress resolved = hostProvider.next(0);        hostProvider.onConnected();        if (resolved.getHostName().equals("www.google.com")) {            assertTrue("HostProvider should return unresolved address if host is unresolvable", resolved.isUnresolved());        } else {            assertFalse("HostProvider should return resolved addresses", resolved.isUnresolved());            assertEquals("192.168.1.1", resolved.getAddress().getHostAddress());        }    }    verify(spyResolver, times(5)).getAllByName("www.apache.org");    verify(spyResolver, times(5)).getAllByName("www.google.com");}
0
public InetAddress[] getAllByName(String name)
{    if ("www.apache.org".equalsIgnoreCase(name)) {        return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);    } else {        return new InetAddress[0];    }}
0
public void testReResolvingLocalhost()
{    byte size = 2;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("localhost", 1234));    list.add(InetSocketAddress.createUnresolved("localhost", 1235));    StaticHostProvider hostProvider = new StaticHostProvider(list);    int sizeBefore = hostProvider.size();    InetSocketAddress next = hostProvider.next(0);    next = hostProvider.next(0);    assertTrue("Different number of addresses in the list: " + hostProvider.size() + " (after), " + sizeBefore + " (before)", hostProvider.size() == sizeBefore);}
0
private StaticHostProvider getHostProviderUnresolved(byte size)
{    return new StaticHostProvider(getUnresolvedServerAddresses(size), r.nextLong());}
0
private Collection<InetSocketAddress> getUnresolvedServerAddresses(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved("10.10.10." + size, 1234 + size));        --size;    }    return list;}
0
private StaticHostProvider getHostProviderWithUnresolvedHostnames(int size)
{    return new StaticHostProvider(getUnresolvedHostnames(size), r.nextLong());}
0
private Collection<InetSocketAddress> getUnresolvedHostnames(int size)
{    ArrayList<InetSocketAddress> list = new ArrayList<>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved(String.format("testhost-%d.testdomain.com", size), 1234 + size));        --size;    }    System.out.println(Arrays.toString(list.toArray()));    return list;}
0
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
0
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
0
private Stat newStat()
{    Stat stat = new Stat();    stat.setAversion(100);    stat.setCtime(100);    stat.setCversion(100);    stat.setCzxid(100);    stat.setDataLength(100);    stat.setEphemeralOwner(100);    stat.setMtime(100);    stat.setMzxid(100);    stat.setNumChildren(100);    stat.setPzxid(100);    stat.setVersion(100);    return stat;}
0
public void testBasic() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void testChild() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    stat = newStat();    zk.getData(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void testChildren() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat;        stat = newStat();        zk.getData(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());    }}
0
public void testDataSizeChange() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    zk.setData(name, (name + name).getBytes(), -1);    stat = newStat();    zk.getData(name, false, stat);    assertNotSame(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertNotSame(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(1, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length() * 2, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
0
public void testStrings()
{    String s1 = "   a  ,   b  , ";    assertEquals("[a, b]", StringUtils.split(s1, ",").toString());    String s2 = "";    assertEquals(0, StringUtils.split(s2, ",").size());    String s3 = "1, , 2";    assertEquals("[1, 2]", StringUtils.split(s3, ",").toString());}
0
public void testSync() throws Exception
{    try {                opsCount = new CountDownLatch(limit);        ZooKeeper zk = createClient();                for (int i = 0; i < 50; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);        }        for (int i = 50; i < 100; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);        }        zk.sync("/test", this, results);        for (int i = 0; i < 100; i++) {            zk.delete("/test" + i, 0, this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (Children2Callback) this, results);        }                if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {            fail("Haven't received all confirmations" + opsCount.getCount());        }        for (int i = 0; i < limit; i++) {            assertEquals(0, (int) results.get(i));        }    } catch (IOException e) {        System.out.println(e.toString());    }}
1
public void processResult(int rc, String path, Object ctx, List<String> children)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
0
public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
0
public void processResult(int rc, String path, Object ctx, String name)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
0
public void processResult(int rc, String path, Object ctx)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
0
public static TestByteBufAllocator getInstance()
{    TestByteBufAllocator result = INSTANCE.get();    if (result == null) {        ResourceLeakDetector.Level oldLevel = ResourceLeakDetector.getLevel();        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);        INSTANCE.compareAndSet(null, new TestByteBufAllocator(oldLevel));        result = INSTANCE.get();    }    return result;}
0
public static void checkForLeaks()
{    TestByteBufAllocator result = INSTANCE.getAndSet(null);    if (result != null) {        result.checkInstanceForLeaks();    }}
0
protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity)
{    return track(super.newHeapBuffer(initialCapacity, maxCapacity));}
0
protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity)
{    return track(super.newDirectBuffer(initialCapacity, maxCapacity));}
0
public CompositeByteBuf compositeHeapBuffer(int maxNumComponents)
{    return track(super.compositeHeapBuffer(maxNumComponents));}
0
public CompositeByteBuf compositeDirectBuffer(int maxNumComponents)
{    return track(super.compositeDirectBuffer(maxNumComponents));}
0
private synchronized CompositeByteBuf track(CompositeByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
0
private synchronized ByteBuf track(ByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
0
private void checkInstanceForLeaks()
{    try {        long referencedBuffersCount = 0;        synchronized (this) {            referencedBuffersCount = trackedBuffers.stream().filter(byteBuf -> byteBuf.refCnt() > 0).count();                        trackedBuffers.clear();        }                if (referencedBuffersCount > 0) {                                                System.gc();            throw new AssertionError("Found a netty ByteBuf leak!");        }    } finally {        ResourceLeakDetector.setLevel(oldLevel);    }}
0
public static void setTestAllocator(ByteBufAllocator allocator) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m1.setAccessible(true);    m1.invoke(null, allocator);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m2.setAccessible(true);    m2.invoke(null, allocator);}
0
public static void clearTestAllocator() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("clearTestAllocator");    m1.setAccessible(true);    m1.invoke(null);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("clearTestAllocator");    m2.setAccessible(true);    m2.invoke(null);}
0
public static void main(String[] args)
{    long startTime = Time.currentElapsedTime();    ZooKeeper zk = null;    try {        zk = ClientBase.createZKClient(args[0], 10000);    } catch (Exception e1) {        e1.printStackTrace();        throw new RuntimeException(e1);    }    for (int i = 0; i < REPS; i++) {        try {            String name = zk.create("/testFile-", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);            zk.delete(name, -1, new TestHammer(), null);        } catch (Exception e) {            i--;            e.printStackTrace();        }    }    System.out.println("creates/sec=" + (REPS * 1000 / (Time.currentElapsedTime() - startTime)));}
0
public void processResult(int rc, String path, Object ctx)
{}
0
public static boolean deleteFileRecursively(File file, final boolean failOnError)
{    if (file != null) {        if (file.isDirectory()) {            File[] files = file.listFiles();            int size = files.length;            for (int i = 0; i < size; i++) {                File f = files[i];                boolean deleted = deleteFileRecursively(files[i], failOnError);                if (!deleted && failOnError) {                    fail("file '" + f.getAbsolutePath() + "' deletion failed");                }            }        }        return file.delete();    }    return true;}
0
public static boolean deleteFileRecursively(File file)
{    return deleteFileRecursively(file, false);}
0
public void setUp() throws IOException
{    dataDir1 = ClientBase.createTmpDir();    dataDir2 = ClientBase.createTmpDir();    dataDir3 = ClientBase.createTmpDir();}
0
public void tearDown()
{    ClientBase.recursiveDelete(dataDir1);    ClientBase.recursiveDelete(dataDir2);    ClientBase.recursiveDelete(dataDir3);}
0
public void testTruncationStreamReset() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);            snaplog.save(zkdb.getDataTree(), zkdb.getSessionWithTimeOuts(), false);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.truncateLog(1);    append(zkdb, 200);    zkdb.close();            FileTxnLog txnlog = new FileTxnLog(new File(tmpdir, "version-2"));    TxnIterator iter = txnlog.read(1);    TxnHeader hdr = iter.getHeader();    Record txn = iter.getTxn();    assertEquals(1, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.next();    hdr = iter.getHeader();    txn = iter.getTxn();    assertEquals(200, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.close();    ClientBase.recursiveDelete(tmpdir);}
0
public void testTruncationNullLog() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.close();    File[] logs = snaplog.getDataDir().listFiles();    for (int i = 0; i < logs.length; i++) {                assertTrue("Failed to delete log file: " + logs[i].getName(), logs[i].delete());    }    try {        zkdb.truncateLog(1);        assertTrue("Should not get here", false);    } catch (IOException e) {        assertTrue("Should have received an IOException", true);    } catch (NullPointerException npe) {        fail("This should not throw NPE!");    }    ClientBase.recursiveDelete(tmpdir);}
1
private void append(ZKDatabase zkdb, int i) throws IOException
{    TxnHeader hdr = new TxnHeader(1, 1, i, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo" + i, new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    zkdb.append(req);    zkdb.commit();}
0
public void testTruncate() throws Exception
{        String hostPort = "127.0.0.1:" + PortAssignment.unique();    int maxCnxns = 100;    ServerCnxnFactory factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ClientBase.shutdownServerInstance(factory, hostPort);        File origfile = new File(new File(dataDir1, "version-2"), "snapshot.0");    File newfile = new File(new File(dataDir1, "version-2"), "snapshot.100000000");    origfile.renameTo(newfile);    factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ZooKeeper zk = ClientBase.createZKClient(hostPort, 15000);    for (int i = 0; i < 50; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    ZKDatabase zkDb;    {        ZooKeeperServer zs = factory.getZooKeeperServer();        zkDb = zs.getZKDatabase();    }    factory.shutdown();    try {        zkDb.close();    } catch (IOException ie) {            }    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    int port1 = PortAssignment.unique();    int port2 = PortAssignment.unique();    int port3 = PortAssignment.unique();        Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port3)));    QuorumPeer s2 = new QuorumPeer(peers, dataDir2, dataDir2, port2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s2.start();    QuorumPeer s3 = new QuorumPeer(peers, dataDir3, dataDir3, port3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s3.start();    zk = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    final ZooKeeper zk2 = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    zk2.getData("/9", false, new Stat());    try {        zk2.getData("/10", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    QuorumPeer s1 = new QuorumPeer(peers, dataDir1, dataDir1, port1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s1.start();    ZooKeeper zk1 = ClientBase.createZKClient("127.0.0.1:" + port1, 15000);    zk1.getData("/9", false, new Stat());    try {                                                        zk1.getData("/12", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    zk1.close();    QuorumBase.shutdown(s1);    QuorumBase.shutdown(s2);    QuorumBase.shutdown(s3);}
1
public void testCreatingWatchedEvent()
{            EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            we = new WatchedEvent(et, ks, "blah");            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
0
public void testCreatingWatchedEventFromWrapper()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    WatcherEvent wep;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            wep = new WatcherEvent(et.getIntValue(), ks.getIntValue(), "blah");            we = new WatchedEvent(wep);            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
0
public void testCreatingWatchedEventFromInvalidWrapper()
{    try {        WatcherEvent wep = new WatcherEvent(-2342, -252352, "foo");        new WatchedEvent(wep);        fail("Was able to create WatchedEvent from bad wrapper");    } catch (RuntimeException re) {        }}
0
public void testConvertingToEventWrapper()
{    WatchedEvent we = new WatchedEvent(EventType.NodeCreated, KeeperState.Expired, "blah");    WatcherEvent wew = we.getWrapper();    assertEquals(EventType.NodeCreated.getIntValue(), wew.getType());    assertEquals(KeeperState.Expired.getIntValue(), wew.getState());    assertEquals("blah", wew.getPath());}
0
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        if (latch != null) {            latch.countDown();        }    }    if (event.getType() == EventType.None) {        return;    }    try {        events.put(event);    } catch (InterruptedException e) {        assertTrue("interruption unexpected", false);    }}
0
public void verify(List<EventType> expected) throws InterruptedException
{    WatchedEvent event;    int count = 0;    while (count < expected.size() && (event = events.poll(30, TimeUnit.SECONDS)) != null) {        assertEquals(expected.get(count), event.getType());        count++;    }    assertEquals(expected.size(), count);    events.clear();}
0
public void setUp() throws Exception
{    super.setUp();    client_latch = new CountDownLatch(1);    client_dwatch = new SimpleWatcher(client_latch);    client = createClient(client_dwatch, client_latch);    lsnr_latch = new CountDownLatch(1);    lsnr_dwatch = new SimpleWatcher(lsnr_latch);    lsnr = createClient(lsnr_dwatch, lsnr_latch);    expected = new ArrayList<EventType>();}
0
public void tearDown() throws Exception
{    client.close();    lsnr.close();    super.tearDown();}
0
protected ZooKeeper createClient(Watcher watcher, CountDownLatch latch) throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
0
private void verify() throws InterruptedException
{    lsnr_dwatch.verify(expected);    expected.clear();}
0
public void testExistsSync() throws IOException, InterruptedException, KeeperException
{    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo/bar", true));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    try {        assertNull(lsnr.exists("/car", true));        client.setData("/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/car", e.getPath());    }    try {        assertNull(lsnr.exists("/foo/car", true));        client.setData("/foo/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/car", e.getPath());    }    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
0
public void testGetDataSync() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getData("/foo", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
0
public void testGetChildrenSync() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.delete("/foo/bar", -1);        expected.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
0
public void testExistsSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo", w1));    assertNull(lsnr.exists("/foo/bar", w2));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w4));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e2.add(EventType.NodeCreated);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();        assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);        lsnr_dwatch.verify(new ArrayList<EventType>());    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
0
public void testGetDataSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getData("/foo", w1, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", w2, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
0
public void testGetChildrenSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.delete("/foo/bar", -1);        e2.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    ((int[]) ctx)[0]++;    this.rc = rc;}
0
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        timeOfLastWatcherInvocation = System.currentTimeMillis();        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
1
public void setUp() throws Exception
{    super.setUp();            System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "false");}
0
public void testWatcherCorrectness() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };        VoidCallback vcb = new VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                        }        };        String[] names = new String[10];        for (int i = 0; i < names.length; i++) {            String name = zk.create("/tc-", "initialvalue".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            names[i] = name;            Stat stat = new Stat();            zk.getData(name, watcher, stat);            zk.setData(name, "new".getBytes(), stat.getVersion(), scb, null);            stat = zk.exists(name, watcher);            zk.delete(name, stat.getVersion(), vcb, null);        }        for (int i = 0; i < names.length; i++) {            String name = names[i];            WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDataChanged, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDeleted, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());        }    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
0
public void processResult(int rc, String path, Object ctx)
{}
0
public void testWatcherDisconnectOnClose() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        final BlockingQueue<WatchedEvent> queue = new LinkedBlockingQueue<>();        MyWatcher connWatcher = new MyWatcher();        Watcher watcher = event -> {            try {                queue.put(event);            } catch (InterruptedException e) {                        }        };        zk = createClient(connWatcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };                zk.exists("/missing", watcher, scb, null);                zk.close();        WatchedEvent event = queue.poll(10, TimeUnit.SECONDS);        assertNotNull("No watch event was received after closing the Zookeeper client. A 'Closed' event should have occurred", event);        assertEquals("Closed events are not generated by the server, and so should have a type of 'None'", Event.EventType.None, event.getType());        assertEquals("A 'Closed' event was expected as the Zookeeper client was closed without altering the node it was watching", Event.KeeperState.Closed, event.getState());    } finally {        if (zk != null) {            zk.close();        }    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
0
public void testWatcherCount() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = null, zk2 = null;    try {        MyWatcher w1 = new MyWatcher();        zk1 = createClient(w1, hostPort);        MyWatcher w2 = new MyWatcher();        zk2 = createClient(w2, hostPort);        Stat stat = new Stat();        zk1.create("/watch-count-test", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.create("/watch-count-test-2", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.getData("/watch-count-test", w1, stat);        zk1.getData("/watch-count-test-2", w1, stat);        zk2.getData("/watch-count-test", w2, stat);        assertEquals(serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().getWatchCount(), 3);    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
0
public void testWatchAutoResetWithPending() throws Exception
{    MyWatcher[] watches = new MyWatcher[COUNT];    MyStatCallback[] cbs = new MyStatCallback[COUNT];    MyWatcher watcher = new MyWatcher();    int[] count = new int[1];    TestableZooKeeper zk = createClient(watcher, hostPort, 6000);    ZooKeeper zk2 = createClient(watcher, hostPort, 5000);    zk2.create("/test", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    for (int i = 0; i < COUNT / 2; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    zk.exists("/test", false);    assertTrue("Failed to pause the connection!", zk.pauseCnxn(3000));    zk2.close();    stopServer();    watches[0].waitForDisconnected(60000);    for (int i = COUNT / 2; i < COUNT; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    startServer();    watches[COUNT / 2 - 1].waitForConnected(60000);    assertEquals(null, zk.exists("/test", false));    waitForAllWatchers();    for (int i = 0; i < COUNT / 2; i++) {        assertEquals("For " + i, 1, watches[i].events.size());    }    for (int i = COUNT / 2; i < COUNT; i++) {        if (cbs[i].rc == 0) {            assertEquals("For " + i, 1, watches[i].events.size());        } else {            assertEquals("For " + i, 0, watches[i].events.size());        }    }    assertEquals(COUNT, count[0]);    zk.close();}
0
private void waitForAllWatchers() throws Exception
{    timeOfLastWatcherInvocation = System.currentTimeMillis();    while (System.currentTimeMillis() - timeOfLastWatcherInvocation < 1000) {        Thread.sleep(1000);    }}
0
public void testWatcherAutoResetWithGlobal() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, watcher);    zk.close();}
0
public void testWatcherAutoResetWithLocal() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, new MyWatcher());    zk.close();}
0
public void testWatcherAutoResetDisabledWithGlobal() throws Exception
{    /**     * When ZooKeeper is created this property will get used.     */    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithGlobal();}
0
public void testWatcherAutoResetDisabledWithLocal() throws Exception
{    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithLocal();}
0
private void testWatcherAutoReset(ZooKeeper zk, MyWatcher globalWatcher, MyWatcher localWatcher) throws Exception
{    boolean isGlobal = (localWatcher == globalWatcher);        zk.create("/watchtest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/watchtest/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(3000);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(3000);    boolean disableAutoWatchReset = zk.getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    assertTrue(localWatcher.events.isEmpty());    zk.setData("/watchtest/child", new byte[1], -1);    zk.create("/watchtest/child2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e;    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(e.getPath(), EventType.NodeDataChanged, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);                        assertEquals(EventType.NodeCreated, e.getType());        assertEquals("/watchtest/child2", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeChildrenChanged, e.getType());        assertEquals("/watchtest", e.getPath());    } else {            }        assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    try {        try {            localWatcher.waitForDisconnected(500);            if (!isGlobal && !disableAutoWatchReset) {                fail("Got an event when I shouldn't have");            }        } catch (TimeoutException toe) {            if (disableAutoWatchReset) {                fail("Didn't get an event when I should have");            }                }    } catch (Exception e1) {                throw new RuntimeException(e1);    }    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }            zk.delete("/watchtest/child2", -1);    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeDeleted, e.getType());    assertEquals("/watchtest/child2", e.getPath());    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/watchtest", e.getPath());    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    zk.delete("/watchtest/child", -1);    zk.delete("/watchtest", -1);    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeDeleted, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }        Thread.sleep(1000);    assertTrue(localWatcher.events.isEmpty());}
1
public void process(WatchedEvent event)
{    super.process(event);    try {        if (event.getType() != Event.EventType.None) {            dataEvents.put(event);        }    } catch (InterruptedException e) {            }}
1
public void assertEvent(long timeout, EventType eventType)
{    try {        WatchedEvent event = dataEvents.poll(timeout, TimeUnit.MILLISECONDS);        assertNotNull("do not receive a " + eventType, event);        assertEquals(eventType, event.getType());    } catch (InterruptedException e) {            }}
1
private ZooKeeper createClient(QuorumUtil qu, int id, EventsWatcher watcher) throws IOException
{    String hostPort = "127.0.0.1:" + qu.getPeer(id).clientPort;    ZooKeeper zk = new ZooKeeper(hostPort, TIMEOUT, watcher);    try {        watcher.waitForConnected(TIMEOUT);    } catch (InterruptedException e) {        } catch (TimeoutException e) {        fail("can not connect to " + hostPort);    }    return zk;}
0
private ZooKeeper createClient(QuorumUtil qu, int id) throws IOException
{    return createClient(qu, id, new EventsWatcher());}
0
public void setUp() throws IOException
{    System.setProperty("zookeeper.admin.enableServer", "false");    qu = new QuorumUtil(1);    qu.startAll();    watcher = new EventsWatcher();    zk1 = createClient(qu, 1, watcher);    zk2 = createClient(qu, 2);}
0
public void tearDown() throws InterruptedException
{    if (zk1 != null) {        zk1.close();        zk1 = null;    }    if (zk2 != null) {        zk2.close();        zk2 = null;    }    if (watcher != null) {        watcher = null;    }    if (qu != null) {        qu.shutdownAll();        qu = null;    }}
0
public void testNodeDataChanged() throws Exception
{    String path = "/test-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat1 = zk1.exists(path, watcher);    qu.shutdown(1);    zk2.setData(path, new byte[2], stat1.getVersion());    qu.start(1);    watcher.waitForConnected(TIMEOUT);    watcher.assertEvent(TIMEOUT, EventType.NodeDataChanged);}
0
public void testNodeCreated() throws Exception
{    String path = "/test1-created";    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeCreated);}
0
public void testNodeDeleted() throws Exception
{    String path = "/test-deleted";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getData(path, watcher, null);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);}
0
public void testNodeChildrenChanged() throws Exception
{    String path = "/test-children-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.create(path + "/children-1", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeChildrenChanged);}
0
public void setUp()
{    System.setProperty("zookeeper.X509AuthenticationProvider.superUser", "CN=SUPER");    System.setProperty("zookeeper.ssl.keyManager", "org.apache.zookeeper.test.X509AuthTest.TestKeyManager");    System.setProperty("zookeeper.ssl.trustManager", "org.apache.zookeeper.test.X509AuthTest.TestTrustManager");    clientCert = new TestCertificate("CLIENT");    superCert = new TestCertificate("SUPER");    unknownCert = new TestCertificate("UNKNOWN");}
0
public void testTrustedAuth()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { clientCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));}
0
public void testSuperAuth()
{    X509AuthenticationProvider provider = createProvider(superCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { superCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));    assertEquals("super", cnxn.getAuthInfo().get(0).getScheme());}
0
public void testUntrustedAuth()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { unknownCert };    assertEquals(KeeperException.Code.AUTHFAILED, provider.handleAuthentication(cnxn, null));}
0
public String getAlgorithm()
{    return null;}
0
public String getFormat()
{    return null;}
0
public byte[] getEncoded()
{    return null;}
0
public boolean hasUnsupportedCriticalExtension()
{    return false;}
0
public Set<String> getCriticalExtensionOIDs()
{    return null;}
0
public Set<String> getNonCriticalExtensionOIDs()
{    return null;}
0
public byte[] getExtensionValue(String oid)
{    return null;}
0
public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException
{}
0
public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException
{}
0
public int getVersion()
{    return 0;}
0
public BigInteger getSerialNumber()
{    return null;}
0
public Principal getIssuerDN()
{    return null;}
0
public Principal getSubjectDN()
{    return null;}
0
public Date getNotBefore()
{    return null;}
0
public Date getNotAfter()
{    return null;}
0
public byte[] getTBSCertificate() throws CertificateEncodingException
{    return null;}
0
public byte[] getSignature()
{    return null;}
0
public String getSigAlgName()
{    return null;}
0
public String getSigAlgOID()
{    return null;}
0
public byte[] getSigAlgParams()
{    return null;}
0
public boolean[] getIssuerUniqueID()
{    return null;}
0
public boolean[] getSubjectUniqueID()
{    return null;}
0
public boolean[] getKeyUsage()
{    return null;}
0
public int getBasicConstraints()
{    return 0;}
0
public byte[] getEncoded() throws CertificateEncodingException
{    return encoded;}
0
public void verify(PublicKey key) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
0
public void verify(PublicKey key, String sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
0
public String toString()
{    return null;}
0
public PublicKey getPublicKey()
{    return publicKey;}
0
public X500Principal getSubjectX500Principal()
{    return principal;}
0
public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket)
{    return null;}
0
public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket)
{    return null;}
0
public X509Certificate[] getCertificateChain(String alias)
{    return null;}
0
public String[] getClientAliases(String keyType, Principal[] issuers)
{    return null;}
0
public PrivateKey getPrivateKey(String alias)
{    return null;}
0
public String[] getServerAliases(String keyType, Principal[] issuers)
{    return null;}
0
public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Client cert not trusted");    }}
0
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Server cert not trusted");    }}
0
public X509Certificate[] getAcceptedIssuers()
{    return null;}
0
protected X509AuthenticationProvider createProvider(X509Certificate trustedCert)
{    return new X509AuthenticationProvider(new TestTrustManager(trustedCert), new TestKeyManager());}
0
public void setUp() throws Exception
{        qb.setUp();}
1
public void tearDown() throws Exception
{    }
1
private void corruptFile(File f) throws IOException
{    RandomAccessFile outFile = new RandomAccessFile(f, "rw");    outFile.write("fail servers".getBytes());    outFile.close();}
0
private void corruptAllSnapshots(File snapDir) throws IOException
{    File[] listFiles = snapDir.listFiles();    for (File f : listFiles) {        if (f.getName().startsWith("snapshot")) {            corruptFile(f);        }    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{}
0
public void testCorruption() throws Exception
{    ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = ClientBase.createZKClient(qb.hostPort, 10000);    SyncRequestProcessor.setSnapCount(100);    for (int i = 0; i < 2000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    long leaderSid = 1;    QuorumPeer leader = null;        for (QuorumPeer quorumPeer : Arrays.asList(qb.s1, qb.s2, qb.s3, qb.s4, qb.s5)) {        if (quorumPeer.getPeerState() == ServerState.LEADING) {            leader = quorumPeer;            break;        }        ++leaderSid;    }    assertNotNull("Cannot find the leader.", leader);    leader.shutdown();        FileTxnSnapLog snapLog = leader.getTxnFactory();    File snapDir = snapLog.getSnapDir();        corruptAllSnapshots(snapDir);    qb.shutdownServers();    qb.setupServers();    if (leaderSid != 1) {        qb.s1.start();    } else {        leader = qb.s1;    }    if (leaderSid != 2) {        qb.s2.start();    } else {        leader = qb.s2;    }    if (leaderSid != 3) {        qb.s3.start();    } else {        leader = qb.s3;    }    if (leaderSid != 4) {        qb.s4.start();    } else {        leader = qb.s4;    }    if (leaderSid != 5) {        qb.s5.start();    } else {        leader = qb.s5;    }    try {        leader.start();        assertTrue(false);    } catch (RuntimeException re) {            }        String[] list = qb.hostPort.split(",");    for (int i = 0; i < 5; i++) {        if (leaderSid != (i + 1)) {            String hp = list[i];            assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));                    } else {                    }    }    zk = qb.createClient();    SyncRequestProcessor.setSnapCount(100);    for (int i = 2000; i < 4000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    if (leaderSid != 1) {        QuorumBase.shutdown(qb.s1);    }    if (leaderSid != 2) {        QuorumBase.shutdown(qb.s2);    }    if (leaderSid != 3) {        QuorumBase.shutdown(qb.s3);    }    if (leaderSid != 4) {        QuorumBase.shutdown(qb.s4);    }    if (leaderSid != 5) {        QuorumBase.shutdown(qb.s5);    }}
1
public void testAbsentRecentSnapshot() throws IOException
{    ZKDatabase zkDatabase = new ZKDatabase(new FileTxnSnapLog(new File("foo"), new File("bar")) {        @Override        public File findMostRecentSnapshot() throws IOException {            return null;        }    });    assertEquals(0, zkDatabase.calculateTxnLogSizeLimit());}
0
public File findMostRecentSnapshot() throws IOException
{    return null;}
0
public void testQuota() throws Exception
{    final ZooKeeper zk = createClient();    final String path = "/a/b/v";        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/d", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    SetQuotaCommand.createQuota(zk, path, 5L, 10);        String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absolutePath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 5L);    assertTrue("num count is set", st.getCount() == 10);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    byte[] qdata = zk.getData(statPath, false, new Stat());    StatsTrack qst = new StatsTrack(new String(qdata));    assertTrue("bytes are set", qst.getBytes() == 8L);    assertTrue("count is set", qst.getCount() == 2);        stopServer();    startServer();    stopServer();    startServer();    ZooKeeperServer server = serverFactory.getZooKeeperServer();    assertNotNull("Quota is still set", server.getZKDatabase().getDataTree().getMaxPrefixWithQuota(path) != null);}
0
public void testSetQuota() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    String path = "/c1";    String nodeData = "foo";    zk.create(path, nodeData.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int count = 10;    long bytes = 5L;    SetQuotaCommand.createQuota(zk, path, bytes, count);        String absoluteLimitPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absoluteLimitPath, false, null);    StatsTrack st = new StatsTrack(new String(data));    assertEquals(bytes, st.getBytes());    assertEquals(count, st.getCount());        String absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));    assertEquals(nodeData.length(), st.getBytes());    assertEquals(1, st.getCount());        String path2 = "/c1/c2";    String nodeData2 = "bar";    zk.create(path2, nodeData2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));        assertEquals(nodeData.length() + nodeData2.length(), st.getBytes());    assertEquals(2, st.getCount());}
0
public void testSetQuotaWhenSetQuotaOnParentOrChildPath() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    zk.create("/c1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4/c5", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        SetQuotaCommand.createQuota(zk, "/c1/c2/c3", 5L, 10);    try {        SetQuotaCommand.createQuota(zk, "/c1", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1 has a child /c1/c2/c3 which has a quota", e.getMessage());    }    try {        SetQuotaCommand.createQuota(zk, "/c1/c2/c3/c4/c5", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1/c2/c3/c4/c5 has a parent /c1/c2/c3 which has a quota", e.getMessage());    }}
0
private WatchedEvent getEvent(int numTries) throws InterruptedException
{    WatchedEvent event = null;    for (int i = 0; i < numTries; i++) {        System.out.println("i = " + i);        event = events.poll(10, TimeUnit.SECONDS);        if (event != null) {            break;        }        Thread.sleep(5000);    }    return event;}
0
private void deleteZKDir(ZooKeeper zk, String nodeName) throws IOException, InterruptedException, KeeperException
{    Stat stat = zk.exists(nodeName, false);    if (stat == null) {        return;    }    List<String> children1 = zk.getChildren(nodeName, false);    List<String> c2 = zk.getChildren(nodeName, false, stat);    if (!children1.equals(c2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat.equals(stat)) {        fail("stats from exists()/getChildren2() do not match");    }    if (children1.size() == 0) {        zk.delete(nodeName, -1);        return;    }    for (String n : children1) {        deleteZKDir(zk, n);    }}
0
private void checkRoot() throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    try {        zk.create(dirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + dirOnZK + ": " + ke.getMessage());    }    try {        zk.create(testDirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + testDirOnZK + ": " + ke.getMessage());    }    zk.close();}
0
private void enode_test_1() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    Stat stat = zk.exists(parentName, false);    if (stat == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    stat = zk.exists(nodeName, false);    if (stat == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("Closing client with sessionid: 0x" + Long.toHexString(zk.getSessionId()));    zk.close();    zk = new ZooKeeper(hostPort, 10000, this);    for (int i = 0; i < 10; i++) {        System.out.println("i = " + i);        stat = zk.exists(nodeName, false);        if (stat != null) {            System.out.println("node " + nodeName + " should not exist after reconnection close");        } else {            System.out.println("node " + nodeName + " is gone after reconnection close!");            break;        }        Thread.sleep(5000);    }    deleteZKDir(zk, nodeName);    zk.close();}
0
private void enode_test_2() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    ZooKeeper zk_1 = new ZooKeeper(hostPort, 10000, this);    Stat stat_parent = zk_1.exists(parentName, false);    if (stat_parent == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    Stat stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        try {            zk.delete(nodeName, -1);        } catch (KeeperException ke) {            Code code = ke.code();            boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;            if (!valid) {                fail("Unexpected exception code for delete: " + ke.getMessage());            }        }    }    List<String> firstGen1 = zk_1.getChildren(parentName, true);    Stat stat = new Stat();    List<String> firstGen2 = zk_1.getChildren(parentName, true, stat);    if (!firstGen1.equals(firstGen2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat_parent.equals(stat)) {        fail("stat from exists()/getChildren() do not match");    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    Thread.sleep(5000);    WatchedEvent event = events.poll(10, TimeUnit.SECONDS);    if (event == null) {        throw new IOException("No event was delivered promptly");    }    if (event.getType() != EventType.NodeChildrenChanged || !event.getPath().equalsIgnoreCase(parentName)) {        fail("Unexpected event was delivered: " + event.toString());    }    stat_node = zk_1.exists(nodeName, false);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    try {        zk.delete(parentName, -1);        fail("Should be impossible to delete a non-empty node " + parentName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    try {        zk.create(nodeName + "/def", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should be impossible to create child off Ephemeral node " + nodeName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOCHILDRENFOREPHEMERALS;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    try {        List<String> children1 = zk.getChildren(nodeName, false);        List<String> children2 = zk.getChildren(nodeName, false, null);        if (!children1.equals(children2)) {            fail("children lists from getChildren()/getChildren2() does not match");        }        if (children1.size() > 0) {            fail("ephemeral node " + nodeName + " should not have children");        }    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    firstGen1 = zk_1.getChildren(parentName, true);    firstGen2 = zk_1.getChildren(parentName, true, null);    if (!firstGen1.equals(firstGen2)) {        fail("children list from getChildren()/getChildren2() does not match");    }    stat_node = zk_1.exists(nodeName, true);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("session id of zk: " + zk.getSessionId());    System.out.println("session id of zk_1: " + zk_1.getSessionId());    zk.close();    zk_1.exists("nosuchnode", false);    event = this.getEvent(10);    if (event == null) {        throw new Error("First event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected first event was delivered: " + event.toString());    }    event = this.getEvent(10);    if (event == null) {        throw new Error("Second event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected second event was delivered: " + event.toString());    }    firstGen1 = zk_1.getChildren(parentName, false);    stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        fail("node " + nodeName + " should have been deleted");    }    if (firstGen1.contains(nodeName)) {        fail("node " + nodeName + " should not be a children");    }    deleteZKDir(zk_1, nodeName);    zk_1.close();}
0
private void delete_create_get_set_test_1() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/benwashere";    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for create: " + ke.getMessage());        }    }    try {        zk.setData(nodeName, "hi".getBytes(), 5700);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        if (ke.code() != Code.BADVERSION) {            fail("Should have gotten BadVersion exception");        }    }    zk.setData(nodeName, "hi".getBytes(), -1);    Stat st = new Stat();    byte[] bytes = zk.getData(nodeName, false, st);    String retrieved = new String(bytes);    if (!"hi".equals(retrieved)) {        fail("The retrieved data [" + retrieved + "] is differented than the expected [hi]");    }    try {        zk.delete(nodeName, 6800);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY || code == KeeperException.Code.BADVERSION;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    deleteZKDir(zk, nodeName);    zk.close();}
0
private void deleteNodeIfExists(ZooKeeper zk, String nodeName) throws InterruptedException
{    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }}
0
private void create_get_stat_test() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/create_with_stat_tmp";    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    Stat stat = new Stat();    zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNotNull(stat);    assertTrue(stat.getCzxid() > 0);    assertTrue(stat.getCtime() > 0);    Stat stat2 = new Stat();    zk.create(nodeName + "_2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat2);    assertNotNull(stat2);    assertTrue(stat2.getCzxid() > stat.getCzxid());    assertTrue(stat2.getCtime() > stat.getCtime());    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    zk.close();}
0
public void my_test_1() throws IOException, InterruptedException, KeeperException
{    enode_test_1();    enode_test_2();    delete_create_get_set_test_1();    create_get_stat_test();}
0
public synchronized void process(WatchedEvent event)
{    try {        System.out.println("Got an event " + event.toString());        events.put(event);    } catch (InterruptedException e) {        e.printStackTrace();    }}
0
public static void main(String[] args)
{    ZooKeeperTestClient zktc = new ZooKeeperTestClient();    try {        zktc.my_test_1();    } catch (Exception e) {        e.printStackTrace();    }}
0
 void setXid(int newXid)
{    xid = newXid;}
0
 int checkXid()
{    return xid;}
0
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new TestableClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watcher, clientCnxnSocket, canBeReadOnly);}
0
public void setXid(int xid)
{    ((TestableClientCnxn) cnxn).setXid(xid);}
0
public int checkXid()
{    return ((TestableClientCnxn) cnxn).checkXid();}
0
public List<String> getChildWatches()
{    return super.getChildWatches();}
0
public List<String> getDataWatches()
{    return super.getDataWatches();}
0
public List<String> getExistWatches()
{    return super.getExistWatches();}
0
public void testableConnloss() throws IOException
{    synchronized (cnxn) {        cnxn.sendThread.testableCloseSocket();    }}
0
public boolean pauseCnxn(final long ms)
{    final CountDownLatch initiatedPause = new CountDownLatch(1);    new Thread() {        public void run() {            synchronized (cnxn) {                try {                    try {                        cnxn.sendThread.testableCloseSocket();                    } catch (IOException e) {                        e.printStackTrace();                    } finally {                        initiatedPause.countDown();                    }                    Thread.sleep(ms);                } catch (InterruptedException e) {                }            }        }    }.start();    try {        return initiatedPause.await(ms, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        e.printStackTrace();        return false;    }}
0
public void run()
{    synchronized (cnxn) {        try {            try {                cnxn.sendThread.testableCloseSocket();            } catch (IOException e) {                e.printStackTrace();            } finally {                initiatedPause.countDown();            }            Thread.sleep(ms);        } catch (InterruptedException e) {        }    }}
0
public SocketAddress testableLocalSocketAddress()
{    return super.testableLocalSocketAddress();}
0
public SocketAddress testableRemoteSocketAddress()
{    return super.testableRemoteSocketAddress();}
0
public long testableLastZxid()
{    return cnxn.getLastZxid();}
0
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return cnxn.submitRequest(h, request, response, watchRegistration);}
0
public void disconnect()
{    cnxn.disconnect();}
0
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
0
public void testLoadPrivateKeyFromKeyStore() throws IOException, GeneralSecurityException
{    Optional<String> optPassword = x509TestContext.getKeyStorePassword().length() > 0 ? Optional.of(x509TestContext.getKeyStorePassword()) : Optional.empty();    PrivateKey privateKey = PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), optPassword);    assertEquals(x509TestContext.getKeyStoreKeyPair().getPrivate(), privateKey);}
0
public void testLoadEncryptedPrivateKeyFromKeyStoreWithoutPassword() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.empty());}
0
public void testLoadEncryptedPrivateKeyFromKeyStoreWithWrongPassword() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
0
public void testLoadUnencryptedPrivateKeyFromKeyStoreWithWrongPassword() throws GeneralSecurityException, IOException
{    if (x509TestContext.isKeyStoreEncrypted()) {        throw new IOException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
0
public void testLoadPrivateKeyFromTrustStore() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.empty());}
0
public void testLoadPrivateKeyFromTrustStoreWithPassword() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.of("foobar"));}
0
public void testLoadCertificateFromKeyStore() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getKeyStoreCertificate(), certs.get(0));}
0
public void testLoadCertificateFromTrustStore() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getTrustStoreCertificate(), certs.get(0));}
0
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { "1.2.3", new Object[] { 1, 2, 3, null } }, { "1.2.3-dev", new Object[] { 1, 2, 3, "dev" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } }, { "1.2.3.4.5-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3.4.5-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } } });}
0
public void testParser()
{    VerGen.Version v = VerGen.parseVersionString(input);    assertEquals(expected[0], v.maj);    assertEquals(expected[1], v.min);    assertEquals(expected[2], v.micro);    assertEquals(expected[3], v.qualifier);}
0
public void testGenFile() throws Exception
{    VerGen.Version v = VerGen.parseVersionString(input);    File outputDir = ClientBase.createTmpDir();    VerGen.generateFile(outputDir, v, "1", "Nov1");    ClientBase.recursiveDelete(outputDir);}
0
public org.junit.runner.Runner createRunnerForTestWithParameters(TestWithParameters test) throws InitializationError
{    return new ZKParameterized.Runner(test);}
0
protected List<FrameworkMethod> computeTestMethods()
{    return JUnit4ZKTestRunner.computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
0
protected Statement methodInvoker(FrameworkMethod method, Object test)
{    return new JUnit4ZKTestRunner.LoggedInvokeMethod(method, test);}
0
protected String getTestName()
{    return testName;}
0
public void starting(Description method)
{                System.setProperty("zookeeper.admin.enableServer", "false");            System.setProperty("zookeeper.4lw.commands.whitelist", "*");    testName = method.getMethodName();    }
1
public void finished(Description method)
{    }
1
public void succeeded(Description method)
{    }
1
public void failed(Throwable e, Description method)
{    }
1
public void waitFor(String msg, WaitForCondition condition, int timeout) throws InterruptedException
{    final LocalDateTime deadline = LocalDateTime.now().plusSeconds(timeout);    while (LocalDateTime.now().isBefore(deadline)) {        if (condition.evaluate()) {            return;        }        Thread.sleep(100);    }    fail(msg);}
0
public static void init()
{    testData.mkdirs();}
0
public void testValidateFileInput() throws IOException
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNull(error);}
0
public void testValidateFileInputNotExist()
{    String fileName = UUID.randomUUID().toString();    File file = new File(testData, fileName);    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "File '" + absolutePath + "' does not exist.";    assertEquals(expectedMessage, error);}
0
public void testValidateFileInputDirectory() throws Exception
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();        file.delete();    file.mkdir();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "'" + absolutePath + "' is a direcory. it must be a file.";    assertEquals(expectedMessage, error);}
0
public void testUnreadableFileInput() throws Exception
{        assumeTrue(!org.apache.zookeeper.Shell.WINDOWS);    File file = File.createTempFile("test", ".junit", testData);    file.setReadable(false, false);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "Read permission is denied on the file '" + absolutePath + "'";    assertEquals(expectedMessage, error);}
0
public void testDeleteRecursive() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    assertTrue(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("1 children - c should be deleted ", 1, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
0
public void testDeleteRecursiveFail() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    ACL deleteProtection = new ACL(ZooDefs.Perms.DELETE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="));    List<ACL> acls = Arrays.asList(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE), deleteProtection);        zk.create("/a/c/0/surprise", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(1, zk.getACL("/a/c/0", new Stat()).size());    zk.setACL("/a/c/0", acls, -1);    assertEquals(2, zk.getACL("/a/c/0", new Stat()).size());    assertFalse(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - c should fail to be deleted ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a/b", 1000));    children = zk.getChildren("/a", false);    assertEquals("1 children - b should be deleted ", 1, children.size());        zk.addAuthInfo(deleteProtection.getId().getScheme(), "user:test".getBytes());    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
0
private void setupDataTree(ZooKeeper zk) throws KeeperException, InterruptedException
{        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 1000; i < 3000; ++i) {        zk.create("/a/b/v/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 500; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));}
0
public void testDeleteRecursiveCli() throws IOException, InterruptedException, CliException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    ZooKeeperMain zkMain = new ZooKeeperMain(zk);            String cmdstring0 = "rmr /a/b/v";    String cmdstring1 = "deleteall /a";    zkMain.cl.parseCommand(cmdstring0);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(null, zk.exists("/a/b/v", null));    zkMain.cl.parseCommand(cmdstring1);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertNull(zk.exists("/a", null));}
0
public void testDeleteRecursiveAsync() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 50; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    VoidCallback cb = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            synchronized (ctx) {                ((AtomicInteger) ctx).set(4);                ctx.notify();            }        }    };    final AtomicInteger ctx = new AtomicInteger(3);    ZKUtil.deleteRecursive(zk, "/a", cb, ctx);    synchronized (ctx) {        ctx.wait();    }    assertEquals(4, ctx.get());}
0
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((AtomicInteger) ctx).set(4);        ctx.notify();    }}
0
public void testStatWhenPathDoesNotExist() throws IOException, InterruptedException, MalformedCommandException
{    final ZooKeeper zk = createClient();    ZooKeeperMain main = new ZooKeeperMain(zk);    String cmdstring = "stat /invalidPath";    main.cl.parseCommand(cmdstring);    try {        main.processZKCmd(main.cl);        fail("As Node does not exist, command should fail by throwing No Node Exception.");    } catch (CliException e) {        assertEquals("Node does not exist: /invalidPath", e.getMessage());    }}
0
public void testParseWithExtraSpaces() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "      ls       /  ";    zkMain.cl.parseCommand(cmdstring);    assertEquals("Spaces also considered as characters", zkMain.cl.getNumArguments(), 2);    assertEquals("ls is not taken as first argument", zkMain.cl.getCmdArgument(0), "ls");    assertEquals("/ is not taken as second argument", zkMain.cl.getCmdArgument(1), "/");}
0
public void testParseWithQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String quoteChar : new String[] { "'", "\"" }) {        String cmdstring = String.format("create /node %1$squoted data%1$s", quoteChar);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), "quoted data");    }}
0
public void testParseWithMixedQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String[] quoteChars : new String[][] { { "'", "\"" }, { "\"", "'" } }) {        String outerQuotes = quoteChars[0];        String innerQuotes = quoteChars[1];        String cmdstring = String.format("create /node %1$s%2$squoted data%2$s%1$s", outerQuotes, innerQuotes);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), innerQuotes + "quoted data" + innerQuotes);    }}
0
public void testParseWithEmptyQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("empty quotes should produce arguments", zkMain.cl.getNumArguments(), 3);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");}
0
public void testParseWithMultipleQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node '' ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("expected 5 arguments", zkMain.cl.getNumArguments(), 4);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");    assertEquals("empty string is not taken as fourth argument", zkMain.cl.getCmdArgument(3), "");}
0
public void testNonexistantCommand() throws Exception
{    testInvalidCommand("cret -s /node1", 127);}
0
public void testCreateCommandWithoutPath() throws Exception
{    testInvalidCommand("create", 1);}
0
public void testCreateEphemeralCommandWithoutPath() throws Exception
{    testInvalidCommand("create -e ", 1);}
0
public void testCreateSequentialCommandWithoutPath() throws Exception
{    testInvalidCommand("create -s ", 1);}
0
public void testCreateEphemeralSequentialCommandWithoutPath() throws Exception
{    testInvalidCommand("create -s -e ", 1);}
0
private void testInvalidCommand(String cmdString, int exitCode) throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.cl.parseCommand(cmdString);        zkMain.processCmd(zkMain.cl);    assertEquals(exitCode, zkMain.exitCode);        try {        zkMain.processZKCmd(zkMain.cl);        fail();    } catch (CliException e) {        return;    }    fail("invalid command should throw CliException");}
0
public void testCreateNodeWithoutData() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create  -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s y /node";    zkMain.cl.parseCommand(cmdstring);    try {        assertTrue("Created node with wrong option", zkMain.processZKCmd(zkMain.cl));        fail("Created the node with wrong option should " + "throw Exception.");    } catch (MalformedPathException e) {        assertEquals("Path must start with / character", e.getMessage());    }}
0
public void testACLWithExtraAgruments() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /l data ip:10.18.52.144:cdrwa f g h";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not considering the extra arguments after the acls.", zkMain.processZKCmd(zkMain.cl));}
0
public void testCreatePersistentNode() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node2";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not creating Persistent node.", zkMain.processZKCmd(zkMain.cl));}
0
public void testDelete() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node2 data";    String cmdstring2 = "delete /node2";    String cmdstring3 = "ls /node2";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse("", zkMain.processCmd(zkMain.cl));}
0
public void testDeleteNonexistantNode() throws Exception
{    testInvalidCommand("delete /blahblahblah", 1);}
0
public void testStatCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node3 data";    String cmdstring2 = "stat /node3";    String cmdstring3 = "delete /node3";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
0
public void testInvalidStatCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring1 = "stat /node123";    zkMain.cl.parseCommand(cmdstring1);    try {        assertFalse(zkMain.processZKCmd(zkMain.cl));        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
0
public void testSetData() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node4 data";    String cmdstring2 = "set /node4 " + "data";    String cmdstring3 = "delete /node4";    Stat stat = new Stat();    int version = 0;    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    version = stat.getVersion();    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    assertEquals(version + 1, stat.getVersion());    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
0
public void testCheckInvalidAcls() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s -e /node data ip:scheme:gggsd";        zkMain.executeLine(cmdstring);}
0
public void testDeleteWithInvalidVersionNo() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create -s -e /node1 data ";        String cmdstring1 = "delete /node1 2";    zkMain.executeLine(cmdstring);        zkMain.executeLine(cmdstring1);}
0
public void testCliCommandsNotEchoingUsage() throws Exception
{            final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "printwatches";    zkMain.executeLine(cmd1);    String cmd2 = "history";    zkMain.executeLine(cmd2);    String cmd3 = "redo";    zkMain.executeLine(cmd3);        System.setErr(systemErr);    if (errContent.toString().contains("ZooKeeper -server host:port cmd args")) {        fail("CLI commands (history, redo, connect, printwatches) display usage info!");    }}
0
public void testRedoWithNegativeCmdNumber() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "redo -1";                final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    try {        zkMain.executeLine(cmd1);        assertEquals("Command index out of range", errContent.toString().trim());    } finally {                System.setErr(systemErr);    }}
0
private static void runCommandExpect(CliCommand command, List<String> expectedResults) throws Exception
{        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    PrintStream out = new PrintStream(byteStream);    command.setOut(out);    command.exec();    String result = byteStream.toString();    assertTrue(result, result.contains(StringUtils.joinStrings(expectedResults, LINE_SEPARATOR)));}
0
public void testSortedLs() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /aa1");    zkMain.executeLine("create /aa2");    zkMain.executeLine("create /aa3");    zkMain.executeLine("create /test1");    zkMain.executeLine("create /zk1");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("[aa1, aa2, aa3, test1, zk1, zookeeper]");    runCommandExpect(cmd, expected);}
0
public void testLsrCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /a");    zkMain.executeLine("create /a/b");    zkMain.executeLine("create /a/c");    zkMain.executeLine("create /a/b/d");    zkMain.executeLine("create /a/c/e");    zkMain.executeLine("create /a/f");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /a".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/a");    expected.add("/a/b");    expected.add("/a/c");    expected.add("/a/f");    expected.add("/a/b/d");    expected.add("/a/c/e");    runCommandExpect(cmd, expected);}
0
public void testLsrRootCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/");    expected.add("/zookeeper");    runCommandExpect(cmd, expected);}
0
public void testLsrLeafCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/b/c");    runCommandExpect(cmd, expected);}
0
public void testLsrNonexistantZnodeCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c/d".split(" "));    try {        runCommandExpect(cmd, new ArrayList<String>());        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
0
public void testSetAclRecursive() throws Exception
{    final ZooKeeper zk = createClient();    final byte[] EMPTY = new byte[0];    zk.setData("/", EMPTY, -1);    zk.create("/a", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/c", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/d", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/e", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String setAclCommand = "setAcl -R /a world:anyone:r";    zkMain.cl.parseCommand(setAclCommand);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b/c", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/d", new Stat()));        assertEquals(Ids.OPEN_ACL_UNSAFE, zk.getACL("/e", new Stat()));}
0
public void testClientReconnectWithZKClientConfig() throws Exception
{    ZooKeeper zk = null;    ZooKeeper newZKClient = null;    try {        zk = createClient();        ZKClientConfig clientConfig = new ZKClientConfig();        clientConfig.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");        CountdownWatcher watcher = new CountdownWatcher();        HostProvider aHostProvider = new StaticHostProvider(new ConnectStringParser(hostPort).getServerAddresses());        newZKClient = new ZooKeeper(hostPort, zk.getSessionTimeout(), watcher, zk.getSessionId(), zk.getSessionPasswd(), false, aHostProvider, clientConfig);        watcher.waitForConnected(CONNECTION_TIMEOUT);        assertEquals("Old client session id and new clinet session id must be same", zk.getSessionId(), newZKClient.getSessionId());    } finally {        zk.close();        newZKClient.close();    }}
0
public void testSyncCommand() throws Exception
{    final ZooKeeper zk = createClient();    SyncCommand cmd = new SyncCommand();    cmd.setZk(zk);    cmd.parse("sync /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("Sync is OK");    runCommandExpect(cmd, expected);}
0
