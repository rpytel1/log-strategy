public Cache<K, V> getCache(String name) throws IllegalArgumentException, CacheException
{    if (!StringUtils.hasText(name)) {        throw new IllegalArgumentException("Cache name cannot be null or empty.");    }    Cache cache;    cache = caches.get(name);    if (cache == null) {        cache = createCache(name);        Cache existing = caches.putIfAbsent(name, cache);        if (existing != null) {            cache = existing;        }    }        return cache;}
0
public void destroy() throws Exception
{    while (!caches.isEmpty()) {        for (Cache cache : caches.values()) {            LifecycleUtils.destroy(cache);        }        caches.clear();    }}
0
public String toString()
{    Collection<Cache> values = caches.values();    StringBuilder sb = new StringBuilder(getClass().getSimpleName()).append(" with ").append(caches.size()).append(" cache(s)): [");    int i = 0;    for (Cache cache : values) {        if (i > 0) {            sb.append(", ");        }        sb.append(cache.toString());        i++;    }    sb.append("]");    return sb.toString();}
0
public V get(K key) throws CacheException
{    return map.get(key);}
0
public V put(K key, V value) throws CacheException
{    return map.put(key, value);}
0
public V remove(K key) throws CacheException
{    return map.remove(key);}
0
public void clear() throws CacheException
{    map.clear();}
0
public int size()
{    return map.size();}
0
public Set<K> keys()
{    Set<K> keys = map.keySet();    if (!keys.isEmpty()) {        return Collections.unmodifiableSet(keys);    }    return Collections.emptySet();}
0
public Collection<V> values()
{    Collection<V> values = map.values();    if (!map.isEmpty()) {        return Collections.unmodifiableCollection(values);    }    return Collections.emptySet();}
0
public String toString()
{    return new StringBuilder("MapCache '").append(name).append("' (").append(map.size()).append(" entries)").toString();}
0
protected Cache createCache(String name)
{    return new MapCache<Object, Object>(name, new SoftHashMap<Object, Object>());}
0
public boolean isEmpty()
{    Collection<Section> sections = this.sections.values();    if (!sections.isEmpty()) {        for (Section section : sections) {            if (!section.isEmpty()) {                return false;            }        }    }    return true;}
0
public Set<String> getSectionNames()
{    return Collections.unmodifiableSet(sections.keySet());}
0
public Collection<Section> getSections()
{    return Collections.unmodifiableCollection(sections.values());}
0
public Section getSection(String sectionName)
{    String name = cleanName(sectionName);    return sections.get(name);}
0
public Section addSection(String sectionName)
{    String name = cleanName(sectionName);    Section section = getSection(name);    if (section == null) {        section = new Section(name);        this.sections.put(name, section);    }    return section;}
0
public Section removeSection(String sectionName)
{    String name = cleanName(sectionName);    return this.sections.remove(name);}
0
private static String cleanName(String sectionName)
{    String name = StringUtils.clean(sectionName);    if (name == null) {        log.trace("Specified name was null or empty.  Defaulting to the default section (name = \"\")");        name = DEFAULT_SECTION_NAME;    }    return name;}
0
public void setSectionProperty(String sectionName, String propertyName, String propertyValue)
{    String name = cleanName(sectionName);    Section section = getSection(name);    if (section == null) {        section = addSection(name);    }    section.put(propertyName, propertyValue);}
0
public String getSectionProperty(String sectionName, String propertyName)
{    Section section = getSection(sectionName);    return section != null ? section.get(propertyName) : null;}
0
public String getSectionProperty(String sectionName, String propertyName, String defaultValue)
{    String value = getSectionProperty(sectionName, propertyName);    return value != null ? value : defaultValue;}
0
public static Ini fromResourcePath(String resourcePath) throws ConfigurationException
{    if (!StringUtils.hasLength(resourcePath)) {        throw new IllegalArgumentException("Resource Path argument cannot be null or empty.");    }    Ini ini = new Ini();    ini.loadFromPath(resourcePath);    return ini;}
0
public void loadFromPath(String resourcePath) throws ConfigurationException
{    InputStream is;    try {        is = ResourceUtils.getInputStreamForPath(resourcePath);    } catch (IOException e) {        throw new ConfigurationException(e);    }    load(is);}
0
public void load(String iniConfig) throws ConfigurationException
{    load(new Scanner(iniConfig));}
0
public void load(InputStream is) throws ConfigurationException
{    if (is == null) {        throw new NullPointerException("InputStream argument cannot be null.");    }    InputStreamReader isr;    try {        isr = new InputStreamReader(is, DEFAULT_CHARSET_NAME);    } catch (UnsupportedEncodingException e) {        throw new ConfigurationException(e);    }    load(isr);}
0
public void load(Reader reader)
{    Scanner scanner = new Scanner(reader);    try {        load(scanner);    } finally {        try {            scanner.close();        } catch (Exception e) {                    }    }}
1
public void merge(Map<String, Section> m)
{    if (m != null) {        for (Entry<String, Section> entry : m.entrySet()) {            Section section = this.getSection(entry.getKey());            if (section == null) {                section = addSection(entry.getKey());            }            section.putAll(entry.getValue());        }    }}
0
private void addSection(String name, StringBuilder content)
{    if (content.length() > 0) {        String contentString = content.toString();        String cleaned = StringUtils.clean(contentString);        if (cleaned != null) {            Section section = new Section(name, contentString);            if (!section.isEmpty()) {                sections.put(name, section);            }        }    }}
0
public void load(Scanner scanner)
{    String sectionName = DEFAULT_SECTION_NAME;    StringBuilder sectionContent = new StringBuilder();    while (scanner.hasNextLine()) {        String rawLine = scanner.nextLine();        String line = StringUtils.clean(rawLine);        if (line == null || line.startsWith(COMMENT_POUND) || line.startsWith(COMMENT_SEMICOLON)) {                        continue;        }        String newSectionName = getSectionName(line);        if (newSectionName != null) {                        addSection(sectionName, sectionContent);                        sectionContent = new StringBuilder();            sectionName = newSectionName;            if (log.isDebugEnabled()) {                            }        } else {                        sectionContent.append(rawLine).append("\n");        }    }        addSection(sectionName, sectionContent);}
1
protected static boolean isSectionHeader(String line)
{    String s = StringUtils.clean(line);    return s != null && s.startsWith(SECTION_PREFIX) && s.endsWith(SECTION_SUFFIX);}
0
protected static String getSectionName(String line)
{    String s = StringUtils.clean(line);    if (isSectionHeader(s)) {        return cleanName(s.substring(1, s.length() - 1));    }    return null;}
0
public boolean equals(Object obj)
{    if (obj instanceof Ini) {        Ini ini = (Ini) obj;        return this.sections.equals(ini.sections);    }    return false;}
0
public int hashCode()
{    return this.sections.hashCode();}
0
public String toString()
{    if (this.sections == null || this.sections.isEmpty()) {        return "<empty INI>";    } else {        StringBuilder sb = new StringBuilder("sections=");        int i = 0;        for (Ini.Section section : this.sections.values()) {            if (i > 0) {                sb.append(",");            }            sb.append(section.toString());            i++;        }        return sb.toString();    }}
0
public int size()
{    return this.sections.size();}
0
public boolean containsKey(Object key)
{    return this.sections.containsKey(key);}
0
public boolean containsValue(Object value)
{    return this.sections.containsValue(value);}
0
public Section get(Object key)
{    return this.sections.get(key);}
0
public Section put(String key, Section value)
{    return this.sections.put(key, value);}
0
public Section remove(Object key)
{    return this.sections.remove(key);}
0
public void putAll(Map<? extends String, ? extends Section> m)
{    this.sections.putAll(m);}
0
public void clear()
{    this.sections.clear();}
0
public Set<String> keySet()
{    return Collections.unmodifiableSet(this.sections.keySet());}
0
public Collection<Section> values()
{    return Collections.unmodifiableCollection(this.sections.values());}
0
public Set<Entry<String, Section>> entrySet()
{    return Collections.unmodifiableSet(this.sections.entrySet());}
0
protected static boolean isContinued(String line)
{    if (!StringUtils.hasText(line)) {        return false;    }    int length = line.length();            int backslashCount = 0;    for (int i = length - 1; i > 0; i--) {        if (line.charAt(i) == ESCAPE_TOKEN) {            backslashCount++;        } else {            break;        }    }    return backslashCount % 2 != 0;}
0
private static boolean isKeyValueSeparatorChar(char c)
{    return Character.isWhitespace(c) || c == ':' || c == '=';}
0
private static boolean isCharEscaped(CharSequence s, int index)
{    return index > 0 && s.charAt(index - 1) == ESCAPE_TOKEN;}
0
protected static String[] splitKeyValue(String keyValueLine)
{    String line = StringUtils.clean(keyValueLine);    if (line == null) {        return null;    }    StringBuilder keyBuffer = new StringBuilder();    StringBuilder valueBuffer = new StringBuilder();        boolean buildingKey = true;    for (int i = 0; i < line.length(); i++) {        char c = line.charAt(i);        if (buildingKey) {            if (isKeyValueSeparatorChar(c) && !isCharEscaped(line, i)) {                                buildingKey = false;            } else {                keyBuffer.append(c);            }        } else {            if (valueBuffer.length() == 0 && isKeyValueSeparatorChar(c) && !isCharEscaped(line, i)) {                        } else {                valueBuffer.append(c);            }        }    }    String key = StringUtils.clean(keyBuffer.toString());    String value = StringUtils.clean(valueBuffer.toString());    if (key == null || value == null) {        String msg = "Line argument must contain a key and a value.  Only one string token was found.";        throw new IllegalArgumentException(msg);    }    log.trace("Discovered key/value pair: {} = {}", key, value);    return new String[] { key, value };}
0
private static Map<String, String> toMapProps(String content)
{    Map<String, String> props = new LinkedHashMap<String, String>();    String line;    StringBuilder lineBuffer = new StringBuilder();    Scanner scanner = new Scanner(content);    while (scanner.hasNextLine()) {        line = StringUtils.clean(scanner.nextLine());        if (isContinued(line)) {                        line = line.substring(0, line.length() - 1);            lineBuffer.append(line);            continue;        } else {            lineBuffer.append(line);        }        line = lineBuffer.toString();        lineBuffer = new StringBuilder();        String[] kvPair = splitKeyValue(line);        props.put(kvPair[0], kvPair[1]);    }    return props;}
0
public String getName()
{    return this.name;}
0
public void clear()
{    this.props.clear();}
0
public boolean containsKey(Object key)
{    return this.props.containsKey(key);}
0
public boolean containsValue(Object value)
{    return this.props.containsValue(value);}
0
public Set<Entry<String, String>> entrySet()
{    return this.props.entrySet();}
0
public String get(Object key)
{    return this.props.get(key);}
0
public boolean isEmpty()
{    return this.props.isEmpty();}
0
public Set<String> keySet()
{    return this.props.keySet();}
0
public String put(String key, String value)
{    return this.props.put(key, value);}
0
public void putAll(Map<? extends String, ? extends String> m)
{    this.props.putAll(m);}
0
public String remove(Object key)
{    return this.props.remove(key);}
0
public int size()
{    return this.props.size();}
0
public Collection<String> values()
{    return this.props.values();}
0
public String toString()
{    String name = getName();    if (DEFAULT_SECTION_NAME.equals(name)) {        return "<default>";    }    return name;}
0
public boolean equals(Object obj)
{    if (obj instanceof Section) {        Section other = (Section) obj;        return getName().equals(other.getName()) && this.props.equals(other.props);    }    return false;}
0
public int hashCode()
{    return this.name.hashCode() * 31 + this.props.hashCode();}
0
public String interpolate(String value)
{    return (String) interpolator.interpolate(value);}
0
public ConfigurationInterpolator getConfigurationInterpolator()
{    return interpolator;}
0
public String interpolate(String value)
{    return value;}
0
public String getBeanName()
{    return beanName;}
0
public Object getBean()
{    return bean;}
0
public Map<String, Object> getBeanContext()
{    return beanContext;}
0
public void onEvent(BeanEvent e)
{    String className = e.getClass().getSimpleName();    int i = className.lastIndexOf(SUFFIX);    String subclassPrefix = i > 0 ? className.substring(0, i) : className;    logger.trace("{} bean '{}' [{}]", new Object[] { subclassPrefix, e.getBeanName(), e.getBean() });}
0
private Map<String, Object> createDefaultObjectMap()
{    Map<String, Object> map = new LinkedHashMap<String, Object>();    map.put(EVENT_BUS_NAME, new DefaultEventBus());    return map;}
0
private void apply(Map<String, ?> objects)
{    if (!isEmpty(objects)) {        this.objects.putAll(objects);    }    EventBus found = findEventBus(this.objects);    Assert.notNull(found, "An " + EventBus.class.getName() + " instance must be present in the object defaults");    enableEvents(found);}
0
public Map<String, ?> getObjects()
{    return objects;}
0
public void setObjects(Map<String, ?> objects)
{    this.objects.clear();    this.objects.putAll(createDefaultObjectMap());    apply(objects);}
0
private void enableEvents(EventBus eventBus)
{    Assert.notNull(eventBus, "EventBus argument cannot be null.");        for (Object subscriber : this.registeredEventSubscribers.values()) {        this.eventBus.unregister(subscriber);    }    this.registeredEventSubscribers.clear();    this.eventBus = eventBus;    for (Map.Entry<String, Object> entry : this.objects.entrySet()) {        enableEventsIfNecessary(entry.getValue(), entry.getKey());    }}
0
private void enableEventsIfNecessary(Object bean, String name)
{    boolean applied = applyEventBusIfNecessary(bean);    if (!applied) {                if (isEventSubscriber(bean, name)) {                        this.eventBus.register(bean);            this.registeredEventSubscribers.put(name, bean);        }    }}
0
private boolean isEventSubscriber(Object bean, String name)
{    List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);    return !isEmpty(annotatedMethods);}
0
protected EventBus findEventBus(Map<String, ?> objects)
{    if (isEmpty(objects)) {        return null;    }        Object value = objects.get(EVENT_BUS_NAME);    if (value != null && value instanceof EventBus) {        return (EventBus) value;    }        for (Object v : objects.values()) {        if (v instanceof EventBus) {            return (EventBus) v;        }    }    return null;}
0
private boolean applyEventBusIfNecessary(Object value)
{    if (value instanceof EventBusAware) {        ((EventBusAware) value).setEventBus(this.eventBus);        return true;    }    return false;}
0
public Object getBean(String id)
{    return objects.get(id);}
0
public T getBean(String id, Class<T> requiredType)
{    if (requiredType == null) {        throw new NullPointerException("requiredType argument cannot be null.");    }    Object bean = getBean(id);    if (bean == null) {        return null;    }    Assert.state(requiredType.isAssignableFrom(bean.getClass()), "Bean with id [" + id + "] is not of the required type [" + requiredType.getName() + "].");    return (T) bean;}
0
private String parseBeanId(String lhs)
{    Assert.notNull(lhs);    if (lhs.indexOf('.') < 0) {        return lhs;    }    String classSuffix = ".class";    int index = lhs.indexOf(classSuffix);    if (index >= 0) {        return lhs.substring(0, index);    }    return null;}
0
public Map<String, ?> buildObjects(Map<String, String> kvPairs)
{    if (kvPairs != null && !kvPairs.isEmpty()) {        BeanConfigurationProcessor processor = new BeanConfigurationProcessor();        for (Map.Entry<String, String> entry : kvPairs.entrySet()) {            String lhs = entry.getKey();            String rhs = interpolator.interpolate(entry.getValue());            String beanId = parseBeanId(lhs);            if (beanId != null) {                                processor.add(new InstantiationStatement(beanId, rhs));            } else {                                processor.add(new AssignmentStatement(lhs, rhs));            }        }        processor.execute();    }        LifecycleUtils.init(objects.values());    return objects;}
0
public void destroy()
{    final Map<String, Object> immutableObjects = Collections.unmodifiableMap(objects);        List<Map.Entry<String, ?>> entries = new ArrayList<Map.Entry<String, ?>>(objects.entrySet());    Collections.reverse(entries);    for (Map.Entry<String, ?> entry : entries) {        String id = entry.getKey();        Object bean = entry.getValue();                if (bean != this.eventBus) {                        LifecycleUtils.destroy(bean);            BeanEvent event = new DestroyedBeanEvent(id, bean, immutableObjects);            eventBus.publish(event);                        this.eventBus.unregister(bean);        }    }        LifecycleUtils.destroy(this.eventBus);}
0
protected void createNewInstance(Map<String, Object> objects, String name, String value)
{    Object currentInstance = objects.get(name);    if (currentInstance != null) {            }        Object instance;    try {        instance = ClassUtils.newInstance(value);        if (instance instanceof Nameable) {            ((Nameable) instance).setName(name);        }    } catch (Exception e) {        String msg = "Unable to instantiate class [" + value + "] for object named '" + name + "'.  " + "Please ensure you've specified the fully qualified class name correctly.";        throw new ConfigurationException(msg, e);    }    objects.put(name, instance);}
1
protected void applyProperty(String key, String value, Map objects)
{    int index = key.indexOf('.');    if (index >= 0) {        String name = key.substring(0, index);        String property = key.substring(index + 1, key.length());        if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {            applyGlobalProperty(objects, property, value);        } else {            applySingleProperty(objects, name, property, value);        }    } else {        throw new IllegalArgumentException("All property keys must contain a '.' character. " + "(e.g. myBean.property = value)  These should already be separated out by buildObjects().");    }}
0
protected void applyGlobalProperty(Map objects, String property, String value)
{    for (Object instance : objects.values()) {        try {            PropertyDescriptor pd = beanUtilsBean.getPropertyUtils().getPropertyDescriptor(instance, property);            if (pd != null) {                applyProperty(instance, property, value);            }        } catch (Exception e) {            String msg = "Error retrieving property descriptor for instance " + "of type [" + instance.getClass().getName() + "] " + "while setting property [" + property + "]";            throw new ConfigurationException(msg, e);        }    }}
0
protected void applySingleProperty(Map objects, String name, String property, String value)
{    Object instance = objects.get(name);    if (property.equals("class")) {        throw new IllegalArgumentException("Property keys should not contain 'class' properties since these " + "should already be separated out by buildObjects().");    } else if (instance == null) {        String msg = "Configuration error.  Specified object [" + name + "] with property [" + property + "] without first defining that object's class.  Please first " + "specify the class property first, e.g. myObject = fully_qualified_class_name " + "and then define additional properties.";        throw new IllegalArgumentException(msg);    } else {        applyProperty(instance, property, value);    }}
0
protected boolean isReference(String value)
{    return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);}
0
protected String getId(String referenceToken)
{    return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());}
0
protected Object getReferencedObject(String id)
{    Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;    if (o == null) {        String msg = "The object with id [" + id + "] has not yet been defined and therefore cannot be " + "referenced.  Please ensure objects are defined in the order in which they should be " + "created and made available for future reference.";        throw new UnresolveableReferenceException(msg);    }    return o;}
0
protected String unescapeIfNecessary(String value)
{    if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {        return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);    }    return value;}
0
protected Object resolveReference(String reference)
{    String id = getId(reference);        final Object referencedObject = getReferencedObject(id);    if (referencedObject instanceof Factory) {        return ((Factory) referencedObject).getInstance();    }    return referencedObject;}
1
protected boolean isTypedProperty(Object object, String propertyName, Class clazz)
{    if (clazz == null) {        throw new NullPointerException("type (class) argument cannot be null.");    }    try {        PropertyDescriptor descriptor = beanUtilsBean.getPropertyUtils().getPropertyDescriptor(object, propertyName);        if (descriptor == null) {            String msg = "Property '" + propertyName + "' does not exist for object of " + "type " + object.getClass().getName() + ".";            throw new ConfigurationException(msg);        }        Class propertyClazz = descriptor.getPropertyType();        return clazz.isAssignableFrom(propertyClazz);    } catch (ConfigurationException ce) {                throw ce;    } catch (Exception e) {        String msg = "Unable to determine if property [" + propertyName + "] represents a " + clazz.getName();        throw new ConfigurationException(msg, e);    }}
0
protected Set<?> toSet(String sValue)
{    String[] tokens = StringUtils.split(sValue);    if (tokens == null || tokens.length <= 0) {        return null;    }        if (tokens.length == 1 && isReference(tokens[0])) {        Object reference = resolveReference(tokens[0]);        if (reference instanceof Set) {            return (Set) reference;        }    }    Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());    for (String token : setTokens) {        Object value = resolveValue(token);        values.add(value);    }    return values;}
0
protected Map<?, ?> toMap(String sValue)
{    String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);    if (tokens == null || tokens.length <= 0) {        return null;    }        if (tokens.length == 1 && isReference(tokens[0])) {        Object reference = resolveReference(tokens[0]);        if (reference instanceof Map) {            return (Map) reference;        }    }    Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);    for (String token : tokens) {        String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);        if (kvPair == null || kvPair.length != 2) {            String msg = "Map property value [" + sValue + "] contained key-value pair token [" + token + "] that does not properly split to a single key and pair.  This must be the " + "case for all map entries.";            throw new ConfigurationException(msg);        }        mapTokens.put(kvPair[0], kvPair[1]);    }        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());    for (Map.Entry<String, String> entry : mapTokens.entrySet()) {        Object key = resolveValue(entry.getKey());        Object value = resolveValue(entry.getValue());        map.put(key, value);    }    return map;}
0
protected Collection<?> toCollection(String sValue)
{    String[] tokens = StringUtils.split(sValue);    if (tokens == null || tokens.length <= 0) {        return null;    }        if (tokens.length == 1 && isReference(tokens[0])) {        Object reference = resolveReference(tokens[0]);        if (reference instanceof Collection) {            return (Collection) reference;        }    }        List<Object> values = new ArrayList<Object>(tokens.length);    for (String token : tokens) {        Object value = resolveValue(token);        values.add(value);    }    return values;}
0
protected List<?> toList(String sValue)
{    String[] tokens = StringUtils.split(sValue);    if (tokens == null || tokens.length <= 0) {        return null;    }        if (tokens.length == 1 && isReference(tokens[0])) {        Object reference = resolveReference(tokens[0]);        if (reference instanceof List) {            return (List) reference;        }    }        List<Object> values = new ArrayList<Object>(tokens.length);    for (String token : tokens) {        Object value = resolveValue(token);        values.add(value);    }    return values;}
0
protected byte[] toBytes(String sValue)
{    if (sValue == null) {        return null;    }    byte[] bytes;    if (sValue.startsWith(HEX_BEGIN_TOKEN)) {        String hex = sValue.substring(HEX_BEGIN_TOKEN.length());        bytes = Hex.decode(hex);    } else {                bytes = Base64.decode(sValue);    }    return bytes;}
0
protected Object resolveValue(String stringValue)
{    Object value;    if (isReference(stringValue)) {        value = resolveReference(stringValue);    } else {        value = unescapeIfNecessary(stringValue);    }    return value;}
0
protected String checkForNullOrEmptyLiteral(String stringValue)
{    if (stringValue == null) {        return null;    }        if (stringValue.equals("\"null\"")) {        return NULL_VALUE_TOKEN;    } else     if (stringValue.equals("\"\"\"\"")) {        return EMPTY_STRING_VALUE_TOKEN;    } else {        return stringValue;    }}
0
protected void applyProperty(Object object, String propertyPath, Object value)
{    int mapBegin = propertyPath.indexOf(MAP_PROPERTY_BEGIN_TOKEN);    int mapEnd = -1;    String mapPropertyPath = null;    String keyString = null;    String remaining = null;    if (mapBegin >= 0) {                mapPropertyPath = propertyPath.substring(0, mapBegin);                mapEnd = propertyPath.indexOf(MAP_PROPERTY_END_TOKEN, mapBegin);                keyString = propertyPath.substring(mapBegin + 1, mapEnd);                if (propertyPath.length() > (mapEnd + 1)) {            remaining = propertyPath.substring(mapEnd + 1);            if (remaining.startsWith(".")) {                remaining = StringUtils.clean(remaining.substring(1));            }        }    }    if (remaining == null) {                if (keyString == null) {                        setProperty(object, propertyPath, value);        } else {                        if (isTypedProperty(object, mapPropertyPath, Map.class)) {                Map map = (Map) getProperty(object, mapPropertyPath);                Object mapKey = resolveValue(keyString);                                map.put(mapKey, value);            } else {                                int index = Integer.valueOf(keyString);                setIndexedProperty(object, mapPropertyPath, index, value);            }        }    } else {                        Object referencedValue = null;        if (isTypedProperty(object, mapPropertyPath, Map.class)) {            Map map = (Map) getProperty(object, mapPropertyPath);            Object mapKey = resolveValue(keyString);            referencedValue = map.get(mapKey);        } else {                        int index = Integer.valueOf(keyString);            referencedValue = getIndexedProperty(object, mapPropertyPath, index);        }        if (referencedValue == null) {            throw new ConfigurationException("Referenced map/array value '" + mapPropertyPath + "[" + keyString + "]' does not exist.");        }        applyProperty(referencedValue, remaining, value);    }}
0
private void setProperty(Object object, String propertyPath, Object value)
{    try {        if (log.isTraceEnabled()) {            log.trace("Applying property [{}] value [{}] on object of type [{}]", new Object[] { propertyPath, value, object.getClass().getName() });        }        beanUtilsBean.setProperty(object, propertyPath, value);    } catch (Exception e) {        String msg = "Unable to set property '" + propertyPath + "' with value [" + value + "] on object " + "of type " + (object != null ? object.getClass().getName() : null) + ".  If " + "'" + value + "' is a reference to another (previously defined) object, prefix it with " + "'" + OBJECT_REFERENCE_BEGIN_TOKEN + "' to indicate that the referenced " + "object should be used as the actual value.  " + "For example, " + OBJECT_REFERENCE_BEGIN_TOKEN + value;        throw new ConfigurationException(msg, e);    }}
0
private Object getProperty(Object object, String propertyPath)
{    try {        return beanUtilsBean.getPropertyUtils().getProperty(object, propertyPath);    } catch (Exception e) {        throw new ConfigurationException("Unable to access property '" + propertyPath + "'", e);    }}
0
private void setIndexedProperty(Object object, String propertyPath, int index, Object value)
{    try {        beanUtilsBean.getPropertyUtils().setIndexedProperty(object, propertyPath, index, value);    } catch (Exception e) {        throw new ConfigurationException("Unable to set array property '" + propertyPath + "'", e);    }}
0
private Object getIndexedProperty(Object object, String propertyPath, int index)
{    try {        return beanUtilsBean.getPropertyUtils().getIndexedProperty(object, propertyPath, index);    } catch (Exception e) {        throw new ConfigurationException("Unable to acquire array property '" + propertyPath + "'", e);    }}
0
protected boolean isIndexedPropertyAssignment(String propertyPath)
{    return propertyPath.endsWith("" + MAP_PROPERTY_END_TOKEN);}
0
protected void applyProperty(Object object, String propertyName, String stringValue)
{    Object value;    if (NULL_VALUE_TOKEN.equals(stringValue)) {        value = null;    } else if (EMPTY_STRING_VALUE_TOKEN.equals(stringValue)) {        value = StringUtils.EMPTY_STRING;    } else if (isIndexedPropertyAssignment(propertyName)) {        String checked = checkForNullOrEmptyLiteral(stringValue);        value = resolveValue(checked);    } else if (isTypedProperty(object, propertyName, Set.class)) {        value = toSet(stringValue);    } else if (isTypedProperty(object, propertyName, Map.class)) {        value = toMap(stringValue);    } else if (isTypedProperty(object, propertyName, List.class)) {        value = toList(stringValue);    } else if (isTypedProperty(object, propertyName, Collection.class)) {        value = toCollection(stringValue);    } else if (isTypedProperty(object, propertyName, byte[].class)) {        value = toBytes(stringValue);    } else if (isTypedProperty(object, propertyName, ByteSource.class)) {        byte[] bytes = toBytes(stringValue);        value = ByteSource.Util.bytes(bytes);    } else {        String checked = checkForNullOrEmptyLiteral(stringValue);        value = resolveValue(checked);    }    applyProperty(object, propertyName, value);}
0
private Interpolator createInterpolator()
{    if (ClassUtils.isAvailable("org.apache.commons.configuration2.interpol.ConfigurationInterpolator")) {        return new CommonsInterpolator();    }    return new DefaultInterpolator();}
0
public void setInterpolator(Interpolator interpolator)
{    this.interpolator = interpolator;}
0
public void add(Statement statement)
{        statements.add(statement);    if (statement instanceof InstantiationStatement) {        InstantiationStatement is = (InstantiationStatement) statement;        beanConfigurations.add(new BeanConfiguration(is));    } else {        AssignmentStatement as = (AssignmentStatement) statement;                        boolean addedToConfig = false;        String beanName = as.getRootBeanName();        for (int i = beanConfigurations.size() - 1; i >= 0; i--) {            BeanConfiguration mostRecent = beanConfigurations.get(i);            String mostRecentBeanName = mostRecent.getBeanName();            if (beanName.equals(mostRecentBeanName)) {                mostRecent.add(as);                addedToConfig = true;                break;            }        }        if (!addedToConfig) {                                                            beanConfigurations.add(new BeanConfiguration(as));        }    }}
0
public void execute()
{    for (Statement statement : statements) {        statement.execute();        BeanConfiguration bd = statement.getBeanConfiguration();        if (bd.isExecuted()) {                        if (bd.getBeanName().equals(EVENT_BUS_NAME)) {                EventBus eventBus = (EventBus) bd.getBean();                enableEvents(eventBus);            }                        if (!bd.isGlobalConfig()) {                BeanEvent event = new ConfiguredBeanEvent(bd.getBeanName(), bd.getBean(), Collections.unmodifiableMap(objects));                eventBus.publish(event);            }                        LifecycleUtils.init(bd.getBean());                        if (!bd.isGlobalConfig()) {                BeanEvent event = new InitializedBeanEvent(bd.getBeanName(), bd.getBean(), Collections.unmodifiableMap(objects));                eventBus.publish(event);            }        }    }}
0
public String getBeanName()
{    return this.beanName;}
0
public boolean isGlobalConfig()
{        return GLOBAL_PROPERTY_PREFIX.equals(getBeanName());}
0
public void add(AssignmentStatement as)
{    as.setBeanConfiguration(this);    assignments.add(as);}
0
public void setBean(Object bean)
{    this.bean = bean;}
0
public Object getBean()
{    return this.bean;}
0
public boolean isExecuted()
{    if (instantiationStatement != null && !instantiationStatement.isExecuted()) {        return false;    }    for (AssignmentStatement as : assignments) {        if (!as.isExecuted()) {            return false;        }    }    return true;}
0
public void setBeanConfiguration(BeanConfiguration bd)
{    this.beanConfiguration = bd;}
0
public BeanConfiguration getBeanConfiguration()
{    return this.beanConfiguration;}
0
public Object execute()
{    if (!isExecuted()) {        this.result = doExecute();        this.executed = true;    }    if (!getBeanConfiguration().isGlobalConfig()) {        Assert.notNull(this.bean, "Implementation must set the root bean for which it executed.");    }    return this.result;}
0
public Object getBean()
{    return this.bean;}
0
protected void setBean(Object bean)
{    this.bean = bean;    if (this.beanConfiguration.getBean() == null) {        this.beanConfiguration.setBean(bean);    }}
0
public Object getResult()
{    return result;}
0
public boolean isExecuted()
{    return executed;}
0
protected Object doExecute()
{    String beanName = this.lhs;    createNewInstance(objects, beanName, this.rhs);    Object instantiated = objects.get(beanName);    setBean(instantiated);                enableEventsIfNecessary(instantiated, beanName);    BeanEvent event = new InstantiatedBeanEvent(beanName, instantiated, Collections.unmodifiableMap(objects));    eventBus.publish(event);    return instantiated;}
0
protected Object doExecute()
{    applyProperty(lhs, rhs, objects);    Object bean = objects.get(this.rootBeanName);    setBean(bean);    return null;}
0
public String getRootBeanName()
{    return this.rootBeanName;}
0
private static boolean isEmpty(Map m)
{    return m == null || m.isEmpty();}
0
private static boolean isEmpty(Collection c)
{    return c == null || c.isEmpty();}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
protected void setAnnotationClass(Class<? extends Annotation> annotationClass) throws IllegalArgumentException
{    if (annotationClass == null) {        String msg = "annotationClass argument cannot be null";        throw new IllegalArgumentException(msg);    }    this.annotationClass = annotationClass;}
0
public Class<? extends Annotation> getAnnotationClass()
{    return this.annotationClass;}
0
public AnnotationHandler getHandler()
{    return handler;}
0
public void setHandler(AnnotationHandler handler)
{    this.handler = handler;}
0
public AnnotationResolver getResolver()
{    return resolver;}
0
public void setResolver(AnnotationResolver resolver)
{    this.resolver = resolver;}
0
public boolean supports(MethodInvocation mi)
{    return getAnnotation(mi) != null;}
0
protected Annotation getAnnotation(MethodInvocation mi)
{    return getResolver().getAnnotation(mi, getHandler().getAnnotationClass());}
0
public Annotation getAnnotation(MethodInvocation mi, Class<? extends Annotation> clazz)
{    if (mi == null) {        throw new IllegalArgumentException("method argument cannot be null");    }    Method m = mi.getMethod();    if (m == null) {        String msg = MethodInvocation.class.getName() + " parameter incorrectly constructed.  getMethod() returned null";        throw new IllegalArgumentException(msg);    }    Annotation annotation = m.getAnnotation(clazz);    if (annotation == null) {        Object miThis = mi.getThis();                annotation = miThis != null ? miThis.getClass().getAnnotation(clazz) : null;    }    return annotation;}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
public void setAuthenticationListeners(Collection<AuthenticationListener> listeners)
{    if (listeners == null) {        this.listeners = new ArrayList<AuthenticationListener>();    } else {        this.listeners = listeners;    }}
0
public Collection<AuthenticationListener> getAuthenticationListeners()
{    return this.listeners;}
0
protected void notifySuccess(AuthenticationToken token, AuthenticationInfo info)
{    for (AuthenticationListener listener : this.listeners) {        listener.onSuccess(token, info);    }}
0
protected void notifyFailure(AuthenticationToken token, AuthenticationException ae)
{    for (AuthenticationListener listener : this.listeners) {        listener.onFailure(token, ae);    }}
0
protected void notifyLogout(PrincipalCollection principals)
{    for (AuthenticationListener listener : this.listeners) {        listener.onLogout(principals);    }}
0
public void onLogout(PrincipalCollection principals)
{    notifyLogout(principals);}
0
public String getHost()
{    return host;}
0
public Object getPrincipal()
{    return token;}
0
public Object getCredentials()
{    return token;}
0
public String getToken()
{    return token;}
0
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info)
{    return true;}
0
public String encryptPassword(Object plaintext)
{    Hash hash = hashPassword(plaintext);    checkHashFormatDurability();    return this.hashFormat.format(hash);}
0
public Hash hashPassword(Object plaintext)
{    ByteSource plaintextBytes = createByteSource(plaintext);    if (plaintextBytes == null || plaintextBytes.isEmpty()) {        return null;    }    HashRequest request = createHashRequest(plaintextBytes);    return hashService.computeHash(request);}
0
public boolean passwordsMatch(Object plaintext, Hash saved)
{    ByteSource plaintextBytes = createByteSource(plaintext);    if (saved == null || saved.isEmpty()) {        return plaintextBytes == null || plaintextBytes.isEmpty();    } else {        if (plaintextBytes == null || plaintextBytes.isEmpty()) {            return false;        }    }    HashRequest request = buildHashRequest(plaintextBytes, saved);    Hash computed = this.hashService.computeHash(request);    return saved.equals(computed);}
0
protected void checkHashFormatDurability()
{    if (!this.hashFormatWarned) {        HashFormat format = this.hashFormat;        if (!(format instanceof ParsableHashFormat) && log.isWarnEnabled()) {            String msg = "The configured hashFormat instance [" + format.getClass().getName() + "] is not a " + ParsableHashFormat.class.getName() + " implementation.  This is " + "required if you wish to support backwards compatibility for saved password checking (almost " + "always desirable).  Without a " + ParsableHashFormat.class.getSimpleName() + " instance, " + "any hashService configuration changes will break previously hashed/saved passwords.";                        this.hashFormatWarned = true;        }    }}
1
protected HashRequest createHashRequest(ByteSource plaintext)
{    return new HashRequest.Builder().setSource(plaintext).build();}
0
protected ByteSource createByteSource(Object o)
{    return ByteSource.Util.bytes(o);}
0
public boolean passwordsMatch(Object submittedPlaintext, String saved)
{    ByteSource plaintextBytes = createByteSource(submittedPlaintext);    if (saved == null || saved.length() == 0) {        return plaintextBytes == null || plaintextBytes.isEmpty();    } else {        if (plaintextBytes == null || plaintextBytes.isEmpty()) {            return false;        }    }                        HashFormat discoveredFormat = this.hashFormatFactory.getInstance(saved);    if (discoveredFormat != null && discoveredFormat instanceof ParsableHashFormat) {        ParsableHashFormat parsableHashFormat = (ParsableHashFormat) discoveredFormat;        Hash savedHash = parsableHashFormat.parse(saved);        return passwordsMatch(submittedPlaintext, savedHash);    }                                HashRequest request = createHashRequest(plaintextBytes);    Hash computed = this.hashService.computeHash(request);    String formatted = this.hashFormat.format(computed);    return saved.equals(formatted);}
0
protected HashRequest buildHashRequest(ByteSource plaintext, Hash saved)
{        return new HashRequest.Builder().setSource(plaintext).setAlgorithmName(saved.getAlgorithmName()).setSalt(saved.getSalt()).setIterations(saved.getIterations()).build();}
0
public HashService getHashService()
{    return hashService;}
0
public void setHashService(HashService hashService)
{    this.hashService = hashService;}
0
public HashFormat getHashFormat()
{    return hashFormat;}
0
public void setHashFormat(HashFormat hashFormat)
{    this.hashFormat = hashFormat;}
0
public HashFormatFactory getHashFormatFactory()
{    return hashFormatFactory;}
0
public void setHashFormatFactory(HashFormatFactory hashFormatFactory)
{    this.hashFormatFactory = hashFormatFactory;}
0
public String getHashAlgorithmName()
{    return hashAlgorithm;}
0
public void setHashAlgorithmName(String hashAlgorithmName)
{    this.hashAlgorithm = hashAlgorithmName;}
0
public boolean isStoredCredentialsHexEncoded()
{    return storedCredentialsHexEncoded;}
0
public void setStoredCredentialsHexEncoded(boolean storedCredentialsHexEncoded)
{    this.storedCredentialsHexEncoded = storedCredentialsHexEncoded;}
0
public boolean isHashSalted()
{    return hashSalted;}
0
public void setHashSalted(boolean hashSalted)
{    this.hashSalted = hashSalted;}
0
public int getHashIterations()
{    return hashIterations;}
0
public void setHashIterations(int hashIterations)
{    if (hashIterations < 1) {        this.hashIterations = 1;    } else {        this.hashIterations = hashIterations;    }}
0
protected Object getSalt(AuthenticationToken token)
{    return token.getPrincipal();}
0
protected Object getCredentials(AuthenticationInfo info)
{    Object credentials = info.getCredentials();    byte[] storedBytes = toBytes(credentials);    if (credentials instanceof String || credentials instanceof char[]) {                if (isStoredCredentialsHexEncoded()) {            storedBytes = Hex.decode(storedBytes);        } else {            storedBytes = Base64.decode(storedBytes);        }    }    AbstractHash hash = newHashInstance();    hash.setBytes(storedBytes);    return hash;}
0
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info)
{    Object tokenHashedCredentials = hashProvidedCredentials(token, info);    Object accountCredentials = getCredentials(info);    return equals(tokenHashedCredentials, accountCredentials);}
0
protected Object hashProvidedCredentials(AuthenticationToken token, AuthenticationInfo info)
{    Object salt = null;    if (info instanceof SaltedAuthenticationInfo) {        salt = ((SaltedAuthenticationInfo) info).getCredentialsSalt();    } else {                if (isHashSalted()) {            salt = getSalt(token);        }    }    return hashProvidedCredentials(token.getCredentials(), salt, getHashIterations());}
0
private String assertHashAlgorithmName() throws IllegalStateException
{    String hashAlgorithmName = getHashAlgorithmName();    if (hashAlgorithmName == null) {        String msg = "Required 'hashAlgorithmName' property has not been set.  This is required to execute " + "the hashing algorithm.";        throw new IllegalStateException(msg);    }    return hashAlgorithmName;}
0
protected Hash hashProvidedCredentials(Object credentials, Object salt, int hashIterations)
{    String hashAlgorithmName = assertHashAlgorithmName();    return new SimpleHash(hashAlgorithmName, credentials, salt, hashIterations);}
0
protected AbstractHash newHashInstance()
{    String hashAlgorithmName = assertHashAlgorithmName();    return new SimpleHash(hashAlgorithmName);}
0
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info)
{    PasswordService service = ensurePasswordService();    Object submittedPassword = getSubmittedPassword(token);    Object storedCredentials = getStoredPassword(info);    assertStoredCredentialsType(storedCredentials);    if (storedCredentials instanceof Hash) {        Hash hashedPassword = (Hash) storedCredentials;        HashingPasswordService hashingService = assertHashingPasswordService(service);        return hashingService.passwordsMatch(submittedPassword, hashedPassword);    }        String formatted = (String) storedCredentials;    return passwordService.passwordsMatch(submittedPassword, formatted);}
0
private HashingPasswordService assertHashingPasswordService(PasswordService service)
{    if (service instanceof HashingPasswordService) {        return (HashingPasswordService) service;    }    String msg = "AuthenticationInfo's stored credentials are a Hash instance, but the " + "configured passwordService is not a " + HashingPasswordService.class.getName() + " instance.  This is required to perform Hash " + "object password comparisons.";    throw new IllegalStateException(msg);}
0
private PasswordService ensurePasswordService()
{    PasswordService service = getPasswordService();    if (service == null) {        String msg = "Required PasswordService has not been configured.";        throw new IllegalStateException(msg);    }    return service;}
0
protected Object getSubmittedPassword(AuthenticationToken token)
{    return token != null ? token.getCredentials() : null;}
0
private void assertStoredCredentialsType(Object credentials)
{    if (credentials instanceof String || credentials instanceof Hash) {        return;    }    String msg = "Stored account credentials are expected to be either a " + Hash.class.getName() + " instance or a formatted hash String.";    throw new IllegalArgumentException(msg);}
0
protected Object getStoredPassword(AuthenticationInfo storedAccountInfo)
{    Object stored = storedAccountInfo != null ? storedAccountInfo.getCredentials() : null;        if (stored instanceof char[]) {        stored = new String((char[]) stored);    }    return stored;}
0
public PasswordService getPasswordService()
{    return passwordService;}
0
public void setPasswordService(PasswordService passwordService)
{    this.passwordService = passwordService;}
0
protected Object getCredentials(AuthenticationToken token)
{    return token.getCredentials();}
0
protected Object getCredentials(AuthenticationInfo info)
{    return info.getCredentials();}
0
protected boolean equals(Object tokenCredentials, Object accountCredentials)
{    if (log.isDebugEnabled()) {            }    if (isByteSource(tokenCredentials) && isByteSource(accountCredentials)) {        if (log.isDebugEnabled()) {                    }        byte[] tokenBytes = toBytes(tokenCredentials);        byte[] accountBytes = toBytes(accountCredentials);        return MessageDigest.isEqual(tokenBytes, accountBytes);    } else {        return accountCredentials.equals(tokenCredentials);    }}
1
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info)
{    Object tokenCredentials = getCredentials(token);    Object accountCredentials = getCredentials(info);    return equals(tokenCredentials, accountCredentials);}
0
public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException
{    return new SimpleAuthenticationInfo();}
0
public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException
{    return aggregate;}
0
public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException
{    AuthenticationInfo info;    if (singleRealmInfo == null) {        info = aggregateInfo;    } else {        if (aggregateInfo == null) {            info = singleRealmInfo;        } else {            info = merge(singleRealmInfo, aggregateInfo);        }    }    return info;}
0
protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate)
{    if (aggregate instanceof MergableAuthenticationInfo) {        ((MergableAuthenticationInfo) aggregate).merge(info);        return aggregate;    } else {        throw new IllegalArgumentException("Attempt to merge authentication info from multiple realms, but aggregate " + "AuthenticationInfo is not of type MergableAuthenticationInfo.");    }}
0
public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException
{    return aggregate;}
0
public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException
{    if (!realm.supports(token)) {        String msg = "Realm [" + realm + "] of type [" + realm.getClass().getName() + "] does not support " + " the submitted AuthenticationToken [" + token + "].  The [" + getClass().getName() + "] implementation requires all configured realm(s) to support and be able to process the submitted " + "AuthenticationToken.";        throw new UnsupportedTokenException(msg);    }    return info;}
0
public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo info, AuthenticationInfo aggregate, Throwable t) throws AuthenticationException
{    if (t != null) {        if (t instanceof AuthenticationException) {                        throw ((AuthenticationException) t);        } else {            String msg = "Unable to acquire account data from realm [" + realm + "].  The [" + getClass().getName() + " implementation requires all configured realm(s) to operate successfully " + "for a successful authentication.";            throw new AuthenticationException(msg, t);        }    }    if (info == null) {        String msg = "Realm [" + realm + "] could not find any associated account data for the submitted " + "AuthenticationToken [" + token + "].  The [" + getClass().getName() + "] implementation requires " + "all configured realm(s) to acquire valid account data for a submitted token during the " + "log-in process.";        throw new UnknownAccountException(msg);    }                merge(info, aggregate);    return aggregate;}
1
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException
{        if (aggregate == null || isEmpty(aggregate.getPrincipals())) {        throw new AuthenticationException("Authentication token of type [" + token.getClass() + "] " + "could not be authenticated by any configured realms.  Please ensure that at least one realm can " + "authenticate these tokens.");    }    return aggregate;}
0
public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException
{    return null;}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate)
{    if (aggregate != null && !isEmpty(aggregate.getPrincipals())) {        return aggregate;    }    return info != null ? info : aggregate;}
0
public void setRealms(Collection<Realm> realms)
{    this.realms = realms;}
0
protected Collection<Realm> getRealms()
{    return this.realms;}
0
public AuthenticationStrategy getAuthenticationStrategy()
{    return authenticationStrategy;}
0
public void setAuthenticationStrategy(AuthenticationStrategy authenticationStrategy)
{    this.authenticationStrategy = authenticationStrategy;}
0
protected void assertRealmsConfigured() throws IllegalStateException
{    Collection<Realm> realms = getRealms();    if (CollectionUtils.isEmpty(realms)) {        String msg = "Configuration error:  No realms have been configured!  One or more realms must be " + "present to execute an authentication attempt.";        throw new IllegalStateException(msg);    }}
0
protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token)
{    if (!realm.supports(token)) {        String msg = "Realm [" + realm + "] does not support authentication token [" + token + "].  Please ensure that the appropriate Realm implementation is " + "configured correctly or that the realm accepts AuthenticationTokens of this type.";        throw new UnsupportedTokenException(msg);    }    AuthenticationInfo info = realm.getAuthenticationInfo(token);    if (info == null) {        String msg = "Realm [" + realm + "] was unable to find account data for the " + "submitted AuthenticationToken [" + token + "].";        throw new UnknownAccountException(msg);    }    return info;}
0
protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms, AuthenticationToken token)
{    AuthenticationStrategy strategy = getAuthenticationStrategy();    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);    if (log.isTraceEnabled()) {        log.trace("Iterating through {} realms for PAM authentication", realms.size());    }    for (Realm realm : realms) {        aggregate = strategy.beforeAttempt(realm, token, aggregate);        if (realm.supports(token)) {            log.trace("Attempting to authenticate token [{}] using realm [{}]", token, realm);            AuthenticationInfo info = null;            Throwable t = null;            try {                info = realm.getAuthenticationInfo(token);            } catch (Throwable throwable) {                t = throwable;                if (log.isDebugEnabled()) {                    String msg = "Realm [" + realm + "] threw an exception during a multi-realm authentication attempt:";                                    }            }            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);        } else {                    }    }    aggregate = strategy.afterAllAttempts(token, aggregate);    return aggregate;}
1
protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException
{    assertRealmsConfigured();    Collection<Realm> realms = getRealms();    if (realms.size() == 1) {        return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);    } else {        return doMultiRealmAuthentication(realms, authenticationToken);    }}
0
public void onLogout(PrincipalCollection principals)
{    super.onLogout(principals);    Collection<Realm> realms = getRealms();    if (!CollectionUtils.isEmpty(realms)) {        for (Realm realm : realms) {            if (realm instanceof LogoutAware) {                ((LogoutAware) realm).onLogout(principals);            }        }    }}
0
public PrincipalCollection getPrincipals()
{    return authcInfo.getPrincipals();}
0
public void setPrincipals(PrincipalCollection principals)
{    this.authcInfo.setPrincipals(principals);}
0
public Object getCredentials()
{    return authcInfo.getCredentials();}
0
public void setCredentials(Object credentials)
{    this.authcInfo.setCredentials(credentials);}
0
public ByteSource getCredentialsSalt()
{    return this.authcInfo.getCredentialsSalt();}
0
public void setCredentialsSalt(ByteSource salt)
{    this.authcInfo.setCredentialsSalt(salt);}
0
public Collection<String> getRoles()
{    return authzInfo.getRoles();}
0
public void setRoles(Set<String> roles)
{    this.authzInfo.setRoles(roles);}
0
public void addRole(String role)
{    this.authzInfo.addRole(role);}
0
public void addRole(Collection<String> roles)
{    this.authzInfo.addRoles(roles);}
0
public Collection<String> getStringPermissions()
{    return authzInfo.getStringPermissions();}
0
public void setStringPermissions(Set<String> permissions)
{    this.authzInfo.setStringPermissions(permissions);}
0
public void addStringPermission(String permission)
{    this.authzInfo.addStringPermission(permission);}
0
public void addStringPermissions(Collection<String> permissions)
{    this.authzInfo.addStringPermissions(permissions);}
0
public Collection<Permission> getObjectPermissions()
{    return authzInfo.getObjectPermissions();}
0
public void setObjectPermissions(Set<Permission> permissions)
{    this.authzInfo.setObjectPermissions(permissions);}
0
public void addObjectPermission(Permission permission)
{    this.authzInfo.addObjectPermission(permission);}
0
public void addObjectPermissions(Collection<Permission> permissions)
{    this.authzInfo.addObjectPermissions(permissions);}
0
public boolean isLocked()
{    return locked;}
0
public void setLocked(boolean locked)
{    this.locked = locked;}
0
public boolean isCredentialsExpired()
{    return credentialsExpired;}
0
public void setCredentialsExpired(boolean credentialsExpired)
{    this.credentialsExpired = credentialsExpired;}
0
public void merge(AuthenticationInfo info)
{    authcInfo.merge(info);        if (info instanceof SimpleAccount) {        SimpleAccount otherAccount = (SimpleAccount) info;        if (otherAccount.isLocked()) {            setLocked(true);        }        if (otherAccount.isCredentialsExpired()) {            setCredentialsExpired(true);        }    }}
0
public int hashCode()
{    return (getPrincipals() != null ? getPrincipals().hashCode() : 0);}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (o instanceof SimpleAccount) {        SimpleAccount sa = (SimpleAccount) o;                return (getPrincipals() != null ? getPrincipals().equals(sa.getPrincipals()) : sa.getPrincipals() == null);    }    return false;}
0
public String toString()
{    return getPrincipals() != null ? getPrincipals().toString() : "empty";}
0
public PrincipalCollection getPrincipals()
{    return principals;}
0
public void setPrincipals(PrincipalCollection principals)
{    this.principals = principals;}
0
public Object getCredentials()
{    return credentials;}
0
public void setCredentials(Object credentials)
{    this.credentials = credentials;}
0
public ByteSource getCredentialsSalt()
{    return credentialsSalt;}
0
public void setCredentialsSalt(ByteSource salt)
{    this.credentialsSalt = salt;}
0
public void merge(AuthenticationInfo info)
{    if (info == null || info.getPrincipals() == null || info.getPrincipals().isEmpty()) {        return;    }    if (this.principals == null) {        this.principals = info.getPrincipals();    } else {        if (!(this.principals instanceof MutablePrincipalCollection)) {            this.principals = new SimplePrincipalCollection(this.principals);        }        ((MutablePrincipalCollection) this.principals).addAll(info.getPrincipals());    }        if (this.credentialsSalt == null && info instanceof SaltedAuthenticationInfo) {        this.credentialsSalt = ((SaltedAuthenticationInfo) info).getCredentialsSalt();    }    Object thisCredentials = getCredentials();    Object otherCredentials = info.getCredentials();    if (otherCredentials == null) {        return;    }    if (thisCredentials == null) {        this.credentials = otherCredentials;        return;    }    if (!(thisCredentials instanceof Collection)) {        Set newSet = new HashSet();        newSet.add(thisCredentials);        setCredentials(newSet);    }        Collection credentialCollection = (Collection) getCredentials();    if (otherCredentials instanceof Collection) {        credentialCollection.addAll((Collection) otherCredentials);    } else {        credentialCollection.add(otherCredentials);    }}
0
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof SimpleAuthenticationInfo))        return false;    SimpleAuthenticationInfo that = (SimpleAuthenticationInfo) o;        if (principals != null ? !principals.equals(that.principals) : that.principals != null)        return false;    return true;}
0
public int hashCode()
{    return (principals != null ? principals.hashCode() : 0);}
0
public String toString()
{    return principals.toString();}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public char[] getPassword()
{    return password;}
0
public void setPassword(char[] password)
{    this.password = password;}
0
public Object getPrincipal()
{    return getUsername();}
0
public Object getCredentials()
{    return getPassword();}
0
public String getHost()
{    return host;}
0
public void setHost(String host)
{    this.host = host;}
0
public boolean isRememberMe()
{    return rememberMe;}
0
public void setRememberMe(boolean rememberMe)
{    this.rememberMe = rememberMe;}
0
public void clear()
{    this.username = null;    this.host = null;    this.rememberMe = false;    if (this.password != null) {        for (int i = 0; i < password.length; i++) {            this.password[i] = 0x00;        }        this.password = null;    }}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(getClass().getName());    sb.append(" - ");    sb.append(username);    sb.append(", rememberMe=").append(rememberMe);    if (host != null) {        sb.append(" (").append(host).append(")");    }    return sb.toString();}
0
public Collection<AuthorizingAnnotationMethodInterceptor> getMethodInterceptors()
{    return methodInterceptors;}
0
public void setMethodInterceptors(Collection<AuthorizingAnnotationMethodInterceptor> methodInterceptors)
{    this.methodInterceptors = methodInterceptors;}
0
protected void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException
{        Collection<AuthorizingAnnotationMethodInterceptor> aamis = getMethodInterceptors();    if (aamis != null && !aamis.isEmpty()) {        for (AuthorizingAnnotationMethodInterceptor aami : aamis) {            if (aami.supports(methodInvocation)) {                aami.assertAuthorized(methodInvocation);            }        }    }}
0
public void assertAuthorized(Annotation a) throws UnauthenticatedException
{    if (a instanceof RequiresAuthentication && !getSubject().isAuthenticated()) {        throw new UnauthenticatedException("The current Subject is not authenticated.  Access denied.");    }}
0
public Object invoke(MethodInvocation methodInvocation) throws Throwable
{    assertAuthorized(methodInvocation);    return methodInvocation.proceed();}
0
public void assertAuthorized(MethodInvocation mi) throws AuthorizationException
{    try {        ((AuthorizingAnnotationHandler) getHandler()).assertAuthorized(getAnnotation(mi));    } catch (AuthorizationException ae) {                if (ae.getCause() == null)            ae.initCause(new AuthorizationException("Not authorized to invoke method: " + mi.getMethod()));        throw ae;    }}
0
public Object invoke(MethodInvocation methodInvocation) throws Throwable
{    assertAuthorized(methodInvocation);    return methodInvocation.proceed();}
0
public void assertAuthorized(Annotation a) throws AuthorizationException
{    if (a instanceof RequiresGuest && getSubject().getPrincipal() != null) {        throw new UnauthenticatedException("Attempting to perform a guest-only operation.  The current Subject is " + "not a guest (they have been authenticated or remembered from a previous login).  Access " + "denied.");    }}
0
protected String[] getAnnotationValue(Annotation a)
{    RequiresPermissions rpAnnotation = (RequiresPermissions) a;    return rpAnnotation.value();}
0
public void assertAuthorized(Annotation a) throws AuthorizationException
{    if (!(a instanceof RequiresPermissions))        return;    RequiresPermissions rpAnnotation = (RequiresPermissions) a;    String[] perms = getAnnotationValue(a);    Subject subject = getSubject();    if (perms.length == 1) {        subject.checkPermission(perms[0]);        return;    }    if (Logical.AND.equals(rpAnnotation.logical())) {        getSubject().checkPermissions(perms);        return;    }    if (Logical.OR.equals(rpAnnotation.logical())) {                boolean hasAtLeastOnePermission = false;        for (String permission : perms) if (getSubject().isPermitted(permission))            hasAtLeastOnePermission = true;                if (!hasAtLeastOnePermission)            getSubject().checkPermission(perms[0]);    }}
0
public void assertAuthorized(Annotation a) throws AuthorizationException
{    if (!(a instanceof RequiresRoles))        return;    RequiresRoles rrAnnotation = (RequiresRoles) a;    String[] roles = rrAnnotation.value();    if (roles.length == 1) {        getSubject().checkRole(roles[0]);        return;    }    if (Logical.AND.equals(rrAnnotation.logical())) {        getSubject().checkRoles(Arrays.asList(roles));        return;    }    if (Logical.OR.equals(rrAnnotation.logical())) {                boolean hasAtLeastOneRole = false;        for (String role : roles) if (getSubject().hasRole(role))            hasAtLeastOneRole = true;                if (!hasAtLeastOneRole)            getSubject().checkRole(roles[0]);    }}
0
public void assertAuthorized(Annotation a) throws AuthorizationException
{    if (a instanceof RequiresUser && getSubject().getPrincipal() == null) {        throw new UnauthenticatedException("Attempting to perform a user-only operation.  The current Subject is " + "not a user (they haven't been authenticated or remembered from a previous login).  " + "Access denied.");    }}
0
public String getHost()
{    return this.host;}
0
public void setHostAddress(String host)
{    this.host = host;}
0
public Collection<Realm> getRealms()
{    return this.realms;}
0
public void setRealms(Collection<Realm> realms)
{    this.realms = realms;    applyPermissionResolverToRealms();    applyRolePermissionResolverToRealms();}
0
public PermissionResolver getPermissionResolver()
{    return this.permissionResolver;}
0
public void setPermissionResolver(PermissionResolver permissionResolver)
{    this.permissionResolver = permissionResolver;    applyPermissionResolverToRealms();}
0
protected void applyPermissionResolverToRealms()
{    PermissionResolver resolver = getPermissionResolver();    Collection<Realm> realms = getRealms();    if (resolver != null && realms != null && !realms.isEmpty()) {        for (Realm realm : realms) {            if (realm instanceof PermissionResolverAware) {                ((PermissionResolverAware) realm).setPermissionResolver(resolver);            }        }    }}
0
public RolePermissionResolver getRolePermissionResolver()
{    return this.rolePermissionResolver;}
0
public void setRolePermissionResolver(RolePermissionResolver rolePermissionResolver)
{    this.rolePermissionResolver = rolePermissionResolver;    applyRolePermissionResolverToRealms();}
0
protected void applyRolePermissionResolverToRealms()
{    RolePermissionResolver resolver = getRolePermissionResolver();    Collection<Realm> realms = getRealms();    if (resolver != null && realms != null && !realms.isEmpty()) {        for (Realm realm : realms) {            if (realm instanceof RolePermissionResolverAware) {                ((RolePermissionResolverAware) realm).setRolePermissionResolver(resolver);            }        }    }}
0
protected void assertRealmsConfigured() throws IllegalStateException
{    Collection<Realm> realms = getRealms();    if (realms == null || realms.isEmpty()) {        String msg = "Configuration error:  No realms have been configured!  One or more realms must be " + "present to execute an authorization operation.";        throw new IllegalStateException(msg);    }}
0
public boolean isPermitted(PrincipalCollection principals, String permission)
{    assertRealmsConfigured();    for (Realm realm : getRealms()) {        if (!(realm instanceof Authorizer))            continue;        if (((Authorizer) realm).isPermitted(principals, permission)) {            return true;        }    }    return false;}
0
public boolean isPermitted(PrincipalCollection principals, Permission permission)
{    assertRealmsConfigured();    for (Realm realm : getRealms()) {        if (!(realm instanceof Authorizer))            continue;        if (((Authorizer) realm).isPermitted(principals, permission)) {            return true;        }    }    return false;}
0
public boolean[] isPermitted(PrincipalCollection principals, String... permissions)
{    assertRealmsConfigured();    if (permissions != null && permissions.length > 0) {        boolean[] isPermitted = new boolean[permissions.length];        for (int i = 0; i < permissions.length; i++) {            isPermitted[i] = isPermitted(principals, permissions[i]);        }        return isPermitted;    }    return new boolean[0];}
0
public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions)
{    assertRealmsConfigured();    if (permissions != null && !permissions.isEmpty()) {        boolean[] isPermitted = new boolean[permissions.size()];        int i = 0;        for (Permission p : permissions) {            isPermitted[i++] = isPermitted(principals, p);        }        return isPermitted;    }    return new boolean[0];}
0
public boolean isPermittedAll(PrincipalCollection principals, String... permissions)
{    assertRealmsConfigured();    if (permissions != null && permissions.length > 0) {        for (String perm : permissions) {            if (!isPermitted(principals, perm)) {                return false;            }        }    }    return true;}
0
public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions)
{    assertRealmsConfigured();    if (permissions != null && !permissions.isEmpty()) {        for (Permission permission : permissions) {            if (!isPermitted(principals, permission)) {                return false;            }        }    }    return true;}
0
public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException
{    assertRealmsConfigured();    if (!isPermitted(principals, permission)) {        throw new UnauthorizedException("Subject does not have permission [" + permission + "]");    }}
0
public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException
{    assertRealmsConfigured();    if (!isPermitted(principals, permission)) {        throw new UnauthorizedException("Subject does not have permission [" + permission + "]");    }}
0
public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException
{    assertRealmsConfigured();    if (permissions != null && permissions.length > 0) {        for (String perm : permissions) {            checkPermission(principals, perm);        }    }}
0
public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException
{    assertRealmsConfigured();    if (permissions != null) {        for (Permission permission : permissions) {            checkPermission(principals, permission);        }    }}
0
public boolean hasRole(PrincipalCollection principals, String roleIdentifier)
{    assertRealmsConfigured();    for (Realm realm : getRealms()) {        if (!(realm instanceof Authorizer))            continue;        if (((Authorizer) realm).hasRole(principals, roleIdentifier)) {            return true;        }    }    return false;}
0
public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers)
{    assertRealmsConfigured();    if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {        boolean[] hasRoles = new boolean[roleIdentifiers.size()];        int i = 0;        for (String roleId : roleIdentifiers) {            hasRoles[i++] = hasRole(principals, roleId);        }        return hasRoles;    }    return new boolean[0];}
0
public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers)
{    assertRealmsConfigured();    for (String roleIdentifier : roleIdentifiers) {        if (!hasRole(principals, roleIdentifier)) {            return false;        }    }    return true;}
0
public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException
{    assertRealmsConfigured();    if (!hasRole(principals, role)) {        throw new UnauthorizedException("Subject does not have role [" + role + "]");    }}
0
public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException
{        if (roles != null && !roles.isEmpty())        checkRoles(principals, roles.toArray(new String[roles.size()]));}
0
public void checkRoles(PrincipalCollection principals, String... roles) throws AuthorizationException
{    assertRealmsConfigured();    if (roles != null) {        for (String role : roles) {            checkRole(principals, role);        }    }}
0
public boolean implies(Permission p)
{    return true;}
0
private void encodeParts(String domain, String actions, String targets)
{    if (!StringUtils.hasText(domain)) {        throw new IllegalArgumentException("domain argument cannot be null or empty.");    }    StringBuilder sb = new StringBuilder(domain);    if (!StringUtils.hasText(actions)) {        if (StringUtils.hasText(targets)) {            sb.append(PART_DIVIDER_TOKEN).append(WILDCARD_TOKEN);        }    } else {        sb.append(PART_DIVIDER_TOKEN).append(actions);    }    if (StringUtils.hasText(targets)) {        sb.append(PART_DIVIDER_TOKEN).append(targets);    }    setParts(sb.toString());}
0
protected void setParts(String domain, Set<String> actions, Set<String> targets)
{    String actionsString = StringUtils.toDelimitedString(actions, SUBPART_DIVIDER_TOKEN);    String targetsString = StringUtils.toDelimitedString(targets, SUBPART_DIVIDER_TOKEN);    encodeParts(domain, actionsString, targetsString);    this.domain = domain;    this.actions = actions;    this.targets = targets;}
0
protected String getDomain(Class<? extends DomainPermission> clazz)
{    String domain = clazz.getSimpleName().toLowerCase();        int index = domain.lastIndexOf("permission");    if (index != -1) {        domain = domain.substring(0, index);    }    return domain;}
0
public String getDomain()
{    return domain;}
0
protected void setDomain(String domain)
{    if (this.domain != null && this.domain.equals(domain)) {        return;    }    this.domain = domain;    setParts(domain, actions, targets);}
0
public Set<String> getActions()
{    return actions;}
0
protected void setActions(Set<String> actions)
{    if (this.actions != null && this.actions.equals(actions)) {        return;    }    this.actions = actions;    setParts(domain, actions, targets);}
0
public Set<String> getTargets()
{    return targets;}
0
protected void setTargets(Set<String> targets)
{    if (this.targets != null && this.targets.equals(targets)) {        return;    }    this.targets = targets;    setParts(domain, actions, targets);}
0
public String getPermissionString()
{    return this.permissionString;}
0
protected void setParts(String wildcardString)
{    setParts(wildcardString, DEFAULT_CASE_SENSITIVE);}
0
protected void setParts(String wildcardString, boolean caseSensitive)
{    wildcardString = StringUtils.clean(wildcardString);    if (wildcardString == null || wildcardString.isEmpty()) {        throw new IllegalArgumentException("Wildcard string cannot be null or empty. Make sure permission strings are properly formatted.");    }    if (!caseSensitive) {        wildcardString = wildcardString.toLowerCase();    }    List<String> parts = CollectionUtils.asList(wildcardString.split(PART_DIVIDER_TOKEN));    this.parts = new ArrayList<Set<String>>();    for (String part : parts) {        Set<String> subparts = CollectionUtils.asSet(part.split(SUBPART_DIVIDER_TOKEN));        if (subparts.isEmpty()) {            throw new IllegalArgumentException("Wildcard string cannot contain parts with only dividers. Make sure permission strings are properly formatted.");        }        this.parts.add(subparts);    }    if (this.parts.isEmpty()) {        throw new IllegalArgumentException("Wildcard string cannot contain only dividers. Make sure permission strings are properly formatted.");    }}
0
protected List<Set<String>> getParts()
{    return this.parts;}
0
protected void setParts(List<Set<String>> parts)
{    this.parts = parts;}
0
public boolean implies(Permission p)
{        if (!(p instanceof WildcardPermission)) {        return false;    }    WildcardPermission wp = (WildcardPermission) p;    List<Set<String>> otherParts = wp.getParts();    int i = 0;    for (Set<String> otherPart : otherParts) {                if (getParts().size() - 1 < i) {            return true;        } else {            Set<String> part = getParts().get(i);            if (!part.contains(WILDCARD_TOKEN) && !part.containsAll(otherPart)) {                return false;            }            i++;        }    }        for (; i < getParts().size(); i++) {        Set<String> part = getParts().get(i);        if (!part.contains(WILDCARD_TOKEN)) {            return false;        }    }    return true;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder();    for (Set<String> part : parts) {        if (buffer.length() > 0) {            buffer.append(PART_DIVIDER_TOKEN);        }        Iterator<String> partIt = part.iterator();        while (partIt.hasNext()) {            buffer.append(partIt.next());            if (partIt.hasNext()) {                buffer.append(SUBPART_DIVIDER_TOKEN);            }        }    }    return buffer.toString();}
0
public boolean equals(Object o)
{    if (o instanceof WildcardPermission) {        WildcardPermission wp = (WildcardPermission) o;        return parts.equals(wp.parts);    }    return false;}
0
public int hashCode()
{    return parts.hashCode();}
0
public void setCaseSensitive(boolean state)
{    this.caseSensitive = state;}
0
public boolean isCaseSensitive()
{    return caseSensitive;}
0
public Permission resolvePermission(String permissionString)
{    return new WildcardPermission(permissionString, caseSensitive);}
0
public Set<String> getRoles()
{    return roles;}
0
public void setRoles(Set<String> roles)
{    this.roles = roles;}
0
public void addRole(String role)
{    if (this.roles == null) {        this.roles = new HashSet<String>();    }    this.roles.add(role);}
0
public void addRoles(Collection<String> roles)
{    if (this.roles == null) {        this.roles = new HashSet<String>();    }    this.roles.addAll(roles);}
0
public Set<String> getStringPermissions()
{    return stringPermissions;}
0
public void setStringPermissions(Set<String> stringPermissions)
{    this.stringPermissions = stringPermissions;}
0
public void addStringPermission(String permission)
{    if (this.stringPermissions == null) {        this.stringPermissions = new HashSet<String>();    }    this.stringPermissions.add(permission);}
0
public void addStringPermissions(Collection<String> permissions)
{    if (this.stringPermissions == null) {        this.stringPermissions = new HashSet<String>();    }    this.stringPermissions.addAll(permissions);}
0
public Set<Permission> getObjectPermissions()
{    return objectPermissions;}
0
public void setObjectPermissions(Set<Permission> objectPermissions)
{    this.objectPermissions = objectPermissions;}
0
public void addObjectPermission(Permission permission)
{    if (this.objectPermissions == null) {        this.objectPermissions = new HashSet<Permission>();    }    this.objectPermissions.add(permission);}
0
public void addObjectPermissions(Collection<Permission> permissions)
{    if (this.objectPermissions == null) {        this.objectPermissions = new HashSet<Permission>();    }    this.objectPermissions.addAll(permissions);}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public Set<Permission> getPermissions()
{    return permissions;}
0
public void setPermissions(Set<Permission> permissions)
{    this.permissions = permissions;}
0
public void add(Permission permission)
{    Set<Permission> permissions = getPermissions();    if (permissions == null) {        permissions = new LinkedHashSet<Permission>();        setPermissions(permissions);    }    permissions.add(permission);}
0
public void addAll(Collection<Permission> perms)
{    if (perms != null && !perms.isEmpty()) {        Set<Permission> permissions = getPermissions();        if (permissions == null) {            permissions = new LinkedHashSet<Permission>(perms.size());            setPermissions(permissions);        }        permissions.addAll(perms);    }}
0
public boolean isPermitted(Permission p)
{    Collection<Permission> perms = getPermissions();    if (perms != null && !perms.isEmpty()) {        for (Permission perm : perms) {            if (perm.implies(p)) {                return true;            }        }    }    return false;}
0
public int hashCode()
{    return (getName() != null ? getName().hashCode() : 0);}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (o instanceof SimpleRole) {        SimpleRole sr = (SimpleRole) o;                return (getName() != null ? getName().equals(sr.getName()) : sr.getName() == null);    }    return false;}
0
public String toString()
{    return getName();}
0
public Executor getTargetExecutor()
{    return targetExecutor;}
0
public void setTargetExecutor(Executor targetExecutor)
{    this.targetExecutor = targetExecutor;}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
protected Runnable associateWithSubject(Runnable r)
{    Subject subject = getSubject();    return subject.associateWith(r);}
0
public void execute(Runnable command)
{    Runnable associated = associateWithSubject(command);    getTargetExecutor().execute(associated);}
0
public ExecutorService getTargetExecutorService()
{    return targetExecutorService;}
0
public void setTargetExecutorService(ExecutorService targetExecutorService)
{    super.setTargetExecutor(targetExecutorService);    this.targetExecutorService = targetExecutorService;}
0
public void setTargetExecutor(Executor targetExecutor)
{    if (!(targetExecutor instanceof ExecutorService)) {        String msg = "The " + getClass().getName() + " implementation only accepts " + ExecutorService.class.getName() + " target instances.";        throw new IllegalArgumentException(msg);    }    super.setTargetExecutor(targetExecutor);}
0
public void shutdown()
{    this.targetExecutorService.shutdown();}
0
public List<Runnable> shutdownNow()
{    return this.targetExecutorService.shutdownNow();}
0
public boolean isShutdown()
{    return this.targetExecutorService.isShutdown();}
0
public boolean isTerminated()
{    return this.targetExecutorService.isTerminated();}
0
public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
{    return this.targetExecutorService.awaitTermination(timeout, unit);}
0
protected Callable<T> associateWithSubject(Callable<T> task)
{    Subject subject = getSubject();    return subject.associateWith(task);}
0
public Future<T> submit(Callable<T> task)
{    Callable<T> work = associateWithSubject(task);    return this.targetExecutorService.submit(work);}
0
public Future<T> submit(Runnable task, T result)
{    Runnable work = associateWithSubject(task);    return this.targetExecutorService.submit(work, result);}
0
public Future<?> submit(Runnable task)
{    Runnable work = associateWithSubject(task);    return this.targetExecutorService.submit(work);}
0
protected Collection<Callable<T>> associateWithSubject(Collection<? extends Callable<T>> tasks)
{    Collection<Callable<T>> workItems = new ArrayList<Callable<T>>(tasks.size());    for (Callable<T> task : tasks) {        Callable<T> work = associateWithSubject(task);        workItems.add(work);    }    return workItems;}
0
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
{    Collection<Callable<T>> workItems = associateWithSubject(tasks);    return this.targetExecutorService.invokeAll(workItems);}
0
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException
{    Collection<Callable<T>> workItems = associateWithSubject(tasks);    return this.targetExecutorService.invokeAll(workItems, timeout, unit);}
0
public T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
{    Collection<Callable<T>> workItems = associateWithSubject(tasks);    return this.targetExecutorService.invokeAny(workItems);}
0
public T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    Collection<Callable<T>> workItems = associateWithSubject(tasks);    return this.targetExecutorService.invokeAny(workItems, timeout, unit);}
0
public ScheduledExecutorService getTargetScheduledExecutorService()
{    return targetScheduledExecutorService;}
0
public void setTargetScheduledExecutorService(ScheduledExecutorService targetScheduledExecutorService)
{    super.setTargetExecutorService(targetScheduledExecutorService);    this.targetScheduledExecutorService = targetScheduledExecutorService;}
0
public void setTargetExecutor(Executor targetExecutor)
{    if (!(targetExecutor instanceof ScheduledExecutorService)) {        String msg = "The " + getClass().getName() + " implementation only accepts " + ScheduledExecutorService.class.getName() + " target instances.";        throw new IllegalArgumentException(msg);    }    super.setTargetExecutorService((ScheduledExecutorService) targetExecutor);}
0
public void setTargetExecutorService(ExecutorService targetExecutorService)
{    if (!(targetExecutorService instanceof ScheduledExecutorService)) {        String msg = "The " + getClass().getName() + " implementation only accepts " + ScheduledExecutorService.class.getName() + " target instances.";        throw new IllegalArgumentException(msg);    }    super.setTargetExecutorService(targetExecutorService);}
0
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)
{    Runnable work = associateWithSubject(command);    return this.targetScheduledExecutorService.schedule(work, delay, unit);}
0
public ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)
{    Callable<V> work = associateWithSubject(callable);    return this.targetScheduledExecutorService.schedule(work, delay, unit);}
0
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
{    Runnable work = associateWithSubject(command);    return this.targetScheduledExecutorService.scheduleAtFixedRate(work, initialDelay, period, unit);}
0
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
{    Runnable work = associateWithSubject(command);    return this.targetScheduledExecutorService.scheduleWithFixedDelay(work, initialDelay, delay, unit);}
0
public Ini getIni()
{    return ini;}
0
public void setIni(Ini ini)
{    this.ini = ini;}
0
protected Map<String, ?> getDefaults()
{    return defaultBeans;}
0
public void setDefaults(Map<String, ?> defaultBeans)
{    this.defaultBeans = defaultBeans;}
0
public static Ini loadDefaultClassPathIni()
{    Ini ini = null;    if (ResourceUtils.resourceExists(DEFAULT_INI_RESOURCE_PATH)) {                ini = new Ini();        ini.loadFromPath(DEFAULT_INI_RESOURCE_PATH);        if (CollectionUtils.isEmpty(ini)) {                    }    }    return ini;}
1
protected Ini resolveIni()
{    Ini ini = getIni();    if (CollectionUtils.isEmpty(ini)) {                ini = loadDefaultClassPathIni();    }    return ini;}
1
public T createInstance()
{    Ini ini = resolveIni();    T instance;    if (CollectionUtils.isEmpty(ini)) {                instance = createDefaultInstance();        if (instance == null) {            String msg = getClass().getName() + " implementation did not return a default instance in " + "the event of a null/empty Ini configuration.  This is required to support the " + "Factory interface.  Please check your implementation.";            throw new IllegalStateException(msg);        }    } else {                instance = createInstance(ini);        if (instance == null) {            String msg = getClass().getName() + " implementation did not return a constructed instance from " + "the createInstance(Ini) method implementation.";            throw new IllegalStateException(msg);        }    }    return instance;}
1
public Map<String, ?> getBeans()
{    return this.builder != null ? Collections.unmodifiableMap(builder.getObjects()) : null;}
0
public void destroy()
{    if (getReflectionBuilder() != null) {        getReflectionBuilder().destroy();    }}
0
private SecurityManager getSecurityManagerBean()
{    return getReflectionBuilder().getBean(SECURITY_MANAGER_NAME, SecurityManager.class);}
0
protected SecurityManager createDefaultInstance()
{    return new DefaultSecurityManager();}
0
protected SecurityManager createInstance(Ini ini)
{    if (CollectionUtils.isEmpty(ini)) {        throw new NullPointerException("Ini argument cannot be null or empty.");    }    SecurityManager securityManager = createSecurityManager(ini);    if (securityManager == null) {        String msg = SecurityManager.class + " instance cannot be null.";        throw new ConfigurationException(msg);    }    return securityManager;}
0
private SecurityManager createSecurityManager(Ini ini)
{    return createSecurityManager(ini, getConfigSection(ini));}
0
private Ini.Section getConfigSection(Ini ini)
{    Ini.Section mainSection = ini.getSection(MAIN_SECTION_NAME);    if (CollectionUtils.isEmpty(mainSection)) {                mainSection = ini.getSection(Ini.DEFAULT_SECTION_NAME);    }    return mainSection;}
0
protected boolean isAutoApplyRealms(SecurityManager securityManager)
{    boolean autoApply = true;    if (securityManager instanceof RealmSecurityManager) {                RealmSecurityManager realmSecurityManager = (RealmSecurityManager) securityManager;        Collection<Realm> realms = realmSecurityManager.getRealms();        if (!CollectionUtils.isEmpty(realms)) {                        autoApply = false;        }    }    return autoApply;}
1
private SecurityManager createSecurityManager(Ini ini, Ini.Section mainSection)
{    getReflectionBuilder().setObjects(createDefaults(ini, mainSection));    Map<String, ?> objects = buildInstances(mainSection);    SecurityManager securityManager = getSecurityManagerBean();    boolean autoApplyRealms = isAutoApplyRealms(securityManager);    if (autoApplyRealms) {                        Collection<Realm> realms = getRealms(objects);                if (!CollectionUtils.isEmpty(realms)) {            applyRealmsToSecurityManager(realms, securityManager);        }    }    return securityManager;}
0
protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection)
{    Map<String, Object> defaults = new LinkedHashMap<String, Object>();    SecurityManager securityManager = createDefaultInstance();    defaults.put(SECURITY_MANAGER_NAME, securityManager);    if (shouldImplicitlyCreateRealm(ini)) {        Realm realm = createRealm(ini);        if (realm != null) {            defaults.put(INI_REALM_NAME, realm);        }    }        Map<String, ?> defaultBeans = getDefaults();    if (!CollectionUtils.isEmpty(defaultBeans)) {        defaults.putAll(defaultBeans);    }    return defaults;}
0
private Map<String, ?> buildInstances(Ini.Section section)
{    return getReflectionBuilder().buildObjects(section);}
0
private void addToRealms(Collection<Realm> realms, RealmFactory factory)
{    LifecycleUtils.init(factory);    Collection<Realm> factoryRealms = factory.getRealms();        if (!CollectionUtils.isEmpty(factoryRealms)) {        realms.addAll(factoryRealms);    }}
0
private Collection<Realm> getRealms(Map<String, ?> instances)
{            List<Realm> realms = new ArrayList<Realm>();        for (Map.Entry<String, ?> entry : instances.entrySet()) {        String name = entry.getKey();        Object value = entry.getValue();        if (value instanceof RealmFactory) {            addToRealms(realms, (RealmFactory) value);        } else if (value instanceof Realm) {            Realm realm = (Realm) value;                        String existingName = realm.getName();            if (existingName == null || existingName.startsWith(realm.getClass().getName())) {                if (realm instanceof Nameable) {                    ((Nameable) realm).setName(name);                                    } else {                                    }            }            realms.add(realm);        }    }    return realms;}
1
private void assertRealmSecurityManager(SecurityManager securityManager)
{    if (securityManager == null) {        throw new NullPointerException("securityManager instance cannot be null");    }    if (!(securityManager instanceof RealmSecurityManager)) {        String msg = "securityManager instance is not a " + RealmSecurityManager.class.getName() + " instance.  This is required to access or configure realms on the instance.";        throw new ConfigurationException(msg);    }}
0
protected void applyRealmsToSecurityManager(Collection<Realm> realms, SecurityManager securityManager)
{    assertRealmSecurityManager(securityManager);    ((RealmSecurityManager) securityManager).setRealms(realms);}
0
protected boolean shouldImplicitlyCreateRealm(Ini ini)
{    return !CollectionUtils.isEmpty(ini) && (!CollectionUtils.isEmpty(ini.getSection(IniRealm.ROLES_SECTION_NAME)) || !CollectionUtils.isEmpty(ini.getSection(IniRealm.USERS_SECTION_NAME)));}
0
protected Realm createRealm(Ini ini)
{        IniRealm realm = new IniRealm();    realm.setName(INI_REALM_NAME);        realm.setIni(ini);    return realm;}
0
public ReflectionBuilder getReflectionBuilder()
{    return builder;}
0
public void setReflectionBuilder(ReflectionBuilder builder)
{    this.builder = builder;}
0
public SecurityManager getSecurityManager() throws IllegalStateException
{    SecurityManager securityManager = lookupSecurityManager();    if (securityManager == null) {        throw new IllegalStateException("No SecurityManager found in Environment.  This is an invalid " + "environment state.");    }    return securityManager;}
0
public void setSecurityManager(SecurityManager securityManager)
{    if (securityManager == null) {        throw new IllegalArgumentException("Null SecurityManager instances are not allowed.");    }    String name = getSecurityManagerName();    setObject(name, securityManager);}
0
protected SecurityManager lookupSecurityManager()
{    String name = getSecurityManagerName();    return getObject(name, SecurityManager.class);}
0
public String getSecurityManagerName()
{    return securityManagerName;}
0
public void setSecurityManagerName(String securityManagerName)
{    this.securityManagerName = securityManagerName;}
0
public Map<String, Object> getObjects()
{    return this.objects;}
0
public T getObject(String name, Class<T> requiredType) throws RequiredTypeException
{    if (name == null) {        throw new NullPointerException("name parameter cannot be null.");    }    if (requiredType == null) {        throw new NullPointerException("requiredType parameter cannot be null.");    }    Object o = this.objects.get(name);    if (o == null) {        return null;    }    if (!requiredType.isInstance(o)) {        String msg = "Object named '" + name + "' is not of required type [" + requiredType.getName() + "].";        throw new RequiredTypeException(msg);    }    return (T) o;}
0
public void setObject(String name, Object instance)
{    if (name == null) {        throw new NullPointerException("name parameter cannot be null.");    }    if (instance == null) {        this.objects.remove(name);    } else {        this.objects.put(name, instance);    }}
0
public void destroy() throws Exception
{    LifecycleUtils.destroy(this.objects.values());}
0
public void setJndiTemplate(JndiTemplate jndiTemplate)
{    this.jndiTemplate = (jndiTemplate != null ? jndiTemplate : new JndiTemplate());}
0
public JndiTemplate getJndiTemplate()
{    return this.jndiTemplate;}
0
public void setJndiEnvironment(Properties jndiEnvironment)
{    this.jndiTemplate = new JndiTemplate(jndiEnvironment);}
0
public Properties getJndiEnvironment()
{    return this.jndiTemplate.getEnvironment();}
0
public void setResourceRef(boolean resourceRef)
{    this.resourceRef = resourceRef;}
0
public boolean isResourceRef()
{    return this.resourceRef;}
0
protected Object lookup(String jndiName) throws NamingException
{    return lookup(jndiName, null);}
0
protected Object lookup(String jndiName, Class requiredType) throws NamingException
{    if (jndiName == null) {        throw new IllegalArgumentException("jndiName argument must not be null");    }    String convertedName = convertJndiName(jndiName);    Object jndiObject;    try {        jndiObject = getJndiTemplate().lookup(convertedName, requiredType);    } catch (NamingException ex) {        if (!convertedName.equals(jndiName)) {                        if (log.isDebugEnabled()) {                            }            jndiObject = getJndiTemplate().lookup(jndiName, requiredType);        } else {            throw ex;        }    }        return jndiObject;}
1
protected String convertJndiName(String jndiName)
{        if (isResourceRef() && !jndiName.startsWith(CONTAINER_PREFIX) && jndiName.indexOf(':') == -1) {        jndiName = CONTAINER_PREFIX + jndiName;    }    return jndiName;}
0
public T getInstance()
{    try {        if (requiredType != null) {            return requiredType.cast(this.lookup(resourceName, requiredType));        } else {            return (T) this.lookup(resourceName);        }    } catch (NamingException e) {        final String typeName = requiredType != null ? requiredType.getName() : "object";        throw new IllegalStateException("Unable to look up " + typeName + " with jndi name '" + resourceName + "'.", e);    }}
0
public String getResourceName()
{    return resourceName;}
0
public void setResourceName(String resourceName)
{    this.resourceName = resourceName;}
0
public Class<? extends T> getRequiredType()
{    return requiredType;}
0
public void setRequiredType(Class<? extends T> requiredType)
{    this.requiredType = requiredType;}
0
public void setEnvironment(Properties environment)
{    this.environment = environment;}
0
public Properties getEnvironment()
{    return this.environment;}
0
public Object execute(JndiCallback contextCallback) throws NamingException
{    Context ctx = createInitialContext();    try {        return contextCallback.doInContext(ctx);    } finally {        try {            ctx.close();        } catch (NamingException ex) {                    }    }}
1
protected Context createInitialContext() throws NamingException
{    Properties env = getEnvironment();    Hashtable icEnv = null;    if (env != null) {        icEnv = new Hashtable(env.size());        for (Enumeration en = env.propertyNames(); en.hasMoreElements(); ) {            String key = (String) en.nextElement();            icEnv.put(key, env.getProperty(key));        }    }    return new InitialContext(icEnv);}
0
public Object lookup(final String name) throws NamingException
{        return execute(new JndiCallback() {        public Object doInContext(Context ctx) throws NamingException {            Object located = ctx.lookup(name);            if (located == null) {                throw new NameNotFoundException("JNDI object with [" + name + "] not found: JNDI implementation returned null");            }            return located;        }    });}
1
public Object doInContext(Context ctx) throws NamingException
{    Object located = ctx.lookup(name);    if (located == null) {        throw new NameNotFoundException("JNDI object with [" + name + "] not found: JNDI implementation returned null");    }    return located;}
0
public Object lookup(String name, Class requiredType) throws NamingException
{    Object jndiObject = lookup(name);    if (requiredType != null && !requiredType.isInstance(jndiObject)) {        String msg = "Jndi object acquired under name '" + name + "' is of type [" + jndiObject.getClass().getName() + "] and not assignable to the required type [" + requiredType.getName() + "].";        throw new NamingException(msg);    }    return jndiObject;}
0
public void bind(final String name, final Object object) throws NamingException
{        execute(new JndiCallback() {        public Object doInContext(Context ctx) throws NamingException {            ctx.bind(name, object);            return null;        }    });}
1
public Object doInContext(Context ctx) throws NamingException
{    ctx.bind(name, object);    return null;}
0
public void rebind(final String name, final Object object) throws NamingException
{        execute(new JndiCallback() {        public Object doInContext(Context ctx) throws NamingException {            ctx.rebind(name, object);            return null;        }    });}
1
public Object doInContext(Context ctx) throws NamingException
{    ctx.rebind(name, object);    return null;}
0
public void unbind(final String name) throws NamingException
{        execute(new JndiCallback() {        public Object doInContext(Context ctx) throws NamingException {            ctx.unbind(name);            return null;        }    });}
1
public Object doInContext(Context ctx) throws NamingException
{    ctx.unbind(name);    return null;}
0
public Serializer<PrincipalCollection> getSerializer()
{    return serializer;}
0
public void setSerializer(Serializer<PrincipalCollection> serializer)
{    this.serializer = serializer;}
0
public CipherService getCipherService()
{    return cipherService;}
0
public void setCipherService(CipherService cipherService)
{    this.cipherService = cipherService;}
0
public byte[] getEncryptionCipherKey()
{    return encryptionCipherKey;}
0
public void setEncryptionCipherKey(byte[] encryptionCipherKey)
{    this.encryptionCipherKey = encryptionCipherKey;}
0
public byte[] getDecryptionCipherKey()
{    return decryptionCipherKey;}
0
public void setDecryptionCipherKey(byte[] decryptionCipherKey)
{    this.decryptionCipherKey = decryptionCipherKey;}
0
public byte[] getCipherKey()
{        return getEncryptionCipherKey();}
0
public void setCipherKey(byte[] cipherKey)
{            setEncryptionCipherKey(cipherKey);    setDecryptionCipherKey(cipherKey);}
0
protected boolean isRememberMe(AuthenticationToken token)
{    return token != null && (token instanceof RememberMeAuthenticationToken) && ((RememberMeAuthenticationToken) token).isRememberMe();}
0
public void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info)
{        forgetIdentity(subject);        if (isRememberMe(token)) {        rememberIdentity(subject, token, info);    } else {        if (log.isDebugEnabled()) {                    }    }}
1
public void rememberIdentity(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo)
{    PrincipalCollection principals = getIdentityToRemember(subject, authcInfo);    rememberIdentity(subject, principals);}
0
protected PrincipalCollection getIdentityToRemember(Subject subject, AuthenticationInfo info)
{    return info.getPrincipals();}
0
protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals)
{    byte[] bytes = convertPrincipalsToBytes(accountPrincipals);    rememberSerializedIdentity(subject, bytes);}
0
protected byte[] convertPrincipalsToBytes(PrincipalCollection principals)
{    byte[] bytes = serialize(principals);    if (getCipherService() != null) {        bytes = encrypt(bytes);    }    return bytes;}
0
public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext)
{    PrincipalCollection principals = null;    try {        byte[] bytes = getRememberedSerializedIdentity(subjectContext);                if (bytes != null && bytes.length > 0) {            principals = convertBytesToPrincipals(bytes, subjectContext);        }    } catch (RuntimeException re) {        principals = onRememberedPrincipalFailure(re, subjectContext);    }    return principals;}
0
protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext)
{    if (getCipherService() != null) {        bytes = decrypt(bytes);    }    return deserialize(bytes);}
0
protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, SubjectContext context)
{    if (log.isWarnEnabled()) {        String message = "There was a failure while trying to retrieve remembered principals.  This could be due to a " + "configuration problem or corrupted principals.  This could also be due to a recently " + "changed encryption key, if you are using a shiro.ini file, this property would be " + "'securityManager.rememberMeManager.cipherKey' see: http://shiro.apache.org/web.html#Web-RememberMeServices. " + "The remembered identity will be forgotten and not used for this request.";            }    forgetIdentity(context);        throw e;}
1
protected byte[] encrypt(byte[] serialized)
{    byte[] value = serialized;    CipherService cipherService = getCipherService();    if (cipherService != null) {        ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());        value = byteSource.getBytes();    }    return value;}
0
protected byte[] decrypt(byte[] encrypted)
{    byte[] serialized = encrypted;    CipherService cipherService = getCipherService();    if (cipherService != null) {        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());        serialized = byteSource.getBytes();    }    return serialized;}
0
protected byte[] serialize(PrincipalCollection principals)
{    return getSerializer().serialize(principals);}
0
protected PrincipalCollection deserialize(byte[] serializedIdentity)
{    return getSerializer().deserialize(serializedIdentity);}
0
public void onFailedLogin(Subject subject, AuthenticationToken token, AuthenticationException ae)
{    forgetIdentity(subject);}
0
public void onLogout(Subject subject)
{    forgetIdentity(subject);}
0
public Authenticator getAuthenticator()
{    return authenticator;}
0
public void setAuthenticator(Authenticator authenticator) throws IllegalArgumentException
{    if (authenticator == null) {        String msg = "Authenticator argument cannot be null.";        throw new IllegalArgumentException(msg);    }    this.authenticator = authenticator;}
0
protected void afterRealmsSet()
{    super.afterRealmsSet();    if (this.authenticator instanceof ModularRealmAuthenticator) {        ((ModularRealmAuthenticator) this.authenticator).setRealms(getRealms());    }}
0
public AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException
{    return this.authenticator.authenticate(token);}
0
public void destroy()
{    LifecycleUtils.destroy(getAuthenticator());    this.authenticator = null;    super.destroy();}
0
public Authorizer getAuthorizer()
{    return authorizer;}
0
public void setAuthorizer(Authorizer authorizer)
{    if (authorizer == null) {        String msg = "Authorizer argument cannot be null.";        throw new IllegalArgumentException(msg);    }    this.authorizer = authorizer;}
0
protected void afterRealmsSet()
{    super.afterRealmsSet();    if (this.authorizer instanceof ModularRealmAuthorizer) {        ((ModularRealmAuthorizer) this.authorizer).setRealms(getRealms());    }}
0
public void destroy()
{    LifecycleUtils.destroy(getAuthorizer());    this.authorizer = null;    super.destroy();}
0
public boolean isPermitted(PrincipalCollection principals, String permissionString)
{    return this.authorizer.isPermitted(principals, permissionString);}
0
public boolean isPermitted(PrincipalCollection principals, Permission permission)
{    return this.authorizer.isPermitted(principals, permission);}
0
public boolean[] isPermitted(PrincipalCollection principals, String... permissions)
{    return this.authorizer.isPermitted(principals, permissions);}
0
public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions)
{    return this.authorizer.isPermitted(principals, permissions);}
0
public boolean isPermittedAll(PrincipalCollection principals, String... permissions)
{    return this.authorizer.isPermittedAll(principals, permissions);}
0
public boolean isPermittedAll(PrincipalCollection principals, Collection<Permission> permissions)
{    return this.authorizer.isPermittedAll(principals, permissions);}
0
public void checkPermission(PrincipalCollection principals, String permission) throws AuthorizationException
{    this.authorizer.checkPermission(principals, permission);}
0
public void checkPermission(PrincipalCollection principals, Permission permission) throws AuthorizationException
{    this.authorizer.checkPermission(principals, permission);}
0
public void checkPermissions(PrincipalCollection principals, String... permissions) throws AuthorizationException
{    this.authorizer.checkPermissions(principals, permissions);}
0
public void checkPermissions(PrincipalCollection principals, Collection<Permission> permissions) throws AuthorizationException
{    this.authorizer.checkPermissions(principals, permissions);}
0
public boolean hasRole(PrincipalCollection principals, String roleIdentifier)
{    return this.authorizer.hasRole(principals, roleIdentifier);}
0
public boolean[] hasRoles(PrincipalCollection principals, List<String> roleIdentifiers)
{    return this.authorizer.hasRoles(principals, roleIdentifiers);}
0
public boolean hasAllRoles(PrincipalCollection principals, Collection<String> roleIdentifiers)
{    return this.authorizer.hasAllRoles(principals, roleIdentifiers);}
0
public void checkRole(PrincipalCollection principals, String role) throws AuthorizationException
{    this.authorizer.checkRole(principals, role);}
0
public void checkRoles(PrincipalCollection principals, Collection<String> roles) throws AuthorizationException
{    this.authorizer.checkRoles(principals, roles);}
0
public void checkRoles(PrincipalCollection principals, String... roles) throws AuthorizationException
{    this.authorizer.checkRoles(principals, roles);}
0
public CacheManager getCacheManager()
{    return cacheManager;}
0
public void setCacheManager(CacheManager cacheManager)
{    this.cacheManager = cacheManager;    afterCacheManagerSet();}
0
protected void afterCacheManagerSet()
{    applyEventBusToCacheManager();}
0
public EventBus getEventBus()
{    return eventBus;}
0
public void setEventBus(EventBus eventBus)
{    this.eventBus = eventBus;    afterEventBusSet();}
0
protected void applyEventBusToCacheManager()
{    if (this.eventBus != null && this.cacheManager != null && this.cacheManager instanceof EventBusAware) {        ((EventBusAware) this.cacheManager).setEventBus(this.eventBus);    }}
0
protected void afterEventBusSet()
{    applyEventBusToCacheManager();}
0
public void destroy()
{    LifecycleUtils.destroy(getCacheManager());    this.cacheManager = null;    LifecycleUtils.destroy(getEventBus());    this.eventBus = new DefaultEventBus();}
0
public SubjectFactory getSubjectFactory()
{    return subjectFactory;}
0
public void setSubjectFactory(SubjectFactory subjectFactory)
{    this.subjectFactory = subjectFactory;}
0
public SubjectDAO getSubjectDAO()
{    return subjectDAO;}
0
public void setSubjectDAO(SubjectDAO subjectDAO)
{    this.subjectDAO = subjectDAO;}
0
public RememberMeManager getRememberMeManager()
{    return rememberMeManager;}
0
public void setRememberMeManager(RememberMeManager rememberMeManager)
{    this.rememberMeManager = rememberMeManager;}
0
protected SubjectContext createSubjectContext()
{    return new DefaultSubjectContext();}
0
protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing)
{    SubjectContext context = createSubjectContext();    context.setAuthenticated(true);    context.setAuthenticationToken(token);    context.setAuthenticationInfo(info);    context.setSecurityManager(this);    if (existing != null) {        context.setSubject(existing);    }    return createSubject(context);}
0
protected void bind(Subject subject)
{    save(subject);}
0
protected void rememberMeSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info, Subject subject)
{    RememberMeManager rmm = getRememberMeManager();    if (rmm != null) {        try {            rmm.onSuccessfulLogin(subject, token, info);        } catch (Exception e) {            if (log.isWarnEnabled()) {                String msg = "Delegate RememberMeManager instance of type [" + rmm.getClass().getName() + "] threw an exception during onSuccessfulLogin.  RememberMe services will not be " + "performed for account [" + info + "].";                            }        }    } else {        if (log.isTraceEnabled()) {            log.trace("This " + getClass().getName() + " instance does not have a " + "[" + RememberMeManager.class.getName() + "] instance configured.  RememberMe services " + "will not be performed for account [" + info + "].");        }    }}
1
protected void rememberMeFailedLogin(AuthenticationToken token, AuthenticationException ex, Subject subject)
{    RememberMeManager rmm = getRememberMeManager();    if (rmm != null) {        try {            rmm.onFailedLogin(subject, token, ex);        } catch (Exception e) {            if (log.isWarnEnabled()) {                String msg = "Delegate RememberMeManager instance of type [" + rmm.getClass().getName() + "] threw an exception during onFailedLogin for AuthenticationToken [" + token + "].";                            }        }    }}
1
protected void rememberMeLogout(Subject subject)
{    RememberMeManager rmm = getRememberMeManager();    if (rmm != null) {        try {            rmm.onLogout(subject);        } catch (Exception e) {            if (log.isWarnEnabled()) {                String msg = "Delegate RememberMeManager instance of type [" + rmm.getClass().getName() + "] threw an exception during onLogout for subject with principals [" + (subject != null ? subject.getPrincipals() : null) + "]";                            }        }    }}
1
public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException
{    AuthenticationInfo info;    try {        info = authenticate(token);    } catch (AuthenticationException ae) {        try {            onFailedLogin(token, ae, subject);        } catch (Exception e) {            if (log.isInfoEnabled()) {                            }        }                throw ae;    }    Subject loggedIn = createSubject(token, info, subject);    onSuccessfulLogin(token, info, loggedIn);    return loggedIn;}
1
protected void onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info, Subject subject)
{    rememberMeSuccessfulLogin(token, info, subject);}
0
protected void onFailedLogin(AuthenticationToken token, AuthenticationException ae, Subject subject)
{    rememberMeFailedLogin(token, ae, subject);}
0
protected void beforeLogout(Subject subject)
{    rememberMeLogout(subject);}
0
protected SubjectContext copy(SubjectContext subjectContext)
{    return new DefaultSubjectContext(subjectContext);}
0
public Subject createSubject(SubjectContext subjectContext)
{        SubjectContext context = copy(subjectContext);        context = ensureSecurityManager(context);                context = resolveSession(context);            context = resolvePrincipals(context);    Subject subject = doCreateSubject(context);                    save(subject);    return subject;}
0
protected Subject doCreateSubject(SubjectContext context)
{    return getSubjectFactory().createSubject(context);}
0
protected void save(Subject subject)
{    this.subjectDAO.save(subject);}
0
protected void delete(Subject subject)
{    this.subjectDAO.delete(subject);}
0
protected SubjectContext ensureSecurityManager(SubjectContext context)
{    if (context.resolveSecurityManager() != null) {        log.trace("Context already contains a SecurityManager instance.  Returning.");        return context;    }    log.trace("No SecurityManager found in context.  Adding self reference.");    context.setSecurityManager(this);    return context;}
0
protected SubjectContext resolveSession(SubjectContext context)
{    if (context.resolveSession() != null) {                return context;    }    try {                        Session session = resolveContextSession(context);        if (session != null) {            context.setSession(session);        }    } catch (InvalidSessionException e) {            }    return context;}
1
protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException
{    SessionKey key = getSessionKey(context);    if (key != null) {        return getSession(key);    }    return null;}
0
protected SessionKey getSessionKey(SubjectContext context)
{    Serializable sessionId = context.getSessionId();    if (sessionId != null) {        return new DefaultSessionKey(sessionId);    }    return null;}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected SubjectContext resolvePrincipals(SubjectContext context)
{    PrincipalCollection principals = context.resolvePrincipals();    if (isEmpty(principals)) {        log.trace("No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.");        principals = getRememberedIdentity(context);        if (!isEmpty(principals)) {                        context.setPrincipals(principals);                                                                                                                } else {            log.trace("No remembered identity found.  Returning original context.");        }    }    return context;}
1
protected SessionContext createSessionContext(SubjectContext subjectContext)
{    DefaultSessionContext sessionContext = new DefaultSessionContext();    if (!CollectionUtils.isEmpty(subjectContext)) {        sessionContext.putAll(subjectContext);    }    Serializable sessionId = subjectContext.getSessionId();    if (sessionId != null) {        sessionContext.setSessionId(sessionId);    }    String host = subjectContext.resolveHost();    if (host != null) {        sessionContext.setHost(host);    }    return sessionContext;}
0
public void logout(Subject subject)
{    if (subject == null) {        throw new IllegalArgumentException("Subject method argument cannot be null.");    }    beforeLogout(subject);    PrincipalCollection principals = subject.getPrincipals();    if (principals != null && !principals.isEmpty()) {        if (log.isDebugEnabled()) {                    }        Authenticator authc = getAuthenticator();        if (authc instanceof LogoutAware) {            ((LogoutAware) authc).onLogout(principals);        }    }    try {        delete(subject);    } catch (Exception e) {        if (log.isDebugEnabled()) {            String msg = "Unable to cleanly unbind Subject.  Ignoring (logging out).";                    }    } finally {        try {            stopSession(subject);        } catch (Exception e) {            if (log.isDebugEnabled()) {                String msg = "Unable to cleanly stop Session for Subject [" + subject.getPrincipal() + "] " + "Ignoring (logging out).";                            }        }    }}
1
protected void stopSession(Subject subject)
{    Session s = subject.getSession(false);    if (s != null) {        s.stop();    }}
0
protected void unbind(Subject subject)
{    delete(subject);}
0
protected PrincipalCollection getRememberedIdentity(SubjectContext subjectContext)
{    RememberMeManager rmm = getRememberMeManager();    if (rmm != null) {        try {            return rmm.getRememberedPrincipals(subjectContext);        } catch (Exception e) {            if (log.isWarnEnabled()) {                String msg = "Delegate RememberMeManager instance of type [" + rmm.getClass().getName() + "] threw an exception during getRememberedPrincipals().";                            }        }    }    return null;}
1
public boolean isSessionStorageEnabled(Subject subject)
{    return (subject != null && subject.getSession(false) != null) || isSessionStorageEnabled();}
0
public boolean isSessionStorageEnabled()
{    return sessionStorageEnabled;}
0
public void setSessionStorageEnabled(boolean sessionStorageEnabled)
{    this.sessionStorageEnabled = sessionStorageEnabled;}
0
protected boolean isSessionStorageEnabled(Subject subject)
{    return getSessionStorageEvaluator().isSessionStorageEnabled(subject);}
0
public SessionStorageEvaluator getSessionStorageEvaluator()
{    return sessionStorageEvaluator;}
0
public void setSessionStorageEvaluator(SessionStorageEvaluator sessionStorageEvaluator)
{    this.sessionStorageEvaluator = sessionStorageEvaluator;}
0
public Subject save(Subject subject)
{    if (isSessionStorageEnabled(subject)) {        saveToSession(subject);    } else {        log.trace("Session storage of subject state for Subject [{}] has been disabled: identity and " + "authentication state are expected to be initialized on every request or invocation.", subject);    }    return subject;}
0
protected void saveToSession(Subject subject)
{        mergePrincipals(subject);    mergeAuthenticationState(subject);}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected void mergePrincipals(Subject subject)
{        PrincipalCollection currentPrincipals = null;        if (subject.isRunAs() && subject instanceof DelegatingSubject) {        try {            Field field = DelegatingSubject.class.getDeclaredField("principals");            field.setAccessible(true);            currentPrincipals = (PrincipalCollection) field.get(subject);        } catch (Exception e) {            throw new IllegalStateException("Unable to access DelegatingSubject principals property.", e);        }    }    if (currentPrincipals == null || currentPrincipals.isEmpty()) {        currentPrincipals = subject.getPrincipals();    }    Session session = subject.getSession(false);    if (session == null) {        if (!isEmpty(currentPrincipals)) {            session = subject.getSession();            session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);        }        } else {        PrincipalCollection existingPrincipals = (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);        if (isEmpty(currentPrincipals)) {            if (!isEmpty(existingPrincipals)) {                session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);            }                } else {            if (!currentPrincipals.equals(existingPrincipals)) {                session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);            }                }    }}
0
protected void mergeAuthenticationState(Subject subject)
{    Session session = subject.getSession(false);    if (session == null) {        if (subject.isAuthenticated()) {            session = subject.getSession();            session.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);        }        } else {        Boolean existingAuthc = (Boolean) session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);        if (subject.isAuthenticated()) {            if (existingAuthc == null || !existingAuthc) {                session.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);            }                } else {            if (existingAuthc != null) {                                session.removeAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);            }                }    }}
0
protected void removeFromSession(Subject subject)
{    Session session = subject.getSession(false);    if (session != null) {        session.removeAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY);        session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);    }}
0
public void delete(Subject subject)
{    removeFromSession(subject);}
0
public Subject createSubject(SubjectContext context)
{    SecurityManager securityManager = context.resolveSecurityManager();    Session session = context.resolveSession();    boolean sessionCreationEnabled = context.isSessionCreationEnabled();    PrincipalCollection principals = context.resolvePrincipals();    boolean authenticated = context.resolveAuthenticated();    String host = context.resolveHost();    return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);}
0
protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated, String host, Session session, SecurityManager securityManager)
{    return new DelegatingSubject(principals, authenticated, host, session, true, securityManager);}
0
public void setRealm(Realm realm)
{    if (realm == null) {        throw new IllegalArgumentException("Realm argument cannot be null");    }    Collection<Realm> realms = new ArrayList<Realm>(1);    realms.add(realm);    setRealms(realms);}
0
public void setRealms(Collection<Realm> realms)
{    if (realms == null) {        throw new IllegalArgumentException("Realms collection argument cannot be null.");    }    if (realms.isEmpty()) {        throw new IllegalArgumentException("Realms collection argument cannot be empty.");    }    this.realms = realms;    afterRealmsSet();}
0
protected void afterRealmsSet()
{    applyCacheManagerToRealms();    applyEventBusToRealms();}
0
public Collection<Realm> getRealms()
{    return realms;}
0
protected void applyCacheManagerToRealms()
{    CacheManager cacheManager = getCacheManager();    Collection<Realm> realms = getRealms();    if (cacheManager != null && realms != null && !realms.isEmpty()) {        for (Realm realm : realms) {            if (realm instanceof CacheManagerAware) {                ((CacheManagerAware) realm).setCacheManager(cacheManager);            }        }    }}
0
protected void applyEventBusToRealms()
{    EventBus eventBus = getEventBus();    Collection<Realm> realms = getRealms();    if (eventBus != null && realms != null && !realms.isEmpty()) {        for (Realm realm : realms) {            if (realm instanceof EventBusAware) {                ((EventBusAware) realm).setEventBus(eventBus);            }        }    }}
0
protected void afterCacheManagerSet()
{    super.afterCacheManagerSet();    applyCacheManagerToRealms();}
0
protected void afterEventBusSet()
{    super.afterEventBusSet();    applyEventBusToRealms();}
0
public void destroy()
{    LifecycleUtils.destroy(getRealms());    this.realms = null;    super.destroy();}
0
public void setSessionManager(SessionManager sessionManager)
{    this.sessionManager = sessionManager;    afterSessionManagerSet();}
0
protected void afterSessionManagerSet()
{    applyCacheManagerToSessionManager();    applyEventBusToSessionManager();}
0
public SessionManager getSessionManager()
{    return this.sessionManager;}
0
protected void afterCacheManagerSet()
{    super.afterCacheManagerSet();    applyCacheManagerToSessionManager();}
0
protected void afterEventBusSet()
{    super.afterEventBusSet();    applyEventBusToSessionManager();}
0
protected void applyCacheManagerToSessionManager()
{    if (this.sessionManager instanceof CacheManagerAware) {        ((CacheManagerAware) this.sessionManager).setCacheManager(getCacheManager());    }}
0
protected void applyEventBusToSessionManager()
{    EventBus eventBus = getEventBus();    if (eventBus != null && this.sessionManager instanceof EventBusAware) {        ((EventBusAware) this.sessionManager).setEventBus(eventBus);    }}
0
public Session start(SessionContext context) throws AuthorizationException
{    return this.sessionManager.start(context);}
0
public Session getSession(SessionKey key) throws SessionException
{    return this.sessionManager.getSession(key);}
0
public void destroy()
{    LifecycleUtils.destroy(getSessionManager());    this.sessionManager = null;    super.destroy();}
0
public void setGroupRolesMap(Map<String, String> groupRolesMap)
{    this.groupRolesMap = groupRolesMap;}
0
protected AuthenticationInfo queryForAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException
{    UsernamePasswordToken upToken = (UsernamePasswordToken) token;        LdapContext ctx = null;    try {        ctx = ldapContextFactory.getLdapContext(upToken.getUsername(), String.valueOf(upToken.getPassword()));    } finally {        LdapUtils.closeContext(ctx);    }    return buildAuthenticationInfo(upToken.getUsername(), upToken.getPassword());}
0
protected AuthenticationInfo buildAuthenticationInfo(String username, char[] password)
{    return new SimpleAuthenticationInfo(username, password, getName());}
0
protected AuthorizationInfo queryForAuthorizationInfo(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException
{    String username = (String) getAvailablePrincipal(principals);        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();    Set<String> roleNames;    try {        roleNames = getRoleNamesForUser(username, ldapContext);    } finally {        LdapUtils.closeContext(ldapContext);    }    return buildAuthorizationInfo(roleNames);}
0
protected AuthorizationInfo buildAuthorizationInfo(Set<String> roleNames)
{    return new SimpleAuthorizationInfo(roleNames);}
0
protected Set<String> getRoleNamesForUser(String username, LdapContext ldapContext) throws NamingException
{    Set<String> roleNames;    roleNames = new LinkedHashSet<String>();    SearchControls searchCtls = new SearchControls();    searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);    String userPrincipalName = username;    if (principalSuffix != null) {        userPrincipalName += principalSuffix;    }    Object[] searchArguments = new Object[] { userPrincipalName };    NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchArguments, searchCtls);    while (answer.hasMoreElements()) {        SearchResult sr = (SearchResult) answer.next();        if (log.isDebugEnabled()) {                    }        Attributes attrs = sr.getAttributes();        if (attrs != null) {            NamingEnumeration ae = attrs.getAll();            while (ae.hasMore()) {                Attribute attr = (Attribute) ae.next();                if (attr.getID().equals("memberOf")) {                    Collection<String> groupNames = LdapUtils.getAllAttributeValues(attr);                    if (log.isDebugEnabled()) {                                            }                    Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);                    roleNames.addAll(rolesForGroups);                }            }        }    }    return roleNames;}
1
protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames)
{    Set<String> roleNames = new HashSet<String>(groupNames.size());    if (groupRolesMap != null) {        for (String groupName : groupNames) {            String strRoleNames = groupRolesMap.get(groupName);            if (strRoleNames != null) {                for (String roleName : strRoleNames.split(ROLE_NAMES_DELIMETER)) {                    if (log.isDebugEnabled()) {                                            }                    roleNames.add(roleName);                }            }        }    }    return roleNames;}
1
public CredentialsMatcher getCredentialsMatcher()
{    return credentialsMatcher;}
0
public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher)
{    this.credentialsMatcher = credentialsMatcher;}
0
public Class getAuthenticationTokenClass()
{    return authenticationTokenClass;}
0
public void setAuthenticationTokenClass(Class<? extends AuthenticationToken> authenticationTokenClass)
{    this.authenticationTokenClass = authenticationTokenClass;}
0
public void setAuthenticationCache(Cache<Object, AuthenticationInfo> authenticationCache)
{    this.authenticationCache = authenticationCache;}
0
public Cache<Object, AuthenticationInfo> getAuthenticationCache()
{    return this.authenticationCache;}
0
public String getAuthenticationCacheName()
{    return this.authenticationCacheName;}
0
public void setAuthenticationCacheName(String authenticationCacheName)
{    this.authenticationCacheName = authenticationCacheName;}
0
public boolean isAuthenticationCachingEnabled()
{    return this.authenticationCachingEnabled && isCachingEnabled();}
0
public void setAuthenticationCachingEnabled(boolean authenticationCachingEnabled)
{    this.authenticationCachingEnabled = authenticationCachingEnabled;    if (authenticationCachingEnabled) {        setCachingEnabled(true);    }}
0
public void setName(String name)
{    super.setName(name);    String authcCacheName = this.authenticationCacheName;    if (authcCacheName != null && authcCacheName.startsWith(getClass().getName())) {                        this.authenticationCacheName = name + DEFAULT_AUTHENTICATION_CACHE_SUFFIX;    }}
0
public boolean supports(AuthenticationToken token)
{    return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());}
0
public final void init()
{        getAvailableAuthenticationCache();    onInit();}
0
protected void onInit()
{}
0
protected void afterCacheManagerSet()
{        getAvailableAuthenticationCache();}
0
private Cache<Object, AuthenticationInfo> getAvailableAuthenticationCache()
{    Cache<Object, AuthenticationInfo> cache = getAuthenticationCache();    boolean authcCachingEnabled = isAuthenticationCachingEnabled();    if (cache == null && authcCachingEnabled) {        cache = getAuthenticationCacheLazy();    }    return cache;}
0
private Cache<Object, AuthenticationInfo> getAuthenticationCacheLazy()
{    if (this.authenticationCache == null) {        log.trace("No authenticationCache instance set.  Checking for a cacheManager...");        CacheManager cacheManager = getCacheManager();        if (cacheManager != null) {            String cacheName = getAuthenticationCacheName();                        this.authenticationCache = cacheManager.getCache(cacheName);        }    }    return this.authenticationCache;}
1
private AuthenticationInfo getCachedAuthenticationInfo(AuthenticationToken token)
{    AuthenticationInfo info = null;    Cache<Object, AuthenticationInfo> cache = getAvailableAuthenticationCache();    if (cache != null && token != null) {        log.trace("Attempting to retrieve the AuthenticationInfo from cache.");        Object key = getAuthenticationCacheKey(token);        info = cache.get(key);        if (info == null) {            log.trace("No AuthorizationInfo found in cache for key [{}]", key);        } else {            log.trace("Found cached AuthorizationInfo for key [{}]", key);        }    }    return info;}
0
private void cacheAuthenticationInfoIfPossible(AuthenticationToken token, AuthenticationInfo info)
{    if (!isAuthenticationCachingEnabled(token, info)) {                        return;    }    Cache<Object, AuthenticationInfo> cache = getAvailableAuthenticationCache();    if (cache != null) {        Object key = getAuthenticationCacheKey(token);        cache.put(key, info);        log.trace("Cached AuthenticationInfo for continued authentication.  key=[{}], value=[{}].", key, info);    }}
1
protected boolean isAuthenticationCachingEnabled(AuthenticationToken token, AuthenticationInfo info)
{    return isAuthenticationCachingEnabled();}
0
public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    AuthenticationInfo info = getCachedAuthenticationInfo(token);    if (info == null) {                info = doGetAuthenticationInfo(token);                if (token != null && info != null) {            cacheAuthenticationInfoIfPossible(token, info);        }    } else {            }    if (info != null) {        assertCredentialsMatch(token, info);    } else {            }    return info;}
1
protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException
{    CredentialsMatcher cm = getCredentialsMatcher();    if (cm != null) {        if (!cm.doCredentialsMatch(token, info)) {                        String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials.";            throw new IncorrectCredentialsException(msg);        }    } else {        throw new AuthenticationException("A CredentialsMatcher must be configured in order to verify " + "credentials during authentication.  If you do not wish for credentials to be examined, you " + "can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");    }}
0
protected Object getAuthenticationCacheKey(AuthenticationToken token)
{    return token != null ? token.getPrincipal() : null;}
0
protected Object getAuthenticationCacheKey(PrincipalCollection principals)
{    return getAvailablePrincipal(principals);}
0
protected void doClearCache(PrincipalCollection principals)
{    super.doClearCache(principals);    clearCachedAuthenticationInfo(principals);}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected void clearCachedAuthenticationInfo(PrincipalCollection principals)
{    if (!isEmpty(principals)) {        Cache<Object, AuthenticationInfo> cache = getAvailableAuthenticationCache();                if (cache != null) {            Object key = getAuthenticationCacheKey(principals);            cache.remove(key);        }    }}
0
public void setName(String name)
{    super.setName(name);    String authzCacheName = this.authorizationCacheName;    if (authzCacheName != null && authzCacheName.startsWith(getClass().getName())) {                        this.authorizationCacheName = name + DEFAULT_AUTHORIZATION_CACHE_SUFFIX;    }}
0
public void setAuthorizationCache(Cache<Object, AuthorizationInfo> authorizationCache)
{    this.authorizationCache = authorizationCache;}
0
public Cache<Object, AuthorizationInfo> getAuthorizationCache()
{    return this.authorizationCache;}
0
public String getAuthorizationCacheName()
{    return authorizationCacheName;}
0
public void setAuthorizationCacheName(String authorizationCacheName)
{    this.authorizationCacheName = authorizationCacheName;}
0
public boolean isAuthorizationCachingEnabled()
{    return isCachingEnabled() && authorizationCachingEnabled;}
0
public void setAuthorizationCachingEnabled(boolean authenticationCachingEnabled)
{    this.authorizationCachingEnabled = authenticationCachingEnabled;    if (authenticationCachingEnabled) {        setCachingEnabled(true);    }}
0
public PermissionResolver getPermissionResolver()
{    return permissionResolver;}
0
public void setPermissionResolver(PermissionResolver permissionResolver)
{    if (permissionResolver == null)        throw new IllegalArgumentException("Null PermissionResolver is not allowed");    this.permissionResolver = permissionResolver;}
0
public RolePermissionResolver getRolePermissionResolver()
{    return permissionRoleResolver;}
0
public void setRolePermissionResolver(RolePermissionResolver permissionRoleResolver)
{    this.permissionRoleResolver = permissionRoleResolver;}
0
protected void onInit()
{    super.onInit();        getAvailableAuthorizationCache();}
0
protected void afterCacheManagerSet()
{    super.afterCacheManagerSet();        getAvailableAuthorizationCache();}
0
private Cache<Object, AuthorizationInfo> getAuthorizationCacheLazy()
{    if (this.authorizationCache == null) {        if (log.isDebugEnabled()) {                    }        CacheManager cacheManager = getCacheManager();        if (cacheManager != null) {            String cacheName = getAuthorizationCacheName();            if (log.isDebugEnabled()) {                            }            this.authorizationCache = cacheManager.getCache(cacheName);        } else {            if (log.isDebugEnabled()) {                            }        }    }    return this.authorizationCache;}
1
private Cache<Object, AuthorizationInfo> getAvailableAuthorizationCache()
{    Cache<Object, AuthorizationInfo> cache = getAuthorizationCache();    if (cache == null && isAuthorizationCachingEnabled()) {        cache = getAuthorizationCacheLazy();    }    return cache;}
0
protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals)
{    if (principals == null) {        return null;    }    AuthorizationInfo info = null;    if (log.isTraceEnabled()) {        log.trace("Retrieving AuthorizationInfo for principals [" + principals + "]");    }    Cache<Object, AuthorizationInfo> cache = getAvailableAuthorizationCache();    if (cache != null) {        if (log.isTraceEnabled()) {            log.trace("Attempting to retrieve the AuthorizationInfo from cache.");        }        Object key = getAuthorizationCacheKey(principals);        info = cache.get(key);        if (log.isTraceEnabled()) {            if (info == null) {                log.trace("No AuthorizationInfo found in cache for principals [" + principals + "]");            } else {                log.trace("AuthorizationInfo found in cache for principals [" + principals + "]");            }        }    }    if (info == null) {                info = doGetAuthorizationInfo(principals);                if (info != null && cache != null) {            if (log.isTraceEnabled()) {                log.trace("Caching authorization info for principals: [" + principals + "].");            }            Object key = getAuthorizationCacheKey(principals);            cache.put(key, info);        }    }    return info;}
0
protected Object getAuthorizationCacheKey(PrincipalCollection principals)
{    return principals;}
0
protected void clearCachedAuthorizationInfo(PrincipalCollection principals)
{    if (principals == null) {        return;    }    Cache<Object, AuthorizationInfo> cache = getAvailableAuthorizationCache();        if (cache != null) {        Object key = getAuthorizationCacheKey(principals);        cache.remove(key);    }}
0
protected Collection<Permission> getPermissions(AuthorizationInfo info)
{    Set<Permission> permissions = new HashSet<Permission>();    if (info != null) {        Collection<Permission> perms = info.getObjectPermissions();        if (!CollectionUtils.isEmpty(perms)) {            permissions.addAll(perms);        }        perms = resolvePermissions(info.getStringPermissions());        if (!CollectionUtils.isEmpty(perms)) {            permissions.addAll(perms);        }        perms = resolveRolePermissions(info.getRoles());        if (!CollectionUtils.isEmpty(perms)) {            permissions.addAll(perms);        }    }    if (permissions.isEmpty()) {        return Collections.emptySet();    } else {        return Collections.unmodifiableSet(permissions);    }}
0
private Collection<Permission> resolvePermissions(Collection<String> stringPerms)
{    Collection<Permission> perms = Collections.emptySet();    PermissionResolver resolver = getPermissionResolver();    if (resolver != null && !CollectionUtils.isEmpty(stringPerms)) {        perms = new LinkedHashSet<Permission>(stringPerms.size());        for (String strPermission : stringPerms) {            if (StringUtils.clean(strPermission) != null) {                Permission permission = resolver.resolvePermission(strPermission);                perms.add(permission);            }        }    }    return perms;}
0
private Collection<Permission> resolveRolePermissions(Collection<String> roleNames)
{    Collection<Permission> perms = Collections.emptySet();    RolePermissionResolver resolver = getRolePermissionResolver();    if (resolver != null && !CollectionUtils.isEmpty(roleNames)) {        perms = new LinkedHashSet<Permission>(roleNames.size());        for (String roleName : roleNames) {            Collection<Permission> resolved = resolver.resolvePermissionsInRole(roleName);            if (!CollectionUtils.isEmpty(resolved)) {                perms.addAll(resolved);            }        }    }    return perms;}
0
public boolean isPermitted(PrincipalCollection principals, String permission)
{    Permission p = getPermissionResolver().resolvePermission(permission);    return isPermitted(principals, p);}
0
public boolean isPermitted(PrincipalCollection principals, Permission permission)
{    AuthorizationInfo info = getAuthorizationInfo(principals);    return isPermitted(permission, info);}
0
protected boolean isPermitted(Permission permission, AuthorizationInfo info)
{    Collection<Permission> perms = getPermissions(info);    if (perms != null && !perms.isEmpty()) {        for (Permission perm : perms) {            if (perm.implies(permission)) {                return true;            }        }    }    return false;}
0
public boolean[] isPermitted(PrincipalCollection subjectIdentifier, String... permissions)
{    List<Permission> perms = new ArrayList<Permission>(permissions.length);    for (String permString : permissions) {        perms.add(getPermissionResolver().resolvePermission(permString));    }    return isPermitted(subjectIdentifier, perms);}
0
public boolean[] isPermitted(PrincipalCollection principals, List<Permission> permissions)
{    AuthorizationInfo info = getAuthorizationInfo(principals);    return isPermitted(permissions, info);}
0
protected boolean[] isPermitted(List<Permission> permissions, AuthorizationInfo info)
{    boolean[] result;    if (permissions != null && !permissions.isEmpty()) {        int size = permissions.size();        result = new boolean[size];        int i = 0;        for (Permission p : permissions) {            result[i++] = isPermitted(p, info);        }    } else {        result = new boolean[0];    }    return result;}
0
public boolean isPermittedAll(PrincipalCollection subjectIdentifier, String... permissions)
{    if (permissions != null && permissions.length > 0) {        Collection<Permission> perms = new ArrayList<Permission>(permissions.length);        for (String permString : permissions) {            perms.add(getPermissionResolver().resolvePermission(permString));        }        return isPermittedAll(subjectIdentifier, perms);    }    return false;}
0
public boolean isPermittedAll(PrincipalCollection principal, Collection<Permission> permissions)
{    AuthorizationInfo info = getAuthorizationInfo(principal);    return info != null && isPermittedAll(permissions, info);}
0
protected boolean isPermittedAll(Collection<Permission> permissions, AuthorizationInfo info)
{    if (permissions != null && !permissions.isEmpty()) {        for (Permission p : permissions) {            if (!isPermitted(p, info)) {                return false;            }        }    }    return true;}
0
public void checkPermission(PrincipalCollection subjectIdentifier, String permission) throws AuthorizationException
{    Permission p = getPermissionResolver().resolvePermission(permission);    checkPermission(subjectIdentifier, p);}
0
public void checkPermission(PrincipalCollection principal, Permission permission) throws AuthorizationException
{    AuthorizationInfo info = getAuthorizationInfo(principal);    checkPermission(permission, info);}
0
protected void checkPermission(Permission permission, AuthorizationInfo info)
{    if (!isPermitted(permission, info)) {        String msg = "User is not permitted [" + permission + "]";        throw new UnauthorizedException(msg);    }}
0
public void checkPermissions(PrincipalCollection subjectIdentifier, String... permissions) throws AuthorizationException
{    if (permissions != null) {        for (String permString : permissions) {            checkPermission(subjectIdentifier, permString);        }    }}
0
public void checkPermissions(PrincipalCollection principal, Collection<Permission> permissions) throws AuthorizationException
{    AuthorizationInfo info = getAuthorizationInfo(principal);    checkPermissions(permissions, info);}
0
protected void checkPermissions(Collection<Permission> permissions, AuthorizationInfo info)
{    if (permissions != null && !permissions.isEmpty()) {        for (Permission p : permissions) {            checkPermission(p, info);        }    }}
0
public boolean hasRole(PrincipalCollection principal, String roleIdentifier)
{    AuthorizationInfo info = getAuthorizationInfo(principal);    return hasRole(roleIdentifier, info);}
0
protected boolean hasRole(String roleIdentifier, AuthorizationInfo info)
{    return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);}
0
public boolean[] hasRoles(PrincipalCollection principal, List<String> roleIdentifiers)
{    AuthorizationInfo info = getAuthorizationInfo(principal);    boolean[] result = new boolean[roleIdentifiers != null ? roleIdentifiers.size() : 0];    if (info != null) {        result = hasRoles(roleIdentifiers, info);    }    return result;}
0
protected boolean[] hasRoles(List<String> roleIdentifiers, AuthorizationInfo info)
{    boolean[] result;    if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {        int size = roleIdentifiers.size();        result = new boolean[size];        int i = 0;        for (String roleName : roleIdentifiers) {            result[i++] = hasRole(roleName, info);        }    } else {        result = new boolean[0];    }    return result;}
0
public boolean hasAllRoles(PrincipalCollection principal, Collection<String> roleIdentifiers)
{    AuthorizationInfo info = getAuthorizationInfo(principal);    return info != null && hasAllRoles(roleIdentifiers, info);}
0
private boolean hasAllRoles(Collection<String> roleIdentifiers, AuthorizationInfo info)
{    if (roleIdentifiers != null && !roleIdentifiers.isEmpty()) {        for (String roleName : roleIdentifiers) {            if (!hasRole(roleName, info)) {                return false;            }        }    }    return true;}
0
public void checkRole(PrincipalCollection principal, String role) throws AuthorizationException
{    AuthorizationInfo info = getAuthorizationInfo(principal);    checkRole(role, info);}
0
protected void checkRole(String role, AuthorizationInfo info)
{    if (!hasRole(role, info)) {        String msg = "User does not have role [" + role + "]";        throw new UnauthorizedException(msg);    }}
0
public void checkRoles(PrincipalCollection principal, Collection<String> roles) throws AuthorizationException
{    AuthorizationInfo info = getAuthorizationInfo(principal);    checkRoles(roles, info);}
0
public void checkRoles(PrincipalCollection principal, String... roles) throws AuthorizationException
{    checkRoles(principal, Arrays.asList(roles));}
0
protected void checkRoles(Collection<String> roles, AuthorizationInfo info)
{    if (roles != null && !roles.isEmpty()) {        for (String roleName : roles) {            checkRole(roleName, info);        }    }}
0
protected void doClearCache(PrincipalCollection principals)
{    super.doClearCache(principals);    clearCachedAuthorizationInfo(principals);}
0
public CacheManager getCacheManager()
{    return this.cacheManager;}
0
public void setCacheManager(CacheManager cacheManager)
{    this.cacheManager = cacheManager;    afterCacheManagerSet();}
0
public boolean isCachingEnabled()
{    return cachingEnabled;}
0
public void setCachingEnabled(boolean cachingEnabled)
{    this.cachingEnabled = cachingEnabled;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
protected void afterCacheManagerSet()
{}
0
public void onLogout(PrincipalCollection principals)
{    clearCache(principals);}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected void clearCache(PrincipalCollection principals)
{    if (!isEmpty(principals)) {        doClearCache(principals);        log.trace("Cleared cache entries for account with principals [{}]", principals);    }}
0
protected void doClearCache(PrincipalCollection principals)
{}
0
protected Object getAvailablePrincipal(PrincipalCollection principals)
{    Object primary = null;    if (!isEmpty(principals)) {        Collection thisPrincipals = principals.fromRealm(getName());        if (!CollectionUtils.isEmpty(thisPrincipals)) {            primary = thisPrincipals.iterator().next();        } else {                        primary = principals.getPrimaryPrincipal();        }    }    return primary;}
0
public void setDataSource(DataSource dataSource)
{    this.dataSource = dataSource;}
0
public void setAuthenticationQuery(String authenticationQuery)
{    this.authenticationQuery = authenticationQuery;}
0
public void setUserRolesQuery(String userRolesQuery)
{    this.userRolesQuery = userRolesQuery;}
0
public void setPermissionsQuery(String permissionsQuery)
{    this.permissionsQuery = permissionsQuery;}
0
public void setPermissionsLookupEnabled(boolean permissionsLookupEnabled)
{    this.permissionsLookupEnabled = permissionsLookupEnabled;}
0
public void setSaltStyle(SaltStyle saltStyle)
{    this.saltStyle = saltStyle;    if (saltStyle == SaltStyle.COLUMN && authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) {        authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY;    }}
0
public void setSaltIsBase64Encoded(boolean saltIsBase64Encoded)
{    this.saltIsBase64Encoded = saltIsBase64Encoded;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    UsernamePasswordToken upToken = (UsernamePasswordToken) token;    String username = upToken.getUsername();        if (username == null) {        throw new AccountException("Null usernames are not allowed by this realm.");    }    Connection conn = null;    SimpleAuthenticationInfo info = null;    try {        conn = dataSource.getConnection();        String password = null;        String salt = null;        switch(saltStyle) {            case NO_SALT:                password = getPasswordForUser(conn, username)[0];                break;            case CRYPT:                                throw new ConfigurationException("Not implemented yet");                        case COLUMN:                String[] queryResults = getPasswordForUser(conn, username);                password = queryResults[0];                salt = queryResults[1];                break;            case EXTERNAL:                password = getPasswordForUser(conn, username)[0];                salt = getSaltForUser(username);        }        if (password == null) {            throw new UnknownAccountException("No account found for user [" + username + "]");        }        info = new SimpleAuthenticationInfo(username, password.toCharArray(), getName());        if (salt != null) {            if (saltStyle == SaltStyle.COLUMN && saltIsBase64Encoded) {                info.setCredentialsSalt(ByteSource.Util.bytes(Base64.decode(salt)));            } else {                info.setCredentialsSalt(ByteSource.Util.bytes(salt));            }        }    } catch (SQLException e) {        final String message = "There was a SQL error while authenticating user [" + username + "]";        if (log.isErrorEnabled()) {                    }                throw new AuthenticationException(message, e);    } finally {        JdbcUtils.closeConnection(conn);    }    return info;}
1
private String[] getPasswordForUser(Connection conn, String username) throws SQLException
{    String[] result;    boolean returningSeparatedSalt = false;    switch(saltStyle) {        case NO_SALT:        case CRYPT:        case EXTERNAL:            result = new String[1];            break;        default:            result = new String[2];            returningSeparatedSalt = true;    }    PreparedStatement ps = null;    ResultSet rs = null;    try {        ps = conn.prepareStatement(authenticationQuery);        ps.setString(1, username);                rs = ps.executeQuery();                boolean foundResult = false;        while (rs.next()) {                        if (foundResult) {                throw new AuthenticationException("More than one user row found for user [" + username + "]. Usernames must be unique.");            }            result[0] = rs.getString(1);            if (returningSeparatedSalt) {                result[1] = rs.getString(2);            }            foundResult = true;        }    } finally {        JdbcUtils.closeResultSet(rs);        JdbcUtils.closeStatement(ps);    }    return result;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{        if (principals == null) {        throw new AuthorizationException("PrincipalCollection method argument cannot be null.");    }    String username = (String) getAvailablePrincipal(principals);    Connection conn = null;    Set<String> roleNames = null;    Set<String> permissions = null;    try {        conn = dataSource.getConnection();                roleNames = getRoleNamesForUser(conn, username);        if (permissionsLookupEnabled) {            permissions = getPermissions(conn, username, roleNames);        }    } catch (SQLException e) {        final String message = "There was a SQL error while authorizing user [" + username + "]";        if (log.isErrorEnabled()) {                    }                throw new AuthorizationException(message, e);    } finally {        JdbcUtils.closeConnection(conn);    }    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roleNames);    info.setStringPermissions(permissions);    return info;}
1
protected Set<String> getRoleNamesForUser(Connection conn, String username) throws SQLException
{    PreparedStatement ps = null;    ResultSet rs = null;    Set<String> roleNames = new LinkedHashSet<String>();    try {        ps = conn.prepareStatement(userRolesQuery);        ps.setString(1, username);                rs = ps.executeQuery();                while (rs.next()) {            String roleName = rs.getString(1);                        if (roleName != null) {                roleNames.add(roleName);            } else {                if (log.isWarnEnabled()) {                                    }            }        }    } finally {        JdbcUtils.closeResultSet(rs);        JdbcUtils.closeStatement(ps);    }    return roleNames;}
1
protected Set<String> getPermissions(Connection conn, String username, Collection<String> roleNames) throws SQLException
{    PreparedStatement ps = null;    Set<String> permissions = new LinkedHashSet<String>();    try {        ps = conn.prepareStatement(permissionsQuery);        for (String roleName : roleNames) {            ps.setString(1, roleName);            ResultSet rs = null;            try {                                rs = ps.executeQuery();                                while (rs.next()) {                    String permissionString = rs.getString(1);                                        permissions.add(permissionString);                }            } finally {                JdbcUtils.closeResultSet(rs);            }        }    } finally {        JdbcUtils.closeStatement(ps);    }    return permissions;}
0
protected String getSaltForUser(String username)
{    return username;}
0
public Collection<String> getJndiNames()
{    return jndiNames;}
0
public void setJndiNames(Collection<String> jndiNames)
{    this.jndiNames = jndiNames;}
0
public void setJndiNames(String commaDelimited) throws IllegalStateException
{    String arg = StringUtils.clean(commaDelimited);    if (arg == null) {        String msg = "One or more comma-delimited jndi names must be specified for the " + getClass().getName() + " to locate Realms.";        throw new IllegalStateException(msg);    }    String[] names = StringUtils.tokenizeToStringArray(arg, ",");    setJndiNames(Arrays.asList(names));}
0
public Collection<Realm> getRealms() throws IllegalStateException
{    Collection<String> jndiNames = getJndiNames();    if (jndiNames == null || jndiNames.isEmpty()) {        String msg = "One or more jndi names must be specified for the " + getClass().getName() + " to locate Realms.";        throw new IllegalStateException(msg);    }    List<Realm> realms = new ArrayList<Realm>(jndiNames.size());    for (String name : jndiNames) {        try {            Realm realm = (Realm) lookup(name, Realm.class);            realms.add(realm);        } catch (Exception e) {            throw new IllegalStateException("Unable to look up realm with jndi name '" + name + "'.", e);        }    }    return realms.isEmpty() ? null : realms;}
0
public void setPrincipalSuffix(String principalSuffix)
{    this.principalSuffix = principalSuffix;}
0
public void setSearchBase(String searchBase)
{    this.searchBase = searchBase;}
0
public void setUrl(String url)
{    this.url = url;}
0
public void setSystemUsername(String systemUsername)
{    this.systemUsername = systemUsername;}
0
public void setSystemPassword(String systemPassword)
{    this.systemPassword = systemPassword;}
0
public void setLdapContextFactory(LdapContextFactory ldapContextFactory)
{    this.ldapContextFactory = ldapContextFactory;}
0
public void setSearchFilter(String searchFilter)
{    this.searchFilter = searchFilter;}
0
protected void onInit()
{    super.onInit();    ensureContextFactory();}
0
private LdapContextFactory ensureContextFactory()
{    if (this.ldapContextFactory == null) {        if (log.isDebugEnabled()) {                    }        DefaultLdapContextFactory defaultFactory = new DefaultLdapContextFactory();        defaultFactory.setPrincipalSuffix(this.principalSuffix);        defaultFactory.setSearchBase(this.searchBase);        defaultFactory.setUrl(this.url);        defaultFactory.setSystemUsername(this.systemUsername);        defaultFactory.setSystemPassword(this.systemPassword);        this.ldapContextFactory = defaultFactory;    }    return this.ldapContextFactory;}
1
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    AuthenticationInfo info;    try {        info = queryForAuthenticationInfo(token, ensureContextFactory());    } catch (javax.naming.AuthenticationException e) {        throw new AuthenticationException("LDAP authentication failed.", e);    } catch (NamingException e) {        String msg = "LDAP naming error while attempting to authenticate user.";        throw new AuthenticationException(msg, e);    }    return info;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    AuthorizationInfo info;    try {        info = queryForAuthorizationInfo(principals, ensureContextFactory());    } catch (NamingException e) {        String msg = "LDAP naming error while attempting to retrieve authorization for user [" + principals + "].";        throw new AuthorizationException(msg, e);    }    return info;}
0
public void setAuthentication(String authentication)
{    this.authentication = authentication;}
0
public void setPrincipalSuffix(String principalSuffix)
{    this.principalSuffix = principalSuffix;}
0
public void setSearchBase(String searchBase)
{    this.searchBase = searchBase;}
0
public void setContextFactoryClassName(String contextFactoryClassName)
{    this.contextFactoryClassName = contextFactoryClassName;}
0
public void setUrl(String url)
{    this.url = url;}
0
public void setReferral(String referral)
{    this.referral = referral;}
0
public void setSystemUsername(String systemUsername)
{    this.systemUsername = systemUsername;}
0
public void setSystemPassword(String systemPassword)
{    this.systemPassword = systemPassword;}
0
public void setUsePooling(boolean usePooling)
{    this.usePooling = usePooling;}
0
public void setAdditionalEnvironment(Map<String, String> additionalEnvironment)
{    this.additionalEnvironment = additionalEnvironment;}
0
public LdapContext getSystemLdapContext() throws NamingException
{    return getLdapContext(systemUsername, systemPassword);}
0
public LdapContext getLdapContext(String username, String password) throws NamingException
{    if (username != null && principalSuffix != null) {        username += principalSuffix;    }    return getLdapContext((Object) username, password);}
0
public LdapContext getLdapContext(Object principal, Object credentials) throws NamingException
{    if (url == null) {        throw new IllegalStateException("An LDAP URL must be specified of the form ldap://<hostname>:<port>");    }    Hashtable<String, Object> env = new Hashtable<String, Object>();    env.put(Context.SECURITY_AUTHENTICATION, authentication);    if (principal != null) {        env.put(Context.SECURITY_PRINCIPAL, principal);    }    if (credentials != null) {        env.put(Context.SECURITY_CREDENTIALS, credentials);    }    env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactoryClassName);    env.put(Context.PROVIDER_URL, url);    env.put(Context.REFERRAL, referral);        if (usePooling && principal != null && principal.equals(systemUsername)) {                env.put(SUN_CONNECTION_POOLING_PROPERTY, "true");    }    if (additionalEnvironment != null) {        env.putAll(additionalEnvironment);    }    if (log.isDebugEnabled()) {            }        validateAuthenticationInfo(env);    return createLdapContext(env);}
1
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    return new InitialLdapContext(env, null);}
0
private void validateAuthenticationInfo(Hashtable<String, Object> environment) throws AuthenticationException
{        if (SIMPLE_AUTHENTICATION_MECHANISM_NAME.equals(environment.get(Context.SECURITY_AUTHENTICATION))) {                if (environment.get(Context.SECURITY_PRINCIPAL) != null && StringUtils.hasText(String.valueOf(environment.get(Context.SECURITY_PRINCIPAL)))) {            Object credentials = environment.get(Context.SECURITY_CREDENTIALS);                        if (credentials == null ||             (credentials instanceof byte[] && ((byte[]) credentials).length <= 0) ||             (credentials instanceof char[] && ((char[]) credentials).length <= 0) || (String.class.isInstance(credentials) && !StringUtils.hasText(String.valueOf(credentials)))) {                throw new javax.naming.AuthenticationException("LDAP Simple authentication requires both a " + "principal and credentials.");            }        }    }}
0
protected String getUserDnPrefix()
{    return userDnPrefix;}
0
protected String getUserDnSuffix()
{    return userDnSuffix;}
0
public void setUserDnTemplate(String template) throws IllegalArgumentException
{    if (!StringUtils.hasText(template)) {        String msg = "User DN template cannot be null or empty.";        throw new IllegalArgumentException(msg);    }    int index = template.indexOf(USERDN_SUBSTITUTION_TOKEN);    if (index < 0) {        String msg = "User DN template must contain the '" + USERDN_SUBSTITUTION_TOKEN + "' replacement token to understand where to " + "insert the runtime authentication principal.";        throw new IllegalArgumentException(msg);    }    String prefix = template.substring(0, index);    String suffix = template.substring(prefix.length() + USERDN_SUBSTITUTION_TOKEN.length());    if (log.isDebugEnabled()) {            }    this.userDnPrefix = prefix;    this.userDnSuffix = suffix;}
1
public String getUserDnTemplate()
{    return getUserDn(USERDN_SUBSTITUTION_TOKEN);}
0
protected String getUserDn(String principal) throws IllegalArgumentException, IllegalStateException
{    if (!StringUtils.hasText(principal)) {        throw new IllegalArgumentException("User principal cannot be null or empty for User DN construction.");    }    String prefix = getUserDnPrefix();    String suffix = getUserDnSuffix();    if (prefix == null && suffix == null) {                return principal;    }    int prefixLength = prefix != null ? prefix.length() : 0;    int suffixLength = suffix != null ? suffix.length() : 0;    StringBuilder sb = new StringBuilder(prefixLength + principal.length() + suffixLength);    if (prefixLength > 0) {        sb.append(prefix);    }    sb.append(principal);    if (suffixLength > 0) {        sb.append(suffix);    }    return sb.toString();}
1
public void setContextFactory(LdapContextFactory contextFactory)
{    this.contextFactory = contextFactory;}
0
public LdapContextFactory getContextFactory()
{    return this.contextFactory;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    AuthenticationInfo info;    try {        info = queryForAuthenticationInfo(token, getContextFactory());    } catch (AuthenticationNotSupportedException e) {        String msg = "Unsupported configured authentication mechanism";        throw new UnsupportedAuthenticationMechanismException(msg, e);    } catch (javax.naming.AuthenticationException e) {        throw new AuthenticationException("LDAP authentication failed.", e);    } catch (NamingException e) {        String msg = "LDAP naming error while attempting to authenticate user.";        throw new AuthenticationException(msg, e);    }    return info;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    AuthorizationInfo info;    try {        info = queryForAuthorizationInfo(principals, getContextFactory());    } catch (NamingException e) {        String msg = "LDAP naming error while attempting to retrieve authorization for user [" + principals + "].";        throw new AuthorizationException(msg, e);    }    return info;}
0
protected Object getLdapPrincipal(AuthenticationToken token)
{    Object principal = token.getPrincipal();    if (principal instanceof String) {        String sPrincipal = (String) principal;        return getUserDn(sPrincipal);    }    return principal;}
0
protected AuthenticationInfo queryForAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException
{    Object principal = token.getPrincipal();    Object credentials = token.getCredentials();        principal = getLdapPrincipal(token);    LdapContext ctx = null;    try {        ctx = ldapContextFactory.getLdapContext(principal, credentials);                return createAuthenticationInfo(token, principal, credentials, ctx);    } finally {        LdapUtils.closeContext(ctx);    }}
1
protected AuthenticationInfo createAuthenticationInfo(AuthenticationToken token, Object ldapPrincipal, Object ldapCredentials, LdapContext ldapContext) throws NamingException
{    return new SimpleAuthenticationInfo(token.getPrincipal(), token.getCredentials(), getName());}
0
protected AuthorizationInfo queryForAuthorizationInfo(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException
{    return null;}
0
public void setAuthenticationMechanism(String authenticationMechanism)
{    setEnvironmentProperty(Context.SECURITY_AUTHENTICATION, authenticationMechanism);}
0
public String getAuthenticationMechanism()
{    return (String) getEnvironmentProperty(Context.SECURITY_AUTHENTICATION);}
0
public void setContextFactoryClassName(String contextFactoryClassName)
{    setEnvironmentProperty(Context.INITIAL_CONTEXT_FACTORY, contextFactoryClassName);}
0
public String getContextFactoryClassName()
{    return (String) getEnvironmentProperty(Context.INITIAL_CONTEXT_FACTORY);}
0
public Map getEnvironment()
{    return this.environment;}
0
public void setEnvironment(Map env)
{    this.environment = env;}
0
private Object getEnvironmentProperty(String name)
{    return this.environment.get(name);}
0
private void setEnvironmentProperty(String name, String value)
{    if (StringUtils.hasText(value)) {        this.environment.put(name, value);    } else {        this.environment.remove(name);    }}
0
public boolean isPoolingEnabled()
{    return poolingEnabled;}
0
public void setPoolingEnabled(boolean poolingEnabled)
{    this.poolingEnabled = poolingEnabled;}
0
public void setReferral(String referral)
{    setEnvironmentProperty(Context.REFERRAL, referral);}
0
public String getReferral()
{    return (String) getEnvironmentProperty(Context.REFERRAL);}
0
public void setUrl(String url)
{    setEnvironmentProperty(Context.PROVIDER_URL, url);}
0
public String getUrl()
{    return (String) getEnvironmentProperty(Context.PROVIDER_URL);}
0
public void setSystemPassword(String systemPassword)
{    this.systemPassword = systemPassword;}
0
public String getSystemPassword()
{    return this.systemPassword;}
0
public void setSystemUsername(String systemUsername)
{    this.systemUsername = systemUsername;}
0
public String getSystemUsername()
{    return systemUsername;}
0
public LdapContext getSystemLdapContext() throws NamingException
{    return getLdapContext((Object) getSystemUsername(), getSystemPassword());}
0
public LdapContext getLdapContext(String username, String password) throws NamingException
{    return getLdapContext((Object) username, password);}
0
protected boolean isPoolingConnections(Object principal)
{    return isPoolingEnabled() && principal != null && principal.equals(getSystemUsername());}
0
public LdapContext getLdapContext(Object principal, Object credentials) throws NamingException, IllegalStateException
{    String url = getUrl();    if (url == null) {        throw new IllegalStateException("An LDAP URL must be specified of the form ldap://<hostname>:<port>");    }            Hashtable<String, Object> env = new Hashtable<String, Object>(this.environment);    Object authcMech = getAuthenticationMechanism();    if (authcMech == null && (principal != null || credentials != null)) {                                                env.put(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION_MECHANISM_NAME);    }    if (principal != null) {        env.put(Context.SECURITY_PRINCIPAL, principal);    }    if (credentials != null) {        env.put(Context.SECURITY_CREDENTIALS, credentials);    }    boolean pooling = isPoolingConnections(principal);    if (pooling) {        env.put(SUN_CONNECTION_POOLING_PROPERTY, "true");    }    if (log.isDebugEnabled()) {            }        validateAuthenticationInfo(env);    return createLdapContext(env);}
1
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    return new InitialLdapContext(env, null);}
0
protected void validateAuthenticationInfo(Hashtable<String, Object> environment) throws AuthenticationException
{        if (SIMPLE_AUTHENTICATION_MECHANISM_NAME.equals(environment.get(Context.SECURITY_AUTHENTICATION))) {                if (environment.get(Context.SECURITY_PRINCIPAL) != null && StringUtils.hasText(String.valueOf(environment.get(Context.SECURITY_PRINCIPAL)))) {            Object credentials = environment.get(Context.SECURITY_CREDENTIALS);                        if (credentials == null ||             (credentials instanceof byte[] && ((byte[]) credentials).length <= 0) ||             (credentials instanceof char[] && ((char[]) credentials).length <= 0) || (String.class.isInstance(credentials) && !StringUtils.hasText(String.valueOf(credentials)))) {                throw new javax.naming.AuthenticationException("LDAP Simple authentication requires both a " + "principal and credentials.");            }        }    }}
0
public static void closeContext(LdapContext ctx)
{    try {        if (ctx != null) {            ctx.close();        }    } catch (NamingException e) {            }}
1
public static Collection<String> getAllAttributeValues(Attribute attr) throws NamingException
{    Set<String> values = new HashSet<String>();    NamingEnumeration ne = null;    try {        ne = attr.getAll();        while (ne.hasMore()) {            String value = (String) ne.next();            values.add(value);        }    } finally {        closeEnumeration(ne);    }    return values;}
0
public static void closeEnumeration(NamingEnumeration ne)
{    try {        if (ne != null) {            ne.close();        }    } catch (NamingException e) {            }}
1
protected SimpleAccount getUser(String username)
{    USERS_LOCK.readLock().lock();    try {        return this.users.get(username);    } finally {        USERS_LOCK.readLock().unlock();    }}
0
public boolean accountExists(String username)
{    return getUser(username) != null;}
0
public void addAccount(String username, String password)
{    addAccount(username, password, (String[]) null);}
0
public void addAccount(String username, String password, String... roles)
{    Set<String> roleNames = CollectionUtils.asSet(roles);    SimpleAccount account = new SimpleAccount(username, password, getName(), roleNames, null);    add(account);}
0
protected String getUsername(SimpleAccount account)
{    return getUsername(account.getPrincipals());}
0
protected String getUsername(PrincipalCollection principals)
{    return getAvailablePrincipal(principals).toString();}
0
protected void add(SimpleAccount account)
{    String username = getUsername(account);    USERS_LOCK.writeLock().lock();    try {        this.users.put(username, account);    } finally {        USERS_LOCK.writeLock().unlock();    }}
0
protected SimpleRole getRole(String rolename)
{    ROLES_LOCK.readLock().lock();    try {        return roles.get(rolename);    } finally {        ROLES_LOCK.readLock().unlock();    }}
0
public boolean roleExists(String name)
{    return getRole(name) != null;}
0
public void addRole(String name)
{    add(new SimpleRole(name));}
0
protected void add(SimpleRole role)
{    ROLES_LOCK.writeLock().lock();    try {        roles.put(role.getName(), role);    } finally {        ROLES_LOCK.writeLock().unlock();    }}
0
protected static Set<String> toSet(String delimited, String delimiter)
{    if (delimited == null || delimited.trim().equals("")) {        return null;    }    Set<String> values = new HashSet<String>();    String[] rolenamesArray = delimited.split(delimiter);    for (String s : rolenamesArray) {        String trimmed = s.trim();        if (trimmed.length() > 0) {            values.add(trimmed);        }    }    return values;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    UsernamePasswordToken upToken = (UsernamePasswordToken) token;    SimpleAccount account = getUser(upToken.getUsername());    if (account != null) {        if (account.isLocked()) {            throw new LockedAccountException("Account [" + account + "] is locked.");        }        if (account.isCredentialsExpired()) {            String msg = "The credentials for account [" + account + "] are expired";            throw new ExpiredCredentialsException(msg);        }    }    return account;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    String username = getUsername(principals);    USERS_LOCK.readLock().lock();    try {        return this.users.get(username);    } finally {        USERS_LOCK.readLock().unlock();    }}
0
public String getResourcePath()
{    return resourcePath;}
0
public void setResourcePath(String resourcePath)
{    this.resourcePath = resourcePath;}
0
public Ini getIni()
{    return ini;}
0
public void setIni(Ini ini)
{    this.ini = ini;}
0
protected void onInit()
{    super.onInit();            Ini ini = getIni();    String resourcePath = getResourcePath();    if (!CollectionUtils.isEmpty(this.users) || !CollectionUtils.isEmpty(this.roles)) {        if (!CollectionUtils.isEmpty(ini)) {                    }        if (StringUtils.hasText(resourcePath)) {                    }                return;    }    if (CollectionUtils.isEmpty(ini)) {                if (StringUtils.hasText(resourcePath)) {                        ini = Ini.fromResourcePath(resourcePath);            if (!CollectionUtils.isEmpty(ini)) {                setIni(ini);            }        }    }    if (CollectionUtils.isEmpty(ini)) {        String msg = "Ini instance and/or resourcePath resulted in null or empty Ini configuration.  Cannot " + "load account data.";        throw new IllegalStateException(msg);    }    processDefinitions(ini);}
1
private void processDefinitions(Ini ini)
{    if (CollectionUtils.isEmpty(ini)) {                return;    }    Ini.Section rolesSection = ini.getSection(ROLES_SECTION_NAME);    if (!CollectionUtils.isEmpty(rolesSection)) {                processRoleDefinitions(rolesSection);    }    Ini.Section usersSection = ini.getSection(USERS_SECTION_NAME);    if (!CollectionUtils.isEmpty(usersSection)) {                processUserDefinitions(usersSection);    } else {            }}
1
public void setUseXmlFormat(boolean useXmlFormat)
{    this.useXmlFormat = useXmlFormat;}
0
public void setResourcePath(String resourcePath)
{    this.resourcePath = resourcePath;}
0
public void setReloadIntervalSeconds(int reloadIntervalSeconds)
{    this.reloadIntervalSeconds = reloadIntervalSeconds;}
0
public void onInit()
{    super.onInit();        afterRoleCacheSet();}
0
protected void afterRoleCacheSet()
{    loadProperties();        if (this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && scheduler == null) {        startReloadThread();    }}
0
public void destroy()
{    try {        if (scheduler != null) {            scheduler.shutdown();        }    } catch (Exception e) {        if (log.isInfoEnabled()) {                    }    } finally {        scheduler = null;    }}
1
protected void startReloadThread()
{    if (this.reloadIntervalSeconds > 0) {        this.scheduler = Executors.newSingleThreadScheduledExecutor();        ((ScheduledExecutorService) this.scheduler).scheduleAtFixedRate(this, reloadIntervalSeconds, reloadIntervalSeconds, TimeUnit.SECONDS);    }}
0
public void run()
{    try {        reloadPropertiesIfNecessary();    } catch (Exception e) {        if (log.isErrorEnabled()) {                    }    }}
1
private void loadProperties()
{    if (resourcePath == null || resourcePath.length() == 0) {        throw new IllegalStateException("The resourcePath property is not set.  " + "It must be set prior to this realm being initialized.");    }    if (log.isDebugEnabled()) {            }    Properties properties = loadProperties(resourcePath);    createRealmEntitiesFromProperties(properties);}
1
private Properties loadProperties(String resourcePath)
{    Properties props = new Properties();    InputStream is = null;    try {        if (log.isDebugEnabled()) {                    }        is = ResourceUtils.getInputStreamForPath(resourcePath);        if (useXmlFormat) {            if (log.isDebugEnabled()) {                            }            props.loadFromXML(is);        } else {            if (log.isDebugEnabled()) {                            }            props.load(is);        }    } catch (IOException e) {        throw new ShiroException("Error reading properties path [" + resourcePath + "].  " + "Initializing of the realm from this file failed.", e);    } finally {        ResourceUtils.close(is);    }    return props;}
1
private void reloadPropertiesIfNecessary()
{    if (isSourceModified()) {        restart();    }}
0
private boolean isSourceModified()
{        return this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && isFileModified();}
0
private boolean isFileModified()
{        String fileNameWithoutPrefix = this.resourcePath.substring(this.resourcePath.indexOf(":") + 1);    File propertyFile = new File(fileNameWithoutPrefix);    long currentLastModified = propertyFile.lastModified();    if (currentLastModified > this.fileLastModified) {        this.fileLastModified = currentLastModified;        return true;    } else {        return false;    }}
0
private void restart()
{    if (resourcePath == null || resourcePath.length() == 0) {        throw new IllegalStateException("The resourcePath property is not set.  " + "It must be set prior to this realm being initialized.");    }    if (log.isDebugEnabled()) {            }    try {        destroy();    } catch (Exception e) {        }    init();}
1
private void createRealmEntitiesFromProperties(Properties properties)
{    StringBuilder userDefs = new StringBuilder();    StringBuilder roleDefs = new StringBuilder();    Enumeration<String> propNames = (Enumeration<String>) properties.propertyNames();    while (propNames.hasMoreElements()) {        String key = propNames.nextElement().trim();        String value = properties.getProperty(key).trim();        if (log.isTraceEnabled()) {            log.trace("Processing properties line - key: [" + key + "], value: [" + value + "].");        }        if (isUsername(key)) {            String username = getUsername(key);            userDefs.append(username).append(" = ").append(value).append("\n");        } else if (isRolename(key)) {            String rolename = getRolename(key);            roleDefs.append(rolename).append(" = ").append(value).append("\n");        } else {            String msg = "Encountered unexpected key/value pair.  All keys must be prefixed with either '" + USERNAME_PREFIX + "' or '" + ROLENAME_PREFIX + "'.";            throw new IllegalStateException(msg);        }    }    setUserDefinitions(userDefs.toString());    setRoleDefinitions(roleDefs.toString());    processDefinitions();}
0
protected String getName(String key, String prefix)
{    return key.substring(prefix.length(), key.length());}
0
protected boolean isUsername(String key)
{    return key != null && key.startsWith(USERNAME_PREFIX);}
0
protected boolean isRolename(String key)
{    return key != null && key.startsWith(ROLENAME_PREFIX);}
0
protected String getUsername(String key)
{    return getName(key, USERNAME_PREFIX);}
0
protected String getRolename(String key)
{    return getName(key, ROLENAME_PREFIX);}
0
protected void onInit()
{    super.onInit();    processDefinitions();}
0
public String getUserDefinitions()
{    return userDefinitions;}
0
public void setUserDefinitions(String userDefinitions)
{    this.userDefinitions = userDefinitions;}
0
public String getRoleDefinitions()
{    return roleDefinitions;}
0
public void setRoleDefinitions(String roleDefinitions)
{    this.roleDefinitions = roleDefinitions;}
0
protected void processDefinitions()
{    try {        processRoleDefinitions();        processUserDefinitions();    } catch (ParseException e) {        String msg = "Unable to parse user and/or role definitions.";        throw new ConfigurationException(msg, e);    }}
0
protected void processRoleDefinitions() throws ParseException
{    String roleDefinitions = getRoleDefinitions();    if (roleDefinitions == null) {        return;    }    Map<String, String> roleDefs = toMap(toLines(roleDefinitions));    processRoleDefinitions(roleDefs);}
0
protected void processRoleDefinitions(Map<String, String> roleDefs)
{    if (roleDefs == null || roleDefs.isEmpty()) {        return;    }    for (String rolename : roleDefs.keySet()) {        String value = roleDefs.get(rolename);        SimpleRole role = getRole(rolename);        if (role == null) {            role = new SimpleRole(rolename);            add(role);        }        Set<Permission> permissions = PermissionUtils.resolveDelimitedPermissions(value, getPermissionResolver());        role.setPermissions(permissions);    }}
0
protected void processUserDefinitions() throws ParseException
{    String userDefinitions = getUserDefinitions();    if (userDefinitions == null) {        return;    }    Map<String, String> userDefs = toMap(toLines(userDefinitions));    processUserDefinitions(userDefs);}
0
protected void processUserDefinitions(Map<String, String> userDefs)
{    if (userDefs == null || userDefs.isEmpty()) {        return;    }    for (String username : userDefs.keySet()) {        String value = userDefs.get(username);        String[] passwordAndRolesArray = StringUtils.split(value);        String password = passwordAndRolesArray[0];        SimpleAccount account = getUser(username);        if (account == null) {            account = new SimpleAccount(username, password, getName());            add(account);        }        account.setCredentials(password);        if (passwordAndRolesArray.length > 1) {            for (int i = 1; i < passwordAndRolesArray.length; i++) {                String rolename = passwordAndRolesArray[i];                account.addRole(rolename);                SimpleRole role = getRole(rolename);                if (role != null) {                    account.addObjectPermissions(role.getPermissions());                }            }        } else {            account.setRoles(null);        }    }}
0
protected static Set<String> toLines(String s)
{    LinkedHashSet<String> set = new LinkedHashSet<String>();    Scanner scanner = new Scanner(s);    while (scanner.hasNextLine()) {        set.add(scanner.nextLine());    }    return set;}
0
protected static Map<String, String> toMap(Collection<String> keyValuePairs) throws ParseException
{    if (keyValuePairs == null || keyValuePairs.isEmpty()) {        return null;    }    Map<String, String> pairs = new HashMap<String, String>();    for (String pairString : keyValuePairs) {        String[] pair = StringUtils.splitKeyValue(pairString);        if (pair != null) {            pairs.put(pair[0].trim(), pair[1].trim());        }    }    return pairs;}
0
public static Subject getSubject()
{    Subject subject = ThreadContext.getSubject();    if (subject == null) {        subject = (new Subject.Builder()).buildSubject();        ThreadContext.bind(subject);    }    return subject;}
0
public static void setSecurityManager(SecurityManager securityManager)
{    SecurityUtils.securityManager = securityManager;}
0
public static SecurityManager getSecurityManager() throws UnavailableSecurityManagerException
{    SecurityManager securityManager = ThreadContext.getSecurityManager();    if (securityManager == null) {        securityManager = SecurityUtils.securityManager;    }    if (securityManager == null) {        String msg = "No SecurityManager accessible to the calling code, either bound to the " + ThreadContext.class.getName() + " or as a vm static singleton.  This is an invalid application " + "configuration.";        throw new UnavailableSecurityManagerException(msg);    }    return securityManager;}
0
public void setSessionListeners(Collection<SessionListener> listeners)
{    this.listeners = listeners != null ? listeners : new ArrayList<SessionListener>();}
0
public Collection<SessionListener> getSessionListeners()
{    return this.listeners;}
0
protected EventBus getEventBus()
{    return eventBus;}
0
public void setEventBus(EventBus eventBus)
{    this.eventBus = eventBus;}
0
protected void publishEvent(Object event)
{    if (this.eventBus != null) {        this.eventBus.publish(event);    }}
0
public Session start(SessionContext context)
{    Session session = createSession(context);    applyGlobalSessionTimeout(session);    onStart(session, context);    notifyStart(session);        return createExposedSession(session, context);}
0
protected void applyGlobalSessionTimeout(Session session)
{    session.setTimeout(getGlobalSessionTimeout());    onChange(session);}
0
protected void onStart(Session session, SessionContext context)
{}
0
public Session getSession(SessionKey key) throws SessionException
{    Session session = lookupSession(key);    return session != null ? createExposedSession(session, key) : null;}
0
private Session lookupSession(SessionKey key) throws SessionException
{    if (key == null) {        throw new NullPointerException("SessionKey argument cannot be null.");    }    return doGetSession(key);}
0
private Session lookupRequiredSession(SessionKey key) throws SessionException
{    Session session = lookupSession(key);    if (session == null) {        String msg = "Unable to locate required Session instance based on SessionKey [" + key + "].";        throw new UnknownSessionException(msg);    }    return session;}
0
protected Session createExposedSession(Session session, SessionContext context)
{    return new DelegatingSession(this, new DefaultSessionKey(session.getId()));}
0
protected Session createExposedSession(Session session, SessionKey key)
{    return new DelegatingSession(this, new DefaultSessionKey(session.getId()));}
0
protected Session beforeInvalidNotification(Session session)
{    return new ImmutableProxiedSession(session);}
0
protected void notifyStart(Session session)
{    for (SessionListener listener : this.listeners) {        listener.onStart(session);    }}
0
protected void notifyStop(Session session)
{    Session forNotification = beforeInvalidNotification(session);    for (SessionListener listener : this.listeners) {        listener.onStop(forNotification);    }}
0
protected void notifyExpiration(Session session)
{    Session forNotification = beforeInvalidNotification(session);    for (SessionListener listener : this.listeners) {        listener.onExpiration(forNotification);    }}
0
public Date getStartTimestamp(SessionKey key)
{    return lookupRequiredSession(key).getStartTimestamp();}
0
public Date getLastAccessTime(SessionKey key)
{    return lookupRequiredSession(key).getLastAccessTime();}
0
public long getTimeout(SessionKey key) throws InvalidSessionException
{    return lookupRequiredSession(key).getTimeout();}
0
public void setTimeout(SessionKey key, long maxIdleTimeInMillis) throws InvalidSessionException
{    Session s = lookupRequiredSession(key);    s.setTimeout(maxIdleTimeInMillis);    onChange(s);}
0
public void touch(SessionKey key) throws InvalidSessionException
{    Session s = lookupRequiredSession(key);    s.touch();    onChange(s);}
0
public String getHost(SessionKey key)
{    return lookupRequiredSession(key).getHost();}
0
public Collection<Object> getAttributeKeys(SessionKey key)
{    Collection<Object> c = lookupRequiredSession(key).getAttributeKeys();    if (!CollectionUtils.isEmpty(c)) {        return Collections.unmodifiableCollection(c);    }    return Collections.emptySet();}
0
public Object getAttribute(SessionKey sessionKey, Object attributeKey) throws InvalidSessionException
{    return lookupRequiredSession(sessionKey).getAttribute(attributeKey);}
0
public void setAttribute(SessionKey sessionKey, Object attributeKey, Object value) throws InvalidSessionException
{    if (value == null) {        removeAttribute(sessionKey, attributeKey);    } else {        Session s = lookupRequiredSession(sessionKey);        s.setAttribute(attributeKey, value);        onChange(s);    }}
0
public Object removeAttribute(SessionKey sessionKey, Object attributeKey) throws InvalidSessionException
{    Session s = lookupRequiredSession(sessionKey);    Object removed = s.removeAttribute(attributeKey);    if (removed != null) {        onChange(s);    }    return removed;}
0
public boolean isValid(SessionKey key)
{    try {        checkValid(key);        return true;    } catch (InvalidSessionException e) {        return false;    }}
0
public void stop(SessionKey key) throws InvalidSessionException
{    Session session = lookupRequiredSession(key);    try {        if (log.isDebugEnabled()) {                    }        session.stop();        onStop(session, key);        notifyStop(session);    } finally {        afterStopped(session);    }}
1
protected void onStop(Session session, SessionKey key)
{    onStop(session);}
0
protected void onStop(Session session)
{    onChange(session);}
0
protected void afterStopped(Session session)
{}
0
public void checkValid(SessionKey key) throws InvalidSessionException
{        lookupRequiredSession(key);}
0
protected void onChange(Session s)
{}
0
public long getGlobalSessionTimeout()
{    return this.globalSessionTimeout;}
0
public void setGlobalSessionTimeout(long globalSessionTimeout)
{    this.globalSessionTimeout = globalSessionTimeout;}
0
public boolean isSessionValidationSchedulerEnabled()
{    return sessionValidationSchedulerEnabled;}
0
public void setSessionValidationSchedulerEnabled(boolean sessionValidationSchedulerEnabled)
{    this.sessionValidationSchedulerEnabled = sessionValidationSchedulerEnabled;}
0
public void setSessionValidationScheduler(SessionValidationScheduler sessionValidationScheduler)
{    this.sessionValidationScheduler = sessionValidationScheduler;}
0
public SessionValidationScheduler getSessionValidationScheduler()
{    return sessionValidationScheduler;}
0
private void enableSessionValidationIfNecessary()
{    SessionValidationScheduler scheduler = getSessionValidationScheduler();    if (isSessionValidationSchedulerEnabled() && (scheduler == null || !scheduler.isEnabled())) {        enableSessionValidation();    }}
0
public void setSessionValidationInterval(long sessionValidationInterval)
{    this.sessionValidationInterval = sessionValidationInterval;}
0
public long getSessionValidationInterval()
{    return sessionValidationInterval;}
0
protected final Session doGetSession(final SessionKey key) throws InvalidSessionException
{    enableSessionValidationIfNecessary();    log.trace("Attempting to retrieve session with key {}", key);    Session s = retrieveSession(key);    if (s != null) {        validate(s, key);    }    return s;}
0
protected Session createSession(SessionContext context) throws AuthorizationException
{    enableSessionValidationIfNecessary();    return doCreateSession(context);}
0
protected void validate(Session session, SessionKey key) throws InvalidSessionException
{    try {        doValidate(session);    } catch (ExpiredSessionException ese) {        onExpiration(session, ese, key);        throw ese;    } catch (InvalidSessionException ise) {        onInvalidation(session, ise, key);        throw ise;    }}
0
protected void onExpiration(Session s, ExpiredSessionException ese, SessionKey key)
{    log.trace("Session with id [{}] has expired.", s.getId());    try {        onExpiration(s);        notifyExpiration(s);    } finally {        afterExpired(s);    }}
0
protected void onExpiration(Session session)
{    onChange(session);}
0
protected void afterExpired(Session session)
{}
0
protected void onInvalidation(Session s, InvalidSessionException ise, SessionKey key)
{    if (ise instanceof ExpiredSessionException) {        onExpiration(s, (ExpiredSessionException) ise, key);        return;    }    log.trace("Session with id [{}] is invalid.", s.getId());    try {        onStop(s);        notifyStop(s);    } finally {        afterStopped(s);    }}
0
protected void doValidate(Session session) throws InvalidSessionException
{    if (session instanceof ValidatingSession) {        ((ValidatingSession) session).validate();    } else {        String msg = "The " + getClass().getName() + " implementation only supports validating " + "Session implementations of the " + ValidatingSession.class.getName() + " interface.  " + "Please either implement this interface in your session implementation or override the " + AbstractValidatingSessionManager.class.getName() + ".doValidate(Session) method to perform validation.";        throw new IllegalStateException(msg);    }}
0
protected long getTimeout(Session session)
{    return session.getTimeout();}
0
protected SessionValidationScheduler createSessionValidationScheduler()
{    ExecutorServiceSessionValidationScheduler scheduler;    if (log.isDebugEnabled()) {            }    scheduler = new ExecutorServiceSessionValidationScheduler(this);    scheduler.setInterval(getSessionValidationInterval());    if (log.isTraceEnabled()) {        log.trace("Created default SessionValidationScheduler instance of type [" + scheduler.getClass().getName() + "].");    }    return scheduler;}
1
protected synchronized void enableSessionValidation()
{    SessionValidationScheduler scheduler = getSessionValidationScheduler();    if (scheduler == null) {        scheduler = createSessionValidationScheduler();        setSessionValidationScheduler(scheduler);    }        if (!scheduler.isEnabled()) {        if (log.isInfoEnabled()) {                    }        scheduler.enableSessionValidation();        afterSessionValidationEnabled();    }}
1
protected void afterSessionValidationEnabled()
{}
0
protected synchronized void disableSessionValidation()
{    beforeSessionValidationDisabled();    SessionValidationScheduler scheduler = getSessionValidationScheduler();    if (scheduler != null) {        try {            scheduler.disableSessionValidation();            if (log.isInfoEnabled()) {                            }        } catch (Exception e) {            if (log.isDebugEnabled()) {                String msg = "Unable to disable SessionValidationScheduler.  Ignoring (shutting down)...";                            }        }        LifecycleUtils.destroy(scheduler);        setSessionValidationScheduler(null);    }}
1
protected void beforeSessionValidationDisabled()
{}
0
public void destroy()
{    disableSessionValidation();}
0
public void validateSessions()
{    if (log.isInfoEnabled()) {            }    int invalidCount = 0;    Collection<Session> activeSessions = getActiveSessions();    if (activeSessions != null && !activeSessions.isEmpty()) {        for (Session s : activeSessions) {            try {                                                SessionKey key = new DefaultSessionKey(s.getId());                validate(s, key);            } catch (InvalidSessionException e) {                if (log.isDebugEnabled()) {                    boolean expired = (e instanceof ExpiredSessionException);                    String msg = "Invalidated session with id [" + s.getId() + "]" + (expired ? " (expired)" : " (stopped)");                                    }                invalidCount++;            }        }    }    if (log.isInfoEnabled()) {        String msg = "Finished session validation.";        if (invalidCount > 0) {            msg += "  [" + invalidCount + "] sessions were stopped.";        } else {            msg += "  No sessions were stopped.";        }            }}
1
public String getHost()
{    return getTypedValue(HOST, String.class);}
0
public void setHost(String host)
{    if (StringUtils.hasText(host)) {        put(HOST, host);    }}
0
public Serializable getSessionId()
{    return getTypedValue(SESSION_ID, Serializable.class);}
0
public void setSessionId(Serializable sessionId)
{    nullSafePut(SESSION_ID, sessionId);}
0
public void setSessionId(Serializable sessionId)
{    this.sessionId = sessionId;}
0
public Serializable getSessionId()
{    return this.sessionId;}
0
public void setSessionDAO(SessionDAO sessionDAO)
{    this.sessionDAO = sessionDAO;    applyCacheManagerToSessionDAO();}
0
public SessionDAO getSessionDAO()
{    return this.sessionDAO;}
0
public SessionFactory getSessionFactory()
{    return sessionFactory;}
0
public void setSessionFactory(SessionFactory sessionFactory)
{    this.sessionFactory = sessionFactory;}
0
public boolean isDeleteInvalidSessions()
{    return deleteInvalidSessions;}
0
public void setDeleteInvalidSessions(boolean deleteInvalidSessions)
{    this.deleteInvalidSessions = deleteInvalidSessions;}
0
public void setCacheManager(CacheManager cacheManager)
{    this.cacheManager = cacheManager;    applyCacheManagerToSessionDAO();}
0
private void applyCacheManagerToSessionDAO()
{    if (this.cacheManager != null && this.sessionDAO != null && this.sessionDAO instanceof CacheManagerAware) {        ((CacheManagerAware) this.sessionDAO).setCacheManager(this.cacheManager);    }}
0
protected Session doCreateSession(SessionContext context)
{    Session s = newSessionInstance(context);    if (log.isTraceEnabled()) {        log.trace("Creating session for host {}", s.getHost());    }    create(s);    return s;}
0
protected Session newSessionInstance(SessionContext context)
{    return getSessionFactory().createSession(context);}
0
protected void create(Session session)
{    if (log.isDebugEnabled()) {            }    sessionDAO.create(session);}
1
protected void onStop(Session session)
{    if (session instanceof SimpleSession) {        SimpleSession ss = (SimpleSession) session;        Date stopTs = ss.getStopTimestamp();        ss.setLastAccessTime(stopTs);    }    onChange(session);}
0
protected void afterStopped(Session session)
{    if (isDeleteInvalidSessions()) {        delete(session);    }}
0
protected void onExpiration(Session session)
{    if (session instanceof SimpleSession) {        ((SimpleSession) session).setExpired(true);    }    onChange(session);}
0
protected void afterExpired(Session session)
{    if (isDeleteInvalidSessions()) {        delete(session);    }}
0
protected void onChange(Session session)
{    sessionDAO.update(session);}
0
protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException
{    Serializable sessionId = getSessionId(sessionKey);    if (sessionId == null) {                return null;    }    Session s = retrieveSessionFromDataSource(sessionId);    if (s == null) {                String msg = "Could not find session with ID [" + sessionId + "]";        throw new UnknownSessionException(msg);    }    return s;}
1
protected Serializable getSessionId(SessionKey sessionKey)
{    return sessionKey.getSessionId();}
0
protected Session retrieveSessionFromDataSource(Serializable sessionId) throws UnknownSessionException
{    return sessionDAO.readSession(sessionId);}
0
protected void delete(Session session)
{    sessionDAO.delete(session);}
0
protected Collection<Session> getActiveSessions()
{    Collection<Session> active = sessionDAO.getActiveSessions();    return active != null ? active : Collections.<Session>emptySet();}
0
public Serializable getId()
{    return key.getSessionId();}
0
public Date getStartTimestamp()
{    if (startTimestamp == null) {        startTimestamp = sessionManager.getStartTimestamp(key);    }    return startTimestamp;}
0
public Date getLastAccessTime()
{        return sessionManager.getLastAccessTime(key);}
0
public long getTimeout() throws InvalidSessionException
{    return sessionManager.getTimeout(key);}
0
public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException
{    sessionManager.setTimeout(key, maxIdleTimeInMillis);}
0
public String getHost()
{    if (host == null) {        host = sessionManager.getHost(key);    }    return host;}
0
public void touch() throws InvalidSessionException
{    sessionManager.touch(key);}
0
public void stop() throws InvalidSessionException
{    sessionManager.stop(key);}
0
public Collection<Object> getAttributeKeys() throws InvalidSessionException
{    return sessionManager.getAttributeKeys(key);}
0
public Object getAttribute(Object attributeKey) throws InvalidSessionException
{    return sessionManager.getAttribute(this.key, attributeKey);}
0
public void setAttribute(Object attributeKey, Object value) throws InvalidSessionException
{    if (value == null) {        removeAttribute(attributeKey);    } else {        sessionManager.setAttribute(this.key, attributeKey, value);    }}
0
public Object removeAttribute(Object attributeKey) throws InvalidSessionException
{    return sessionManager.removeAttribute(this.key, attributeKey);}
0
public SessionIdGenerator getSessionIdGenerator()
{    return sessionIdGenerator;}
0
public void setSessionIdGenerator(SessionIdGenerator sessionIdGenerator)
{    this.sessionIdGenerator = sessionIdGenerator;}
0
protected Serializable generateSessionId(Session session)
{    if (this.sessionIdGenerator == null) {        String msg = "sessionIdGenerator attribute has not been configured.";        throw new IllegalStateException(msg);    }    return this.sessionIdGenerator.generateId(session);}
0
public Serializable create(Session session)
{    Serializable sessionId = doCreate(session);    verifySessionId(sessionId);    return sessionId;}
0
private void verifySessionId(Serializable sessionId)
{    if (sessionId == null) {        String msg = "sessionId returned from doCreate implementation is null.  Please verify the implementation.";        throw new IllegalStateException(msg);    }}
0
protected void assignSessionId(Session session, Serializable sessionId)
{    ((SimpleSession) session).setId(sessionId);}
0
public Session readSession(Serializable sessionId) throws UnknownSessionException
{    Session s = doReadSession(sessionId);    if (s == null) {        throw new UnknownSessionException("There is no session with id [" + sessionId + "]");    }    return s;}
0
public void setCacheManager(CacheManager cacheManager)
{    this.cacheManager = cacheManager;}
0
public CacheManager getCacheManager()
{    return cacheManager;}
0
public String getActiveSessionsCacheName()
{    return activeSessionsCacheName;}
0
public void setActiveSessionsCacheName(String activeSessionsCacheName)
{    this.activeSessionsCacheName = activeSessionsCacheName;}
0
public Cache<Serializable, Session> getActiveSessionsCache()
{    return this.activeSessions;}
0
public void setActiveSessionsCache(Cache<Serializable, Session> cache)
{    this.activeSessions = cache;}
0
private Cache<Serializable, Session> getActiveSessionsCacheLazy()
{    if (this.activeSessions == null) {        this.activeSessions = createActiveSessionsCache();    }    return activeSessions;}
0
protected Cache<Serializable, Session> createActiveSessionsCache()
{    Cache<Serializable, Session> cache = null;    CacheManager mgr = getCacheManager();    if (mgr != null) {        String name = getActiveSessionsCacheName();        cache = mgr.getCache(name);    }    return cache;}
0
public Serializable create(Session session)
{    Serializable sessionId = super.create(session);    cache(session, sessionId);    return sessionId;}
0
protected Session getCachedSession(Serializable sessionId)
{    Session cached = null;    if (sessionId != null) {        Cache<Serializable, Session> cache = getActiveSessionsCacheLazy();        if (cache != null) {            cached = getCachedSession(sessionId, cache);        }    }    return cached;}
0
protected Session getCachedSession(Serializable sessionId, Cache<Serializable, Session> cache)
{    return cache.get(sessionId);}
0
protected void cache(Session session, Serializable sessionId)
{    if (session == null || sessionId == null) {        return;    }    Cache<Serializable, Session> cache = getActiveSessionsCacheLazy();    if (cache == null) {        return;    }    cache(session, sessionId, cache);}
0
protected void cache(Session session, Serializable sessionId, Cache<Serializable, Session> cache)
{    cache.put(sessionId, session);}
0
public Session readSession(Serializable sessionId) throws UnknownSessionException
{    Session s = getCachedSession(sessionId);    if (s == null) {        s = super.readSession(sessionId);    }    return s;}
0
public void update(Session session) throws UnknownSessionException
{    doUpdate(session);    if (session instanceof ValidatingSession) {        if (((ValidatingSession) session).isValid()) {            cache(session, session.getId());        } else {            uncache(session);        }    } else {        cache(session, session.getId());    }}
0
public void delete(Session session)
{    uncache(session);    doDelete(session);}
0
protected void uncache(Session session)
{    if (session == null) {        return;    }    Serializable id = session.getId();    if (id == null) {        return;    }    Cache<Serializable, Session> cache = getActiveSessionsCacheLazy();    if (cache != null) {        cache.remove(id);    }}
0
public Collection<Session> getActiveSessions()
{    Cache<Serializable, Session> cache = getActiveSessionsCacheLazy();    if (cache != null) {        return cache.values();    } else {        return Collections.emptySet();    }}
0
protected Cache<Serializable, Session> createCache(String name) throws CacheException
{    return new MapCache<Serializable, Session>(name, new ConcurrentHashMap<Serializable, Session>());}
0
protected Serializable doCreate(Session session)
{    Serializable sessionId = generateSessionId(session);    assignSessionId(session, sessionId);    return sessionId;}
0
protected Session doReadSession(Serializable sessionId)
{        return null;}
0
protected void doUpdate(Session session)
{}
0
protected void doDelete(Session session)
{}
0
public Serializable generateId(Session session)
{    return UUID.randomUUID().toString();}
0
protected Serializable doCreate(Session session)
{    Serializable sessionId = generateSessionId(session);    assignSessionId(session, sessionId);    storeSession(sessionId, session);    return sessionId;}
0
protected Session storeSession(Serializable id, Session session)
{    if (id == null) {        throw new NullPointerException("id argument cannot be null.");    }    return sessions.putIfAbsent(id, session);}
0
protected Session doReadSession(Serializable sessionId)
{    return sessions.get(sessionId);}
0
public void update(Session session) throws UnknownSessionException
{    storeSession(session.getId(), session);}
0
public void delete(Session session)
{    if (session == null) {        throw new NullPointerException("session argument cannot be null.");    }    Serializable id = session.getId();    if (id != null) {        sessions.remove(id);    }}
0
public Collection<Session> getActiveSessions()
{    Collection<Session> values = sessions.values();    if (CollectionUtils.isEmpty(values)) {        return Collections.emptySet();    } else {        return Collections.unmodifiableCollection(values);    }}
0
public Random getRandom()
{    return this.random;}
0
public void setRandom(Random random)
{    this.random = random;}
0
public Serializable generateId(Session session)
{        return Long.toString(getRandom().nextLong());}
0
public ValidatingSessionManager getSessionManager()
{    return sessionManager;}
0
public void setSessionManager(ValidatingSessionManager sessionManager)
{    this.sessionManager = sessionManager;}
0
public long getInterval()
{    return interval;}
0
public void setInterval(long interval)
{    this.interval = interval;}
0
public boolean isEnabled()
{    return this.enabled;}
0
public void setThreadNamePrefix(String threadNamePrefix)
{    this.threadNamePrefix = threadNamePrefix;}
0
public String getThreadNamePrefix()
{    return this.threadNamePrefix;}
0
public void enableSessionValidation()
{    if (this.interval > 0l) {        this.service = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {            private final AtomicInteger count = new AtomicInteger(1);            public Thread newThread(Runnable r) {                Thread thread = new Thread(r);                thread.setDaemon(true);                thread.setName(threadNamePrefix + count.getAndIncrement());                return thread;            }        });        this.service.scheduleAtFixedRate(this, interval, interval, TimeUnit.MILLISECONDS);    }    this.enabled = true;}
0
public Thread newThread(Runnable r)
{    Thread thread = new Thread(r);    thread.setDaemon(true);    thread.setName(threadNamePrefix + count.getAndIncrement());    return thread;}
0
public void run()
{    if (log.isDebugEnabled()) {            }    long startTime = System.currentTimeMillis();    this.sessionManager.validateSessions();    long stopTime = System.currentTimeMillis();    if (log.isDebugEnabled()) {            }}
1
public void disableSessionValidation()
{    if (this.service != null) {        this.service.shutdownNow();    }    this.enabled = false;}
0
protected void throwImmutableException() throws InvalidSessionException
{    String msg = "This session is immutable and read-only - it cannot be altered.  This is usually because " + "the session has been stopped or expired already.";    throw new InvalidSessionException(msg);}
0
public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException
{    throwImmutableException();}
0
public void touch() throws InvalidSessionException
{    throwImmutableException();}
0
public void stop() throws InvalidSessionException
{    throwImmutableException();}
0
public void setAttribute(Object key, Object value) throws InvalidSessionException
{    throwImmutableException();}
0
public Object removeAttribute(Object key) throws InvalidSessionException
{    throwImmutableException();        throw new InternalError("This code should never execute - please report this as a bug!");}
0
public Serializable getId()
{    return this.id;}
0
public void setId(Serializable id)
{    this.id = id;}
0
public Date getStartTimestamp()
{    return startTimestamp;}
0
public void setStartTimestamp(Date startTimestamp)
{    this.startTimestamp = startTimestamp;}
0
public Date getStopTimestamp()
{    return stopTimestamp;}
0
public void setStopTimestamp(Date stopTimestamp)
{    this.stopTimestamp = stopTimestamp;}
0
public Date getLastAccessTime()
{    return lastAccessTime;}
0
public void setLastAccessTime(Date lastAccessTime)
{    this.lastAccessTime = lastAccessTime;}
0
public boolean isExpired()
{    return expired;}
0
public void setExpired(boolean expired)
{    this.expired = expired;}
0
public long getTimeout()
{    return timeout;}
0
public void setTimeout(long timeout)
{    this.timeout = timeout;}
0
public String getHost()
{    return host;}
0
public void setHost(String host)
{    this.host = host;}
0
public Map<Object, Object> getAttributes()
{    return attributes;}
0
public void setAttributes(Map<Object, Object> attributes)
{    this.attributes = attributes;}
0
public void touch()
{    this.lastAccessTime = new Date();}
0
public void stop()
{    if (this.stopTimestamp == null) {        this.stopTimestamp = new Date();    }}
0
protected boolean isStopped()
{    return getStopTimestamp() != null;}
0
protected void expire()
{    stop();    this.expired = true;}
0
public boolean isValid()
{    return !isStopped() && !isExpired();}
0
protected boolean isTimedOut()
{    if (isExpired()) {        return true;    }    long timeout = getTimeout();    if (timeout >= 0l) {        Date lastAccessTime = getLastAccessTime();        if (lastAccessTime == null) {            String msg = "session.lastAccessTime for session with id [" + getId() + "] is null.  This value must be set at " + "least once, preferably at least upon instantiation.  Please check the " + getClass().getName() + " implementation and ensure " + "this value will be set (perhaps in the constructor?)";            throw new IllegalStateException(msg);        }                                                long expireTimeMillis = System.currentTimeMillis() - timeout;        Date expireTime = new Date(expireTimeMillis);        return lastAccessTime.before(expireTime);    } else {        if (log.isTraceEnabled()) {            log.trace("No timeout for session with id [" + getId() + "].  Session is not considered expired.");        }    }    return false;}
0
public void validate() throws InvalidSessionException
{        if (isStopped()) {                String msg = "Session with id [" + getId() + "] has been " + "explicitly stopped.  No further interaction under this session is " + "allowed.";        throw new StoppedSessionException(msg);    }        if (isTimedOut()) {        expire();                Date lastAccessTime = getLastAccessTime();        long timeout = getTimeout();        Serializable sessionId = getId();        DateFormat df = DateFormat.getInstance();        String msg = "Session with id [" + sessionId + "] has expired. " + "Last access time: " + df.format(lastAccessTime) + ".  Current time: " + df.format(new Date()) + ".  Session timeout is set to " + timeout / MILLIS_PER_SECOND + " seconds (" + timeout / MILLIS_PER_MINUTE + " minutes)";        if (log.isTraceEnabled()) {            log.trace(msg);        }        throw new ExpiredSessionException(msg);    }}
0
private Map<Object, Object> getAttributesLazy()
{    Map<Object, Object> attributes = getAttributes();    if (attributes == null) {        attributes = new HashMap<Object, Object>();        setAttributes(attributes);    }    return attributes;}
0
public Collection<Object> getAttributeKeys() throws InvalidSessionException
{    Map<Object, Object> attributes = getAttributes();    if (attributes == null) {        return Collections.emptySet();    }    return attributes.keySet();}
0
public Object getAttribute(Object key)
{    Map<Object, Object> attributes = getAttributes();    if (attributes == null) {        return null;    }    return attributes.get(key);}
0
public void setAttribute(Object key, Object value)
{    if (value == null) {        removeAttribute(key);    } else {        getAttributesLazy().put(key, value);    }}
0
public Object removeAttribute(Object key)
{    Map<Object, Object> attributes = getAttributes();    if (attributes == null) {        return null;    } else {        return attributes.remove(key);    }}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj instanceof SimpleSession) {        SimpleSession other = (SimpleSession) obj;        Serializable thisId = getId();        Serializable otherId = other.getId();        if (thisId != null && otherId != null) {            return thisId.equals(otherId);        } else {                        return onEquals(other);        }    }    return false;}
0
protected boolean onEquals(SimpleSession ss)
{    return (getStartTimestamp() != null ? getStartTimestamp().equals(ss.getStartTimestamp()) : ss.getStartTimestamp() == null) && (getStopTimestamp() != null ? getStopTimestamp().equals(ss.getStopTimestamp()) : ss.getStopTimestamp() == null) && (getLastAccessTime() != null ? getLastAccessTime().equals(ss.getLastAccessTime()) : ss.getLastAccessTime() == null) && (getTimeout() == ss.getTimeout()) && (isExpired() == ss.isExpired()) && (getHost() != null ? getHost().equals(ss.getHost()) : ss.getHost() == null) && (getAttributes() != null ? getAttributes().equals(ss.getAttributes()) : ss.getAttributes() == null);}
0
public int hashCode()
{    Serializable id = getId();    if (id != null) {        return id.hashCode();    }    int hashCode = getStartTimestamp() != null ? getStartTimestamp().hashCode() : 0;    hashCode = 31 * hashCode + (getStopTimestamp() != null ? getStopTimestamp().hashCode() : 0);    hashCode = 31 * hashCode + (getLastAccessTime() != null ? getLastAccessTime().hashCode() : 0);    hashCode = 31 * hashCode + Long.valueOf(Math.max(getTimeout(), 0)).hashCode();    hashCode = 31 * hashCode + Boolean.valueOf(isExpired()).hashCode();    hashCode = 31 * hashCode + (getHost() != null ? getHost().hashCode() : 0);    hashCode = 31 * hashCode + (getAttributes() != null ? getAttributes().hashCode() : 0);    return hashCode;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(getClass().getName()).append(",id=").append(getId());    return sb.toString();}
0
private void writeObject(ObjectOutputStream out) throws IOException
{    out.defaultWriteObject();    short alteredFieldsBitMask = getAlteredFieldsBitMask();    out.writeShort(alteredFieldsBitMask);    if (id != null) {        out.writeObject(id);    }    if (startTimestamp != null) {        out.writeObject(startTimestamp);    }    if (stopTimestamp != null) {        out.writeObject(stopTimestamp);    }    if (lastAccessTime != null) {        out.writeObject(lastAccessTime);    }    if (timeout != 0l) {        out.writeLong(timeout);    }    if (expired) {        out.writeBoolean(expired);    }    if (host != null) {        out.writeUTF(host);    }    if (!CollectionUtils.isEmpty(attributes)) {        out.writeObject(attributes);    }}
0
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{    in.defaultReadObject();    short bitMask = in.readShort();    if (isFieldPresent(bitMask, ID_BIT_MASK)) {        this.id = (Serializable) in.readObject();    }    if (isFieldPresent(bitMask, START_TIMESTAMP_BIT_MASK)) {        this.startTimestamp = (Date) in.readObject();    }    if (isFieldPresent(bitMask, STOP_TIMESTAMP_BIT_MASK)) {        this.stopTimestamp = (Date) in.readObject();    }    if (isFieldPresent(bitMask, LAST_ACCESS_TIME_BIT_MASK)) {        this.lastAccessTime = (Date) in.readObject();    }    if (isFieldPresent(bitMask, TIMEOUT_BIT_MASK)) {        this.timeout = in.readLong();    }    if (isFieldPresent(bitMask, EXPIRED_BIT_MASK)) {        this.expired = in.readBoolean();    }    if (isFieldPresent(bitMask, HOST_BIT_MASK)) {        this.host = in.readUTF();    }    if (isFieldPresent(bitMask, ATTRIBUTES_BIT_MASK)) {        this.attributes = (Map<Object, Object>) in.readObject();    }}
0
private short getAlteredFieldsBitMask()
{    int bitMask = 0;    bitMask = id != null ? bitMask | ID_BIT_MASK : bitMask;    bitMask = startTimestamp != null ? bitMask | START_TIMESTAMP_BIT_MASK : bitMask;    bitMask = stopTimestamp != null ? bitMask | STOP_TIMESTAMP_BIT_MASK : bitMask;    bitMask = lastAccessTime != null ? bitMask | LAST_ACCESS_TIME_BIT_MASK : bitMask;    bitMask = timeout != 0l ? bitMask | TIMEOUT_BIT_MASK : bitMask;    bitMask = expired ? bitMask | EXPIRED_BIT_MASK : bitMask;    bitMask = host != null ? bitMask | HOST_BIT_MASK : bitMask;    bitMask = !CollectionUtils.isEmpty(attributes) ? bitMask | ATTRIBUTES_BIT_MASK : bitMask;    return (short) bitMask;}
0
private static boolean isFieldPresent(short bitMask, int fieldBitMask)
{    return (bitMask & fieldBitMask) != 0;}
0
public Session createSession(SessionContext initData)
{    if (initData != null) {        String host = initData.getHost();        if (host != null) {            return new SimpleSession(host);        }    }    return new SimpleSession();}
0
public Serializable getId()
{    return delegate.getId();}
0
public Date getStartTimestamp()
{    return delegate.getStartTimestamp();}
0
public Date getLastAccessTime()
{    return delegate.getLastAccessTime();}
0
public long getTimeout() throws InvalidSessionException
{    return delegate.getTimeout();}
0
public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException
{    delegate.setTimeout(maxIdleTimeInMillis);}
0
public String getHost()
{    return delegate.getHost();}
0
public void touch() throws InvalidSessionException
{    delegate.touch();}
0
public void stop() throws InvalidSessionException
{    delegate.stop();}
0
public Collection<Object> getAttributeKeys() throws InvalidSessionException
{    return delegate.getAttributeKeys();}
0
public Object getAttribute(Object key) throws InvalidSessionException
{    return delegate.getAttribute(key);}
0
public void setAttribute(Object key, Object value) throws InvalidSessionException
{    delegate.setAttribute(key, value);}
0
public Object removeAttribute(Object key) throws InvalidSessionException
{    return delegate.removeAttribute(key);}
0
public void onStart(Session session)
{}
0
public void onStop(Session session)
{}
0
public void onExpiration(Session session)
{}
0
protected Collection getPrincipalsLazy(String realmName)
{    if (realmPrincipals == null) {        realmPrincipals = new LinkedHashMap<String, Set>();    }    Set principals = realmPrincipals.get(realmName);    if (principals == null) {        principals = new LinkedHashSet();        realmPrincipals.put(realmName, principals);    }    return principals;}
0
public Object getPrimaryPrincipal()
{    if (isEmpty()) {        return null;    }    return iterator().next();}
0
public void add(Object principal, String realmName)
{    if (realmName == null) {        throw new IllegalArgumentException("realmName argument cannot be null.");    }    if (principal == null) {        throw new IllegalArgumentException("principal argument cannot be null.");    }    this.cachedToString = null;    getPrincipalsLazy(realmName).add(principal);}
0
public void addAll(Collection principals, String realmName)
{    if (realmName == null) {        throw new IllegalArgumentException("realmName argument cannot be null.");    }    if (principals == null) {        throw new IllegalArgumentException("principals argument cannot be null.");    }    if (principals.isEmpty()) {        throw new IllegalArgumentException("principals argument cannot be an empty collection.");    }    this.cachedToString = null;    getPrincipalsLazy(realmName).addAll(principals);}
0
public void addAll(PrincipalCollection principals)
{    if (principals.getRealmNames() != null) {        for (String realmName : principals.getRealmNames()) {            for (Object principal : principals.fromRealm(realmName)) {                add(principal, realmName);            }        }    }}
0
public T oneByType(Class<T> type)
{    if (realmPrincipals == null || realmPrincipals.isEmpty()) {        return null;    }    Collection<Set> values = realmPrincipals.values();    for (Set set : values) {        for (Object o : set) {            if (type.isAssignableFrom(o.getClass())) {                return (T) o;            }        }    }    return null;}
0
public Collection<T> byType(Class<T> type)
{    if (realmPrincipals == null || realmPrincipals.isEmpty()) {        return Collections.EMPTY_SET;    }    Set<T> typed = new LinkedHashSet<T>();    Collection<Set> values = realmPrincipals.values();    for (Set set : values) {        for (Object o : set) {            if (type.isAssignableFrom(o.getClass())) {                typed.add((T) o);            }        }    }    if (typed.isEmpty()) {        return Collections.EMPTY_SET;    }    return Collections.unmodifiableSet(typed);}
0
public List asList()
{    Set all = asSet();    if (all.isEmpty()) {        return Collections.EMPTY_LIST;    }    return Collections.unmodifiableList(new ArrayList(all));}
0
public Set asSet()
{    if (realmPrincipals == null || realmPrincipals.isEmpty()) {        return Collections.EMPTY_SET;    }    Set aggregated = new LinkedHashSet();    Collection<Set> values = realmPrincipals.values();    for (Set set : values) {        aggregated.addAll(set);    }    if (aggregated.isEmpty()) {        return Collections.EMPTY_SET;    }    return Collections.unmodifiableSet(aggregated);}
0
public Collection fromRealm(String realmName)
{    if (realmPrincipals == null || realmPrincipals.isEmpty()) {        return Collections.EMPTY_SET;    }    Set principals = realmPrincipals.get(realmName);    if (principals == null || principals.isEmpty()) {        principals = Collections.EMPTY_SET;    }    return Collections.unmodifiableSet(principals);}
0
public Set<String> getRealmNames()
{    if (realmPrincipals == null) {        return null;    } else {        return realmPrincipals.keySet();    }}
0
public boolean isEmpty()
{    return realmPrincipals == null || realmPrincipals.isEmpty();}
0
public void clear()
{    this.cachedToString = null;    if (realmPrincipals != null) {        realmPrincipals.clear();        realmPrincipals = null;    }}
0
public Iterator iterator()
{    return asSet().iterator();}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (o instanceof SimplePrincipalCollection) {        SimplePrincipalCollection other = (SimplePrincipalCollection) o;        return this.realmPrincipals != null ? this.realmPrincipals.equals(other.realmPrincipals) : other.realmPrincipals == null;    }    return false;}
0
public int hashCode()
{    if (this.realmPrincipals != null && !realmPrincipals.isEmpty()) {        return realmPrincipals.hashCode();    }    return super.hashCode();}
0
public String toString()
{    if (this.cachedToString == null) {        Set<Object> principals = asSet();        if (!CollectionUtils.isEmpty(principals)) {            this.cachedToString = StringUtils.toString(principals.toArray());        } else {            this.cachedToString = "empty";        }    }    return this.cachedToString;}
0
private void writeObject(ObjectOutputStream out) throws IOException
{    out.defaultWriteObject();    boolean principalsExist = !CollectionUtils.isEmpty(realmPrincipals);    out.writeBoolean(principalsExist);    if (principalsExist) {        out.writeObject(realmPrincipals);    }}
0
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{    in.defaultReadObject();    boolean principalsExist = in.readBoolean();    if (principalsExist) {        this.realmPrincipals = (Map<String, Set>) in.readObject();    }}
0
public int size()
{    return CollectionUtils.size(this.combinedPrincipals);}
0
protected Map<String, Object> ensureCombinedPrincipals()
{    if (this.combinedPrincipals == null) {        this.combinedPrincipals = new HashMap<String, Object>();    }    return this.combinedPrincipals;}
0
public boolean containsKey(Object o)
{    return this.combinedPrincipals != null && this.combinedPrincipals.containsKey(o);}
0
public boolean containsValue(Object o)
{    return this.combinedPrincipals != null && this.combinedPrincipals.containsKey(o);}
0
public Object get(Object o)
{    return this.combinedPrincipals != null && this.combinedPrincipals.containsKey(o);}
0
public Object put(String s, Object o)
{    return ensureCombinedPrincipals().put(s, o);}
0
public Object remove(Object o)
{    return this.combinedPrincipals != null ? this.combinedPrincipals.remove(o) : null;}
0
public void putAll(Map<? extends String, ?> map)
{    if (!CollectionUtils.isEmpty(map)) {        ensureCombinedPrincipals().putAll(map);    }}
0
public Set<String> keySet()
{    return CollectionUtils.isEmpty(this.combinedPrincipals) ? Collections.<String>emptySet() : Collections.unmodifiableSet(this.combinedPrincipals.keySet());}
0
public Collection<Object> values()
{    return CollectionUtils.isEmpty(this.combinedPrincipals) ? Collections.emptySet() : Collections.unmodifiableCollection(this.combinedPrincipals.values());}
0
public Set<Entry<String, Object>> entrySet()
{    return CollectionUtils.isEmpty(this.combinedPrincipals) ? Collections.<Entry<String, Object>>emptySet() : Collections.unmodifiableSet(this.combinedPrincipals.entrySet());}
0
public void clear()
{    this.realmPrincipals = null;    this.combinedPrincipals = null;}
0
public Object getPrimaryPrincipal()
{        return !CollectionUtils.isEmpty(this.combinedPrincipals) ? this.combinedPrincipals.values().iterator().next() : null;}
0
public T oneByType(Class<T> type)
{    if (CollectionUtils.isEmpty(this.combinedPrincipals)) {        return null;    }    for (Object value : this.combinedPrincipals.values()) {        if (type.isInstance(value)) {            return type.cast(value);        }    }    return null;}
0
public Collection<T> byType(Class<T> type)
{    if (CollectionUtils.isEmpty(this.combinedPrincipals)) {        return Collections.emptySet();    }    Collection<T> instances = null;    for (Object value : this.combinedPrincipals.values()) {        if (type.isInstance(value)) {            if (instances == null) {                instances = new ArrayList<T>();            }            instances.add(type.cast(value));        }    }    return instances != null ? instances : Collections.<T>emptyList();}
0
public List asList()
{    if (CollectionUtils.isEmpty(this.combinedPrincipals)) {        return Collections.emptyList();    }    List<Object> list = new ArrayList<Object>(this.combinedPrincipals.size());    list.addAll(this.combinedPrincipals.values());    return list;}
0
public Set asSet()
{    if (CollectionUtils.isEmpty(this.combinedPrincipals)) {        return Collections.emptySet();    }    Set<Object> set = new HashSet<Object>(this.combinedPrincipals.size());    set.addAll(this.combinedPrincipals.values());    return set;}
0
public Collection fromRealm(String realmName)
{    if (CollectionUtils.isEmpty(this.realmPrincipals)) {        return Collections.emptySet();    }    Map<String, Object> principals = this.realmPrincipals.get(realmName);    if (CollectionUtils.isEmpty(principals)) {        return Collections.emptySet();    }    return Collections.unmodifiableCollection(principals.values());}
0
public Set<String> getRealmNames()
{    if (CollectionUtils.isEmpty(this.realmPrincipals)) {        return Collections.emptySet();    }    return Collections.unmodifiableSet(this.realmPrincipals.keySet());}
0
public boolean isEmpty()
{    return CollectionUtils.isEmpty(this.combinedPrincipals);}
0
public Iterator iterator()
{    return asList().iterator();}
0
public Map<String, Object> getRealmPrincipals(String name)
{    if (this.realmPrincipals == null) {        return null;    }    Map<String, Object> principals = this.realmPrincipals.get(name);    if (principals == null) {        return null;    }    return Collections.unmodifiableMap(principals);}
0
public Map<String, Object> setRealmPrincipals(String realmName, Map<String, Object> principals)
{    if (realmName == null) {        throw new NullPointerException("realmName argument cannot be null.");    }    if (this.realmPrincipals == null) {        if (!CollectionUtils.isEmpty(principals)) {            this.realmPrincipals = new HashMap<String, Map<String, Object>>();            return this.realmPrincipals.put(realmName, new HashMap<String, Object>(principals));        } else {            return null;        }    } else {        Map<String, Object> existingPrincipals = this.realmPrincipals.remove(realmName);        if (!CollectionUtils.isEmpty(principals)) {            this.realmPrincipals.put(realmName, new HashMap<String, Object>(principals));        }        return existingPrincipals;    }}
0
public Object setRealmPrincipal(String realmName, String principalName, Object principal)
{    if (realmName == null) {        throw new NullPointerException("realmName argument cannot be null.");    }    if (principalName == null) {        throw new NullPointerException(("principalName argument cannot be null."));    }    if (principal == null) {        return removeRealmPrincipal(realmName, principalName);    }    if (this.realmPrincipals == null) {        this.realmPrincipals = new HashMap<String, Map<String, Object>>();    }    Map<String, Object> principals = this.realmPrincipals.get(realmName);    if (principals == null) {        principals = new HashMap<String, Object>();        this.realmPrincipals.put(realmName, principals);    }    return principals.put(principalName, principal);}
0
public Object getRealmPrincipal(String realmName, String principalName)
{    if (realmName == null) {        throw new NullPointerException("realmName argument cannot be null.");    }    if (principalName == null) {        throw new NullPointerException(("principalName argument cannot be null."));    }    if (this.realmPrincipals == null) {        return null;    }    Map<String, Object> principals = this.realmPrincipals.get(realmName);    if (principals != null) {        return principals.get(principalName);    }    return null;}
0
public Object removeRealmPrincipal(String realmName, String principalName)
{    if (realmName == null) {        throw new NullPointerException("realmName argument cannot be null.");    }    if (principalName == null) {        throw new NullPointerException(("principalName argument cannot be null."));    }    if (this.realmPrincipals == null) {        return null;    }    Map<String, Object> principals = this.realmPrincipals.get(realmName);    if (principals != null) {        return principals.remove(principalName);    }    return null;}
0
protected SubjectContext newSubjectContextInstance()
{    return new DefaultSubjectContext();}
0
protected SubjectContext getSubjectContext()
{    return this.subjectContext;}
0
public Builder sessionId(Serializable sessionId)
{    if (sessionId != null) {        this.subjectContext.setSessionId(sessionId);    }    return this;}
0
public Builder host(String host)
{    if (StringUtils.hasText(host)) {        this.subjectContext.setHost(host);    }    return this;}
0
public Builder session(Session session)
{    if (session != null) {        this.subjectContext.setSession(session);    }    return this;}
0
public Builder principals(PrincipalCollection principals)
{    if (principals != null && !principals.isEmpty()) {        this.subjectContext.setPrincipals(principals);    }    return this;}
0
public Builder sessionCreationEnabled(boolean enabled)
{    this.subjectContext.setSessionCreationEnabled(enabled);    return this;}
0
public Builder authenticated(boolean authenticated)
{    this.subjectContext.setAuthenticated(authenticated);    return this;}
0
public Builder contextAttribute(String attributeKey, Object attributeValue)
{    if (attributeKey == null) {        String msg = "Subject context map key cannot be null.";        throw new IllegalArgumentException(msg);    }    if (attributeValue == null) {        this.subjectContext.remove(attributeKey);    } else {        this.subjectContext.put(attributeKey, attributeValue);    }    return this;}
0
public Subject buildSubject()
{    return this.securityManager.createSubject(this.subjectContext);}
0
public SecurityManager getSecurityManager()
{    return getTypedValue(SECURITY_MANAGER, SecurityManager.class);}
0
public void setSecurityManager(SecurityManager securityManager)
{    nullSafePut(SECURITY_MANAGER, securityManager);}
0
public SecurityManager resolveSecurityManager()
{    SecurityManager securityManager = getSecurityManager();    if (securityManager == null) {        if (log.isDebugEnabled()) {                    }        try {            securityManager = SecurityUtils.getSecurityManager();        } catch (UnavailableSecurityManagerException e) {            if (log.isDebugEnabled()) {                            }        }    }    return securityManager;}
1
public Serializable getSessionId()
{    return getTypedValue(SESSION_ID, Serializable.class);}
0
public void setSessionId(Serializable sessionId)
{    nullSafePut(SESSION_ID, sessionId);}
0
public Subject getSubject()
{    return getTypedValue(SUBJECT, Subject.class);}
0
public void setSubject(Subject subject)
{    nullSafePut(SUBJECT, subject);}
0
public PrincipalCollection getPrincipals()
{    return getTypedValue(PRINCIPALS, PrincipalCollection.class);}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
public void setPrincipals(PrincipalCollection principals)
{    if (!isEmpty(principals)) {        put(PRINCIPALS, principals);    }}
0
public PrincipalCollection resolvePrincipals()
{    PrincipalCollection principals = getPrincipals();    if (isEmpty(principals)) {                AuthenticationInfo info = getAuthenticationInfo();        if (info != null) {            principals = info.getPrincipals();        }    }    if (isEmpty(principals)) {        Subject subject = getSubject();        if (subject != null) {            principals = subject.getPrincipals();        }    }    if (isEmpty(principals)) {                Session session = resolveSession();        if (session != null) {            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);        }    }    return principals;}
0
public Session getSession()
{    return getTypedValue(SESSION, Session.class);}
0
public void setSession(Session session)
{    nullSafePut(SESSION, session);}
0
public Session resolveSession()
{    Session session = getSession();    if (session == null) {                Subject existingSubject = getSubject();        if (existingSubject != null) {            session = existingSubject.getSession(false);        }    }    return session;}
0
public boolean isSessionCreationEnabled()
{    Boolean val = getTypedValue(SESSION_CREATION_ENABLED, Boolean.class);    return val == null || val;}
0
public void setSessionCreationEnabled(boolean enabled)
{    nullSafePut(SESSION_CREATION_ENABLED, enabled);}
0
public boolean isAuthenticated()
{    Boolean authc = getTypedValue(AUTHENTICATED, Boolean.class);    return authc != null && authc;}
0
public void setAuthenticated(boolean authc)
{    put(AUTHENTICATED, authc);}
0
public boolean resolveAuthenticated()
{    Boolean authc = getTypedValue(AUTHENTICATED, Boolean.class);    if (authc == null) {                        AuthenticationInfo info = getAuthenticationInfo();        authc = info != null;    }    if (!authc) {                Session session = resolveSession();        if (session != null) {            Boolean sessionAuthc = (Boolean) session.getAttribute(AUTHENTICATED_SESSION_KEY);            authc = sessionAuthc != null && sessionAuthc;        }    }    return authc;}
0
public AuthenticationInfo getAuthenticationInfo()
{    return getTypedValue(AUTHENTICATION_INFO, AuthenticationInfo.class);}
0
public void setAuthenticationInfo(AuthenticationInfo info)
{    nullSafePut(AUTHENTICATION_INFO, info);}
0
public AuthenticationToken getAuthenticationToken()
{    return getTypedValue(AUTHENTICATION_TOKEN, AuthenticationToken.class);}
0
public void setAuthenticationToken(AuthenticationToken token)
{    nullSafePut(AUTHENTICATION_TOKEN, token);}
0
public String getHost()
{    return getTypedValue(HOST, String.class);}
0
public void setHost(String host)
{    if (StringUtils.hasText(host)) {        put(HOST, host);    }}
0
public String resolveHost()
{    String host = getHost();    if (host == null) {                AuthenticationToken token = getAuthenticationToken();        if (token instanceof HostAuthenticationToken) {            host = ((HostAuthenticationToken) token).getHost();        }    }    if (host == null) {        Session session = resolveSession();        if (session != null) {            host = session.getHost();        }    }    return host;}
0
protected Session decorate(Session session)
{    if (session == null) {        throw new IllegalArgumentException("session cannot be null");    }    return new StoppingAwareProxiedSession(session, this);}
0
public SecurityManager getSecurityManager()
{    return securityManager;}
0
private static boolean isEmpty(PrincipalCollection pc)
{    return pc == null || pc.isEmpty();}
0
protected boolean hasPrincipals()
{    return !isEmpty(getPrincipals());}
0
public String getHost()
{    return this.host;}
0
private Object getPrimaryPrincipal(PrincipalCollection principals)
{    if (!isEmpty(principals)) {        return principals.getPrimaryPrincipal();    }    return null;}
0
public Object getPrincipal()
{    return getPrimaryPrincipal(getPrincipals());}
0
public PrincipalCollection getPrincipals()
{    List<PrincipalCollection> runAsPrincipals = getRunAsPrincipalsStack();    return CollectionUtils.isEmpty(runAsPrincipals) ? this.principals : runAsPrincipals.get(0);}
0
public boolean isPermitted(String permission)
{    return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);}
0
public boolean isPermitted(Permission permission)
{    return hasPrincipals() && securityManager.isPermitted(getPrincipals(), permission);}
0
public boolean[] isPermitted(String... permissions)
{    if (hasPrincipals()) {        return securityManager.isPermitted(getPrincipals(), permissions);    } else {        return new boolean[permissions.length];    }}
0
public boolean[] isPermitted(List<Permission> permissions)
{    if (hasPrincipals()) {        return securityManager.isPermitted(getPrincipals(), permissions);    } else {        return new boolean[permissions.size()];    }}
0
public boolean isPermittedAll(String... permissions)
{    return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);}
0
public boolean isPermittedAll(Collection<Permission> permissions)
{    return hasPrincipals() && securityManager.isPermittedAll(getPrincipals(), permissions);}
0
protected void assertAuthzCheckPossible() throws AuthorizationException
{    if (!hasPrincipals()) {        String msg = "This subject is anonymous - it does not have any identifying principals and " + "authorization operations require an identity to check against.  A Subject instance will " + "acquire these identifying principals automatically after a successful login is performed " + "be executing " + Subject.class.getName() + ".login(AuthenticationToken) or when 'Remember Me' " + "functionality is enabled by the SecurityManager.  This exception can also occur when a " + "previously logged-in Subject has logged out which " + "makes it anonymous again.  Because an identity is currently not known due to any of these " + "conditions, authorization is denied.";        throw new UnauthenticatedException(msg);    }}
0
public void checkPermission(String permission) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkPermission(getPrincipals(), permission);}
0
public void checkPermission(Permission permission) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkPermission(getPrincipals(), permission);}
0
public void checkPermissions(String... permissions) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkPermissions(getPrincipals(), permissions);}
0
public void checkPermissions(Collection<Permission> permissions) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkPermissions(getPrincipals(), permissions);}
0
public boolean hasRole(String roleIdentifier)
{    return hasPrincipals() && securityManager.hasRole(getPrincipals(), roleIdentifier);}
0
public boolean[] hasRoles(List<String> roleIdentifiers)
{    if (hasPrincipals()) {        return securityManager.hasRoles(getPrincipals(), roleIdentifiers);    } else {        return new boolean[roleIdentifiers.size()];    }}
0
public boolean hasAllRoles(Collection<String> roleIdentifiers)
{    return hasPrincipals() && securityManager.hasAllRoles(getPrincipals(), roleIdentifiers);}
0
public void checkRole(String role) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkRole(getPrincipals(), role);}
0
public void checkRoles(String... roleIdentifiers) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkRoles(getPrincipals(), roleIdentifiers);}
0
public void checkRoles(Collection<String> roles) throws AuthorizationException
{    assertAuthzCheckPossible();    securityManager.checkRoles(getPrincipals(), roles);}
0
public void login(AuthenticationToken token) throws AuthenticationException
{    clearRunAsIdentitiesInternal();    Subject subject = securityManager.login(this, token);    PrincipalCollection principals;    String host = null;    if (subject instanceof DelegatingSubject) {        DelegatingSubject delegating = (DelegatingSubject) subject;                principals = delegating.principals;        host = delegating.host;    } else {        principals = subject.getPrincipals();    }    if (principals == null || principals.isEmpty()) {        String msg = "Principals returned from securityManager.login( token ) returned a null or " + "empty value.  This value must be non null and populated with one or more elements.";        throw new IllegalStateException(msg);    }    this.principals = principals;    this.authenticated = true;    if (token instanceof HostAuthenticationToken) {        host = ((HostAuthenticationToken) token).getHost();    }    if (host != null) {        this.host = host;    }    Session session = subject.getSession(false);    if (session != null) {        this.session = decorate(session);    } else {        this.session = null;    }}
0
public boolean isAuthenticated()
{    return authenticated && hasPrincipals();}
0
public boolean isRemembered()
{    PrincipalCollection principals = getPrincipals();    return principals != null && !principals.isEmpty() && !isAuthenticated();}
0
protected boolean isSessionCreationEnabled()
{    return this.sessionCreationEnabled;}
0
public Session getSession()
{    return getSession(true);}
0
public Session getSession(boolean create)
{    if (log.isTraceEnabled()) {        log.trace("attempting to get session; create = " + create + "; session is null = " + (this.session == null) + "; session has id = " + (this.session != null && session.getId() != null));    }    if (this.session == null && create) {                if (!isSessionCreationEnabled()) {            String msg = "Session creation has been disabled for the current subject.  This exception indicates " + "that there is either a programming error (using a session when it should never be " + "used) or that Shiro's configuration needs to be adjusted to allow Sessions to be created " + "for the current Subject.  See the " + DisabledSessionException.class.getName() + " JavaDoc " + "for more.";            throw new DisabledSessionException(msg);        }        log.trace("Starting session for host {}", getHost());        SessionContext sessionContext = createSessionContext();        Session session = this.securityManager.start(sessionContext);        this.session = decorate(session);    }    return this.session;}
0
protected SessionContext createSessionContext()
{    SessionContext sessionContext = new DefaultSessionContext();    if (StringUtils.hasText(host)) {        sessionContext.setHost(host);    }    return sessionContext;}
0
private void clearRunAsIdentitiesInternal()
{        try {        clearRunAsIdentities();    } catch (SessionException se) {            }}
1
public void logout()
{    try {        clearRunAsIdentitiesInternal();        this.securityManager.logout(this);    } finally {        this.session = null;        this.principals = null;        this.authenticated = false;                        }}
0
private void sessionStopped()
{    this.session = null;}
0
public V execute(Callable<V> callable) throws ExecutionException
{    Callable<V> associated = associateWith(callable);    try {        return associated.call();    } catch (Throwable t) {        throw new ExecutionException(t);    }}
0
public void execute(Runnable runnable)
{    Runnable associated = associateWith(runnable);    associated.run();}
0
public Callable<V> associateWith(Callable<V> callable)
{    return new SubjectCallable<V>(this, callable);}
0
public Runnable associateWith(Runnable runnable)
{    if (runnable instanceof Thread) {        String msg = "This implementation does not support Thread arguments because of JDK ThreadLocal " + "inheritance mechanisms required by Shiro.  Instead, the method argument should be a non-Thread " + "Runnable and the return value from this method can then be given to an ExecutorService or " + "another Thread.";        throw new UnsupportedOperationException(msg);    }    return new SubjectRunnable(this, runnable);}
0
public void stop() throws InvalidSessionException
{    super.stop();    owner.sessionStopped();}
0
public void runAs(PrincipalCollection principals)
{    if (!hasPrincipals()) {        String msg = "This subject does not yet have an identity.  Assuming the identity of another " + "Subject is only allowed for Subjects with an existing identity.  Try logging this subject in " + "first, or using the " + Subject.Builder.class.getName() + " to build ad hoc Subject instances " + "with identities as necessary.";        throw new IllegalStateException(msg);    }    pushIdentity(principals);}
0
public boolean isRunAs()
{    List<PrincipalCollection> stack = getRunAsPrincipalsStack();    return !CollectionUtils.isEmpty(stack);}
0
public PrincipalCollection getPreviousPrincipals()
{    PrincipalCollection previousPrincipals = null;    List<PrincipalCollection> stack = getRunAsPrincipalsStack();    int stackSize = stack != null ? stack.size() : 0;    if (stackSize > 0) {        if (stackSize == 1) {            previousPrincipals = this.principals;        } else {                        assert stack != null;            previousPrincipals = stack.get(1);        }    }    return previousPrincipals;}
0
public PrincipalCollection releaseRunAs()
{    return popIdentity();}
0
private List<PrincipalCollection> getRunAsPrincipalsStack()
{    Session session = getSession(false);    if (session != null) {        return (List<PrincipalCollection>) session.getAttribute(RUN_AS_PRINCIPALS_SESSION_KEY);    }    return null;}
0
private void clearRunAsIdentities()
{    Session session = getSession(false);    if (session != null) {        session.removeAttribute(RUN_AS_PRINCIPALS_SESSION_KEY);    }}
0
private void pushIdentity(PrincipalCollection principals) throws NullPointerException
{    if (isEmpty(principals)) {        String msg = "Specified Subject principals cannot be null or empty for 'run as' functionality.";        throw new NullPointerException(msg);    }    List<PrincipalCollection> stack = getRunAsPrincipalsStack();    if (stack == null) {        stack = new CopyOnWriteArrayList<PrincipalCollection>();    }    stack.add(0, principals);    Session session = getSession();    session.setAttribute(RUN_AS_PRINCIPALS_SESSION_KEY, stack);}
0
private PrincipalCollection popIdentity()
{    PrincipalCollection popped = null;    List<PrincipalCollection> stack = getRunAsPrincipalsStack();    if (!CollectionUtils.isEmpty(stack)) {        popped = stack.remove(0);        Session session;        if (!CollectionUtils.isEmpty(stack)) {                        session = getSession();            session.setAttribute(RUN_AS_PRINCIPALS_SESSION_KEY, stack);        } else {                        clearRunAsIdentities();        }    }    return popped;}
0
public V call() throws Exception
{    try {        threadState.bind();        return doCall(this.callable);    } finally {        threadState.restore();    }}
0
protected V doCall(Callable<V> target) throws Exception
{    return target.call();}
0
public void run()
{    try {        threadState.bind();        doRun(this.runnable);    } finally {        threadState.restore();    }}
0
protected void doRun(Runnable runnable)
{    runnable.run();}
0
protected Subject getSubject()
{    return this.subject;}
0
public void bind()
{    SecurityManager securityManager = this.securityManager;    if (securityManager == null) {                securityManager = ThreadContext.getSecurityManager();    }    this.originalResources = ThreadContext.getResources();    ThreadContext.remove();    ThreadContext.bind(this.subject);    if (securityManager != null) {        ThreadContext.bind(securityManager);    }}
0
public void restore()
{    ThreadContext.remove();    if (!CollectionUtils.isEmpty(this.originalResources)) {        ThreadContext.setResources(this.originalResources);    }}
0
public void clear()
{    ThreadContext.remove();}
0
public boolean isSingleton()
{    return singleton;}
0
public void setSingleton(boolean singleton)
{    this.singleton = singleton;}
0
public T getInstance()
{    T instance;    if (isSingleton()) {        if (this.singletonInstance == null) {            this.singletonInstance = createInstance();        }        instance = this.singletonInstance;    } else {        instance = createInstance();    }    if (instance == null) {        String msg = "Factory 'createInstance' implementation returned a null object.";        throw new IllegalStateException(msg);    }    return instance;}
0
public void setPathSeparator(String pathSeparator)
{    this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);}
0
public boolean isPattern(String path)
{    return (path.indexOf('*') != -1 || path.indexOf('?') != -1);}
0
public boolean matches(String pattern, String source)
{    return match(pattern, source);}
0
public boolean match(String pattern, String path)
{    return doMatch(pattern, path, true);}
0
public boolean matchStart(String pattern, String path)
{    return doMatch(pattern, path, false);}
0
protected boolean doMatch(String pattern, String path, boolean fullMatch)
{    if (path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {        return false;    }    String[] pattDirs = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);    String[] pathDirs = StringUtils.tokenizeToStringArray(path, this.pathSeparator);    int pattIdxStart = 0;    int pattIdxEnd = pattDirs.length - 1;    int pathIdxStart = 0;    int pathIdxEnd = pathDirs.length - 1;        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {        String patDir = pattDirs[pattIdxStart];        if ("**".equals(patDir)) {            break;        }        if (!matchStrings(patDir, pathDirs[pathIdxStart])) {            return false;        }        pattIdxStart++;        pathIdxStart++;    }    if (pathIdxStart > pathIdxEnd) {                if (pattIdxStart > pattIdxEnd) {            return (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator));        }        if (!fullMatch) {            return true;        }        if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals("*") && path.endsWith(this.pathSeparator)) {            return true;        }        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {            if (!pattDirs[i].equals("**")) {                return false;            }        }        return true;    } else if (pattIdxStart > pattIdxEnd) {                return false;    } else if (!fullMatch && "**".equals(pattDirs[pattIdxStart])) {                return true;    }        while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {        String patDir = pattDirs[pattIdxEnd];        if (patDir.equals("**")) {            break;        }        if (!matchStrings(patDir, pathDirs[pathIdxEnd])) {            return false;        }        pattIdxEnd--;        pathIdxEnd--;    }    if (pathIdxStart > pathIdxEnd) {                for (int i = pattIdxStart; i <= pattIdxEnd; i++) {            if (!pattDirs[i].equals("**")) {                return false;            }        }        return true;    }    while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {        int patIdxTmp = -1;        for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {            if (pattDirs[i].equals("**")) {                patIdxTmp = i;                break;            }        }        if (patIdxTmp == pattIdxStart + 1) {                        pattIdxStart++;            continue;        }                        int patLength = (patIdxTmp - pattIdxStart - 1);        int strLength = (pathIdxEnd - pathIdxStart + 1);        int foundIdx = -1;        strLoop: for (int i = 0; i <= strLength - patLength; i++) {            for (int j = 0; j < patLength; j++) {                String subPat = (String) pattDirs[pattIdxStart + j + 1];                String subStr = (String) pathDirs[pathIdxStart + i + j];                if (!matchStrings(subPat, subStr)) {                    continue strLoop;                }            }            foundIdx = pathIdxStart + i;            break;        }        if (foundIdx == -1) {            return false;        }        pattIdxStart = patIdxTmp;        pathIdxStart = foundIdx + patLength;    }    for (int i = pattIdxStart; i <= pattIdxEnd; i++) {        if (!pattDirs[i].equals("**")) {            return false;        }    }    return true;}
0
private boolean matchStrings(String pattern, String str)
{    char[] patArr = pattern.toCharArray();    char[] strArr = str.toCharArray();    int patIdxStart = 0;    int patIdxEnd = patArr.length - 1;    int strIdxStart = 0;    int strIdxEnd = strArr.length - 1;    char ch;    boolean containsStar = false;    for (char aPatArr : patArr) {        if (aPatArr == '*') {            containsStar = true;            break;        }    }    if (!containsStar) {                if (patIdxEnd != strIdxEnd) {                        return false;        }        for (int i = 0; i <= patIdxEnd; i++) {            ch = patArr[i];            if (ch != '?') {                if (ch != strArr[i]) {                                        return false;                }            }        }                return true;    }    if (patIdxEnd == 0) {                return true;    }        while ((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {        if (ch != '?') {            if (ch != strArr[strIdxStart]) {                                return false;            }        }        patIdxStart++;        strIdxStart++;    }    if (strIdxStart > strIdxEnd) {                for (int i = patIdxStart; i <= patIdxEnd; i++) {            if (patArr[i] != '*') {                return false;            }        }        return true;    }        while ((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {        if (ch != '?') {            if (ch != strArr[strIdxEnd]) {                                return false;            }        }        patIdxEnd--;        strIdxEnd--;    }    if (strIdxStart > strIdxEnd) {                for (int i = patIdxStart; i <= patIdxEnd; i++) {            if (patArr[i] != '*') {                return false;            }        }        return true;    }        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {        int patIdxTmp = -1;        for (int i = patIdxStart + 1; i <= patIdxEnd; i++) {            if (patArr[i] == '*') {                patIdxTmp = i;                break;            }        }        if (patIdxTmp == patIdxStart + 1) {                        patIdxStart++;            continue;        }                        int patLength = (patIdxTmp - patIdxStart - 1);        int strLength = (strIdxEnd - strIdxStart + 1);        int foundIdx = -1;        strLoop: for (int i = 0; i <= strLength - patLength; i++) {            for (int j = 0; j < patLength; j++) {                ch = patArr[patIdxStart + j + 1];                if (ch != '?') {                    if (ch != strArr[strIdxStart + i + j]) {                        continue strLoop;                    }                }            }            foundIdx = strIdxStart + i;            break;        }        if (foundIdx == -1) {            return false;        }        patIdxStart = patIdxTmp;        strIdxStart = foundIdx + patLength;    }        for (int i = patIdxStart; i <= patIdxEnd; i++) {        if (patArr[i] != '*') {            return false;        }    }    return true;}
0
public String extractPathWithinPattern(String pattern, String path)
{    String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator);    String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator);    StringBuilder buffer = new StringBuilder();        int puts = 0;    for (int i = 0; i < patternParts.length; i++) {        String patternPart = patternParts[i];        if ((patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) && pathParts.length >= i + 1) {            if (puts > 0 || (i == 0 && !pattern.startsWith(this.pathSeparator))) {                buffer.append(this.pathSeparator);            }            buffer.append(pathParts[i]);            puts++;        }    }        for (int i = patternParts.length; i < pathParts.length; i++) {        if (puts > 0 || i > 0) {            buffer.append(this.pathSeparator);        }        buffer.append(pathParts[i]);    }    return buffer.toString();}
0
public static Set<E> asSet(E... elements)
{    if (elements == null || elements.length == 0) {        return Collections.emptySet();    }    if (elements.length == 1) {        return Collections.singleton(elements[0]);    }    LinkedHashSet<E> set = new LinkedHashSet<E>(elements.length * 4 / 3 + 1);    Collections.addAll(set, elements);    return set;}
0
public static boolean isEmpty(Collection c)
{    return c == null || c.isEmpty();}
0
public static boolean isEmpty(Map m)
{    return m == null || m.isEmpty();}
0
public static int size(Collection c)
{    return c != null ? c.size() : 0;}
0
public static int size(Map m)
{    return m != null ? m.size() : 0;}
0
public static boolean isEmpty(PrincipalCollection principals)
{    return principals == null || principals.isEmpty();}
0
public static List<E> asList(E... elements)
{    if (elements == null || elements.length == 0) {        return Collections.emptyList();    }        return Arrays.asList(elements);}
0
 static int computeListCapacity(int arraySize)
{    return (int) Math.min(5L + arraySize + (arraySize / 10), Integer.MAX_VALUE);}
0
public static String getVersion()
{    return version;}
0
public static int getMajorVersion()
{    return majorVersion;}
0
public static boolean isAtLeastVersion14()
{    return getMajorVersion() >= JAVA_14;}
0
public static boolean isAtLeastVersion15()
{    return getMajorVersion() >= JAVA_15;}
0
public static boolean isAtLeastVersion16()
{    return getMajorVersion() >= JAVA_16;}
0
public static void closeConnection(Connection connection)
{    if (connection != null) {        try {            connection.close();        } catch (SQLException ex) {            if (log.isDebugEnabled()) {                            }        } catch (Throwable ex) {            if (log.isDebugEnabled()) {                            }        }    }}
1
public static void closeStatement(Statement statement)
{    if (statement != null) {        try {            statement.close();        } catch (SQLException ex) {            if (log.isDebugEnabled()) {                            }        } catch (Throwable ex) {            if (log.isDebugEnabled()) {                            }        }    }}
1
public static void closeResultSet(ResultSet rs)
{    if (rs != null) {        try {            rs.close();        } catch (SQLException ex) {            if (log.isDebugEnabled()) {                            }        } catch (Throwable ex) {            if (log.isDebugEnabled()) {                            }        }    }}
1
protected E getTypedValue(String key, Class<E> type)
{    E found = null;    Object o = backingMap.get(key);    if (o != null) {        if (!type.isAssignableFrom(o.getClass())) {            String msg = "Invalid object found in SubjectContext Map under key [" + key + "].  Expected type " + "was [" + type.getName() + "], but the object under that key is of type " + "[" + o.getClass().getName() + "].";            throw new IllegalArgumentException(msg);        }        found = (E) o;    }    return found;}
0
protected void nullSafePut(String key, Object value)
{    if (value != null) {        put(key, value);    }}
0
public int size()
{    return backingMap.size();}
0
public boolean isEmpty()
{    return backingMap.isEmpty();}
0
public boolean containsKey(Object o)
{    return backingMap.containsKey(o);}
0
public boolean containsValue(Object o)
{    return backingMap.containsValue(o);}
0
public Object get(Object o)
{    return backingMap.get(o);}
0
public Object put(String s, Object o)
{    return backingMap.put(s, o);}
0
public Object remove(Object o)
{    return backingMap.remove(o);}
0
public void putAll(Map<? extends String, ?> map)
{    backingMap.putAll(map);}
0
public void clear()
{    backingMap.clear();}
0
public Set<String> keySet()
{    return Collections.unmodifiableSet(backingMap.keySet());}
0
public Collection<Object> values()
{    return Collections.unmodifiableCollection(backingMap.values());}
0
public Set<Entry<String, Object>> entrySet()
{    return Collections.unmodifiableSet(backingMap.entrySet());}
0
public static Set<Permission> resolveDelimitedPermissions(String s, PermissionResolver permissionResolver)
{    Set<String> permStrings = toPermissionStrings(s);    return resolvePermissions(permStrings, permissionResolver);}
0
public static Set<String> toPermissionStrings(String permissionsString)
{    String[] tokens = StringUtils.split(permissionsString);    if (tokens != null && tokens.length > 0) {        return new LinkedHashSet<String>(Arrays.asList(tokens));    }    return null;}
0
public static Set<Permission> resolvePermissions(Collection<String> permissionStrings, PermissionResolver permissionResolver)
{    Set<Permission> permissions = new LinkedHashSet<Permission>(permissionStrings.size());    for (String permissionString : permissionStrings) {        permissions.add(permissionResolver.resolvePermission(permissionString));    }    return permissions;}
0
public boolean matches(String pattern, String source)
{    if (pattern == null) {        throw new IllegalArgumentException("pattern argument cannot be null.");    }    Pattern p = Pattern.compile(pattern);    Matcher m = p.matcher(source);    return m.matches();}
0
public static Map<Object, Object> getResources()
{    if (resources.get() == null) {        return Collections.emptyMap();    } else {        return new HashMap<Object, Object>(resources.get());    }}
0
public static void setResources(Map<Object, Object> newResources)
{    if (CollectionUtils.isEmpty(newResources)) {        return;    }    ensureResourcesInitialized();    resources.get().clear();    resources.get().putAll(newResources);}
0
private static Object getValue(Object key)
{    Map<Object, Object> perThreadResources = resources.get();    return perThreadResources != null ? perThreadResources.get(key) : null;}
0
private static void ensureResourcesInitialized()
{    if (resources.get() == null) {        resources.set(new HashMap<Object, Object>());    }}
0
public static Object get(Object key)
{    if (log.isTraceEnabled()) {        String msg = "get() - in thread [" + Thread.currentThread().getName() + "]";        log.trace(msg);    }    Object value = getValue(key);    if ((value != null) && log.isTraceEnabled()) {        String msg = "Retrieved value of type [" + value.getClass().getName() + "] for key [" + key + "] " + "bound to thread [" + Thread.currentThread().getName() + "]";        log.trace(msg);    }    return value;}
0
public static void put(Object key, Object value)
{    if (key == null) {        throw new IllegalArgumentException("key cannot be null");    }    if (value == null) {        remove(key);        return;    }    ensureResourcesInitialized();    resources.get().put(key, value);    if (log.isTraceEnabled()) {        String msg = "Bound value of type [" + value.getClass().getName() + "] for key [" + key + "] to thread " + "[" + Thread.currentThread().getName() + "]";        log.trace(msg);    }}
0
public static Object remove(Object key)
{    Map<Object, Object> perThreadResources = resources.get();    Object value = perThreadResources != null ? perThreadResources.remove(key) : null;    if ((value != null) && log.isTraceEnabled()) {        String msg = "Removed value of type [" + value.getClass().getName() + "] for key [" + key + "]" + "from thread [" + Thread.currentThread().getName() + "]";        log.trace(msg);    }    return value;}
0
public static void remove()
{    resources.remove();}
0
public static SecurityManager getSecurityManager()
{    return (SecurityManager) get(SECURITY_MANAGER_KEY);}
0
public static void bind(SecurityManager securityManager)
{    if (securityManager != null) {        put(SECURITY_MANAGER_KEY, securityManager);    }}
0
public static SecurityManager unbindSecurityManager()
{    return (SecurityManager) remove(SECURITY_MANAGER_KEY);}
0
public static Subject getSubject()
{    return (Subject) get(SUBJECT_KEY);}
0
public static void bind(Subject subject)
{    if (subject != null) {        put(SUBJECT_KEY, subject);    }}
0
public static Subject unbindSubject()
{    return (Subject) remove(SUBJECT_KEY);}
0
protected Map<Object, Object> childValue(Map<Object, Object> parentValue)
{    if (parentValue != null) {        return (Map<Object, Object>) ((HashMap<Object, Object>) parentValue).clone();    } else {        return null;    }}
0
public void operateThis()
{}
0
public void operateThat()
{}
0
public void testAnnotationFoundFromClass() throws SecurityException, NoSuchMethodException
{    MyFixture myFixture = new MyFixture();    MethodInvocation methodInvocation = createMock(MethodInvocation.class);    Method method = MyFixture.class.getDeclaredMethod("operateThis");    expect(methodInvocation.getMethod()).andReturn(method);    expect(methodInvocation.getThis()).andReturn(myFixture);    replay(methodInvocation);    assertNotNull(annotationResolver.getAnnotation(methodInvocation, RequiresRoles.class));}
0
public void testAnnotationFoundFromMethod() throws SecurityException, NoSuchMethodException
{    MethodInvocation methodInvocation = createMock(MethodInvocation.class);    Method method = MyFixture.class.getDeclaredMethod("operateThat");    expect(methodInvocation.getMethod()).andReturn(method);    replay(methodInvocation);    assertNotNull(annotationResolver.getAnnotation(methodInvocation, RequiresUser.class));}
0
public void testNullMethodInvocation() throws SecurityException, NoSuchMethodException
{    MethodInvocation methodInvocation = createMock(MethodInvocation.class);    Method method = MyFixture.class.getDeclaredMethod("operateThis");    expect(methodInvocation.getMethod()).andReturn(method);    expect(methodInvocation.getThis()).andReturn(null);    replay(methodInvocation);    assertNull(annotationResolver.getAnnotation(methodInvocation, RequiresUser.class));}
0
private AbstractAuthenticator createAuthcReturnNull()
{    return new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            return null;        }    };}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    return null;}
0
private AbstractAuthenticator createAuthcReturnValidAuthcInfo()
{    return new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            return info;        }    };}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    return info;}
0
private AuthenticationToken newToken()
{    return new UsernamePasswordToken("user1", "secret");}
0
public void setUp()
{    abstractAuthenticator = createAuthcReturnValidAuthcInfo();}
0
public void newAbstractAuthenticatorSecurityManagerConstructor()
{    abstractAuthenticator = new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            return info;        }    };}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    return info;}
0
public void authenticateWithNullArgument()
{    abstractAuthenticator.authenticate(null);}
0
public void throwAuthenticationExceptionIfDoAuthenticateReturnsNull()
{    abstractAuthenticator = createAuthcReturnNull();    abstractAuthenticator.authenticate(newToken());}
0
public void nonNullAuthenticationInfoAfterAuthenticate()
{    AuthenticationInfo authcInfo = abstractAuthenticator.authenticate(newToken());    assertNotNull(authcInfo);}
0
public void notifySuccessAfterDoAuthenticate()
{    AuthenticationListener mockListener = createMock(AuthenticationListener.class);    abstractAuthenticator.getAuthenticationListeners().add(mockListener);    AuthenticationToken token = newToken();    mockListener.onSuccess(token, info);    replay(mockListener);    abstractAuthenticator.authenticate(token);    verify(mockListener);}
0
public void notifyFailureAfterDoAuthenticateThrowsAuthenticationException()
{    AuthenticationListener mockListener = createMock(AuthenticationListener.class);    AuthenticationToken token = newToken();    final AuthenticationException ae = new AuthenticationException("dummy exception to test notification");    abstractAuthenticator = new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            throw ae;        }    };    abstractAuthenticator.getAuthenticationListeners().add(mockListener);    mockListener.onFailure(token, ae);    replay(mockListener);    boolean exceptionThrown = false;    try {        abstractAuthenticator.authenticate(token);    } catch (AuthenticationException e) {        exceptionThrown = true;        assertEquals(e, ae);    }    verify(mockListener);    if (!exceptionThrown) {        fail("An AuthenticationException should have been thrown during the notifyFailure test case.");    }}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    throw ae;}
0
public void notifyFailureAfterDoAuthenticateThrowsNonAuthenticationException()
{    abstractAuthenticator = new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            throw new IllegalArgumentException("not an AuthenticationException subclass");        }    };    AuthenticationToken token = newToken();    abstractAuthenticator.authenticate(token);}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    throw new IllegalArgumentException("not an AuthenticationException subclass");}
0
public void logExceptionAfterDoAuthenticateThrowsNonAuthenticationException()
{    Logger logger = Logger.getLogger(AbstractAuthenticator.class);        ByteArrayOutputStream out = new ByteArrayOutputStream();    Layout layout = new SimpleLayout();    Appender appender = new WriterAppender(layout, out);    logger.addAppender(appender);    final String expectedExceptionMessage = "exception thrown for test logExceptionAfterDoAuthenticateThrowsNonAuthenticationException";    abstractAuthenticator = new AbstractAuthenticator() {        protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException {            throw new IllegalArgumentException(expectedExceptionMessage);        }    };    AuthenticationToken token = newToken();    try {        abstractAuthenticator.authenticate(token);        fail("the expected AuthenticationException was not thrown");    } catch (AuthenticationException expectedException) {    }    String logMsg = out.toString();    assertTrue(logMsg.contains("WARN"));    assertTrue(logMsg.contains("java.lang.IllegalArgumentException: " + expectedExceptionMessage));    logger.removeAppender(appender);}
0
protected AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException
{    throw new IllegalArgumentException(expectedExceptionMessage);}
0
protected Class getExceptionClass()
{    return ConcurrentAccessException.class;}
0
public void testBasic()
{    CredentialsMatcher matcher = (CredentialsMatcher) ClassUtils.newInstance(getMatcherClass());    byte[] hashed = hash("password").getBytes();    AuthenticationInfo account = new SimpleAuthenticationInfo("username", hashed, "realmName");    AuthenticationToken token = new UsernamePasswordToken("username", "password");    assertTrue(matcher.doCredentialsMatch(token, account));}
0
public void testBasic()
{    assertTrue(new AllowAllCredentialsMatcher().doCredentialsMatch(null, null));}
0
public void testSaltedAuthenticationInfo()
{        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(Sha1Hash.ALGORITHM_NAME);        ByteSource salt = new SecureRandomNumberGenerator().nextBytes();    Object hashedPassword = new Sha1Hash("password", salt);    SimpleAuthenticationInfo account = new SimpleAuthenticationInfo("username", hashedPassword, salt, "realmName");        AuthenticationToken token = new UsernamePasswordToken("username", "password");        assertTrue(matcher.doCredentialsMatch(token, account));}
0
public void testBackwardsCompatibleUnsaltedAuthenticationInfo()
{    HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(Sha1Hash.ALGORITHM_NAME);        final String username = "username";    final String password = "password";    final Object hashedPassword = new Sha1Hash(password).getBytes();    AuthenticationInfo account = new AuthenticationInfo() {        public PrincipalCollection getPrincipals() {            return new SimplePrincipalCollection(username, "realmName");        }        public Object getCredentials() {            return hashedPassword;        }    };        AuthenticationToken token = new UsernamePasswordToken("username", "password");        assertTrue(matcher.doCredentialsMatch(token, account));}
0
public PrincipalCollection getPrincipals()
{    return new SimplePrincipalCollection(username, "realmName");}
0
public Object getCredentials()
{    return hashedPassword;}
0
public void testBackwardsCompatibleSaltedAuthenticationInfo()
{    HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(Sha1Hash.ALGORITHM_NAME);        matcher.setHashSalted(true);            final String username = "username";    final String password = "password";    final Object hashedPassword = new Sha1Hash(password, username).getBytes();    AuthenticationInfo account = new AuthenticationInfo() {        public PrincipalCollection getPrincipals() {            return new SimplePrincipalCollection(username, "realmName");        }        public Object getCredentials() {            return hashedPassword;        }    };        AuthenticationToken token = new UsernamePasswordToken("username", "password");        assertTrue(matcher.doCredentialsMatch(token, account));}
0
public PrincipalCollection getPrincipals()
{    return new SimplePrincipalCollection(username, "realmName");}
0
public Object getCredentials()
{    return hashedPassword;}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Md2CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Md2Hash(credentials);}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Md5CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Md5Hash(credentials);}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Sha1CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Sha1Hash(credentials);}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Sha256CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Sha256Hash(credentials);}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Sha384CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Sha384Hash(credentials);}
0
public Class<? extends HashedCredentialsMatcher> getMatcherClass()
{    return Sha512CredentialsMatcher.class;}
0
public AbstractHash hash(Object credentials)
{    return new Sha512Hash(credentials);}
0
protected Class getExceptionClass()
{    return ExcessiveAttemptsException.class;}
0
protected Class getExceptionClass()
{    return ExpiredCredentialsException.class;}
0
protected Class getExceptionClass()
{    return IncorrectCredentialsException.class;}
0
protected Class getExceptionClass()
{    return LockedAccountException.class;}
0
public void setUp()
{    strategy = new AllSuccessfulStrategy();}
0
public void beforeAllAttempts()
{    AuthenticationInfo info = strategy.beforeAllAttempts(null, null);    assertNotNull(info);}
0
public void beforeAttemptSupportingToken()
{    new SimpleAccountRealm();}
0
public void beforeAttemptRealmDoesntSupportToken()
{    Realm notSupportingRealm = new AuthorizingRealm() {        public boolean supports(AuthenticationToken token) {            return false;        }        protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {            return null;        }        protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) {            return null;        }    };    strategy.beforeAttempt(notSupportingRealm, null, null);}
0
public boolean supports(AuthenticationToken token)
{    return false;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    return null;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal)
{    return null;}
0
public void setUp()
{    strategy = new FirstSuccessfulStrategy();}
0
public void beforeAllAttempts()
{    AuthenticationInfo authenticationInfo = strategy.beforeAllAttempts(null, null);    assertNull(authenticationInfo);}
0
public void testMergeWithValidAggregateInfo()
{    AuthenticationInfo aggregate = new MergableAuthenticationInfo() {        @Override        public void merge(AuthenticationInfo info) {        }        @Override        public PrincipalCollection getPrincipals() {            return new SimplePrincipalCollection("principals", "realmName");        }        @Override        public Object getCredentials() {            return null;        }    };    AuthenticationInfo mergeResult = strategy.merge(new SimpleAuthenticationInfo(), aggregate);    assertEquals(aggregate, mergeResult);}
0
public void merge(AuthenticationInfo info)
{}
0
public PrincipalCollection getPrincipals()
{    return new SimplePrincipalCollection("principals", "realmName");}
0
public Object getCredentials()
{    return null;}
0
public void testMergeWithInvalidAggregateInfo()
{    AuthenticationInfo aggregate = new MergableAuthenticationInfo() {        @Override        public void merge(AuthenticationInfo info) {        }        @Override        public PrincipalCollection getPrincipals() {            return new SimplePrincipalCollection();        }        @Override        public Object getCredentials() {            return null;        }    };    AuthenticationInfo authInfo = new SimpleAuthenticationInfo();    AuthenticationInfo mergeResult = strategy.merge(authInfo, aggregate);    assertEquals(authInfo, mergeResult);}
0
public void merge(AuthenticationInfo info)
{}
0
public PrincipalCollection getPrincipals()
{    return new SimplePrincipalCollection();}
0
public Object getCredentials()
{    return null;}
0
public void testMergeWithEmptyInstances()
{    SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();    SimpleAuthenticationInfo local = new SimpleAuthenticationInfo();    aggregate.merge(local);}
0
public void testMergeWithAggregateNullCredentials()
{    SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();    SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");    aggregate.merge(local);}
0
public void testMergeWithImmutablePrincipalCollection()
{    SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();        PrincipalCollection principalCollection = new PrincipalCollection() {        @SuppressWarnings("unchecked")        public List asList() {            return null;        }        @SuppressWarnings("unchecked")        public Set asSet() {            return null;        }        public <T> Collection<T> byType(Class<T> type) {            return null;        }        @SuppressWarnings("unchecked")        public Collection fromRealm(String realmName) {            Collection<Object> principals = new HashSet<Object>();            principals.add("testprincipal");            return principals;        }        public Object getPrimaryPrincipal() {            return null;        }        public Set<String> getRealmNames() {            Set<String> realms = new HashSet<String>();            realms.add("testrealm");            return realms;        }        public boolean isEmpty() {            return false;        }        public <T> T oneByType(Class<T> type) {            return null;        }        @SuppressWarnings("unchecked")        public Iterator iterator() {            return null;        }    };    aggregate.setPrincipals(principalCollection);    SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");    aggregate.merge(local);    assertEquals(2, aggregate.getPrincipals().asList().size());}
0
public List asList()
{    return null;}
0
public Set asSet()
{    return null;}
0
public Collection<T> byType(Class<T> type)
{    return null;}
0
public Collection fromRealm(String realmName)
{    Collection<Object> principals = new HashSet<Object>();    principals.add("testprincipal");    return principals;}
0
public Object getPrimaryPrincipal()
{    return null;}
0
public Set<String> getRealmNames()
{    Set<String> realms = new HashSet<String>();    realms.add("testrealm");    return realms;}
0
public boolean isEmpty()
{    return false;}
0
public T oneByType(Class<T> type)
{    return null;}
0
public Iterator iterator()
{    return null;}
0
protected Class getExceptionClass()
{    return UnknownAccountException.class;}
0
public void testGuestSinglePermissionAssertion() throws Throwable
{    PermissionAnnotationHandler handler = new PermissionAnnotationHandler();    Annotation requiresPermissionAnnotation = new RequiresPermissions() {        public String[] value() {            return new String[] { "test:test" };        }        public Class<? extends Annotation> annotationType() {            return RequiresPermissions.class;        }        public Logical logical() {            return Logical.AND;        }    };    handler.assertAuthorized(requiresPermissionAnnotation);}
0
public String[] value()
{    return new String[] { "test:test" };}
0
public Class<? extends Annotation> annotationType()
{    return RequiresPermissions.class;}
0
public Logical logical()
{    return Logical.AND;}
0
public void testGuestMultiplePermissionAssertion() throws Throwable
{    PermissionAnnotationHandler handler = new PermissionAnnotationHandler();    Annotation requiresPermissionAnnotation = new RequiresPermissions() {        public String[] value() {            return new String[] { "test:test", "test2:test2" };        }        public Class<? extends Annotation> annotationType() {            return RequiresPermissions.class;        }        public Logical logical() {            return Logical.AND;        }    };    handler.assertAuthorized(requiresPermissionAnnotation);}
0
public String[] value()
{    return new String[] { "test:test", "test2:test2" };}
0
public Class<? extends Annotation> annotationType()
{    return RequiresPermissions.class;}
0
public Logical logical()
{    return Logical.AND;}
0
public void testGuestSingleRoleAssertion() throws Throwable
{    RoleAnnotationHandler handler = new RoleAnnotationHandler();    Annotation requiresRolesAnnotation = new RequiresRoles() {        public String[] value() {            return new String[] { "blah" };        }        public Class<? extends Annotation> annotationType() {            return RequiresRoles.class;        }        public Logical logical() {            return Logical.AND;        }    };    handler.assertAuthorized(requiresRolesAnnotation);}
0
public String[] value()
{    return new String[] { "blah" };}
0
public Class<? extends Annotation> annotationType()
{    return RequiresRoles.class;}
0
public Logical logical()
{    return Logical.AND;}
0
public void testGuestMultipleRolesAssertion() throws Throwable
{    RoleAnnotationHandler handler = new RoleAnnotationHandler();    Annotation requiresRolesAnnotation = new RequiresRoles() {        public String[] value() {            return new String[] { "blah", "blah2" };        }        public Class<? extends Annotation> annotationType() {            return RequiresRoles.class;        }        public Logical logical() {            return Logical.AND;        }    };    handler.assertAuthorized(requiresRolesAnnotation);}
0
public String[] value()
{    return new String[] { "blah", "blah2" };}
0
public Class<? extends Annotation> annotationType()
{    return RequiresRoles.class;}
0
public Logical logical()
{    return Logical.AND;}
0
public void testOneOfTheRolesRequired() throws Throwable
{    subject = createMock(Subject.class);    expect(subject.hasRole("blah")).andReturn(true);    expect(subject.hasRole("blah2")).andReturn(false);    replay(subject);    RoleAnnotationHandler handler = new RoleAnnotationHandler() {        @Override        protected Subject getSubject() {            return subject;        }    };    Annotation requiresRolesAnnotation = new RequiresRoles() {        public String[] value() {            return new String[] { "blah", "blah2" };        }        public Class<? extends Annotation> annotationType() {            return RequiresRoles.class;        }        public Logical logical() {            return Logical.OR;        }    };    handler.assertAuthorized(requiresRolesAnnotation);}
0
protected Subject getSubject()
{    return subject;}
0
public String[] value()
{    return new String[] { "blah", "blah2" };}
0
public Class<? extends Annotation> annotationType()
{    return RequiresRoles.class;}
0
public Logical logical()
{    return Logical.OR;}
0
protected Class getExceptionClass()
{    return AuthorizationException.class;}
0
protected Class getExceptionClass()
{    return HostUnauthorizedException.class;}
0
public void testSettingOfRolePermissionResolver()
{    Collection<Realm> realms = new ArrayList<Realm>();    realms.add(new MockAuthorizingRealm());    realms.add(new MockAuthorizingRealm());        for (Realm realm : realms) {        assertNull(((AuthorizingRealm) realm).getRolePermissionResolver());    }    ModularRealmAuthorizer modRealmAuthz = new ModularRealmAuthorizer();    modRealmAuthz.setRealms(realms);        for (Realm realm : realms) {        assertNull(((AuthorizingRealm) realm).getRolePermissionResolver());    }        RolePermissionResolver rolePermissionResolver = new RolePermissionResolver() {        public Collection<Permission> resolvePermissionsInRole(String roleString) {            return null;        }    };    modRealmAuthz.setRolePermissionResolver(rolePermissionResolver);        for (Realm realm : realms) {                assertTrue(((AuthorizingRealm) realm).getRolePermissionResolver() == rolePermissionResolver);    }        MockAuthorizingRealm mockRealm = new MockAuthorizingRealm();    realms.add(mockRealm);    modRealmAuthz.setRealms(realms);    assertTrue(((AuthorizingRealm) mockRealm).getRolePermissionResolver() == rolePermissionResolver);}
0
public Collection<Permission> resolvePermissionsInRole(String roleString)
{    return null;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    return null;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    return null;}
0
public void testNullArgument()
{    assertTrue(new AllPermission().implies(null));}
0
public void testNonNullArgument()
{    assertTrue(new AllPermission().implies(new AllPermission()));}
0
public void testDefaultConstructor()
{    DomainPermission p;    List<Set<String>> parts;    Set<String> set;    String entry;        p = new DomainPermission();        assertTrue("domain".equals(p.getDomain()));        set = p.getActions();    assertNull(set);        set = p.getTargets();    assertNull(set);        parts = p.getParts();    assertEquals("Number of parts", 1, parts.size());    set = parts.get(0);    assertEquals(1, set.size());    entry = set.iterator().next();    assertEquals("domain", entry);}
0
public void testActionsConstructorWithSingleAction()
{    DomainPermission p;    List<Set<String>> parts;    Set<String> set;    Iterator<String> iterator;    String entry;        p = new DomainPermission("action1");        assertEquals("domain", p.getDomain());        set = p.getActions();    assertNotNull(set);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);        set = p.getTargets();    assertNull(set);        parts = p.getParts();    assertEquals(2, parts.size());    set = parts.get(0);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("domain", entry);    set = parts.get(1);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);}
0
public void testActionsConstructorWithMultipleActions()
{    DomainPermission p;    List<Set<String>> parts;    Set<String> set;    Iterator<String> iterator;    String entry;        p = new DomainPermission("action1,action2,action3");        assertEquals("domain", p.getDomain());        set = p.getActions();    assertNotNull(set);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);    entry = iterator.next();    assertEquals("action2", entry);    entry = iterator.next();    assertEquals("action3", entry);        set = p.getTargets();    assertNull(set);        parts = p.getParts();    assertEquals(2, parts.size());    set = parts.get(0);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("domain", entry);    set = parts.get(1);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);    entry = iterator.next();    assertEquals("action2", entry);    entry = iterator.next();    assertEquals("action3", entry);}
0
public void testActionsTargetsConstructorWithSingleActionAndTarget()
{    DomainPermission p;    List<Set<String>> parts;    Set<String> set;    Iterator<String> iterator;    String entry;        p = new DomainPermission("action1", "target1");        assertEquals("domain", p.getDomain());        set = p.getActions();    assertNotNull(set);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);        set = p.getTargets();    assertNotNull(set);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("target1", entry);        parts = p.getParts();    assertEquals(3, parts.size());    set = parts.get(0);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("domain", entry);    set = parts.get(1);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);    set = parts.get(2);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("target1", entry);}
0
public void testActionsTargetsConstructorWithMultipleActionsAndTargets()
{    DomainPermission p;    List<Set<String>> parts;    Set<String> set;    Iterator<String> iterator;    String entry;        p = new DomainPermission("action1,action2,action3", "target1,target2,target3");        assertEquals("domain", p.getDomain());        set = p.getActions();    assertNotNull(set);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);    entry = iterator.next();    assertEquals("action2", entry);    entry = iterator.next();    assertEquals("action3", entry);        set = p.getTargets();    assertNotNull(set);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("target1", entry);    entry = iterator.next();    assertEquals("target2", entry);    entry = iterator.next();    assertEquals("target3", entry);        parts = p.getParts();    assertEquals(3, parts.size());    set = parts.get(0);    assertEquals(1, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("domain", entry);    set = parts.get(1);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("action1", entry);    entry = iterator.next();    assertEquals("action2", entry);    entry = iterator.next();    assertEquals("action3", entry);    set = parts.get(2);    assertEquals(3, set.size());    iterator = set.iterator();    entry = iterator.next();    assertEquals("target1", entry);    entry = iterator.next();    assertEquals("target2", entry);    entry = iterator.next();    assertEquals("target3", entry);}
0
public void testDefaultIsNonCaseSensitive()
{    WildcardPermissionResolver resolver = new WildcardPermissionResolver();    assertFalse("Default sensitivity should be false", resolver.isCaseSensitive());    /* this is a round-about test as permissions don't store case sensitivity just lower case         the string. */    WildcardPermission permission = (WildcardPermission) resolver.resolvePermission("Foo:*");    assertEquals("string should be lowercase", "foo:*", permission.toString());}
0
public void testCaseSensitive()
{    WildcardPermissionResolver resolver = new WildcardPermissionResolver(true);    assertTrue("Sensitivity should be true", resolver.isCaseSensitive());    /* this is a round-about test as permissions don't store case sensitivity just lower case         the string. */    WildcardPermission permission = (WildcardPermission) resolver.resolvePermission("Foo:*");    assertEquals("string should be mixed case", "Foo:*", permission.toString());}
0
public void testCaseInsensitive()
{    WildcardPermissionResolver resolver = new WildcardPermissionResolver(false);    assertFalse("Sensitivity should be false", resolver.isCaseSensitive());    /* this is a round-about test as permissions don't store case sensitivity just lower case         the string. */    WildcardPermission permission = (WildcardPermission) resolver.resolvePermission("Foo:*");    assertEquals("string should be lowercase", "foo:*", permission.toString());}
0
public void testCaseSensitiveToggle()
{    WildcardPermissionResolver resolver = new WildcardPermissionResolver();    assertFalse("Default sensitivity should be false", resolver.isCaseSensitive());    resolver.setCaseSensitive(true);    assertTrue("Sensitivity should be true", resolver.isCaseSensitive());    resolver.setCaseSensitive(false);    assertFalse("Sensitivity should be false", resolver.isCaseSensitive());}
0
public void testNull()
{    new WildcardPermission(null);}
0
public void testEmpty()
{    new WildcardPermission("");}
0
public void testBlank()
{    new WildcardPermission("   ");}
0
public void testOnlyDelimiters()
{    new WildcardPermission("::,,::,:");}
0
public void testNamed()
{    WildcardPermission p1, p2;        p1 = new WildcardPermission("something");    p2 = new WildcardPermission("something");    assertTrue(p1.implies(p2));    assertTrue(p2.implies(p1));        p1 = new WildcardPermission("something");    p2 = new WildcardPermission("SOMETHING");    assertTrue(p1.implies(p2));    assertTrue(p2.implies(p1));        p1 = new WildcardPermission("something");    p2 = new WildcardPermission("else");    assertFalse(p1.implies(p2));    assertFalse(p2.implies(p1));        p1 = new WildcardPermission("BLAHBLAH", false);    p2 = new WildcardPermission("BLAHBLAH", false);    assertTrue(p1.implies(p2));    assertTrue(p2.implies(p1));        p1 = new WildcardPermission("BLAHBLAH", false);    p2 = new WildcardPermission("bLAHBLAH", false);    assertTrue(p1.implies(p2));    assertTrue(p2.implies(p1));        p1 = new WildcardPermission("BLAHBLAH", false);    p2 = new WildcardPermission("whatwhat", false);    assertFalse(p1.implies(p2));    assertFalse(p2.implies(p1));}
0
public void testLists()
{    WildcardPermission p1, p2, p3;    p1 = new WildcardPermission("one,two");    p2 = new WildcardPermission("one");    assertTrue(p1.implies(p2));    assertFalse(p2.implies(p1));    p1 = new WildcardPermission("one,two,three");    p2 = new WildcardPermission("one,three");    assertTrue(p1.implies(p2));    assertFalse(p2.implies(p1));    p1 = new WildcardPermission("one,two:one,two,three");    p2 = new WildcardPermission("one:three");    p3 = new WildcardPermission("one:two,three");    assertTrue(p1.implies(p2));    assertFalse(p2.implies(p1));    assertTrue(p1.implies(p3));    assertFalse(p2.implies(p3));    assertTrue(p3.implies(p2));    p1 = new WildcardPermission("one,two,three:one,two,three:one,two");    p2 = new WildcardPermission("one:three:two");    assertTrue(p1.implies(p2));    assertFalse(p2.implies(p1));    p1 = new WildcardPermission("one");    p2 = new WildcardPermission("one:two,three,four");    p3 = new WildcardPermission("one:two,three,four:five:six:seven");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertFalse(p2.implies(p1));    assertFalse(p3.implies(p1));    assertTrue(p2.implies(p3));}
0
public void testListDifferentOrder()
{    WildcardPermission p6 = new WildcardPermission("one,two:three,four");    WildcardPermission p6DiffOrder = new WildcardPermission("two,one:four,three");    assertTrue(p6.equals(p6DiffOrder));}
0
public void testWildcards()
{    WildcardPermission p1, p2, p3, p4, p5, p6, p7, p8, p9;    p1 = new WildcardPermission("*");    p2 = new WildcardPermission("one");    p3 = new WildcardPermission("one:two");    p4 = new WildcardPermission("one,two:three,four");    p5 = new WildcardPermission("one,two:three,four,five:six:seven,eight");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p1.implies(p5));    p1 = new WildcardPermission("newsletter:*");    p2 = new WildcardPermission("newsletter:read");    p3 = new WildcardPermission("newsletter:read,write");    p4 = new WildcardPermission("newsletter:*");    p5 = new WildcardPermission("newsletter:*:*");    p6 = new WildcardPermission("newsletter:*:read");    p7 = new WildcardPermission("newsletter:write:*");    p8 = new WildcardPermission("newsletter:read,write:*");    p9 = new WildcardPermission("newsletter");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p1.implies(p5));    assertTrue(p1.implies(p6));    assertTrue(p1.implies(p7));    assertTrue(p1.implies(p8));    assertTrue(p1.implies(p9));    p1 = new WildcardPermission("newsletter:*:*");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p1.implies(p5));    assertTrue(p1.implies(p6));    assertTrue(p1.implies(p7));    assertTrue(p1.implies(p8));    assertTrue(p1.implies(p9));    p1 = new WildcardPermission("newsletter:*:*:*");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p1.implies(p5));    assertTrue(p1.implies(p6));    assertTrue(p1.implies(p7));    assertTrue(p1.implies(p8));    assertTrue(p1.implies(p9));    p1 = new WildcardPermission("newsletter");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p1.implies(p5));    assertTrue(p1.implies(p6));    assertTrue(p1.implies(p7));    assertTrue(p1.implies(p8));    assertTrue(p1.implies(p9));    p1 = new WildcardPermission("newsletter:*:read");    p2 = new WildcardPermission("newsletter:123:read");    p3 = new WildcardPermission("newsletter:123,456:read,write");    p4 = new WildcardPermission("newsletter:read");    p5 = new WildcardPermission("newsletter:read,write");    p6 = new WildcardPermission("newsletter:123:read:write");    assertTrue(p1.implies(p2));    assertFalse(p1.implies(p3));    assertFalse(p1.implies(p4));    assertFalse(p1.implies(p5));    assertTrue(p1.implies(p6));    p1 = new WildcardPermission("newsletter:*:read:*");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p6));}
0
public void testToString()
{    WildcardPermission p1 = new WildcardPermission("*");    WildcardPermission p2 = new WildcardPermission("one");    WildcardPermission p3 = new WildcardPermission("one:two");    WildcardPermission p4 = new WildcardPermission("one,two:three,four");    WildcardPermission p5 = new WildcardPermission("one,two:three,four,five:six:seven,eight");    assertTrue("*".equals(p1.toString()));    assertTrue(p1.equals(new WildcardPermission(p1.toString())));    assertTrue("one".equals(p2.toString()));    assertTrue(p2.equals(new WildcardPermission(p2.toString())));    assertTrue("one:two".equals(p3.toString()));    assertTrue(p3.equals(new WildcardPermission(p3.toString())));    assertTrue("one,two:three,four".equals(p4.toString()));    assertTrue(p4.equals(new WildcardPermission(p4.toString())));    assertTrue("one,two:three,four,five:six:seven,eight".equals(p5.toString()));    assertTrue(p5.equals(new WildcardPermission(p5.toString())));}
0
public void testWildcardLeftTermination()
{    WildcardPermission p1, p2, p3, p4;    p1 = new WildcardPermission("one");    p2 = new WildcardPermission("one:*");    p3 = new WildcardPermission("one:*:*");    p4 = new WildcardPermission("one:read");    assertTrue(p1.implies(p2));    assertTrue(p1.implies(p3));    assertTrue(p1.implies(p4));    assertTrue(p2.implies(p1));    assertTrue(p2.implies(p3));    assertTrue(p2.implies(p4));    assertTrue(p3.implies(p1));    assertTrue(p3.implies(p2));    assertTrue(p3.implies(p4));    assertFalse(p4.implies(p1));    assertFalse(p4.implies(p2));    assertFalse(p4.implies(p3));}
0
protected Class getExceptionClass()
{    return UnauthenticatedException.class;}
0
protected Class getExceptionClass()
{    return UnauthorizedException.class;}
0
public void testSubmitRunnable()
{    ExecutorService mockExecutorService = createNiceMock(ExecutorService.class);    expect(mockExecutorService.submit(isA(SubjectRunnable.class))).andReturn(new DummyFuture());    replay(mockExecutorService);    final SubjectAwareExecutorService executor = new SubjectAwareExecutorService(mockExecutorService);    Runnable testRunnable = new Runnable() {        public void run() {            System.out.println("Hello World");        }    };    executor.submit(testRunnable);    verify(mockExecutorService);}
0
public void run()
{    System.out.println("Hello World");}
0
public boolean cancel(boolean b)
{    return false;}
0
public boolean isCancelled()
{    return false;}
0
public boolean isDone()
{    return true;}
0
public V get() throws InterruptedException, ExecutionException
{    return null;}
0
public V get(long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException
{    return null;}
0
public void testExecute()
{    Executor targetMockExecutor = createNiceMock(Executor.class);            targetMockExecutor.execute(isA(SubjectRunnable.class));    replay(targetMockExecutor);    final SubjectAwareExecutor executor = new SubjectAwareExecutor(targetMockExecutor);    Runnable work = new Runnable() {        public void run() {            System.out.println("Hello World");        }    };    executor.execute(work);    verify(targetMockExecutor);}
0
public void run()
{    System.out.println("Hello World");}
0
protected Cache createCache(String name) throws CacheException
{    return new HashMapCache<K, V>(name);}
0
public void testNoArgConstructor()
{    ClassUtils.newInstance(getExceptionClass());}
0
public void testMsgConstructor() throws Exception
{    ClassUtils.newInstance(getExceptionClass(), "Msg");}
0
public void testCauseConstructor() throws Exception
{    ClassUtils.newInstance(getExceptionClass(), new Throwable());}
0
public void testMsgCauseConstructor()
{    ClassUtils.newInstance(getExceptionClass(), "Msg", new Throwable());}
0
protected Class getExceptionClass()
{    return SerializationException.class;}
0
public void testGetInstanceWithType() throws Exception
{    final String name = "my/jndi/resource";    final String returnValue = "jndiString";    JndiObjectFactory<String> underTest = new JndiObjectFactory<String>() {        @Override        protected Object lookup(String jndiName, Class requiredType) throws NamingException {            assertEquals(name, jndiName);            assertEquals(String.class, requiredType);            return new String(returnValue);        }    };    underTest.setRequiredType(String.class);    underTest.setResourceName(name);    assertEquals(returnValue, underTest.getInstance());}
0
protected Object lookup(String jndiName, Class requiredType) throws NamingException
{    assertEquals(name, jndiName);    assertEquals(String.class, requiredType);    return new String(returnValue);}
0
public void testGetInstanceNoType() throws Exception
{    final String name = "my/jndi/resource";    final String returnValue = "jndiString";    JndiObjectFactory<String> underTest = new JndiObjectFactory<String>() {        @Override        protected Object lookup(String jndiName) throws NamingException {            assertEquals(name, jndiName);            return new String(returnValue);        }    };    underTest.setResourceName(name);    assertEquals(returnValue, underTest.getInstance());}
0
protected Object lookup(String jndiName) throws NamingException
{    assertEquals(name, jndiName);    return new String(returnValue);}
0
public void testJndiLookupFailsWithType() throws Exception
{    final String name = "my/jndi/resource";    JndiObjectFactory<String> underTest = new JndiObjectFactory<String>() {        @Override        protected Object lookup(String jndiName, Class requiredType) throws NamingException {            throw new NamingException("No resource named " + jndiName);        }    };    underTest.setResourceName(name);    underTest.setRequiredType(String.class);    underTest.getInstance();}
0
protected Object lookup(String jndiName, Class requiredType) throws NamingException
{    throw new NamingException("No resource named " + jndiName);}
0
public void testJndiLookupFailsNoType() throws Exception
{    final String name = "my/jndi/resource";    JndiObjectFactory<String> underTest = new JndiObjectFactory<String>() {        @Override        protected Object lookup(String jndiName) throws NamingException {            throw new NamingException("No resource named " + jndiName);        }    };    underTest.setResourceName(name);    underTest.getInstance();}
0
protected Object lookup(String jndiName) throws NamingException
{    throw new NamingException("No resource named " + jndiName);}
0
public void testGetRememberedPrincipalsWithEmptySerializedBytes()
{    AbstractRememberMeManager rmm = new DummyRememberMeManager();            PrincipalCollection principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());    assertNull(principals);        rmm = new DummyRememberMeManager() {        @Override        protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {            return null;        }    };    principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());    assertNull(principals);}
0
protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext)
{    return null;}
0
public void forgetIdentity(SubjectContext subjectContext)
{}
0
protected void forgetIdentity(Subject subject)
{}
0
protected void rememberSerializedIdentity(Subject subject, byte[] serialized)
{}
0
protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext)
{    return new byte[0];}
0
public void tearDown()
{    ThreadContext.remove();}
0
protected Subject newSubject(SecurityManager securityManager)
{    Subject subject = new Subject.Builder(securityManager).buildSubject();    threadState = new SubjectThreadState(subject);    threadState.bind();    return subject;}
0
public void setup()
{    sm = new DefaultSecurityManager();    Ini ini = new Ini();    Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);    section.put("guest", "guest, guest");    section.put("lonestarr", "vespa, goodguy");    sm.setRealm(new IniRealm(ini));    SecurityUtils.setSecurityManager(sm);}
0
public void tearDown()
{    SecurityUtils.setSecurityManager(null);    sm.destroy();    super.tearDown();}
0
public void testDefaultConfig()
{    Subject subject = SecurityUtils.getSubject();    AuthenticationToken token = new UsernamePasswordToken("guest", "guest");    subject.login(token);    assertTrue(subject.isAuthenticated());    assertTrue("guest".equals(subject.getPrincipal()));    assertTrue(subject.hasRole("guest"));    Session session = subject.getSession();    session.setAttribute("key", "value");    assertEquals(session.getAttribute("key"), "value");    subject.logout();    assertNull(subject.getSession(false));    assertNull(subject.getPrincipal());    assertNull(subject.getPrincipals());}
0
public void testAutoCreateSessionAfterInvalidation()
{    Subject subject = SecurityUtils.getSubject();    Session session = subject.getSession();    Serializable origSessionId = session.getId();    String key = "foo";    String value1 = "bar";    session.setAttribute(key, value1);    assertEquals(value1, session.getAttribute(key));        session.setTimeout(50);    try {        Thread.sleep(150);    } catch (InterruptedException e) {        }    try {        session.setTimeout(AbstractValidatingSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);        fail("Session should have expired.");    } catch (ExpiredSessionException expected) {    }}
0
public void testSubjectReuseAfterLogout()
{    Subject subject = SecurityUtils.getSubject();    AuthenticationToken token = new UsernamePasswordToken("guest", "guest");    subject.login(token);    assertTrue(subject.isAuthenticated());    assertTrue("guest".equals(subject.getPrincipal()));    assertTrue(subject.hasRole("guest"));    Session session = subject.getSession();    Serializable firstSessionId = session.getId();    session.setAttribute("key", "value");    assertEquals(session.getAttribute("key"), "value");    subject.logout();    assertNull(subject.getSession(false));    assertNull(subject.getPrincipal());    assertNull(subject.getPrincipals());    subject.login(new UsernamePasswordToken("lonestarr", "vespa"));    assertTrue(subject.isAuthenticated());    assertTrue("lonestarr".equals(subject.getPrincipal()));    assertTrue(subject.hasRole("goodguy"));    assertNotNull(subject.getSession());    assertFalse(firstSessionId.equals(subject.getSession().getId()));    subject.logout();    assertNull(subject.getSession(false));    assertNull(subject.getPrincipal());    assertNull(subject.getPrincipals());}
0
public void testNewSubjectWithoutThreadSecurityManager()
{        SecurityUtils.setSecurityManager(null);    try {        SecurityUtils.getSecurityManager();    } catch (UnavailableSecurityManagerException e) {        assertTrue(e.getMessage().startsWith("No SecurityManager accessible"));    }        DelegatingSubject subject = (DelegatingSubject) (new Subject.Builder(sm)).buildSubject();        AuthenticationToken token = new UsernamePasswordToken("guest", "guest");    subject.login(token);    assertEquals(sm, subject.getSecurityManager());}
0
public void setUp()
{    ThreadContext.remove();}
0
public void tearDown()
{    ThreadContext.remove();}
0
public void testVMSingleton()
{    DefaultSecurityManager sm = new DefaultSecurityManager();    Ini ini = new Ini();    Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);    section.put("guest", "guest");    sm.setRealm(new IniRealm(ini));    SecurityUtils.setSecurityManager(sm);    try {        Subject subject = SecurityUtils.getSubject();        AuthenticationToken token = new UsernamePasswordToken("guest", "guest");        subject.login(token);        subject.getSession().setAttribute("key", "value");        assertTrue(subject.getSession().getAttribute("key").equals("value"));        subject = SecurityUtils.getSubject();        assertTrue(subject.isAuthenticated());        assertTrue(subject.getSession().getAttribute("key").equals("value"));    } finally {        sm.destroy();                SecurityUtils.setSecurityManager(null);    }}
0
public void setup()
{    ThreadContext.remove();    realm = new TestActiveDirectoryRealm();    securityManager = new DefaultSecurityManager(realm);    SecurityUtils.setSecurityManager(securityManager);}
0
public void tearDown()
{    SecurityUtils.setSecurityManager(null);    securityManager.destroy();    ThreadContext.remove();}
0
public void testDefaultConfig()
{    String localhost = "localhost";    Subject subject = SecurityUtils.getSubject();    subject.login(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));    assertTrue(subject.isAuthenticated());    assertTrue(subject.hasRole(ROLE));    UsernamePrincipal usernamePrincipal = subject.getPrincipals().oneByType(UsernamePrincipal.class);    assertTrue(usernamePrincipal.getUsername().equals(USERNAME));    UserIdPrincipal userIdPrincipal = subject.getPrincipals().oneByType(UserIdPrincipal.class);    assertTrue(userIdPrincipal.getUserId() == USER_ID);    assertTrue(realm.hasRole(subject.getPrincipals(), ROLE));    subject.logout();}
0
public boolean doCredentialsMatch(AuthenticationToken object, AuthenticationInfo object1)
{    return true;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    SimpleAccount account = (SimpleAccount) super.doGetAuthenticationInfo(token);    if (account != null) {        SimplePrincipalCollection principals = new SimplePrincipalCollection();        principals.add(new UserIdPrincipal(USER_ID), getName());        principals.add(new UsernamePrincipal(USERNAME), getName());        account.setPrincipals(principals);    }    return account;}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    Set<String> roles = new HashSet<String>();    roles.add(ROLE);    return new SimpleAuthorizationInfo(roles);}
0
protected AuthenticationInfo queryForAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException
{    return new SimpleAccount(token.getPrincipal(), token.getCredentials(), getName());}
0
public void setup()
{    realm = new AllowAllRealm();}
0
public void tearDown()
{    realm = null;}
0
public void testDefaultConfig()
{    AuthenticationInfo info = realm.getAuthenticationInfo(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));    assertNotNull(info);    assertTrue(realm.hasRole(info.getPrincipals(), ROLE));    Object principal = info.getPrincipals().getPrimaryPrincipal();    assertTrue(principal instanceof UserIdPrincipal);    UsernamePrincipal usernamePrincipal = info.getPrincipals().oneByType(UsernamePrincipal.class);    assertTrue(usernamePrincipal.getUsername().equals(USERNAME));    UserIdPrincipal userIdPrincipal = info.getPrincipals().oneByType(UserIdPrincipal.class);    assertTrue(userIdPrincipal.getUserId() == USER_ID);    String stringPrincipal = info.getPrincipals().oneByType(String.class);    assertTrue(stringPrincipal.equals(USER_ID + USERNAME));}
0
public void testCreateAccountOverride()
{    AuthorizingRealm realm = new AllowAllRealm() {        @Override        protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object credentials) {            String username = (String) principal;            UsernamePrincipal customPrincipal = new UsernamePrincipal(username);            return new SimpleAccount(customPrincipal, credentials, getName());        }    };    AuthenticationInfo info = realm.getAuthenticationInfo(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));    assertNotNull(info);    assertTrue(realm.hasRole(info.getPrincipals(), ROLE));    Object principal = info.getPrincipals().getPrimaryPrincipal();    assertTrue(principal instanceof UsernamePrincipal);    assertEquals(USERNAME, ((UsernamePrincipal) principal).getUsername());}
0
protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object credentials)
{    String username = (String) principal;    UsernamePrincipal customPrincipal = new UsernamePrincipal(username);    return new SimpleAccount(customPrincipal, credentials, getName());}
0
public void testNullAuthzInfo()
{    AuthorizingRealm realm = new AuthorizingRealm() {        protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {            return null;        }        protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {            return null;        }    };    Principal principal = new UsernamePrincipal("blah");    PrincipalCollection pCollection = new SimplePrincipalCollection(principal, "nullAuthzRealm");    List<Permission> permList = new ArrayList<Permission>();    permList.add(new WildcardPermission("stringPerm1"));    permList.add(new WildcardPermission("stringPerm2"));    List<String> roleList = new ArrayList<String>();    roleList.add("role1");    roleList.add("role2");    boolean thrown = false;    try {        realm.checkPermission(pCollection, "stringPermission");    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        realm.checkPermission(pCollection, new WildcardPermission("stringPermission"));    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        realm.checkPermissions(pCollection, "stringPerm1", "stringPerm2");    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        realm.checkPermissions(pCollection, permList);    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        realm.checkRole(pCollection, "role1");    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        realm.checkRoles(pCollection, roleList);    } catch (UnauthorizedException e) {        thrown = true;    }    assertTrue(thrown);    assertFalse(realm.hasAllRoles(pCollection, roleList));    assertFalse(realm.hasRole(pCollection, "role1"));    assertArrayEquals(new boolean[] { false, false }, realm.hasRoles(pCollection, roleList));    assertFalse(realm.isPermitted(pCollection, "perm1"));    assertFalse(realm.isPermitted(pCollection, new WildcardPermission("perm1")));    assertArrayEquals(new boolean[] { false, false }, realm.isPermitted(pCollection, "perm1", "perm2"));    assertArrayEquals(new boolean[] { false, false }, realm.isPermitted(pCollection, permList));    assertFalse(realm.isPermittedAll(pCollection, "perm1", "perm2"));    assertFalse(realm.isPermittedAll(pCollection, permList));}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    return null;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    return null;}
0
public void testRealmWithRolePermissionResolver()
{    Principal principal = new UsernamePrincipal("rolePermResolver");    PrincipalCollection pCollection = new SimplePrincipalCollection(principal, "testRealmWithRolePermissionResolver");    AuthorizingRealm realm = new AllowAllRealm();    realm.setRolePermissionResolver(new RolePermissionResolver() {        public Collection<Permission> resolvePermissionsInRole(String roleString) {            Collection<Permission> permissions = new HashSet<Permission>();            if (roleString.equals(ROLE)) {                permissions.add(new WildcardPermission(ROLE + ":perm1"));                permissions.add(new WildcardPermission(ROLE + ":perm2"));                permissions.add(new WildcardPermission("other:*:foo"));            }            return permissions;        }    });    assertTrue(realm.hasRole(pCollection, ROLE));    assertTrue(realm.isPermitted(pCollection, ROLE + ":perm1"));    assertTrue(realm.isPermitted(pCollection, ROLE + ":perm2"));    assertFalse(realm.isPermitted(pCollection, ROLE + ":perm3"));    assertTrue(realm.isPermitted(pCollection, "other:bar:foo"));}
0
public Collection<Permission> resolvePermissionsInRole(String roleString)
{    Collection<Permission> permissions = new HashSet<Permission>();    if (roleString.equals(ROLE)) {        permissions.add(new WildcardPermission(ROLE + ":perm1"));        permissions.add(new WildcardPermission(ROLE + ":perm2"));        permissions.add(new WildcardPermission("other:*:foo"));    }    return permissions;}
0
public void testRealmWithEmptyOrNullPermissions()
{    Principal principal = new UsernamePrincipal("rolePermResolver");    PrincipalCollection pCollection = new SimplePrincipalCollection(principal, "testRealmWithRolePermissionResolver");    AuthorizingRealm realm = new AllowAllRealm();    realm.setRolePermissionResolver(new RolePermissionResolver() {        public Collection<Permission> resolvePermissionsInRole(String roleString) {            Collection<Permission> permissions = new HashSet<Permission>();            if (roleString.equals(ROLE)) {                permissions.add(new WildcardPermission(ROLE + ":perm1"));                permissions.add(new WildcardPermission(ROLE + ":perm2"));                permissions.add(new WildcardPermission(ROLE + ": "));                permissions.add(new WildcardPermission(ROLE + ":\t"));                permissions.add(new WildcardPermission("other:*:foo"));            }            return permissions;        }    });    realm.setPermissionResolver(new WildcardPermissionResolver());    SimpleAuthorizationInfo authorizationInfo = (SimpleAuthorizationInfo) realm.getAuthorizationInfo(pCollection);    assertNotNull(authorizationInfo);    authorizationInfo.addStringPermission("");    authorizationInfo.addStringPermission(" ");    authorizationInfo.addStringPermission("\t");    authorizationInfo.addStringPermission(null);    Collection<Permission> permissions = realm.getPermissions(authorizationInfo);    assertEquals(permissions.size(), 4);}
0
public Collection<Permission> resolvePermissionsInRole(String roleString)
{    Collection<Permission> permissions = new HashSet<Permission>();    if (roleString.equals(ROLE)) {        permissions.add(new WildcardPermission(ROLE + ":perm1"));        permissions.add(new WildcardPermission(ROLE + ":perm2"));        permissions.add(new WildcardPermission(ROLE + ": "));        permissions.add(new WildcardPermission(ROLE + ":\t"));        permissions.add(new WildcardPermission("other:*:foo"));    }    return permissions;}
0
private void assertArrayEquals(boolean[] expected, boolean[] actual)
{    if (expected.length != actual.length) {        fail("Expected array of length [" + expected.length + "] but received array of length [" + actual.length + "]");    }    for (int i = 0; i < expected.length; i++) {        if (expected[i] != actual[i]) {            fail("Expected index [" + i + "] to be [" + expected[i] + "] but was [" + actual[i] + "]");        }    }}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    return buildAuthenticationInfo(token.getPrincipal(), token.getCredentials());}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    Set<String> roles = new HashSet<String>();    roles.add(ROLE);    return new SimpleAuthorizationInfo(roles);}
0
protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object credentials)
{    Collection<Object> principals = new ArrayList<Object>(3);    principals.add(new UserIdPrincipal(USER_ID));    principals.add(new UsernamePrincipal(USERNAME));    principals.add(USER_ID + USERNAME);    return new SimpleAuthenticationInfo(principals, PASSWORD, getName());}
0
public void setup()
{    ThreadContext.remove();    Ini config = new Ini();    config.setSectionProperty("main", "myRealm", "org.apache.shiro.realm.jdbc.JdbcRealm");    config.setSectionProperty("main", "myRealmCredentialsMatcher", "org.apache.shiro.authc.credential.Sha256CredentialsMatcher");    config.setSectionProperty("main", "myRealm.credentialsMatcher", "$myRealmCredentialsMatcher");    config.setSectionProperty("main", "securityManager.sessionManager.sessionValidationSchedulerEnabled", "false");    IniSecurityManagerFactory factory = new IniSecurityManagerFactory(config);    securityManager = (DefaultSecurityManager) factory.createInstance();    SecurityUtils.setSecurityManager(securityManager);        createRealm(name.getMethodName());}
0
public void tearDown()
{    final String testName = name.getMethodName();    shutDown(testName);    SecurityUtils.setSecurityManager(null);    securityManager.destroy();    ThreadContext.remove();}
0
public void testUnSaltedSuccess() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    currentUser.logout();}
0
public void testUnSaltedWrongPassword() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, "passwrd");    try {        currentUser.login(token);    } catch (IncorrectCredentialsException ex) {        }}
0
public void testUnSaltedMultipleRows() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    Connection conn = dsMap.get(testMethodName).getConnection();    Statement sql = conn.createStatement();    sql.executeUpdate("insert into users values ('" + username + "', 'dupe')");    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, "passwrd");    try {        currentUser.login(token);    } catch (AuthenticationException ex) {        }}
0
public void testSaltColumnSuccess() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createSaltColumnSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);    realm.setSaltIsBase64Encoded(false);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    currentUser.logout();}
0
public void testBase64EncodedSaltColumnSuccess() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createSaltColumnSchema(testMethodName, true);    realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    currentUser.logout();}
0
public void testSaltColumnWrongPassword() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createSaltColumnSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);    realm.setSaltIsBase64Encoded(false);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, "passwrd");    try {        currentUser.login(token);    } catch (IncorrectCredentialsException ex) {        }}
0
public void testBase64SaltColumnWrongPassword() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createSaltColumnSchema(testMethodName, true);    realm.setSaltStyle(JdbcRealm.SaltStyle.COLUMN);    realm.setSaltIsBase64Encoded(false);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, "passwrd");    try {        currentUser.login(token);    } catch (IncorrectCredentialsException ex) {        }}
0
public void testExternalSuccess() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, true);    realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    currentUser.logout();}
0
public void testExternalWrongPassword() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, true);    realm.setSaltStyle(JdbcRealm.SaltStyle.EXTERNAL);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, "passwrd");    try {        currentUser.login(token);    } catch (IncorrectCredentialsException ex) {        }}
0
public void testRolePresent() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    Assert.assertTrue(currentUser.hasRole(testRole));}
0
public void testRoleNotPresent() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    Assert.assertFalse(currentUser.hasRole("Game Overall Director"));}
0
public void testPermissionPresent() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    realm.setPermissionsLookupEnabled(true);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    Assert.assertTrue(currentUser.isPermitted(testPermissionString));}
0
public void testPermissionNotPresent() throws Exception
{    String testMethodName = name.getMethodName();    JdbcRealm realm = realmMap.get(testMethodName);    createDefaultSchema(testMethodName, false);    realm.setSaltStyle(JdbcRealm.SaltStyle.NO_SALT);    realm.setPermissionsLookupEnabled(true);    Subject.Builder builder = new Subject.Builder(securityManager);    Subject currentUser = builder.buildSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username, plainTextPassword);    currentUser.login(token);    Assert.assertFalse(currentUser.isPermitted("testDomain:testTarget:specialAction"));}
0
protected void createRealm(String testMethodName)
{    JdbcRealm realm = (JdbcRealm) securityManager.getRealms().iterator().next();    realmMap.put(testMethodName, realm);}
0
protected void shutDown(String testName)
{    Connection conn = null;    Statement sql = null;    DataSource ds = dsMap.get(testName);    try {        Connection c = ds.getConnection();        Statement s = c.createStatement();        s.executeUpdate("SHUTDOWN");    } catch (SQLException ex) {        } finally {        JdbcUtils.closeStatement(sql);        JdbcUtils.closeConnection(conn);        dsMap.remove(testName);        realmMap.remove(testName);    }}
0
protected void createDefaultSchema(String testName, boolean salted)
{    JDBCDataSource ds = new JDBCDataSource();    ds.setDatabase("jdbc:hsqldb:mem:" + name);    ds.setUser("SA");    ds.setPassword("");    Connection conn = null;    Statement sql = null;    try {        conn = ds.getConnection();        sql = conn.createStatement();        sql.executeUpdate("create table users (username varchar(20), password varchar(100))");        Sha256Hash sha256Hash = salted ? new Sha256Hash(plainTextPassword, salt) : new Sha256Hash(plainTextPassword);        String password = sha256Hash.toHex();        sql.executeUpdate("insert into users values ('" + username + "', '" + password + "')");    } catch (SQLException ex) {        Assert.fail("Exception creating test database");    } finally {        JdbcUtils.closeStatement(sql);        JdbcUtils.closeConnection(conn);    }    createRolesAndPermissions(ds);    realmMap.get(testName).setDataSource(ds);    dsMap.put(testName, ds);}
0
protected void createSaltColumnSchema(String testName, boolean base64EncodeSalt)
{    JDBCDataSource ds = new JDBCDataSource();    ds.setDatabase("jdbc:hsqldb:mem:" + name);    ds.setUser("SA");    ds.setPassword("");    Connection conn = null;    Statement sql = null;    try {        conn = ds.getConnection();        sql = conn.createStatement();        sql.executeUpdate("create table users (username varchar(20), password varchar(100), password_salt varchar(20))");        Sha256Hash sha256Hash = new Sha256Hash(plainTextPassword, salt);        String password = sha256Hash.toHex();        String maybeBase64EncodedSalt = base64EncodeSalt ? Base64.encodeToString(CodecSupport.toBytes(salt)) : salt;        sql.executeUpdate("insert into users values ('" + username + "', '" + password + "', '" + maybeBase64EncodedSalt + "')");    } catch (SQLException ex) {        Assert.fail("Exception creating test database");    } finally {        JdbcUtils.closeStatement(sql);        JdbcUtils.closeConnection(conn);    }    createRolesAndPermissions(ds);    realmMap.get(testName).setDataSource(ds);    dsMap.put(testName, ds);}
0
protected void createRolesAndPermissions(DataSource ds)
{    Connection conn = null;    ;    Statement sql = null;    try {        conn = ds.getConnection();        sql = conn.createStatement();        sql.executeUpdate("create table user_roles (username varchar(20), role_name varchar(20))");        sql.executeUpdate("insert into user_roles values ('" + username + "', '" + testRole + "')");        sql.executeUpdate("create table roles_permissions (role_name varchar(20), permission varchar(40))");        sql.executeUpdate("insert into roles_permissions values ('" + testRole + "', '" + testPermissionString + "')");    } catch (SQLException ex) {        Assert.fail("Exception adding test role and permission");    } finally {        JdbcUtils.closeStatement(sql);        JdbcUtils.closeConnection(conn);    }}
0
public void setUp()
{    factory = new DefaultLdapContextFactory() {                @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            return createNiceMock(LdapContext.class);        }    };}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    return createNiceMock(LdapContext.class);}
0
public void testGetLdapContext() throws NamingException
{    factory = new DefaultLdapContextFactory();        String brokenHost = UUID.randomUUID().toString();    factory.setUrl("ldap://" + brokenHost + ":389");    factory.getLdapContext((Object) "foo", "bar");}
0
public void testGetLdapContextWithoutUrl() throws NamingException
{    factory.getLdapContext((Object) "foo", "bar");}
0
public void testEmptyStringCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", "");}
0
public void testEmptyCharArrayCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", new char[0]);}
0
public void testEmptyByteArrayCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", new byte[0]);}
0
public void testEmptyNullCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", null);}
0
protected DefaultLdapRealm getNewRealmUnderTest()
{    return new DefaultLdapRealm();}
0
public void setUp()
{    realm = getNewRealmUnderTest();}
0
public void testDefaultInstance()
{    assertTrue(realm.getCredentialsMatcher() instanceof AllowAllCredentialsMatcher);    assertEquals(AuthenticationToken.class, realm.getAuthenticationTokenClass());    assertTrue(realm.getContextFactory() instanceof JndiLdapContextFactory);}
0
public void testSetUserDnTemplateNull()
{    realm.setUserDnTemplate(null);}
0
public void testSetUserDnTemplateEmpty()
{    realm.setUserDnTemplate("  ");}
0
public void testSetUserDnTemplateWithoutToken()
{    realm.setUserDnTemplate("uid=,ou=users,dc=mycompany,dc=com");}
0
public void testUserDnTemplate()
{    String template = "uid={0},ou=users,dc=mycompany,dc=com";    realm.setUserDnTemplate(template);    assertEquals(template, realm.getUserDnTemplate());}
0
public void testUserDnTemplateSubstitution() throws NamingException
{    realm.setUserDnTemplate("uid={0},ou=users,dc=mycompany,dc=com");    LdapContextFactory factory = createMock(LdapContextFactory.class);    realm.setContextFactory(factory);    Object expectedPrincipal = "uid=jsmith,ou=users,dc=mycompany,dc=com";    expect(factory.getLdapContext(eq(expectedPrincipal), isA(Object.class))).andReturn(createNiceMock(LdapContext.class));    replay(factory);    realm.getAuthenticationInfo(new UsernamePasswordToken("jsmith", "secret"));    verify(factory);}
0
public void testGetAuthenticationInfoNamingAuthenticationException() throws NamingException
{    realm.setUserDnTemplate("uid={0},ou=users,dc=mycompany,dc=com");    LdapContextFactory factory = createMock(LdapContextFactory.class);    realm.setContextFactory(factory);    expect(factory.getLdapContext(isA(Object.class), isA(Object.class))).andThrow(new javax.naming.AuthenticationException("LDAP Authentication failed."));    replay(factory);    realm.getAuthenticationInfo(new UsernamePasswordToken("jsmith", "secret"));}
0
public void testGetAuthenticationInfoNamingException() throws NamingException
{    realm.setUserDnTemplate("uid={0},ou=users,dc=mycompany,dc=com");    LdapContextFactory factory = createMock(LdapContextFactory.class);    realm.setContextFactory(factory);    expect(factory.getLdapContext(isA(Object.class), isA(Object.class))).andThrow(new NamingException("Communication error."));    replay(factory);    realm.getAuthenticationInfo(new UsernamePasswordToken("jsmith", "secret"));}
0
public void testGetAuthenticationInfoNonSimpleToken() throws NamingException
{    realm.setUserDnTemplate("uid={0},ou=users,dc=mycompany,dc=com");    LdapContextFactory factory = createMock(LdapContextFactory.class);    realm.setContextFactory(factory);    final UUID userId = UUID.randomUUID();        expect(factory.getLdapContext(eq(userId), isA(Object.class))).andReturn(createNiceMock(LdapContext.class));    replay(factory);    realm.getAuthenticationInfo(new AuthenticationToken() {        public Object getPrincipal() {            return userId;        }        public Object getCredentials() {            return "secret";        }    });    verify(factory);}
0
public Object getPrincipal()
{    return userId;}
0
public Object getCredentials()
{    return "secret";}
0
public void testGetUserDnNullArgument()
{    realm.getUserDn(null);}
0
public void testGetUserDnWithOutPrefixAndSuffix()
{    realm = new DefaultLdapRealm() {        @Override        protected String getUserDnPrefix() {            return null;        }        @Override        protected String getUserDnSuffix() {            return null;        }    };    String principal = "foo";    String userDn = realm.getUserDn(principal);    assertEquals(principal, userDn);}
0
protected String getUserDnPrefix()
{    return null;}
0
protected String getUserDnSuffix()
{    return null;}
0
public void setUp()
{    factory = new JndiLdapContextFactory() {                @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            return createNiceMock(LdapContext.class);        }    };}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    return createNiceMock(LdapContext.class);}
0
public void testGetLdapContext() throws NamingException
{    factory = new JndiLdapContextFactory();        String brokenHost = UUID.randomUUID().toString();    factory.setUrl("ldap://" + brokenHost + ":389");    factory.getLdapContext((Object) "foo", "bar");}
0
public void testAuthenticationMechanism()
{    String mech = "MD5-DIGEST";    factory.setAuthenticationMechanism(mech);    assertEquals(mech, factory.getAuthenticationMechanism());}
0
public void testReferral()
{    String referral = "throw";    factory.setReferral(referral);    assertEquals(referral, factory.getReferral());}
0
public void testGetContextFactoryClassName()
{    assertEquals(JndiLdapContextFactory.DEFAULT_CONTEXT_FACTORY_CLASS_NAME, factory.getContextFactoryClassName());}
0
public void testSetEnvironmentPropertyNull()
{    factory.setAuthenticationMechanism("MD5-DIGEST");    factory.setAuthenticationMechanism(null);    assertNull(factory.getAuthenticationMechanism());}
0
public void testCustomEnvironment()
{    Map<String, String> map = new HashMap<String, String>();    map.put("foo", "bar");    factory.setEnvironment(map);    assertEquals("bar", factory.getEnvironment().get("foo"));}
0
public void testGetLdapContextWithoutUrl() throws NamingException
{    factory.getLdapContext((Object) "foo", "bar");}
0
public void testGetLdapContextDefault() throws NamingException
{    factory = new JndiLdapContextFactory() {        @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));            assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));            assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));            assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));            assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));            return createNiceMock(LdapContext.class);        }    };    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "foo", "bar");}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));    assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));    assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));    assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));    assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));    return createNiceMock(LdapContext.class);}
0
public void testGetLdapContextStringArguments() throws NamingException
{    factory = new JndiLdapContextFactory() {        @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));            assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));            assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));            assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));            assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));            return createNiceMock(LdapContext.class);        }    };    factory.setUrl("ldap://localhost:389");    factory.getLdapContext("foo", "bar");}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));    assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));    assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));    assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));    assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));    return createNiceMock(LdapContext.class);}
0
public void testGetSystemLdapContext() throws NamingException
{    factory = new JndiLdapContextFactory() {        @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));            assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));            assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));            assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));            assertNotNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));            return createNiceMock(LdapContext.class);        }    };    factory.setSystemUsername("foo");    factory.setSystemPassword("bar");    factory.setUrl("ldap://localhost:389");    factory.getSystemLdapContext();}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));    assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));    assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));    assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));    assertNotNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));    return createNiceMock(LdapContext.class);}
0
public void testGetSystemLdapContextPoolingDisabled() throws NamingException
{    factory = new JndiLdapContextFactory() {        @Override        protected LdapContext createLdapContext(Hashtable env) throws NamingException {            assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));            assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));            assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));            assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));            assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));            return createNiceMock(LdapContext.class);        }    };    factory.setSystemUsername("foo");    factory.setSystemPassword("bar");    factory.setPoolingEnabled(false);    factory.setUrl("ldap://localhost:389");    factory.getSystemLdapContext();}
0
protected LdapContext createLdapContext(Hashtable env) throws NamingException
{    assertEquals("ldap://localhost:389", env.get(Context.PROVIDER_URL));    assertEquals("foo", env.get(Context.SECURITY_PRINCIPAL));    assertEquals("bar", env.get(Context.SECURITY_CREDENTIALS));    assertEquals("simple", env.get(Context.SECURITY_AUTHENTICATION));    assertNull(env.get(SUN_CONNECTION_POOLING_PROPERTY));    return createNiceMock(LdapContext.class);}
0
public void testEmptyStringCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", "");}
0
public void testEmptyCharArrayCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", new char[0]);}
0
public void testEmptyByteArrayCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", new byte[0]);}
0
public void testEmptyNullCredentials() throws NamingException
{    factory.setUrl("ldap://localhost:389");    factory.getLdapContext((Object) "jcoder", null);}
0
protected DefaultLdapRealm getNewRealmUnderTest()
{    return new JndiLdapRealm();}
0
public void testGetUserDnWithOutPrefixAndSuffix()
{    JndiLdapRealm realm = new JndiLdapRealm() {        @Override        protected String getUserDnPrefix() {            return null;        }        @Override        protected String getUserDnSuffix() {            return null;        }    };    String principal = "foo";    String userDn = realm.getUserDn(principal);    assertEquals(principal, userDn);}
0
protected String getUserDnPrefix()
{    return null;}
0
protected String getUserDnSuffix()
{    return null;}
0
public void testNullIni()
{    IniRealm realm = new IniRealm((Ini) null);}
0
public void testEmptyIni()
{    new IniRealm(new Ini());}
0
public void testInitWithoutIniResource()
{    new IniRealm().init();}
0
public void testIniFile()
{    IniRealm realm = new IniRealm();    realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.simple.ini");    realm.init();    assertTrue(realm.roleExists("admin"));    UsernamePasswordToken token = new UsernamePasswordToken("user1", "user1");    AuthenticationInfo info = realm.getAuthenticationInfo(token);    assertNotNull(info);    assertTrue(realm.hasRole(info.getPrincipals(), "admin"));}
0
public void testIniFileWithoutUsers()
{    IniRealm realm = new IniRealm();    realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.noUsers.ini");    realm.init();    assertTrue(realm.roleExists("admin"));}
0
private void setRoles()
{    StringBuilder roleDefinitions = new StringBuilder().append("role1 = role1_permission1\n").append("role2 = role2_persission1, role2_permission2\n");    realm.setRoleDefinitions(roleDefinitions.toString());}
0
private void setUsers()
{    StringBuilder userDefinitions = new StringBuilder();    for (int i = 1; i < 3; i++) {        userDefinitions.append(String.format("user%1$d = user%1$d_password, role1, role2%n", i));    }    realm.setUserDefinitions(userDefinitions.toString());}
0
private void setUpForReadConfigurationTest()
{    realm = new TestRealm() {        /*             * Demonstrates that a lock can't be obtained on the realm by a read thread until after             * the lock is released.             */        public void test(Thread runnable) throws InterruptedException {                        USERS_LOCK.writeLock().lock();            try {                ROLES_LOCK.writeLock().lock();                try {                                        runnable.start();                    Thread.sleep(500);                                        realm.onInit();                } finally {                    ROLES_LOCK.writeLock().unlock();                }            } finally {                USERS_LOCK.writeLock().unlock();            }        }    };    setRoles();    setUsers();}
0
public void test(Thread runnable) throws InterruptedException
{        USERS_LOCK.writeLock().lock();    try {        ROLES_LOCK.writeLock().lock();        try {                        runnable.start();            Thread.sleep(500);                        realm.onInit();        } finally {            ROLES_LOCK.writeLock().unlock();        }    } finally {        USERS_LOCK.writeLock().unlock();    }}
0
private void executeTest(Runnable runnable) throws InterruptedException
{    TestThread testThread = new TestThread(runnable);    Thread testTask = new Thread(testThread);    realm.test(testTask);    testTask.join(500);        testThread.test();}
0
public void testRoleAndUserAccount() throws InterruptedException
{    setUpForReadConfigurationTest();    executeTest(new Runnable() {        public void run() {            assertTrue("role not found when it was expected", realm.roleExists("role1"));            assertTrue("user not found when it was expected", realm.accountExists("user1"));        }    });}
0
public void run()
{    assertTrue("role not found when it was expected", realm.roleExists("role1"));    assertTrue("user not found when it was expected", realm.accountExists("user1"));}
0
public void testHasRole() throws InterruptedException
{    setUpForReadConfigurationTest();    executeTest(new Runnable() {        public void run() {            PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");            assertTrue("principal doesn't have role when it should", realm.hasRole(principalCollection, "role2"));            assertTrue("principal doesn't have all roles when it should", realm.hasAllRoles(principalCollection, Arrays.asList(new String[] { "role1", "role2" })));        }    });}
0
public void run()
{    PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");    assertTrue("principal doesn't have role when it should", realm.hasRole(principalCollection, "role2"));    assertTrue("principal doesn't have all roles when it should", realm.hasAllRoles(principalCollection, Arrays.asList(new String[] { "role1", "role2" })));}
0
public void testCheckRole() throws InterruptedException
{    setUpForReadConfigurationTest();    executeTest(new Runnable() {        public void run() {            PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");            try {                realm.checkRoles(principalCollection, new String[] { "role1", "role2" });            } catch (AuthorizationException ae) {                fail("principal doesn't have all roles when it should");            }        }    });}
0
public void run()
{    PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");    try {        realm.checkRoles(principalCollection, new String[] { "role1", "role2" });    } catch (AuthorizationException ae) {        fail("principal doesn't have all roles when it should");    }}
0
public void testCheckPermission() throws InterruptedException
{    setUpForReadConfigurationTest();    executeTest(new Runnable() {        public void run() {            PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");            try {                realm.checkPermission(principalCollection, "role1_permission1");                realm.checkPermissions(principalCollection, new String[] { "role1_permission1", "role2_permission2" });            } catch (AuthorizationException ae) {                fail("principal doesn't have permission when it should");            }        }    });}
0
public void run()
{    PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");    try {        realm.checkPermission(principalCollection, "role1_permission1");        realm.checkPermissions(principalCollection, new String[] { "role1_permission1", "role2_permission2" });    } catch (AuthorizationException ae) {        fail("principal doesn't have permission when it should");    }}
0
public void testIsPermitted() throws InterruptedException
{    setUpForReadConfigurationTest();    executeTest(new Runnable() {        public void run() {            PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");            assertTrue("permission not permitted when it should be", realm.isPermitted(principalCollection, "role1_permission1"));            assertTrue("permission not permitted when it should be", realm.isPermittedAll(principalCollection, new String[] { "role1_permission1", "role2_permission2" }));        }    });}
0
public void run()
{    PrincipalCollection principalCollection = new SimplePrincipalCollection("user1", "realm1");    assertTrue("permission not permitted when it should be", realm.isPermitted(principalCollection, "role1_permission1"));    assertTrue("permission not permitted when it should be", realm.isPermittedAll(principalCollection, new String[] { "role1_permission1", "role2_permission2" }));}
0
public void testProcessRoleDefinitions() throws InterruptedException
{    realm = new TestRealm() {        public void test(Thread runnable) throws InterruptedException {                                    ROLES_LOCK.writeLock().lock();            try {                runnable.start();                Thread.sleep(500);                                assertFalse("role exists when it shouldn't", realm.roleExists("role1"));            } finally {                ROLES_LOCK.writeLock().unlock();            }        }    };        TestThread testThread = new TestThread(new Runnable() {        public void run() {            try {                realm.processRoleDefinitions();            } catch (ParseException e) {                fail("Unable to parse role definitions");            }        }    });    setRoles();    Thread testTask = new Thread(testThread);    realm.test(testTask);    testTask.join(500);    assertTrue("role doesn't exist when it should", realm.roleExists("role1"));    testThread.test();}
0
public void test(Thread runnable) throws InterruptedException
{            ROLES_LOCK.writeLock().lock();    try {        runnable.start();        Thread.sleep(500);                assertFalse("role exists when it shouldn't", realm.roleExists("role1"));    } finally {        ROLES_LOCK.writeLock().unlock();    }}
0
public void run()
{    try {        realm.processRoleDefinitions();    } catch (ParseException e) {        fail("Unable to parse role definitions");    }}
0
public void testProcessUserDefinitions() throws InterruptedException
{    realm = new TestRealm() {        public void test(Thread runnable) throws InterruptedException {                                    USERS_LOCK.writeLock().lock();            try {                runnable.start();                Thread.sleep(500);                                assertFalse("account exists when it shouldn't", realm.accountExists("user1"));            } finally {                USERS_LOCK.writeLock().unlock();            }        }    };    TestThread testThread = new TestThread(new Runnable() {        public void run() {            try {                realm.processUserDefinitions();            } catch (ParseException e) {                fail("Unable to parse user definitions");            }        }    });    setUsers();    Thread testTask = new Thread(testThread);    realm.test(testTask);    testTask.join(500);    assertTrue("account doesn't exist when it should", realm.accountExists("user1"));    testThread.test();}
0
public void test(Thread runnable) throws InterruptedException
{            USERS_LOCK.writeLock().lock();    try {        runnable.start();        Thread.sleep(500);                assertFalse("account exists when it shouldn't", realm.accountExists("user1"));    } finally {        USERS_LOCK.writeLock().unlock();    }}
0
public void run()
{    try {        realm.processUserDefinitions();    } catch (ParseException e) {        fail("Unable to parse user definitions");    }}
0
public void run()
{    try {        test.run();    } catch (AssertionError ae) {        this.ae = ae;    }}
0
public void test()
{    if (ae != null)        throw ae;}
0
public int getUserId()
{    return userId;}
0
public String getName()
{    return String.valueOf(userId);}
0
public String getUsername()
{    return username;}
0
public String getName()
{    return String.valueOf(username);}
0
public void testValidateSessions()
{    final SimpleSession validSession = new SimpleSession();    validSession.setId(1);    final SimpleSession invalidSession = new SimpleSession();        Calendar cal = Calendar.getInstance();    Long expiredTimeout = AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT + 1;    cal.add(Calendar.MILLISECOND, -(expiredTimeout.intValue()));    Date past = cal.getTime();    invalidSession.setStartTimestamp(past);    invalidSession.setLastAccessTime(past);    invalidSession.setId(2);    final AtomicInteger expirationCount = new AtomicInteger();    SessionListener sessionListener = new SessionListenerAdapter() {        @Override        public void onExpiration(Session session) {            expirationCount.incrementAndGet();        }    };    AbstractValidatingSessionManager sessionManager = new AbstractValidatingSessionManager() {        @Override        protected Session retrieveSession(SessionKey key) throws UnknownSessionException {            throw new UnsupportedOperationException("Should not be called in this test.");        }        @Override        protected Session doCreateSession(SessionContext initData) throws AuthorizationException {            throw new UnsupportedOperationException("Should not be called in this test.");        }        @Override        protected Collection<Session> getActiveSessions() {            Collection<Session> sessions = new ArrayList<Session>(2);            sessions.add(validSession);            sessions.add(invalidSession);            return sessions;        }    };    sessionManager.setSessionListeners(Arrays.asList(sessionListener));    sessionManager.validateSessions();    assertEquals(1, expirationCount.intValue());}
0
public void onExpiration(Session session)
{    expirationCount.incrementAndGet();}
0
protected Session retrieveSession(SessionKey key) throws UnknownSessionException
{    throw new UnsupportedOperationException("Should not be called in this test.");}
0
protected Session doCreateSession(SessionContext initData) throws AuthorizationException
{    throw new UnsupportedOperationException("Should not be called in this test.");}
0
protected Collection<Session> getActiveSessions()
{    Collection<Session> sessions = new ArrayList<Session>(2);    sessions.add(validSession);    sessions.add(invalidSession);    return sessions;}
0
public void testNoMemoryLeakOnInvalidSessions() throws Exception
{    SessionListener sessionListener = new SessionListener() {        public void onStart(Session session) {            session.setAttribute("I love", "Romania");        }        public void onStop(Session session) {            tryToCleanSession(session);        }        public void onExpiration(Session session) {            tryToCleanSession(session);        }        private void tryToCleanSession(Session session) {            Collection<Object> keys = session.getAttributeKeys();            for (Object key : keys) {                session.removeAttribute(key);            }        }    };    DefaultSessionManager sessionManager = new DefaultSessionManager();    sessionManager.setSessionListeners(Arrays.asList(sessionListener));    Session session = sessionManager.start(null);    assertEquals(1, sessionManager.getActiveSessions().size());    session.setTimeout(0L);        Thread.sleep(1);    sessionManager.validateSessions();    assertEquals(0, sessionManager.getActiveSessions().size());}
0
public void onStart(Session session)
{    session.setAttribute("I love", "Romania");}
0
public void onStop(Session session)
{    tryToCleanSession(session);}
0
public void onExpiration(Session session)
{    tryToCleanSession(session);}
0
private void tryToCleanSession(Session session)
{    Collection<Object> keys = session.getAttributeKeys();    for (Object key : keys) {        session.removeAttribute(key);    }}
0
public void setup()
{    ThreadContext.remove();    sm = new DefaultSessionManager();}
0
public void tearDown()
{    sm.destroy();    ThreadContext.remove();}
0
public void sleep(long millis)
{    try {        Thread.sleep(millis);    } catch (InterruptedException e) {        throw new IllegalStateException(e);    }}
0
public void testGlobalTimeout()
{    long timeout = 1000;    sm.setGlobalSessionTimeout(timeout);    Session session = sm.start(null);    assertNotNull(session);    assertNotNull(session.getId());    assertEquals(session.getTimeout(), timeout);}
0
public void testSessionListenerStartNotification()
{    final boolean[] started = new boolean[1];    SessionListener listener = new SessionListenerAdapter() {        public void onStart(Session session) {            started[0] = true;        }    };    sm.getSessionListeners().add(listener);    sm.start(null);    assertTrue(started[0]);}
0
public void onStart(Session session)
{    started[0] = true;}
0
public void testSessionListenerStopNotification()
{    final boolean[] stopped = new boolean[1];    SessionListener listener = new SessionListenerAdapter() {        public void onStop(Session session) {            stopped[0] = true;        }    };    sm.getSessionListeners().add(listener);    Session session = sm.start(null);    sm.stop(new DefaultSessionKey(session.getId()));    assertTrue(stopped[0]);}
0
public void onStop(Session session)
{    stopped[0] = true;}
0
public void testSessionListenerStopNotificationWithReadAttribute()
{    final boolean[] stopped = new boolean[1];    final String[] value = new String[1];    SessionListener listener = new SessionListenerAdapter() {        public void onStop(Session session) {            stopped[0] = true;            value[0] = (String) session.getAttribute("foo");        }    };    sm.getSessionListeners().add(listener);    Session session = sm.start(null);    session.setAttribute("foo", "bar");    sm.stop(new DefaultSessionKey(session.getId()));    assertTrue(stopped[0]);    assertEquals("bar", value[0]);}
0
public void onStop(Session session)
{    stopped[0] = true;    value[0] = (String) session.getAttribute("foo");}
0
public void testSessionListenerExpiredNotification()
{    final boolean[] expired = new boolean[1];    SessionListener listener = new SessionListenerAdapter() {        public void onExpiration(Session session) {            expired[0] = true;        }    };    sm.getSessionListeners().add(listener);    sm.setGlobalSessionTimeout(100);    Session session = sm.start(null);    sleep(150);    try {        sm.checkValid(new DefaultSessionKey(session.getId()));        fail("check should have thrown an exception.");    } catch (InvalidSessionException expected) {        }    assertTrue(expired[0]);}
0
public void onExpiration(Session session)
{    expired[0] = true;}
0
public void testSessionDeleteOnExpiration()
{    sm.setGlobalSessionTimeout(100);    SessionDAO sessionDAO = createMock(SessionDAO.class);    sm.setSessionDAO(sessionDAO);    String sessionId1 = UUID.randomUUID().toString();    final SimpleSession session1 = new SimpleSession();    session1.setId(sessionId1);    final Session[] activeSession = new SimpleSession[] { session1 };    sm.setSessionFactory(new SessionFactory() {        public Session createSession(SessionContext initData) {            return activeSession[0];        }    });    expect(sessionDAO.create(eq(session1))).andReturn(sessionId1);    sessionDAO.update(eq(session1));    expectLastCall().anyTimes();    replay(sessionDAO);    Session session = sm.start(null);    assertNotNull(session);    verify(sessionDAO);    reset(sessionDAO);    expect(sessionDAO.readSession(sessionId1)).andReturn(session1).anyTimes();    sessionDAO.update(eq(session1));    replay(sessionDAO);    sm.setTimeout(new DefaultSessionKey(sessionId1), 1);    verify(sessionDAO);    reset(sessionDAO);    sleep(20);    expect(sessionDAO.readSession(sessionId1)).andReturn(session1);        sessionDAO.update(eq(session1));    sessionDAO.delete(session1);    replay(sessionDAO);        try {        sm.getTimeout(new DefaultSessionKey(sessionId1));        fail("Session with id [" + sessionId1 + "] should have expired due to timeout.");    } catch (ExpiredSessionException expected) {        }        verify(sessionDAO);}
0
public Session createSession(SessionContext initData)
{    return activeSession[0];}
0
public void testEnablingOfCustomSessionValidationScheduler()
{            ExecutorServiceSessionValidationScheduler sessionValidationScheduler = new ExecutorServiceSessionValidationScheduler();    DefaultSessionManager sessionManager = new DefaultSessionManager();    sessionManager.setSessionValidationScheduler(sessionValidationScheduler);        try {        Session session = sessionManager.start(null);                assertTrue("sessionValidationScheduler was not enabled", sessionValidationScheduler.isEnabled());    } finally {                sessionManager.destroy();    }}
0
public static T eqSessionTimeout(long timeout)
{    EasyMock.reportMatcher(new SessionTimeoutMatcher(timeout));    return null;}
0
public void appendTo(StringBuffer buffer)
{    buffer.append("eqSession(timeout=").append(this.timeout).append(")");}
0
public boolean matches(Object o)
{    return o instanceof Session && ((Session) o).getTimeout() == this.timeout;}
0
public void setup()
{    ThreadContext.remove();    sm = new DefaultSessionManager();    this.session = new DelegatingSession(sm, new DefaultSessionKey(sm.start(null).getId()));}
0
public void tearDown()
{    sm.destroy();    ThreadContext.remove();}
0
public void sleep(long millis)
{    try {        Thread.sleep(millis);    } catch (InterruptedException e) {        throw new IllegalStateException(e);    }}
0
public void testTimeout()
{    Serializable origId = session.getId();    assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);    session.touch();    session.setTimeout(100);    assertEquals(100, session.getTimeout());    sleep(150);    try {        session.getTimeout();        fail("Session should have expired.");    } catch (ExpiredSessionException expected) {    }}
0
public void testDefaultSerialization() throws Exception
{    SimpleSession session = new SimpleSession();    long timeout = session.getTimeout();    Date start = session.getStartTimestamp();    Date lastAccess = session.getLastAccessTime();    SimpleSession deserialized = serializeAndDeserialize(session);    assertEquals(timeout, deserialized.getTimeout());    assertEquals(start, deserialized.getStartTimestamp());    assertEquals(lastAccess, deserialized.getLastAccessTime());}
0
public void serializeHost() throws IOException, ClassNotFoundException
{    SimpleSession session = new SimpleSession("localhost");    assertEquals("localhost", serializeAndDeserialize(session).getHost());}
0
public void serializeExpired() throws IOException, ClassNotFoundException
{    SimpleSession session = new SimpleSession();    session.setExpired(true);    assertTrue(serializeAndDeserialize(session).isExpired());}
0
private SimpleSession serializeAndDeserialize(SimpleSession session) throws IOException, ClassNotFoundException
{    ByteArrayOutputStream serialized = new ByteArrayOutputStream();    ObjectOutputStream serializer = new ObjectOutputStream(serialized);    serializer.writeObject(session);    serializer.close();    return (SimpleSession) new ObjectInputStream(new ByteArrayInputStream(serialized.toByteArray())).readObject();}
0
public void setup()
{    ThreadContext.remove();}
0
public void tearDown()
{    ThreadContext.remove();}
0
public void testSessionStopThenStart()
{    String key = "testKey";    String value = "testValue";    DefaultSecurityManager sm = new DefaultSecurityManager();    DelegatingSubject subject = new DelegatingSubject(sm);    Session session = subject.getSession();    session.setAttribute(key, value);    assertTrue(session.getAttribute(key).equals(value));    Serializable firstSessionId = session.getId();    assertNotNull(firstSessionId);    session.stop();    session = subject.getSession();    assertNotNull(session);    assertNull(session.getAttribute(key));    Serializable secondSessionId = session.getId();    assertNotNull(secondSessionId);    assertFalse(firstSessionId.equals(secondSessionId));    subject.logout();    sm.destroy();}
0
public void testExecuteCallable()
{    String username = "jsmith";    SecurityManager securityManager = createNiceMock(SecurityManager.class);    PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");    final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);    assertNull(ThreadContext.getSubject());    assertNull(ThreadContext.getSecurityManager());    Callable<String> callable = new Callable<String>() {        public String call() throws Exception {            Subject callingSubject = SecurityUtils.getSubject();            assertNotNull(callingSubject);            assertNotNull(SecurityUtils.getSecurityManager());            assertEquals(callingSubject, sourceSubject);            return "Hello " + callingSubject.getPrincipal();        }    };    String response = sourceSubject.execute(callable);    assertNotNull(response);    assertEquals("Hello " + username, response);    assertNull(ThreadContext.getSubject());    assertNull(ThreadContext.getSecurityManager());}
0
public String call() throws Exception
{    Subject callingSubject = SecurityUtils.getSubject();    assertNotNull(callingSubject);    assertNotNull(SecurityUtils.getSecurityManager());    assertEquals(callingSubject, sourceSubject);    return "Hello " + callingSubject.getPrincipal();}
0
public void testExecuteRunnable()
{    String username = "jsmith";    SecurityManager securityManager = createNiceMock(SecurityManager.class);    PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");    final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);    assertNull(ThreadContext.getSubject());    assertNull(ThreadContext.getSecurityManager());    Runnable runnable = new Runnable() {        public void run() {            Subject callingSubject = SecurityUtils.getSubject();            assertNotNull(callingSubject);            assertNotNull(SecurityUtils.getSecurityManager());            assertEquals(callingSubject, sourceSubject);        }    };    sourceSubject.execute(runnable);    assertNull(ThreadContext.getSubject());    assertNull(ThreadContext.getSecurityManager());}
0
public void run()
{    Subject callingSubject = SecurityUtils.getSubject();    assertNotNull(callingSubject);    assertNotNull(SecurityUtils.getSecurityManager());    assertEquals(callingSubject, sourceSubject);}
0
public void testRunAs()
{    Ini ini = new Ini();    Ini.Section users = ini.addSection("users");    users.put("user1", "user1,role1");    users.put("user2", "user2,role2");    users.put("user3", "user3,role3");    IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);    SecurityManager sm = factory.getInstance();        Subject subject = new Subject.Builder(sm).buildSubject();    subject.login(new UsernamePasswordToken("user1", "user1"));    assertFalse(subject.isRunAs());    assertEquals("user1", subject.getPrincipal());    assertTrue(subject.hasRole("role1"));    assertFalse(subject.hasRole("role2"));    assertFalse(subject.hasRole("role3"));        assertNull(subject.getPreviousPrincipals());        subject.runAs(new SimplePrincipalCollection("user2", IniSecurityManagerFactory.INI_REALM_NAME));    assertTrue(subject.isRunAs());    assertEquals("user2", subject.getPrincipal());    assertTrue(subject.hasRole("role2"));    assertFalse(subject.hasRole("role1"));    assertFalse(subject.hasRole("role3"));        PrincipalCollection previous = subject.getPreviousPrincipals();    assertFalse(previous == null || previous.isEmpty());    assertTrue(previous.getPrimaryPrincipal().equals("user1"));        subject.runAs(new SimplePrincipalCollection("user3", IniSecurityManagerFactory.INI_REALM_NAME));    assertTrue(subject.isRunAs());    assertEquals("user3", subject.getPrincipal());    assertTrue(subject.hasRole("role3"));    assertFalse(subject.hasRole("role1"));    assertFalse(subject.hasRole("role2"));        previous = subject.getPreviousPrincipals();    assertFalse(previous == null || previous.isEmpty());    assertTrue(previous.getPrimaryPrincipal().equals("user2"));        subject.releaseRunAs();        assertTrue(subject.isRunAs());    assertEquals("user2", subject.getPrincipal());    assertTrue(subject.hasRole("role2"));    assertFalse(subject.hasRole("role1"));    assertFalse(subject.hasRole("role3"));        previous = subject.getPreviousPrincipals();    assertFalse(previous == null || previous.isEmpty());    assertTrue(previous.getPrimaryPrincipal().equals("user1"));        subject.releaseRunAs();        assertFalse(subject.isRunAs());    assertEquals("user1", subject.getPrincipal());    assertTrue(subject.hasRole("role1"));    assertFalse(subject.hasRole("role2"));    assertFalse(subject.hasRole("role3"));        assertNull(subject.getPreviousPrincipals());    subject.logout();    LifecycleUtils.destroy(sm);}
0
public void multiplePrincipalsTest()
{    SimplePrincipalCollection principalCollection = new SimplePrincipalCollection();    principalCollection.add("frank", "realm1");    principalCollection.add("johnny", "realm1");    principalCollection.add("Alberto", "realm2");    PrincipalCollection underTest = principalCollection;        System.out.println(principalCollection);}
0
protected void setSubject(Subject subject)
{    clearSubject();    subjectThreadState = createThreadState(subject);    subjectThreadState.bind();}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
protected ThreadState createThreadState(Subject subject)
{    return new SubjectThreadState(subject);}
0
protected void clearSubject()
{    doClearSubject();}
0
private static void doClearSubject()
{    if (subjectThreadState != null) {        subjectThreadState.clear();        subjectThreadState = null;    }}
0
protected static void setSecurityManager(SecurityManager securityManager)
{    SecurityUtils.setSecurityManager(securityManager);}
0
protected static SecurityManager getSecurityManager()
{    return SecurityUtils.getSecurityManager();}
0
public static void tearDownShiro()
{    doClearSubject();    try {        SecurityManager securityManager = getSecurityManager();        LifecycleUtils.destroy(securityManager);    } catch (UnavailableSecurityManagerException e) {                }    setSecurityManager(null);}
0
public static void beforeClass()
{                Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:test.shiro.ini");    setSecurityManager(factory.getInstance());}
0
public void testSimple()
{        Subject subjectUnderTest = new Subject.Builder(getSecurityManager()).buildSubject();        setSubject(subjectUnderTest);}
0
public void tearDownSubject()
{        clearSubject();}
0
public void testSimple()
{            Subject subjectUnderTest = createNiceMock(Subject.class);    expect(subjectUnderTest.isAuthenticated()).andReturn(true);        setSubject(subjectUnderTest);}
0
public void tearDownSubject()
{        clearSubject();}
0
protected static SecurityManager createTestSecurityManager()
{    Ini ini = new Ini();    ini.setSectionProperty("users", "test", "test");    return new DefaultSecurityManager(new IniRealm(ini));}
0
protected void destroy(SecurityManager sm)
{    LifecycleUtils.destroy(sm);}
0
protected SecurityManager createAndBindTestSecurityManager()
{    SecurityManager sm = createTestSecurityManager();    ThreadContext.bind(sm);    return sm;}
0
protected Subject createAndBindTestSubject()
{    SecurityManager sm = ThreadContext.getSecurityManager();    if (sm == null) {        createAndBindTestSecurityManager();    }    return SecurityUtils.getSubject();}
0
public void setup()
{    createAndBindTestSubject();}
0
public void teardown()
{    ThreadContext.remove();}
0
public void testSimplePattern()
{    PatternMatcher pm = new RegExPatternMatcher();    String pattern = "a*b";    String test = "aaaaaaab";        Pattern.compile(pattern);    assertTrue(pm.matches(pattern, test));}
0
public void splitWithNullInput()
{    String line = null;    String[] split = StringUtils.split(line);    assertNull(split);}
0
public void splitWithCommas()
{    String line = "shall,we,play,a,game?";    String[] split = StringUtils.split(line);    assertNotNull(split);    assertTrue(split.length == 5);    assertEquals("shall", split[0]);    assertEquals("we", split[1]);    assertEquals("play", split[2]);    assertEquals("a", split[3]);    assertEquals("game?", split[4]);}
0
public void splitWithCommasAndSpaces()
{    String line = "shall,we ,    play, a,game?";    String[] split = StringUtils.split(line);    assertNotNull(split);    assertTrue(split.length == 5);    assertEquals("shall", split[0]);    assertEquals("we", split[1]);    assertEquals("play", split[2]);    assertEquals("a", split[3]);    assertEquals("game?", split[4]);}
0
public void splitWithQuotedCommasAndSpaces()
{    String line = "shall, \"we, play\", a, game?";    String[] split = StringUtils.split(line);    assertNotNull(split);    assertTrue(split.length == 4);    assertEquals("shall", split[0]);    assertEquals("we, play", split[1]);    assertEquals("a", split[2]);    assertEquals("game?", split[3]);}
0
public void splitWithQuotedCommasAndSpacesAndDifferentQuoteChars()
{    String line = "authc, test[blah], test[1,2,3], test[]";    String[] split = StringUtils.split(line, ',', '[', ']', false, true);    assertNotNull(split);    assertTrue(split.length == 4);    assertEquals("authc", split[0]);    assertEquals("testblah", split[1]);    assertEquals("test1,2,3", split[2]);    assertEquals("test", split[3]);}
0
public void splitWithQuotedCommasAndSpacesAndDifferentQuoteCharsWhileRetainingQuotes()
{    String line = "authc, test[blah], test[1,2,3], test[]";    String[] split = StringUtils.split(line, ',', '[', ']', true, true);    assertNotNull(split);    assertTrue(split.length == 4);    assertEquals("authc", split[0]);    assertEquals("test[blah]", split[1]);    assertEquals("test[1,2,3]", split[2]);    assertEquals("test[]", split[3]);}
0
public void splitTestWithQuotedCommas()
{    String line = "authc, test[blah], test[\"1,2,3\"], test[]";    String[] split = StringUtils.split(line);    assertNotNull(split);    assertTrue(split.length == 4);    assertEquals("authc", split[0]);    assertEquals("test[blah]", split[1]);    assertEquals("test[1,2,3]", split[2]);    assertEquals("test[]", split[3]);}
0
public void splitWithQuotedCommasAndSpacesAndEscapedQuotes()
{    String line = "shall, \"\"\"we, play\", a, \"\"\"game?";    String[] split = StringUtils.split(line);    assertNotNull(split);    assertTrue(split.length == 4);    assertEquals("shall", split[0]);    assertEquals("\"we, play", split[1]);    assertEquals("a", split[2]);    assertEquals("\"game?", split[3]);}
0
public Key generateNewKey()
{    return generateNewKey(getKeySize());}
0
public Key generateNewKey(int keyBitSize)
{    KeyGenerator kg;    try {        kg = KeyGenerator.getInstance(getAlgorithmName());    } catch (NoSuchAlgorithmException e) {        String msg = "Unable to acquire " + getAlgorithmName() + " algorithm.  This is required to function.";        throw new IllegalStateException(msg, e);    }    kg.init(keyBitSize);    return kg.generateKey();}
0
public String getModeName()
{    return modeName;}
0
public void setModeName(String modeName)
{    this.modeName = modeName;        this.transformationString = null;}
0
public void setMode(OperationMode mode)
{    setModeName(mode.name());}
0
public String getPaddingSchemeName()
{    return paddingSchemeName;}
0
public void setPaddingSchemeName(String paddingSchemeName)
{    this.paddingSchemeName = paddingSchemeName;        this.transformationString = null;}
0
public void setPaddingScheme(PaddingScheme paddingScheme)
{    setPaddingSchemeName(paddingScheme.getTransformationName());}
0
public int getBlockSize()
{    return blockSize;}
0
public void setBlockSize(int blockSize)
{    this.blockSize = Math.max(DEFAULT_BLOCK_SIZE, blockSize);        this.transformationString = null;}
0
public String getStreamingModeName()
{    return streamingModeName;}
0
private boolean isModeStreamingCompatible(String modeName)
{    return modeName != null && !modeName.equalsIgnoreCase(OperationMode.ECB.name()) && !modeName.equalsIgnoreCase(OperationMode.NONE.name());}
0
public void setStreamingModeName(String streamingModeName)
{    if (!isModeStreamingCompatible(streamingModeName)) {        String msg = "mode [" + streamingModeName + "] is not a valid operation mode for block cipher streaming.";        throw new IllegalArgumentException(msg);    }    this.streamingModeName = streamingModeName;        this.streamingTransformationString = null;}
0
public void setStreamingMode(OperationMode mode)
{    setStreamingModeName(mode.name());}
0
public String getStreamingPaddingSchemeName()
{    return streamingPaddingSchemeName;}
0
public void setStreamingPaddingSchemeName(String streamingPaddingSchemeName)
{    this.streamingPaddingSchemeName = streamingPaddingSchemeName;        this.streamingTransformationString = null;}
0
public void setStreamingPaddingScheme(PaddingScheme scheme)
{    setStreamingPaddingSchemeName(scheme.getTransformationName());}
0
public int getStreamingBlockSize()
{    return streamingBlockSize;}
0
public void setStreamingBlockSize(int streamingBlockSize)
{    this.streamingBlockSize = Math.max(DEFAULT_BLOCK_SIZE, streamingBlockSize);        this.streamingTransformationString = null;}
0
protected String getTransformationString(boolean streaming)
{    if (streaming) {        if (this.streamingTransformationString == null) {            this.streamingTransformationString = buildStreamingTransformationString();        }        return this.streamingTransformationString;    } else {        if (this.transformationString == null) {            this.transformationString = buildTransformationString();        }        return this.transformationString;    }}
0
private String buildTransformationString()
{    return buildTransformationString(getModeName(), getPaddingSchemeName(), getBlockSize());}
0
private String buildStreamingTransformationString()
{    return buildTransformationString(getStreamingModeName(), getStreamingPaddingSchemeName(), 0);}
0
private String buildTransformationString(String modeName, String paddingSchemeName, int blockSize)
{    StringBuilder sb = new StringBuilder(getAlgorithmName());    if (StringUtils.hasText(modeName)) {        sb.append(TRANSFORMATION_STRING_DELIMITER).append(modeName);    }    if (blockSize > 0) {        sb.append(blockSize);    }    if (StringUtils.hasText(paddingSchemeName)) {        sb.append(TRANSFORMATION_STRING_DELIMITER).append(paddingSchemeName);    }    return sb.toString();}
0
private boolean isModeInitializationVectorCompatible(String modeName)
{    return modeName != null && !modeName.equalsIgnoreCase(OperationMode.ECB.name()) && !modeName.equalsIgnoreCase(OperationMode.NONE.name());}
0
protected boolean isGenerateInitializationVectors(boolean streaming)
{    return streaming || super.isGenerateInitializationVectors() && isModeInitializationVectorCompatible(getModeName());}
0
protected byte[] generateInitializationVector(boolean streaming)
{    if (streaming) {        String streamingModeName = getStreamingModeName();        if (!isModeInitializationVectorCompatible(streamingModeName)) {            String msg = "streamingMode attribute value [" + streamingModeName + "] does not support " + "Initialization Vectors.  Ensure the streamingMode value represents an operation mode " + "that is compatible with initialization vectors.";            throw new IllegalStateException(msg);        }    } else {        String modeName = getModeName();        if (!isModeInitializationVectorCompatible(modeName)) {            String msg = "mode attribute value [" + modeName + "] does not support " + "Initialization Vectors.  Ensure the mode value represents an operation mode " + "that is compatible with initialization vectors.";            throw new IllegalStateException(msg);        }    }    return super.generateInitializationVector(streaming);}
0
public String getAlgorithmName()
{    return algorithmName;}
0
public int getKeySize()
{    return keySize;}
0
public void setKeySize(int keySize)
{    this.keySize = keySize;}
0
public boolean isGenerateInitializationVectors()
{    return generateInitializationVectors;}
0
public void setGenerateInitializationVectors(boolean generateInitializationVectors)
{    this.generateInitializationVectors = generateInitializationVectors;}
0
public int getInitializationVectorSize()
{    return initializationVectorSize;}
0
public void setInitializationVectorSize(int initializationVectorSize) throws IllegalArgumentException
{    if (initializationVectorSize % BITS_PER_BYTE != 0) {        String msg = "Initialization vector sizes are specified in bits, but must be a multiple of 8 so they " + "can be easily represented as a byte array.";        throw new IllegalArgumentException(msg);    }    this.initializationVectorSize = initializationVectorSize;}
0
protected boolean isGenerateInitializationVectors(boolean streaming)
{    return isGenerateInitializationVectors();}
0
public int getStreamingBufferSize()
{    return streamingBufferSize;}
0
public void setStreamingBufferSize(int streamingBufferSize)
{    this.streamingBufferSize = streamingBufferSize;}
0
public SecureRandom getSecureRandom()
{    return secureRandom;}
0
public void setSecureRandom(SecureRandom secureRandom)
{    this.secureRandom = secureRandom;}
0
protected static SecureRandom getDefaultSecureRandom()
{    try {        return java.security.SecureRandom.getInstance(RANDOM_NUM_GENERATOR_ALGORITHM_NAME);    } catch (java.security.NoSuchAlgorithmException e) {                return new java.security.SecureRandom();    }}
1
protected SecureRandom ensureSecureRandom()
{    SecureRandom random = getSecureRandom();    if (random == null) {        random = getDefaultSecureRandom();    }    return random;}
0
protected String getTransformationString(boolean streaming)
{    return getAlgorithmName();}
0
protected byte[] generateInitializationVector(boolean streaming)
{    int size = getInitializationVectorSize();    if (size <= 0) {        String msg = "initializationVectorSize property must be greater than zero.  This number is " + "typically set in the " + CipherService.class.getSimpleName() + " subclass constructor.  " + "Also check your configuration to ensure that if you are setting a value, it is positive.";        throw new IllegalStateException(msg);    }    if (size % BITS_PER_BYTE != 0) {        String msg = "initializationVectorSize property must be a multiple of 8 to represent as a byte array.";        throw new IllegalStateException(msg);    }    int sizeInBytes = size / BITS_PER_BYTE;    byte[] ivBytes = new byte[sizeInBytes];    SecureRandom random = ensureSecureRandom();    random.nextBytes(ivBytes);    return ivBytes;}
0
public ByteSource encrypt(byte[] plaintext, byte[] key)
{    byte[] ivBytes = null;    boolean generate = isGenerateInitializationVectors(false);    if (generate) {        ivBytes = generateInitializationVector(false);        if (ivBytes == null || ivBytes.length == 0) {            throw new IllegalStateException("Initialization vector generation is enabled - generated vector" + "cannot be null or empty.");        }    }    return encrypt(plaintext, key, ivBytes, generate);}
0
private ByteSource encrypt(byte[] plaintext, byte[] key, byte[] iv, boolean prependIv) throws CryptoException
{    final int MODE = javax.crypto.Cipher.ENCRYPT_MODE;    byte[] output;    if (prependIv && iv != null && iv.length > 0) {        byte[] encrypted = crypt(plaintext, key, iv, MODE);        output = new byte[iv.length + encrypted.length];                        System.arraycopy(iv, 0, output, 0, iv.length);                System.arraycopy(encrypted, 0, output, iv.length, encrypted.length);    } else {        output = crypt(plaintext, key, iv, MODE);    }    if (log.isTraceEnabled()) {        log.trace("Incoming plaintext of size " + (plaintext != null ? plaintext.length : 0) + ".  Ciphertext " + "byte array is size " + (output != null ? output.length : 0));    }    return ByteSource.Util.bytes(output);}
0
public ByteSource decrypt(byte[] ciphertext, byte[] key) throws CryptoException
{    byte[] encrypted = ciphertext;        byte[] iv = null;    if (isGenerateInitializationVectors(false)) {        try {                                                                                                int ivSize = getInitializationVectorSize();            int ivByteSize = ivSize / BITS_PER_BYTE;                        iv = new byte[ivByteSize];            System.arraycopy(ciphertext, 0, iv, 0, ivByteSize);                        int encryptedSize = ciphertext.length - ivByteSize;            encrypted = new byte[encryptedSize];            System.arraycopy(ciphertext, ivByteSize, encrypted, 0, encryptedSize);        } catch (Exception e) {            String msg = "Unable to correctly extract the Initialization Vector or ciphertext.";            throw new CryptoException(msg, e);        }    }    return decrypt(encrypted, key, iv);}
0
private ByteSource decrypt(byte[] ciphertext, byte[] key, byte[] iv) throws CryptoException
{    if (log.isTraceEnabled()) {        log.trace("Attempting to decrypt incoming byte array of length " + (ciphertext != null ? ciphertext.length : 0));    }    byte[] decrypted = crypt(ciphertext, key, iv, javax.crypto.Cipher.DECRYPT_MODE);    return decrypted == null ? null : ByteSource.Util.bytes(decrypted);}
0
private javax.crypto.Cipher newCipherInstance(boolean streaming) throws CryptoException
{    String transformationString = getTransformationString(streaming);    try {        return javax.crypto.Cipher.getInstance(transformationString);    } catch (Exception e) {        String msg = "Unable to acquire a Java JCA Cipher instance using " + javax.crypto.Cipher.class.getName() + ".getInstance( \"" + transformationString + "\" ). " + getAlgorithmName() + " under this configuration is required for the " + getClass().getName() + " instance to function.";        throw new CryptoException(msg, e);    }}
0
private byte[] crypt(byte[] bytes, byte[] key, byte[] iv, int mode) throws IllegalArgumentException, CryptoException
{    if (key == null || key.length == 0) {        throw new IllegalArgumentException("key argument cannot be null or empty.");    }    javax.crypto.Cipher cipher = initNewCipher(mode, key, iv, false);    return crypt(cipher, bytes);}
0
private byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) throws CryptoException
{    try {        return cipher.doFinal(bytes);    } catch (Exception e) {        String msg = "Unable to execute 'doFinal' with cipher instance [" + cipher + "].";        throw new CryptoException(msg, e);    }}
0
private void init(javax.crypto.Cipher cipher, int mode, java.security.Key key, AlgorithmParameterSpec spec, SecureRandom random) throws CryptoException
{    try {        if (random != null) {            if (spec != null) {                cipher.init(mode, key, spec, random);            } else {                cipher.init(mode, key, random);            }        } else {            if (spec != null) {                cipher.init(mode, key, spec);            } else {                cipher.init(mode, key);            }        }    } catch (Exception e) {        String msg = "Unable to init cipher instance.";        throw new CryptoException(msg, e);    }}
0
public void encrypt(InputStream in, OutputStream out, byte[] key) throws CryptoException
{    byte[] iv = null;    boolean generate = isGenerateInitializationVectors(true);    if (generate) {        iv = generateInitializationVector(true);        if (iv == null || iv.length == 0) {            throw new IllegalStateException("Initialization vector generation is enabled - generated vector" + "cannot be null or empty.");        }    }    encrypt(in, out, key, iv, generate);}
0
private void encrypt(InputStream in, OutputStream out, byte[] key, byte[] iv, boolean prependIv) throws CryptoException
{    if (prependIv && iv != null && iv.length > 0) {        try {                        out.write(iv);        } catch (IOException e) {            throw new CryptoException(e);        }    }    crypt(in, out, key, iv, javax.crypto.Cipher.ENCRYPT_MODE);}
0
public void decrypt(InputStream in, OutputStream out, byte[] key) throws CryptoException
{    decrypt(in, out, key, isGenerateInitializationVectors(true));}
0
private void decrypt(InputStream in, OutputStream out, byte[] key, boolean ivPrepended) throws CryptoException
{    byte[] iv = null;        if (ivPrepended) {                        int ivSize = getInitializationVectorSize();        int ivByteSize = ivSize / BITS_PER_BYTE;        iv = new byte[ivByteSize];        int read;        try {            read = in.read(iv);        } catch (IOException e) {            String msg = "Unable to correctly read the Initialization Vector from the input stream.";            throw new CryptoException(msg, e);        }        if (read != ivByteSize) {            throw new CryptoException("Unable to read initialization vector bytes from the InputStream.  " + "This is required when initialization vectors are autogenerated during an encryption " + "operation.");        }    }    decrypt(in, out, key, iv);}
0
private void decrypt(InputStream in, OutputStream out, byte[] decryptionKey, byte[] iv) throws CryptoException
{    crypt(in, out, decryptionKey, iv, javax.crypto.Cipher.DECRYPT_MODE);}
0
private void crypt(InputStream in, OutputStream out, byte[] keyBytes, byte[] iv, int cryptMode) throws CryptoException
{    if (in == null) {        throw new NullPointerException("InputStream argument cannot be null.");    }    if (out == null) {        throw new NullPointerException("OutputStream argument cannot be null.");    }    javax.crypto.Cipher cipher = initNewCipher(cryptMode, keyBytes, iv, true);    CipherInputStream cis = new CipherInputStream(in, cipher);    int bufSize = getStreamingBufferSize();    byte[] buffer = new byte[bufSize];    int bytesRead;    try {        while ((bytesRead = cis.read(buffer)) != -1) {            out.write(buffer, 0, bytesRead);        }    } catch (IOException e) {        throw new CryptoException(e);    }}
0
private javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming) throws CryptoException
{    javax.crypto.Cipher cipher = newCipherInstance(streaming);    java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());    IvParameterSpec ivSpec = null;    if (iv != null && iv.length > 0) {        ivSpec = new IvParameterSpec(iv);    }    init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());    return cipher;}
0
public String getTransformationName()
{    return this.transformationName;}
0
public void setSeed(byte[] bytes)
{    this.secureRandom.setSeed(bytes);}
0
public SecureRandom getSecureRandom()
{    return secureRandom;}
0
public void setSecureRandom(SecureRandom random) throws NullPointerException
{    if (random == null) {        throw new NullPointerException("SecureRandom argument cannot be null.");    }    this.secureRandom = random;}
0
public int getDefaultNextBytesSize()
{    return defaultNextBytesSize;}
0
public void setDefaultNextBytesSize(int defaultNextBytesSize) throws IllegalArgumentException
{    if (defaultNextBytesSize <= 0) {        throw new IllegalArgumentException("size value must be a positive integer (1 or larger)");    }    this.defaultNextBytesSize = defaultNextBytesSize;}
0
public ByteSource nextBytes()
{    return nextBytes(getDefaultNextBytesSize());}
0
public ByteSource nextBytes(int numBytes)
{    if (numBytes <= 0) {        throw new IllegalArgumentException("numBytes argument must be a positive integer (1 or larger)");    }    byte[] bytes = new byte[numBytes];    this.secureRandom.nextBytes(bytes);    return ByteSource.Util.bytes(bytes);}
0
public byte[] getBytes()
{    return this.bytes;}
0
public void setBytes(byte[] alreadyHashedBytes)
{    this.bytes = alreadyHashedBytes;    this.hexEncoded = null;    this.base64Encoded = null;}
0
protected MessageDigest getDigest(String algorithmName) throws UnknownAlgorithmException
{    try {        return MessageDigest.getInstance(algorithmName);    } catch (NoSuchAlgorithmException e) {        String msg = "No native '" + algorithmName + "' MessageDigest instance available on the current JVM.";        throw new UnknownAlgorithmException(msg, e);    }}
0
protected byte[] hash(byte[] bytes)
{    return hash(bytes, null, 1);}
0
protected byte[] hash(byte[] bytes, byte[] salt)
{    return hash(bytes, salt, 1);}
0
protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) throws UnknownAlgorithmException
{    MessageDigest digest = getDigest(getAlgorithmName());    if (salt != null) {        digest.reset();        digest.update(salt);    }    byte[] hashed = digest.digest(bytes);        int iterations = hashIterations - 1;        for (int i = 0; i < iterations; i++) {        digest.reset();        hashed = digest.digest(hashed);    }    return hashed;}
0
public String toHex()
{    if (this.hexEncoded == null) {        this.hexEncoded = Hex.encodeToString(getBytes());    }    return this.hexEncoded;}
0
public String toBase64()
{    if (this.base64Encoded == null) {                this.base64Encoded = Base64.encodeToString(getBytes());    }    return this.base64Encoded;}
0
public String toString()
{    return toHex();}
0
public boolean equals(Object o)
{    if (o instanceof Hash) {        Hash other = (Hash) o;        return MessageDigest.isEqual(getBytes(), other.getBytes());    }    return false;}
0
public int hashCode()
{    if (this.bytes == null || this.bytes.length == 0) {        return 0;    }    return Arrays.hashCode(this.bytes);}
0
private static void printMainUsage(Class<? extends AbstractHash> clazz, String type)
{    System.out.println("Prints an " + type + " hash value.");    System.out.println("Usage: java " + clazz.getName() + " [-base64] [-salt <saltValue>] [-times <N>] <valueToHash>");    System.out.println("Options:");    System.out.println("\t-base64\t\tPrints the hash value as a base64 String instead of the default hex.");    System.out.println("\t-salt\t\tSalts the hash with the specified <saltValue>");    System.out.println("\t-times\t\tHashes the input <N> number of times");}
0
private static boolean isReserved(String arg)
{    return "-base64".equals(arg) || "-times".equals(arg) || "-salt".equals(arg);}
0
 static int doMain(Class<? extends AbstractHash> clazz, String[] args)
{    String simple = clazz.getSimpleName();    int index = simple.indexOf("Hash");    String type = simple.substring(0, index).toUpperCase();    if (args == null || args.length < 1 || args.length > 7) {        printMainUsage(clazz, type);        return -1;    }    boolean hex = true;    String salt = null;    int times = 1;    String text = args[args.length - 1];    for (int i = 0; i < args.length; i++) {        String arg = args[i];        if (arg.equals("-base64")) {            hex = false;        } else if (arg.equals("-salt")) {            if ((i + 1) >= (args.length - 1)) {                String msg = "Salt argument must be followed by a salt value.  The final argument is " + "reserved for the value to hash.";                System.out.println(msg);                printMainUsage(clazz, type);                return -1;            }            salt = args[i + 1];        } else if (arg.equals("-times")) {            if ((i + 1) >= (args.length - 1)) {                String msg = "Times argument must be followed by an integer value.  The final argument is " + "reserved for the value to hash";                System.out.println(msg);                printMainUsage(clazz, type);                return -1;            }            try {                times = Integer.valueOf(args[i + 1]);            } catch (NumberFormatException e) {                String msg = "Times argument must be followed by an integer value.";                System.out.println(msg);                printMainUsage(clazz, type);                return -1;            }        }    }    Hash hash = new Md2Hash(text, salt, times);    String hashed = hex ? hash.toHex() : hash.toBase64();    System.out.print(hex ? "Hex: " : "Base64: ");    System.out.println(hashed);    return 0;}
0
public Hash computeHash(HashRequest request)
{    if (request == null || request.getSource() == null || request.getSource().isEmpty()) {        return null;    }    String algorithmName = getAlgorithmName(request);    ByteSource source = request.getSource();    int iterations = getIterations(request);    ByteSource publicSalt = getPublicSalt(request);    ByteSource privateSalt = getPrivateSalt();    ByteSource salt = combine(privateSalt, publicSalt);    Hash computed = new SimpleHash(algorithmName, source, salt, iterations);    SimpleHash result = new SimpleHash(algorithmName);    result.setBytes(computed.getBytes());    result.setIterations(iterations);        result.setSalt(publicSalt);    return result;}
0
protected String getAlgorithmName(HashRequest request)
{    String name = request.getAlgorithmName();    if (name == null) {        name = getHashAlgorithmName();    }    return name;}
0
protected int getIterations(HashRequest request)
{    int iterations = Math.max(0, request.getIterations());    if (iterations < 1) {        iterations = Math.max(1, getHashIterations());    }    return iterations;}
0
protected ByteSource getPublicSalt(HashRequest request)
{    ByteSource publicSalt = request.getSalt();    if (publicSalt != null && !publicSalt.isEmpty()) {                return publicSalt;    }    publicSalt = null;        ByteSource privateSalt = getPrivateSalt();    boolean privateSaltExists = privateSalt != null && !privateSalt.isEmpty();        if (privateSaltExists || isGeneratePublicSalt()) {        publicSalt = getRandomNumberGenerator().nextBytes();    }    return publicSalt;}
0
protected ByteSource combine(ByteSource privateSalt, ByteSource publicSalt)
{    byte[] privateSaltBytes = privateSalt != null ? privateSalt.getBytes() : null;    int privateSaltLength = privateSaltBytes != null ? privateSaltBytes.length : 0;    byte[] publicSaltBytes = publicSalt != null ? publicSalt.getBytes() : null;    int extraBytesLength = publicSaltBytes != null ? publicSaltBytes.length : 0;    int length = privateSaltLength + extraBytesLength;    if (length <= 0) {        return null;    }    byte[] combined = new byte[length];    int i = 0;    for (int j = 0; j < privateSaltLength; j++) {        assert privateSaltBytes != null;        combined[i++] = privateSaltBytes[j];    }    for (int j = 0; j < extraBytesLength; j++) {        assert publicSaltBytes != null;        combined[i++] = publicSaltBytes[j];    }    return ByteSource.Util.bytes(combined);}
0
public void setHashAlgorithmName(String name)
{    this.algorithmName = name;}
0
public String getHashAlgorithmName()
{    return this.algorithmName;}
0
public void setPrivateSalt(ByteSource privateSalt)
{    this.privateSalt = privateSalt;}
0
public ByteSource getPrivateSalt()
{    return this.privateSalt;}
0
public void setHashIterations(int count)
{    this.iterations = count;}
0
public int getHashIterations()
{    return this.iterations;}
0
public void setRandomNumberGenerator(RandomNumberGenerator rng)
{    this.rng = rng;}
0
public RandomNumberGenerator getRandomNumberGenerator()
{    return this.rng;}
0
public boolean isGeneratePublicSalt()
{    return generatePublicSalt;}
0
public void setGeneratePublicSalt(boolean generatePublicSalt)
{    this.generatePublicSalt = generatePublicSalt;}
0
public String format(Hash hash)
{    return hash != null ? hash.toBase64() : null;}
0
public Map<String, String> getFormatClassNames()
{    return formatClassNames;}
0
public void setFormatClassNames(Map<String, String> formatClassNames)
{    this.formatClassNames = formatClassNames;}
0
public Set<String> getSearchPackages()
{    return searchPackages;}
0
public void setSearchPackages(Set<String> searchPackages)
{    this.searchPackages = searchPackages;}
0
public HashFormat getInstance(String in)
{    if (in == null) {        return null;    }    HashFormat hashFormat = null;    Class clazz = null;        if (in.startsWith(ModularCryptFormat.TOKEN_DELIMITER)) {                        String test = in.substring(ModularCryptFormat.TOKEN_DELIMITER.length());        String[] tokens = test.split("\\" + ModularCryptFormat.TOKEN_DELIMITER);                String possibleMcfId = (tokens != null && tokens.length > 0) ? tokens[0] : null;        if (possibleMcfId != null) {                        clazz = getHashFormatClass(possibleMcfId);        }    }    if (clazz == null) {                clazz = getHashFormatClass(in);    }    if (clazz != null) {                hashFormat = newHashFormatInstance(clazz);    }    return hashFormat;}
0
protected Class getHashFormatClass(String token)
{    Class clazz = null;        if (this.formatClassNames != null) {        String value = this.formatClassNames.get(token);        if (value != null) {                        clazz = lookupHashFormatClass(value);        }    }        if (clazz == null) {        ProvidedHashFormat provided = ProvidedHashFormat.byId(token);        if (provided != null) {            clazz = provided.getHashFormatClass();        }    }    if (clazz == null) {                clazz = lookupHashFormatClass(token);    }    if (clazz == null) {                if (this.searchPackages != null) {            for (String packageName : this.searchPackages) {                clazz = getHashFormatClass(packageName, token);                if (clazz != null) {                                        break;                }            }        }    }    if (clazz != null) {        assertHashFormatImpl(clazz);    }    return clazz;}
0
protected Class getHashFormatClass(String packageName, String token)
{    String test = token;    Class clazz = null;    String pkg = packageName == null ? "" : packageName;        clazz = lookupHashFormatClass(test);    if (clazz == null) {        test = pkg + "." + token;        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + StringUtils.uppercaseFirstChar(token) + "Format";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + token + "Format";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + StringUtils.uppercaseFirstChar(token) + "HashFormat";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + token + "HashFormat";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + StringUtils.uppercaseFirstChar(token) + "CryptFormat";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {        test = pkg + "." + token + "CryptFormat";        clazz = lookupHashFormatClass(test);    }    if (clazz == null) {                return null;    }    assertHashFormatImpl(clazz);    return clazz;}
0
protected Class lookupHashFormatClass(String name)
{    try {        return ClassUtils.forName(name);    } catch (UnknownClassException ignored) {    }    return null;}
0
protected final void assertHashFormatImpl(Class clazz)
{    if (!HashFormat.class.isAssignableFrom(clazz) || clazz.isInterface()) {        throw new IllegalArgumentException("Discovered class [" + clazz.getName() + "] is not a " + HashFormat.class.getName() + " implementation.");    }}
0
protected final HashFormat newHashFormatInstance(Class clazz)
{    assertHashFormatImpl(clazz);    return (HashFormat) ClassUtils.newInstance(clazz);}
0
public String format(Hash hash)
{    return hash != null ? hash.toHex() : null;}
0
 Class<? extends HashFormat> getHashFormatClass()
{    return this.clazz;}
0
public static ProvidedHashFormat byId(String id)
{    if (id == null) {        return null;    }    try {                return valueOf(id.toUpperCase(Locale.ENGLISH));    } catch (IllegalArgumentException ignored) {        return null;    }}
0
public String getId()
{    return ID;}
0
public String format(Hash hash)
{    if (hash == null) {        return null;    }    String algorithmName = hash.getAlgorithmName();    ByteSource salt = hash.getSalt();    int iterations = hash.getIterations();    StringBuilder sb = new StringBuilder(MCF_PREFIX).append(algorithmName).append(TOKEN_DELIMITER).append(iterations).append(TOKEN_DELIMITER);    if (salt != null) {        sb.append(salt.toBase64());    }    sb.append(TOKEN_DELIMITER);    sb.append(hash.toBase64());    return sb.toString();}
0
public Hash parse(String formatted)
{    if (formatted == null) {        return null;    }    if (!formatted.startsWith(MCF_PREFIX)) {                String msg = "The argument is not a valid '" + ID + "' formatted hash.";        throw new IllegalArgumentException(msg);    }    String suffix = formatted.substring(MCF_PREFIX.length());    String[] parts = suffix.split("\\$");        int i = parts.length - 1;    String digestBase64 = parts[i--];        String saltBase64 = parts[i--];    String iterationsString = parts[i--];    String algorithmName = parts[i];    byte[] digest = Base64.decode(digestBase64);    ByteSource salt = null;    if (StringUtils.hasLength(saltBase64)) {        byte[] saltBytes = Base64.decode(saltBase64);        salt = ByteSource.Util.bytes(saltBytes);    }    int iterations;    try {        iterations = Integer.parseInt(iterationsString);    } catch (NumberFormatException e) {        String msg = "Unable to parse formatted hash string: " + formatted;        throw new IllegalArgumentException(msg, e);    }    SimpleHash hash = new SimpleHash(algorithmName);    hash.setBytes(digest);    if (salt != null) {        hash.setSalt(salt);    }    hash.setIterations(iterations);    return hash;}
0
public Builder setSource(ByteSource source)
{    this.source = source;    return this;}
0
public Builder setSource(Object source) throws IllegalArgumentException
{    this.source = ByteSource.Util.bytes(source);    return this;}
0
public Builder setSalt(ByteSource salt)
{    this.salt = salt;    return this;}
0
public Builder setSalt(Object salt) throws IllegalArgumentException
{    this.salt = ByteSource.Util.bytes(salt);    return this;}
0
public Builder setIterations(int iterations)
{    this.iterations = iterations;    return this;}
0
public Builder setAlgorithmName(String algorithmName)
{    this.algorithmName = algorithmName;    return this;}
0
public HashRequest build()
{    return new SimpleHashRequest(this.algorithmName, this.source, this.salt, this.iterations);}
0
public static Md2Hash fromHexString(String hex)
{    Md2Hash hash = new Md2Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Md2Hash fromBase64String(String base64)
{    Md2Hash hash = new Md2Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
public static Md5Hash fromHexString(String hex)
{    Md5Hash hash = new Md5Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Md5Hash fromBase64String(String base64)
{    Md5Hash hash = new Md5Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
public static Sha1Hash fromHexString(String hex)
{    Sha1Hash hash = new Sha1Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Sha1Hash fromBase64String(String base64)
{    Sha1Hash hash = new Sha1Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
public static Sha256Hash fromHexString(String hex)
{    Sha256Hash hash = new Sha256Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Sha256Hash fromBase64String(String base64)
{    Sha256Hash hash = new Sha256Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
public static Sha384Hash fromHexString(String hex)
{    Sha384Hash hash = new Sha384Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Sha384Hash fromBase64String(String base64)
{    Sha384Hash hash = new Sha384Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
public static Sha512Hash fromHexString(String hex)
{    Sha512Hash hash = new Sha512Hash();    hash.setBytes(Hex.decode(hex));    return hash;}
0
public static Sha512Hash fromBase64String(String base64)
{    Sha512Hash hash = new Sha512Hash();    hash.setBytes(Base64.decode(base64));    return hash;}
0
protected ByteSource convertSourceToBytes(Object source)
{    return toByteSource(source);}
0
protected ByteSource convertSaltToBytes(Object salt)
{    return toByteSource(salt);}
0
protected ByteSource toByteSource(Object o)
{    if (o == null) {        return null;    }    if (o instanceof ByteSource) {        return (ByteSource) o;    }    byte[] bytes = toBytes(o);    return ByteSource.Util.bytes(bytes);}
0
private void hash(ByteSource source, ByteSource salt, int hashIterations) throws CodecException, UnknownAlgorithmException
{    byte[] saltBytes = salt != null ? salt.getBytes() : null;    byte[] hashedBytes = hash(source.getBytes(), saltBytes, hashIterations);    setBytes(hashedBytes);}
0
public String getAlgorithmName()
{    return this.algorithmName;}
0
public ByteSource getSalt()
{    return this.salt;}
0
public int getIterations()
{    return this.iterations;}
0
public byte[] getBytes()
{    return this.bytes;}
0
public void setBytes(byte[] alreadyHashedBytes)
{    this.bytes = alreadyHashedBytes;    this.hexEncoded = null;    this.base64Encoded = null;}
0
public void setIterations(int iterations)
{    this.iterations = Math.max(DEFAULT_ITERATIONS, iterations);}
0
public void setSalt(ByteSource salt)
{    this.salt = salt;}
0
protected MessageDigest getDigest(String algorithmName) throws UnknownAlgorithmException
{    try {        return MessageDigest.getInstance(algorithmName);    } catch (NoSuchAlgorithmException e) {        String msg = "No native '" + algorithmName + "' MessageDigest instance available on the current JVM.";        throw new UnknownAlgorithmException(msg, e);    }}
0
protected byte[] hash(byte[] bytes) throws UnknownAlgorithmException
{    return hash(bytes, null, DEFAULT_ITERATIONS);}
0
protected byte[] hash(byte[] bytes, byte[] salt) throws UnknownAlgorithmException
{    return hash(bytes, salt, DEFAULT_ITERATIONS);}
0
protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) throws UnknownAlgorithmException
{    MessageDigest digest = getDigest(getAlgorithmName());    if (salt != null) {        digest.reset();        digest.update(salt);    }    byte[] hashed = digest.digest(bytes);        int iterations = hashIterations - 1;        for (int i = 0; i < iterations; i++) {        digest.reset();        hashed = digest.digest(hashed);    }    return hashed;}
0
public boolean isEmpty()
{    return this.bytes == null || this.bytes.length == 0;}
0
public String toHex()
{    if (this.hexEncoded == null) {        this.hexEncoded = Hex.encodeToString(getBytes());    }    return this.hexEncoded;}
0
public String toBase64()
{    if (this.base64Encoded == null) {                this.base64Encoded = Base64.encodeToString(getBytes());    }    return this.base64Encoded;}
0
public String toString()
{    return toHex();}
0
public boolean equals(Object o)
{    if (o instanceof Hash) {        Hash other = (Hash) o;        return MessageDigest.isEqual(getBytes(), other.getBytes());    }    return false;}
0
public int hashCode()
{    if (this.bytes == null || this.bytes.length == 0) {        return 0;    }    return Arrays.hashCode(this.bytes);}
0
public ByteSource getSource()
{    return this.source;}
0
public ByteSource getSalt()
{    return this.salt;}
0
public int getIterations()
{    return iterations;}
0
public String getAlgorithmName()
{    return algorithmName;}
0
public long getTimestamp()
{    return this.timestamp;}
0
public List<EventListener> getEventListeners(Object instance)
{    if (instance == null) {        return Collections.emptyList();    }    List<Method> methods = ClassUtils.getAnnotatedMethods(instance.getClass(), getAnnotationClass());    if (methods == null || methods.isEmpty()) {        return Collections.emptyList();    }    List<EventListener> listeners = new ArrayList<EventListener>(methods.size());    for (Method m : methods) {        listeners.add(new SingleArgumentMethodEventListener(instance, m));    }    return listeners;}
0
public Class<? extends Annotation> getAnnotationClass()
{    return annotationClass;}
0
public void setAnnotationClass(Class<? extends Annotation> annotationClass)
{    this.annotationClass = annotationClass;}
0
public EventListenerResolver getEventListenerResolver()
{    return eventListenerResolver;}
0
public void setEventListenerResolver(EventListenerResolver eventListenerResolver)
{    this.eventListenerResolver = eventListenerResolver;}
0
public void publish(Object event)
{    if (event == null) {                return;    }    registryReadLock.lock();    try {        for (Subscription subscription : this.registry.values()) {            subscription.onEvent(event);        }    } finally {        registryReadLock.unlock();    }}
1
public void register(Object instance)
{    if (instance == null) {                return;    }    unregister(instance);    List<EventListener> listeners = getEventListenerResolver().getEventListeners(instance);    if (listeners == null || listeners.isEmpty()) {                return;    }    Subscription subscription = new Subscription(listeners);    this.registryWriteLock.lock();    try {        this.registry.put(instance, subscription);    } finally {        this.registryWriteLock.unlock();    }}
1
public void unregister(Object instance)
{    if (instance == null) {        return;    }    this.registryWriteLock.lock();    try {        this.registry.remove(instance);    } finally {        this.registryWriteLock.unlock();    }}
0
public void onEvent(Object event)
{    Set<Object> delivered = new HashSet<Object>();    for (EventListener listener : this.listeners) {        Object target = listener;        if (listener instanceof SingleArgumentMethodEventListener) {            SingleArgumentMethodEventListener singleArgListener = (SingleArgumentMethodEventListener) listener;            target = singleArgListener.getTarget();        }        if (listener.accepts(event) && !delivered.contains(target)) {            try {                listener.onEvent(event);            } catch (Throwable t) {                            }            delivered.add(target);        }    }}
1
public int compare(Class a, Class b)
{    if (a == null) {        if (b == null) {            return 0;        } else {            return -1;        }    } else if (b == null) {        return 1;    } else if (a == b || a.equals(b)) {        return 0;    } else {        if (a.isAssignableFrom(b)) {            return 1;        } else if (b.isAssignableFrom(a)) {            return -1;        } else {            return 0;        }    }}
0
public int compare(EventListener a, EventListener b)
{    if (a == null) {        if (b == null) {            return 0;        } else {            return -1;        }    } else if (b == null) {        return 1;    } else if (a == b || a.equals(b)) {        return 0;    } else {        if (a instanceof TypedEventListener) {            TypedEventListener ta = (TypedEventListener) a;            if (b instanceof TypedEventListener) {                TypedEventListener tb = (TypedEventListener) b;                return EVENT_CLASS_COMPARATOR.compare(ta.getEventType(), tb.getEventType());            } else {                                return -1;            }        } else {            if (b instanceof TypedEventListener) {                return 1;            } else {                return 0;            }        }    }}
0
public Object getTarget()
{    return this.target;}
0
public Method getMethod()
{    return this.method;}
0
private void assertPublicMethod(Method method)
{    int modifiers = method.getModifiers();    if (!Modifier.isPublic(modifiers)) {        throw new IllegalArgumentException("Event handler method [" + method + "] must be public.");    }}
0
public boolean accepts(Object event)
{    return event != null && getEventType().isInstance(event);}
0
public Class getEventType()
{    return getMethodArgumentType(getMethod());}
0
public void onEvent(Object event)
{    Method method = getMethod();    try {        method.invoke(getTarget(), event);    } catch (Exception e) {        throw new IllegalStateException("Unable to invoke event handler method [" + method + "].", e);    }}
0
protected Class getMethodArgumentType(Method method)
{    Class[] paramTypes = method.getParameterTypes();    if (paramTypes.length != 1) {                String msg = "Event handler methods must accept a single argument.";        throw new IllegalArgumentException(msg);    }    return paramTypes[0];}
0
public void contextInitialized(final ServletContextEvent servletContextEvent)
{    this.servletContext = servletContextEvent.getServletContext();    super.contextInitialized(servletContextEvent);}
0
protected Injector getInjector()
{    return Guice.createInjector(new SampleShiroServletModule(servletContext), ShiroWebModule.guiceFilterModule());}
0
protected void configureShiroWeb()
{    bindConstant().annotatedWith(Names.named("shiro.loginUrl")).to("/login.jsp");    try {        this.bindRealm().toConstructor(IniRealm.class.getConstructor(Ini.class));    } catch (NoSuchMethodException e) {        addError("Could not locate proper constructor for IniRealm.", e);    }    this.addFilterChain("/login.jsp", AUTHC);    this.addFilterChain("/logout", LOGOUT);    this.addFilterChain("/account/**", AUTHC);    this.addFilterChain("/remoting/**", AUTHC, config(ROLES, "b2bClient"), config(PERMS, "remote:invoke:lan,wan"));}
0
 Ini loadShiroIni() throws MalformedURLException
{    URL iniUrl = servletContext.getResource("/WEB-INF/shiro.ini");    return Ini.fromResourcePath("url:" + iniUrl.toExternalForm());}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    try {        String cipherKey = loadShiroIni().getSectionProperty("main", "securityManager.rememberMeManager.cipherKey");        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        CookieRememberMeManager rememberMeManager = new CookieRememberMeManager();        rememberMeManager.setCipherKey(Base64.decode(cipherKey));        securityManager.setRememberMeManager(rememberMeManager);        bind.toInstance(securityManager);    } catch (MalformedURLException e) {                throw new ConfigurationException("securityManager.rememberMeManager.cipherKey must be set in shiro.ini.");    }}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    page = form.<HtmlInput>getInputByName("submit").click();        page.getAnchorByHref("/logout");}
0
public void logInAndRememberMe() throws Exception
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    HtmlCheckBoxInput checkbox = form.getInputByName("rememberMe");    checkbox.setChecked(true);    page = form.<HtmlInput>getInputByName("submit").click();    jetty.stop();    jetty.start();    page = webClient.getPage(getBaseUri());        WebAssert.assertLinkPresentWithText(page, "Log out");    page = page.getAnchorByHref("/account").click();        WebAssert.assertFormPresent(page, "loginform");}
0
public void contextInitialized(final ServletContextEvent servletContextEvent)
{    this.servletContext = servletContextEvent.getServletContext();    super.contextInitialized(servletContextEvent);}
0
protected Injector getInjector()
{    return Guice.createInjector(new SampleShiroServletModule(servletContext), ShiroWebModule.guiceFilterModule());}
0
protected void configureShiroWeb()
{    bindConstant().annotatedWith(Names.named("shiro.loginUrl")).to("/login.jsp");    try {        this.bindRealm().toConstructor(IniRealm.class.getConstructor(Ini.class));    } catch (NoSuchMethodException e) {        addError("Could not locate proper constructor for IniRealm.", e);    }    this.addFilterChain("/login.jsp", AUTHC);    this.addFilterChain("/logout", LOGOUT);    this.addFilterChain("/account/**", AUTHC);    this.addFilterChain("/remoting/**", filterConfig(AUTHC), filterConfig(ROLES, "b2bClient"), filterConfig(PERMS, "remote:invoke:lan,wan"));}
0
 Ini loadShiroIni() throws MalformedURLException
{    URL iniUrl = servletContext.getResource("/WEB-INF/shiro.ini");    return Ini.fromResourcePath("url:" + iniUrl.toExternalForm());}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    try {        String cipherKey = loadShiroIni().getSectionProperty("main", "securityManager.rememberMeManager.cipherKey");        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        CookieRememberMeManager rememberMeManager = new CookieRememberMeManager();        rememberMeManager.setCipherKey(Base64.decode(cipherKey));        securityManager.setRememberMeManager(rememberMeManager);        bind.toInstance(securityManager);    } catch (MalformedURLException e) {                throw new ConfigurationException("securityManager.rememberMeManager.cipherKey must be set in shiro.ini.");    }}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    page = form.<HtmlInput>getInputByName("submit").click();        page.getAnchorByHref("/logout");}
0
public void logInAndRememberMe() throws Exception
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    HtmlCheckBoxInput checkbox = form.getInputByName("rememberMe");    checkbox.setChecked(true);    page = form.<HtmlInput>getInputByName("submit").click();    jetty.stop();    jetty.start();    page = webClient.getPage(getBaseUri());        WebAssert.assertLinkPresentWithText(page, "Log out");    page = page.getAnchorByHref("/account").click();        WebAssert.assertFormPresent(page, "loginform");}
0
public static void startContainer() throws Exception
{    EmbeddedJettyConfiguration config = EmbeddedJettyConfiguration.builder().withWebapp(getWarDir()).build();    jetty = new EmbeddedJetty(config) {        /**         * Overriding with contents of this pull request, to make fragment scanning work.         * https://github.com/mjeanroy/junit-servers/pull/3         */        protected WebAppContext createdWebAppContext() throws Exception {            final String path = configuration.getPath();            final String webapp = configuration.getWebapp();            final String classpath = configuration.getClasspath();            WebAppContext ctx = new WebAppContext();            ctx.setClassLoader(Thread.currentThread().getContextClassLoader());            ctx.setContextPath(path);                        ctx.setBaseResource(newResource(webapp));            ctx.setConfigurations(new Configuration[] { new WebInfConfiguration(), new WebXmlConfiguration(), new AnnotationConfiguration(), new JettyWebXmlConfiguration(), new MetaInfConfiguration(), new FragmentConfiguration() });            if (isNotBlank(classpath)) {                                                                                File classes = new File(classpath);                FileResource containerResources = new FileResource(classes.toURI());                ctx.getMetaData().addContainerResource(containerResources);            }            Server server = getDelegate();            ctx.setParentLoaderPriority(true);            ctx.setWar(webapp);            ctx.setServer(server);                        server.setHandler(ctx);            return ctx;        }    };    jetty.start();    assertTrue(jetty.isStarted());}
0
protected WebAppContext createdWebAppContext() throws Exception
{    final String path = configuration.getPath();    final String webapp = configuration.getWebapp();    final String classpath = configuration.getClasspath();    WebAppContext ctx = new WebAppContext();    ctx.setClassLoader(Thread.currentThread().getContextClassLoader());    ctx.setContextPath(path);        ctx.setBaseResource(newResource(webapp));    ctx.setConfigurations(new Configuration[] { new WebInfConfiguration(), new WebXmlConfiguration(), new AnnotationConfiguration(), new JettyWebXmlConfiguration(), new MetaInfConfiguration(), new FragmentConfiguration() });    if (isNotBlank(classpath)) {                                        File classes = new File(classpath);        FileResource containerResources = new FileResource(classes.toURI());        ctx.getMetaData().addContainerResource(containerResources);    }    Server server = getDelegate();    ctx.setParentLoaderPriority(true);    ctx.setWar(webapp);    ctx.setServer(server);        server.setHandler(ctx);    return ctx;}
0
protected static String getBaseUri()
{    return "http://localhost:" + jetty.getPort() + "/";}
0
protected static String getWarDir()
{    File[] warFiles = new File("target").listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.endsWith(".war");        }    });    assertEquals("Expected only one war file in target directory, run 'mvn clean' and try again", 1, warFiles.length);    return warFiles[0].getAbsolutePath().replaceFirst("\\.war$", "");}
0
public boolean accept(File dir, String name)
{    return name.endsWith(".war");}
0
protected static String getBasicAuthorizationHeaderValue(String username, String password) throws UnsupportedEncodingException
{    String authorizationHeader = username + ":" + password;    byte[] valueBytes;    valueBytes = authorizationHeader.getBytes("UTF-8");    authorizationHeader = new String(Base64.encode(valueBytes));    return "Basic " + authorizationHeader;}
0
public void beforeTest()
{    webClient.getOptions().setThrowExceptionOnFailingStatusCode(true);}
0
public static void stopContainer()
{    if (jetty != null) {        jetty.stop();    }}
0
private static boolean isBase64(byte octect)
{    if (octect == PAD) {        return true;    } else     if (octect < 0 || base64Alphabet[octect] == -1) {        return false;    } else {        return true;    }}
0
public static boolean isBase64(byte[] arrayOctect)
{    arrayOctect = discardWhitespace(arrayOctect);    int length = arrayOctect.length;    if (length == 0) {                return true;    }    for (int i = 0; i < length; i++) {        if (!isBase64(arrayOctect[i])) {            return false;        }    }    return true;}
0
 static byte[] discardWhitespace(byte[] data)
{    byte[] groomedData = new byte[data.length];    int bytesCopied = 0;    for (byte aByte : data) {        switch(aByte) {            case (byte) ' ':            case (byte) '\n':            case (byte) '\r':            case (byte) '\t':                break;            default:                groomedData[bytesCopied++] = aByte;        }    }    byte[] packedData = new byte[bytesCopied];    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);    return packedData;}
0
public static String encodeToString(byte[] bytes)
{    byte[] encoded = encode(bytes);    return CodecSupport.toString(encoded);}
0
public static byte[] encodeChunked(byte[] binaryData)
{    return encode(binaryData, true);}
0
public static byte[] encode(byte[] pArray)
{    return encode(pArray, false);}
0
public static byte[] encode(byte[] binaryData, boolean isChunked)
{    long binaryDataLength = binaryData.length;    long lengthDataBits = binaryDataLength * EIGHTBIT;    long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;    long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;    long encodedDataLengthLong;    int chunckCount = 0;    if (fewerThan24bits != 0) {                encodedDataLengthLong = (tripletCount + 1) * 4;    } else {                encodedDataLengthLong = tripletCount * 4;    }        if (isChunked) {        chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE));        encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;    }    if (encodedDataLengthLong > Integer.MAX_VALUE) {        throw new IllegalArgumentException("Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer.MAX_VALUE);    }    int encodedDataLength = (int) encodedDataLengthLong;    byte[] encodedData = new byte[encodedDataLength];    byte k, l, b1, b2, b3;    int encodedIndex = 0;    int dataIndex;    int i;    int nextSeparatorIndex = CHUNK_SIZE;    int chunksSoFar = 0;        for (i = 0; i < tripletCount; i++) {        dataIndex = i * 3;        b1 = binaryData[dataIndex];        b2 = binaryData[dataIndex + 1];        b3 = binaryData[dataIndex + 2];                l = (byte) (b2 & 0x0f);        k = (byte) (b1 & 0x03);        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);        byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);        byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);        encodedData[encodedIndex] = lookUpBase64Alphabet[val1];                                encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];        encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];        encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];        encodedIndex += 4;                if (isChunked) {                        if (encodedIndex == nextSeparatorIndex) {                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);                chunksSoFar++;                nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);                encodedIndex += CHUNK_SEPARATOR.length;            }        }    }        dataIndex = i * 3;    if (fewerThan24bits == EIGHTBIT) {        b1 = binaryData[dataIndex];        k = (byte) (b1 & 0x03);                        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);        encodedData[encodedIndex] = lookUpBase64Alphabet[val1];        encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];        encodedData[encodedIndex + 2] = PAD;        encodedData[encodedIndex + 3] = PAD;    } else if (fewerThan24bits == SIXTEENBIT) {        b1 = binaryData[dataIndex];        b2 = binaryData[dataIndex + 1];        l = (byte) (b2 & 0x0f);        k = (byte) (b1 & 0x03);        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);        byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);        encodedData[encodedIndex] = lookUpBase64Alphabet[val1];        encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];        encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];        encodedData[encodedIndex + 3] = PAD;    }    if (isChunked) {                if (chunksSoFar < chunckCount) {            System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);        }    }    return encodedData;}
0
public static String decodeToString(String base64Encoded)
{    byte[] encodedBytes = CodecSupport.toBytes(base64Encoded);    return decodeToString(encodedBytes);}
0
public static String decodeToString(byte[] base64Encoded)
{    byte[] decoded = decode(base64Encoded);    return CodecSupport.toString(decoded);}
0
public static byte[] decode(String base64Encoded)
{    byte[] bytes = CodecSupport.toBytes(base64Encoded);    return decode(bytes);}
0
public static byte[] decode(byte[] base64Data)
{        base64Data = discardNonBase64(base64Data);        if (base64Data.length == 0) {        return new byte[0];    }    int numberQuadruple = base64Data.length / FOURBYTE;    byte[] decodedData;    byte b1, b2, b3, b4, marker0, marker1;        int encodedIndex = 0;    int dataIndex;    {                int lastData = base64Data.length;                while (base64Data[lastData - 1] == PAD) {            if (--lastData == 0) {                return new byte[0];            }        }        decodedData = new byte[lastData - numberQuadruple];    }    for (int i = 0; i < numberQuadruple; i++) {        dataIndex = i * 4;        marker0 = base64Data[dataIndex + 2];        marker1 = base64Data[dataIndex + 3];        b1 = base64Alphabet[base64Data[dataIndex]];        b2 = base64Alphabet[base64Data[dataIndex + 1]];        if (marker0 != PAD && marker1 != PAD) {                        b3 = base64Alphabet[marker0];            b4 = base64Alphabet[marker1];            decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);            decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));            decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);        } else if (marker0 == PAD) {                        decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);        } else {                        b3 = base64Alphabet[marker0];            decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);            decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));        }        encodedIndex += 3;    }    return decodedData;}
0
 static byte[] discardNonBase64(byte[] data)
{    byte[] groomedData = new byte[data.length];    int bytesCopied = 0;    for (byte aByte : data) {        if (isBase64(aByte)) {            groomedData[bytesCopied++] = aByte;        }    }    byte[] packedData = new byte[bytesCopied];    System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);    return packedData;}
0
public static byte[] toBytes(char[] chars)
{    return toBytes(new String(chars), PREFERRED_ENCODING);}
0
public static byte[] toBytes(char[] chars, String encoding) throws CodecException
{    return toBytes(new String(chars), encoding);}
0
public static byte[] toBytes(String source)
{    return toBytes(source, PREFERRED_ENCODING);}
0
public static byte[] toBytes(String source, String encoding) throws CodecException
{    try {        return source.getBytes(encoding);    } catch (UnsupportedEncodingException e) {        String msg = "Unable to convert source [" + source + "] to byte array using " + "encoding '" + encoding + "'";        throw new CodecException(msg, e);    }}
0
public static String toString(byte[] bytes)
{    return toString(bytes, PREFERRED_ENCODING);}
0
public static String toString(byte[] bytes, String encoding) throws CodecException
{    try {        return new String(bytes, encoding);    } catch (UnsupportedEncodingException e) {        String msg = "Unable to convert byte array to String with encoding '" + encoding + "'.";        throw new CodecException(msg, e);    }}
0
public static char[] toChars(byte[] bytes)
{    return toChars(bytes, PREFERRED_ENCODING);}
0
public static char[] toChars(byte[] bytes, String encoding) throws CodecException
{    return toString(bytes, encoding).toCharArray();}
0
protected boolean isByteSource(Object o)
{    return o instanceof byte[] || o instanceof char[] || o instanceof String || o instanceof ByteSource || o instanceof File || o instanceof InputStream;}
0
protected byte[] toBytes(Object o)
{    if (o == null) {        String msg = "Argument for byte conversion cannot be null.";        throw new IllegalArgumentException(msg);    }    if (o instanceof byte[]) {        return (byte[]) o;    } else if (o instanceof ByteSource) {        return ((ByteSource) o).getBytes();    } else if (o instanceof char[]) {        return toBytes((char[]) o);    } else if (o instanceof String) {        return toBytes((String) o);    } else if (o instanceof File) {        return toBytes((File) o);    } else if (o instanceof InputStream) {        return toBytes((InputStream) o);    } else {        return objectToBytes(o);    }}
0
protected String toString(Object o)
{    if (o == null) {        String msg = "Argument for String conversion cannot be null.";        throw new IllegalArgumentException(msg);    }    if (o instanceof byte[]) {        return toString((byte[]) o);    } else if (o instanceof char[]) {        return new String((char[]) o);    } else if (o instanceof String) {        return (String) o;    } else {        return objectToString(o);    }}
0
protected byte[] toBytes(File file)
{    if (file == null) {        throw new IllegalArgumentException("File argument cannot be null.");    }    try {        return toBytes(new FileInputStream(file));    } catch (FileNotFoundException e) {        String msg = "Unable to acquire InputStream for file [" + file + "]";        throw new CodecException(msg, e);    }}
0
protected byte[] toBytes(InputStream in)
{    if (in == null) {        throw new IllegalArgumentException("InputStream argument cannot be null.");    }    final int BUFFER_SIZE = 512;    ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE);    byte[] buffer = new byte[BUFFER_SIZE];    int bytesRead;    try {        while ((bytesRead = in.read(buffer)) != -1) {            out.write(buffer, 0, bytesRead);        }        return out.toByteArray();    } catch (IOException ioe) {        throw new CodecException(ioe);    } finally {        try {            in.close();        } catch (IOException ignored) {        }        try {            out.close();        } catch (IOException ignored) {        }    }}
0
protected byte[] objectToBytes(Object o)
{    String msg = "The " + getClass().getName() + " implementation only supports conversion to " + "byte[] if the source is of type byte[], char[], String, " + ByteSource.class.getName() + " File or InputStream.  The instance provided as a method " + "argument is of type [" + o.getClass().getName() + "].  If you would like to convert " + "this argument type to a byte[], you can 1) convert the argument to one of the supported types " + "yourself and then use that as the method argument or 2) subclass " + getClass().getName() + "and override the objectToBytes(Object o) method.";    throw new CodecException(msg);}
0
protected String objectToString(Object o)
{    return o.toString();}
0
private static short toShort(byte b)
{    return (short) (b & 0xff);}
0
private static int toInt(byte[] bytes, int offset, int numBytes)
{    if (numBytes < 1 || numBytes > 4) {        throw new IllegalArgumentException("numBytes must be between 1 and 4.");    }        int val = toShort(bytes[offset]);    for (int i = 1; i < numBytes; i++) {                short s = toShort(bytes[offset + i]);        switch(i) {            case 1:                val |= s << 8;                break;            case 2:                val |= s << 16;                break;            case 3:                val |= s << 24;                break;        }    }    return val;}
0
private static void append(Appendable buf, char c)
{    try {        buf.append(c);    } catch (IOException e) {        throw new IllegalStateException("Unable to append character to internal buffer.", e);    }}
0
private static void encodeAndAppend(int value, Appendable buf, int numChars)
{    for (int i = 0; i < numChars; i++) {        append(buf, itoa64[value & 0x3f]);        value >>= 6;    }}
0
public static String encodeToString(byte[] bytes)
{    if (bytes == null || bytes.length == 0)        return null;    StringBuilder buf = new StringBuilder();    int length = bytes.length;    int remainder = length % 3;        int i = 0;        int last3ByteIndex = length - remainder;    for (; i < last3ByteIndex; i += 3) {        int twentyFourBit = toInt(bytes, i, 3);        encodeAndAppend(twentyFourBit, buf, 4);    }    if (remainder > 0) {                int a = toInt(bytes, i, remainder);        encodeAndAppend(a, buf, remainder + 1);    }    return buf.toString();}
0
public static String encodeToString(byte[] bytes)
{    char[] encodedChars = encode(bytes);    return new String(encodedChars);}
0
public static char[] encode(byte[] data)
{    int l = data.length;    char[] out = new char[l << 1];        for (int i = 0, j = 0; i < l; i++) {        out[j++] = DIGITS[(0xF0 & data[i]) >>> 4];        out[j++] = DIGITS[0x0F & data[i]];    }    return out;}
0
public static byte[] decode(byte[] array) throws IllegalArgumentException
{    String s = CodecSupport.toString(array);    return decode(s);}
0
public static byte[] decode(String hex)
{    return decode(hex.toCharArray());}
0
public static byte[] decode(char[] data) throws IllegalArgumentException
{    int len = data.length;    if ((len & 0x01) != 0) {        throw new IllegalArgumentException("Odd number of characters.");    }    byte[] out = new byte[len >> 1];        for (int i = 0, j = 0; j < len; i++) {        int f = toDigit(data[j], j) << 4;        j++;        f = f | toDigit(data[j], j);        j++;        out[i] = (byte) (f & 0xFF);    }    return out;}
0
protected static int toDigit(char ch, int index) throws IllegalArgumentException
{    int digit = Character.digit(ch, 16);    if (digit == -1) {        throw new IllegalArgumentException("Illegal hexadecimal character " + ch + " at index " + index);    }    return digit;}
0
protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException
{    try {        return ClassUtils.forName(osc.getName());    } catch (UnknownClassException e) {        throw new ClassNotFoundException("Unable to load ObjectStreamClass [" + osc + "]: ", e);    }}
0
public byte[] serialize(T o) throws SerializationException
{    if (o == null) {        String msg = "argument cannot be null.";        throw new IllegalArgumentException(msg);    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BufferedOutputStream bos = new BufferedOutputStream(baos);    try {        ObjectOutputStream oos = new ObjectOutputStream(bos);        oos.writeObject(o);        oos.close();        return baos.toByteArray();    } catch (IOException e) {        String msg = "Unable to serialize object [" + o + "].  " + "In order for the DefaultSerializer to serialize this object, the [" + o.getClass().getName() + "] " + "class must implement java.io.Serializable.";        throw new SerializationException(msg, e);    }}
0
public T deserialize(byte[] serialized) throws SerializationException
{    if (serialized == null) {        String msg = "argument cannot be null.";        throw new IllegalArgumentException(msg);    }    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try {        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings({ "unchecked" })        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    } catch (Exception e) {        String msg = "Unable to deserialize argument byte array.";        throw new SerializationException(msg, e);    }}
0
public static boolean hasResourcePrefix(String resourcePath)
{    return resourcePath != null && (resourcePath.startsWith(CLASSPATH_PREFIX) || resourcePath.startsWith(URL_PREFIX) || resourcePath.startsWith(FILE_PREFIX));}
0
public static boolean resourceExists(String resourcePath)
{    InputStream stream = null;    boolean exists = false;    try {        stream = getInputStreamForPath(resourcePath);        exists = true;    } catch (IOException e) {        stream = null;    } finally {        if (stream != null) {            try {                stream.close();            } catch (IOException ignored) {            }        }    }    return exists;}
0
public static InputStream getInputStreamForPath(String resourcePath) throws IOException
{    InputStream is;    if (resourcePath.startsWith(CLASSPATH_PREFIX)) {        is = loadFromClassPath(stripPrefix(resourcePath));    } else if (resourcePath.startsWith(URL_PREFIX)) {        is = loadFromUrl(stripPrefix(resourcePath));    } else if (resourcePath.startsWith(FILE_PREFIX)) {        is = loadFromFile(stripPrefix(resourcePath));    } else {        is = loadFromFile(resourcePath);    }    if (is == null) {        throw new IOException("Resource [" + resourcePath + "] could not be found.");    }    return is;}
0
private static InputStream loadFromFile(String path) throws IOException
{    if (log.isDebugEnabled()) {            }    return new FileInputStream(path);}
1
private static InputStream loadFromUrl(String urlPath) throws IOException
{        URL url = new URL(urlPath);    return url.openStream();}
1
private static InputStream loadFromClassPath(String path)
{        return ClassUtils.getResourceAsStream(path);}
1
private static String stripPrefix(String resourcePath)
{    return resourcePath.substring(resourcePath.indexOf(":") + 1);}
0
public static void close(InputStream is)
{    if (is != null) {        try {            is.close();        } catch (IOException e) {                    }    }}
1
public byte[] serialize(Object source)
{    if (source == null) {        String msg = "argument cannot be null.";        throw new IllegalArgumentException(msg);    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    XMLEncoder encoder = new XMLEncoder(new BufferedOutputStream(bos));    encoder.writeObject(source);    encoder.close();    return bos.toByteArray();}
0
public Object deserialize(byte[] serialized)
{    if (serialized == null) {        throw new IllegalArgumentException("Argument cannot be null.");    }    ByteArrayInputStream bis = new ByteArrayInputStream(serialized);    XMLDecoder decoder = new XMLDecoder(new BufferedInputStream(bis));    Object o = decoder.readObject();    decoder.close();    return o;}
0
public static void isTrue(boolean expression, String message)
{    if (!expression) {        throw new IllegalArgumentException(message);    }}
0
public static void isTrue(boolean expression)
{    isTrue(expression, "[Assertion failed] - this expression must be true");}
0
public static void isNull(Object object, String message)
{    if (object != null) {        throw new IllegalArgumentException(message);    }}
0
public static void isNull(Object object)
{    isNull(object, "[Assertion failed] - the object argument must be null");}
0
public static void notNull(Object object, String message)
{    if (object == null) {        throw new IllegalArgumentException(message);    }}
0
public static void notNull(Object object)
{    notNull(object, "[Assertion failed] - this argument is required; it must not be null");}
0
public static void hasLength(String text, String message)
{    if (!StringUtils.hasLength(text)) {        throw new IllegalArgumentException(message);    }}
0
public static void hasLength(String text)
{    hasLength(text, "[Assertion failed] - this String argument must have length; it must not be null or empty");}
0
public static void hasText(String text, String message)
{    if (!StringUtils.hasText(text)) {        throw new IllegalArgumentException(message);    }}
0
public static void hasText(String text)
{    hasText(text, "[Assertion failed] - this String argument must have text; it must not be null, empty, or blank");}
0
public static void doesNotContain(String textToSearch, String substring, String message)
{    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && textToSearch.indexOf(substring) != -1) {        throw new IllegalArgumentException(message);    }}
0
public static void doesNotContain(String textToSearch, String substring)
{    doesNotContain(textToSearch, substring, "[Assertion failed] - this String argument must not contain the substring [" + substring + "]");}
0
public static void notEmpty(Object[] array, String message)
{    if (array == null || array.length == 0) {        throw new IllegalArgumentException(message);    }}
0
public static void notEmpty(Object[] array)
{    notEmpty(array, "[Assertion failed] - this array must not be empty: it must contain at least 1 element");}
0
public static void noNullElements(Object[] array, String message)
{    if (array != null) {        for (int i = 0; i < array.length; i++) {            if (array[i] == null) {                throw new IllegalArgumentException(message);            }        }    }}
0
public static void noNullElements(Object[] array)
{    noNullElements(array, "[Assertion failed] - this array must not contain any null elements");}
0
public static void notEmpty(Collection collection, String message)
{    if (isEmpty(collection)) {        throw new IllegalArgumentException(message);    }}
0
public static void notEmpty(Collection collection)
{    notEmpty(collection, "[Assertion failed] - this collection must not be empty: it must contain at least 1 element");}
0
public static void notEmpty(Map map, String message)
{    if (isEmpty(map)) {        throw new IllegalArgumentException(message);    }}
0
public static void notEmpty(Map map)
{    notEmpty(map, "[Assertion failed] - this map must not be empty; it must contain at least one entry");}
0
public static void isInstanceOf(Class clazz, Object obj)
{    isInstanceOf(clazz, obj, "");}
0
public static void isInstanceOf(Class type, Object obj, String message)
{    notNull(type, "Type to check against must not be null");    if (!type.isInstance(obj)) {        throw new IllegalArgumentException(message + "Object of class [" + (obj != null ? obj.getClass().getName() : "null") + "] must be an instance of " + type);    }}
0
public static void isAssignable(Class superType, Class subType)
{    isAssignable(superType, subType, "");}
0
public static void isAssignable(Class superType, Class subType, String message)
{    notNull(superType, "Type to check against must not be null");    if (subType == null || !superType.isAssignableFrom(subType)) {        throw new IllegalArgumentException(message + subType + " is not assignable to " + superType);    }}
0
public static void state(boolean expression, String message)
{    if (!expression) {        throw new IllegalStateException(message);    }}
0
public static void state(boolean expression)
{    state(expression, "[Assertion failed] - this state invariant must be true");}
0
private static boolean isEmpty(Map m)
{    return m == null || m.isEmpty();}
0
private static boolean isEmpty(Collection c)
{    return c == null || c.isEmpty();}
0
public static ByteSource bytes(byte[] bytes)
{    return new SimpleByteSource(bytes);}
0
public static ByteSource bytes(char[] chars)
{    return new SimpleByteSource(chars);}
0
public static ByteSource bytes(String string)
{    return new SimpleByteSource(string);}
0
public static ByteSource bytes(ByteSource source)
{    return new SimpleByteSource(source);}
0
public static ByteSource bytes(File file)
{    return new SimpleByteSource(file);}
0
public static ByteSource bytes(InputStream stream)
{    return new SimpleByteSource(stream);}
0
public static boolean isCompatible(Object source)
{    return SimpleByteSource.isCompatible(source);}
0
public static ByteSource bytes(Object source) throws IllegalArgumentException
{    if (source == null) {        return null;    }    if (!isCompatible(source)) {        String msg = "Unable to heuristically acquire bytes for object of type [" + source.getClass().getName() + "].  If this type is indeed a byte-backed data type, you might " + "want to write your own ByteSource implementation to extract its bytes explicitly.";        throw new IllegalArgumentException(msg);    }    if (source instanceof byte[]) {        return bytes((byte[]) source);    } else if (source instanceof ByteSource) {        return (ByteSource) source;    } else if (source instanceof char[]) {        return bytes((char[]) source);    } else if (source instanceof String) {        return bytes((String) source);    } else if (source instanceof File) {        return bytes((File) source);    } else if (source instanceof InputStream) {        return bytes((InputStream) source);    } else {        throw new IllegalStateException("Encountered unexpected byte source.  This is a bug - please notify " + "the Shiro developer list asap (the isCompatible implementation does not reflect this " + "method's implementation).");    }}
0
protected ClassLoader doGetClassLoader() throws Throwable
{    return Thread.currentThread().getContextClassLoader();}
0
protected ClassLoader doGetClassLoader() throws Throwable
{    return ClassUtils.class.getClassLoader();}
0
protected ClassLoader doGetClassLoader() throws Throwable
{    return ClassLoader.getSystemClassLoader();}
0
public static InputStream getResourceAsStream(String name)
{    InputStream is = THREAD_CL_ACCESSOR.getResourceStream(name);    if (is == null) {        if (log.isTraceEnabled()) {            log.trace("Resource [" + name + "] was not found via the thread context ClassLoader.  Trying the " + "current ClassLoader...");        }        is = CLASS_CL_ACCESSOR.getResourceStream(name);    }    if (is == null) {        if (log.isTraceEnabled()) {            log.trace("Resource [" + name + "] was not found via the current class loader.  Trying the " + "system/application ClassLoader...");        }        is = SYSTEM_CL_ACCESSOR.getResourceStream(name);    }    if (is == null && log.isTraceEnabled()) {        log.trace("Resource [" + name + "] was not found via the thread context, current, or " + "system/application ClassLoaders.  All heuristics have been exhausted.  Returning null.");    }    return is;}
0
public static Class forName(String fqcn) throws UnknownClassException
{    Class clazz = THREAD_CL_ACCESSOR.loadClass(fqcn);    if (clazz == null) {        if (log.isTraceEnabled()) {            log.trace("Unable to load class named [" + fqcn + "] from the thread context ClassLoader.  Trying the current ClassLoader...");        }        clazz = CLASS_CL_ACCESSOR.loadClass(fqcn);    }    if (clazz == null) {        if (log.isTraceEnabled()) {            log.trace("Unable to load class named [" + fqcn + "] from the current ClassLoader.  " + "Trying the system/application ClassLoader...");        }        clazz = SYSTEM_CL_ACCESSOR.loadClass(fqcn);    }    if (clazz == null) {        String msg = "Unable to load class named [" + fqcn + "] from the thread context, current, or " + "system/application ClassLoaders.  All heuristics have been exhausted.  Class could not be found.";        throw new UnknownClassException(msg);    }    return clazz;}
0
public static boolean isAvailable(String fullyQualifiedClassName)
{    try {        forName(fullyQualifiedClassName);        return true;    } catch (UnknownClassException e) {        return false;    }}
0
public static Object newInstance(String fqcn)
{    return newInstance(forName(fqcn));}
0
public static Object newInstance(String fqcn, Object... args)
{    return newInstance(forName(fqcn), args);}
0
public static Object newInstance(Class clazz)
{    if (clazz == null) {        String msg = "Class method parameter cannot be null.";        throw new IllegalArgumentException(msg);    }    try {        return clazz.newInstance();    } catch (Exception e) {        throw new InstantiationException("Unable to instantiate class [" + clazz.getName() + "]", e);    }}
0
public static Object newInstance(Class clazz, Object... args)
{    Class[] argTypes = new Class[args.length];    for (int i = 0; i < args.length; i++) {        argTypes[i] = args[i].getClass();    }    Constructor ctor = getConstructor(clazz, argTypes);    return instantiate(ctor, args);}
0
public static Constructor getConstructor(Class clazz, Class... argTypes)
{    try {        return clazz.getConstructor(argTypes);    } catch (NoSuchMethodException e) {        throw new IllegalStateException(e);    }}
0
public static Object instantiate(Constructor ctor, Object... args)
{    try {        return ctor.newInstance(args);    } catch (Exception e) {        String msg = "Unable to instantiate Permission instance with constructor [" + ctor + "]";        throw new InstantiationException(msg, e);    }}
0
public static List<Method> getAnnotatedMethods(final Class<?> type, final Class<? extends Annotation> annotation)
{    final List<Method> methods = new ArrayList<Method>();    Class<?> clazz = type;    while (!Object.class.equals(clazz)) {        Method[] currentClassMethods = clazz.getDeclaredMethods();        for (final Method method : currentClassMethods) {            if (annotation == null || method.isAnnotationPresent(annotation)) {                methods.add(method);            }        }                clazz = clazz.getSuperclass();    }    return methods;}
0
public Class loadClass(String fqcn)
{    Class clazz = null;    ClassLoader cl = getClassLoader();    if (cl != null) {        try {            clazz = cl.loadClass(fqcn);        } catch (ClassNotFoundException e) {            if (log.isTraceEnabled()) {                log.trace("Unable to load clazz named [" + fqcn + "] from class loader [" + cl + "]");            }        }    }    return clazz;}
0
public InputStream getResourceStream(String name)
{    InputStream is = null;    ClassLoader cl = getClassLoader();    if (cl != null) {        is = cl.getResourceAsStream(name);    }    return is;}
0
protected final ClassLoader getClassLoader()
{    try {        return doGetClassLoader();    } catch (Throwable t) {        if (log.isDebugEnabled()) {                    }    }    return null;}
1
public static void init(Object o) throws ShiroException
{    if (o instanceof Initializable) {        init((Initializable) o);    }}
0
public static void init(Initializable initializable) throws ShiroException
{    initializable.init();}
0
public static void init(Collection c) throws ShiroException
{    if (c == null || c.isEmpty()) {        return;    }    for (Object o : c) {        init(o);    }}
0
public static void destroy(Object o)
{    if (o instanceof Destroyable) {        destroy((Destroyable) o);    } else if (o instanceof Collection) {        destroy((Collection) o);    }}
0
public static void destroy(Destroyable d)
{    if (d != null) {        try {            d.destroy();        } catch (Throwable t) {            if (log.isDebugEnabled()) {                String msg = "Unable to cleanly destroy instance [" + d + "] of type [" + d.getClass().getName() + "].";                            }        }    }}
1
public static void destroy(Collection c)
{    if (c == null || c.isEmpty()) {        return;    }    for (Object o : c) {        destroy(o);    }}
0
public static boolean isCompatible(Object o)
{    return o instanceof byte[] || o instanceof char[] || o instanceof String || o instanceof ByteSource || o instanceof File || o instanceof InputStream;}
0
public byte[] getBytes()
{    return this.bytes;}
0
public boolean isEmpty()
{    return this.bytes == null || this.bytes.length == 0;}
0
public String toHex()
{    if (this.cachedHex == null) {        this.cachedHex = Hex.encodeToString(getBytes());    }    return this.cachedHex;}
0
public String toBase64()
{    if (this.cachedBase64 == null) {        this.cachedBase64 = Base64.encodeToString(getBytes());    }    return this.cachedBase64;}
0
public String toString()
{    return toBase64();}
0
public int hashCode()
{    if (this.bytes == null || this.bytes.length == 0) {        return 0;    }    return Arrays.hashCode(this.bytes);}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (o instanceof ByteSource) {        ByteSource bs = (ByteSource) o;        return Arrays.equals(getBytes(), bs.getBytes());    }    return false;}
0
public byte[] getBytes(File file)
{    return toBytes(file);}
0
public byte[] getBytes(InputStream stream)
{    return toBytes(stream);}
0
public V get(Object key)
{    processQueue();    V result = null;    SoftValue<V, K> value = map.get(key);    if (value != null) {                result = value.get();        if (result == null) {                                    map.remove(key);        } else {                        addToStrongReferences(result);        }    }    return result;}
0
private void addToStrongReferences(V result)
{    strongReferencesLock.lock();    try {        strongReferences.add(result);        trimStrongReferencesIfNecessary();    } finally {        strongReferencesLock.unlock();    }}
0
private void trimStrongReferencesIfNecessary()
{        while (strongReferences.size() > RETENTION_SIZE) {        strongReferences.poll();    }}
0
private void processQueue()
{    SoftValue sv;    while ((sv = (SoftValue) queue.poll()) != null) {                        map.remove(sv.key);    }}
0
public boolean isEmpty()
{    processQueue();    return map.isEmpty();}
0
public boolean containsKey(Object key)
{    processQueue();    return map.containsKey(key);}
0
public boolean containsValue(Object value)
{    processQueue();    Collection values = values();    return values != null && values.contains(value);}
0
public void putAll(Map<? extends K, ? extends V> m)
{    if (m == null || m.isEmpty()) {        processQueue();        return;    }    for (Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {        put(entry.getKey(), entry.getValue());    }}
0
public Set<K> keySet()
{    processQueue();    return map.keySet();}
0
public Collection<V> values()
{    processQueue();    Collection<K> keys = map.keySet();    if (keys.isEmpty()) {                return Collections.EMPTY_SET;    }    Collection<V> values = new ArrayList<V>(keys.size());    for (K key : keys) {        V v = get(key);        if (v != null) {            values.add(v);        }    }    return values;}
0
public V put(K key, V value)
{        processQueue();    SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);    SoftValue<V, K> previous = map.put(key, sv);    addToStrongReferences(value);    return previous != null ? previous.get() : null;}
0
public V remove(Object key)
{        processQueue();    SoftValue<V, K> raw = map.remove(key);    return raw != null ? raw.get() : null;}
0
public void clear()
{    strongReferencesLock.lock();    try {        strongReferences.clear();    } finally {        strongReferencesLock.unlock();    }        processQueue();    map.clear();}
0
public int size()
{        processQueue();    return map.size();}
0
public Set<Map.Entry<K, V>> entrySet()
{        processQueue();    Collection<K> keys = map.keySet();    if (keys.isEmpty()) {                return Collections.EMPTY_SET;    }    Map<K, V> kvPairs = new HashMap<K, V>(keys.size());    for (K key : keys) {        V v = get(key);        if (v != null) {            kvPairs.put(key, v);        }    }    return kvPairs.entrySet();}
0
public static boolean hasText(String str)
{    if (!hasLength(str)) {        return false;    }    int strLen = str.length();    for (int i = 0; i < strLen; i++) {        if (!Character.isWhitespace(str.charAt(i))) {            return true;        }    }    return false;}
0
public static boolean hasLength(String str)
{    return (str != null && str.length() > 0);}
0
public static boolean startsWithIgnoreCase(String str, String prefix)
{    if (str == null || prefix == null) {        return false;    }    if (str.startsWith(prefix)) {        return true;    }    if (str.length() < prefix.length()) {        return false;    }    String lcStr = str.substring(0, prefix.length()).toLowerCase();    String lcPrefix = prefix.toLowerCase();    return lcStr.equals(lcPrefix);}
0
public static String clean(String in)
{    String out = in;    if (in != null) {        out = in.trim();        if (out.equals(EMPTY_STRING)) {            out = null;        }    }    return out;}
0
public static String toString(Object[] array)
{    return toDelimitedString(array, ",");}
0
public static String toDelimitedString(Object[] array, String delimiter)
{    if (array == null || array.length == 0) {        return EMPTY_STRING;    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i < array.length; i++) {        if (i > 0) {            sb.append(delimiter);        }        sb.append(array[i]);    }    return sb.toString();}
0
public static String toDelimitedString(Collection c, String delimiter)
{    if (c == null || c.isEmpty()) {        return EMPTY_STRING;    }    return join(c.iterator(), delimiter);}
0
public static String[] tokenizeToStringArray(String str, String delimiters)
{    return tokenizeToStringArray(str, delimiters, true, true);}
0
public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)
{    if (str == null) {        return null;    }    StringTokenizer st = new StringTokenizer(str, delimiters);    List tokens = new ArrayList();    while (st.hasMoreTokens()) {        String token = st.nextToken();        if (trimTokens) {            token = token.trim();        }        if (!ignoreEmptyTokens || token.length() > 0) {            tokens.add(token);        }    }    return toStringArray(tokens);}
0
public static String[] toStringArray(Collection collection)
{    if (collection == null) {        return null;    }    return (String[]) collection.toArray(new String[collection.size()]);}
0
public static String[] splitKeyValue(String aLine) throws ParseException
{    String line = clean(aLine);    if (line == null) {        return null;    }    String[] split = line.split(" ", 2);    if (split.length != 2) {                split = line.split("=", 2);        if (split.length != 2) {            String msg = "Unable to determine Key/Value pair from line [" + line + "].  There is no space from " + "which the split location could be determined.";            throw new ParseException(msg, 0);        }    }    split[0] = clean(split[0]);    split[1] = clean(split[1]);    if (split[1].startsWith("=")) {                        split[1] = clean(split[1].substring(1));    }    if (split[0] == null) {        String msg = "No valid key could be found in line [" + line + "] to form a key/value pair.";        throw new ParseException(msg, 0);    }    if (split[1] == null) {        String msg = "No corresponding value could be found in line [" + line + "] for key [" + split[0] + "]";        throw new ParseException(msg, 0);    }    return split;}
0
public static String[] split(String line)
{    return split(line, DEFAULT_DELIMITER_CHAR);}
0
public static String[] split(String line, char delimiter)
{    return split(line, delimiter, DEFAULT_QUOTE_CHAR);}
0
public static String[] split(String line, char delimiter, char quoteChar)
{    return split(line, delimiter, quoteChar, quoteChar);}
0
public static String[] split(String line, char delimiter, char beginQuoteChar, char endQuoteChar)
{    return split(line, delimiter, beginQuoteChar, endQuoteChar, false, true);}
0
public static String[] split(String aLine, char delimiter, char beginQuoteChar, char endQuoteChar, boolean retainQuotes, boolean trimTokens)
{    String line = clean(aLine);    if (line == null) {        return null;    }    List<String> tokens = new ArrayList<String>();    StringBuilder sb = new StringBuilder();    boolean inQuotes = false;    for (int i = 0; i < line.length(); i++) {        char c = line.charAt(i);        if (c == beginQuoteChar) {                        if (            inQuotes &&             line.length() > (i + 1) && line.charAt(i + 1) == beginQuoteChar) {                                                                sb.append(line.charAt(i + 1));                i++;            } else {                inQuotes = !inQuotes;                if (retainQuotes) {                    sb.append(c);                }            }        } else if (c == endQuoteChar) {            inQuotes = !inQuotes;            if (retainQuotes) {                sb.append(c);            }        } else if (c == delimiter && !inQuotes) {            String s = sb.toString();            if (trimTokens) {                s = s.trim();            }            tokens.add(s);                        sb = new StringBuilder();        } else {            sb.append(c);        }    }    String s = sb.toString();    if (trimTokens) {        s = s.trim();    }    tokens.add(s);    return tokens.toArray(new String[tokens.size()]);}
0
public static String join(Iterator<?> iterator, String separator)
{    final String empty = "";        if (iterator == null) {        return null;    }    if (!iterator.hasNext()) {        return empty;    }    Object first = iterator.next();    if (!iterator.hasNext()) {        return first == null ? empty : first.toString();    }            StringBuilder buf = new StringBuilder(256);    if (first != null) {        buf.append(first);    }    while (iterator.hasNext()) {        if (separator != null) {            buf.append(separator);        }        Object obj = iterator.next();        if (obj != null) {            buf.append(obj);        }    }    return buf.toString();}
0
public static Set<String> splitToSet(String delimited, String separator)
{    if (delimited == null || separator == null) {        return null;    }    String[] split = split(delimited, separator.charAt(0));    return asSet(split);}
0
public static String uppercaseFirstChar(String in)
{    if (in == null || in.length() == 0) {        return in;    }    int length = in.length();    StringBuilder sb = new StringBuilder(length);    sb.append(Character.toUpperCase(in.charAt(0)));    if (length > 1) {        String remaining = in.substring(1);        sb.append(remaining);    }    return sb.toString();}
0
private static Set<E> asSet(E... elements)
{    if (elements == null || elements.length == 0) {        return Collections.emptySet();    }    if (elements.length == 1) {        return Collections.singleton(elements[0]);    }    LinkedHashSet<E> set = new LinkedHashSet<E>(elements.length * 4 / 3 + 1);    Collections.addAll(set, elements);    return set;}
0
public long getId()
{    return _id;}
0
public String getOwnerName()
{    return _ownerName;}
0
public boolean isActive()
{    return _isActive;}
0
public void setActive(boolean aIsActive)
{    _isActive = aIsActive;}
0
public void setOwnerName(String aOwnerName)
{    _ownerName = aOwnerName;}
0
public double getBalance()
{    return _balance;}
0
public List<AccountTransaction> getTransactions()
{    return _transactions;}
0
protected void applyTransaction(AccountTransaction aTransaction) throws NotEnoughFundsException, InactiveAccountException
{    if (!_isActive) {        throw new InactiveAccountException("Unable to apply " + aTransaction.getType() + " of amount " + aTransaction.getAmount() + " to account " + _id);    }    synchronized (_transactions) {        if (AccountTransaction.TransactionType.DEPOSIT == aTransaction.getType()) {            _transactions.add(aTransaction);            _balance += aTransaction.getAmount();        } else if (AccountTransaction.TransactionType.WITHDRAWAL == aTransaction.getType()) {            if (_balance < aTransaction.getAmount()) {                throw new NotEnoughFundsException("Unable to withdraw " + aTransaction.getAmount() + "$ from account " + _id + " - current balance is " + _balance);            }            _transactions.add(aTransaction);            _balance -= aTransaction.getAmount();        } else {            throw new IllegalArgumentException("The transaction passed in has an invalid type: " + aTransaction.getType());        }    }}
0
protected void setCreatedBy(String aCreatedBy)
{    _createdBy = aCreatedBy;}
0
public String getCreatedBy()
{    return _createdBy;}
0
public Date getCreationDate()
{    return _creationDate;}
0
public String toString()
{    return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).append("id", _id).append("ownerName", _ownerName).append("isActive", _isActive).append("balance", _balance).append("tx.count", _transactions.size()).append("createdBy", _createdBy).append("creationDate", new Timestamp(_creationDate.getTime())).toString();}
0
public static AccountTransaction createDepositTx(long anAccountId, double anAmount)
{    return new AccountTransaction(TransactionType.DEPOSIT, anAccountId, anAmount);}
0
public static AccountTransaction createWithdrawalTx(long anAccountId, double anAmount)
{    return new AccountTransaction(TransactionType.WITHDRAWAL, anAccountId, anAmount);}
0
public long getId()
{    return _id;}
0
public TransactionType getType()
{    return _type;}
0
public long getAccountId()
{    return _accountId;}
0
public double getAmount()
{    return _amount;}
0
protected void setCreatedBy(String aCreatedBy)
{    _createdBy = aCreatedBy;}
0
public String getCreatedBy()
{    return _createdBy;}
0
public Date getCreationDate()
{    return _creationDate;}
0
public String toString()
{    return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).append("id", _id).append("type", _type).append("accountId", _accountId).append("amount", _amount).append("createdBy", _createdBy).append("creationDate", new Timestamp(_creationDate.getTime())).toString();}
0
public synchronized void start() throws Exception
{    if (_bankService == null) {        _bankService = new SecureBankService();        _bankService.start();    }}
0
public synchronized void stop()
{    if (_bankService != null) {        try {            _bankService.dispose();        } finally {            _bankService = null;        }    }}
0
public BankService getBankService()
{    return _bankService;}
0
public static void main(String[] args)
{    try {        BankServerRunner server = new BankServerRunner();        server.start();        server.stop();    } catch (Exception e) {        e.printStackTrace();    }}
0
public Date getCreationDate()
{    return _creationDate;}
0
public double getAmount()
{    return _amount;}
0
public String getMadeBy()
{    return _madeBy;}
0
public void start() throws Exception
{    _isRunning = true;    }
1
public void dispose()
{        _isRunning = false;    synchronized (_accounts) {        _accountsById.clear();        _accounts.clear();    }    }
1
protected void assertServiceState()
{    if (!_isRunning) {        throw new IllegalStateException("This bank service is not running");    }}
0
public int getAccountCount()
{    return _accounts.size();}
0
public long createNewAccount(String anOwnerName)
{    assertServiceState();        synchronized (_accounts) {        Account account = new Account(anOwnerName);        account.setCreatedBy(getCurrentUsername());        _accounts.add(account);        _accountsById.put(account.getId(), account);                return account.getId();    }}
1
public long[] searchAccountIdsByOwner(String anOwnerName)
{    assertServiceState();        ArrayList<Account> matchAccounts = new ArrayList<Account>();    synchronized (_accounts) {        for (Account a : _accounts) {            if (a.getOwnerName().toLowerCase().contains(anOwnerName.toLowerCase())) {                matchAccounts.add(a);            }        }    }    long[] accountIds = new long[matchAccounts.size()];    int index = 0;    for (Account a : matchAccounts) {        accountIds[index++] = a.getId();    }        return accountIds;}
1
public String getOwnerOf(long anAccountId) throws AccountNotFoundException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    return a.getOwnerName();}
1
public double getBalanceOf(long anAccountId) throws AccountNotFoundException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    return a.getBalance();}
1
public double depositInto(long anAccountId, double anAmount) throws AccountNotFoundException, InactiveAccountException
{    assertServiceState();        try {        Account a = safellyRetrieveAccountForId(anAccountId);        AccountTransaction tx = AccountTransaction.createDepositTx(anAccountId, anAmount);        tx.setCreatedBy(getCurrentUsername());                a.applyTransaction(tx);                return a.getBalance();    } catch (NotEnoughFundsException nefe) {        throw new IllegalStateException("Should never happen", nefe);    }}
1
public double withdrawFrom(long anAccountId, double anAmount) throws AccountNotFoundException, NotEnoughFundsException, InactiveAccountException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    AccountTransaction tx = AccountTransaction.createWithdrawalTx(anAccountId, anAmount);    tx.setCreatedBy(getCurrentUsername());        a.applyTransaction(tx);        return a.getBalance();}
1
public TxLog[] getTxHistoryFor(long anAccountId) throws AccountNotFoundException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    TxLog[] txs = new TxLog[a.getTransactions().size()];    int index = 0;    for (AccountTransaction tx : a.getTransactions()) {                if (TransactionType.DEPOSIT == tx.getType()) {            txs[index++] = new TxLog(tx.getCreationDate(), tx.getAmount(), tx.getCreatedBy());        } else {            txs[index++] = new TxLog(tx.getCreationDate(), -1.0d * tx.getAmount(), tx.getCreatedBy());        }    }    return txs;}
1
public double closeAccount(long anAccountId) throws AccountNotFoundException, InactiveAccountException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    if (!a.isActive()) {        throw new InactiveAccountException("The account " + anAccountId + " is already closed");    }    try {        AccountTransaction tx = AccountTransaction.createWithdrawalTx(a.getId(), a.getBalance());        tx.setCreatedBy(getCurrentUsername());                a.applyTransaction(tx);        a.setActive(false);                return tx.getAmount();    } catch (NotEnoughFundsException nefe) {        throw new IllegalStateException("Should never happen", nefe);    }}
1
public boolean isAccountActive(long anAccountId) throws AccountNotFoundException
{    assertServiceState();        Account a = safellyRetrieveAccountForId(anAccountId);    return a.isActive();}
1
protected Account safellyRetrieveAccountForId(long anAccountId) throws AccountNotFoundException
{    Account account = null;    synchronized (_accounts) {        account = _accountsById.get(anAccountId);    }    if (account == null) {        throw new AccountNotFoundException("No account found for the id " + anAccountId);    }        return account;}
1
protected String getCurrentUsername()
{    Subject subject = SecurityUtils.getSubject();    if (subject == null || subject.getPrincipal() == null || !subject.isAuthenticated()) {        throw new IllegalStateException("Unable to retrieve the current authenticated subject");    }    return SecurityUtils.getSubject().getPrincipal().toString();}
0
public static void setUpClass() throws Exception
{    Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiroBankServiceTest.ini");    SecurityManager securityManager = factory.getInstance();    SecurityUtils.setSecurityManager(securityManager);    service = new SecureBankService();    service.start();}
0
public static void tearDownClass()
{    if (service != null) {        service.dispose();    }}
0
public void setUp() throws Exception
{        Thread.sleep(50);}
1
public void tearDown()
{    if (_subject != null) {        _subject.logout();    }}
0
protected void logoutCurrentSubject()
{    if (_subject != null) {        _subject.logout();    }}
0
protected void loginAsUser()
{    if (_subject == null) {        _subject = SecurityUtils.getSubject();    }        _subject.login(new UsernamePasswordToken("dan", "123"));}
0
protected void loginAsSuperviser()
{    if (_subject == null) {        _subject = SecurityUtils.getSubject();    }        _subject.login(new UsernamePasswordToken("sally", "1234"));}
0
public void testCreateAccount() throws Exception
{    loginAsUser();    createAndValidateAccountFor("Bob Smith");}
0
public void testDepositInto_singleTx() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Joe Smith");    makeDepositAndValidateAccount(accountId, 250, "Joe Smith");}
0
public void testDepositInto_multiTxs() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Everett Smith");    makeDepositAndValidateAccount(accountId, 50, "Everett Smith");    makeDepositAndValidateAccount(accountId, 300, "Everett Smith");    makeDepositAndValidateAccount(accountId, 85, "Everett Smith");    assertAccount("Everett Smith", true, 435, 3, accountId);}
0
public void testWithdrawFrom_emptyAccount() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Wally Smith");    service.withdrawFrom(accountId, 100);}
0
public void testWithdrawFrom_notEnoughFunds() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Frank Smith");    makeDepositAndValidateAccount(accountId, 50, "Frank Smith");    service.withdrawFrom(accountId, 100);}
0
public void testWithdrawFrom_singleTx() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Al Smith");    makeDepositAndValidateAccount(accountId, 500, "Al Smith");    makeWithdrawalAndValidateAccount(accountId, 100, "Al Smith");    assertAccount("Al Smith", true, 400, 2, accountId);}
0
public void testWithdrawFrom_manyTxs() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Zoe Smith");    makeDepositAndValidateAccount(accountId, 500, "Zoe Smith");    makeWithdrawalAndValidateAccount(accountId, 100, "Zoe Smith");    makeWithdrawalAndValidateAccount(accountId, 75, "Zoe Smith");    makeWithdrawalAndValidateAccount(accountId, 125, "Zoe Smith");    assertAccount("Zoe Smith", true, 200, 4, accountId);}
0
public void testWithdrawFrom_upToZero() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Zoe Smith");    makeDepositAndValidateAccount(accountId, 500, "Zoe Smith");    makeWithdrawalAndValidateAccount(accountId, 500, "Zoe Smith");    assertAccount("Zoe Smith", true, 0, 2, accountId);}
0
public void testCloseAccount_zeroBalance() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Chris Smith");    logoutCurrentSubject();    loginAsSuperviser();    double closingBalance = service.closeAccount(accountId);    Assert.assertEquals(0, (int) closingBalance);    assertAccount("Chris Smith", false, 0, 1, accountId);}
0
public void testCloseAccount_withBalance() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Gerry Smith");    makeDepositAndValidateAccount(accountId, 385, "Gerry Smith");    logoutCurrentSubject();    loginAsSuperviser();    double closingBalance = service.closeAccount(accountId);    Assert.assertEquals(385, (int) closingBalance);    assertAccount("Gerry Smith", false, 0, 2, accountId);}
0
public void testCloseAccount_alreadyClosed() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Chris Smith");    logoutCurrentSubject();    loginAsSuperviser();    double closingBalance = service.closeAccount(accountId);    Assert.assertEquals(0, (int) closingBalance);    assertAccount("Chris Smith", false, 0, 1, accountId);    service.closeAccount(accountId);}
0
public void testCloseAccount_unauthorizedAttempt() throws Exception
{    loginAsUser();    long accountId = createAndValidateAccountFor("Chris Smith");    service.closeAccount(accountId);}
0
protected long createAndValidateAccountFor(String anOwner) throws Exception
{    long createdId = service.createNewAccount(anOwner);    assertAccount(anOwner, true, 0, 0, createdId);    return createdId;}
0
protected double makeDepositAndValidateAccount(long anAccountId, int anAmount, String eOwnerName) throws Exception
{    double previousBalance = service.getBalanceOf(anAccountId);    int previousTxCount = service.getTxHistoryFor(anAccountId).length;    double newBalance = service.depositInto(anAccountId, anAmount);    Assert.assertEquals((int) previousBalance + anAmount, (int) newBalance);    assertAccount(eOwnerName, true, (int) newBalance, 1 + previousTxCount, anAccountId);    return newBalance;}
0
protected double makeWithdrawalAndValidateAccount(long anAccountId, int anAmount, String eOwnerName) throws Exception
{    double previousBalance = service.getBalanceOf(anAccountId);    int previousTxCount = service.getTxHistoryFor(anAccountId).length;    double newBalance = service.withdrawFrom(anAccountId, anAmount);    Assert.assertEquals((int) previousBalance - anAmount, (int) newBalance);    assertAccount(eOwnerName, true, (int) newBalance, 1 + previousTxCount, anAccountId);    return newBalance;}
0
public static void assertAccount(String eOwnerName, boolean eIsActive, int eBalance, int eTxLogCount, long actualAccountId) throws Exception
{    Assert.assertEquals(eOwnerName, service.getOwnerOf(actualAccountId));    Assert.assertEquals(eIsActive, service.isAccountActive(actualAccountId));    Assert.assertEquals(eBalance, (int) service.getBalanceOf(actualAccountId));    Assert.assertEquals(eTxLogCount, service.getTxHistoryFor(actualAccountId).length);}
0
public void contextInitialized(final ServletContextEvent servletContextEvent)
{    this.servletContext = servletContextEvent.getServletContext();    super.contextInitialized(servletContextEvent);}
0
protected Injector getInjector()
{        return Guice.createInjector(new SampleShiroNativeSessionsServletModule(servletContext), ShiroWebModule.guiceFilterModule());}
0
protected void configureShiroWeb()
{    bindConstant().annotatedWith(Names.named("shiro.loginUrl")).to("/login.jsp");    try {        this.bindRealm().toConstructor(IniRealm.class.getConstructor(Ini.class));    } catch (NoSuchMethodException e) {        addError("Could not locate proper constructor for IniRealm.", e);    }    this.addFilterChain("/login.jsp", AUTHC);    this.addFilterChain("/logout", LOGOUT);    this.addFilterChain("/account/**", AUTHC);    this.addFilterChain("/remoting/**", filterConfig(AUTHC), filterConfig(ROLES, "b2bClient"), filterConfig(PERMS, "remote:invoke:lan,wan"));}
0
 Ini loadShiroIni() throws MalformedURLException
{    URL iniUrl = servletContext.getResource("/WEB-INF/shiro.ini");    return Ini.fromResourcePath("url:" + iniUrl.toExternalForm());}
0
protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind)
{    bind.to(DefaultWebSessionManager.class);    bindConstant().annotatedWith(Names.named("shiro.globalSessionTimeout")).to(5000L);    bindConstant().annotatedWith(Names.named("shiro.sessionIdUrlRewritingEnabled")).to(false);    bind(DefaultWebSessionManager.class);    bind(Cookie.class).toInstance(new SimpleCookie("myCookie"));}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    try {        String cipherKey = loadShiroIni().getSectionProperty("main", "securityManager.rememberMeManager.cipherKey");        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        CookieRememberMeManager rememberMeManager = new CookieRememberMeManager();        rememberMeManager.setCipherKey(Base64.decode(cipherKey));        securityManager.setRememberMeManager(rememberMeManager);        bind.toInstance(securityManager);    } catch (MalformedURLException e) {                throw new ConfigurationException("securityManager.rememberMeManager.cipherKey must be set in shiro.ini.");    }}
0
protected void configureShiroWeb()
{    bindConstant().annotatedWith(Names.named("shiro.loginUrl")).to("/login.jsp");    try {        this.bindRealm().toConstructor(IniRealm.class.getConstructor(Ini.class));    } catch (NoSuchMethodException e) {        addError("Could not locate proper constructor for IniRealm.", e);    }    this.addFilterChain("/login.jsp", AUTHC);    this.addFilterChain("/logout", LOGOUT);    this.addFilterChain("/account/**", AUTHC);    this.addFilterChain("/remoting/**", filterConfig(AUTHC), filterConfig(ROLES, "b2bClient"), filterConfig(PERMS, "remote:invoke:lan,wan"));}
0
 Ini loadShiroIni() throws MalformedURLException
{    URL iniUrl = servletContext.getResource("/WEB-INF/shiro.ini");    return Ini.fromResourcePath("url:" + iniUrl.toExternalForm());}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    try {        String cipherKey = loadShiroIni().getSectionProperty("main", "securityManager.rememberMeManager.cipherKey");        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        CookieRememberMeManager rememberMeManager = new CookieRememberMeManager();        rememberMeManager.setCipherKey(Base64.decode(cipherKey));        securityManager.setRememberMeManager(rememberMeManager);        bind.toInstance(securityManager);    } catch (MalformedURLException e) {                throw new ConfigurationException("securityManager.rememberMeManager.cipherKey must be set in shiro.ini.");    }}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    page = form.<HtmlInput>getInputByName("submit").click();        page.getAnchorByHref("/logout");}
0
public void logInAndRememberMe() throws Exception
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    HtmlCheckBoxInput checkbox = form.getInputByName("rememberMe");    checkbox.setChecked(true);    page = form.<HtmlInput>getInputByName("submit").click();    jetty.stop();    jetty.start();    page = webClient.getPage(getBaseUri());        WebAssert.assertLinkPresentWithText(page, "Log out");    page = page.getAnchorByHref("/account").click();        WebAssert.assertFormPresent(page, "loginform");}
0
public String saySomething(@QueryParam("words") @DefaultValue("Hello!") String words)
{    return words;}
0
public String protectedByRequiresPermissions()
{    return "protected";}
0
public String protectedByRequiresRoles()
{    return "protected";}
0
public String protectedByRequiresUser()
{    return "protected";}
0
public String protectedByRequiresGuest()
{    return "not protected";}
0
public String protectedByRequiresAuthentication()
{    return "protected";}
0
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = new HashSet<Class<?>>();        classes.add(ShiroFeature.class);        classes.add(HelloResource.class);    classes.add(SecureResource.class);    return classes;}
0
public static void main(String[] args)
{                            Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");    SecurityManager securityManager = factory.getInstance();                            SecurityUtils.setSecurityManager(securityManager);            Subject currentUser = SecurityUtils.getSubject();        Session session = currentUser.getSession();    session.setAttribute("someKey", "aValue");    String value = (String) session.getAttribute("someKey");    if (value.equals("aValue")) {            }        if (!currentUser.isAuthenticated()) {        UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");        token.setRememberMe(true);        try {            currentUser.login(token);        } catch (UnknownAccountException uae) {                    } catch (IncorrectCredentialsException ice) {                    } catch (LockedAccountException lae) {                    }         catch (AuthenticationException ae) {                }    }                    if (currentUser.hasRole("schwartz")) {            } else {            }        if (currentUser.isPermitted("lightsaber:wield")) {            } else {            }        if (currentUser.isPermitted("winnebago:drive:eagle5")) {            } else {            }        currentUser.logout();    System.exit(0);}
1
public static void main(String[] args)
{        Injector injector = Guice.createInjector(new QuickstartShiroModule());    SecurityManager securityManager = injector.getInstance(SecurityManager.class);                            SecurityUtils.setSecurityManager(securityManager);            Subject currentUser = SecurityUtils.getSubject();        Session session = currentUser.getSession();    session.setAttribute("someKey", "aValue");    String value = (String) session.getAttribute("someKey");    if (value.equals("aValue")) {            }        if (!currentUser.isAuthenticated()) {        UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");        token.setRememberMe(true);        try {            currentUser.login(token);        } catch (UnknownAccountException uae) {                    } catch (IncorrectCredentialsException ice) {                    } catch (LockedAccountException lae) {                    }         catch (AuthenticationException ae) {                }    }                    if (currentUser.hasRole("schwartz")) {            } else {            }        if (currentUser.isPermitted("lightsaber:weild")) {            } else {            }        if (currentUser.isPermitted("winnebago:drive:eagle5")) {            } else {            }        currentUser.logout();    System.exit(0);}
1
protected void configureShiro()
{    try {        bindRealm().toConstructor(IniRealm.class.getConstructor(Ini.class));    } catch (NoSuchMethodException e) {        addError(e);    }}
0
 Ini loadShiroIni()
{    return Ini.fromResourcePath("classpath:shiro.ini");}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    page = form.<HtmlInput>getInputByName("submit").click();        page.getAnchorByHref("/logout");}
0
public Realm realm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
public static void main(String[] args)
{    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(CliApp.class);    context.getBean(QuickStart.class).run();}
0
public void run()
{        Subject subject = SecurityUtils.getSubject();        Assert.isTrue(!subject.isAuthenticated());        UsernamePasswordToken token = new UsernamePasswordToken("joe.coder", "password");    subject.login(token);        subject.checkRole("user");        Assert.isTrue(!subject.hasRole("admin"));        subject.checkPermission("read");        simpleService.readRestrictedCall();    try {                simpleService.writeRestrictedCall();    } catch (AuthorizationException e) {            }        subject.logout();    Assert.isTrue(!subject.isAuthenticated());}
1
private void initStaticSecurityManager()
{    SecurityUtils.setSecurityManager(securityManager);}
0
public void writeRestrictedCall()
{    }
1
public void readRestrictedCall()
{    }
1
public static void main(String[] args)
{    ConfigurableApplicationContext context = SpringApplication.run(CliApp.class, args);        context.getBean(QuickStart.class).run();}
0
public Realm realm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
public void run()
{        Subject subject = SecurityUtils.getSubject();        Assert.isTrue(!subject.isAuthenticated());        UsernamePasswordToken token = new UsernamePasswordToken("joe.coder", "password");    subject.login(token);        subject.checkRole("user");        Assert.isTrue(!subject.hasRole("admin"));        subject.checkPermission("read");        simpleService.readRestrictedCall();    try {                simpleService.writeRestrictedCall();    } catch (AuthorizationException e) {            }        subject.logout();    Assert.isTrue(!subject.isAuthenticated());}
1
private void initStaticSecurityManager()
{    SecurityUtils.setSecurityManager(securityManager);}
0
public void writeRestrictedCall()
{    }
1
public void readRestrictedCall()
{    }
1
public String home(Model model)
{    String name = "World";    Subject subject = SecurityUtils.getSubject();    PrincipalCollection principalCollection = subject.getPrincipals();    if (principalCollection != null && !principalCollection.isEmpty()) {        name = principalCollection.getPrimaryPrincipal().toString();    }    model.addAttribute("name", name);    return "account-info";}
0
public String home(HttpServletRequest request, Model model)
{    String name = "World";    Subject subject = SecurityUtils.getSubject();    PrincipalCollection principalCollection = subject.getPrincipals();    if (principalCollection != null && !principalCollection.isEmpty()) {        Collection<Map> principalMaps = subject.getPrincipals().byType(Map.class);        if (CollectionUtils.isEmpty(principalMaps)) {            name = subject.getPrincipal().toString();        } else {            name = (String) principalMaps.iterator().next().get("username");        }    }    model.addAttribute("name", name);    return "hello";}
0
public String loginTemplate()
{    return "login";}
0
public String getErrorPath()
{    return ERROR_PATH;}
0
 String error(HttpServletRequest request, Model model)
{    Map<String, Object> errorMap = errorAttributes.getErrorAttributes(new ServletWebRequest(request), false);    model.addAttribute("errors", errorMap);    return "error";}
0
public static void main(String[] args)
{    SpringApplication.run(WebApp.class, args);}
0
public String handleException(AuthorizationException e, Model model)
{                Map<String, Object> map = new HashMap<String, Object>();    map.put("status", HttpStatus.FORBIDDEN.value());    map.put("message", "No message available");    model.addAttribute("errors", map);    return "error";}
1
public Realm realm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
public ShiroFilterChainDefinition shiroFilterChainDefinition()
{    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();        chainDefinition.addPathDefinition("/login.html", "authc");    chainDefinition.addPathDefinition("/logout", "logout");    return chainDefinition;}
0
public Subject subject()
{    return SecurityUtils.getSubject();}
0
public static void main(String[] args)
{        if (args.length > 0)        LAUNCH_SESSION_ID = args[0];    new ClassPathXmlApplicationContext("webstart.spring.xml");}
0
public void setSampleManager(SampleManager sampleManager)
{    this.sampleManager = sampleManager;}
0
public void afterPropertiesSet() throws Exception
{    ClassPathResource resource = new ClassPathResource("logo.png");    ImageIcon icon = new ImageIcon(resource.getURL());    JLabel logo = new JLabel(icon);    valueField = new JTextField(20);    updateValueLabel();    saveButton = new JButton("Save Value");    saveButton.addActionListener(this);    refreshButton = new JButton("Refresh Value");    refreshButton.addActionListener(this);    JPanel valuePanel = new JPanel(new FlowLayout(FlowLayout.CENTER));    valuePanel.add(valueField);    valuePanel.add(saveButton);    valuePanel.add(refreshButton);    secureMethod1Button = new JButton("Method #1");    secureMethod1Button.addActionListener(this);    secureMethod2Button = new JButton("Method #2");    secureMethod2Button.addActionListener(this);    secureMethod3Button = new JButton("Method #3");    secureMethod3Button.addActionListener(this);    JPanel methodPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));    methodPanel.add(secureMethod1Button);    methodPanel.add(secureMethod2Button);    methodPanel.add(secureMethod3Button);    frame = new JFrame("Apache Shiro Sample Application");    frame.setSize(500, 200);    Container panel = frame.getContentPane();    panel.setLayout(new BorderLayout());    panel.add(logo, BorderLayout.NORTH);    panel.add(valuePanel, BorderLayout.CENTER);    panel.add(methodPanel, BorderLayout.SOUTH);    frame.setVisible(true);    frame.addWindowListener(new WindowAdapter() {        public void windowClosing(WindowEvent e) {            System.exit(0);        }    });}
0
public void windowClosing(WindowEvent e)
{    System.exit(0);}
0
private void updateValueLabel()
{    valueField.setText(sampleManager.getValue());}
0
public void actionPerformed(ActionEvent e)
{    try {        if (e.getSource() == saveButton) {            sampleManager.setValue(valueField.getText());        } else if (e.getSource() == refreshButton) {            updateValueLabel();        } else if (e.getSource() == secureMethod1Button) {            sampleManager.secureMethod1();            JOptionPane.showMessageDialog(frame, "Method #1 successfully called.", "Success", JOptionPane.INFORMATION_MESSAGE);        } else if (e.getSource() == secureMethod2Button) {            sampleManager.secureMethod2();            JOptionPane.showMessageDialog(frame, "Method #2 successfully called.", "Success", JOptionPane.INFORMATION_MESSAGE);        } else if (e.getSource() == secureMethod3Button) {            sampleManager.secureMethod3();            JOptionPane.showMessageDialog(frame, "Method #3 successfully called.", "Success", JOptionPane.INFORMATION_MESSAGE);        } else {            throw new RuntimeException("Unexpected action event from source: " + e.getSource());        }    } catch (AuthorizationException ae) {        JOptionPane.showMessageDialog(frame, "Unauthorized to perform action: " + ae.getMessage(), "Unauthorized", JOptionPane.WARNING_MESSAGE);    }}
0
public void setDataSource(DataSource dataSource)
{    this.dataSource = dataSource;}
0
public void setSessionFactory(SessionFactory sessionFactory)
{    this.sessionFactory = sessionFactory;}
0
public void afterPropertiesSet() throws Exception
{            JdbcTemplate jdbcTemplate = new JdbcTemplate(this.dataSource);    jdbcTemplate.execute("insert into roles values (1, 'user', 'The default role given to all users.')");    jdbcTemplate.execute("insert into roles values (2, 'admin', 'The administrator role only given to site admins')");    jdbcTemplate.execute("insert into roles_permissions values (2, 'user:*')");    jdbcTemplate.execute("insert into users(id,username,email,password) values (1, 'admin', 'sample@shiro.apache.org', '" + new Sha256Hash("admin").toHex() + "')");    jdbcTemplate.execute("insert into users_roles values (1, 2)");}
0
public void setSessionFactory(SessionFactory sessionFactory)
{    this.sessionFactory = sessionFactory;}
0
public Session getSession()
{    return sessionFactory.getCurrentSession();}
0
public User getUser(Long userId)
{    return (User) getSession().get(User.class, userId);}
0
public User findUser(String username)
{    Assert.hasText(username);    String query = "from User u where u.username = :username";    return (User) getSession().createQuery(query).setString("username", username).uniqueResult();}
0
public void createUser(User user)
{    getSession().save(user);}
0
public List<User> getAllUsers()
{    return getSession().createQuery("from User order by username").list();}
0
public void deleteUser(Long userId)
{    User user = getUser(userId);    if (user != null) {        getSession().delete(user);    }}
0
public void updateUser(User user)
{    getSession().update(user);}
0
public Long getId()
{    return id;}
0
public void setId(Long id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public String getDescription()
{    return description;}
0
public void setDescription(String description)
{    this.description = description;}
0
public Set<String> getPermissions()
{    return permissions;}
0
public void setPermissions(Set<String> permissions)
{    this.permissions = permissions;}
0
public Long getId()
{    return id;}
0
public void setId(Long id)
{    this.id = id;}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public String getEmail()
{    return email;}
0
public void setEmail(String email)
{    this.email = email;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public Set<Role> getRoles()
{    return roles;}
0
public void setRoles(Set<Role> roles)
{    this.roles = roles;}
0
public void setUserDAO(UserDAO userDAO)
{    this.userDAO = userDAO;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException
{    UsernamePasswordToken token = (UsernamePasswordToken) authcToken;    User user = userDAO.findUser(token.getUsername());    if (user != null) {        return new SimpleAuthenticationInfo(user.getId(), user.getPassword(), getName());    } else {        return null;    }}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    Long userId = (Long) principals.fromRealm(getName()).iterator().next();    User user = userDAO.getUser(userId);    if (user != null) {        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        for (Role role : user.getRoles()) {            info.addRole(role.getName());            info.addStringPermissions(role.getPermissions());        }        return info;    } else {        return null;    }}
0
public void setUserDAO(UserDAO userDAO)
{    this.userDAO = userDAO;}
0
public User getCurrentUser()
{    final Long currentUserId = (Long) SecurityUtils.getSubject().getPrincipal();    if (currentUserId != null) {        return getUser(currentUserId);    } else {        return null;    }}
0
public void createUser(String username, String email, String password)
{    User user = new User();    user.setUsername(username);    user.setEmail(email);    user.setPassword(new Sha256Hash(password).toHex());    userDAO.createUser(user);}
0
public List<User> getAllUsers()
{    return userDAO.getAllUsers();}
0
public User getUser(Long userId)
{    return userDAO.getUser(userId);}
0
public void deleteUser(Long userId)
{    userDAO.deleteUser(userId);}
0
public void updateUser(User user)
{    userDAO.updateUser(user);}
0
public void setUserService(UserService userService)
{    this.userService = userService;}
0
public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception
{        User currentUser = userService.getCurrentUser();    if (currentUser != null) {        httpServletRequest.setAttribute("currentUser", currentUser);    }}
0
public Long getUserId()
{    return userId;}
0
public void setUserId(Long userId)
{    this.userId = userId;}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public String getEmail()
{    return email;}
0
public void setEmail(String email)
{    this.email = email;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public void updateUser(User user)
{    Assert.isTrue(userId.equals(user.getId()), "User ID of command must match the user being updated.");    user.setUsername(getUsername());    user.setEmail(getEmail());    if (StringUtils.hasText(getPassword())) {        user.setPassword(new Sha256Hash(getPassword()).toHex());    }}
0
public boolean supports(Class aClass)
{    return EditUserCommand.class.isAssignableFrom(aClass);}
0
public void validate(Object o, Errors errors)
{    EditUserCommand command = (EditUserCommand) o;    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "error.username.empty", "Please specify a username.");    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "error.email.empty", "Please specify an email address.");    if (StringUtils.hasText(command.getEmail()) && !Pattern.matches(SIMPLE_EMAIL_REGEX, command.getEmail().toUpperCase())) {        errors.rejectValue("email", "error.email.invalid", "Please enter a valid email address.");    }}
0
public void setUserService(UserService userService)
{    this.userService = userService;}
0
public void viewHome(Model model)
{    model.addAttribute("users", userService.getAllUsers());}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public boolean isRememberMe()
{    return rememberMe;}
0
public void setRememberMe(boolean rememberMe)
{    this.rememberMe = rememberMe;}
0
public boolean supports(Class aClass)
{    return LoginCommand.class.isAssignableFrom(aClass);}
0
public void validate(Object o, Errors errors)
{    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "error.username.empty", "Please specify a username.");    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "error.password.empty", "Please specify a password.");}
0
public void setUserService(UserService userService)
{    this.userService = userService;}
0
public void manageUsers(Model model)
{    model.addAttribute("users", userService.getAllUsers());}
0
public String showEditUserForm(Model model, @RequestParam Long userId, @ModelAttribute EditUserCommand command)
{    User user = userService.getUser(userId);    command.setUserId(userId);    command.setUsername(user.getUsername());    command.setEmail(user.getEmail());    return "editUser";}
0
public String editUser(Model model, @RequestParam Long userId, @ModelAttribute EditUserCommand command, BindingResult errors)
{    editUserValidator.validate(command, errors);    if (errors.hasErrors()) {        return "editUser";    }    User user = userService.getUser(userId);    command.updateUser(user);    userService.updateUser(user);    return "redirect:/s/manageUsers";}
0
public String deleteUser(@RequestParam Long userId)
{    Assert.isTrue(userId != 1, "Cannot delete admin user");    userService.deleteUser(userId);    return "redirect:/s/manageUsers";}
0
public String showLoginForm(Model model, @ModelAttribute LoginCommand command)
{    return "login";}
0
public String login(Model model, @ModelAttribute LoginCommand command, BindingResult errors)
{    loginValidator.validate(command, errors);    if (errors.hasErrors()) {        return showLoginForm(model, command);    }    UsernamePasswordToken token = new UsernamePasswordToken(command.getUsername(), command.getPassword(), command.isRememberMe());    try {        SecurityUtils.getSubject().login(token);    } catch (AuthenticationException e) {        errors.reject("error.login.generic", "Invalid username or password.  Please try again.");    }    if (errors.hasErrors()) {        return showLoginForm(model, command);    } else {        return "redirect:/s/home";    }}
0
public String logout()
{    SecurityUtils.getSubject().logout();    return "redirect:/";}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public String getEmail()
{    return email;}
0
public void setEmail(String email)
{    this.email = email;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public void setUserService(UserService userService)
{    this.userService = userService;}
0
public String showSignupForm(Model model, @ModelAttribute SignupCommand command)
{    return "signup";}
0
public String showSignupForm(Model model, @ModelAttribute SignupCommand command, BindingResult errors)
{    signupValidator.validate(command, errors);    if (errors.hasErrors()) {        return showSignupForm(model, command);    }        userService.createUser(command.getUsername(), command.getEmail(), command.getPassword());        SecurityUtils.getSubject().login(new UsernamePasswordToken(command.getUsername(), command.getPassword()));    return "redirect:/s/home";}
0
public boolean supports(Class aClass)
{    return SignupCommand.class.isAssignableFrom(aClass);}
0
public void validate(Object o, Errors errors)
{    SignupCommand command = (SignupCommand) o;    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "error.username.empty", "Please specify a username.");    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "error.email.empty", "Please specify an email address.");    if (StringUtils.hasText(command.getEmail()) && !Pattern.matches(SIMPLE_EMAIL_REGEX, command.getEmail().toUpperCase())) {        errors.rejectValue("email", "error.email.invalid", "Please enter a valid email address.");    }    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "error.password.empty", "Please specify a password.");}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/s/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "s/login");    HtmlForm form = page.getFormByName("loginForm");    form.<HtmlInput>getInputByName("username").setValueAttribute("admin");    form.<HtmlInput>getInputByName("password").setValueAttribute("admin");    page = form.<HtmlInput>getInputByValue("Login").click();        page.getAnchorByHref("/s/logout");}
0
public void setDataSource(DataSource dataSource)
{    this.dataSource = dataSource;}
0
public void afterPropertiesSet() throws Exception
{            JdbcTemplate jdbcTemplate = new JdbcTemplate(this.dataSource);    jdbcTemplate.execute(CREATE_TABLES);                        String query = "insert into users values ('user1', '" + new Sha256Hash("user1", "user1").toBase64() + "' )";    jdbcTemplate.execute(query);            query = "insert into users values ( 'user2', '" + new Sha256Hash("user2", "user2").toBase64() + "' )";    jdbcTemplate.execute(query);        query = "insert into roles values ( 'role1' )";    jdbcTemplate.execute(query);        query = "insert into roles values ( 'role2' )";    jdbcTemplate.execute(query);        query = "insert into roles_permissions values ( 'role1', 'permission1')";    jdbcTemplate.execute(query);        query = "insert into roles_permissions values ( 'role1', 'permission2')";    jdbcTemplate.execute(query);        query = "insert into roles_permissions values ( 'role2', 'permission1')";    jdbcTemplate.execute(query);        query = "insert into user_roles values ( 'user1', 'role1' )";    jdbcTemplate.execute(query);    query = "insert into user_roles values ( 'user1', 'role2' )";    jdbcTemplate.execute(query);        query = "insert into user_roles values ( 'user2', 'role2' )";    jdbcTemplate.execute(query);    }
1
protected BootstrapDataPopulator bootstrapDataPopulator(DataSource dataSource)
{    BootstrapDataPopulator populator = new BootstrapDataPopulator();    populator.setDataSource(dataSource);    return populator;}
0
protected SaltAwareJdbcRealm jdbcRealm(DataSource dataSource)
{    HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();    credentialsMatcher.setHashAlgorithmName("SHA-256");    credentialsMatcher.setStoredCredentialsHexEncoded(false);    SaltAwareJdbcRealm jdbcRealm = new SaltAwareJdbcRealm();    jdbcRealm.setName("jdbcRealm");    jdbcRealm.setCredentialsMatcher(credentialsMatcher);    jdbcRealm.setDataSource(dataSource);    return jdbcRealm;}
0
protected EhCacheManager cacheManager()
{    EhCacheManager ehCacheManager = new EhCacheManager();    return ehCacheManager;}
0
protected SecureRemoteInvocationExecutor secureRemoteInvocationExecutor(SecurityManager securityManager)
{    SecureRemoteInvocationExecutor executor = new SecureRemoteInvocationExecutor();    executor.setSecurityManager(securityManager);    return executor;}
0
protected DefaultSampleManager sampleManager()
{    return new DefaultSampleManager();}
0
protected DriverManagerDataSource dataSource()
{    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName("org.hsqldb.jdbcDriver");    dataSource.setUrl("jdbc:hsqldb:mem:shiro-spring");    dataSource.setUsername("sa");    return dataSource;}
0
public ShiroFilterChainDefinition shiroFilterChainDefinition()
{    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();            chainDefinition.addPathDefinition("/favicon.ico", "anon");    chainDefinition.addPathDefinition("/logo.png", "anon");    chainDefinition.addPathDefinition("/shiro.css", "anon");    chainDefinition.addPathDefinition("/s/login", "anon");        chainDefinition.addPathDefinition("/*.jar", "anon");        chainDefinition.addPathDefinition("/remoting/**", "anon");    chainDefinition.addPathDefinition("/**", "authc");    return chainDefinition;}
0
public ViewResolver getViewResolver()
{    InternalResourceViewResolver resolver = new InternalResourceViewResolver();    resolver.setViewClass(JstlView.class);    resolver.setPrefix("/WEB-INF/resources/");    resolver.setSuffix(".jsp");    return resolver;}
0
public ViewResolver jnlpViewResolver()
{    InternalResourceViewResolver resolver = new InternalResourceViewResolver();    resolver.setViewClass(JstlView.class);    resolver.setPrefix("/WEB-INF/jnlp/");    resolver.setSuffix(".jsp");    return resolver;}
0
public void addResourceHandlers(ResourceHandlerRegistry registry)
{    registry.addResourceHandler("*.css", "*.png").addResourceLocations("/");    registry.addResourceHandler("*.jar", "*.pack").addResourceLocations("/WEB-INF/resources/");}
0
public HttpInvokerServiceExporter accountServiceExporter(SampleManager sampleManager, SecureRemoteInvocationExecutor secureRemoteInvocationExecutor)
{    HttpInvokerServiceExporter httpInvokerServiceExporter = new HttpInvokerServiceExporter();    httpInvokerServiceExporter.setService(sampleManager);    httpInvokerServiceExporter.setServiceInterface(SampleManager.class);    httpInvokerServiceExporter.setRemoteInvocationExecutor(secureRemoteInvocationExecutor);    return httpInvokerServiceExporter;}
0
public void onStartup(ServletContext container)
{        AnnotationConfigWebApplicationContext appContext = getContext();        container.addListener(new ContextLoaderListener(appContext));    FilterRegistration.Dynamic shiroFilter = container.addFilter("shiroFilterFactoryBean", DelegatingFilterProxy.class);    shiroFilter.setInitParameter("targetFilterLifecycle", "true");    shiroFilter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "/*");    ServletRegistration.Dynamic remotingDispatcher = container.addServlet("remoting", new DispatcherServlet(appContext));    remotingDispatcher.setLoadOnStartup(1);    remotingDispatcher.addMapping("/remoting/*");    ServletRegistration.Dynamic dispatcher = container.addServlet("DispatcherServlet", new DispatcherServlet(appContext));    dispatcher.setLoadOnStartup(1);    dispatcher.addMapping("/");}
0
private AnnotationConfigWebApplicationContext getContext()
{    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();    context.setConfigLocation(getClass().getPackage().getName());    return context;}
0
public String getValue()
{    String value = null;    Subject subject = SecurityUtils.getSubject();    Session session = subject.getSession(false);    if (session != null) {        value = (String) session.getAttribute(VALUE_KEY);        if (log.isDebugEnabled()) {                    }    }    return value;}
1
public void setValue(String newValue)
{    Subject subject = SecurityUtils.getSubject();    Session session = subject.getSession();    if (log.isDebugEnabled()) {            }    session.setAttribute(VALUE_KEY, newValue);}
1
public void secureMethod1()
{    if (log.isInfoEnabled()) {            }}
1
public void secureMethod2()
{    if (log.isInfoEnabled()) {            }}
1
public void secureMethod3()
{    if (log.isInfoEnabled()) {            }}
1
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    UsernamePasswordToken upToken = (UsernamePasswordToken) token;    String username = upToken.getUsername();        if (username == null) {        throw new AccountException("Null usernames are not allowed by this realm.");    }    Connection conn = null;    AuthenticationInfo info = null;    try {        conn = dataSource.getConnection();        String password = getPasswordForUser(conn, username);        if (password == null) {            throw new UnknownAccountException("No account found for user [" + username + "]");        }        SimpleAuthenticationInfo saInfo = new SimpleAuthenticationInfo(username, password, getName());        /**         * This (very bad) example uses the username as the salt in this sample app.  DON'T DO THIS IN A REAL APP!         *         * Salts should not be based on anything that a user could enter (attackers can exploit this).  Instead         * they should ideally be cryptographically-strong randomly generated numbers.         */        saInfo.setCredentialsSalt(ByteSource.Util.bytes(username));        info = saInfo;    } catch (SQLException e) {        final String message = "There was a SQL error while authenticating user [" + username + "]";        if (log.isErrorEnabled()) {                    }                throw new AuthenticationException(message, e);    } finally {        JdbcUtils.closeConnection(conn);    }    return info;}
1
private String getPasswordForUser(Connection conn, String username) throws SQLException
{    PreparedStatement ps = null;    ResultSet rs = null;    String password = null;    try {        ps = conn.prepareStatement(authenticationQuery);        ps.setString(1, username);                rs = ps.executeQuery();                boolean foundResult = false;        while (rs.next()) {                        if (foundResult) {                throw new AuthenticationException("More than one user row found for user [" + username + "]. Usernames must be unique.");            }            password = rs.getString(1);            foundResult = true;        }    } finally {        JdbcUtils.closeResultSet(rs);        JdbcUtils.closeStatement(ps);    }    return password;}
0
public void setSampleManager(SampleManager sampleManager)
{    this.sampleManager = sampleManager;}
0
protected String doGet(Model model)
{    buildModel(model);    model.addAttribute("value", sampleManager.getValue());    return "sampleIndex";}
0
protected Model buildModel(Model model)
{    Subject subject = SecurityUtils.getSubject();    boolean hasRole1 = subject.hasRole("role1");    boolean hasRole2 = subject.hasRole("role2");    model.addAttribute("hasRole1", hasRole1);    model.addAttribute("hasRole2", hasRole2);    Session session = subject.getSession();    Map<Object, Object> sessionAttributes = new LinkedHashMap<Object, Object>();    for (Object key : session.getAttributeKeys()) {        sessionAttributes.put(key, session.getAttribute(key));    }    model.addAttribute("sessionAttributes", sessionAttributes);    model.addAttribute("subjectSession", subject.getSession());    return model;}
0
protected String doPost(@RequestParam("value") String newSessionValue, Model model)
{    sampleManager.setValue(newSessionValue);    buildModel(model);    model.addAttribute("value", sampleManager.getValue());    return "sampleIndex";}
0
public void setJnlpView(String jnlpView)
{    this.jnlpView = jnlpView;}
0
protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception
{    Subject subject = SecurityUtils.getSubject();    Session session = null;    if (subject != null) {        session = subject.getSession();    }    if (session == null) {        String msg = "Expected a non-null Shiro session.";        throw new IllegalArgumentException(msg);    }    StringBuilder sb = new StringBuilder();    sb.append("http://");    sb.append(request.getServerName());    if (request.getServerPort() != 80) {        sb.append(":");        sb.append(request.getServerPort());    }    sb.append(request.getContextPath());        response.setHeader("cache-control", "no-cache");    response.setHeader("pragma", "no-cache");    Map<String, Object> model = new HashMap<String, Object>();    model.put("codebaseUrl", sb.toString());    model.put("sessionId", session.getId());    return new ModelAndView(jnlpView, model);}
0
protected String view()
{    return loginView;}
0
protected String onSubmit(@RequestParam("username") String username, @RequestParam("password") String password, Model model) throws Exception
{    UsernamePasswordToken token = new UsernamePasswordToken(username, password);    try {        SecurityUtils.getSubject().login(token);    } catch (AuthenticationException e) {                model.addAttribute("errorInvalidLogin", "The username or password was not correct.");        return loginView;    }    return "redirect:/s/index";}
1
protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception
{    SecurityUtils.getSubject().logout();    return new ModelAndView("redirect:login");}
0
public String redirect()
{    return "redirect:/s/login";}
0
public void logOut() throws IOException
{        final HtmlPage homePage = webClient.getPage(getBaseUri());    try {        homePage.getAnchorByHref("/logout").click();    } catch (ElementNotFoundException e) {        }}
0
public void logIn() throws FailingHttpStatusCodeException, MalformedURLException, IOException, InterruptedException
{    HtmlPage page = webClient.getPage(getBaseUri() + "login.jsp");    HtmlForm form = page.getFormByName("loginform");    form.<HtmlInput>getInputByName("username").setValueAttribute("root");    form.<HtmlInput>getInputByName("password").setValueAttribute("secret");    page = form.<HtmlInput>getInputByName("submit").click();        page.getAnchorByHref("/logout");}
0
public void anyShiroAnnotatedMethod()
{}
0
 void anyShiroAnnotatedMethodCall(JoinPoint thisJoinPoint)
{}
0
public void executeAnnotatedMethod(JoinPoint thisJoinPoint) throws Throwable
{    interceptor.performBeforeInterception(thisJoinPoint);}
0
protected void performBeforeInterception(JoinPoint aJoinPoint) throws Throwable
{    if (log.isTraceEnabled())        log.trace("#### Invoking a method decorated with a Shiro annotation" + "\n\tkind       : " + aJoinPoint.getKind() + "\n\tjoinPoint  : " + aJoinPoint + "\n\tannotations: " + Arrays.toString(((MethodSignature) aJoinPoint.getSignature()).getMethod().getAnnotations()) + "\n\ttarget     : " + aJoinPoint.getTarget());        BeforeAdviceMethodInvocationAdapter mi = BeforeAdviceMethodInvocationAdapter.createFrom(aJoinPoint);        super.invoke(mi);}
0
public static BeforeAdviceMethodInvocationAdapter createFrom(JoinPoint aJoinPoint)
{    if (aJoinPoint.getSignature() instanceof MethodSignature) {        return new BeforeAdviceMethodInvocationAdapter(aJoinPoint.getThis(), ((MethodSignature) aJoinPoint.getSignature()).getMethod(), aJoinPoint.getArgs());    } else if (aJoinPoint.getSignature() instanceof AdviceSignature) {        return new BeforeAdviceMethodInvocationAdapter(aJoinPoint.getThis(), ((AdviceSignature) aJoinPoint.getSignature()).getAdvice(), aJoinPoint.getArgs());    } else {        throw new IllegalArgumentException("The joint point signature is invalid: expected a MethodSignature or an AdviceSignature but was " + aJoinPoint.getSignature());    }}
0
public Object[] getArguments()
{    return _arguments;}
0
public Method getMethod()
{    return _method;}
0
public Object proceed() throws Throwable
{        return null;}
0
public Object getThis()
{    return _object;}
0
public static void setUpClass() throws Exception
{    Logger log = Logger.getLogger(AspectjAnnotationsAuthorizingMethodInterceptor.class);    log.addAppender(new ConsoleAppender(new SimpleLayout(), ConsoleAppender.SYSTEM_OUT));    log.setLevel(Level.TRACE);    Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiroDummyServiceTest.ini");    SecurityManager securityManager = factory.getInstance();    SecurityUtils.setSecurityManager(securityManager);    SECURED_SERVICE = new SecuredDummyService();    RESTRICTED_SERVICE = new RestrictedDummyService();}
0
public static void tearDownClass() throws Exception
{        SecurityUtils.setSecurityManager(null);}
0
public void setUp() throws Exception
{    subject = SecurityUtils.getSubject();}
0
public void tearDown() throws Exception
{    subject.logout();}
0
private void loginAsUser()
{    subject.login(new UsernamePasswordToken("joe", "bob"));}
0
private void loginAsAdmin()
{    subject.login(new UsernamePasswordToken("root", "secret"));}
0
public void testAnonymous_asAnonymous() throws Exception
{    SECURED_SERVICE.anonymous();}
0
public void testAnonymous_asUser() throws Exception
{    loginAsUser();    SECURED_SERVICE.anonymous();}
0
public void testAnonymous_asAdmin() throws Exception
{    loginAsAdmin();    SECURED_SERVICE.anonymous();}
0
public void testGuest_asAnonymous() throws Exception
{    SECURED_SERVICE.guest();}
0
public void testGuest_asUser() throws Exception
{    loginAsUser();    SECURED_SERVICE.guest();}
0
public void testGuest_asAdmin() throws Exception
{    loginAsAdmin();    SECURED_SERVICE.guest();}
0
public void testPeek_asAnonymous() throws Exception
{    SECURED_SERVICE.peek();}
0
public void testPeek_asUser() throws Exception
{    loginAsUser();    SECURED_SERVICE.peek();}
0
public void testPeek_asAdmin() throws Exception
{    loginAsAdmin();    SECURED_SERVICE.peek();}
0
public void testRetrieve_asAnonymous() throws Exception
{    SECURED_SERVICE.retrieve();}
0
public void testRetrieve_asUser() throws Exception
{    loginAsUser();    SECURED_SERVICE.retrieve();}
0
public void testRetrieve_asAdmin() throws Exception
{    loginAsAdmin();    SECURED_SERVICE.retrieve();}
0
public void testChange_asAnonymous() throws Exception
{    SECURED_SERVICE.change();}
0
public void testChange_asUser() throws Exception
{    loginAsUser();    SECURED_SERVICE.change();}
0
public void testChange_asAdmin() throws Exception
{    loginAsAdmin();    SECURED_SERVICE.change();}
0
public void testRetrieveRestricted_asAnonymous() throws Exception
{    RESTRICTED_SERVICE.retrieve();}
0
public void testRetrieveRestricted_asUser() throws Exception
{    loginAsUser();    RESTRICTED_SERVICE.retrieve();}
0
public void testRetrieveRestricted_asAdmin() throws Exception
{    loginAsAdmin();    RESTRICTED_SERVICE.retrieve();}
0
public void retrieve()
{    log("retrieve *RESTRICTED*");    super.retrieve();}
0
public void change()
{    retrieve();    log("change");    peek();}
0
public void anonymous()
{    log("anonymous");}
0
public void guest()
{    log("guest");}
0
public void peek()
{    log("peek");}
0
public void retrieve()
{    log("retrieve");}
0
public void log(String aMessage)
{    if (aMessage != null) {        System.out.println(new Timestamp(System.currentTimeMillis()).toString() + " [" + Thread.currentThread() + "] * LOG * " + aMessage);    } else {        System.out.println("\n\n");    }}
0
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception
{    HttpServletRequest httpRequest = (HttpServletRequest) request;    String ticket = httpRequest.getParameter(TICKET_PARAMETER);    return new CasToken(ticket);}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception
{    return executeLogin(request, response);}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{    return false;}
0
protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception
{    issueSuccessRedirect(request, response);    return false;}
0
protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException ae, ServletRequest request, ServletResponse response)
{    if (logger.isDebugEnabled()) {            }        Subject subject = getSubject(request, response);    if (subject.isAuthenticated() || subject.isRemembered()) {        try {            issueSuccessRedirect(request, response);        } catch (Exception e) {                    }    } else {        try {            WebUtils.issueRedirect(request, response, failureUrl);        } catch (IOException e) {                    }    }    return false;}
1
public void setFailureUrl(String failureUrl)
{    this.failureUrl = failureUrl;}
0
protected void onInit()
{    super.onInit();    ensureTicketValidator();}
0
protected TicketValidator ensureTicketValidator()
{    if (this.ticketValidator == null) {        this.ticketValidator = createTicketValidator();    }    return this.ticketValidator;}
0
protected TicketValidator createTicketValidator()
{    String urlPrefix = getCasServerUrlPrefix();    if ("saml".equalsIgnoreCase(getValidationProtocol())) {        return new Saml11TicketValidator(urlPrefix);    }    return new Cas20ServiceTicketValidator(urlPrefix);}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    CasToken casToken = (CasToken) token;    if (token == null) {        return null;    }    String ticket = (String) casToken.getCredentials();    if (!StringUtils.hasText(ticket)) {        return null;    }    TicketValidator ticketValidator = ensureTicketValidator();    try {                Assertion casAssertion = ticketValidator.validate(ticket, getCasService());                AttributePrincipal casPrincipal = casAssertion.getPrincipal();        String userId = casPrincipal.getName();                Map<String, Object> attributes = casPrincipal.getAttributes();                casToken.setUserId(userId);        String rememberMeAttributeName = getRememberMeAttributeName();        String rememberMeStringValue = (String) attributes.get(rememberMeAttributeName);        boolean isRemembered = rememberMeStringValue != null && Boolean.parseBoolean(rememberMeStringValue);        if (isRemembered) {            casToken.setRememberMe(true);        }                List<Object> principals = CollectionUtils.asList(userId, attributes);        PrincipalCollection principalCollection = new SimplePrincipalCollection(principals, getName());        return new SimpleAuthenticationInfo(principalCollection, ticket);    } catch (TicketValidationException e) {        throw new CasAuthenticationException("Unable to validate ticket [" + ticket + "]", e);    }}
1
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{        SimplePrincipalCollection principalCollection = (SimplePrincipalCollection) principals;    List<Object> listPrincipals = principalCollection.asList();    Map<String, String> attributes = (Map<String, String>) listPrincipals.get(1);        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();        addRoles(simpleAuthorizationInfo, split(defaultRoles));        addPermissions(simpleAuthorizationInfo, split(defaultPermissions));        List<String> attributeNames = split(roleAttributeNames);    for (String attributeName : attributeNames) {        String value = attributes.get(attributeName);        addRoles(simpleAuthorizationInfo, split(value));    }        attributeNames = split(permissionAttributeNames);    for (String attributeName : attributeNames) {        String value = attributes.get(attributeName);        addPermissions(simpleAuthorizationInfo, split(value));    }    return simpleAuthorizationInfo;}
0
private List<String> split(String s)
{    List<String> list = new ArrayList<String>();    String[] elements = StringUtils.split(s, ',');    if (elements != null && elements.length > 0) {        for (String element : elements) {            if (StringUtils.hasText(element)) {                list.add(element.trim());            }        }    }    return list;}
0
private void addRoles(SimpleAuthorizationInfo simpleAuthorizationInfo, List<String> roles)
{    for (String role : roles) {        simpleAuthorizationInfo.addRole(role);    }}
0
private void addPermissions(SimpleAuthorizationInfo simpleAuthorizationInfo, List<String> permissions)
{    for (String permission : permissions) {        simpleAuthorizationInfo.addStringPermission(permission);    }}
0
public String getCasServerUrlPrefix()
{    return casServerUrlPrefix;}
0
public void setCasServerUrlPrefix(String casServerUrlPrefix)
{    this.casServerUrlPrefix = casServerUrlPrefix;}
0
public String getCasService()
{    return casService;}
0
public void setCasService(String casService)
{    this.casService = casService;}
0
public String getValidationProtocol()
{    return validationProtocol;}
0
public void setValidationProtocol(String validationProtocol)
{    this.validationProtocol = validationProtocol;}
0
public String getRememberMeAttributeName()
{    return rememberMeAttributeName;}
0
public void setRememberMeAttributeName(String rememberMeAttributeName)
{    this.rememberMeAttributeName = rememberMeAttributeName;}
0
public String getDefaultRoles()
{    return defaultRoles;}
0
public void setDefaultRoles(String defaultRoles)
{    this.defaultRoles = defaultRoles;}
0
public String getDefaultPermissions()
{    return defaultPermissions;}
0
public void setDefaultPermissions(String defaultPermissions)
{    this.defaultPermissions = defaultPermissions;}
0
public String getRoleAttributeNames()
{    return roleAttributeNames;}
0
public void setRoleAttributeNames(String roleAttributeNames)
{    this.roleAttributeNames = roleAttributeNames;}
0
public String getPermissionAttributeNames()
{    return permissionAttributeNames;}
0
public void setPermissionAttributeNames(String permissionAttributeNames)
{    this.permissionAttributeNames = permissionAttributeNames;}
0
public Subject createSubject(SubjectContext context)
{        boolean authenticated = context.isAuthenticated();        if (authenticated) {        AuthenticationToken token = context.getAuthenticationToken();        if (token != null && token instanceof CasToken) {            CasToken casToken = (CasToken) token;                        if (casToken.isRememberMe()) {                context.setAuthenticated(false);            }        }    }    return super.createSubject(context);}
0
public Object getPrincipal()
{    return userId;}
0
public Object getCredentials()
{    return ticket;}
0
public void setUserId(String userId)
{    this.userId = userId;}
0
public boolean isRememberMe()
{    return isRememberMe;}
0
public void setRememberMe(boolean isRememberMe)
{    this.isRememberMe = isRememberMe;}
0
public V get(K key) throws CacheException
{    try {        if (log.isTraceEnabled()) {            log.trace("Getting object from cache [" + cache.getName() + "] for key [" + key + "]");        }        if (key == null) {            return null;        } else {            Element element = cache.get(key);            if (element == null) {                if (log.isTraceEnabled()) {                    log.trace("Element for [" + key + "] is null.");                }                return null;            } else {                                return (V) element.getObjectValue();            }        }    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public V put(K key, V value) throws CacheException
{    if (log.isTraceEnabled()) {        log.trace("Putting object in cache [" + cache.getName() + "] for key [" + key + "]");    }    try {        V previous = get(key);        Element element = new Element(key, value);        cache.put(element);        return previous;    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public V remove(K key) throws CacheException
{    if (log.isTraceEnabled()) {        log.trace("Removing object from cache [" + cache.getName() + "] for key [" + key + "]");    }    try {        V previous = get(key);        cache.remove(key);        return previous;    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public void clear() throws CacheException
{    if (log.isTraceEnabled()) {        log.trace("Clearing all objects from cache [" + cache.getName() + "]");    }    try {        cache.removeAll();    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public int size()
{    try {        return cache.getSize();    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public Set<K> keys()
{    try {        @SuppressWarnings({ "unchecked" })        List<K> keys = cache.getKeys();        if (!isEmpty(keys)) {            return Collections.unmodifiableSet(new LinkedHashSet<K>(keys));        } else {            return Collections.emptySet();        }    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public Collection<V> values()
{    try {        @SuppressWarnings({ "unchecked" })        List<K> keys = cache.getKeys();        if (!isEmpty(keys)) {            List<V> values = new ArrayList<V>(keys.size());            for (K key : keys) {                V value = get(key);                if (value != null) {                    values.add(value);                }            }            return Collections.unmodifiableList(values);        } else {            return Collections.emptyList();        }    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public long getMemoryUsage()
{    try {        return cache.calculateInMemorySize();    } catch (Throwable t) {        return -1;    }}
0
public long getMemoryStoreSize()
{    try {        return cache.getMemoryStoreSize();    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public long getDiskStoreSize()
{    try {        return cache.getDiskStoreSize();    } catch (Throwable t) {        throw new CacheException(t);    }}
0
public String toString()
{    return "EhCache [" + cache.getName() + "]";}
0
private static boolean isEmpty(Collection c)
{    return c == null || c.isEmpty();}
0
public net.sf.ehcache.CacheManager getCacheManager()
{    return manager;}
0
public void setCacheManager(net.sf.ehcache.CacheManager manager)
{    this.manager = manager;}
0
public String getCacheManagerConfigFile()
{    return this.cacheManagerConfigFile;}
0
public void setCacheManagerConfigFile(String classpathLocation)
{    this.cacheManagerConfigFile = classpathLocation;}
0
protected InputStream getCacheManagerConfigFileInputStream()
{    String configFile = getCacheManagerConfigFile();    try {        return ResourceUtils.getInputStreamForPath(configFile);    } catch (IOException e) {        throw new IllegalStateException("Unable to obtain input stream for cacheManagerConfigFile [" + configFile + "]", e);    }}
0
public final Cache<K, V> getCache(String name) throws CacheException
{    if (log.isTraceEnabled()) {        log.trace("Acquiring EhCache instance named [" + name + "]");    }    try {        net.sf.ehcache.Ehcache cache = ensureCacheManager().getEhcache(name);        if (cache == null) {            if (log.isInfoEnabled()) {                            }            this.manager.addCache(name);            cache = manager.getCache(name);            if (log.isInfoEnabled()) {                            }        } else {            if (log.isInfoEnabled()) {                            }        }        return new EhCache<K, V>(cache);    } catch (net.sf.ehcache.CacheException e) {        throw new CacheException(e);    }}
1
public final void init() throws CacheException
{    ensureCacheManager();}
0
private net.sf.ehcache.CacheManager ensureCacheManager()
{    try {        if (this.manager == null) {            if (log.isDebugEnabled()) {                            }                                                                        this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream());            if (log.isTraceEnabled()) {                log.trace("instantiated Ehcache CacheManager instance.");            }            cacheManagerImplicitlyCreated = true;            if (log.isDebugEnabled()) {                            }        }        return this.manager;    } catch (Exception e) {        throw new CacheException(e);    }}
1
public void destroy()
{    if (cacheManagerImplicitlyCreated) {        try {            net.sf.ehcache.CacheManager cacheMgr = getCacheManager();            cacheMgr.shutdown();        } catch (Throwable t) {            if (log.isWarnEnabled()) {                            }        } finally {            this.manager = null;            this.cacheManagerImplicitlyCreated = false;        }    }}
1
public void setUp()
{    cacheManager = new EhCacheManager();}
0
public void tearDown()
{    LifecycleUtils.destroy(cacheManager);}
0
public void testCacheManagerCreationDuringInit()
{    net.sf.ehcache.CacheManager ehCacheManager = cacheManager.getCacheManager();    assertNull(ehCacheManager);    cacheManager.init();        ehCacheManager = cacheManager.getCacheManager();    assertNotNull(ehCacheManager);}
0
public void testLazyCacheManagerCreationWithoutCallingInit()
{    net.sf.ehcache.CacheManager ehCacheManager = cacheManager.getCacheManager();    assertNull(ehCacheManager);            Cache<String, String> cache = cacheManager.getCache("test");        ehCacheManager = cacheManager.getCacheManager();    assertNotNull(ehCacheManager);    assertNotNull(cache);    cache.put("hello", "world");    String value = cache.get("hello");    assertNotNull(value);    assertEquals(value, "world");}
0
public Object invoke(MethodInvocation invocation) throws Throwable
{    return shiroInterceptor.invoke(new AopAllianceMethodInvocationAdapter(invocation));}
0
public String toString()
{    return "AopAlliance Adapter for " + shiroInterceptor.toString();}
0
public Method getMethod()
{    return mi.getMethod();}
0
public Object[] getArguments()
{    return mi.getArguments();}
0
public String toString()
{    return "Method invocation [" + mi.getMethod() + "]";}
0
public Object proceed() throws Throwable
{    return mi.proceed();}
0
public Object getThis()
{    return mi.getThis();}
0
protected final void configure()
{    AnnotationResolver resolver = createAnnotationResolver();    configureDefaultInterceptors(resolver);    configureInterceptors(resolver);}
0
protected final void bindShiroInterceptor(final AnnotationMethodInterceptor methodInterceptor)
{    bindInterceptor(Matchers.any(), new AbstractMatcher<Method>() {        public boolean matches(Method method) {            Class<? extends Annotation> annotation = methodInterceptor.getHandler().getAnnotationClass();            return method.getAnnotation(annotation) != null || method.getDeclaringClass().getAnnotation(annotation) != null;        }    }, new AopAllianceMethodInterceptorAdapter(methodInterceptor));}
0
public boolean matches(Method method)
{    Class<? extends Annotation> annotation = methodInterceptor.getHandler().getAnnotationClass();    return method.getAnnotation(annotation) != null || method.getDeclaringClass().getAnnotation(annotation) != null;}
0
protected AnnotationResolver createAnnotationResolver()
{    return new DefaultAnnotationResolver();}
0
protected void configureDefaultInterceptors(AnnotationResolver resolver)
{    bindShiroInterceptor(new RoleAnnotationMethodInterceptor(resolver));    bindShiroInterceptor(new PermissionAnnotationMethodInterceptor(resolver));    bindShiroInterceptor(new AuthenticatedAnnotationMethodInterceptor(resolver));    bindShiroInterceptor(new UserAnnotationMethodInterceptor(resolver));    bindShiroInterceptor(new GuestAnnotationMethodInterceptor(resolver));}
0
protected void configureInterceptors(AnnotationResolver resolver)
{}
0
public void hear(TypeLiteral<I> type, final TypeEncounter<I> encounter)
{    PropertyDescriptor[] propertyDescriptors = beanUtilsBean.getPropertyUtils().getPropertyDescriptors(type.getRawType());    final Map<PropertyDescriptor, Key<?>> propertyDependencies = new HashMap<PropertyDescriptor, Key<?>>(propertyDescriptors.length);    final Provider<Injector> injectorProvider = encounter.getProvider(Injector.class);    for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {        if (propertyDescriptor.getWriteMethod() != null && Modifier.isPublic(propertyDescriptor.getWriteMethod().getModifiers())) {            Type propertyType = propertyDescriptor.getWriteMethod().getGenericParameterTypes()[0];            propertyDependencies.put(propertyDescriptor, createDependencyKey(propertyDescriptor, propertyType));        }    }    encounter.register(new MembersInjector<I>() {        public void injectMembers(I instance) {            for (Map.Entry<PropertyDescriptor, Key<?>> dependency : propertyDependencies.entrySet()) {                try {                    final Injector injector = injectorProvider.get();                    Object value = injector.getInstance(getMappedKey(injector, dependency.getValue()));                    dependency.getKey().getWriteMethod().invoke(instance, value);                } catch (ConfigurationException e) {                                                } catch (InvocationTargetException e) {                    throw new RuntimeException("Couldn't set property " + dependency.getKey().getDisplayName(), e);                } catch (IllegalAccessException e) {                    throw new RuntimeException("We shouldn't have ever reached this point, we don't try to inject to non-accessible methods.", e);                }            }        }    });}
0
public void injectMembers(I instance)
{    for (Map.Entry<PropertyDescriptor, Key<?>> dependency : propertyDependencies.entrySet()) {        try {            final Injector injector = injectorProvider.get();            Object value = injector.getInstance(getMappedKey(injector, dependency.getValue()));            dependency.getKey().getWriteMethod().invoke(instance, value);        } catch (ConfigurationException e) {                        } catch (InvocationTargetException e) {            throw new RuntimeException("Couldn't set property " + dependency.getKey().getDisplayName(), e);        } catch (IllegalAccessException e) {            throw new RuntimeException("We shouldn't have ever reached this point, we don't try to inject to non-accessible methods.", e);        }    }}
0
private static Key<?> getMappedKey(Injector injector, Key<?> key)
{    Map<TypeLiteral, BeanTypeKey> beanTypeMap = getBeanTypeMap(injector);    if (key.getAnnotation() == null && beanTypeMap.containsKey(key.getTypeLiteral())) {        return beanTypeMap.get(key.getTypeLiteral()).key;    } else {        return key;    }}
0
private static Map<TypeLiteral, BeanTypeKey> getBeanTypeMap(Injector injector)
{    return (Map<TypeLiteral, BeanTypeKey>) injector.getInstance(MAP_KEY);}
0
private static Key<?> createDependencyKey(PropertyDescriptor propertyDescriptor, Type propertyType)
{    if (requiresName(propertyType)) {        return Key.get(propertyType, Names.named("shiro." + propertyDescriptor.getName()));    } else {        return Key.get(propertyType);    }}
0
private static boolean requiresName(Type propertyType)
{    if (propertyType instanceof Class) {        Class<?> aClass = (Class<?>) propertyType;        return aClass.isPrimitive() || aClass.isEnum() || WRAPPER_TYPES.contains(aClass) || CharSequence.class.isAssignableFrom(aClass);    } else {        return false;    }}
0
 static void ensureBeanTypeMapExists(Binder binder)
{    beanTypeMapBinding(binder).addBinding(TypeLiteral.get(BeanTypeKey.class)).toInstance(new BeanTypeKey(null));}
0
 static void bindBeanType(Binder binder, TypeLiteral<T> typeLiteral, Key<? extends T> key)
{    beanTypeMapBinding(binder).addBinding(typeLiteral).toInstance(new BeanTypeKey(key));}
0
private static MapBinder<TypeLiteral, BeanTypeKey> beanTypeMapBinding(Binder binder)
{    return MapBinder.newMapBinder(binder, TypeLiteral.class, BeanTypeKey.class, Names.named(BEAN_TYPE_MAP_NAME));}
0
public void afterInjection(Destroyable injectee)
{    registry.add(injectee);}
0
public SecurityManager getSecurityManager()
{    return securityManager;}
0
public void afterInjection(Initializable injectee)
{    injectee.init();}
0
public void hear(TypeLiteral<I> type, TypeEncounter<I> encounter)
{    if (InitializableInjectionListener.MATCHER.matches(type)) {        encounter.register(this.<I>castListener(new InitializableInjectionListener<Initializable>()));    }    if (DestroyableInjectionListener.MATCHER.matches(type)) {        encounter.register(this.<I>castListener(new DestroyableInjectionListener<Destroyable>(registry)));    }}
0
private InjectionListener<? super I> castListener(InjectionListener<?> listener)
{    return (InjectionListener<? super I>) listener;}
0
public boolean matches(Class aClass)
{    return aClass.getPackage() != null;}
0
public static Matcher<TypeLiteral> typeLiteral(final Matcher<Class> classMatcher)
{    return new AbstractMatcher<TypeLiteral>() {        public boolean matches(TypeLiteral typeLiteral) {            return classMatcher.matches(typeLiteral.getRawType());        }    };}
0
public boolean matches(TypeLiteral typeLiteral)
{    return classMatcher.matches(typeLiteral.getRawType());}
0
public void configure()
{        bindSecurityManager(bind(SecurityManager.class));    bindSessionManager(bind(SessionManager.class));    bindEnvironment(bind(Environment.class));    bindListener(BeanTypeListener.MATCHER, new BeanTypeListener());    bindEventBus(bind(EventBus.class));    bindListener(Matchers.any(), new SubscribedEventTypeListener());    bindListener(Matchers.any(), new EventBusAwareTypeListener());    final DestroyableInjectionListener.DestroyableRegistry registry = new DestroyableInjectionListener.DestroyableRegistry() {        public void add(Destroyable destroyable) {            ShiroModule.this.add(destroyable);        }        @PreDestroy        public void destroy() {            ShiroModule.this.destroy();        }    };    bindListener(LifecycleTypeListener.MATCHER, new LifecycleTypeListener(registry));    expose(SecurityManager.class);    expose(EventBus.class);    configureShiro();    bind(realmCollectionKey()).to(realmSetKey());    bind(DestroyableInjectionListener.DestroyableRegistry.class).toInstance(registry);    BeanTypeListener.ensureBeanTypeMapExists(binder());}
0
public void add(Destroyable destroyable)
{    ShiroModule.this.add(destroyable);}
0
public void destroy()
{    ShiroModule.this.destroy();}
0
private Key<Set<Realm>> realmSetKey()
{    return (Key<Set<Realm>>) Key.get(TypeLiteral.get(Types.setOf(Realm.class)));}
0
private Key<Collection<Realm>> realmCollectionKey()
{    return (Key<Collection<Realm>>) Key.get(Types.newParameterizedType(Collection.class, Realm.class));}
0
protected final LinkedBindingBuilder<Realm> bindRealm()
{    Multibinder<Realm> multibinder = Multibinder.newSetBinder(binder(), Realm.class);    return multibinder.addBinding();}
0
protected void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind)
{    try {        bind.toConstructor(DefaultSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();    } catch (NoSuchMethodException e) {        throw new ConfigurationException("This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in " + ShiroModule.class.getSimpleName(), e);    }}
0
protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind)
{    bind.to(DefaultSessionManager.class).asEagerSingleton();}
0
protected void bindEnvironment(AnnotatedBindingBuilder<Environment> bind)
{    bind.to(GuiceEnvironment.class).asEagerSingleton();}
0
protected final void bindBeanType(TypeLiteral<T> typeLiteral, Key<? extends T> key)
{    BeanTypeListener.bindBeanType(binder(), typeLiteral, key);}
0
protected void bindEventBus(AnnotatedBindingBuilder<EventBus> bind)
{    bind.to(DefaultEventBus.class).asEagerSingleton();}
0
public final void destroy()
{    for (Destroyable destroyable : destroyables) {        try {            destroyable.destroy();        } catch (Exception e) {                    }    }}
1
public void add(Destroyable destroyable)
{    this.destroyables.add(destroyable);}
0
public void hear(TypeLiteral<I> typeLiteral, TypeEncounter<I> typeEncounter)
{    final Provider<EventBus> eventBusProvider = typeEncounter.getProvider(EventBus.class);    List<Method> methods = ClassUtils.getAnnotatedMethods(typeLiteral.getRawType(), Subscribe.class);    if (methods != null && !methods.isEmpty()) {        typeEncounter.register(new InjectionListener<I>() {            @Override            public void afterInjection(Object o) {                eventBusProvider.get().register(o);            }        });    }}
0
public void afterInjection(Object o)
{    eventBusProvider.get().register(o);}
0
public void hear(TypeLiteral<I> typeLiteral, TypeEncounter<I> typeEncounter)
{    final Provider<EventBus> eventBusProvider = typeEncounter.getProvider(EventBus.class);    if (EventBusAware.class.isAssignableFrom(typeLiteral.getRawType())) {        typeEncounter.register(new InjectionListener<I>() {            @Override            public void afterInjection(Object o) {                ((EventBusAware) o).setEventBus(eventBusProvider.get());            }        });    }}
0
public void afterInjection(Object o)
{    ((EventBusAware) o).setEventBus(eventBusProvider.get());}
0
public Provider<T> scope(final Key<T> key, final Provider<T> unscoped)
{    return new Provider<T>() {        public T get() {            Subject subject = ThreadContext.getSubject();            if (subject == null) {                throw new OutOfScopeException("There is no Shiro Session currently in scope.");            }            Session session = subject.getSession();            T scoped = castSessionAttribute(session);            if (scoped == null) {                scoped = unscoped.get();            }            return scoped;        }        @SuppressWarnings({ "unchecked" })        private T castSessionAttribute(Session session) {            return (T) session.getAttribute(key);        }        @Override        public String toString() {            return unscoped.toString();        }    };}
0
public T get()
{    Subject subject = ThreadContext.getSubject();    if (subject == null) {        throw new OutOfScopeException("There is no Shiro Session currently in scope.");    }    Session session = subject.getSession();    T scoped = castSessionAttribute(session);    if (scoped == null) {        scoped = unscoped.get();    }    return scoped;}
0
private T castSessionAttribute(Session session)
{    return (T) session.getAttribute(key);}
0
public String toString()
{    return unscoped.toString();}
0
public String toString()
{    return "ShiroSessionScope";}
0
public T get()
{    Constructor<T> constructor = getConstructor();    Object[] params = new Object[constructor.getParameterTypes().length];    for (Dependency<?> dependency : constructorInjectionPoint.getDependencies()) {        params[dependency.getParameterIndex()] = injector.getInstance(dependency.getKey());    }    T t;    try {        t = constructor.newInstance(params);    } catch (Exception e) {        throw new ProvisionException("Could not instantiate " + key + "", e);    }    injector.injectMembers(t);    return postProcess(t);}
0
private Constructor<T> getConstructor()
{    return (Constructor<T>) constructorInjectionPoint.getMember();}
0
protected T postProcess(T t)
{        return t;}
0
public Set<Dependency<?>> getDependencies()
{    return dependencies;}
0
public void setPatternMatcher(PatternMatcher patternMatcher)
{    this.patternMatcher = patternMatcher;}
0
public Set<Dependency<?>> getDependencies()
{    return dependencies;}
0
public FilterChainResolver get()
{    return new SimpleFilterChainResolver(chains, injector, patternMatcher);}
0
protected T postProcess(T filter)
{    for (Map.Entry<String, String> pathConfig : this.pathConfigs.entrySet()) {        filter.processPathConfig(pathConfig.getKey(), pathConfig.getValue());    }    return filter;}
0
public static void bindGuiceFilter(Binder binder)
{    binder.install(guiceFilterModule());}
0
public static void bindGuiceFilter(final String pattern, Binder binder)
{    binder.install(guiceFilterModule(pattern));}
0
public static ServletModule guiceFilterModule()
{    return guiceFilterModule("/*");}
0
public static ServletModule guiceFilterModule(final String pattern)
{    return new ServletModule() {        @Override        protected void configureServlets() {            filter(pattern).through(GuiceShiroFilter.class);        }    };}
0
protected void configureServlets()
{    filter(pattern).through(GuiceShiroFilter.class);}
0
protected final void configureShiro()
{    bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));    bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);    bindWebSecurityManager(bind(WebSecurityManager.class));    bindWebEnvironment(bind(WebEnvironment.class));    bind(GuiceShiroFilter.class).asEagerSingleton();    expose(GuiceShiroFilter.class);    this.configureShiroWeb();    bind(FilterChainResolver.class).toProvider(new FilterChainResolverProvider(setupFilterChainConfigs()));}
0
private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs()
{        Map<Key<? extends Filter>, Map<String, String>> filterToPathToConfig = new HashMap<Key<? extends Filter>, Map<String, String>>();        Map<String, Key<? extends Filter>[]> resultConfigMap = new LinkedHashMap<String, Key<? extends Filter>[]>();    for (Map.Entry<String, FilterConfig<? extends Filter>[]> filterChain : filterChains.entrySet()) {        String path = filterChain.getKey();                List<Key<? extends Filter>> keysForPath = new ArrayList<Key<? extends Filter>>();        for (int i = 0; i < filterChain.getValue().length; i++) {            FilterConfig<? extends Filter> filterConfig = filterChain.getValue()[i];            Key<? extends Filter> key = filterConfig.getKey();            String config = filterConfig.getConfigValue();                        if (filterToPathToConfig.get(key) == null) {                                filterToPathToConfig.put((key), new LinkedHashMap<String, String>());            }                        filterToPathToConfig.get(key).put(path, config);                        if (StringUtils.hasText(config) && !PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {                throw new ConfigurationException("Config information requires a PathMatchingFilter - can't apply to " + key.getTypeLiteral().getRawType());            }                        keysForPath.add(key);        }                resultConfigMap.put(path, keysForPath.toArray(new Key[keysForPath.size()]));    }        for (Key<? extends Filter> key : filterToPathToConfig.keySet()) {        if (PathMatchingFilter.class.isAssignableFrom(key.getTypeLiteral().getRawType())) {            bindPathMatchingFilter(castToPathMatching(key), filterToPathToConfig.get(key));        } else {            bind(key);        }    }    return resultConfigMap;}
0
private void bindPathMatchingFilter(Key<T> filterKey, Map<String, String> configs)
{    bind(filterKey).toProvider(new PathMatchingFilterProvider<T>(filterKey, configs)).asEagerSingleton();}
0
private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filter> key)
{    return (Key<? extends PathMatchingFilter>) key;}
0
protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind)
{        bind.to(WebSecurityManager.class);}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    try {        bind.toConstructor(DefaultWebSecurityManager.class.getConstructor(Collection.class)).asEagerSingleton();    } catch (NoSuchMethodException e) {        throw new ConfigurationException("This really shouldn't happen.  Either something has changed in Shiro, or there's a bug in ShiroModule.", e);    }}
0
protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind)
{    bind.to(ServletContainerSessionManager.class).asEagerSingleton();}
0
protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind)
{        bind.to(WebEnvironment.class);}
0
protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind)
{    bind.to(WebGuiceEnvironment.class).asEagerSingleton();}
0
protected final void addFilterChain(String pattern, Key<? extends Filter> key)
{        if (key instanceof FilterConfigKey) {        addLegacyFilterChain(pattern, (FilterConfigKey) key);    } else {        addFilterChain(pattern, new FilterConfig<Filter>((Key<Filter>) key, ""));    }}
0
protected final void addFilterChain(String pattern, FilterConfig<? extends Filter>... filterConfigs)
{    filterChains.put(pattern, filterConfigs);}
0
protected static FilterConfig<T> filterConfig(Key<T> baseKey, String configValue)
{    return new FilterConfig<T>(baseKey, configValue);}
0
protected static FilterConfig<T> filterConfig(Key<T> baseKey)
{    return filterConfig(baseKey, "");}
0
protected static FilterConfig<T> filterConfig(TypeLiteral<T> typeLiteral, String configValue)
{    return filterConfig(Key.get(typeLiteral), configValue);}
0
protected static FilterConfig<T> filterConfig(Class<T> type, String configValue)
{    return filterConfig(Key.get(type), configValue);}
0
public Key<T> getKey()
{    return key;}
0
public String getConfigValue()
{    return configValue;}
0
 static boolean isGuiceVersion3()
{    try {        Class.forName("com.google.inject.multibindings.MapKey");        return false;    } catch (ClassNotFoundException e) {        return true;    }}
0
private void addLegacyFilterChain(String pattern, FilterConfigKey filterConfigKey)
{    FilterConfig<Filter> filterConfig = new FilterConfig<Filter>(filterConfigKey.getKey(), filterConfigKey.getConfigValue());    addFilterChain(pattern, filterConfig);}
0
protected final void addFilterChain(String pattern, Key<? extends Filter>... keys)
{        FilterConfig[] filterConfigs = new FilterConfig[keys.length];    for (int ii = 0; ii < keys.length; ii++) {        Key<? extends Filter> key = keys[ii];                if (key instanceof FilterConfigKey) {                        FilterConfigKey legacyKey = (FilterConfigKey) key;            filterConfigs[ii] = new FilterConfig(legacyKey.getKey(), legacyKey.getConfigValue());        } else {                        filterConfigs[ii] = new FilterConfig(key, "");        }    }    filterChains.put(pattern, filterConfigs);}
0
protected static Key<T> config(Key<T> baseKey, String configValue)
{    if (!isGuiceVersion3()) {        throw new ConfigurationException("Method ShiroWebModule.config(Key<? extends PathMatchingFilter>, String configValue), is not supported when using Guice 4+");    }    return new FilterConfigKey<T>(baseKey, configValue);}
0
protected static Key<T> config(TypeLiteral<T> typeLiteral, String configValue)
{    return config(Key.get(typeLiteral), configValue);}
0
protected static Key<T> config(Class<T> type, String configValue)
{    return config(Key.get(type), configValue);}
0
public Key<T> getKey()
{    return key;}
0
public String getConfigValue()
{    return configValue;}
0
public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException
{    if (chain.hasNext()) {        Filter filter = chain.next();        filter.doFilter(request, response, this);    } else if (!originalCalled) {        originalCalled = true;        originalChain.doFilter(request, response);    }}
0
 Iterator<? extends Filter> getFilters()
{    return chain;}
0
public FilterChain getChain(ServletRequest request, ServletResponse response, final FilterChain originalChain)
{    String path = WebUtils.getPathWithinApplication(WebUtils.toHttp(request));    for (final String pathPattern : chains.keySet()) {        if (patternMatcher.matches(pathPattern, path)) {            final Iterator<Key<? extends Filter>> chain = Arrays.asList(chains.get(pathPattern)).iterator();            return new SimpleFilterChain(originalChain, new Iterator<Filter>() {                public boolean hasNext() {                    return chain.hasNext();                }                public Filter next() {                    return injector.getInstance(chain.next());                }                public void remove() {                    throw new UnsupportedOperationException();                }            });        }    }    return null;}
0
public boolean hasNext()
{    return chain.hasNext();}
0
public Filter next()
{    return injector.getInstance(chain.next());}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
public FilterChainResolver getFilterChainResolver()
{    return filterChainResolver;}
0
public ServletContext getServletContext()
{    return servletContext;}
0
public WebSecurityManager getWebSecurityManager()
{    return securityManager;}
0
public SecurityManager getSecurityManager()
{    return securityManager;}
0
public void testInvoke() throws Throwable
{    MethodInvocation allianceInvocation = createMock(MethodInvocation.class);    MethodInterceptor mockShiroInterceptor = createMock(MethodInterceptor.class);    expect(mockShiroInterceptor.invoke(anyObject(AopAllianceMethodInvocationAdapter.class))).andAnswer(new IAnswer<Object>() {        public Object answer() throws Throwable {            return getCurrentArguments()[0];        }    });    final Object expectedValue = new Object();    expect(allianceInvocation.proceed()).andReturn(expectedValue);    replay(mockShiroInterceptor, allianceInvocation);    AopAllianceMethodInterceptorAdapter underTest = new AopAllianceMethodInterceptorAdapter(mockShiroInterceptor);    Object invocation = underTest.invoke(allianceInvocation);    Object value = ((AopAllianceMethodInvocationAdapter) invocation).proceed();    assertSame("Adapter invocation returned a different value.", expectedValue, value);    verify(mockShiroInterceptor, allianceInvocation);}
0
public Object answer() throws Throwable
{    return getCurrentArguments()[0];}
0
public void testGetMethod() throws Exception
{    MethodInvocation mock = createMock(MethodInvocation.class);    Method method = AopAllianceMethodInvocationAdapterTest.class.getMethod("testGetMethod");    expect(mock.getMethod()).andReturn(method);    AopAllianceMethodInvocationAdapter underTest = new AopAllianceMethodInvocationAdapter(mock);    replay(mock);    assertSame(method, underTest.getMethod());    verify(mock);}
0
public void testGetArguments() throws Exception
{    MethodInvocation mock = createMock(MethodInvocation.class);    Object[] args = new Object[0];    expect(mock.getArguments()).andReturn(args);    AopAllianceMethodInvocationAdapter underTest = new AopAllianceMethodInvocationAdapter(mock);    replay(mock);    assertSame(args, underTest.getArguments());    verify(mock);}
0
public void testProceed() throws Throwable
{    MethodInvocation mock = createMock(MethodInvocation.class);    Object value = new Object();    expect(mock.proceed()).andReturn(value);    AopAllianceMethodInvocationAdapter underTest = new AopAllianceMethodInvocationAdapter(mock);    replay(mock);    assertSame(value, underTest.proceed());    verify(mock);}
0
public void testGetThis() throws Exception
{    MethodInvocation mock = createMock(MethodInvocation.class);    Object value = new Object();    expect(mock.getThis()).andReturn(value);    AopAllianceMethodInvocationAdapter underTest = new AopAllianceMethodInvocationAdapter(mock);    replay(mock);    assertSame(value, underTest.getThis());    verify(mock);}
0
public void testGetAnnotationResolver()
{    final AnnotationResolver annotationResolver = new DefaultAnnotationResolver();    ShiroAopModule underTest = new ShiroAopModule() {        @Override        protected AnnotationResolver createAnnotationResolver() {            return annotationResolver;        }        @Override        protected void configureDefaultInterceptors(AnnotationResolver resolver) {            assertSame(annotationResolver, resolver);            bind(Object.class).annotatedWith(Names.named("configureDefaultInterceptors"));        }        @Override        protected void configureInterceptors(AnnotationResolver resolver) {            assertSame(annotationResolver, resolver);            bind(Object.class).annotatedWith(Names.named("configureInterceptors"));        }    };    boolean calledDefault = false;    boolean calledCustom = false;    for (Element e : Elements.getElements(underTest)) {        if (e instanceof Binding) {            Key key = ((Binding) e).getKey();            if (Named.class.isAssignableFrom(key.getAnnotation().annotationType()) && "configureInterceptors".equals(((Named) key.getAnnotation()).value()) && key.getTypeLiteral().getRawType().equals(Object.class)) {                calledCustom = true;            }            if (Named.class.isAssignableFrom(key.getAnnotation().annotationType()) && "configureDefaultInterceptors".equals(((Named) key.getAnnotation()).value()) && key.getTypeLiteral().getRawType().equals(Object.class)) {                calledDefault = true;            }        }    }}
0
protected AnnotationResolver createAnnotationResolver()
{    return annotationResolver;}
0
protected void configureDefaultInterceptors(AnnotationResolver resolver)
{    assertSame(annotationResolver, resolver);    bind(Object.class).annotatedWith(Names.named("configureDefaultInterceptors"));}
0
protected void configureInterceptors(AnnotationResolver resolver)
{    assertSame(annotationResolver, resolver);    bind(Object.class).annotatedWith(Names.named("configureInterceptors"));}
0
public void testBindShiroInterceptor()
{    ShiroAopModule underTest = new ShiroAopModule() {        @Override        protected void configureInterceptors(AnnotationResolver resolver) {            bindShiroInterceptor(new MyAnnotationMethodInterceptor());        }    };    List<Element> elements = Elements.getElements(underTest);    for (Element element : elements) {        if (element instanceof InterceptorBinding) {            InterceptorBinding binding = (InterceptorBinding) element;            assertTrue(binding.getClassMatcher().matches(getClass()));            Method method = null;            Class<? extends Annotation> theAnnotation = null;            for (Class<? extends Annotation> annotation : protectedMethods.keySet()) {                if (binding.getMethodMatcher().matches(protectedMethods.get(annotation))) {                    method = protectedMethods.get(annotation);                    theAnnotation = annotation;                    protectedMethods.remove(annotation);                    break;                }            }            if (method == null) {                fail("Did not expect interceptor binding " + binding.getInterceptors());            }            List<MethodInterceptor> interceptors = binding.getInterceptors();            assertEquals(1, interceptors.size());            assertTrue(interceptors.get(0) instanceof AopAllianceMethodInterceptorAdapter);            assertTrue(interceptorTypes.get(theAnnotation).isInstance(((AopAllianceMethodInterceptorAdapter) interceptors.get(0)).shiroInterceptor));        }    }    assertTrue("Not all interceptors were bound.", protectedMethods.isEmpty());}
0
protected void configureInterceptors(AnnotationResolver resolver)
{    bindShiroInterceptor(new MyAnnotationMethodInterceptor());}
0
public Object invoke(MethodInvocation methodInvocation) throws Throwable
{    return null;}
0
public void roleProtected()
{}
0
public void permissionProtected()
{}
0
public void authProtected()
{}
0
public void userProtected()
{}
0
public void guestProtected()
{}
0
public void myTestProtected()
{}
0
public void setup() throws NoSuchMethodException
{    protectedMethods = new HashMap<Class<? extends Annotation>, Method>();    protectedMethods.put(RequiresRoles.class, getClass().getMethod("roleProtected"));    protectedMethods.put(RequiresPermissions.class, getClass().getMethod("permissionProtected"));    protectedMethods.put(RequiresAuthentication.class, getClass().getMethod("authProtected"));    protectedMethods.put(RequiresUser.class, getClass().getMethod("userProtected"));    protectedMethods.put(RequiresGuest.class, getClass().getMethod("guestProtected"));    protectedMethods.put(MyTestAnnotation.class, getClass().getMethod("myTestProtected"));    interceptorTypes = new HashMap<Class<? extends Annotation>, Class<? extends AnnotationMethodInterceptor>>();    interceptorTypes.put(RequiresRoles.class, RoleAnnotationMethodInterceptor.class);    interceptorTypes.put(RequiresPermissions.class, PermissionAnnotationMethodInterceptor.class);    interceptorTypes.put(RequiresAuthentication.class, AuthenticatedAnnotationMethodInterceptor.class);    interceptorTypes.put(RequiresUser.class, UserAnnotationMethodInterceptor.class);    interceptorTypes.put(RequiresGuest.class, GuestAnnotationMethodInterceptor.class);    interceptorTypes.put(MyTestAnnotation.class, MyAnnotationMethodInterceptor.class);}
0
public void testUnmatchedPackage() throws Exception
{    assertFalse(BeanTypeListener.MATCHER.matches(TypeLiteral.get(GuiceEnvironment.class)));    assertFalse(BeanTypeListener.MATCHER.matches(TypeLiteral.get(ShiroWebModule.class)));    assertFalse(BeanTypeListener.MATCHER.matches(TypeLiteral.get(ShiroAopModule.class)));}
0
public void testMatchedPackage() throws Exception
{    assertTrue(BeanTypeListener.MATCHER.matches(TypeLiteral.get(SecurityUtils.class)));    assertTrue(BeanTypeListener.MATCHER.matches(TypeLiteral.get(DefaultAnnotationResolver.class)));    assertTrue(BeanTypeListener.MATCHER.matches(TypeLiteral.get(BlowfishCipherService.class)));}
0
public void testPropertySetting() throws Exception
{    IMocksControl control = createControl();    TypeEncounter<SomeInjectableBean> encounter = control.createMock(TypeEncounter.class);    Provider<Injector> injectorProvider = control.createMock(Provider.class);    Injector injector = control.createMock(Injector.class);    expect(encounter.getProvider(Injector.class)).andReturn(injectorProvider);    expect(injectorProvider.get()).andReturn(injector).anyTimes();    Capture<MembersInjector<SomeInjectableBean>> capture = Capture.newInstance();    encounter.register(and(anyObject(MembersInjector.class), capture(capture)));    SecurityManager securityManager = control.createMock(SecurityManager.class);    String property = "myPropertyValue";    expect(injector.getInstance(Key.get(SecurityManager.class))).andReturn(securityManager);    expect(injector.getInstance(Key.get(String.class, Names.named("shiro.myProperty")))).andReturn(property);    expect(injector.getInstance(Key.get(String.class, Names.named("shiro.unavailableProperty")))).andThrow(new ConfigurationException(Collections.singleton(new Message("Not Available!"))));    expect((Map) injector.getInstance(BeanTypeListener.MAP_KEY)).andReturn(Collections.EMPTY_MAP).anyTimes();    control.replay();    BeanTypeListener underTest = new BeanTypeListener();    underTest.hear(TypeLiteral.get(SomeInjectableBean.class), encounter);    SomeInjectableBean bean = new SomeInjectableBean();    capture.getValue().injectMembers(bean);    assertSame(securityManager, bean.securityManager);    assertSame(property, bean.myProperty);    assertNull(bean.unavailableProperty);    control.verify();}
0
public void setSecurityManager(SecurityManager securityManager)
{    this.securityManager = securityManager;}
0
public void setMyProperty(String myProperty)
{    this.myProperty = myProperty;}
0
public void setUnavailableProperty(String unavailableProperty)
{    this.unavailableProperty = unavailableProperty;}
0
public void testAfterInjection() throws Exception
{    DestroyableInjectionListener.DestroyableRegistry registry = createMock(DestroyableInjectionListener.DestroyableRegistry.class);    Destroyable destroyable = createMock(Destroyable.class);    registry.add(destroyable);    replay(registry, destroyable);    DestroyableInjectionListener underTest = new DestroyableInjectionListener(registry);    underTest.afterInjection(destroyable);    verify(registry, destroyable);}
0
public void testGetSecurityManager() throws Exception
{    SecurityManager securityManager = createMock(SecurityManager.class);    GuiceEnvironment underTest = new GuiceEnvironment(securityManager);    assertSame(securityManager, underTest.getSecurityManager());}
0
public void ensureInjectable()
{    try {        InjectionPoint ip = InjectionPoint.forConstructorOf(GuiceEnvironment.class);    } catch (Exception e) {        fail("Could not create constructor injection point.");    }}
0
public void testAfterInjection() throws Exception
{    Initializable initializable = createMock(Initializable.class);    initializable.init();    replay(initializable);    InitializableInjectionListener underTest = new InitializableInjectionListener();    underTest.afterInjection(initializable);    verify(initializable);}
0
public void testHearInitializable() throws Exception
{    TypeEncounter encounter = createMock(TypeEncounter.class);    encounter.register(anyObject(InitializableInjectionListener.class));    replay(encounter);    LifecycleTypeListener underTest = new LifecycleTypeListener(null);    underTest.hear(TypeLiteral.get(MyInitializable.class), encounter);    verify(encounter);}
0
public void testHearDestroyable() throws Exception
{    TypeEncounter encounter = createMock(TypeEncounter.class);    encounter.register(anyObject(DestroyableInjectionListener.class));    replay(encounter);    LifecycleTypeListener underTest = new LifecycleTypeListener(null);    underTest.hear(TypeLiteral.get(MyDestroyable.class), encounter);    verify(encounter);}
0
public void init() throws ShiroException
{}
0
public void destroy() throws Exception
{}
0
public void testTypeLiteral() throws Exception
{    Matcher<Class> classMatcher = createMock(Matcher.class);    expect(classMatcher.matches(MatchingClass.class)).andReturn(true);    expect(classMatcher.matches(NotMatchingClass.class)).andReturn(false);    replay(classMatcher);    Matcher<TypeLiteral> underTest = ShiroMatchers.typeLiteral(classMatcher);    assertTrue(underTest.matches(TypeLiteral.get(MatchingClass.class)));    assertFalse(underTest.matches(TypeLiteral.get(NotMatchingClass.class)));    verify(classMatcher);}
0
public void basicInstantiation()
{    final MockRealm mockRealm = createMock(MockRealm.class);    Injector injector = Guice.createInjector(new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }    });    SecurityManager securityManager = injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
public void testConfigure()
{    final MockRealm mockRealm = createMock(MockRealm.class);    AuthenticationToken authToken = createMock(AuthenticationToken.class);    AuthenticationInfo info = new SimpleAuthenticationInfo("mockUser", "password", "mockRealm");    expect(mockRealm.supports(authToken)).andReturn(true);    expect(mockRealm.getAuthenticationInfo(authToken)).andReturn(info);    replay(mockRealm);    Injector injector = Guice.createInjector(new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }    });    SecurityManager securityManager = injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);    SecurityUtils.setSecurityManager(securityManager);    final Subject subject = new Subject.Builder(securityManager).buildSubject();    securityManager.login(subject, authToken);    verify(mockRealm);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
public void testBindSecurityManager()
{    final MockRealm mockRealm = createMock(MockRealm.class);    Injector injector = Guice.createInjector(new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }        @Override        protected void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {            bind.to(MyDefaultSecurityManager.class);        }    });    SecurityManager securityManager = injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);    assertTrue(securityManager instanceof MyDefaultSecurityManager);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
protected void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind)
{    bind.to(MyDefaultSecurityManager.class);}
0
public void testBindSessionManager()
{    final MockRealm mockRealm = createMock(MockRealm.class);    Injector injector = Guice.createInjector(new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }        @Override        protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {            bind.to(MyDefaultSessionManager.class);        }    });    DefaultSecurityManager securityManager = (DefaultSecurityManager) injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);    assertNotNull(securityManager.getSessionManager());    assertTrue(securityManager.getSessionManager() instanceof MyDefaultSessionManager);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind)
{    bind.to(MyDefaultSessionManager.class);}
0
public void testBindEnvironment()
{    final MockRealm mockRealm = createMock(MockRealm.class);    Injector injector = Guice.createInjector(new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);            expose(Environment.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }        @Override        protected void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {            bind.to(MyEnvironment.class);        }    });    Environment environment = injector.getInstance(Environment.class);    assertNotNull(environment);    assertTrue(environment instanceof MyEnvironment);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);    expose(Environment.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
protected void bindEnvironment(AnnotatedBindingBuilder<Environment> bind)
{    bind.to(MyEnvironment.class);}
0
public void testDestroy() throws Exception
{    final MockRealm mockRealm = createMock(MockRealm.class);    final MyDestroyable myDestroyable = createMock(MyDestroyable.class);    myDestroyable.destroy();    replay(myDestroyable);    final ShiroModule shiroModule = new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);            bind(MyDestroyable.class).toInstance(myDestroyable);            expose(MyDestroyable.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }    };    Injector injector = Guice.createInjector(shiroModule);    injector.getInstance(MyDestroyable.class);    shiroModule.destroy();    verify(myDestroyable);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);    bind(MyDestroyable.class).toInstance(myDestroyable);    expose(MyDestroyable.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
public void testEventListener() throws Exception
{    final MockRealm mockRealm = createMock(MockRealm.class);    final EventBus eventBus = createMock(EventBus.class);        eventBus.register(anyObject(MockEventListener1.class));    eventBus.register(anyObject(MockEventListener2.class));    replay(eventBus);    final ShiroModule shiroModule = new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);                        binder().bind(MockEventListener1.class).asEagerSingleton();            binder().bind(MockEventListener2.class).asEagerSingleton();        }        @Override        protected void bindEventBus(AnnotatedBindingBuilder<EventBus> bind) {            bind.toInstance(eventBus);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }    };    Guice.createInjector(shiroModule);    verify(eventBus);}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);        binder().bind(MockEventListener1.class).asEagerSingleton();    binder().bind(MockEventListener2.class).asEagerSingleton();}
0
protected void bindEventBus(AnnotatedBindingBuilder<EventBus> bind)
{    bind.toInstance(eventBus);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
public void testEventBusAware() throws Exception
{    final MockRealm mockRealm = createMock(MockRealm.class);    final ShiroModule shiroModule = new ShiroModule() {        @Override        protected void configureShiro() {            bindRealm().to(MockRealm.class);            binder().bind(MockEventBusAware.class).asEagerSingleton();            expose(MockEventBusAware.class);        }        @Provides        public MockRealm createRealm() {            return mockRealm;        }    };    Injector injector = Guice.createInjector(shiroModule);    EventBus eventBus = injector.getInstance(EventBus.class);    SecurityManager securityManager = injector.getInstance(SecurityManager.class);    MockEventBusAware eventBusAware = injector.getInstance(MockEventBusAware.class);    assertSame(eventBus, eventBusAware.eventBus);    assertSame(eventBus, ((DefaultSecurityManager) securityManager).getEventBus());}
0
protected void configureShiro()
{    bindRealm().to(MockRealm.class);    binder().bind(MockEventBusAware.class).asEagerSingleton();    expose(MockEventBusAware.class);}
0
public MockRealm createRealm()
{    return mockRealm;}
0
public void listenToAllAndDoNothing(Object o)
{}
0
public void listenToAllAndDoNothing(Object o)
{}
0
public EventBus getEventBus()
{    return eventBus;}
0
public void setEventBus(EventBus eventBus)
{    this.eventBus = eventBus;}
0
public void testScope() throws Exception
{    Subject subject = createMock(Subject.class);    try {        ThreadContext.bind(subject);        final Key<SomeClass> key = Key.get(SomeClass.class);        Provider<SomeClass> mockProvider = createMock(Provider.class);        Session session = createMock(Session.class);        SomeClass retuned = new SomeClass();        expect(subject.getSession()).andReturn(session);        expect(session.getAttribute(key)).andReturn(null);        expect(mockProvider.get()).andReturn(retuned);        expect(subject.getSession()).andReturn(session);        expect(session.getAttribute(key)).andReturn(retuned);        replay(subject, mockProvider, session);        ShiroSessionScope underTest = new ShiroSessionScope();                assertSame(retuned, underTest.scope(key, mockProvider).get());                assertSame(retuned, underTest.scope(key, mockProvider).get());        verify(subject, mockProvider, session);    } finally {        ThreadContext.unbindSubject();    }}
0
public void testOutOfScope() throws Exception
{    ShiroSessionScope underTest = new ShiroSessionScope();    Provider<SomeClass> mockProvider = createMock(Provider.class);    replay(mockProvider);    underTest.scope(Key.get(SomeClass.class), mockProvider).get();}
0
public void testGet() throws Exception
{    Injector mockInjector = createMock(Injector.class);    Object c1 = new Object();    Object c2 = new Object();    final AtomicBoolean postProcessCalled = new AtomicBoolean(false);    expect(mockInjector.getInstance(keyC1)).andReturn(c1);    expect(mockInjector.getInstance(keyC2)).andReturn(c2);    mockInjector.injectMembers(anyObject(SomeInjectedClass.class));    replay(mockInjector);    AbstractInjectionProvider<SomeInjectedClass> underTest = new AbstractInjectionProvider<SomeInjectedClass>(Key.get(SomeInjectedClass.class)) {        @Override        protected SomeInjectedClass postProcess(SomeInjectedClass someInjectedClass) {            postProcessCalled.set(true);            return super.postProcess(someInjectedClass);        }    };    underTest.injector = mockInjector;    SomeInjectedClass got = underTest.get();    assertEquals("Wrong parameter passed to constructor (index 0).", c1, got.c1);    assertEquals("Wrong parameter passed to constructor (index 1).", c2, got.c2);    assertTrue("postProcess method was not called.", postProcessCalled.get());    verify(mockInjector);}
0
protected SomeInjectedClass postProcess(SomeInjectedClass someInjectedClass)
{    postProcessCalled.set(true);    return super.postProcess(someInjectedClass);}
0
public void testGetDependencies() throws Exception
{    AbstractInjectionProvider<SomeInjectedClass> underTest = new AbstractInjectionProvider<SomeInjectedClass>(Key.get(SomeInjectedClass.class));    boolean foundC1 = false;    boolean foundC2 = false;    boolean foundV1 = false;    boolean foundV2 = false;    boolean foundF1 = false;    for (Dependency<?> dependency : underTest.getDependencies()) {        if (dependency.getInjectionPoint().getMember() instanceof Constructor) {            if (dependency.getParameterIndex() == 0 && dependency.getKey().equals(keyC1)) {                foundC1 = true;            } else if (dependency.getParameterIndex() == 1 && dependency.getKey().equals(keyC2)) {                foundC2 = true;            } else {                fail("Did not expect constructor dependency with key " + dependency.getKey() + " at parameter index " + dependency.getParameterIndex());            }        } else if (dependency.getInjectionPoint().getMember() instanceof Method) {            if (dependency.getKey().equals(keyV1)) {                foundV1 = true;            } else if (dependency.getKey().equals(keyV2)) {                foundV2 = true;            } else {                fail("Did not expect method dependency with key " + dependency.getKey());            }        } else if (dependency.getInjectionPoint().getMember() instanceof Field) {            if (dependency.getKey().equals(keyF1)) {                foundF1 = true;            } else {                fail("Did not expect field dependency with key " + dependency.getKey());            }        } else {            fail("Did not expect dependency with key " + dependency.getKey());        }    }    assertTrue("Did not find dependency C1", foundC1);    assertTrue("Did not find dependency C2", foundC2);    assertTrue("Did not find dependency V1", foundV1);    assertTrue("Did not find dependency V2", foundV2);    assertTrue("Did not find dependency F1", foundF1);}
0
public void setVal1(@Named("val1") Object v1)
{}
0
public void setVal2(@Named("val2") Object v2)
{}
0
public void checkDefaultFilters() throws Exception
{    EnumSet<DefaultFilter> defaultFilters = EnumSet.allOf(DefaultFilter.class);    for (Field field : ShiroWebModule.class.getFields()) {        if (Modifier.isStatic(field.getModifiers()) && Key.class.isAssignableFrom(field.getType())) {            Class<? extends Filter> filterType = ((Key) field.get(null)).getTypeLiteral().getRawType();            boolean found = false;            for (DefaultFilter filter : defaultFilters) {                if (filterType.equals(filter.getFilterClass())) {                    found = true;                    defaultFilters.remove(filter);                    break;                }            }            if (!found) {                fail("Guice ShiroWebModule containts a default filter that Shiro proper does not. (" + filterType.getName() + ")");            }        }    }    if (!defaultFilters.isEmpty()) {        fail("Guice ShiroWebModule is missing one or more filters. " + defaultFilters);    }}
0
public void setup()
{    chains = new LinkedHashMap<String, Key<? extends Filter>[]>();    key1a = Key.get(Filter.class, Names.named("key1a"));    key1b = Key.get(Filter.class, Names.named("key1b"));    key1c = Key.get(Filter.class, Names.named("key1c"));    key2a = Key.get(Filter.class, Names.named("key2a"));    chains.put("one", new Key[] { key1a, key1b, key1c });    chains.put("two", new Key[] { key2a });    underTest = new FilterChainResolverProvider(chains);}
0
public void testGetDependencies() throws Exception
{    Set<Dependency<?>> dependencySet = underTest.getDependencies();    assertEquals(4, dependencySet.size());    assertTrue("Dependency set doesn't contain key1a.", dependencySet.contains(Dependency.get(key1a)));    assertTrue("Dependency set doesn't contain key1b.", dependencySet.contains(Dependency.get(key1b)));    assertTrue("Dependency set doesn't contain key1c.", dependencySet.contains(Dependency.get(key1c)));    assertTrue("Dependency set doesn't contain key2a.", dependencySet.contains(Dependency.get(key2a)));}
0
public void testGet() throws Exception
{    Injector injector = createMock(Injector.class);    PatternMatcher patternMatcher = createMock(PatternMatcher.class);    underTest.injector = injector;    underTest.setPatternMatcher(patternMatcher);    FilterChainResolver resolver = underTest.get();    Field chainsField = SimpleFilterChainResolver.class.getDeclaredField("chains");    chainsField.setAccessible(true);    Field injectorField = SimpleFilterChainResolver.class.getDeclaredField("injector");    injectorField.setAccessible(true);    Field patternMatcherField = SimpleFilterChainResolver.class.getDeclaredField("patternMatcher");    patternMatcherField.setAccessible(true);    assertSame(chains, chainsField.get(resolver));    assertSame(injector, injectorField.get(resolver));    assertSame(patternMatcher, patternMatcherField.get(resolver));}
0
private FilterChainResolver setupResolver()
{    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            addFilterChain("/index.html", AUTHC_BASIC);                        addFilterChain("/index2.html", filterConfig(PERMS, "permission"));        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }    });    GuiceShiroFilter filter = injector.getInstance(GuiceShiroFilter.class);    return filter.getFilterChainResolver();}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    addFilterChain("/index.html", AUTHC_BASIC);        addFilterChain("/index2.html", filterConfig(PERMS, "permission"));}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
public void testSimple() throws Exception
{    FilterChainResolver resolver = setupResolver();    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);    HttpServletRequest request = createMockRequest("/index.html");    FilterChain resolved = resolver.getChain(request, response, chain);    assertNotNull(resolved);    verify(request);}
0
public void testWithConfig() throws Exception
{    FilterChainResolver resolver = setupResolver();    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);    HttpServletRequest request = createMockRequest("/index2.html");    FilterChain resolved = resolver.getChain(request, response, chain);    assertNotNull(resolved);    verify(request);}
0
private HttpServletRequest createMockRequest(String path)
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();    expect(request.getContextPath()).andReturn("");    expect(request.getRequestURI()).andReturn(path);    replay(request);    return request;}
0
public void ensureInjectable()
{    try {        InjectionPoint ip = InjectionPoint.forConstructorOf(GuiceShiroFilter.class);    } catch (Exception e) {        fail("Could not create constructor injection point.");    }}
0
public void testConstructor()
{    WebSecurityManager securityManager = createMock(WebSecurityManager.class);    FilterChainResolver filterChainResolver = createMock(FilterChainResolver.class);    GuiceShiroFilter underTest = new GuiceShiroFilter(securityManager, filterChainResolver);    assertSame(securityManager, underTest.getSecurityManager());    assertSame(filterChainResolver, underTest.getFilterChainResolver());}
0
public void testPostProcess()
{    PathMatchingFilter filter = createMock(PathMatchingFilter.class);    expect(filter.processPathConfig("/1", "first")).andReturn(filter);    expect(filter.processPathConfig("/2", "second")).andReturn(filter);    replay(filter);    Map<String, String> pathConfigMap = new HashMap<String, String>();    pathConfigMap.put("/1", "first");    pathConfigMap.put("/2", "second");    PathMatchingFilterProvider underTest = new PathMatchingFilterProvider(Key.get(PathMatchingFilter.class), pathConfigMap);    underTest.postProcess(filter);    verify(filter);}
0
public void basicInstantiation()
{    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            expose(SessionManager.class);        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }    });            SecurityManager securityManager = injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);    assertTrue(securityManager instanceof WebSecurityManager);    SessionManager sessionManager = injector.getInstance(SessionManager.class);    assertNotNull(sessionManager);    assertTrue(sessionManager instanceof ServletContainerSessionManager);    assertTrue(((DefaultWebSecurityManager) securityManager).getSessionManager() instanceof ServletContainerSessionManager);}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    expose(SessionManager.class);}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
public void testBindGuiceFilter() throws Exception
{}
0
public void testBindWebSecurityManager() throws Exception
{    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            expose(WebSecurityManager.class);        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }        @Override        protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind) {            bind.to(MyDefaultWebSecurityManager.class).asEagerSingleton();        }    });    SecurityManager securityManager = injector.getInstance(SecurityManager.class);    assertNotNull(securityManager);    assertTrue(securityManager instanceof MyDefaultWebSecurityManager);    WebSecurityManager webSecurityManager = injector.getInstance(WebSecurityManager.class);    assertNotNull(webSecurityManager);    assertTrue(webSecurityManager instanceof MyDefaultWebSecurityManager);        assertTrue(securityManager == webSecurityManager);}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    expose(WebSecurityManager.class);}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurityManager> bind)
{    bind.to(MyDefaultWebSecurityManager.class).asEagerSingleton();}
0
public void testBindWebEnvironment() throws Exception
{    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            expose(WebEnvironment.class);            expose(Environment.class);        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }        @Override        protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {            bind.to(MyWebEnvironment.class).asEagerSingleton();        }    });    Environment environment = injector.getInstance(Environment.class);    assertNotNull(environment);    assertTrue(environment instanceof MyWebEnvironment);    WebEnvironment webEnvironment = injector.getInstance(WebEnvironment.class);    assertNotNull(webEnvironment);    assertTrue(webEnvironment instanceof MyWebEnvironment);        assertTrue(environment == webEnvironment);}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    expose(WebEnvironment.class);    expose(Environment.class);}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind)
{    bind.to(MyWebEnvironment.class).asEagerSingleton();}
0
public void testAddFilterChainGuice3and4()
{    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    HttpServletRequest request = createMock(HttpServletRequest.class);    servletContext.setAttribute(eq(EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY), EasyMock.anyObject());    expect(request.getAttribute("javax.servlet.include.context_path")).andReturn("").anyTimes();    expect(request.getCharacterEncoding()).andReturn("UTF-8").anyTimes();    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_authc");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_custom_filter");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_authc_basic");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_perms");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/multiple_configs");    replay(servletContext, request);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            expose(FilterChainResolver.class);            this.addFilterChain("/test_authc/**", filterConfig(AUTHC));            this.addFilterChain("/test_custom_filter/**", Key.get(CustomFilter.class));            this.addFilterChain("/test_authc_basic/**", AUTHC_BASIC);            this.addFilterChain("/test_perms/**", filterConfig(PERMS, "remote:invoke:lan,wan"));            this.addFilterChain("/multiple_configs/**", filterConfig(AUTHC), filterConfig(ROLES, "b2bClient"), filterConfig(PERMS, "remote:invoke:lan,wan"));        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }    });    FilterChainResolver resolver = injector.getInstance(FilterChainResolver.class);    assertThat(resolver, instanceOf(SimpleFilterChainResolver.class));    SimpleFilterChainResolver simpleFilterChainResolver = (SimpleFilterChainResolver) resolver;        FilterChain filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    Filter nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(FormAuthenticationFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(CustomFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(BasicHttpAuthenticationFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(PermissionsAuthorizationFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(FormAuthenticationFilter.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(RolesAuthorizationFilter.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(PermissionsAuthorizationFilter.class));    verify(servletContext, request);}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    expose(FilterChainResolver.class);    this.addFilterChain("/test_authc/**", filterConfig(AUTHC));    this.addFilterChain("/test_custom_filter/**", Key.get(CustomFilter.class));    this.addFilterChain("/test_authc_basic/**", AUTHC_BASIC);    this.addFilterChain("/test_perms/**", filterConfig(PERMS, "remote:invoke:lan,wan"));    this.addFilterChain("/multiple_configs/**", filterConfig(AUTHC), filterConfig(ROLES, "b2bClient"), filterConfig(PERMS, "remote:invoke:lan,wan"));}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
public void testAddFilterChainGuice3Only()
{    Assume.assumeTrue("This test only runs agains Guice 3.x", ShiroWebModule.isGuiceVersion3());    final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);    ServletContext servletContext = createMock(ServletContext.class);    HttpServletRequest request = createMock(HttpServletRequest.class);    servletContext.setAttribute(eq(EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY), EasyMock.anyObject());    expect(request.getAttribute("javax.servlet.include.context_path")).andReturn("").anyTimes();    expect(request.getCharacterEncoding()).andReturn("UTF-8").anyTimes();    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_authc");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_custom_filter");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/test_perms");    expect(request.getAttribute("javax.servlet.include.request_uri")).andReturn("/multiple_configs");    replay(servletContext, request);    Injector injector = Guice.createInjector(new ShiroWebModule(servletContext) {        @Override        protected void configureShiroWeb() {            bindRealm().to(ShiroModuleTest.MockRealm.class);            expose(FilterChainResolver.class);            this.addFilterChain("/test_authc/**", AUTHC);            this.addFilterChain("/test_custom_filter/**", Key.get(CustomFilter.class));            this.addFilterChain("/test_perms/**", config(PERMS, "remote:invoke:lan,wan"));            this.addFilterChain("/multiple_configs/**", AUTHC, config(ROLES, "b2bClient"), config(PERMS, "remote:invoke:lan,wan"));        }        @Provides        public ShiroModuleTest.MockRealm createRealm() {            return mockRealm;        }    });    FilterChainResolver resolver = injector.getInstance(FilterChainResolver.class);    assertThat(resolver, instanceOf(SimpleFilterChainResolver.class));    SimpleFilterChainResolver simpleFilterChainResolver = (SimpleFilterChainResolver) resolver;        FilterChain filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    Filter nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(FormAuthenticationFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(CustomFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    nextFilter = getNextFilter((SimpleFilterChain) filterChain);    assertThat(nextFilter, instanceOf(PermissionsAuthorizationFilter.class));        filterChain = simpleFilterChainResolver.getChain(request, null, null);    assertThat(filterChain, instanceOf(SimpleFilterChain.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(FormAuthenticationFilter.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(RolesAuthorizationFilter.class));    assertThat(getNextFilter((SimpleFilterChain) filterChain), instanceOf(PermissionsAuthorizationFilter.class));    verify(servletContext, request);}
0
protected void configureShiroWeb()
{    bindRealm().to(ShiroModuleTest.MockRealm.class);    expose(FilterChainResolver.class);    this.addFilterChain("/test_authc/**", AUTHC);    this.addFilterChain("/test_custom_filter/**", Key.get(CustomFilter.class));    this.addFilterChain("/test_perms/**", config(PERMS, "remote:invoke:lan,wan"));    this.addFilterChain("/multiple_configs/**", AUTHC, config(ROLES, "b2bClient"), config(PERMS, "remote:invoke:lan,wan"));}
0
public ShiroModuleTest.MockRealm createRealm()
{    return mockRealm;}
0
private Filter getNextFilter(SimpleFilterChain filterChain)
{    Iterator<? extends Filter> filters = filterChain.getFilters();    if (filters.hasNext()) {        return filters.next();    }    return null;}
0
public void init(FilterConfig filterConfig) throws ServletException
{}
0
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException
{}
0
public void destroy()
{}
0
public void testGetChain() throws Exception
{                        IMocksControl ctrl = createStrictControl();    Injector injector = ctrl.createMock(Injector.class);    Map<String, Key<? extends Filter>[]> chainMap = new LinkedHashMap<String, Key<? extends Filter>[]>();    final String chainOne = "one";    final String chainTwo = "two";    final String chainThree = "three";    final Key<? extends Filter> key1a = Key.get(Filter.class, Names.named("key1a"));    final Key<? extends Filter> key1b = Key.get(Filter.class, Names.named("key1b"));    final Key<? extends Filter> key2a = Key.get(Filter.class, Names.named("key2a"));    final Key<? extends Filter> key2b = Key.get(Filter.class, Names.named("key2b"));    final Key<? extends Filter> key3a = Key.get(Filter.class, Names.named("key3a"));    final Key<? extends Filter> key3b = Key.get(Filter.class, Names.named("key3b"));    chainMap.put(chainOne, new Key[] { key1a, key1b });    chainMap.put(chainTwo, new Key[] { key2a, key2b });    chainMap.put(chainThree, new Key[] { key3a, key3b });    PatternMatcher patternMatcher = ctrl.createMock(PatternMatcher.class);    ServletRequest request = ctrl.createMock(HttpServletRequest.class);    ServletResponse response = ctrl.createMock(HttpServletResponse.class);    FilterChain originalChain = ctrl.createMock(FilterChain.class);    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn("/context");    expect(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).andReturn("/mychain");    expect(request.getCharacterEncoding()).andStubReturn(null);    expect(patternMatcher.matches(chainOne, "/mychain")).andReturn(false);    expect(patternMatcher.matches(chainTwo, "/mychain")).andReturn(true);    Filter filter2a = ctrl.createMock(Filter.class);    Filter filter2b = ctrl.createMock(Filter.class);    expect((Filter) injector.getInstance(key2a)).andReturn(filter2a);    filter2a.doFilter(same(request), same(response), anyObject(FilterChain.class));    expect((Filter) injector.getInstance(key2b)).andReturn(filter2b);    filter2b.doFilter(same(request), same(response), anyObject(FilterChain.class));    originalChain.doFilter(request, response);    ctrl.replay();    SimpleFilterChainResolver underTest = new SimpleFilterChainResolver(chainMap, injector, patternMatcher);    FilterChain got = underTest.getChain(request, response, originalChain);    got.doFilter(request, response);    got.doFilter(request, response);    got.doFilter(request, response);    ctrl.verify();    ctrl.reset();    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn("/context");    expect(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).andReturn("/nochain");    expect(request.getCharacterEncoding()).andStubReturn(null);    expect(patternMatcher.matches(chainOne, "/nochain")).andReturn(false);    expect(patternMatcher.matches(chainTwo, "/nochain")).andReturn(false);    expect(patternMatcher.matches(chainThree, "/nochain")).andReturn(false);    ctrl.replay();    assertNull("Expected no chain to match, did not get a null value in return.", underTest.getChain(request, response, originalChain));    ctrl.verify();}
0
public void testDoFilter() throws Exception
{    IMocksControl ctrl = createStrictControl();    FilterChain originalChain = ctrl.createMock(FilterChain.class);    Filter filter1 = ctrl.createMock("filter1", Filter.class);    Filter filter2 = ctrl.createMock("filter2", Filter.class);    ServletRequest request = ctrl.createMock(ServletRequest.class);    ServletResponse response = ctrl.createMock(ServletResponse.class);    Capture<FilterChain> fc1 = Capture.newInstance();    Capture<FilterChain> fc2 = Capture.newInstance();    filter1.doFilter(same(request), same(response), and(anyObject(FilterChain.class), capture(fc1)));    filter2.doFilter(same(request), same(response), and(anyObject(FilterChain.class), capture(fc2)));    originalChain.doFilter(request, response);    ctrl.replay();    SimpleFilterChain underTest = new SimpleFilterChain(originalChain, Arrays.asList(filter1, filter2).iterator());            underTest.doFilter(request, response);    fc1.getValue().doFilter(request, response);    fc2.getValue().doFilter(request, response);    ctrl.verify();}
0
public void ensureInjectable()
{    try {        InjectionPoint ip = InjectionPoint.forConstructorOf(WebGuiceEnvironment.class);    } catch (Exception e) {        fail("Could not create constructor injection point.");    }}
0
public void testConstructor()
{    WebSecurityManager securityManager = createMock(WebSecurityManager.class);    FilterChainResolver filterChainResolver = createMock(FilterChainResolver.class);    ServletContext servletContext = createMock(ServletContext.class);    Capture<WebGuiceEnvironment> capture = Capture.newInstance();    servletContext.setAttribute(eq(EnvironmentLoaderListener.ENVIRONMENT_ATTRIBUTE_KEY), and(anyObject(WebGuiceEnvironment.class), capture(capture)));    replay(servletContext, securityManager, filterChainResolver);    WebGuiceEnvironment underTest = new WebGuiceEnvironment(filterChainResolver, servletContext, securityManager);    assertSame(securityManager, underTest.getSecurityManager());    assertSame(filterChainResolver, underTest.getFilterChainResolver());    assertSame(securityManager, underTest.getWebSecurityManager());    assertSame(servletContext, underTest.getServletContext());    assertSame(underTest, capture.getValue());    verify(servletContext);}
0
public Cache<K, V> getCache(String name) throws CacheException
{        Map<K, V> map = ensureHazelcastInstance().getMap(name);    return new MapCache<K, V>(name, map);}
0
protected HazelcastInstance ensureHazelcastInstance()
{    if (this.hazelcastInstance == null) {        this.hazelcastInstance = createHazelcastInstance();        this.implicitlyCreated = true;    }    return this.hazelcastInstance;}
0
public void init() throws ShiroException
{    ensureHazelcastInstance();}
0
protected HazelcastInstance createHazelcastInstance()
{    return Hazelcast.newHazelcastInstance(this.config);}
0
protected final boolean isImplicitlyCreated()
{    return this.implicitlyCreated;}
0
public void destroy() throws Exception
{    if (this.implicitlyCreated) {        try {            this.hazelcastInstance.getLifecycleService().shutdown();        } catch (Throwable t) {            if (log.isWarnEnabled()) {                            }        } finally {            this.hazelcastInstance = null;            this.implicitlyCreated = false;        }    }}
1
public HazelcastInstance getHazelcastInstance()
{    return hazelcastInstance;}
0
public void setHazelcastInstance(HazelcastInstance hazelcastInstance)
{    this.hazelcastInstance = hazelcastInstance;}
0
public Config getConfig()
{    return config;}
0
public void setConfig(Config config)
{    this.config = config;}
0
private static AuthorizingAnnotationHandler createHandler(Annotation annotation)
{    Class<?> t = annotation.annotationType();    if (RequiresPermissions.class.equals(t))        return new PermissionAnnotationHandler();    else if (RequiresRoles.class.equals(t))        return new RoleAnnotationHandler();    else if (RequiresUser.class.equals(t))        return new UserAnnotationHandler();    else if (RequiresGuest.class.equals(t))        return new GuestAnnotationHandler();    else if (RequiresAuthentication.class.equals(t))        return new AuthenticatedAnnotationHandler();    else        throw new IllegalArgumentException("Cannot create a handler for the unknown for annotation " + t);}
0
public void filter(ContainerRequestContext requestContext) throws IOException
{    for (Map.Entry<AuthorizingAnnotationHandler, Annotation> authzCheck : authzChecks.entrySet()) {        AuthorizingAnnotationHandler handler = authzCheck.getKey();        Annotation authzSpec = authzCheck.getValue();        handler.assertAuthorized(authzSpec);    }}
0
public Response toResponse(AuthorizationException exception)
{    Status status;    if (exception instanceof UnauthorizedException) {        status = Status.FORBIDDEN;    } else {        status = Status.UNAUTHORIZED;    }    return Response.status(status).build();}
0
public void configure(ResourceInfo resourceInfo, FeatureContext context)
{    List<Annotation> authzSpecs = new ArrayList<Annotation>();    for (Class<? extends Annotation> annotationClass : shiroAnnotations) {                Annotation classAuthzSpec = resourceInfo.getResourceClass().getAnnotation(annotationClass);        Annotation methodAuthzSpec = resourceInfo.getResourceMethod().getAnnotation(annotationClass);        if (classAuthzSpec != null)            authzSpecs.add(classAuthzSpec);        if (methodAuthzSpec != null)            authzSpecs.add(methodAuthzSpec);    }    if (!authzSpecs.isEmpty()) {        context.register(new AnnotationAuthorizationFilter(authzSpecs), Priorities.AUTHORIZATION);    }}
0
public boolean configure(FeatureContext context)
{    context.register(ExceptionMapper.class);    context.register(SubjectPrincipalRequestFilter.class);    context.register(ShiroAnnotationFilterFeature.class);    return true;}
0
public Principal getUserPrincipal()
{    Principal result;    Subject subject = getSubject();    PrincipalCollection shiroPrincipals = subject.getPrincipals();    if (shiroPrincipals != null) {        result = shiroPrincipals.oneByType(Principal.class);        if (result == null) {            result = new ObjectPrincipal(shiroPrincipals.getPrimaryPrincipal());        }    } else {        result = originalSecurityContext.getUserPrincipal();    }    return result;}
0
public boolean isUserInRole(String role)
{    return getSubject().hasRole(role);}
0
public boolean isSecure()
{    return containerRequestContext.getSecurityContext().isSecure();}
0
public String getAuthenticationScheme()
{    return containerRequestContext.getSecurityContext().getAuthenticationScheme();}
0
private Subject getSubject()
{    return SecurityUtils.getSubject();}
0
public Object getObject()
{    return object;}
0
public String getName()
{    return getObject().toString();}
0
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ObjectPrincipal that = (ObjectPrincipal) o;    return object.equals(that.object);}
0
public int hashCode()
{    return object.hashCode();}
0
public String toString()
{    return object.toString();}
0
public void filter(ContainerRequestContext requestContext) throws IOException
{    requestContext.setSecurityContext(new ShiroSecurityContext(requestContext));}
0
public void execute(JobExecutionContext context) throws JobExecutionException
{    JobDataMap jobDataMap = context.getMergedJobDataMap();    ValidatingSessionManager sessionManager = (ValidatingSessionManager) jobDataMap.get(SESSION_MANAGER_KEY);    if (log.isDebugEnabled()) {            }    sessionManager.validateSessions();    if (log.isDebugEnabled()) {            }}
1
protected Scheduler getScheduler() throws SchedulerException
{    if (scheduler == null) {        scheduler = StdSchedulerFactory.getDefaultScheduler();        schedulerImplicitlyCreated = true;    }    return scheduler;}
0
public void setScheduler(Scheduler scheduler)
{    this.scheduler = scheduler;}
0
public void setSessionManager(ValidatingSessionManager sessionManager)
{    this.sessionManager = sessionManager;}
0
public boolean isEnabled()
{    return this.enabled;}
0
public void setSessionValidationInterval(long sessionValidationInterval)
{    this.sessionValidationInterval = sessionValidationInterval;}
0
public void enableSessionValidation()
{    if (log.isDebugEnabled()) {            }    try {        SimpleTrigger trigger = new SimpleTrigger(getClass().getName(), Scheduler.DEFAULT_GROUP, SimpleTrigger.REPEAT_INDEFINITELY, sessionValidationInterval);        JobDetail detail = new JobDetail(JOB_NAME, Scheduler.DEFAULT_GROUP, QuartzSessionValidationJob.class);        detail.getJobDataMap().put(QuartzSessionValidationJob.SESSION_MANAGER_KEY, sessionManager);        Scheduler scheduler = getScheduler();        scheduler.scheduleJob(detail, trigger);        if (schedulerImplicitlyCreated) {            scheduler.start();            if (log.isDebugEnabled()) {                            }        }        this.enabled = true;        if (log.isDebugEnabled()) {                    }    } catch (SchedulerException e) {        if (log.isErrorEnabled()) {                    }    }}
1
public void disableSessionValidation()
{    if (log.isDebugEnabled()) {            }    Scheduler scheduler;    try {        scheduler = getScheduler();        if (scheduler == null) {            if (log.isWarnEnabled()) {                            }            return;        }    } catch (SchedulerException e) {        if (log.isWarnEnabled()) {                    }        return;    }    try {        scheduler.unscheduleJob(JOB_NAME, Scheduler.DEFAULT_GROUP);        if (log.isDebugEnabled()) {                    }    } catch (SchedulerException e) {        if (log.isDebugEnabled()) {                    }    }    this.enabled = false;    if (schedulerImplicitlyCreated) {        try {            scheduler.shutdown();        } catch (SchedulerException e) {            if (log.isWarnEnabled()) {                            }        } finally {            setScheduler(null);            schedulerImplicitlyCreated = false;        }    }}
1
public Annotation getAnnotation(MethodInvocation mi, Class<? extends Annotation> clazz)
{    Method m = mi.getMethod();    Annotation a = AnnotationUtils.findAnnotation(m, clazz);    if (a != null)        return a;                        Class<?> targetClass = mi.getThis().getClass();    m = ClassUtils.getMostSpecificMethod(m, targetClass);    a = AnnotationUtils.findAnnotation(m, clazz);    if (a != null)        return a;        return AnnotationUtils.findAnnotation(mi.getThis().getClass(), clazz);}
0
protected DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator()
{    return new DefaultAdvisorAutoProxyCreator();}
0
protected AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)
{    AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();    advisor.setSecurityManager(securityManager);    return advisor;}
0
protected LifecycleBeanPostProcessor lifecycleBeanPostProcessor()
{    return new LifecycleBeanPostProcessor();}
0
protected EventBus eventBus()
{    return new DefaultEventBus();}
0
protected ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor()
{    return new ShiroEventBusBeanPostProcessor(eventBus());}
0
protected SessionsSecurityManager securityManager(List<Realm> realms)
{    SessionsSecurityManager securityManager = createSecurityManager();    securityManager.setAuthenticator(authenticator());    securityManager.setAuthorizer(authorizer());    securityManager.setRealms(realms);    securityManager.setSessionManager(sessionManager());    securityManager.setEventBus(eventBus);    if (cacheManager != null) {        securityManager.setCacheManager(cacheManager);    }    return securityManager;}
0
protected SessionManager sessionManager()
{    DefaultSessionManager sessionManager = new DefaultSessionManager();    sessionManager.setSessionDAO(sessionDAO());    sessionManager.setSessionFactory(sessionFactory());    sessionManager.setDeleteInvalidSessions(sessionManagerDeleteInvalidSessions);    return sessionManager;}
0
protected SessionsSecurityManager createSecurityManager()
{    DefaultSecurityManager securityManager = new DefaultSecurityManager();    securityManager.setSubjectDAO(subjectDAO());    securityManager.setSubjectFactory(subjectFactory());    RememberMeManager rememberMeManager = rememberMeManager();    if (rememberMeManager != null) {        securityManager.setRememberMeManager(rememberMeManager);    }    return securityManager;}
0
protected RememberMeManager rememberMeManager()
{    return null;}
0
protected SubjectDAO subjectDAO()
{    DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();    subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator());    return subjectDAO;}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return new DefaultSessionStorageEvaluator();}
0
protected SubjectFactory subjectFactory()
{    return new DefaultSubjectFactory();}
0
protected SessionFactory sessionFactory()
{    return new SimpleSessionFactory();}
0
protected SessionDAO sessionDAO()
{    return new MemorySessionDAO();}
0
protected Authorizer authorizer()
{    ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();    if (permissionResolver != null) {        authorizer.setPermissionResolver(permissionResolver);    }    if (rolePermissionResolver != null) {        authorizer.setRolePermissionResolver(rolePermissionResolver);    }    return authorizer;}
0
protected AuthenticationStrategy authenticationStrategy()
{    return new AtLeastOneSuccessfulStrategy();}
0
protected Authenticator authenticator()
{    ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();    authenticator.setAuthenticationStrategy(authenticationStrategy());    return authenticator;}
0
protected Realm iniRealmFromLocation(String iniLocation)
{    Ini ini = Ini.fromResourcePath(iniLocation);    return new IniRealm(ini);}
0
protected DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator()
{    return super.defaultAdvisorAutoProxyCreator();}
0
protected AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)
{    return super.authorizationAttributeSourceAdvisor(securityManager);}
0
public LifecycleBeanPostProcessor lifecycleBeanPostProcessor()
{    return super.lifecycleBeanPostProcessor();}
0
protected EventBus eventBus()
{    return super.eventBus();}
0
public ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor()
{    return super.shiroEventBusAwareBeanPostProcessor();}
0
protected SessionsSecurityManager securityManager(List<Realm> realms)
{    return super.securityManager(realms);}
0
protected SessionManager sessionManager()
{    return super.sessionManager();}
0
protected SubjectDAO subjectDAO()
{    return super.subjectDAO();}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return super.sessionStorageEvaluator();}
0
protected SubjectFactory subjectFactory()
{    return super.subjectFactory();}
0
protected SessionFactory sessionFactory()
{    return super.sessionFactory();}
0
protected SessionDAO sessionDAO()
{    return super.sessionDAO();}
0
protected Authorizer authorizer()
{    return super.authorizer();}
0
protected AuthenticationStrategy authenticationStrategy()
{    return super.authenticationStrategy();}
0
protected Authenticator authenticator()
{    return super.authenticator();}
0
protected RememberMeManager rememberMeManager()
{    return super.rememberMeManager();}
0
public Object postProcessBeforeInitialization(Object object, String name) throws BeansException
{    if (object instanceof Initializable) {        try {            if (log.isDebugEnabled()) {                            }            ((Initializable) object).init();        } catch (Exception e) {            throw new FatalBeanException("Error initializing bean [" + name + "]", e);        }    }    return object;}
1
public Object postProcessAfterInitialization(Object object, String name) throws BeansException
{        return object;}
0
public void postProcessBeforeDestruction(Object object, String name) throws BeansException
{    if (object instanceof Destroyable) {        try {            if (log.isDebugEnabled()) {                            }            ((Destroyable) object).destroy();        } catch (Exception e) {            throw new FatalBeanException("Error destroying bean [" + name + "]", e);        }    }}
1
public int getOrder()
{        return order;}
0
public boolean requiresDestruction(Object bean)
{    return (bean instanceof Destroyable);}
0
public void setSecurityManager(org.apache.shiro.mgt.SecurityManager securityManager)
{    this.securityManager = securityManager;}
0
public Object invoke(final RemoteInvocation invocation, final Object targetObject) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    try {        SecurityManager securityManager = this.securityManager != null ? this.securityManager : SecurityUtils.getSecurityManager();        Subject.Builder builder = new Subject.Builder(securityManager);        String host = (String) invocation.getAttribute(SecureRemoteInvocationFactory.HOST_KEY);        if (host != null) {            builder.host(host);        }        Serializable sessionId = invocation.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY);        if (sessionId != null) {            builder.sessionId(sessionId);        } else {            if (log.isTraceEnabled()) {                log.trace("RemoteInvocation did not contain a Shiro Session id attribute under " + "key [" + SecureRemoteInvocationFactory.SESSION_ID_KEY + "].  A Subject based " + "on an existing Session will not be available during the method invocation.");            }        }        Subject subject = builder.buildSubject();        return subject.execute(new Callable() {            public Object call() throws Exception {                return SecureRemoteInvocationExecutor.super.invoke(invocation, targetObject);            }        });    } catch (ExecutionException e) {        Throwable cause = e.getCause();        if (cause instanceof NoSuchMethodException) {            throw (NoSuchMethodException) cause;        } else if (cause instanceof IllegalAccessException) {            throw (IllegalAccessException) cause;        } else if (cause instanceof InvocationTargetException) {            throw (InvocationTargetException) cause;        } else {            throw new InvocationTargetException(cause);        }    } catch (Throwable t) {        throw new InvocationTargetException(t);    }}
0
public Object call() throws Exception
{    return SecureRemoteInvocationExecutor.super.invoke(invocation, targetObject);}
0
public RemoteInvocation createRemoteInvocation(MethodInvocation mi)
{    Serializable sessionId = null;    String host = null;    boolean sessionManagerMethodInvocation = false;            Class miDeclaringClass = mi.getMethod().getDeclaringClass();    if (SessionManager.class.equals(miDeclaringClass) || NativeSessionManager.class.equals(miDeclaringClass)) {        sessionManagerMethodInvocation = true;                if (!mi.getMethod().getName().equals("start")) {            SessionKey key = (SessionKey) mi.getArguments()[0];            sessionId = key.getSessionId();        }    }        if (sessionId == null)        sessionId = this.sessionId;        if (sessionId == null) {        try {                        SecurityUtils.getSecurityManager();            if (!sessionManagerMethodInvocation) {                Subject subject = SecurityUtils.getSubject();                Session session = subject.getSession(false);                if (session != null) {                    sessionId = session.getId();                    host = session.getHost();                }            }        } catch (Exception e) {            log.trace("No security manager set. Trying next to get session id from system property");        }    }        if (sessionId == null) {        if (log.isTraceEnabled()) {            log.trace("No Session found for the currently executing subject via subject.getSession(false).  " + "Attempting to revert back to the 'shiro.session.id' system property...");        }        sessionId = System.getProperty(SESSION_ID_SYSTEM_PROPERTY_NAME);        if (sessionId == null && log.isTraceEnabled()) {            log.trace("No 'shiro.session.id' system property found.  Heuristics have been exhausted; " + "RemoteInvocation will not contain a sessionId.");        }    }    RemoteInvocation ri = new RemoteInvocation(mi);    if (sessionId != null) {        ri.addAttribute(SESSION_ID_KEY, sessionId);    }    if (host != null) {        ri.addAttribute(HOST_KEY, host);    }    return ri;}
0
protected org.apache.shiro.aop.MethodInvocation createMethodInvocation(Object implSpecificMethodInvocation)
{    final MethodInvocation mi = (MethodInvocation) implSpecificMethodInvocation;    return new org.apache.shiro.aop.MethodInvocation() {        public Method getMethod() {            return mi.getMethod();        }        public Object[] getArguments() {            return mi.getArguments();        }        public String toString() {            return "Method invocation [" + mi.getMethod() + "]";        }        public Object proceed() throws Throwable {            return mi.proceed();        }        public Object getThis() {            return mi.getThis();        }    };}
0
public Method getMethod()
{    return mi.getMethod();}
0
public Object[] getArguments()
{    return mi.getArguments();}
0
public String toString()
{    return "Method invocation [" + mi.getMethod() + "]";}
0
public Object proceed() throws Throwable
{    return mi.proceed();}
0
public Object getThis()
{    return mi.getThis();}
0
protected Object continueInvocation(Object aopAllianceMethodInvocation) throws Throwable
{    MethodInvocation mi = (MethodInvocation) aopAllianceMethodInvocation;    return mi.proceed();}
0
public Object invoke(MethodInvocation methodInvocation) throws Throwable
{    org.apache.shiro.aop.MethodInvocation mi = createMethodInvocation(methodInvocation);    return super.invoke(mi);}
0
public SecurityManager getSecurityManager()
{    return securityManager;}
0
public void setSecurityManager(org.apache.shiro.mgt.SecurityManager securityManager)
{    this.securityManager = securityManager;}
0
public boolean matches(Method method, Class targetClass)
{    Method m = method;    if (isAuthzAnnotationPresent(m)) {        return true;    }        if (targetClass != null) {        try {            m = targetClass.getMethod(m.getName(), m.getParameterTypes());            return isAuthzAnnotationPresent(m) || isAuthzAnnotationPresent(targetClass);        } catch (NoSuchMethodException ignored) {                        }    }    return false;}
0
private boolean isAuthzAnnotationPresent(Class<?> targetClazz)
{    for (Class<? extends Annotation> annClass : AUTHZ_ANNOTATION_CLASSES) {        Annotation a = AnnotationUtils.findAnnotation(targetClazz, annClass);        if (a != null) {            return true;        }    }    return false;}
0
private boolean isAuthzAnnotationPresent(Method method)
{    for (Class<? extends Annotation> annClass : AUTHZ_ANNOTATION_CLASSES) {        Annotation a = AnnotationUtils.findAnnotation(method, annClass);        if (a != null) {            return true;        }    }    return false;}
0
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException
{    return bean;}
0
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException
{    if (bean instanceof EventBusAware) {        ((EventBusAware) bean).setEventBus(eventBus);    } else if (isEventSubscriber(bean)) {        eventBus.register(bean);    }    return bean;}
0
private boolean isEventSubscriber(Object bean)
{    List annotatedMethods = ClassUtils.getAnnotatedMethods(bean.getClass(), Subscribe.class);    return !CollectionUtils.isEmpty(annotatedMethods);}
0
protected SessionManager nativeSessionManager()
{    DefaultWebSessionManager webSessionManager = new DefaultWebSessionManager();    webSessionManager.setSessionIdCookieEnabled(sessionIdCookieEnabled);    webSessionManager.setSessionIdUrlRewritingEnabled(sessionIdUrlRewritingEnabled);    webSessionManager.setSessionIdCookie(sessionCookieTemplate());    webSessionManager.setSessionFactory(sessionFactory());    webSessionManager.setSessionDAO(sessionDAO());    webSessionManager.setDeleteInvalidSessions(sessionManagerDeleteInvalidSessions);    return webSessionManager;}
0
protected Cookie sessionCookieTemplate()
{    return buildCookie(sessionIdCookieName, sessionIdCookieMaxAge, sessionIdCookiePath, sessionIdCookieDomain, sessionIdCookieSecure);}
0
protected Cookie rememberMeCookieTemplate()
{    return buildCookie(rememberMeCookieName, rememberMeCookieMaxAge, rememberMeCookiePath, rememberMeCookieDomain, rememberMeCookieSecure);}
0
protected Cookie buildCookie(String name, int maxAge, String path, String domain, boolean secure)
{    Cookie cookie = new SimpleCookie(name);    cookie.setHttpOnly(true);    cookie.setMaxAge(maxAge);    cookie.setPath(path);    cookie.setDomain(domain);    cookie.setSecure(secure);    return cookie;}
0
protected SessionManager sessionManager()
{    if (useNativeSessionManager) {        return nativeSessionManager();    }    return new ServletContainerSessionManager();}
0
protected RememberMeManager rememberMeManager()
{    CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager();    cookieRememberMeManager.setCookie(rememberMeCookieTemplate());    return cookieRememberMeManager;}
0
protected SubjectFactory subjectFactory()
{    return new DefaultWebSubjectFactory();}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return new DefaultWebSessionStorageEvaluator();}
0
protected SessionsSecurityManager createSecurityManager()
{    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();    securityManager.setSubjectDAO(subjectDAO());    securityManager.setSubjectFactory(subjectFactory());    securityManager.setRememberMeManager(rememberMeManager());    return securityManager;}
0
protected ShiroFilterChainDefinition shiroFilterChainDefinition()
{    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();    chainDefinition.addPathDefinition("/**", "authc");    return chainDefinition;}
0
protected ShiroFilterFactoryBean shiroFilterFactoryBean()
{    ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean();    filterFactoryBean.setLoginUrl(loginUrl);    filterFactoryBean.setSuccessUrl(successUrl);    filterFactoryBean.setUnauthorizedUrl(unauthorizedUrl);    filterFactoryBean.setSecurityManager(securityManager);    filterFactoryBean.setFilterChainDefinitionMap(shiroFilterChainDefinition.getFilterChainMap());    return filterFactoryBean;}
0
public void addPathDefinition(String antPath, String definition)
{    filterChainDefinitionMap.put(antPath, definition);}
0
public void addPathDefinitions(Map<String, String> pathDefinitions)
{    filterChainDefinitionMap.putAll(pathDefinitions);}
0
public Map<String, String> getFilterChainMap()
{    return filterChainDefinitionMap;}
0
protected SubjectDAO subjectDAO()
{    return super.subjectDAO();}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return super.sessionStorageEvaluator();}
0
protected SessionFactory sessionFactory()
{    return super.sessionFactory();}
0
protected SessionDAO sessionDAO()
{    return super.sessionDAO();}
0
protected Cookie sessionCookieTemplate()
{    return super.sessionCookieTemplate();}
0
protected Cookie rememberMeCookieTemplate()
{    return super.rememberMeCookieTemplate();}
0
protected RememberMeManager rememberMeManager()
{    return super.rememberMeManager();}
0
protected SubjectFactory subjectFactory()
{    return super.subjectFactory();}
0
protected Authorizer authorizer()
{    return super.authorizer();}
0
protected AuthenticationStrategy authenticationStrategy()
{    return super.authenticationStrategy();}
0
protected Authenticator authenticator()
{    return super.authenticator();}
0
protected SessionManager sessionManager()
{    return super.sessionManager();}
0
protected SessionsSecurityManager securityManager(List<Realm> realms)
{    return super.securityManager(realms);}
0
protected ShiroFilterChainDefinition shiroFilterChainDefinition()
{    return super.shiroFilterChainDefinition();}
0
protected ShiroFilterFactoryBean shiroFilterFactoryBean()
{    return super.shiroFilterFactoryBean();}
0
public SecurityManager getSecurityManager()
{    return securityManager;}
0
public void setSecurityManager(SecurityManager securityManager)
{    this.securityManager = securityManager;}
0
public String getLoginUrl()
{    return loginUrl;}
0
public void setLoginUrl(String loginUrl)
{    this.loginUrl = loginUrl;}
0
public String getSuccessUrl()
{    return successUrl;}
0
public void setSuccessUrl(String successUrl)
{    this.successUrl = successUrl;}
0
public String getUnauthorizedUrl()
{    return unauthorizedUrl;}
0
public void setUnauthorizedUrl(String unauthorizedUrl)
{    this.unauthorizedUrl = unauthorizedUrl;}
0
public Map<String, Filter> getFilters()
{    return filters;}
0
public void setFilters(Map<String, Filter> filters)
{    this.filters = filters;}
0
public Map<String, String> getFilterChainDefinitionMap()
{    return filterChainDefinitionMap;}
0
public void setFilterChainDefinitionMap(Map<String, String> filterChainDefinitionMap)
{    this.filterChainDefinitionMap = filterChainDefinitionMap;}
0
public void setFilterChainDefinitions(String definitions)
{    Ini ini = new Ini();    ini.load(definitions);        Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS);    if (CollectionUtils.isEmpty(section)) {                        section = ini.getSection(Ini.DEFAULT_SECTION_NAME);    }    setFilterChainDefinitionMap(section);}
0
public Object getObject() throws Exception
{    if (instance == null) {        instance = createInstance();    }    return instance;}
0
public Class getObjectType()
{    return SpringShiroFilter.class;}
0
public boolean isSingleton()
{    return true;}
0
protected FilterChainManager createFilterChainManager()
{    DefaultFilterChainManager manager = new DefaultFilterChainManager();    Map<String, Filter> defaultFilters = manager.getFilters();        for (Filter filter : defaultFilters.values()) {        applyGlobalPropertiesIfNecessary(filter);    }        Map<String, Filter> filters = getFilters();    if (!CollectionUtils.isEmpty(filters)) {        for (Map.Entry<String, Filter> entry : filters.entrySet()) {            String name = entry.getKey();            Filter filter = entry.getValue();            applyGlobalPropertiesIfNecessary(filter);            if (filter instanceof Nameable) {                ((Nameable) filter).setName(name);            }                                    manager.addFilter(name, filter, false);        }    }        Map<String, String> chains = getFilterChainDefinitionMap();    if (!CollectionUtils.isEmpty(chains)) {        for (Map.Entry<String, String> entry : chains.entrySet()) {            String url = entry.getKey();            String chainDefinition = entry.getValue();            manager.createChain(url, chainDefinition);        }    }    return manager;}
0
protected AbstractShiroFilter createInstance() throws Exception
{        SecurityManager securityManager = getSecurityManager();    if (securityManager == null) {        String msg = "SecurityManager property must be set.";        throw new BeanInitializationException(msg);    }    if (!(securityManager instanceof WebSecurityManager)) {        String msg = "The security manager does not implement the WebSecurityManager interface.";        throw new BeanInitializationException(msg);    }    FilterChainManager manager = createFilterChainManager();                PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();    chainResolver.setFilterChainManager(manager);        return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);}
1
private void applyLoginUrlIfNecessary(Filter filter)
{    String loginUrl = getLoginUrl();    if (StringUtils.hasText(loginUrl) && (filter instanceof AccessControlFilter)) {        AccessControlFilter acFilter = (AccessControlFilter) filter;                String existingLoginUrl = acFilter.getLoginUrl();        if (AccessControlFilter.DEFAULT_LOGIN_URL.equals(existingLoginUrl)) {            acFilter.setLoginUrl(loginUrl);        }    }}
0
private void applySuccessUrlIfNecessary(Filter filter)
{    String successUrl = getSuccessUrl();    if (StringUtils.hasText(successUrl) && (filter instanceof AuthenticationFilter)) {        AuthenticationFilter authcFilter = (AuthenticationFilter) filter;                String existingSuccessUrl = authcFilter.getSuccessUrl();        if (AuthenticationFilter.DEFAULT_SUCCESS_URL.equals(existingSuccessUrl)) {            authcFilter.setSuccessUrl(successUrl);        }    }}
0
private void applyUnauthorizedUrlIfNecessary(Filter filter)
{    String unauthorizedUrl = getUnauthorizedUrl();    if (StringUtils.hasText(unauthorizedUrl) && (filter instanceof AuthorizationFilter)) {        AuthorizationFilter authzFilter = (AuthorizationFilter) filter;                String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl();        if (existingUnauthorizedUrl == null) {            authzFilter.setUnauthorizedUrl(unauthorizedUrl);        }    }}
0
private void applyGlobalPropertiesIfNecessary(Filter filter)
{    applyLoginUrlIfNecessary(filter);    applySuccessUrlIfNecessary(filter);    applyUnauthorizedUrlIfNecessary(filter);}
0
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException
{    if (bean instanceof Filter) {                Filter filter = (Filter) bean;        applyGlobalPropertiesIfNecessary(filter);        getFilters().put(beanName, filter);    } else {        log.trace("Ignoring non-Filter bean '{}'", beanName);    }    return bean;}
1
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException
{    return bean;}
0
protected EventBusAwareObject eventBusAwareObject()
{    return new EventBusAwareObject();}
0
protected EventSubscriber subscriber()
{    return new EventSubscriber();}
0
public EventBus getEventBus()
{    return eventBus;}
0
public void setEventBus(EventBus eventBus)
{    this.eventBus = eventBus;}
0
public void listen(Object object)
{}
0
protected EventBus eventBus()
{    return new DefaultEventBus();}
0
 CacheManager cacheManager()
{    return new MemoryConstrainedCacheManager();}
0
 RolePermissionResolver rolePermissionResolver()
{    return new RolePermissionResolver() {        @Override        public Collection<Permission> resolvePermissionsInRole(String roleString) {            return Collections.emptySet();        }    };}
0
public Collection<Permission> resolvePermissionsInRole(String roleString)
{    return Collections.emptySet();}
0
 PermissionResolver permissionResolver()
{        return new WildcardPermissionResolver();}
0
 Realm getTextConfigurationRealm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
public void setup()
{    ThreadContext.remove();}
0
public void tearDown()
{    ThreadContext.remove();}
0
protected Method getMethod(String name, Class clazz)
{    Method[] methods = clazz.getMethods();    for (Method method : methods) {        if (method.getName().equals(name)) {            return method;        }    }    throw new IllegalStateException("'" + name + "' method should exist.");}
0
public void testSessionManagerProxyStartRemoteInvocation() throws Exception
{    SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();    MethodInvocation mi = createMock(MethodInvocation.class);    Method startMethod = getMethod("start", SessionManager.class);    expect(mi.getMethod()).andReturn(startMethod).anyTimes();    Object[] args = { "localhost" };    expect(mi.getArguments()).andReturn(args).anyTimes();    replay(mi);    RemoteInvocation ri = factory.createRemoteInvocation(mi);    verify(mi);    assertNull(ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));}
0
public void testSessionManagerProxyNonStartRemoteInvocation() throws Exception
{    SecureRemoteInvocationFactory factory = new SecureRemoteInvocationFactory();    MethodInvocation mi = createMock(MethodInvocation.class);    Method method = getMethod("getSession", SessionManager.class);    expect(mi.getMethod()).andReturn(method).anyTimes();    String dummySessionId = UUID.randomUUID().toString();    SessionKey sessionKey = new DefaultSessionKey(dummySessionId);    Object[] args = { sessionKey };    expect(mi.getArguments()).andReturn(args).anyTimes();    replay(mi);    RemoteInvocation ri = factory.createRemoteInvocation(mi);    verify(mi);    assertEquals(dummySessionId, ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));}
0
protected void bind(Subject subject)
{    clearSubject();    this.threadState = new SubjectThreadState(subject);    this.threadState.bind();}
0
public void clearSubject()
{    if (threadState != null) {        threadState.clear();    }}
0
protected void bindGuest()
{    bind(new Subject.Builder(securityManager).buildSubject());}
0
protected void bindUser()
{    PrincipalCollection principals = new SimplePrincipalCollection("test", realm.getName());    bind(new Subject.Builder(securityManager).principals(principals).buildSubject());}
0
protected void bindAuthenticatedUser()
{    PrincipalCollection principals = new SimplePrincipalCollection("test", realm.getName());    bind(new Subject.Builder(securityManager).principals(principals).authenticated(true).buildSubject());}
0
public void testGuestImplementation()
{    bindGuest();    testService.guestImplementation();}
0
public void testGuestImplementationFailure()
{    bindUser();    testService.guestImplementation();}
0
public void testGuestInterface()
{    bindGuest();    testService.guestInterface();}
0
public void testUserImplementation()
{    bindUser();    testService.userImplementation();}
0
public void testUserImplementationFailure()
{    bindGuest();    testService.userImplementation();}
0
public void testUserInterface()
{    bindUser();    testService.userInterface();}
0
public void testAuthenticatedImplementation()
{    bindAuthenticatedUser();    testService.authenticatedImplementation();}
0
public void testAuthenticatedImplementationFailure()
{    bindUser();    testService.authenticatedImplementation();}
0
public void testAuthenticatedInterface()
{    bindAuthenticatedUser();    testService.authenticatedInterface();}
0
public void secureMethod()
{}
0
public void unsecuredMethod()
{}
0
public String secureMethod()
{    return "";}
0
public String unsecuredMethod()
{    return "";}
0
public String someMethod()
{    return "";}
0
public void matches() throws NoSuchMethodException
{    assertTrue("the method is annotated, should match", new AuthorizationAttributeSourceAdvisor().matches(Secured.class.getDeclaredMethod("secureMethod"), Secured.class));    assertFalse("the method is not annotated, should not match", new AuthorizationAttributeSourceAdvisor().matches(Secured.class.getDeclaredMethod("unsecuredMethod"), Secured.class));    assertTrue("the method declaration is annotated in the interface, should match", new AuthorizationAttributeSourceAdvisor().matches(ServiceInterface.class.getDeclaredMethod("secureMethod"), ServiceImpl.class));    assertFalse("not annotated method, should not match", new AuthorizationAttributeSourceAdvisor().matches(ServiceInterface.class.getDeclaredMethod("unsecuredMethod"), ServiceImpl.class));    assertTrue("the method declaration is in the interface with type-annotation, should match", new AuthorizationAttributeSourceAdvisor().matches(SafeServiceInterface.class.getDeclaredMethod("someMethod"), SafeServiceInterface.class));    assertTrue("the method declaration is in the interface with type-annotation, should match", new AuthorizationAttributeSourceAdvisor().matches(SafeServiceImpl.class.getDeclaredMethod("someMethod"), SafeServiceImpl.class));}
0
public void testGuestInterfaceFailure()
{    bindUser();    testService.guestInterface();}
0
public void testUserInterfaceFailure()
{    bindGuest();    testService.userInterface();}
0
public void testAuthenticatedInterfaceFailure()
{    bindGuest();    testService.authenticatedInterface();}
0
public void guestImplementation()
{}
0
public void guestInterface()
{}
0
public void userImplementation()
{}
0
public void userInterface()
{}
0
public void authenticatedImplementation()
{}
0
public void authenticatedInterface()
{}
0
public void roleImplementation()
{}
0
public void roleInterface()
{}
0
public void permissionImplementation()
{}
0
public void permissionInterface()
{}
0
 CacheManager getCacheManager()
{    return new MemoryConstrainedCacheManager();}
0
public void init(FilterConfig filterConfig) throws ServletException
{}
0
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException
{    chain.doFilter(request, response);}
0
public void destroy()
{}
0
public void testFilterDefinition()
{    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("org/apache/shiro/spring/web/ShiroFilterFactoryBeanTest.xml");    AbstractShiroFilter shiroFilter = (AbstractShiroFilter) context.getBean("shiroFilter");    PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) shiroFilter.getFilterChainResolver();    DefaultFilterChainManager fcManager = (DefaultFilterChainManager) resolver.getFilterChainManager();    NamedFilterList chain = fcManager.getChain("/test");    assertNotNull(chain);    assertEquals(chain.size(), 2);    Filter[] filters = new Filter[chain.size()];    filters = chain.toArray(filters);    assertTrue(filters[0] instanceof DummyFilter);    assertTrue(filters[1] instanceof FormAuthenticationFilter);}
0
public void testFilterDefinitionWithInit() throws Exception
{    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("org/apache/shiro/spring/web/ShiroFilterFactoryBeanTest.xml");    AbstractShiroFilter shiroFilter = (AbstractShiroFilter) context.getBean("shiroFilter");    FilterConfig mockFilterConfig = createNiceMock(FilterConfig.class);    ServletContext mockServletContext = createNiceMock(ServletContext.class);    expect(mockFilterConfig.getServletContext()).andReturn(mockServletContext).anyTimes();    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    expect(mockRequest.getContextPath()).andReturn("/").anyTimes();    expect(mockRequest.getRequestURI()).andReturn("/").anyTimes();    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    replay(mockFilterConfig);    replay(mockServletContext);    shiroFilter.init(mockFilterConfig);    verify(mockServletContext);    verify(mockFilterConfig);    FilterChain filterChain = new FilterChain() {        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException, ServletException {            HttpServletRequest request = (HttpServletRequest) servletRequest;            assertNotNull(request.getSession());                        assertNotNull(request.getSession().getServletContext());        }    };    replay(mockRequest);    replay(mockResponse);    shiroFilter.doFilter(mockRequest, mockResponse, filterChain);    verify(mockResponse);    verify(mockRequest);}
0
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException, ServletException
{    HttpServletRequest request = (HttpServletRequest) servletRequest;    assertNotNull(request.getSession());        assertNotNull(request.getSession().getServletContext());}
0
public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator()
{    return super.defaultAdvisorAutoProxyCreator();}
0
public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)
{    return super.authorizationAttributeSourceAdvisor(securityManager);}
0
protected AuthenticationStrategy authenticationStrategy()
{    return super.authenticationStrategy();}
0
protected Authenticator authenticator()
{    return super.authenticator();}
0
protected Authorizer authorizer()
{    return super.authorizer();}
0
protected SubjectDAO subjectDAO()
{    return super.subjectDAO();}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return super.sessionStorageEvaluator();}
0
protected SubjectFactory subjectFactory()
{    return super.subjectFactory();}
0
protected SessionFactory sessionFactory()
{    return super.sessionFactory();}
0
protected SessionDAO sessionDAO()
{    return super.sessionDAO();}
0
protected SessionManager sessionManager()
{    return super.sessionManager();}
0
protected SessionsSecurityManager securityManager(List<Realm> realms)
{    return super.securityManager(realms);}
0
protected Realm iniClasspathRealm()
{    return iniRealmFromLocation("classpath:shiro.ini");}
0
protected Realm iniMetaInfClasspathRealm()
{    return iniRealmFromLocation("classpath:META-INF/shiro.ini");}
0
protected Realm missingRealm()
{    throw new NoRealmBeanConfiguredException();}
0
public LifecycleBeanPostProcessor lifecycleBeanPostProcessor()
{    return super.lifecycleBeanPostProcessor();}
0
protected EventBus eventBus()
{    return super.eventBus();}
0
public ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor()
{    return super.shiroEventBusAwareBeanPostProcessor();}
0
protected FailureAnalysis analyze(Throwable rootFailure, NoRealmBeanConfiguredException cause)
{    return new FailureAnalysis("No bean of type 'org.apache.shiro.realm.Realm' found.", "Please create bean of type 'Realm' or add a shiro.ini in the root classpath (src/main/resources/shiro.ini) or in the META-INF folder (src/main/resources/META-INF/shiro.ini).", cause);}
0
public static void main(String[] args)
{    SpringApplication.run(ShiroAutoConfigurationTestApplication.class, args);}
0
 Realm getTextConfigurationRealm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
 EventBusAwareObject eventBusAwareObject()
{    return new EventBusAwareObject();}
0
 SubscribedListener subscribedListener()
{    return new SubscribedListener();}
0
public void setEventBus(EventBus bus)
{    this.eventBus = bus;}
0
public EventBus getEventBus()
{    return eventBus;}
0
public void onEvent(Object object)
{}
0
protected AuthenticationStrategy authenticationStrategy()
{    return super.authenticationStrategy();}
0
protected Authenticator authenticator()
{    return super.authenticator();}
0
protected Authorizer authorizer()
{    return super.authorizer();}
0
protected SubjectDAO subjectDAO()
{    return super.subjectDAO();}
0
protected SessionStorageEvaluator sessionStorageEvaluator()
{    return super.sessionStorageEvaluator();}
0
protected SubjectFactory subjectFactory()
{    return super.subjectFactory();}
0
protected SessionFactory sessionFactory()
{    return super.sessionFactory();}
0
protected SessionDAO sessionDAO()
{    return super.sessionDAO();}
0
protected SessionManager sessionManager()
{    return super.sessionManager();}
0
protected SessionsSecurityManager securityManager(List<Realm> realms)
{    return super.securityManager(realms);}
0
protected Cookie sessionCookieTemplate()
{    return super.sessionCookieTemplate();}
0
protected RememberMeManager rememberMeManager()
{    return super.rememberMeManager();}
0
protected Cookie rememberMeCookieTemplate()
{    return super.rememberMeCookieTemplate();}
0
protected ShiroFilterChainDefinition shiroFilterChainDefinition()
{    return super.shiroFilterChainDefinition();}
0
protected ShiroFilterFactoryBean shiroFilterFactoryBean()
{    return super.shiroFilterFactoryBean();}
0
protected FilterRegistrationBean filterShiroFilterRegistrationBean() throws Exception
{    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();    filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ERROR);    filterRegistrationBean.setFilter((AbstractShiroFilter) shiroFilterFactoryBean().getObject());    filterRegistrationBean.setOrder(1);    return filterRegistrationBean;}
0
public static void main(String[] args)
{    SpringApplication.run(ShiroWebAutoConfigurationTestApplication.class, args);}
0
 Realm getTextConfigurationRealm()
{    TextConfigurationRealm realm = new TextConfigurationRealm();    realm.setUserDefinitions("joe.coder=password,user\n" + "jill.coder=password,admin");    realm.setRoleDefinitions("admin=read,write\n" + "user=read");    realm.setCachingEnabled(true);    return realm;}
0
 ShiroFilterChainDefinition shiroFilterChainDefinition()
{    return new DefaultShiroFilterChainDefinition();}
0
 EventBusAwareObject eventBusAwareObject()
{    return new EventBusAwareObject();}
0
 SubscribedListener subscribedListener()
{    return new SubscribedListener();}
0
public void setEventBus(EventBus bus)
{    this.eventBus = bus;}
0
public EventBus getEventBus()
{    return eventBus;}
0
public void onEvent(Object object)
{}
0
public static void main(String[] args)
{    CommandLineParser parser = new DefaultParser();    Options options = new Options();    options.addOption(HELP).addOption(DEBUG).addOption(ALGORITHM).addOption(ITERATIONS);    options.addOption(RESOURCE).addOption(PASSWORD).addOption(PASSWORD_NC);    options.addOption(SALT).addOption(SALT_BYTES).addOption(SALT_GEN).addOption(SALT_GEN_SIZE).addOption(NO_SALT_GEN);    options.addOption(PRIVATE_SALT).addOption(PRIVATE_SALT_BYTES);    options.addOption(FORMAT);    boolean debug = false;        String algorithm = null;        int iterations = 0;    boolean resource = false;    boolean password = false;    boolean passwordConfirm = true;    String saltString = null;    String saltBytesString = null;    boolean generateSalt = false;    int generatedSaltSize = DEFAULT_GENERATED_SALT_SIZE;    String privateSaltString = null;    String privateSaltBytesString = null;    String formatString = null;    char[] passwordChars = null;    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption(HELP.getOpt())) {            printHelpAndExit(options, null, debug, 0);        }        if (line.hasOption(DEBUG.getOpt())) {            debug = true;        }        if (line.hasOption(ALGORITHM.getOpt())) {            algorithm = line.getOptionValue(ALGORITHM.getOpt());        }        if (line.hasOption(ITERATIONS.getOpt())) {            iterations = getRequiredPositiveInt(line, ITERATIONS);        }        if (line.hasOption(PASSWORD.getOpt())) {            password = true;            generateSalt = true;        }        if (line.hasOption(RESOURCE.getOpt())) {            resource = true;        }        if (line.hasOption(PASSWORD_NC.getOpt())) {            password = true;            generateSalt = true;            passwordConfirm = false;        }        if (line.hasOption(SALT.getOpt())) {            saltString = line.getOptionValue(SALT.getOpt());        }        if (line.hasOption(SALT_BYTES.getOpt())) {            saltBytesString = line.getOptionValue(SALT_BYTES.getOpt());        }        if (line.hasOption(NO_SALT_GEN.getOpt())) {            generateSalt = false;        }        if (line.hasOption(SALT_GEN.getOpt())) {            generateSalt = true;        }        if (line.hasOption(SALT_GEN_SIZE.getOpt())) {            generateSalt = true;            generatedSaltSize = getRequiredPositiveInt(line, SALT_GEN_SIZE);            if (generatedSaltSize % 8 != 0) {                throw new IllegalArgumentException("Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc).");            }        }        if (line.hasOption(PRIVATE_SALT.getOpt())) {            privateSaltString = line.getOptionValue(PRIVATE_SALT.getOpt());        }        if (line.hasOption(PRIVATE_SALT_BYTES.getOpt())) {            privateSaltBytesString = line.getOptionValue(PRIVATE_SALT_BYTES.getOpt());        }        if (line.hasOption(FORMAT.getOpt())) {            formatString = line.getOptionValue(FORMAT.getOpt());        }        String sourceValue;        Object source;        if (password) {            passwordChars = readPassword(passwordConfirm);            source = passwordChars;        } else {            String[] remainingArgs = line.getArgs();            if (remainingArgs == null || remainingArgs.length != 1) {                printHelpAndExit(options, null, debug, -1);            }            assert remainingArgs != null;            sourceValue = toString(remainingArgs);            if (resource) {                if (!ResourceUtils.hasResourcePrefix(sourceValue)) {                    source = toFile(sourceValue);                } else {                    source = ResourceUtils.getInputStreamForPath(sourceValue);                }            } else {                source = sourceValue;            }        }        if (algorithm == null) {            if (password) {                algorithm = DEFAULT_PASSWORD_ALGORITHM_NAME;            } else {                algorithm = DEFAULT_ALGORITHM_NAME;            }        }        if (iterations < DEFAULT_NUM_ITERATIONS) {                        if (password) {                iterations = DEFAULT_PASSWORD_NUM_ITERATIONS;            } else {                iterations = DEFAULT_NUM_ITERATIONS;            }        }        ByteSource publicSalt = getSalt(saltString, saltBytesString, generateSalt, generatedSaltSize);        ByteSource privateSalt = getSalt(privateSaltString, privateSaltBytesString, false, generatedSaltSize);        HashRequest hashRequest = new SimpleHashRequest(algorithm, ByteSource.Util.bytes(source), publicSalt, iterations);        DefaultHashService hashService = new DefaultHashService();        hashService.setPrivateSalt(privateSalt);        Hash hash = hashService.computeHash(hashRequest);        if (formatString == null) {                        if (password) {                formatString = Shiro1CryptFormat.class.getName();            } else {                formatString = HexFormat.class.getName();            }        }        HashFormat format = HASH_FORMAT_FACTORY.getInstance(formatString);        if (format == null) {            throw new IllegalArgumentException("Unrecognized hash format '" + formatString + "'.");        }        String output = format.format(hash);        System.out.println(output);    } catch (IllegalArgumentException iae) {        exit(iae, debug);    } catch (UnknownAlgorithmException uae) {        exit(uae, debug);    } catch (IOException ioe) {        exit(ioe, debug);    } catch (Exception e) {        printHelpAndExit(options, e, debug, -1);    } finally {        if (passwordChars != null && passwordChars.length > 0) {            for (int i = 0; i < passwordChars.length; i++) {                passwordChars[i] = ' ';            }        }    }}
0
private static String createMutexMessage(Option... options)
{    StringBuilder sb = new StringBuilder();    sb.append("The ");    for (int i = 0; i < options.length; i++) {        if (i > 0) {            sb.append(", ");        }        Option o = options[0];        sb.append("-").append(o.getOpt()).append("/--").append(o.getLongOpt());    }    sb.append(" and generated salt options are mutually exclusive.  Only one of them may be used at a time");    return sb.toString();}
0
private static void exit(Exception e, boolean debug)
{    printException(e, debug);    System.exit(-1);}
0
private static int getRequiredPositiveInt(CommandLine line, Option option)
{    String iterVal = line.getOptionValue(option.getOpt());    try {        return Integer.parseInt(iterVal);    } catch (NumberFormatException e) {        String msg = "'" + option.getLongOpt() + "' value must be a positive integer.";        throw new IllegalArgumentException(msg, e);    }}
0
private static ByteSource getSalt(String saltString, String saltBytesString, boolean generateSalt, int generatedSaltSize)
{    if (saltString != null) {        if (generateSalt || (saltBytesString != null)) {            throw new IllegalArgumentException(SALT_MUTEX_MSG);        }        return ByteSource.Util.bytes(saltString);    }    if (saltBytesString != null) {        if (generateSalt) {            throw new IllegalArgumentException(SALT_MUTEX_MSG);        }        String value = saltBytesString;        boolean base64 = true;        if (saltBytesString.startsWith(HEX_PREFIX)) {                        base64 = false;            value = value.substring(HEX_PREFIX.length());        }        byte[] bytes;        if (base64) {            bytes = Base64.decode(value);        } else {            bytes = Hex.decode(value);        }        return ByteSource.Util.bytes(bytes);    }    if (generateSalt) {        SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();                int byteSize = generatedSaltSize / 8;        return generator.nextBytes(byteSize);    }        return null;}
0
private static void printException(Exception e, boolean debug)
{    if (e != null) {        System.out.println();        if (debug) {            System.out.println("Error: ");            e.printStackTrace(System.out);            System.out.println(e.getMessage());        } else {            System.out.println("Error: " + e.getMessage());            System.out.println();            System.out.println("Specify -d or --debug for more information.");        }    }}
0
private static void printHelp(Options options, Exception e, boolean debug)
{    HelpFormatter help = new HelpFormatter();    String command = "java -jar shiro-tools-hasher-<version>.jar [options] [<value>]";    String header = "\nPrint a cryptographic hash (aka message digest) of the specified <value>.\n--\nOptions:";    String footer = "\n" + "<value> is optional only when hashing passwords (see below).  It is\n" + "required all other times." + "\n\n" + "Password Hashing:\n" + "---------------------------------\n" + "Specify the -p/--password option and DO NOT enter a <value>.  You will\n" + "be prompted for a password and characters will not echo as you type." + "\n\n" + "Salting:\n" + "---------------------------------\n" + "Specifying a salt:" + "\n\n" + "You may specify a salt using the -s/--salt option followed by the salt\n" + "value.  If the salt value is a base64 or hex string representing a\n" + "byte array, you must specify the -sb/--saltbytes option to indicate this,\n" + "otherwise the text value bytes will be used directly." + "\n\n" + "When using -sb/--saltbytes, the -s/--salt value is expected to be a\n" + "base64-encoded string by default.  If the value is a hex-encoded string,\n" + "you must prefix the string with 0x (zero x) to indicate a hex value." + "\n\n" + "Generating a salt:" + "\n\n" + "Use the -gs/--gensalt option if you don't want to specify a salt,\n" + "but want a strong random salt to be generated and used during hashing.\n" + "The generated salt size defaults to 128 bits.  You may specify\n" + "a different size by using the -gss/--gensaltsize option followed by\n" + "a positive integer (size is in bits, not bytes)." + "\n\n" + "Because a salt must be specified if computing the hash later,\n" + "generated salts are only useful with the shiro1 output format;\n" + "the other formats do not include the generated salt." + "\n\n" + "Specifying a private salt:" + "\n\n" + "You may specify a private salt using the -ps/--privatesalt option followed\n" + "by the private salt value.  If the private salt value is a base64 or hex \n" + "string representing a byte array, you must specify the -psb/--privatesaltbytes\n" + "option to indicate this, otherwise the text value bytes will be used directly." + "\n\n" + "When using -psb/--privatesaltbytes, the -ps/--privatesalt value is expected to\n" + "be a base64-encoded string by default.  If the value is a hex-encoded string,\n" + "you must prefix the string with 0x (zero x) to indicate a hex value." + "\n\n" + "Files, URLs and classpath resources:\n" + "---------------------------------\n" + "If using the -r/--resource option, the <value> represents a resource path.\n" + "By default this is expected to be a file path, but you may specify\n" + "classpath or URL resources by using the classpath: or url: prefix\n" + "respectively." + "\n\n" + "Some examples:" + "\n\n" + "<command> -r fileInCurrentDirectory.txt\n" + "<command> -r ../../relativePathFile.xml\n" + "<command> -r ~/documents/myfile.pdf\n" + "<command> -r /usr/local/logs/absolutePathFile.log\n" + "<command> -r url:http://foo.com/page.html\n" + "<command> -r classpath:/WEB-INF/lib/something.jar" + "\n\n" + "Output Format:\n" + "---------------------------------\n" + "Specify the -f/--format option followed by either 1) the format ID (as defined\n" + "by the " + DefaultHashFormatFactory.class.getName() + "\n" + "JavaDoc) or 2) the fully qualified " + HashFormat.class.getName() + "\n" + "implementation class name to instantiate and use for formatting.\n\n" + "The default output format is 'shiro1' which is a Modular Crypt Format (MCF)\n" + "that shows all relevant information as a dollar-sign ($) delimited string.\n" + "This format is ideal for use in Shiro's text-based user configuration (e.g.\n" + "shiro.ini or a properties file).";    printException(e, debug);    System.out.println();    help.printHelp(command, header, options, null);    System.out.println(footer);}
0
private static void printHelpAndExit(Options options, Exception e, boolean debug, int exitCode)
{    printHelp(options, e, debug);    System.exit(exitCode);}
0
private static char[] readPassword(boolean confirm)
{    java.io.Console console = System.console();    if (console == null) {        throw new IllegalStateException("java.io.Console is not available on the current JVM.  Cannot read passwords.");    }    char[] first = console.readPassword("%s", "Password to hash: ");    if (first == null || first.length == 0) {        throw new IllegalArgumentException("No password specified.");    }    if (confirm) {        char[] second = console.readPassword("%s", "Password to hash (confirm): ");        if (!Arrays.equals(first, second)) {            String msg = "Password entries do not match.";            throw new IllegalArgumentException(msg);        }    }    return first;}
0
private static File toFile(String path)
{    String resolved = path;    if (path.startsWith("~/") || path.startsWith(("~\\"))) {        resolved = path.replaceFirst("\\~", System.getProperty("user.home"));    }    return new File(resolved);}
0
private static String toString(String[] strings)
{    int len = strings != null ? strings.length : 0;    if (len == 0) {        return null;    }    return StringUtils.toDelimitedString(strings, " ");}
0
public FilterConfig getFilterConfig()
{    return filterConfig;}
0
public void setFilterConfig(FilterConfig filterConfig)
{    this.filterConfig = filterConfig;}
0
protected FilterChainResolver createInstance(Ini ini)
{    FilterChainResolver filterChainResolver = createDefaultInstance();    if (filterChainResolver instanceof PathMatchingFilterChainResolver) {        PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) filterChainResolver;        FilterChainManager manager = resolver.getFilterChainManager();        buildChains(manager, ini);    }    return filterChainResolver;}
0
protected FilterChainResolver createDefaultInstance()
{    FilterConfig filterConfig = getFilterConfig();    if (filterConfig != null) {        return new PathMatchingFilterChainResolver(filterConfig);    } else {        return new PathMatchingFilterChainResolver();    }}
0
protected void buildChains(FilterChainManager manager, Ini ini)
{        Ini.Section section = ini.getSection(FILTERS);    if (!CollectionUtils.isEmpty(section)) {        String msg = "The [{}] section has been deprecated and will be removed in a future release!  Please " + "move all object configuration (filters and all other objects) to the [{}] section.";            }    Map<String, Object> defaults = new LinkedHashMap<String, Object>();    Map<String, Filter> defaultFilters = manager.getFilters();        if (!CollectionUtils.isEmpty(defaultFilters)) {        defaults.putAll(defaultFilters);    }            Map<String, ?> defaultBeans = getDefaults();    if (!CollectionUtils.isEmpty(defaultBeans)) {        defaults.putAll(defaultBeans);    }    Map<String, Filter> filters = getFilters(section, defaults);        registerFilters(filters, manager);        section = ini.getSection(URLS);    createChains(section, manager);}
1
protected void registerFilters(Map<String, Filter> filters, FilterChainManager manager)
{    if (!CollectionUtils.isEmpty(filters)) {                boolean init = getFilterConfig() != null;        for (Map.Entry<String, Filter> entry : filters.entrySet()) {            String name = entry.getKey();            Filter filter = entry.getValue();            manager.addFilter(name, filter, init);        }    }}
0
protected Map<String, Filter> getFilters(Map<String, String> section, Map<String, ?> defaults)
{    Map<String, Filter> filters = extractFilters(defaults);    if (!CollectionUtils.isEmpty(section)) {        ReflectionBuilder builder = new ReflectionBuilder(defaults);        Map<String, ?> built = builder.buildObjects(section);        Map<String, Filter> sectionFilters = extractFilters(built);        if (CollectionUtils.isEmpty(filters)) {            filters = sectionFilters;        } else {            if (!CollectionUtils.isEmpty(sectionFilters)) {                filters.putAll(sectionFilters);            }        }    }    return filters;}
0
private Map<String, Filter> extractFilters(Map<String, ?> objects)
{    if (CollectionUtils.isEmpty(objects)) {        return null;    }    Map<String, Filter> filterMap = new LinkedHashMap<String, Filter>();    for (Map.Entry<String, ?> entry : objects.entrySet()) {        String key = entry.getKey();        Object value = entry.getValue();        if (value instanceof Filter) {            filterMap.put(key, (Filter) value);        }    }    return filterMap;}
0
protected void createChains(Map<String, String> urls, FilterChainManager manager)
{    if (CollectionUtils.isEmpty(urls)) {        if (log.isDebugEnabled()) {                    }        return;    }    if (log.isTraceEnabled()) {        log.trace("Before url processing.");    }    for (Map.Entry<String, String> entry : urls.entrySet()) {        String path = entry.getKey();        String value = entry.getValue();        manager.createChain(path, value);    }}
1
protected SecurityManager createDefaultInstance()
{    return new DefaultWebSecurityManager();}
0
protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection)
{    Map defaults = super.createDefaults(ini, mainSection);        Map<String, Filter> defaultFilters = DefaultFilter.createInstanceMap(null);    defaults.putAll(defaultFilters);    return defaults;}
0
public FilterChainResolver getFilterChainResolver()
{    return getObject(DEFAULT_FILTER_CHAIN_RESOLVER_NAME, FilterChainResolver.class);}
0
public void setFilterChainResolver(FilterChainResolver filterChainResolver)
{    setObject(DEFAULT_FILTER_CHAIN_RESOLVER_NAME, filterChainResolver);}
0
public SecurityManager getSecurityManager() throws IllegalStateException
{    return getWebSecurityManager();}
0
public void setSecurityManager(SecurityManager securityManager)
{    assertWebSecurityManager(securityManager);    super.setSecurityManager(securityManager);}
0
public WebSecurityManager getWebSecurityManager()
{    SecurityManager sm = super.getSecurityManager();    assertWebSecurityManager(sm);    return (WebSecurityManager) sm;}
0
public void setWebSecurityManager(WebSecurityManager wsm)
{    super.setSecurityManager(wsm);}
0
private void assertWebSecurityManager(SecurityManager sm)
{    if (!(sm instanceof WebSecurityManager)) {        String msg = "SecurityManager instance must be a " + WebSecurityManager.class.getName() + " instance.";        throw new IllegalStateException(msg);    }}
0
public ServletContext getServletContext()
{    return this.servletContext;}
0
public void setServletContext(ServletContext servletContext)
{    this.servletContext = servletContext;}
0
public WebEnvironment initEnvironment(ServletContext servletContext) throws IllegalStateException
{    if (servletContext.getAttribute(ENVIRONMENT_ATTRIBUTE_KEY) != null) {        String msg = "There is already a Shiro environment associated with the current ServletContext.  " + "Check if you have multiple EnvironmentLoader* definitions in your web.xml!";        throw new IllegalStateException(msg);    }    servletContext.log("Initializing Shiro environment");        long startTime = System.currentTimeMillis();    try {        WebEnvironment environment = createEnvironment(servletContext);        servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, environment);                if (log.isInfoEnabled()) {            long elapsed = System.currentTimeMillis() - startTime;                    }        return environment;    } catch (RuntimeException ex) {                servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, ex);        throw ex;    } catch (Error err) {                servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, err);        throw err;    }}
1
protected Class<?> determineWebEnvironmentClass(ServletContext servletContext)
{    Class<? extends WebEnvironment> webEnvironmentClass = webEnvironmentClassFromServletContext(servletContext);    if (webEnvironmentClass != null) {        return webEnvironmentClass;    } else {        return getDefaultWebEnvironmentClass();    }}
0
private Class<? extends WebEnvironment> webEnvironmentClassFromServletContext(ServletContext servletContext)
{    Class<? extends WebEnvironment> webEnvironmentClass = null;    String className = servletContext.getInitParameter(ENVIRONMENT_CLASS_PARAM);    if (className != null) {        try {            webEnvironmentClass = ClassUtils.forName(className);        } catch (UnknownClassException ex) {            throw new ConfigurationException("Failed to load custom WebEnvironment class [" + className + "]", ex);        }    }    return webEnvironmentClass;}
0
private WebEnvironment webEnvironmentFromServiceLoader()
{    WebEnvironment webEnvironment = null;        ServiceLoader<WebEnvironment> serviceLoader = ServiceLoader.load(WebEnvironment.class);    Iterator<WebEnvironment> iterator = serviceLoader.iterator();        if (iterator.hasNext()) {        webEnvironment = iterator.next();    }        if (iterator.hasNext()) {        List<String> allWebEnvironments = new ArrayList<String>();        allWebEnvironments.add(webEnvironment.getClass().getName());        while (iterator.hasNext()) {            allWebEnvironments.add(iterator.next().getClass().getName());        }        throw new ConfigurationException("ServiceLoader for class [" + WebEnvironment.class + "] returned more then one " + "result.  ServiceLoader must return zero or exactly one result for this class. Select one using the " + "servlet init parameter '" + ENVIRONMENT_CLASS_PARAM + "'. Found: " + allWebEnvironments);    }    return webEnvironment;}
0
protected Class<? extends WebEnvironment> getDefaultWebEnvironmentClass()
{    return IniWebEnvironment.class;}
0
protected WebEnvironment determineWebEnvironment(ServletContext servletContext)
{    Class<? extends WebEnvironment> webEnvironmentClass = webEnvironmentClassFromServletContext(servletContext);    WebEnvironment webEnvironment = null;        if (webEnvironmentClass == null) {        webEnvironment = webEnvironmentFromServiceLoader();    }        if (webEnvironmentClass == null && webEnvironment == null) {        webEnvironmentClass = getDefaultWebEnvironmentClass();    }        if (webEnvironmentClass != null) {        webEnvironment = (WebEnvironment) ClassUtils.newInstance(webEnvironmentClass);    }    return webEnvironment;}
0
protected WebEnvironment createEnvironment(ServletContext sc)
{    WebEnvironment webEnvironment = determineWebEnvironment(sc);    if (!MutableWebEnvironment.class.isInstance(webEnvironment)) {        throw new ConfigurationException("Custom WebEnvironment class [" + webEnvironment.getClass().getName() + "] is not of required type [" + MutableWebEnvironment.class.getName() + "]");    }    String configLocations = sc.getInitParameter(CONFIG_LOCATIONS_PARAM);    boolean configSpecified = StringUtils.hasText(configLocations);    if (configSpecified && !(ResourceConfigurable.class.isInstance(webEnvironment))) {        String msg = "WebEnvironment class [" + webEnvironment.getClass().getName() + "] does not implement the " + ResourceConfigurable.class.getName() + "interface.  This is required to accept any " + "configured " + CONFIG_LOCATIONS_PARAM + "value(s).";        throw new ConfigurationException(msg);    }    MutableWebEnvironment environment = (MutableWebEnvironment) webEnvironment;    environment.setServletContext(sc);    if (configSpecified && (environment instanceof ResourceConfigurable)) {        ((ResourceConfigurable) environment).setConfigLocations(configLocations);    }    customizeEnvironment(environment);    LifecycleUtils.init(environment);    return environment;}
0
protected void customizeEnvironment(WebEnvironment environment)
{}
0
public void destroyEnvironment(ServletContext servletContext)
{    servletContext.log("Cleaning up Shiro Environment");    try {        Object environment = servletContext.getAttribute(ENVIRONMENT_ATTRIBUTE_KEY);        if (environment instanceof WebEnvironment) {            finalizeEnvironment((WebEnvironment) environment);        }        LifecycleUtils.destroy(environment);    } finally {        servletContext.removeAttribute(ENVIRONMENT_ATTRIBUTE_KEY);    }}
0
protected void finalizeEnvironment(WebEnvironment environment)
{}
0
public void contextInitialized(ServletContextEvent sce)
{    initEnvironment(sce.getServletContext());}
0
public void contextDestroyed(ServletContextEvent sce)
{    destroyEnvironment(sce.getServletContext());}
0
public void init()
{    setIni(parseConfig());    configure();}
0
protected Ini parseConfig()
{    Ini ini = getIni();    String[] configLocations = getConfigLocations();    if (log.isWarnEnabled() && !CollectionUtils.isEmpty(ini) && configLocations != null && configLocations.length > 0) {            }    if (CollectionUtils.isEmpty(ini)) {                ini = getSpecifiedIni(configLocations);    }    if (CollectionUtils.isEmpty(ini)) {                ini = getDefaultIni();    }            ini = mergeIni(getFrameworkIni(), ini);    if (CollectionUtils.isEmpty(ini)) {        String msg = "Shiro INI configuration was either not found or discovered to be empty/unconfigured.";        throw new ConfigurationException(msg);    }    return ini;}
1
protected void configure()
{    this.objects.clear();    WebSecurityManager securityManager = createWebSecurityManager();    setWebSecurityManager(securityManager);    FilterChainResolver resolver = createFilterChainResolver();    if (resolver != null) {        setFilterChainResolver(resolver);    }}
0
protected Ini getFrameworkIni()
{    return null;}
0
protected Ini getSpecifiedIni(String[] configLocations) throws ConfigurationException
{    Ini ini = null;    if (configLocations != null && configLocations.length > 0) {        if (configLocations.length > 1) {                    }                ini = createIni(configLocations[0], true);    }    return ini;}
1
protected Ini mergeIni(Ini ini1, Ini ini2)
{    if (ini1 == null) {        return ini2;    }    if (ini2 == null) {        return ini1;    }        Ini iniResult = new Ini(ini1);    iniResult.merge(ini2);    return iniResult;}
0
protected Ini getDefaultIni()
{    Ini ini = null;    String[] configLocations = getDefaultConfigLocations();    if (configLocations != null) {        for (String location : configLocations) {            ini = createIni(location, false);            if (!CollectionUtils.isEmpty(ini)) {                                break;            }        }    }    return ini;}
1
protected Ini createIni(String configLocation, boolean required) throws ConfigurationException
{    Ini ini = null;    if (configLocation != null) {        ini = convertPathToIni(configLocation, required);    }    if (required && CollectionUtils.isEmpty(ini)) {        String msg = "Required configuration location '" + configLocation + "' does not exist or did not " + "contain any INI configuration.";        throw new ConfigurationException(msg);    }    return ini;}
0
protected FilterChainResolver createFilterChainResolver()
{    FilterChainResolver resolver = null;    Ini ini = getIni();    if (!CollectionUtils.isEmpty(ini)) {                Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);        Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);        if (!CollectionUtils.isEmpty(urls) || !CollectionUtils.isEmpty(filters)) {                        Factory<FilterChainResolver> factory = (Factory<FilterChainResolver>) this.objects.get(FILTER_CHAIN_RESOLVER_NAME);            if (factory instanceof IniFactorySupport) {                IniFactorySupport iniFactory = (IniFactorySupport) factory;                iniFactory.setIni(ini);                iniFactory.setDefaults(this.objects);            }            resolver = factory.getInstance();        }    }    return resolver;}
0
protected WebSecurityManager createWebSecurityManager()
{    Ini ini = getIni();    if (!CollectionUtils.isEmpty(ini)) {        factory.setIni(ini);    }    Map<String, Object> defaults = getDefaults();    if (!CollectionUtils.isEmpty(defaults)) {        factory.setDefaults(defaults);    }    WebSecurityManager wsm = (WebSecurityManager) factory.getInstance();            Map<String, ?> beans = factory.getBeans();    if (!CollectionUtils.isEmpty(beans)) {        this.objects.putAll(beans);    }    return wsm;}
0
protected String[] getDefaultConfigLocations()
{    return new String[] { DEFAULT_WEB_INI_RESOURCE_PATH, IniFactorySupport.DEFAULT_INI_RESOURCE_PATH };}
0
private Ini convertPathToIni(String path, boolean required)
{        Ini ini = null;    if (StringUtils.hasText(path)) {        InputStream is = null;                if (!ResourceUtils.hasResourcePrefix(path)) {            is = getServletContextResourceStream(path);        } else {            try {                is = ResourceUtils.getInputStreamForPath(path);            } catch (IOException e) {                if (required) {                    throw new ConfigurationException(e);                } else {                    if (log.isDebugEnabled()) {                                            }                }            }        }        if (is != null) {            ini = new Ini();            ini.load(is);        } else {            if (required) {                throw new ConfigurationException("Unable to load resource path '" + path + "'");            }        }    }    return ini;}
1
private InputStream getServletContextResourceStream(String path)
{    InputStream is = null;    path = WebUtils.normalize(path);    ServletContext sc = getServletContext();    if (sc != null) {        is = sc.getResourceAsStream(path);    }    return is;}
0
public Ini getIni()
{    return this.ini;}
0
public void setIni(Ini ini)
{    this.ini = ini;}
0
protected Map<String, Object> getDefaults()
{    Map<String, Object> defaults = new HashMap<String, Object>();    defaults.put(FILTER_CHAIN_RESOLVER_NAME, new IniFilterChainResolverFactory());    return defaults;}
0
protected WebIniSecurityManagerFactory getSecurityManagerFactory()
{    return factory;}
0
protected void setSecurityManagerFactory(WebIniSecurityManagerFactory factory)
{    this.factory = factory;}
0
public String[] getConfigLocations()
{    return configLocations;}
0
public void setConfigLocations(String locations)
{    if (!StringUtils.hasText(locations)) {        throw new IllegalArgumentException("Null/empty locations argument not allowed.");    }    String[] arr = StringUtils.split(locations);    setConfigLocations(arr);}
0
public void setConfigLocations(String[] configLocations)
{    this.configLocations = configLocations;}
0
public String getLoginUrl()
{    return loginUrl;}
0
public void setLoginUrl(String loginUrl)
{    this.loginUrl = loginUrl;}
0
protected Subject getSubject(ServletRequest request, ServletResponse response)
{    return SecurityUtils.getSubject();}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    return onAccessDenied(request, response);}
0
public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);}
0
protected boolean isLoginRequest(ServletRequest request, ServletResponse response)
{    return pathsMatch(getLoginUrl(), request);}
0
protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException
{    saveRequest(request);    redirectToLogin(request, response);}
0
protected void saveRequest(ServletRequest request)
{    WebUtils.saveRequest(request);}
0
protected void redirectToLogin(ServletRequest request, ServletResponse response) throws IOException
{    String loginUrl = getLoginUrl();    WebUtils.issueRedirect(request, response, loginUrl);}
0
protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)
{        return true;}
0
protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception
{    AuthenticationToken token = createToken(request, response);    if (token == null) {        String msg = "createToken method implementation returned null. A valid non-null AuthenticationToken " + "must be created in order to execute a login attempt.";        throw new IllegalStateException(msg);    }    try {        Subject subject = getSubject(request, response);        subject.login(token);        return onLoginSuccess(token, subject, request, response);    } catch (AuthenticationException e) {        return onLoginFailure(token, e, request, response);    }}
0
protected AuthenticationToken createToken(String username, String password, ServletRequest request, ServletResponse response)
{    boolean rememberMe = isRememberMe(request);    String host = getHost(request);    return createToken(username, password, rememberMe, host);}
0
protected AuthenticationToken createToken(String username, String password, boolean rememberMe, String host)
{    return new UsernamePasswordToken(username, password, rememberMe, host);}
0
protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception
{    return true;}
0
protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response)
{    return false;}
0
protected String getHost(ServletRequest request)
{    return request.getRemoteHost();}
0
protected boolean isRememberMe(ServletRequest request)
{    return false;}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{    return super.isAccessAllowed(request, response, mappedValue) || (!isLoginRequest(request, response) && isPermissive(mappedValue));}
0
protected boolean isPermissive(Object mappedValue)
{    if (mappedValue != null) {        String[] values = (String[]) mappedValue;        return Arrays.binarySearch(values, PERMISSIVE) >= 0;    }    return false;}
0
protected void cleanup(ServletRequest request, ServletResponse response, Exception existing) throws ServletException, IOException
{    if (existing instanceof UnauthenticatedException || (existing instanceof ServletException && existing.getCause() instanceof UnauthenticatedException)) {        try {            onAccessDenied(request, response);            existing = null;        } catch (Exception e) {            existing = e;        }    }    super.cleanup(request, response, existing);}
0
public String getSuccessUrl()
{    return successUrl;}
0
public void setSuccessUrl(String successUrl)
{    this.successUrl = successUrl;}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{    Subject subject = getSubject(request, response);    return subject.isAuthenticated() && subject.getPrincipal() != null;}
0
protected void issueSuccessRedirect(ServletRequest request, ServletResponse response) throws Exception
{    WebUtils.redirectToSavedRequest(request, response, getSuccessUrl());}
0
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response)
{    String authorizationHeader = getAuthzHeader(request);    if (authorizationHeader == null || authorizationHeader.length() == 0) {                return createToken("", "", request, response);    }        String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);    if (prinCred == null || prinCred.length < 2) {                        String username = prinCred == null || prinCred.length == 0 ? "" : prinCred[0];        return createToken(username, "", request, response);    }    String username = prinCred[0];    String password = prinCred[1];    return createToken(username, password, request, response);}
1
protected String[] getPrincipalsAndCredentials(String scheme, String encoded)
{    String decoded = Base64.decodeToString(encoded);    return decoded.split(":", 2);}
0
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response)
{    String authorizationHeader = getAuthzHeader(request);    if (authorizationHeader == null || authorizationHeader.length() == 0) {                return createBearerToken("", request);    }        String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);    if (prinCred == null || prinCred.length < 1) {                return createBearerToken("", request);    }    String token = prinCred[0] != null ? prinCred[0] : "";    return createBearerToken(token, request);}
1
protected String[] getPrincipalsAndCredentials(String scheme, String token)
{    return new String[] { token };}
0
protected AuthenticationToken createBearerToken(String token, ServletRequest request)
{    return new BearerToken(token, request.getRemoteHost());}
0
public void setLoginUrl(String loginUrl)
{    String previous = getLoginUrl();    if (previous != null) {        this.appliedPaths.remove(previous);    }    super.setLoginUrl(loginUrl);    if (log.isTraceEnabled()) {        log.trace("Adding login url to applied paths.");    }    this.appliedPaths.put(getLoginUrl(), null);}
0
public String getUsernameParam()
{    return usernameParam;}
0
public void setUsernameParam(String usernameParam)
{    this.usernameParam = usernameParam;}
0
public String getPasswordParam()
{    return passwordParam;}
0
public void setPasswordParam(String passwordParam)
{    this.passwordParam = passwordParam;}
0
public String getRememberMeParam()
{    return rememberMeParam;}
0
public void setRememberMeParam(String rememberMeParam)
{    this.rememberMeParam = rememberMeParam;}
0
public String getFailureKeyAttribute()
{    return failureKeyAttribute;}
0
public void setFailureKeyAttribute(String failureKeyAttribute)
{    this.failureKeyAttribute = failureKeyAttribute;}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception
{    if (isLoginRequest(request, response)) {        if (isLoginSubmission(request, response)) {            if (log.isTraceEnabled()) {                log.trace("Login submission detected.  Attempting to execute login.");            }            return executeLogin(request, response);        } else {            if (log.isTraceEnabled()) {                log.trace("Login page view.");            }                        return true;        }    } else {        if (log.isTraceEnabled()) {            log.trace("Attempting to access a path which requires authentication.  Forwarding to the " + "Authentication url [" + getLoginUrl() + "]");        }        saveRequestAndRedirectToLogin(request, response);        return false;    }}
0
protected boolean isLoginSubmission(ServletRequest request, ServletResponse response)
{    return (request instanceof HttpServletRequest) && WebUtils.toHttp(request).getMethod().equalsIgnoreCase(POST_METHOD);}
0
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response)
{    String username = getUsername(request);    String password = getPassword(request);    return createToken(username, password, request, response);}
0
protected boolean isRememberMe(ServletRequest request)
{    return WebUtils.isTrue(request, getRememberMeParam());}
0
protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception
{    issueSuccessRedirect(request, response);        return false;}
0
protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response)
{    if (log.isDebugEnabled()) {            }    setFailureAttribute(request, e);        return true;}
1
protected void setFailureAttribute(ServletRequest request, AuthenticationException ae)
{    String className = ae.getClass().getName();    request.setAttribute(getFailureKeyAttribute(), className);}
0
protected String getUsername(ServletRequest request)
{    return WebUtils.getCleanParam(request, getUsernameParam());}
0
protected String getPassword(ServletRequest request)
{    return WebUtils.getCleanParam(request, getPasswordParam());}
0
public String getApplicationName()
{    return applicationName;}
0
public void setApplicationName(String applicationName)
{    this.applicationName = applicationName;}
0
public String getAuthzScheme()
{    return authzScheme;}
0
public void setAuthzScheme(String authzScheme)
{    this.authzScheme = authzScheme;}
0
public String getAuthcScheme()
{    return authcScheme;}
0
public void setAuthcScheme(String authcScheme)
{    this.authcScheme = authcScheme;}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{    HttpServletRequest httpRequest = WebUtils.toHttp(request);    String httpMethod = httpRequest.getMethod();                Set<String> methods = httpMethodsFromOptions((String[]) mappedValue);    boolean authcRequired = methods.size() == 0;    for (String m : methods) {        if (httpMethod.toUpperCase(Locale.ENGLISH).equals(m)) {                        authcRequired = true;            break;        }    }    if (authcRequired) {        return super.isAccessAllowed(request, response, mappedValue);    } else {        return true;    }}
0
private Set<String> httpMethodsFromOptions(String[] options)
{    Set<String> methods = new HashSet<String>();    if (options != null) {        for (String option : options) {                        if (!option.equalsIgnoreCase(PERMISSIVE)) {                methods.add(option.toUpperCase(Locale.ENGLISH));            }        }    }    return methods;}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception
{        boolean loggedIn = false;    if (isLoginAttempt(request, response)) {        loggedIn = executeLogin(request, response);    }    if (!loggedIn) {        sendChallenge(request, response);    }    return loggedIn;}
0
protected boolean isLoginAttempt(ServletRequest request, ServletResponse response)
{    String authzHeader = getAuthzHeader(request);    return authzHeader != null && isLoginAttempt(authzHeader);}
0
protected final boolean isLoginRequest(ServletRequest request, ServletResponse response)
{    return this.isLoginAttempt(request, response);}
0
protected String getAuthzHeader(ServletRequest request)
{    HttpServletRequest httpRequest = WebUtils.toHttp(request);    return httpRequest.getHeader(AUTHORIZATION_HEADER);}
0
protected boolean isLoginAttempt(String authzHeader)
{        String authzScheme = getAuthzScheme().toLowerCase(Locale.ENGLISH);    return authzHeader.toLowerCase(Locale.ENGLISH).startsWith(authzScheme);}
0
protected boolean sendChallenge(ServletRequest request, ServletResponse response)
{        HttpServletResponse httpResponse = WebUtils.toHttp(response);    httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);    String authcHeader = getAuthcScheme() + " realm=\"" + getApplicationName() + "\"";    httpResponse.setHeader(AUTHENTICATE_HEADER, authcHeader);    return false;}
1
protected AuthenticationToken createToken(ServletRequest request, ServletResponse response)
{    String authorizationHeader = getAuthzHeader(request);    if (authorizationHeader == null || authorizationHeader.length() == 0) {                return createToken("", "", request, response);    }        String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);    if (prinCred == null || prinCred.length < 2) {                        String username = prinCred == null || prinCred.length == 0 ? "" : prinCred[0];        return createToken(username, "", request, response);    }    String username = prinCred[0];    String password = prinCred[1];    return createToken(username, password, request, response);}
1
protected String[] getPrincipalsAndCredentials(String authorizationHeader, ServletRequest request)
{    if (authorizationHeader == null) {        return null;    }    String[] authTokens = authorizationHeader.split(" ");    if (authTokens == null || authTokens.length < 2) {        return null;    }    return getPrincipalsAndCredentials(authTokens[0], authTokens[1]);}
0
protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception
{    Subject subject = getSubject(request, response);        if (isPostOnlyLogout()) {                if (!WebUtils.toHttp(request).getMethod().toUpperCase(Locale.ENGLISH).equals("POST")) {            return onLogoutRequestNotAPost(request, response);        }    }    String redirectUrl = getRedirectUrl(request, response, subject);        try {        subject.logout();    } catch (SessionException ise) {            }    issueRedirect(request, response, redirectUrl);    return false;}
1
protected Subject getSubject(ServletRequest request, ServletResponse response)
{    return SecurityUtils.getSubject();}
0
protected void issueRedirect(ServletRequest request, ServletResponse response, String redirectUrl) throws Exception
{    WebUtils.issueRedirect(request, response, redirectUrl);}
0
protected String getRedirectUrl(ServletRequest request, ServletResponse response, Subject subject)
{    return getRedirectUrl();}
0
public String getRedirectUrl()
{    return redirectUrl;}
0
public void setRedirectUrl(String redirectUrl)
{    this.redirectUrl = redirectUrl;}
0
protected boolean onLogoutRequestNotAPost(ServletRequest request, ServletResponse response)
{    HttpServletResponse httpServletResponse = WebUtils.toHttp(response);    httpServletResponse.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);    httpServletResponse.setHeader("Allow", "POST");    return false;}
0
public boolean isPostOnlyLogout()
{    return postOnlyLogout;}
0
public void setPostOnlyLogout(boolean postOnlyLogout)
{    this.postOnlyLogout = postOnlyLogout;}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception
{    if (isLoginRequest(request, response)) {        return true;    } else {        saveRequestAndRedirectToLogin(request, response);        return false;    }}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{    if (isLoginRequest(request, response)) {        return true;    } else {        Subject subject = getSubject(request, response);                return subject.getPrincipal() != null;    }}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception
{    saveRequestAndRedirectToLogin(request, response);    return false;}
0
public String getUnauthorizedUrl()
{    return unauthorizedUrl;}
0
public void setUnauthorizedUrl(String unauthorizedUrl)
{    this.unauthorizedUrl = unauthorizedUrl;}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException
{    Subject subject = getSubject(request, response);        if (subject.getPrincipal() == null) {        saveRequestAndRedirectToLogin(request, response);    } else {                        String unauthorizedUrl = getUnauthorizedUrl();                if (StringUtils.hasText(unauthorizedUrl)) {            WebUtils.issueRedirect(request, response, unauthorizedUrl);        } else {            WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);        }    }    return false;}
0
public void setAuthorizedHosts(String authorizedHosts)
{    if (!StringUtils.hasText(authorizedHosts)) {        throw new IllegalArgumentException("authorizedHosts argument cannot be null or empty.");    }    String[] hosts = StringUtils.tokenizeToStringArray(authorizedHosts, ", \t");    for (String host : hosts) {                String periodsReplaced = host.replace(".", "\\.");                String wildcardsReplaced = periodsReplaced.replace("*", IPV4_QUAD_REGEX);        if (IPV4_PATTERN.matcher(wildcardsReplaced).matches()) {            authorizedIps.put(host, wildcardsReplaced);        } else {        }    }}
0
public void setDeniedHosts(String deniedHosts)
{    if (!StringUtils.hasText(deniedHosts)) {        throw new IllegalArgumentException("deniedHosts argument cannot be null or empty.");    }}
0
protected boolean isIpv4Candidate(String host)
{    String[] quads = StringUtils.tokenizeToStringArray(host, ".");    if (quads == null || quads.length != 4) {        return false;    }    for (String quad : quads) {        if (!quad.equals("*")) {            try {                Integer.parseInt(quad);            } catch (NumberFormatException nfe) {                return false;            }        }    }    return true;}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    throw new UnsupportedOperationException("Not yet fully implemented!!!");}
0
public String getAction()
{    return this.action;}
0
protected Map<String, String> getHttpMethodActions()
{    return this.httpMethodActions;}
0
protected String getHttpMethodAction(ServletRequest request)
{    String method = ((HttpServletRequest) request).getMethod();    return getHttpMethodAction(method);}
0
protected String getHttpMethodAction(String method)
{    String lc = method.toLowerCase();    String resolved = getHttpMethodActions().get(lc);    return resolved != null ? resolved : method;}
0
protected String[] buildPermissions(HttpServletRequest request, String[] configuredPerms, String action)
{    return buildPermissions(configuredPerms, action);}
0
protected String[] buildPermissions(String[] configuredPerms, String action)
{    if (configuredPerms == null || configuredPerms.length <= 0 || !StringUtils.hasText(action)) {        return configuredPerms;    }    String[] mappedPerms = new String[configuredPerms.length];        for (int i = 0; i < configuredPerms.length; i++) {        mappedPerms[i] = configuredPerms[i] + ":" + action;    }    if (log.isTraceEnabled()) {        StringBuilder sb = new StringBuilder();        for (int i = 0; i < mappedPerms.length; i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(mappedPerms[i]);        }        log.trace("MAPPED '{}' action to permission(s) '{}'", action, sb);    }    return mappedPerms;}
0
public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException
{    String[] perms = (String[]) mappedValue;        String action = getHttpMethodAction(request);    String[] resolvedPerms = buildPermissions(perms, action);    return super.isAccessAllowed(request, response, resolvedPerms);}
0
public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException
{    Subject subject = getSubject(request, response);    String[] perms = (String[]) mappedValue;    boolean isPermitted = true;    if (perms != null && perms.length > 0) {        if (perms.length == 1) {            if (!subject.isPermitted(perms[0])) {                isPermitted = false;            }        } else {            if (!subject.isPermittedAll(perms)) {                isPermitted = false;            }        }    }    return isPermitted;}
0
public int getPort()
{    return port;}
0
public void setPort(int port)
{    this.port = port;}
0
protected int toPort(Object mappedValue)
{    String[] ports = (String[]) mappedValue;    if (ports == null || ports.length == 0) {        return getPort();    }    if (ports.length > 1) {        throw new ConfigurationException("PortFilter can only be configured with a single port.  You have " + "configured " + ports.length + ": " + StringUtils.toString(ports));    }    return Integer.parseInt(ports[0]);}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    int requiredPort = toPort(mappedValue);    int requestPort = request.getServerPort();    return requiredPort == requestPort;}
0
protected String getScheme(String requestScheme, int port)
{    if (port == DEFAULT_HTTP_PORT) {        return HTTP_SCHEME;    } else if (port == SslFilter.DEFAULT_HTTPS_PORT) {        return SslFilter.HTTPS_SCHEME;    } else {        return requestScheme;    }}
0
protected boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException
{        int port = toPort(mappedValue);    String scheme = getScheme(request.getScheme(), port);    StringBuilder sb = new StringBuilder();    sb.append(scheme).append("://");    sb.append(request.getServerName());    if (port != DEFAULT_HTTP_PORT && port != SslFilter.DEFAULT_HTTPS_PORT) {        sb.append(":");        sb.append(port);    }    if (request instanceof HttpServletRequest) {        sb.append(WebUtils.toHttp(request).getRequestURI());        String query = WebUtils.toHttp(request).getQueryString();        if (query != null) {            sb.append("?").append(query);        }    }    WebUtils.issueRedirect(request, response, sb.toString());    return false;}
0
public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException
{    Subject subject = getSubject(request, response);    String[] rolesArray = (String[]) mappedValue;    if (rolesArray == null || rolesArray.length == 0) {                return true;    }    Set<String> roles = CollectionUtils.asSet(rolesArray);    return subject.hasAllRoles(roles);}
0
protected String getScheme(String requestScheme, int port)
{    if (port == DEFAULT_HTTP_PORT) {        return PortFilter.HTTP_SCHEME;    } else {        return HTTPS_SCHEME;    }}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    return super.isAccessAllowed(request, response, mappedValue) && request.isSecure();}
0
public Filter newInstance()
{    return (Filter) ClassUtils.newInstance(this.filterClass);}
0
public Class<? extends Filter> getFilterClass()
{    return this.filterClass;}
0
public static Map<String, Filter> createInstanceMap(FilterConfig config)
{    Map<String, Filter> filters = new LinkedHashMap<String, Filter>(values().length);    for (DefaultFilter defaultFilter : values()) {        Filter filter = defaultFilter.newInstance();        if (config != null) {            try {                filter.init(config);            } catch (ServletException e) {                String msg = "Unable to correctly init default filter instance of type " + filter.getClass().getName();                throw new IllegalStateException(msg, e);            }        }        filters.put(defaultFilter.name(), filter);    }    return filters;}
0
public FilterConfig getFilterConfig()
{    return filterConfig;}
0
public void setFilterConfig(FilterConfig filterConfig)
{    this.filterConfig = filterConfig;}
0
public Map<String, Filter> getFilters()
{    return filters;}
0
public void setFilters(Map<String, Filter> filters)
{    this.filters = filters;}
0
public Map<String, NamedFilterList> getFilterChains()
{    return filterChains;}
0
public void setFilterChains(Map<String, NamedFilterList> filterChains)
{    this.filterChains = filterChains;}
0
public Filter getFilter(String name)
{    return this.filters.get(name);}
0
public void addFilter(String name, Filter filter)
{    addFilter(name, filter, false);}
0
public void addFilter(String name, Filter filter, boolean init)
{    addFilter(name, filter, init, true);}
0
public void createChain(String chainName, String chainDefinition)
{    if (!StringUtils.hasText(chainName)) {        throw new NullPointerException("chainName cannot be null or empty.");    }    if (!StringUtils.hasText(chainDefinition)) {        throw new NullPointerException("chainDefinition cannot be null or empty.");    }    if (log.isDebugEnabled()) {            }                                            String[] filterTokens = splitChainDefinition(chainDefinition);        for (String token : filterTokens) {        String[] nameConfigPair = toNameConfigPair(token);                addToChain(chainName, nameConfigPair[0], nameConfigPair[1]);    }}
1
protected String[] splitChainDefinition(String chainDefinition)
{    return StringUtils.split(chainDefinition, StringUtils.DEFAULT_DELIMITER_CHAR, '[', ']', true, true);}
0
protected String[] toNameConfigPair(String token) throws ConfigurationException
{    try {        String[] pair = token.split("\\[", 2);        String name = StringUtils.clean(pair[0]);        if (name == null) {            throw new IllegalArgumentException("Filter name not found for filter chain definition token: " + token);        }        String config = null;        if (pair.length == 2) {            config = StringUtils.clean(pair[1]);                        config = config.substring(0, config.length() - 1);            config = StringUtils.clean(config);                        if (config != null && config.startsWith("\"") && config.endsWith("\"")) {                String stripped = config.substring(1, config.length() - 1);                stripped = StringUtils.clean(stripped);                                if (stripped != null && stripped.indexOf('"') == -1) {                    config = stripped;                }                                                            }        }        return new String[] { name, config };    } catch (Exception e) {        String msg = "Unable to parse filter chain definition token: " + token;        throw new ConfigurationException(msg, e);    }}
0
protected void addFilter(String name, Filter filter, boolean init, boolean overwrite)
{    Filter existing = getFilter(name);    if (existing == null || overwrite) {        if (filter instanceof Nameable) {            ((Nameable) filter).setName(name);        }        if (init) {            initFilter(filter);        }        this.filters.put(name, filter);    }}
0
public void addToChain(String chainName, String filterName)
{    addToChain(chainName, filterName, null);}
0
public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig)
{    if (!StringUtils.hasText(chainName)) {        throw new IllegalArgumentException("chainName cannot be null or empty.");    }    Filter filter = getFilter(filterName);    if (filter == null) {        throw new IllegalArgumentException("There is no filter with name '" + filterName + "' to apply to chain [" + chainName + "] in the pool of available Filters.  Ensure a " + "filter with that name/path has first been registered with the addFilter method(s).");    }    applyChainConfig(chainName, filter, chainSpecificFilterConfig);    NamedFilterList chain = ensureChain(chainName);    chain.add(filter);}
0
protected void applyChainConfig(String chainName, Filter filter, String chainSpecificFilterConfig)
{    if (log.isDebugEnabled()) {            }    if (filter instanceof PathConfigProcessor) {        ((PathConfigProcessor) filter).processPathConfig(chainName, chainSpecificFilterConfig);    } else {        if (StringUtils.hasText(chainSpecificFilterConfig)) {                                    String msg = "chainSpecificFilterConfig was specified, but the underlying " + "Filter instance is not an 'instanceof' " + PathConfigProcessor.class.getName() + ".  This is required if the filter is to accept " + "chain-specific configuration.";            throw new ConfigurationException(msg);        }    }}
1
protected NamedFilterList ensureChain(String chainName)
{    NamedFilterList chain = getChain(chainName);    if (chain == null) {        chain = new SimpleNamedFilterList(chainName);        this.filterChains.put(chainName, chain);    }    return chain;}
0
public NamedFilterList getChain(String chainName)
{    return this.filterChains.get(chainName);}
0
public boolean hasChains()
{    return !CollectionUtils.isEmpty(this.filterChains);}
0
public Set<String> getChainNames()
{        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;}
0
public FilterChain proxy(FilterChain original, String chainName)
{    NamedFilterList configured = getChain(chainName);    if (configured == null) {        String msg = "There is no configured chain under the name/key [" + chainName + "].";        throw new IllegalArgumentException(msg);    }    return configured.proxy(original);}
0
protected void initFilter(Filter filter)
{    FilterConfig filterConfig = getFilterConfig();    if (filterConfig == null) {        throw new IllegalStateException("FilterConfig attribute has not been set.  This must occur before filter " + "initialization can occur.");    }    try {        filter.init(filterConfig);    } catch (ServletException e) {        throw new ConfigurationException(e);    }}
0
protected void addDefaultFilters(boolean init)
{    for (DefaultFilter defaultFilter : DefaultFilter.values()) {        addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false);    }}
0
public PatternMatcher getPathMatcher()
{    return pathMatcher;}
0
public void setPathMatcher(PatternMatcher pathMatcher)
{    this.pathMatcher = pathMatcher;}
0
public FilterChainManager getFilterChainManager()
{    return filterChainManager;}
0
public void setFilterChainManager(FilterChainManager filterChainManager)
{    this.filterChainManager = filterChainManager;}
0
public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain)
{    FilterChainManager filterChainManager = getFilterChainManager();    if (!filterChainManager.hasChains()) {        return null;    }    String requestURI = getPathWithinApplication(request);        for (String pathPattern : filterChainManager.getChainNames()) {                if (pathMatches(pathPattern, requestURI)) {            if (log.isTraceEnabled()) {                log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "].  " + "Utilizing corresponding filter chain...");            }            return filterChainManager.proxy(originalChain, pathPattern);        }    }    return null;}
0
protected boolean pathMatches(String pattern, String path)
{    PatternMatcher pathMatcher = getPathMatcher();    return pathMatcher.matches(pattern, path);}
0
protected String getPathWithinApplication(ServletRequest request)
{    return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));}
0
protected void setName(String name)
{    if (!StringUtils.hasText(name)) {        throw new IllegalArgumentException("Cannot specify a null or empty name.");    }    this.name = name;}
0
public String getName()
{    return name;}
0
public FilterChain proxy(FilterChain orig)
{    return new ProxiedFilterChain(orig, this);}
0
public boolean add(Filter filter)
{    return this.backingList.add(filter);}
0
public void add(int index, Filter filter)
{    this.backingList.add(index, filter);}
0
public boolean addAll(Collection<? extends Filter> c)
{    return this.backingList.addAll(c);}
0
public boolean addAll(int index, Collection<? extends Filter> c)
{    return this.backingList.addAll(index, c);}
0
public void clear()
{    this.backingList.clear();}
0
public boolean contains(Object o)
{    return this.backingList.contains(o);}
0
public boolean containsAll(Collection<?> c)
{    return this.backingList.containsAll(c);}
0
public Filter get(int index)
{    return this.backingList.get(index);}
0
public int indexOf(Object o)
{    return this.backingList.indexOf(o);}
0
public boolean isEmpty()
{    return this.backingList.isEmpty();}
0
public Iterator<Filter> iterator()
{    return this.backingList.iterator();}
0
public int lastIndexOf(Object o)
{    return this.backingList.lastIndexOf(o);}
0
public ListIterator<Filter> listIterator()
{    return this.backingList.listIterator();}
0
public ListIterator<Filter> listIterator(int index)
{    return this.backingList.listIterator(index);}
0
public Filter remove(int index)
{    return this.backingList.remove(index);}
0
public boolean remove(Object o)
{    return this.backingList.remove(o);}
0
public boolean removeAll(Collection<?> c)
{    return this.backingList.removeAll(c);}
0
public boolean retainAll(Collection<?> c)
{    return this.backingList.retainAll(c);}
0
public Filter set(int index, Filter filter)
{    return this.backingList.set(index, filter);}
0
public int size()
{    return this.backingList.size();}
0
public List<Filter> subList(int fromIndex, int toIndex)
{    return this.backingList.subList(fromIndex, toIndex);}
0
public Object[] toArray()
{    return this.backingList.toArray();}
0
public T[] toArray(T[] a)
{        return this.backingList.toArray(a);}
0
public Filter processPathConfig(String path, String config)
{    String[] values = null;    if (config != null) {        values = split(config);    }    this.appliedPaths.put(path, values);    return this;}
0
protected String getPathWithinApplication(ServletRequest request)
{    return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));}
0
protected boolean pathsMatch(String path, ServletRequest request)
{    String requestURI = getPathWithinApplication(request);    log.trace("Attempting to match pattern '{}' with current requestURI '{}'...", path, requestURI);    return pathsMatch(path, requestURI);}
0
protected boolean pathsMatch(String pattern, String path)
{    return pathMatcher.matches(pattern, path);}
0
protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception
{    if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {        if (log.isTraceEnabled()) {            log.trace("appliedPaths property is null or empty.  This Filter will passthrough immediately.");        }        return true;    }    for (String path : this.appliedPaths.keySet()) {                if (pathsMatch(path, request)) {            log.trace("Current requestURI matches pattern '{}'.  Determining filter chain execution...", path);            Object config = this.appliedPaths.get(path);            return isFilterChainContinued(request, response, path, config);        }    }        return true;}
0
private boolean isFilterChainContinued(ServletRequest request, ServletResponse response, String path, Object pathConfig) throws Exception
{    if (isEnabled(request, response, path, pathConfig)) {                if (log.isTraceEnabled()) {            log.trace("Filter '{}' is enabled for the current request under path '{}' with config [{}].  " + "Delegating to subclass implementation for 'onPreHandle' check.", new Object[] { getName(), path, pathConfig });        }                return onPreHandle(request, response, pathConfig);    }    if (log.isTraceEnabled()) {        log.trace("Filter '{}' is disabled for the current request under path '{}' with config [{}].  " + "The next element in the FilterChain will be called immediately.", new Object[] { getName(), path, pathConfig });    }        return true;}
0
protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    return true;}
0
protected boolean isEnabled(ServletRequest request, ServletResponse response, String path, Object mappedValue) throws Exception
{    return isEnabled(request, response);}
0
protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{    request.setAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED, Boolean.FALSE);    return true;}
0
public Cookie getCookie()
{    return cookie;}
0
public void setCookie(Cookie cookie)
{    this.cookie = cookie;}
0
protected void rememberSerializedIdentity(Subject subject, byte[] serialized)
{    if (!WebUtils.isHttp(subject)) {        if (log.isDebugEnabled()) {            String msg = "Subject argument is not an HTTP-aware instance.  This is required to obtain a servlet " + "request and response in order to set the rememberMe cookie. Returning immediately and " + "ignoring rememberMe operation.";                    }        return;    }    HttpServletRequest request = WebUtils.getHttpRequest(subject);    HttpServletResponse response = WebUtils.getHttpResponse(subject);        String base64 = Base64.encodeToString(serialized);        Cookie template = getCookie();    Cookie cookie = new SimpleCookie(template);    cookie.setValue(base64);    cookie.saveTo(request, response);}
1
private boolean isIdentityRemoved(WebSubjectContext subjectContext)
{    ServletRequest request = subjectContext.resolveServletRequest();    if (request != null) {        Boolean removed = (Boolean) request.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY);        return removed != null && removed;    }    return false;}
0
protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext)
{    if (!WebUtils.isHttp(subjectContext)) {        if (log.isDebugEnabled()) {            String msg = "SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a " + "servlet request and response in order to retrieve the rememberMe cookie. Returning " + "immediately and ignoring rememberMe operation.";                    }        return null;    }    WebSubjectContext wsc = (WebSubjectContext) subjectContext;    if (isIdentityRemoved(wsc)) {        return null;    }    HttpServletRequest request = WebUtils.getHttpRequest(wsc);    HttpServletResponse response = WebUtils.getHttpResponse(wsc);    String base64 = getCookie().readValue(request, response);        if (Cookie.DELETED_COOKIE_VALUE.equals(base64))        return null;    if (base64 != null) {        base64 = ensurePadding(base64);        if (log.isTraceEnabled()) {            log.trace("Acquired Base64 encoded identity [" + base64 + "]");        }        byte[] decoded = Base64.decode(base64);        if (log.isTraceEnabled()) {            log.trace("Base64 decoded byte array length: " + (decoded != null ? decoded.length : 0) + " bytes.");        }        return decoded;    } else {                return null;    }}
1
private String ensurePadding(String base64)
{    int length = base64.length();    if (length % 4 != 0) {        StringBuilder sb = new StringBuilder(base64);        for (int i = 0; i < length % 4; ++i) {            sb.append('=');        }        base64 = sb.toString();    }    return base64;}
0
protected void forgetIdentity(Subject subject)
{    if (WebUtils.isHttp(subject)) {        HttpServletRequest request = WebUtils.getHttpRequest(subject);        HttpServletResponse response = WebUtils.getHttpResponse(subject);        forgetIdentity(request, response);    }}
0
public void forgetIdentity(SubjectContext subjectContext)
{    if (WebUtils.isHttp(subjectContext)) {        HttpServletRequest request = WebUtils.getHttpRequest(subjectContext);        HttpServletResponse response = WebUtils.getHttpResponse(subjectContext);        forgetIdentity(request, response);    }}
0
private void forgetIdentity(HttpServletRequest request, HttpServletResponse response)
{    getCookie().removeFrom(request, response);}
0
protected SubjectContext createSubjectContext()
{    return new DefaultWebSubjectContext();}
0
public void setSubjectDAO(SubjectDAO subjectDAO)
{    super.setSubjectDAO(subjectDAO);    applySessionManagerToSessionStorageEvaluatorIfPossible();}
0
protected void afterSessionManagerSet()
{    super.afterSessionManagerSet();    applySessionManagerToSessionStorageEvaluatorIfPossible();}
0
private void applySessionManagerToSessionStorageEvaluatorIfPossible()
{    SubjectDAO subjectDAO = getSubjectDAO();    if (subjectDAO instanceof DefaultSubjectDAO) {        SessionStorageEvaluator evaluator = ((DefaultSubjectDAO) subjectDAO).getSessionStorageEvaluator();        if (evaluator instanceof DefaultWebSessionStorageEvaluator) {            ((DefaultWebSessionStorageEvaluator) evaluator).setSessionManager(getSessionManager());        }    }}
0
protected SubjectContext copy(SubjectContext subjectContext)
{    if (subjectContext instanceof WebSubjectContext) {        return new DefaultWebSubjectContext((WebSubjectContext) subjectContext);    }    return super.copy(subjectContext);}
0
public String getSessionMode()
{    return sessionMode;}
0
public void setSessionMode(String sessionMode)
{        String mode = sessionMode;    if (mode == null) {        throw new IllegalArgumentException("sessionMode argument cannot be null.");    }    mode = sessionMode.toLowerCase();    if (!HTTP_SESSION_MODE.equals(mode) && !NATIVE_SESSION_MODE.equals(mode)) {        String msg = "Invalid sessionMode [" + sessionMode + "].  Allowed values are " + "public static final String constants in the " + getClass().getName() + " class: '" + HTTP_SESSION_MODE + "' or '" + NATIVE_SESSION_MODE + "', with '" + HTTP_SESSION_MODE + "' being the default.";        throw new IllegalArgumentException(msg);    }    boolean recreate = this.sessionMode == null || !this.sessionMode.equals(mode);    this.sessionMode = mode;    if (recreate) {        LifecycleUtils.destroy(getSessionManager());        SessionManager sessionManager = createSessionManager(mode);        this.setInternalSessionManager(sessionManager);    }}
1
public void setSessionManager(SessionManager sessionManager)
{    this.sessionMode = null;    if (sessionManager != null && !(sessionManager instanceof WebSessionManager)) {        if (log.isWarnEnabled()) {            String msg = "The " + getClass().getName() + " implementation expects SessionManager instances " + "that implement the " + WebSessionManager.class.getName() + " interface.  The " + "configured instance is of type [" + sessionManager.getClass().getName() + "] which does not " + "implement this interface..  This may cause unexpected behavior.";                    }    }    setInternalSessionManager(sessionManager);}
1
private void setInternalSessionManager(SessionManager sessionManager)
{    super.setSessionManager(sessionManager);}
0
public boolean isHttpSessionMode()
{    SessionManager sessionManager = getSessionManager();    return sessionManager instanceof WebSessionManager && ((WebSessionManager) sessionManager).isServletContainerSessions();}
0
protected SessionManager createSessionManager(String sessionMode)
{    if (sessionMode == null || !sessionMode.equalsIgnoreCase(NATIVE_SESSION_MODE)) {                return new ServletContainerSessionManager();    } else {                return new DefaultWebSessionManager();    }}
1
protected SessionContext createSessionContext(SubjectContext subjectContext)
{    SessionContext sessionContext = super.createSessionContext(subjectContext);    if (subjectContext instanceof WebSubjectContext) {        WebSubjectContext wsc = (WebSubjectContext) subjectContext;        ServletRequest request = wsc.resolveServletRequest();        ServletResponse response = wsc.resolveServletResponse();        DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);        if (request != null) {            webSessionContext.setServletRequest(request);        }        if (response != null) {            webSessionContext.setServletResponse(response);        }        sessionContext = webSessionContext;    }    return sessionContext;}
0
protected SessionKey getSessionKey(SubjectContext context)
{    if (WebUtils.isWeb(context)) {        Serializable sessionId = context.getSessionId();        ServletRequest request = WebUtils.getRequest(context);        ServletResponse response = WebUtils.getResponse(context);        return new WebSessionKey(sessionId, request, response);    } else {        return super.getSessionKey(context);    }}
0
protected void beforeLogout(Subject subject)
{    super.beforeLogout(subject);    removeRequestIdentity(subject);}
0
protected void removeRequestIdentity(Subject subject)
{    if (subject instanceof WebSubject) {        WebSubject webSubject = (WebSubject) subject;        ServletRequest request = webSubject.getServletRequest();        if (request != null) {            request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);        }    }}
0
 void setSessionManager(SessionManager sessionManager)
{    this.sessionManager = sessionManager;}
0
public boolean isSessionStorageEnabled(Subject subject)
{    if (subject.getSession(false) != null) {                return true;    }    if (!isSessionStorageEnabled()) {                return false;    }        if (!(subject instanceof WebSubject) && (this.sessionManager != null && !(this.sessionManager instanceof NativeSessionManager))) {        return false;    }    return WebUtils._isSessionCreationEnabled(subject);}
0
public Subject createSubject(SubjectContext context)
{                boolean isNotBasedOnWebSubject = context.getSubject() != null && !(context.getSubject() instanceof WebSubject);    if (!(context instanceof WebSubjectContext) || isNotBasedOnWebSubject) {        return super.createSubject(context);    }    WebSubjectContext wsc = (WebSubjectContext) context;    SecurityManager securityManager = wsc.resolveSecurityManager();    Session session = wsc.resolveSession();    boolean sessionEnabled = wsc.isSessionCreationEnabled();    PrincipalCollection principals = wsc.resolvePrincipals();    boolean authenticated = wsc.resolveAuthenticated();    String host = wsc.resolveHost();    ServletRequest request = wsc.resolveServletRequest();    ServletResponse response = wsc.resolveServletResponse();    return new WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled, request, response, securityManager);}
0
protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated, String host, Session session, ServletRequest request, ServletResponse response, SecurityManager securityManager)
{    return new WebDelegatingSubject(principals, authenticated, host, session, true, request, response, securityManager);}
0
public FilterConfig getFilterConfig()
{    return filterConfig;}
0
public void setFilterConfig(FilterConfig filterConfig)
{    this.filterConfig = filterConfig;    setServletContext(filterConfig.getServletContext());}
0
protected String getInitParam(String paramName)
{    FilterConfig config = getFilterConfig();    if (config != null) {        return StringUtils.clean(config.getInitParameter(paramName));    }    return null;}
0
public final void init(FilterConfig filterConfig) throws ServletException
{    setFilterConfig(filterConfig);    try {        onFilterConfigSet();    } catch (Exception e) {        if (e instanceof ServletException) {            throw (ServletException) e;        } else {            if (log.isErrorEnabled()) {                            }            throw new ServletException(e);        }    }}
1
protected void onFilterConfigSet() throws Exception
{}
0
public void destroy()
{}
0
public WebSecurityManager getSecurityManager()
{    return securityManager;}
0
public void setSecurityManager(WebSecurityManager sm)
{    this.securityManager = sm;}
0
public FilterChainResolver getFilterChainResolver()
{    return filterChainResolver;}
0
public void setFilterChainResolver(FilterChainResolver filterChainResolver)
{    this.filterChainResolver = filterChainResolver;}
0
public boolean isStaticSecurityManagerEnabled()
{    return staticSecurityManagerEnabled;}
0
public void setStaticSecurityManagerEnabled(boolean staticSecurityManagerEnabled)
{    this.staticSecurityManagerEnabled = staticSecurityManagerEnabled;}
0
protected final void onFilterConfigSet() throws Exception
{        applyStaticSecurityManagerEnabledConfig();    init();    ensureSecurityManager();        if (isStaticSecurityManagerEnabled()) {        SecurityUtils.setSecurityManager(getSecurityManager());    }}
0
private void applyStaticSecurityManagerEnabledConfig()
{    String value = getInitParam(STATIC_INIT_PARAM_NAME);    if (value != null) {        Boolean b = Boolean.valueOf(value);        if (b != null) {            setStaticSecurityManagerEnabled(b);        }    }}
0
public void init() throws Exception
{}
0
private void ensureSecurityManager()
{    WebSecurityManager securityManager = getSecurityManager();    if (securityManager == null) {                securityManager = createDefaultSecurityManager();        setSecurityManager(securityManager);    }}
1
protected WebSecurityManager createDefaultSecurityManager()
{    return new DefaultWebSecurityManager();}
0
protected boolean isHttpSessions()
{    return getSecurityManager().isHttpSessionMode();}
0
protected ServletRequest wrapServletRequest(HttpServletRequest orig)
{    return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());}
0
protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain)
{    ServletRequest toUse = request;    if (request instanceof HttpServletRequest) {        HttpServletRequest http = (HttpServletRequest) request;        toUse = wrapServletRequest(http);    }    return toUse;}
0
protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request)
{    return new ShiroHttpServletResponse(orig, getServletContext(), request);}
0
protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain)
{    ServletResponse toUse = response;    if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) && (response instanceof HttpServletResponse)) {                        toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);    }    return toUse;}
0
protected WebSubject createSubject(ServletRequest request, ServletResponse response)
{    return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();}
0
protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response)
{    if (!isHttpSessions()) {                Subject subject = SecurityUtils.getSubject();                if (subject != null) {            Session session = subject.getSession(false);            if (session != null) {                try {                    session.touch();                } catch (Throwable t) {                                    }            }        }    }}
1
protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain) throws ServletException, IOException
{    Throwable t = null;    try {        final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);        final ServletResponse response = prepareServletResponse(request, servletResponse, chain);        final Subject subject = createSubject(request, response);                subject.execute(new Callable() {            public Object call() throws Exception {                updateSessionLastAccessTime(request, response);                executeChain(request, response, chain);                return null;            }        });    } catch (ExecutionException ex) {        t = ex.getCause();    } catch (Throwable throwable) {        t = throwable;    }    if (t != null) {        if (t instanceof ServletException) {            throw (ServletException) t;        }        if (t instanceof IOException) {            throw (IOException) t;        }                String msg = "Filtered request failed.";        throw new ServletException(msg, t);    }}
0
public Object call() throws Exception
{    updateSessionLastAccessTime(request, response);    executeChain(request, response, chain);    return null;}
0
protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain)
{    FilterChain chain = origChain;    FilterChainResolver resolver = getFilterChainResolver();    if (resolver == null) {                return origChain;    }    FilterChain resolved = resolver.getChain(request, response, origChain);    if (resolved != null) {        log.trace("Resolved a configured FilterChain for the current request.");        chain = resolved;    } else {        log.trace("No FilterChain configured for the current request.  Using the default.");    }    return chain;}
1
protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain) throws IOException, ServletException
{    FilterChain chain = getExecutionChain(request, response, origChain);    chain.doFilter(request, response);}
0
protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception
{    return true;}
0
protected void postHandle(ServletRequest request, ServletResponse response) throws Exception
{}
0
public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception
{}
0
protected void executeChain(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception
{    chain.doFilter(request, response);}
0
public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException
{    Exception exception = null;    try {        boolean continueChain = preHandle(request, response);        if (log.isTraceEnabled()) {            log.trace("Invoked preHandle method.  Continuing chain?: [" + continueChain + "]");        }        if (continueChain) {            executeChain(request, response, chain);        }        postHandle(request, response);        if (log.isTraceEnabled()) {            log.trace("Successfully invoked postHandle method");        }    } catch (Exception e) {        exception = e;    } finally {        cleanup(request, response, exception);    }}
0
protected void cleanup(ServletRequest request, ServletResponse response, Exception existing) throws ServletException, IOException
{    Exception exception = existing;    try {        afterCompletion(request, response, exception);        if (log.isTraceEnabled()) {            log.trace("Successfully invoked afterCompletion method.");        }    } catch (Exception e) {        if (exception == null) {            exception = e;        } else {                    }    }    if (exception != null) {        if (exception instanceof ServletException) {            throw (ServletException) exception;        } else if (exception instanceof IOException) {            throw (IOException) exception;        } else {            if (log.isDebugEnabled()) {                String msg = "Filter execution resulted in an unexpected Exception " + "(not IOException or ServletException as the Filter API recommends).  " + "Wrapping in ServletException and propagating.";                            }            throw new ServletException(exception);        }    }}
1
public String getConfig()
{    return this.config;}
0
public void setConfig(String config)
{    this.config = config;}
0
public String getConfigPath()
{    return configPath;}
0
public void setConfigPath(String configPath)
{    this.configPath = StringUtils.clean(configPath);}
0
public void init() throws Exception
{    applyInitParams();    configure();}
0
protected void applyInitParams() throws Exception
{    String config = getInitParam(CONFIG_INIT_PARAM_NAME);    if (config != null) {        setConfig(config);    }    String configPath = getInitParam(CONFIG_PATH_INIT_PARAM_NAME);    if (configPath != null) {        setConfigPath(configPath);    }}
0
protected void configure() throws Exception
{    Ini ini = loadIniFromConfig();    if (CollectionUtils.isEmpty(ini)) {                ini = loadIniFromPath();    }        if (CollectionUtils.isEmpty(ini)) {                ini = getServletContextIniResource(DEFAULT_WEB_INI_RESOURCE_PATH);    }        if (CollectionUtils.isEmpty(ini)) {                ini = IniFactorySupport.loadDefaultClassPathIni();    }    Map<String, ?> objects = applySecurityManager(ini);    applyFilterChainResolver(ini, objects);}
1
protected Ini loadIniFromConfig()
{    Ini ini = null;    String config = getConfig();    if (config != null) {        ini = convertConfigToIni(config);    }    return ini;}
0
protected Ini loadIniFromPath()
{    Ini ini = null;    String path = getConfigPath();    if (path != null) {        ini = convertPathToIni(path);    }    return ini;}
0
protected Map<String, ?> applySecurityManager(Ini ini)
{    WebIniSecurityManagerFactory factory;    if (CollectionUtils.isEmpty(ini)) {        factory = new WebIniSecurityManagerFactory();    } else {        factory = new WebIniSecurityManagerFactory(ini);    }            SecurityManager securityManager = factory.getInstance();    if (!(securityManager instanceof WebSecurityManager)) {        String msg = "The configured security manager is not an instance of WebSecurityManager, so " + "it can not be used with the Shiro servlet filter.";        throw new ConfigurationException(msg);    }    setSecurityManager((WebSecurityManager) securityManager);    return factory.getBeans();}
0
protected void applyFilterChainResolver(Ini ini, Map<String, ?> defaults)
{    if (ini == null || ini.isEmpty()) {                return;    }        Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);    Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);    if ((urls != null && !urls.isEmpty()) || (filters != null && !filters.isEmpty())) {                        IniFilterChainResolverFactory filterChainResolverFactory = new IniFilterChainResolverFactory(ini, defaults);        filterChainResolverFactory.setFilterConfig(getFilterConfig());        FilterChainResolver resolver = filterChainResolverFactory.getInstance();        setFilterChainResolver(resolver);    }}
0
protected Ini convertConfigToIni(String config)
{    Ini ini = new Ini();    ini.load(config);    return ini;}
0
protected Ini getServletContextIniResource(String servletContextPath)
{    String path = WebUtils.normalize(servletContextPath);    if (getServletContext() != null) {        InputStream is = getServletContext().getResourceAsStream(path);        if (is != null) {            Ini ini = new Ini();            ini.load(is);            if (CollectionUtils.isEmpty(ini)) {                            }            return ini;        }    }    return null;}
1
protected Ini convertPathToIni(String path)
{    Ini ini = new Ini();        if (!ResourceUtils.hasResourcePrefix(path)) {        ini = getServletContextIniResource(path);        if (ini == null) {            String msg = "There is no servlet context resource corresponding to configPath '" + path + "'  If " + "the resource is located elsewhere (not immediately resolveable in the servlet context), " + "specify an appropriate classpath:, url:, or file: resource prefix accordingly.";            throw new ConfigurationException(msg);        }    } else {                ini.loadFromPath(path);    }    return ini;}
0
protected String getName()
{    if (this.name == null) {        FilterConfig config = getFilterConfig();        if (config != null) {            this.name = config.getFilterName();        }    }    return this.name;}
0
public void setName(String name)
{    this.name = name;}
0
protected StringBuilder toStringBuilder()
{    String name = getName();    if (name == null) {        return super.toStringBuilder();    } else {        StringBuilder sb = new StringBuilder();        sb.append(name);        return sb;    }}
0
public boolean isEnabled()
{    return enabled;}
0
public void setEnabled(boolean enabled)
{    this.enabled = enabled;}
0
public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException
{    String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();    if (request.getAttribute(alreadyFilteredAttributeName) != null) {        log.trace("Filter '{}' already executed.  Proceeding without invoking this filter.", getName());        filterChain.doFilter(request, response);    } else     if (/* added in 1.2: */    !isEnabled(request, response) || /* retain backwards compatibility: */    shouldNotFilter(request)) {                filterChain.doFilter(request, response);    } else {                log.trace("Filter '{}' not yet executed.  Executing now.", getName());        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);        try {            doFilterInternal(request, response, filterChain);        } finally {                                    request.removeAttribute(alreadyFilteredAttributeName);        }    }}
1
protected boolean isEnabled(ServletRequest request, ServletResponse response) throws ServletException, IOException
{    return isEnabled();}
0
protected String getAlreadyFilteredAttributeName()
{    String name = getName();    if (name == null) {        name = getClass().getName();    }    return name + ALREADY_FILTERED_SUFFIX;}
0
protected boolean shouldNotFilter(ServletRequest request) throws ServletException
{    return false;}
0
public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException
{    if (this.filters == null || this.filters.size() == this.index) {                if (log.isTraceEnabled()) {            log.trace("Invoking original filter chain.");        }        this.orig.doFilter(request, response);    } else {        if (log.isTraceEnabled()) {            log.trace("Invoking wrapped filter at index [" + this.index + "]");        }        this.filters.get(this.index++).doFilter(request, response, this);    }}
0
public ServletContext getServletContext()
{    return servletContext;}
0
public void setServletContext(ServletContext servletContext)
{    this.servletContext = servletContext;}
0
protected String getContextInitParam(String paramName)
{    return getServletContext().getInitParameter(paramName);}
0
private ServletContext getRequiredServletContext()
{    ServletContext servletContext = getServletContext();    if (servletContext == null) {        String msg = "ServletContext property must be set via the setServletContext method.";        throw new IllegalStateException(msg);    }    return servletContext;}
0
protected void setContextAttribute(String key, Object value)
{    if (value == null) {        removeContextAttribute(key);    } else {        getRequiredServletContext().setAttribute(key, value);    }}
0
protected Object getContextAttribute(String key)
{    return getRequiredServletContext().getAttribute(key);}
0
protected void removeContextAttribute(String key)
{    getRequiredServletContext().removeAttribute(key);}
0
public String toString()
{    return toStringBuilder().toString();}
0
protected StringBuilder toStringBuilder()
{    return new StringBuilder(super.toString());}
0
public void init() throws Exception
{    WebEnvironment env = WebUtils.getRequiredWebEnvironment(getServletContext());    setSecurityManager(env.getWebSecurityManager());    FilterChainResolver resolver = env.getFilterChainResolver();    if (resolver != null) {        setFilterChainResolver(resolver);    }}
0
public boolean isHttpSessions()
{    return httpSessions;}
0
public String getRemoteUser()
{    String remoteUser;    Object scPrincipal = getSubjectPrincipal();    if (scPrincipal != null) {        if (scPrincipal instanceof String) {            return (String) scPrincipal;        } else if (scPrincipal instanceof Principal) {            remoteUser = ((Principal) scPrincipal).getName();        } else {            remoteUser = scPrincipal.toString();        }    } else {        remoteUser = super.getRemoteUser();    }    return remoteUser;}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
protected Object getSubjectPrincipal()
{    Object userPrincipal = null;    Subject subject = getSubject();    if (subject != null) {        userPrincipal = subject.getPrincipal();    }    return userPrincipal;}
0
public boolean isUserInRole(String s)
{    Subject subject = getSubject();    boolean inRole = (subject != null && subject.hasRole(s));    if (!inRole) {        inRole = super.isUserInRole(s);    }    return inRole;}
0
public Principal getUserPrincipal()
{    Principal userPrincipal;    Object scPrincipal = getSubjectPrincipal();    if (scPrincipal != null) {        if (scPrincipal instanceof Principal) {            userPrincipal = (Principal) scPrincipal;        } else {            userPrincipal = new ObjectPrincipal(scPrincipal);        }    } else {        userPrincipal = super.getUserPrincipal();    }    return userPrincipal;}
0
public String getRequestedSessionId()
{    String requestedSessionId = null;    if (isHttpSessions()) {        requestedSessionId = super.getRequestedSessionId();    } else {        Object sessionId = getAttribute(REFERENCED_SESSION_ID);        if (sessionId != null) {            requestedSessionId = sessionId.toString();        }    }    return requestedSessionId;}
0
public HttpSession getSession(boolean create)
{    HttpSession httpSession;    if (isHttpSessions()) {        httpSession = super.getSession(false);        if (httpSession == null && create) {                        if (WebUtils._isSessionCreationEnabled(this)) {                httpSession = super.getSession(create);            } else {                throw newNoSessionCreationException();            }        }    } else {        boolean existing = getSubject().getSession(false) != null;        if (this.session == null || !existing) {            Session shiroSession = getSubject().getSession(create);            if (shiroSession != null) {                this.session = new ShiroHttpSession(shiroSession, this, this.servletContext);                if (!existing) {                    setAttribute(REFERENCED_SESSION_IS_NEW, Boolean.TRUE);                }            } else if (this.session != null) {                this.session = null;            }        }        httpSession = this.session;    }    return httpSession;}
0
private DisabledSessionException newNoSessionCreationException()
{    String msg = "Session creation has been disabled for the current request.  This exception indicates " + "that there is either a programming error (using a session when it should never be " + "used) or that Shiro's configuration needs to be adjusted to allow Sessions to be created " + "for the current request.  See the " + DisabledSessionException.class.getName() + " JavaDoc " + "for more.";    return new DisabledSessionException(msg);}
0
public HttpSession getSession()
{    return getSession(true);}
0
public boolean isRequestedSessionIdValid()
{    if (isHttpSessions()) {        return super.isRequestedSessionIdValid();    } else {        Boolean value = (Boolean) getAttribute(REFERENCED_SESSION_ID_IS_VALID);        return (value != null && value.equals(Boolean.TRUE));    }}
0
public boolean isRequestedSessionIdFromCookie()
{    if (isHttpSessions()) {        return super.isRequestedSessionIdFromCookie();    } else {        String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);        return value != null && value.equals(COOKIE_SESSION_ID_SOURCE);    }}
0
public boolean isRequestedSessionIdFromURL()
{    if (isHttpSessions()) {        return super.isRequestedSessionIdFromURL();    } else {        String value = (String) getAttribute(REFERENCED_SESSION_ID_SOURCE);        return value != null && value.equals(URL_SESSION_ID_SOURCE);    }}
0
public boolean isRequestedSessionIdFromUrl()
{    return isRequestedSessionIdFromURL();}
0
public Object getObject()
{    return object;}
0
public String getName()
{    return getObject().toString();}
0
public int hashCode()
{    return object.hashCode();}
0
public boolean equals(Object o)
{    if (o instanceof ObjectPrincipal) {        ObjectPrincipal op = (ObjectPrincipal) o;        return getObject().equals(op.getObject());    }    return false;}
0
public String toString()
{    return object.toString();}
0
public ServletContext getContext()
{    return context;}
0
public void setContext(ServletContext context)
{    this.context = context;}
0
public ShiroHttpServletRequest getRequest()
{    return request;}
0
public void setRequest(ShiroHttpServletRequest request)
{    this.request = request;}
0
public String encodeRedirectURL(String url)
{    if (isEncodeable(toAbsolute(url))) {        return toEncoded(url, request.getSession().getId());    } else {        return url;    }}
0
public String encodeRedirectUrl(String s)
{    return encodeRedirectURL(s);}
0
public String encodeURL(String url)
{    String absolute = toAbsolute(url);    if (isEncodeable(absolute)) {                if (url.equalsIgnoreCase("")) {            url = absolute;        }        return toEncoded(url, request.getSession().getId());    } else {        return url;    }}
0
public String encodeUrl(String s)
{    return encodeURL(s);}
0
protected boolean isEncodeable(final String location)
{        if (Boolean.FALSE.equals(request.getAttribute(ShiroHttpServletRequest.SESSION_ID_URL_REWRITING_ENABLED)))        return (false);    if (location == null)        return (false);        if (location.startsWith("#"))        return (false);        final HttpServletRequest hreq = request;    final HttpSession session = hreq.getSession(false);    if (session == null)        return (false);    if (hreq.isRequestedSessionIdFromCookie())        return (false);    return doIsEncodeable(hreq, session, location);}
0
private boolean doIsEncodeable(HttpServletRequest hreq, HttpSession session, String location)
{        URL url;    try {        url = new URL(location);    } catch (MalformedURLException e) {        return (false);    }        if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol()))        return (false);    if (!hreq.getServerName().equalsIgnoreCase(url.getHost()))        return (false);    int serverPort = hreq.getServerPort();    if (serverPort == -1) {        if ("https".equals(hreq.getScheme()))            serverPort = 443;        else            serverPort = 80;    }    int urlPort = url.getPort();    if (urlPort == -1) {        if ("https".equals(url.getProtocol()))            urlPort = 443;        else            urlPort = 80;    }    if (serverPort != urlPort)        return (false);    String contextPath = getRequest().getContextPath();    if (contextPath != null) {        String file = url.getFile();        if ((file == null) || !file.startsWith(contextPath))            return (false);        String tok = ";" + DEFAULT_SESSION_ID_PARAMETER_NAME + "=" + session.getId();        if (file.indexOf(tok, contextPath.length()) >= 0)            return (false);    }        return (true);}
0
private String toAbsolute(String location)
{    if (location == null)        return (location);    boolean leadingSlash = location.startsWith("/");    if (leadingSlash || !hasScheme(location)) {        StringBuilder buf = new StringBuilder();        String scheme = request.getScheme();        String name = request.getServerName();        int port = request.getServerPort();        try {            buf.append(scheme).append("://").append(name);            if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {                buf.append(':').append(port);            }            if (!leadingSlash) {                String relativePath = request.getRequestURI();                int pos = relativePath.lastIndexOf('/');                relativePath = relativePath.substring(0, pos);                String encodedURI = URLEncoder.encode(relativePath, getCharacterEncoding());                buf.append(encodedURI).append('/');            }            buf.append(location);        } catch (IOException e) {            IllegalArgumentException iae = new IllegalArgumentException(location);            iae.initCause(e);            throw iae;        }        return buf.toString();    } else {        return location;    }}
0
public static boolean isSchemeChar(char c)
{    return Character.isLetterOrDigit(c) || c == '+' || c == '-' || c == '.';}
0
private boolean hasScheme(String uri)
{    int len = uri.length();    for (int i = 0; i < len; i++) {        char c = uri.charAt(i);        if (c == ':') {            return i > 0;        } else if (!isSchemeChar(c)) {            return false;        }    }    return false;}
0
protected String toEncoded(String url, String sessionId)
{    if ((url == null) || (sessionId == null))        return (url);    String path = url;    String query = "";    String anchor = "";    int question = url.indexOf('?');    if (question >= 0) {        path = url.substring(0, question);        query = url.substring(question);    }    int pound = path.indexOf('#');    if (pound >= 0) {        anchor = path.substring(pound);        path = path.substring(0, pound);    }    StringBuilder sb = new StringBuilder(path);    if (sb.length() > 0) {                sb.append(";");        sb.append(DEFAULT_SESSION_ID_PARAMETER_NAME);        sb.append("=");        sb.append(sessionId);    }    sb.append(anchor);    sb.append(query);    return (sb.toString());}
0
public boolean hasMoreElements()
{    return false;}
0
public Object nextElement()
{    return null;}
0
public HttpSession getSession(String s)
{    return null;}
0
public Enumeration getIds()
{    return EMPTY_ENUMERATION;}
0
public Session getSession()
{    return this.session;}
0
public long getCreationTime()
{    try {        return getSession().getStartTimestamp().getTime();    } catch (Exception e) {        throw new IllegalStateException(e);    }}
0
public String getId()
{    return getSession().getId().toString();}
0
public long getLastAccessedTime()
{    return getSession().getLastAccessTime().getTime();}
0
public ServletContext getServletContext()
{    return this.servletContext;}
0
public void setMaxInactiveInterval(int i)
{    try {        getSession().setTimeout(i * 1000);    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }}
0
public int getMaxInactiveInterval()
{    try {        return (new Long(getSession().getTimeout() / 1000)).intValue();    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }}
0
public javax.servlet.http.HttpSessionContext getSessionContext()
{    return HTTP_SESSION_CONTEXT;}
0
public Object getAttribute(String s)
{    try {        return getSession().getAttribute(s);    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }}
0
public Object getValue(String s)
{    return getAttribute(s);}
0
protected Set<String> getKeyNames()
{    Collection<Object> keySet;    try {        keySet = getSession().getAttributeKeys();    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }    Set<String> keyNames;    if (keySet != null && !keySet.isEmpty()) {        keyNames = new HashSet<String>(keySet.size());        for (Object o : keySet) {            keyNames.add(o.toString());        }    } else {        keyNames = Collections.EMPTY_SET;    }    return keyNames;}
0
public Enumeration getAttributeNames()
{    Set<String> keyNames = getKeyNames();    final Iterator iterator = keyNames.iterator();    return new Enumeration() {        public boolean hasMoreElements() {            return iterator.hasNext();        }        public Object nextElement() {            return iterator.next();        }    };}
0
public boolean hasMoreElements()
{    return iterator.hasNext();}
0
public Object nextElement()
{    return iterator.next();}
0
public String[] getValueNames()
{    Set<String> keyNames = getKeyNames();    String[] array = new String[keyNames.size()];    if (keyNames.size() > 0) {        array = keyNames.toArray(array);    }    return array;}
0
protected void afterBound(String s, Object o)
{    if (o instanceof HttpSessionBindingListener) {        HttpSessionBindingListener listener = (HttpSessionBindingListener) o;        HttpSessionBindingEvent event = new HttpSessionBindingEvent(this, s, o);        listener.valueBound(event);    }}
0
protected void afterUnbound(String s, Object o)
{    if (o instanceof HttpSessionBindingListener) {        HttpSessionBindingListener listener = (HttpSessionBindingListener) o;        HttpSessionBindingEvent event = new HttpSessionBindingEvent(this, s, o);        listener.valueUnbound(event);    }}
0
public void setAttribute(String s, Object o)
{    try {        getSession().setAttribute(s, o);        afterBound(s, o);    } catch (InvalidSessionException e) {                try {            afterUnbound(s, o);        } finally {                        throw new IllegalStateException(e);        }    }}
0
public void putValue(String s, Object o)
{    setAttribute(s, o);}
0
public void removeAttribute(String s)
{    try {        Object attribute = getSession().removeAttribute(s);        afterUnbound(s, attribute);    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }}
0
public void removeValue(String s)
{    removeAttribute(s);}
0
public void invalidate()
{    try {        getSession().stop();    } catch (InvalidSessionException e) {        throw new IllegalStateException(e);    }}
0
public boolean isNew()
{    Boolean value = (Boolean) currentRequest.getAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_IS_NEW);    return value != null && value.equals(Boolean.TRUE);}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    if (!StringUtils.hasText(name)) {        throw new IllegalArgumentException("Name cannot be null/empty.");    }    this.name = name;}
0
public String getValue()
{    return value;}
0
public void setValue(String value)
{    this.value = value;}
0
public String getComment()
{    return comment;}
0
public void setComment(String comment)
{    this.comment = comment;}
0
public String getDomain()
{    return domain;}
0
public void setDomain(String domain)
{    this.domain = domain;}
0
public String getPath()
{    return path;}
0
public void setPath(String path)
{    this.path = path;}
0
public int getMaxAge()
{    return maxAge;}
0
public void setMaxAge(int maxAge)
{    this.maxAge = Math.max(DEFAULT_MAX_AGE, maxAge);}
0
public int getVersion()
{    return version;}
0
public void setVersion(int version)
{    this.version = Math.max(DEFAULT_VERSION, version);}
0
public boolean isSecure()
{    return secure;}
0
public void setSecure(boolean secure)
{    this.secure = secure;}
0
public boolean isHttpOnly()
{    return httpOnly;}
0
public void setHttpOnly(boolean httpOnly)
{    this.httpOnly = httpOnly;}
0
public SameSiteOptions getSameSite()
{    return sameSite;}
0
public void setSameSite(SameSiteOptions sameSite)
{    this.sameSite = sameSite;}
0
private String calculatePath(HttpServletRequest request)
{    String path = StringUtils.clean(getPath());    if (!StringUtils.hasText(path)) {        path = StringUtils.clean(request.getContextPath());    }        if (path == null) {        path = ROOT_PATH;    }    log.trace("calculated path: {}", path);    return path;}
0
public void saveTo(HttpServletRequest request, HttpServletResponse response)
{    String name = getName();    String value = getValue();    String comment = getComment();    String domain = getDomain();    String path = calculatePath(request);    int maxAge = getMaxAge();    int version = getVersion();    boolean secure = isSecure();    boolean httpOnly = isHttpOnly();    SameSiteOptions sameSite = getSameSite();    addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly, sameSite);}
0
private void addCookieHeader(HttpServletResponse response, String name, String value, String comment, String domain, String path, int maxAge, int version, boolean secure, boolean httpOnly, SameSiteOptions sameSite)
{    String headerValue = buildHeaderValue(name, value, comment, domain, path, maxAge, version, secure, httpOnly, sameSite);    response.addHeader(COOKIE_HEADER_NAME, headerValue);    if (log.isDebugEnabled()) {            }}
1
protected String buildHeaderValue(String name, String value, String comment, String domain, String path, int maxAge, int version, boolean secure, boolean httpOnly)
{    return buildHeaderValue(name, value, comment, domain, path, maxAge, version, secure, httpOnly, getSameSite());}
0
protected String buildHeaderValue(String name, String value, String comment, String domain, String path, int maxAge, int version, boolean secure, boolean httpOnly, SameSiteOptions sameSite)
{    if (!StringUtils.hasText(name)) {        throw new IllegalStateException("Cookie name cannot be null/empty.");    }    StringBuilder sb = new StringBuilder(name).append(NAME_VALUE_DELIMITER);    if (StringUtils.hasText(value)) {        sb.append(value);    }    appendComment(sb, comment);    appendDomain(sb, domain);    appendPath(sb, path);    appendExpires(sb, maxAge);    appendVersion(sb, version);    appendSecure(sb, secure);    appendHttpOnly(sb, httpOnly);    appendSameSite(sb, sameSite);    return sb.toString();}
0
private void appendComment(StringBuilder sb, String comment)
{    if (StringUtils.hasText(comment)) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(COMMENT_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(comment);    }}
0
private void appendDomain(StringBuilder sb, String domain)
{    if (StringUtils.hasText(domain)) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(DOMAIN_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(domain);    }}
0
private void appendPath(StringBuilder sb, String path)
{    if (StringUtils.hasText(path)) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(PATH_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(path);    }}
0
private void appendExpires(StringBuilder sb, int maxAge)
{        if (maxAge >= 0) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(MAXAGE_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(maxAge);        sb.append(ATTRIBUTE_DELIMITER);        Date expires;        if (maxAge == 0) {                        expires = new Date(System.currentTimeMillis() - DAY_MILLIS);        } else {                        Calendar cal = Calendar.getInstance();            cal.add(Calendar.SECOND, maxAge);            expires = cal.getTime();        }        String formatted = toCookieDate(expires);        sb.append(EXPIRES_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(formatted);    }}
0
private void appendVersion(StringBuilder sb, int version)
{    if (version > DEFAULT_VERSION) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(VERSION_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(version);    }}
0
private void appendSecure(StringBuilder sb, boolean secure)
{    if (secure) {        sb.append(ATTRIBUTE_DELIMITER);                sb.append(SECURE_ATTRIBUTE_NAME);    }}
0
private void appendHttpOnly(StringBuilder sb, boolean httpOnly)
{    if (httpOnly) {        sb.append(ATTRIBUTE_DELIMITER);                sb.append(HTTP_ONLY_ATTRIBUTE_NAME);    }}
0
private void appendSameSite(StringBuilder sb, SameSiteOptions sameSite)
{    if (sameSite != null) {        sb.append(ATTRIBUTE_DELIMITER);        sb.append(SAME_SITE_ATTRIBUTE_NAME).append(NAME_VALUE_DELIMITER).append(sameSite.toString().toLowerCase(Locale.ENGLISH));    }}
0
private boolean pathMatches(String cookiePath, String requestPath)
{    if (!requestPath.startsWith(cookiePath)) {        return false;    }    return requestPath.length() == cookiePath.length() || cookiePath.charAt(cookiePath.length() - 1) == '/' || requestPath.charAt(cookiePath.length()) == '/';}
0
private static String toCookieDate(Date date)
{    TimeZone tz = TimeZone.getTimeZone(GMT_TIME_ZONE_ID);    DateFormat fmt = new SimpleDateFormat(COOKIE_DATE_FORMAT_STRING, Locale.US);    fmt.setTimeZone(tz);    return fmt.format(date);}
0
public void removeFrom(HttpServletRequest request, HttpServletResponse response)
{    String name = getName();    String value = DELETED_COOKIE_VALUE;        String comment = null;    String domain = getDomain();    String path = calculatePath(request);        int maxAge = 0;    int version = getVersion();    boolean secure = isSecure();        boolean httpOnly = false;    SameSiteOptions sameSite = null;    addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly, sameSite);    log.trace("Removed '{}' cookie by setting maxAge=0", name);}
0
public String readValue(HttpServletRequest request, HttpServletResponse ignored)
{    String name = getName();    String value = null;    javax.servlet.http.Cookie cookie = getCookie(request, name);    if (cookie != null) {                String path = StringUtils.clean(getPath());        if (path != null && !pathMatches(path, request.getRequestURI())) {                    } else {            value = cookie.getValue();                    }    } else {        log.trace("No '{}' cookie value", name);    }    return value;}
1
private static javax.servlet.http.Cookie getCookie(HttpServletRequest request, String cookieName)
{    javax.servlet.http.Cookie[] cookies = request.getCookies();    if (cookies != null) {        for (javax.servlet.http.Cookie cookie : cookies) {            if (cookie.getName().equals(cookieName)) {                return cookie;            }        }    }    return null;}
0
public Serializable getId()
{    return httpSession.getId();}
0
public Date getStartTimestamp()
{    return new Date(httpSession.getCreationTime());}
0
public Date getLastAccessTime()
{    return new Date(httpSession.getLastAccessedTime());}
0
public long getTimeout() throws InvalidSessionException
{    try {        return httpSession.getMaxInactiveInterval() * 1000L;    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException
{    try {        int timeout = Long.valueOf(maxIdleTimeInMillis / 1000).intValue();        httpSession.setMaxInactiveInterval(timeout);    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
protected void setHost(String host)
{    setAttribute(HOST_SESSION_KEY, host);}
0
public String getHost()
{    return (String) getAttribute(HOST_SESSION_KEY);}
0
public void touch() throws InvalidSessionException
{        try {        httpSession.setAttribute(TOUCH_OBJECT_SESSION_KEY, TOUCH_OBJECT_SESSION_KEY);        httpSession.removeAttribute(TOUCH_OBJECT_SESSION_KEY);    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public void stop() throws InvalidSessionException
{    try {        httpSession.invalidate();    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public Collection<Object> getAttributeKeys() throws InvalidSessionException
{    try {        Enumeration namesEnum = httpSession.getAttributeNames();        Collection<Object> keys = null;        if (namesEnum != null) {            keys = new ArrayList<Object>();            while (namesEnum.hasMoreElements()) {                keys.add(namesEnum.nextElement());            }        }        return keys;    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
private static String assertString(Object key)
{    if (!(key instanceof String)) {        String msg = "HttpSession based implementations of the Shiro Session interface requires attribute keys " + "to be String objects.  The HttpSession class does not support anything other than String keys.";        throw new IllegalArgumentException(msg);    }    return (String) key;}
0
public Object getAttribute(Object key) throws InvalidSessionException
{    try {        return httpSession.getAttribute(assertString(key));    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public void setAttribute(Object key, Object value) throws InvalidSessionException
{    try {        httpSession.setAttribute(assertString(key), value);    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public Object removeAttribute(Object key) throws InvalidSessionException
{    try {        String sKey = assertString(key);        Object removed = httpSession.getAttribute(sKey);        httpSession.removeAttribute(sKey);        return removed;    } catch (Exception e) {        throw new InvalidSessionException(e);    }}
0
public void setServletRequest(ServletRequest request)
{    if (request != null) {        put(SERVLET_REQUEST, request);    }}
0
public ServletRequest getServletRequest()
{    return getTypedValue(SERVLET_REQUEST, ServletRequest.class);}
0
public void setServletResponse(ServletResponse response)
{    if (response != null) {        put(SERVLET_RESPONSE, response);    }}
0
public ServletResponse getServletResponse()
{    return getTypedValue(SERVLET_RESPONSE, ServletResponse.class);}
0
public Cookie getSessionIdCookie()
{    return sessionIdCookie;}
0
public void setSessionIdCookie(Cookie sessionIdCookie)
{    this.sessionIdCookie = sessionIdCookie;}
0
public boolean isSessionIdCookieEnabled()
{    return sessionIdCookieEnabled;}
0
public void setSessionIdCookieEnabled(boolean sessionIdCookieEnabled)
{    this.sessionIdCookieEnabled = sessionIdCookieEnabled;}
0
public boolean isSessionIdUrlRewritingEnabled()
{    return sessionIdUrlRewritingEnabled;}
0
public void setSessionIdUrlRewritingEnabled(boolean sessionIdUrlRewritingEnabled)
{    this.sessionIdUrlRewritingEnabled = sessionIdUrlRewritingEnabled;}
0
private void storeSessionId(Serializable currentId, HttpServletRequest request, HttpServletResponse response)
{    if (currentId == null) {        String msg = "sessionId cannot be null when persisting for subsequent requests.";        throw new IllegalArgumentException(msg);    }    Cookie template = getSessionIdCookie();    Cookie cookie = new SimpleCookie(template);    String idString = currentId.toString();    cookie.setValue(idString);    cookie.saveTo(request, response);    log.trace("Set session ID cookie for session with id {}", idString);}
0
private void removeSessionIdCookie(HttpServletRequest request, HttpServletResponse response)
{    getSessionIdCookie().removeFrom(request, response);}
0
private String getSessionIdCookieValue(ServletRequest request, ServletResponse response)
{    if (!isSessionIdCookieEnabled()) {                return null;    }    if (!(request instanceof HttpServletRequest)) {                return null;    }    HttpServletRequest httpRequest = (HttpServletRequest) request;    return getSessionIdCookie().readValue(httpRequest, WebUtils.toHttp(response));}
1
private Serializable getReferencedSessionId(ServletRequest request, ServletResponse response)
{    String id = getSessionIdCookieValue(request, response);    if (id != null) {        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE);    } else {                        id = getUriPathSegmentParamValue(request, ShiroHttpSession.DEFAULT_SESSION_ID_NAME);        if (id == null) {                        String name = getSessionIdName();            id = request.getParameter(name);            if (id == null) {                                id = request.getParameter(name.toLowerCase());            }        }        if (id != null) {            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);        }    }    if (id != null) {        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);                        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);    }        request.setAttribute(ShiroHttpServletRequest.SESSION_ID_URL_REWRITING_ENABLED, isSessionIdUrlRewritingEnabled());    return id;}
0
private String getUriPathSegmentParamValue(ServletRequest servletRequest, String paramName)
{    if (!(servletRequest instanceof HttpServletRequest)) {        return null;    }    HttpServletRequest request = (HttpServletRequest) servletRequest;    String uri = request.getRequestURI();    if (uri == null) {        return null;    }    int queryStartIndex = uri.indexOf('?');    if (queryStartIndex >= 0) {                uri = uri.substring(0, queryStartIndex);    }        int index = uri.indexOf(';');    if (index < 0) {                return null;    }        final String TOKEN = paramName + "=";        uri = uri.substring(index + 1);        index = uri.lastIndexOf(TOKEN);    if (index < 0) {                return null;    }    uri = uri.substring(index + TOKEN.length());        index = uri.indexOf(';');    if (index >= 0) {        uri = uri.substring(0, index);    }        return uri;}
0
private String getSessionIdName()
{    String name = this.sessionIdCookie != null ? this.sessionIdCookie.getName() : null;    if (name == null) {        name = ShiroHttpSession.DEFAULT_SESSION_ID_NAME;    }    return name;}
0
protected Session createExposedSession(Session session, SessionContext context)
{    if (!WebUtils.isWeb(context)) {        return super.createExposedSession(session, context);    }    ServletRequest request = WebUtils.getRequest(context);    ServletResponse response = WebUtils.getResponse(context);    SessionKey key = new WebSessionKey(session.getId(), request, response);    return new DelegatingSession(this, key);}
0
protected Session createExposedSession(Session session, SessionKey key)
{    if (!WebUtils.isWeb(key)) {        return super.createExposedSession(session, key);    }    ServletRequest request = WebUtils.getRequest(key);    ServletResponse response = WebUtils.getResponse(key);    SessionKey sessionKey = new WebSessionKey(session.getId(), request, response);    return new DelegatingSession(this, sessionKey);}
0
protected void onStart(Session session, SessionContext context)
{    super.onStart(session, context);    if (!WebUtils.isHttp(context)) {                return;    }    HttpServletRequest request = WebUtils.getHttpRequest(context);    HttpServletResponse response = WebUtils.getHttpResponse(context);    if (isSessionIdCookieEnabled()) {        Serializable sessionId = session.getId();        storeSessionId(sessionId, request, response);    } else {            }    request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);    request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);}
1
public Serializable getSessionId(SessionKey key)
{    Serializable id = super.getSessionId(key);    if (id == null && WebUtils.isWeb(key)) {        ServletRequest request = WebUtils.getRequest(key);        ServletResponse response = WebUtils.getResponse(key);        id = getSessionId(request, response);    }    return id;}
0
protected Serializable getSessionId(ServletRequest request, ServletResponse response)
{    return getReferencedSessionId(request, response);}
0
protected void onExpiration(Session s, ExpiredSessionException ese, SessionKey key)
{    super.onExpiration(s, ese, key);    onInvalidation(key);}
0
protected void onInvalidation(Session session, InvalidSessionException ise, SessionKey key)
{    super.onInvalidation(session, ise, key);    onInvalidation(key);}
0
private void onInvalidation(SessionKey key)
{    ServletRequest request = WebUtils.getRequest(key);    if (request != null) {        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);    }    if (WebUtils.isHttp(key)) {                removeSessionIdCookie(WebUtils.getHttpRequest(key), WebUtils.getHttpResponse(key));    } else {            }}
1
protected void onStop(Session session, SessionKey key)
{    super.onStop(session, key);    if (WebUtils.isHttp(key)) {        HttpServletRequest request = WebUtils.getHttpRequest(key);        HttpServletResponse response = WebUtils.getHttpResponse(key);                removeSessionIdCookie(request, response);    } else {            }}
1
public boolean isServletContainerSessions()
{    return false;}
0
public Session start(SessionContext context) throws AuthorizationException
{    return createSession(context);}
0
public Session getSession(SessionKey key) throws SessionException
{    if (!WebUtils.isHttp(key)) {        String msg = "SessionKey must be an HTTP compatible implementation.";        throw new IllegalArgumentException(msg);    }    HttpServletRequest request = WebUtils.getHttpRequest(key);    Session session = null;    HttpSession httpSession = request.getSession(false);    if (httpSession != null) {        session = createSession(httpSession, request.getRemoteHost());    }    return session;}
0
private String getHost(SessionContext context)
{    String host = context.getHost();    if (host == null) {        ServletRequest request = WebUtils.getRequest(context);        if (request != null) {            host = request.getRemoteHost();        }    }    return host;}
0
protected Session createSession(SessionContext sessionContext) throws AuthorizationException
{    if (!WebUtils.isHttp(sessionContext)) {        String msg = "SessionContext must be an HTTP compatible implementation.";        throw new IllegalArgumentException(msg);    }    HttpServletRequest request = WebUtils.getHttpRequest(sessionContext);    HttpSession httpSession = request.getSession();            String host = getHost(sessionContext);    return createSession(httpSession, host);}
0
protected Session createSession(HttpSession httpSession, String host)
{    return new HttpServletSession(httpSession, host);}
0
public boolean isServletContainerSessions()
{    return true;}
0
public ServletRequest getServletRequest()
{    return servletRequest;}
0
public ServletResponse getServletResponse()
{    return servletResponse;}
0
public String resolveHost()
{    String host = super.resolveHost();    if (host == null) {        ServletRequest request = resolveServletRequest();        if (request != null) {            host = request.getRemoteHost();        }    }    return host;}
0
public ServletRequest getServletRequest()
{    return getTypedValue(SERVLET_REQUEST, ServletRequest.class);}
0
public void setServletRequest(ServletRequest request)
{    if (request != null) {        put(SERVLET_REQUEST, request);    }}
0
public ServletRequest resolveServletRequest()
{    ServletRequest request = getServletRequest();        if (request == null) {        Subject existing = getSubject();        if (existing instanceof WebSubject) {            request = ((WebSubject) existing).getServletRequest();        }    }    return request;}
0
public ServletResponse getServletResponse()
{    return getTypedValue(SERVLET_RESPONSE, ServletResponse.class);}
0
public void setServletResponse(ServletResponse response)
{    if (response != null) {        put(SERVLET_RESPONSE, response);    }}
0
public ServletResponse resolveServletResponse()
{    ServletResponse response = getServletResponse();        if (response == null) {        Subject existing = getSubject();        if (existing instanceof WebSubject) {            response = ((WebSubject) existing).getServletResponse();        }    }    return response;}
0
public ServletRequest getServletRequest()
{    return servletRequest;}
0
public ServletResponse getServletResponse()
{    return servletResponse;}
0
protected boolean isSessionCreationEnabled()
{    boolean enabled = super.isSessionCreationEnabled();    return enabled && WebUtils._isSessionCreationEnabled(this);}
0
protected SessionContext createSessionContext()
{    WebSessionContext wsc = new DefaultWebSessionContext();    String host = getHost();    if (StringUtils.hasText(host)) {        wsc.setHost(host);    }    wsc.setServletRequest(this.servletRequest);    wsc.setServletResponse(this.servletResponse);    return wsc;}
0
protected SubjectContext newSubjectContextInstance()
{    return new DefaultWebSubjectContext();}
0
protected Builder setRequest(ServletRequest request)
{    if (request != null) {        ((WebSubjectContext) getSubjectContext()).setServletRequest(request);    }    return this;}
0
protected Builder setResponse(ServletResponse response)
{    if (response != null) {        ((WebSubjectContext) getSubjectContext()).setServletResponse(response);    }    return this;}
0
public WebSubject buildWebSubject()
{    Subject subject = super.buildSubject();    if (!(subject instanceof WebSubject)) {        String msg = "Subject implementation returned from the SecurityManager was not a " + WebSubject.class.getName() + " implementation.  Please ensure a Web-enabled SecurityManager " + "has been configured and made available to this builder.";        throw new IllegalStateException(msg);    }    return (WebSubject) subject;}
0
public int onDoStartTag() throws JspException
{    if (getSubject() != null && getSubject().isAuthenticated()) {        if (log.isTraceEnabled()) {            log.trace("Subject exists and is authenticated.  Tag body will be evaluated.");        }        return TagSupport.EVAL_BODY_INCLUDE;    } else {        if (log.isTraceEnabled()) {            log.trace("Subject does not exist or is not authenticated.  Tag body will not be evaluated.");        }        return TagSupport.SKIP_BODY;    }}
0
public int onDoStartTag() throws JspException
{    if (getSubject() == null || getSubject().getPrincipal() == null) {        if (log.isTraceEnabled()) {            log.trace("Subject does not exist or does not have a known identity (aka 'principal').  " + "Tag body will be evaluated.");        }        return TagSupport.EVAL_BODY_INCLUDE;    } else {        if (log.isTraceEnabled()) {            log.trace("Subject exists or has a known identity (aka 'principal').  " + "Tag body will not be evaluated.");        }        return TagSupport.SKIP_BODY;    }}
0
protected boolean showTagBody(String roleNames)
{    boolean hasAnyRole = false;    Subject subject = getSubject();    if (subject != null) {                for (String role : roleNames.split(ROLE_NAMES_DELIMETER)) {            if (subject.hasRole(role.trim())) {                hasAnyRole = true;                break;            }        }    }    return hasAnyRole;}
0
protected boolean showTagBody(String p)
{    return isPermitted(p);}
0
protected boolean showTagBody(String roleName)
{    return getSubject() != null && getSubject().hasRole(roleName);}
0
protected boolean showTagBody(String p)
{    return !isPermitted(p);}
0
protected boolean showTagBody(String roleName)
{    boolean hasRole = getSubject() != null && getSubject().hasRole(roleName);    return !hasRole;}
0
public int onDoStartTag() throws JspException
{    if (getSubject() == null || !getSubject().isAuthenticated()) {        if (log.isTraceEnabled()) {            log.trace("Subject does not exist or is not authenticated.  Tag body will be evaluated.");        }        return TagSupport.EVAL_BODY_INCLUDE;    } else {        if (log.isTraceEnabled()) {            log.trace("Subject exists and is authenticated.  Tag body will not be evaluated.");        }        return TagSupport.SKIP_BODY;    }}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
protected void verifyAttributes() throws JspException
{    String permission = getName();    if (permission == null || permission.length() == 0) {        String msg = "The 'name' tag attribute must be set.";        throw new JspException(msg);    }}
0
public int onDoStartTag() throws JspException
{    String p = getName();    boolean show = showTagBody(p);    if (show) {        return TagSupport.EVAL_BODY_INCLUDE;    } else {        return TagSupport.SKIP_BODY;    }}
0
protected boolean isPermitted(String p)
{    return getSubject() != null && getSubject().isPermitted(p);}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public String getProperty()
{    return property;}
0
public void setProperty(String property)
{    this.property = property;}
0
public String getDefaultValue()
{    return defaultValue;}
0
public void setDefaultValue(String defaultValue)
{    this.defaultValue = defaultValue;}
0
public int onDoStartTag() throws JspException
{    String strValue = null;    if (getSubject() != null) {                Object principal;        if (type == null) {            principal = getSubject().getPrincipal();        } else {            principal = getPrincipalFromClassName();        }                if (principal != null) {            if (property == null) {                strValue = principal.toString();            } else {                strValue = getPrincipalProperty(principal, property);            }        }    }        if (strValue != null) {        try {            pageContext.getOut().write(strValue);        } catch (IOException e) {            throw new JspTagException("Error writing [" + strValue + "] to JSP.", e);        }    }    return SKIP_BODY;}
0
private Object getPrincipalFromClassName()
{    Object principal = null;    try {        Class cls = Class.forName(type);        principal = getSubject().getPrincipals().oneByType(cls);    } catch (ClassNotFoundException e) {        if (log.isErrorEnabled()) {                    }    }    return principal;}
1
private String getPrincipalProperty(Object principal, String property) throws JspTagException
{    String strValue = null;    try {        BeanInfo bi = Introspector.getBeanInfo(principal.getClass());                boolean foundProperty = false;        for (PropertyDescriptor pd : bi.getPropertyDescriptors()) {            if (pd.getName().equals(property)) {                Object value = pd.getReadMethod().invoke(principal, (Object[]) null);                strValue = String.valueOf(value);                foundProperty = true;                break;            }        }        if (!foundProperty) {            final String message = "Property [" + property + "] not found in principal of type [" + principal.getClass().getName() + "]";            if (log.isErrorEnabled()) {                            }            throw new JspTagException(message);        }    } catch (Exception e) {        final String message = "Error reading property [" + property + "] from principal of type [" + principal.getClass().getName() + "]";        if (log.isErrorEnabled()) {                    }        throw new JspTagException(message, e);    }    return strValue;}
1
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public int onDoStartTag() throws JspException
{    boolean show = showTagBody(getName());    if (show) {        return TagSupport.EVAL_BODY_INCLUDE;    } else {        return TagSupport.SKIP_BODY;    }}
0
protected Subject getSubject()
{    return SecurityUtils.getSubject();}
0
protected void verifyAttributes() throws JspException
{}
0
public int doStartTag() throws JspException
{    verifyAttributes();    return onDoStartTag();}
0
public int onDoStartTag() throws JspException
{    if (getSubject() != null && getSubject().getPrincipal() != null) {        if (log.isTraceEnabled()) {            log.trace("Subject has known identity (aka 'principal').  " + "Tag body will be evaluated.");        }        return EVAL_BODY_INCLUDE;    } else {        if (log.isTraceEnabled()) {            log.trace("Subject does not exist or have a known identity (aka 'principal').  " + "Tag body will not be evaluated.");        }        return SKIP_BODY;    }}
0
public String getUrl()
{    return url;}
0
public void setUrl(String url)
{    this.url = url;}
0
public void setContextRelative(boolean contextRelative)
{    this.contextRelative = contextRelative;}
0
public void setHttp10Compatible(boolean http10Compatible)
{    this.http10Compatible = http10Compatible;}
0
public void setEncodingScheme(String encodingScheme)
{    this.encodingScheme = encodingScheme;}
0
public final void renderMergedOutputModel(Map model, HttpServletRequest request, HttpServletResponse response) throws IOException
{        StringBuilder targetUrl = new StringBuilder();    if (this.contextRelative && getUrl().startsWith("/")) {                targetUrl.append(request.getContextPath());    }    targetUrl.append(getUrl());        appendQueryProperties(targetUrl, model, this.encodingScheme);    sendRedirect(request, response, targetUrl.toString(), this.http10Compatible);}
0
protected void appendQueryProperties(StringBuilder targetUrl, Map model, String encodingScheme) throws UnsupportedEncodingException
{                String fragment = null;    int anchorIndex = targetUrl.toString().indexOf('#');    if (anchorIndex > -1) {        fragment = targetUrl.substring(anchorIndex);        targetUrl.delete(anchorIndex, targetUrl.length());    }        boolean first = (getUrl().indexOf('?') < 0);    Map queryProps = queryProperties(model);    if (queryProps != null) {        for (Object o : queryProps.entrySet()) {            if (first) {                targetUrl.append('?');                first = false;            } else {                targetUrl.append('&');            }            Map.Entry entry = (Map.Entry) o;            String encodedKey = urlEncode(entry.getKey().toString(), encodingScheme);            String encodedValue = (entry.getValue() != null ? urlEncode(entry.getValue().toString(), encodingScheme) : "");            targetUrl.append(encodedKey).append('=').append(encodedValue);        }    }        if (fragment != null) {        targetUrl.append(fragment);    }}
0
protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException
{    return URLEncoder.encode(input, encodingScheme);}
0
protected Map queryProperties(Map model)
{    return model;}
0
protected void sendRedirect(HttpServletRequest request, HttpServletResponse response, String targetUrl, boolean http10Compatible) throws IOException
{    if (http10Compatible) {                response.sendRedirect(response.encodeRedirectURL(targetUrl));    } else {                response.setStatus(303);        response.setHeader("Location", response.encodeRedirectURL(targetUrl));    }}
0
public String getMethod()
{    return method;}
0
public String getQueryString()
{    return queryString;}
0
public String getRequestURI()
{    return requestURI;}
0
public String getRequestUrl()
{    StringBuilder requestUrl = new StringBuilder(getRequestURI());    if (getQueryString() != null) {        requestUrl.append("?").append(getQueryString());    }    return requestUrl.toString();}
0
public static String getPathWithinApplication(HttpServletRequest request)
{    String contextPath = getContextPath(request);    String requestUri = getRequestUri(request);    if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {                String path = requestUri.substring(contextPath.length());        return (StringUtils.hasText(path) ? path : "/");    } else {                return requestUri;    }}
0
public static String getRequestUri(HttpServletRequest request)
{    String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);    if (uri == null) {        uri = request.getRequestURI();    }    return normalize(decodeAndCleanUriString(request, uri));}
0
public static String normalize(String path)
{    return normalize(path, true);}
0
private static String normalize(String path, boolean replaceBackSlash)
{    if (path == null)        return null;        String normalized = path;    if (replaceBackSlash && normalized.indexOf('\\') >= 0)        normalized = normalized.replace('\\', '/');    if (normalized.equals("/."))        return "/";        if (!normalized.startsWith("/"))        normalized = "/" + normalized;        while (true) {        int index = normalized.indexOf("//");        if (index < 0)            break;        normalized = normalized.substring(0, index) + normalized.substring(index + 1);    }        while (true) {        int index = normalized.indexOf("/./");        if (index < 0)            break;        normalized = normalized.substring(0, index) + normalized.substring(index + 2);    }        while (true) {        int index = normalized.indexOf("/../");        if (index < 0)            break;        if (index == 0)                        return (null);        int index2 = normalized.lastIndexOf('/', index - 1);        normalized = normalized.substring(0, index2) + normalized.substring(index + 3);    }        return (normalized);}
0
private static String decodeAndCleanUriString(HttpServletRequest request, String uri)
{    uri = decodeRequestString(request, uri);    int semicolonIndex = uri.indexOf(';');    return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);}
0
public static String getContextPath(HttpServletRequest request)
{    String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);    if (contextPath == null) {        contextPath = request.getContextPath();    }    contextPath = normalize(decodeRequestString(request, contextPath));    if ("/".equals(contextPath)) {                contextPath = "";    }    return contextPath;}
0
public static WebEnvironment getRequiredWebEnvironment(ServletContext sc) throws IllegalStateException
{    WebEnvironment we = getWebEnvironment(sc);    if (we == null) {        throw new IllegalStateException("No WebEnvironment found: no EnvironmentLoaderListener registered?");    }    return we;}
0
public static WebEnvironment getWebEnvironment(ServletContext sc)
{    return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);}
0
public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName)
{    if (sc == null) {        throw new IllegalArgumentException("ServletContext argument must not be null.");    }    Object attr = sc.getAttribute(attrName);    if (attr == null) {        return null;    }    if (attr instanceof RuntimeException) {        throw (RuntimeException) attr;    }    if (attr instanceof Error) {        throw (Error) attr;    }    if (attr instanceof Exception) {        throw new IllegalStateException((Exception) attr);    }    if (!(attr instanceof WebEnvironment)) {        throw new IllegalStateException("Context attribute is not of type WebEnvironment: " + attr);    }    return (WebEnvironment) attr;}
0
protected static String determineEncoding(HttpServletRequest request)
{    String enc = request.getCharacterEncoding();    if (enc == null) {        enc = DEFAULT_CHARACTER_ENCODING;    }    return enc;}
0
public static boolean isWeb(Object requestPairSource)
{    return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);}
0
public static boolean isHttp(Object requestPairSource)
{    return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);}
0
public static ServletRequest getRequest(Object requestPairSource)
{    if (requestPairSource instanceof RequestPairSource) {        return ((RequestPairSource) requestPairSource).getServletRequest();    }    return null;}
0
public static ServletResponse getResponse(Object requestPairSource)
{    if (requestPairSource instanceof RequestPairSource) {        return ((RequestPairSource) requestPairSource).getServletResponse();    }    return null;}
0
public static HttpServletRequest getHttpRequest(Object requestPairSource)
{    ServletRequest request = getRequest(requestPairSource);    if (request instanceof HttpServletRequest) {        return (HttpServletRequest) request;    }    return null;}
0
public static HttpServletResponse getHttpResponse(Object requestPairSource)
{    ServletResponse response = getResponse(requestPairSource);    if (response instanceof HttpServletResponse) {        return (HttpServletResponse) response;    }    return null;}
0
private static boolean isWeb(RequestPairSource source)
{    ServletRequest request = source.getServletRequest();    ServletResponse response = source.getServletResponse();    return request != null && response != null;}
0
private static boolean isHttp(RequestPairSource source)
{    ServletRequest request = source.getServletRequest();    ServletResponse response = source.getServletResponse();    return request instanceof HttpServletRequest && response instanceof HttpServletResponse;}
0
public static boolean _isSessionCreationEnabled(Object requestPairSource)
{    if (requestPairSource instanceof RequestPairSource) {        RequestPairSource source = (RequestPairSource) requestPairSource;        return _isSessionCreationEnabled(source.getServletRequest());    }        return true;}
0
public static boolean _isSessionCreationEnabled(ServletRequest request)
{    if (request != null) {        Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);        if (val != null && val instanceof Boolean) {            return (Boolean) val;        }    }        return true;}
0
public static HttpServletRequest toHttp(ServletRequest request)
{    return (HttpServletRequest) request;}
0
public static HttpServletResponse toHttp(ServletResponse response)
{    return (HttpServletResponse) response;}
0
public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException
{    RedirectView view = new RedirectView(url, contextRelative, http10Compatible);    view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));}
0
public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException
{    issueRedirect(request, response, url, null, true, true);}
0
public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException
{    issueRedirect(request, response, url, queryParams, true, true);}
0
public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException
{    issueRedirect(request, response, url, queryParams, contextRelative, true);}
0
public static boolean isTrue(ServletRequest request, String paramName)
{    String value = getCleanParam(request, paramName);    return value != null && (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("t") || value.equalsIgnoreCase("1") || value.equalsIgnoreCase("enabled") || value.equalsIgnoreCase("y") || value.equalsIgnoreCase("yes") || value.equalsIgnoreCase("on"));}
0
public static String getCleanParam(ServletRequest request, String paramName)
{    return StringUtils.clean(request.getParameter(paramName));}
0
public static void saveRequest(ServletRequest request)
{    Subject subject = SecurityUtils.getSubject();    Session session = subject.getSession();    HttpServletRequest httpRequest = toHttp(request);    SavedRequest savedRequest = new SavedRequest(httpRequest);    session.setAttribute(SAVED_REQUEST_KEY, savedRequest);}
0
public static SavedRequest getAndClearSavedRequest(ServletRequest request)
{    SavedRequest savedRequest = getSavedRequest(request);    if (savedRequest != null) {        Subject subject = SecurityUtils.getSubject();        Session session = subject.getSession();        session.removeAttribute(SAVED_REQUEST_KEY);    }    return savedRequest;}
0
public static SavedRequest getSavedRequest(ServletRequest request)
{    SavedRequest savedRequest = null;    Subject subject = SecurityUtils.getSubject();    Session session = subject.getSession(false);    if (session != null) {        savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);    }    return savedRequest;}
0
public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl) throws IOException
{    String successUrl = null;    boolean contextRelative = true;    SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);    if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {        successUrl = savedRequest.getRequestUrl();        contextRelative = false;    }    if (successUrl == null) {        successUrl = fallbackUrl;    }    if (successUrl == null) {        throw new IllegalStateException("Success URL not available via saved request or via the " + "successUrlFallback method parameter. One of these must be non-null for " + "issueSuccessRedirect() to work.");    }    WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);}
0
public void testDefaultFiltersPresent()
{    Ini ini = new Ini();            Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);    section.put("authc.loginUrl", "/login.jsp");    WebIniSecurityManagerFactory factory = new WebIniSecurityManagerFactory(ini);    org.apache.shiro.mgt.SecurityManager sm = factory.getInstance();    assertNotNull(sm);    assertTrue(sm instanceof DefaultWebSecurityManager);        Map<String, ?> beans = factory.getBeans();    for (DefaultFilter defaultFilter : DefaultFilter.values()) {        Filter filter = (Filter) beans.get(defaultFilter.name());        assertNotNull(filter);        assertTrue(defaultFilter.getFilterClass().isAssignableFrom(filter.getClass()));    }}
0
public void singleServiceTest() throws Exception
{    List<WebEnvironmentStub> environmentList = Arrays.asList(new WebEnvironmentStub());    ServletContext servletContext = EasyMock.mock(ServletContext.class);    expect(servletContext.getInitParameter("shiroEnvironmentClass")).andReturn(null);    expect(servletContext.getInitParameter("shiroConfigLocations")).andReturn(null);    PowerMock.mockStaticPartialStrict(ServiceLoader.class, "load");    final ServiceLoader serviceLoader = PowerMock.createMock(ServiceLoader.class);    EasyMock.expect(ServiceLoader.load(WebEnvironment.class)).andReturn(serviceLoader);    EasyMock.expect(serviceLoader.iterator()).andReturn(environmentList.iterator());    EasyMock.replay(servletContext);    PowerMock.replayAll();    WebEnvironment resultEnvironment = new EnvironmentLoader().createEnvironment(servletContext);    PowerMock.verifyAll();    EasyMock.verify(servletContext);    assertThat(resultEnvironment, instanceOf(WebEnvironmentStub.class));    WebEnvironmentStub environmentStub = (WebEnvironmentStub) resultEnvironment;    assertThat(environmentStub.getServletContext(), sameInstance(servletContext));}
0
public void multipleServiceTest() throws Exception
{    List<WebEnvironmentStub> environmentList = Arrays.asList(new WebEnvironmentStub(), new WebEnvironmentStub());    ServletContext servletContext = EasyMock.mock(ServletContext.class);    expect(servletContext.getInitParameter("shiroEnvironmentClass")).andReturn(null);    PowerMock.mockStaticPartialStrict(ServiceLoader.class, "load");    final ServiceLoader serviceLoader = PowerMock.createMock(ServiceLoader.class);    EasyMock.expect(ServiceLoader.load(WebEnvironment.class)).andReturn(serviceLoader);    EasyMock.expect(serviceLoader.iterator()).andReturn(environmentList.iterator());    EasyMock.replay(servletContext);    PowerMock.replayAll();    try {        new EnvironmentLoader().createEnvironment(servletContext);        Assert.fail("Expected ConfigurationException to be thrown");    } catch (ConfigurationException e) {        assertThat(e.getMessage(), stringContainsInOrder("zero or exactly one", "shiroEnvironmentClass"));    }    PowerMock.verifyAll();    EasyMock.verify(servletContext);}
0
public void loadFromInitParamTest() throws Exception
{    ServletContext servletContext = EasyMock.mock(ServletContext.class);    expect(servletContext.getInitParameter("shiroEnvironmentClass")).andReturn(WebEnvironmentStub.class.getName());    expect(servletContext.getInitParameter("shiroConfigLocations")).andReturn(null);    PowerMock.mockStaticPartialStrict(ServiceLoader.class, "load");    EasyMock.replay(servletContext);    PowerMock.replayAll();    WebEnvironment resultEnvironment = new EnvironmentLoader().createEnvironment(servletContext);    PowerMock.verifyAll();    EasyMock.verify(servletContext);    assertThat(resultEnvironment, instanceOf(WebEnvironmentStub.class));    WebEnvironmentStub environmentStub = (WebEnvironmentStub) resultEnvironment;    assertThat(environmentStub.getServletContext(), sameInstance(servletContext));}
0
public FilterChainResolver getFilterChainResolver()
{    return filterChainResolver;}
0
public void setFilterChainResolver(FilterChainResolver filterChainResolver)
{    this.filterChainResolver = filterChainResolver;}
0
public ServletContext getServletContext()
{    return servletContext;}
0
public void setServletContext(ServletContext servletContext)
{    this.servletContext = servletContext;}
0
public WebSecurityManager getWebSecurityManager()
{    return webSecurityManager;}
0
public void setWebSecurityManager(WebSecurityManager webSecurityManager)
{    this.webSecurityManager = webSecurityManager;}
0
public SecurityManager getSecurityManager()
{    return getWebSecurityManager();}
0
public void test()
{    AnonymousFilter filter = new AnonymousFilter();    boolean allow = filter.onPreHandle(null, null, null);    assertTrue(allow);}
0
public void setUp()
{}
0
public void createTokenNoAuthorizationHeader() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(null);    expect(request.getRemoteHost()).andReturn("localhost");    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(request);    replay(response);    AuthenticationToken token = testFilter.createToken(request, response);    assertNotNull(token);    assertTrue("Token is not a username and password token.", token instanceof UsernamePasswordToken);    assertEquals("", token.getPrincipal());    verify(request);    verify(response);}
0
public void createTokenNoUsername() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("", ""));    expect(request.getRemoteHost()).andReturn("localhost");    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(request);    replay(response);    AuthenticationToken token = testFilter.createToken(request, response);    assertNotNull(token);    assertTrue("Token is not a username and password token.", token instanceof UsernamePasswordToken);    assertEquals("", token.getPrincipal());    verify(request);    verify(response);}
0
public void createTokenNoPassword() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", ""));    expect(request.getRemoteHost()).andReturn("localhost");    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(request);    replay(response);    AuthenticationToken token = testFilter.createToken(request, response);    assertNotNull(token);    assertTrue("Token is not a username and password token.", token instanceof UsernamePasswordToken);    UsernamePasswordToken upToken = (UsernamePasswordToken) token;    assertEquals("pedro", upToken.getUsername());    assertEquals("Password is not empty.", 0, upToken.getPassword().length);    verify(request);    verify(response);}
0
public void createTokenColonInPassword() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", "pass:word"));    expect(request.getRemoteHost()).andReturn("localhost");    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(request);    replay(response);    AuthenticationToken token = testFilter.createToken(request, response);    assertNotNull(token);    assertTrue("Token is not a username and password token.", token instanceof UsernamePasswordToken);    UsernamePasswordToken upToken = (UsernamePasswordToken) token;    assertEquals("pedro", upToken.getUsername());    assertEquals("pass:word", new String(upToken.getPassword()));    verify(request);    verify(response);}
0
public void httpMethodDoesNotRequireAuthentication() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getMethod()).andReturn("GET");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, new String[] { "POST", "PUT", "DELETE" });    assertTrue("Access not allowed for GET", accessAllowed);}
0
public void httpMethodRequiresAuthentication() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", ""));    expect(request.getRemoteHost()).andReturn("localhost");    expect(request.getMethod()).andReturn("POST");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, new String[] { "POST", "PUT", "DELETE" });    assertTrue("Access allowed for POST", !accessAllowed);}
0
public void httpMethodsAreCaseInsensitive() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getMethod()).andReturn("GET");    expect(request.getMethod()).andReturn("post");    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", "")).anyTimes();    expect(request.getRemoteHost()).andReturn("localhost").anyTimes();    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, new String[] { "POST", "put", "delete" });    assertTrue("Access not allowed for GET", accessAllowed);    accessAllowed = testFilter.isAccessAllowed(request, response, new String[] { "post", "put", "delete" });    assertTrue("Access allowed for POST", !accessAllowed);}
0
public void allHttpMethodsRequireAuthenticationIfNoneConfigured() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", "")).anyTimes();    expect(request.getRemoteHost()).andReturn("localhost").anyTimes();    expect(request.getMethod()).andReturn("GET");    expect(request.getMethod()).andReturn("POST");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, new String[0]);    assertTrue("Access allowed for GET", !accessAllowed);    accessAllowed = testFilter.isAccessAllowed(request, response, new String[0]);    assertTrue("Access allowed for POST", !accessAllowed);}
0
public void allHttpMethodsRequireAuthenticationIfNullConfig() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", "")).anyTimes();    expect(request.getRemoteHost()).andReturn("localhost").anyTimes();    expect(request.getMethod()).andReturn("GET");    expect(request.getMethod()).andReturn("POST");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, null);    assertTrue("Access allowed for GET", !accessAllowed);    accessAllowed = testFilter.isAccessAllowed(request, response, null);    assertTrue("Access allowed for POST", !accessAllowed);}
0
public void permissiveEnabledWithLoginTest()
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", "")).anyTimes();    expect(request.getRemoteHost()).andReturn("localhost").anyTimes();    expect(request.getMethod()).andReturn("GET");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    String[] mappedValue = { "permissive" };    boolean accessAllowed = testFilter.isAccessAllowed(request, response, mappedValue);        assertTrue("Access allowed for GET", !accessAllowed);}
0
public void permissiveEnabledTest()
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(null).anyTimes();    expect(request.getRemoteHost()).andReturn("localhost").anyTimes();    expect(request.getMethod()).andReturn("GET");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    String[] mappedValue = { "permissive" };    boolean accessAllowed = testFilter.isAccessAllowed(request, response, mappedValue);        assertTrue("Access should be allowed for GET", accessAllowed);}
0
public void httpMethodRequiresAuthenticationWithPermissive() throws Exception
{    testFilter = new BasicHttpAuthenticationFilter();    HttpServletRequest request = createMock(HttpServletRequest.class);    expect(request.getHeader("Authorization")).andReturn(createAuthorizationHeader("pedro", ""));    expect(request.getRemoteHost()).andReturn("localhost");    expect(request.getMethod()).andReturn("POST");    replay(request);    HttpServletResponse response = createMock(HttpServletResponse.class);    replay(response);    boolean accessAllowed = testFilter.isAccessAllowed(request, response, new String[] { "permissive", "POST", "PUT", "DELETE" });    assertTrue("Access allowed for POST", !accessAllowed);}
0
private String createAuthorizationHeader(String username, String password)
{    return "Basic " + new String(Base64.encode((username + ":" + password).getBytes()));}
0
public void testUserOnAccessDeniedWithResponseError() throws IOException
{                SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));    AuthorizationFilter filter = new AuthorizationFilter() {        @Override        protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {                        return false;        }    };    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);    replay(response);    filter.onAccessDenied(request, response);    verify(response);}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{        return false;}
0
public void testUserOnAccessDeniedWithRedirect() throws IOException
{                SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));    String unauthorizedUrl = "unauthorized.jsp";    AuthorizationFilter filter = new AuthorizationFilter() {        @Override        protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {                        return false;        }    };    filter.setUnauthorizedUrl(unauthorizedUrl);    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    expect(request.getContextPath()).andReturn("/").anyTimes();    String encoded = "/" + unauthorizedUrl;    expect(response.encodeRedirectURL(unauthorizedUrl)).andReturn(encoded);    response.sendRedirect(encoded);    replay(request);    replay(response);    filter.onAccessDenied(request, response);    verify(request);    verify(response);}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{        return false;}
0
public void testPrivateClassC()
{    Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_C_REGEX);    String base = "192.168.";    for (int i = 0; i < 256; i++) {        String ibase = base + i;        for (int j = 0; j < 256; j++) {            String ip = ibase + "." + j;            assertTrue(p.matcher(ip).matches());        }    }}
0
public void testPrivateClassB()
{    Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_B_REGEX);    String base = "172.";    for (int i = 16; i < 32; i++) {        String ibase = base + i;        for (int j = 0; j < 256; j++) {            String jBase = ibase + "." + j;            for (int k = 0; k < 256; k++) {                String ip = jBase + "." + k;                assertTrue(p.matcher(ip).matches());            }        }    }}
0
public void testPermisisonMapping()
{        HttpMethodPermissionFilter filter = new HttpMethodPermissionFilter();    String[] permsBefore = { "foo", "bar" };    String[] permsAfter = filter.buildPermissions(permsBefore, filter.getHttpMethodAction("get"));    Assert.assertEquals(2, permsAfter.length);    Assert.assertEquals("foo:read", permsAfter[0]);    Assert.assertEquals("bar:read", permsAfter[1]);    Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("head"))[0]);    Assert.assertEquals("foo:update", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("put"))[0]);    Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("post"))[0]);    Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("mkcol"))[0]);    Assert.assertEquals("foo:delete", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("delete"))[0]);    Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("options"))[0]);    Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("trace"))[0]);}
0
protected HttpServletRequest createBaseMockRequest()
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    expect(request.getScheme()).andReturn("http");    expect(request.getServerName()).andReturn("localhost");    expect(request.getRequestURI()).andReturn("/");    return request;}
0
public void testDefault() throws Exception
{    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    HttpServletRequest request = createBaseMockRequest();    expect(response.encodeRedirectURL(eq("http://localhost/"))).andReturn("http://localhost/");    replay(request);    replay(response);    PortFilter filter = new PortFilter();    boolean result = filter.onAccessDenied(request, response, null);    verify(request);    verify(response);    assertFalse(result);}
0
public void testConfiguredPort() throws Exception
{    int port = 8080;    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    HttpServletRequest request = createBaseMockRequest();    String expected = "http://localhost:" + port + "/";    expect(response.encodeRedirectURL(eq(expected))).andReturn(expected);    replay(request);    replay(response);    PortFilter filter = new PortFilter();    filter.setPort(port);    boolean result = filter.onAccessDenied(request, response, null);    verify(request);    verify(response);    assertFalse(result);}
0
public void setUp()
{    resolver = new PathMatchingFilterChainResolver();}
0
public void testNewInstance()
{    assertNotNull(resolver.getPathMatcher());    assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);    assertNotNull(resolver.getFilterChainManager());    assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);}
0
public void testNewInstanceWithFilterConfig()
{    FilterConfig mock = createNiceMockFilterConfig();    replay(mock);    resolver = new PathMatchingFilterChainResolver(mock);    assertNotNull(resolver.getPathMatcher());    assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);    assertNotNull(resolver.getFilterChainManager());    assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);    assertEquals(((DefaultFilterChainManager) resolver.getFilterChainManager()).getFilterConfig(), mock);    verify(mock);}
0
public void testSetters()
{    resolver.setPathMatcher(new AntPathMatcher());    assertNotNull(resolver.getPathMatcher());    assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);    resolver.setFilterChainManager(new DefaultFilterChainManager());    assertNotNull(resolver.getFilterChainManager());    assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);}
0
public void testGetChainsWithoutChains()
{    ServletRequest request = createNiceMock(HttpServletRequest.class);    ServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);    FilterChain resolved = resolver.getChain(request, response, chain);    assertNull(resolved);}
0
public void testGetChainsWithMatch()
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();    expect(request.getContextPath()).andReturn("");    expect(request.getRequestURI()).andReturn("/index.html");    replay(request);    FilterChain resolved = resolver.getChain(request, response, chain);    assertNotNull(resolved);    verify(request);}
0
public void testPathTraversalWithDot()
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();    expect(request.getContextPath()).andReturn("");    expect(request.getRequestURI()).andReturn("/./index.html");    replay(request);    FilterChain resolved = resolver.getChain(request, response, chain);    assertNotNull(resolved);    verify(request);}
0
public void testPathTraversalWithDotDot()
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();    expect(request.getContextPath()).andReturn("");    expect(request.getRequestURI()).andReturn("/public/../index.html");    replay(request);    FilterChain resolved = resolver.getChain(request, response, chain);    assertNotNull(resolved);    verify(request);}
0
public void testGetChainsWithoutMatch()
{    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    HttpServletResponse response = createNiceMock(HttpServletResponse.class);    FilterChain chain = createNiceMock(FilterChain.class);        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");    expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();    expect(request.getContextPath()).andReturn("");    expect(request.getRequestURI()).andReturn("/");    replay(request);    FilterChain resolved = resolver.getChain(request, response, chain);    assertNull(resolved);    verify(request);}
0
public void testNewInstance()
{    @SuppressWarnings({ "MismatchedQueryAndUpdateOfCollection" })    SimpleNamedFilterList list = new SimpleNamedFilterList("test");    assertNotNull(list.getName());    assertEquals("test", list.getName());}
0
public void testNewInstanceNameless()
{    new SimpleNamedFilterList(null);}
0
public void testNewInstanceBackingList()
{    new SimpleNamedFilterList("test", new ArrayList<Filter>());}
0
public void testNewInstanceNullBackingList()
{    new SimpleNamedFilterList("test", null);}
0
public void testListMethods()
{    FilterChain mock = createNiceMock(FilterChain.class);    Filter filter = createNiceMock(Filter.class);    NamedFilterList list = new SimpleNamedFilterList("test");    list.add(filter);    FilterChain chain = list.proxy(mock);    assertNotNull(chain);    assertNotSame(mock, chain);    Filter singleFilter = new SslFilter();    List<? extends Filter> multipleFilters = CollectionUtils.asList(new PortFilter(), new UserFilter());    list.add(0, singleFilter);    assertEquals(2, list.size());    assertTrue(list.get(0) instanceof SslFilter);    assertTrue(Arrays.equals(list.toArray(), new Object[] { singleFilter, filter }));    list.addAll(multipleFilters);    assertEquals(4, list.size());    assertTrue(list.get(2) instanceof PortFilter);    assertTrue(list.get(3) instanceof UserFilter);    list.addAll(0, CollectionUtils.asList(new PermissionsAuthorizationFilter(), new RolesAuthorizationFilter()));    assertEquals(6, list.size());    assertTrue(list.get(0) instanceof PermissionsAuthorizationFilter);    assertTrue(list.get(1) instanceof RolesAuthorizationFilter);    assertEquals(2, list.indexOf(singleFilter));    assertEquals(multipleFilters, list.subList(4, list.size()));    assertTrue(list.contains(singleFilter));    assertTrue(list.containsAll(multipleFilters));    assertFalse(list.isEmpty());    list.clear();    assertTrue(list.isEmpty());    list.add(singleFilter);    Iterator i = list.iterator();    assertTrue(i.hasNext());    assertEquals(i.next(), singleFilter);    ListIterator li = list.listIterator();    assertTrue(li.hasNext());    assertEquals(li.next(), singleFilter);    li = list.listIterator(0);    assertTrue(li.hasNext());    assertEquals(li.next(), singleFilter);    list.set(0, singleFilter);    assertEquals(list.get(0), singleFilter);    Filter[] filters = new Filter[list.size()];    filters = list.toArray(filters);    assertEquals(1, filters.length);    assertEquals(filters[0], singleFilter);    assertEquals(0, list.lastIndexOf(singleFilter));    list.remove(singleFilter);    assertTrue(list.isEmpty());    list.add(singleFilter);    list.remove(0);    assertTrue(list.isEmpty());    list.add(singleFilter);    list.addAll(multipleFilters);    assertEquals(3, list.size());    list.removeAll(multipleFilters);    assertEquals(1, list.size());    assertEquals(list.get(0), singleFilter);    list.addAll(multipleFilters);    assertEquals(3, list.size());    list.retainAll(multipleFilters);    assertEquals(2, list.size());        assertEquals(new ArrayList(list), multipleFilters);}
0
public void setUp()
{    request = createNiceMock(HttpServletRequest.class);    response = createNiceMock(ServletResponse.class);    filter = createTestInstance();}
0
private PathMatchingFilter createTestInstance()
{    final String NAME = "pathMatchingFilter";    PathMatchingFilter filter = new PathMatchingFilter() {        @Override        protected boolean isEnabled(ServletRequest request, ServletResponse response, String path, Object mappedValue) throws Exception {            return !path.equals(DISABLED_PATH);        }        @Override        protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {                        return false;        }    };    filter.setName(NAME);    return filter;}
0
protected boolean isEnabled(ServletRequest request, ServletResponse response, String path, Object mappedValue) throws Exception
{    return !path.equals(DISABLED_PATH);}
0
protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
{        return false;}
0
public void testDisabledBasedOnPath() throws Exception
{    filter.processPathConfig(DISABLED_PATH, null);    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    ServletResponse response = createNiceMock(ServletResponse.class);    expect(request.getContextPath()).andReturn(CONTEXT_PATH).anyTimes();    expect(request.getRequestURI()).andReturn(DISABLED_PATH).anyTimes();    replay(request);    boolean continueFilterChain = filter.preHandle(request, response);    assertTrue("FilterChain should continue.", continueFilterChain);    verify(request);}
0
public void testEnabled() throws Exception
{            filter.processPathConfig(DISABLED_PATH, null);    filter.processPathConfig(ENABLED_PATH, null);    HttpServletRequest request = createNiceMock(HttpServletRequest.class);    ServletResponse response = createNiceMock(ServletResponse.class);    expect(request.getContextPath()).andReturn(CONTEXT_PATH).anyTimes();    expect(request.getRequestURI()).andReturn(ENABLED_PATH).anyTimes();    replay(request);    boolean continueFilterChain = filter.preHandle(request, response);    assertFalse("FilterChain should NOT continue.", continueFilterChain);    verify(request);}
0
public void tearDown()
{    ThreadContext.remove();}
0
public void onSuccessfulLogin()
{    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    WebSubject mockSubject = createNiceMock(WebSubject.class);    expect(mockSubject.getServletRequest()).andReturn(mockRequest).anyTimes();    expect(mockSubject.getServletResponse()).andReturn(mockResponse).anyTimes();    CookieRememberMeManager mgr = new CookieRememberMeManager();    org.apache.shiro.web.servlet.Cookie cookie = createMock(org.apache.shiro.web.servlet.Cookie.class);    mgr.setCookie(cookie);        cookie.removeFrom(isA(HttpServletRequest.class), isA(HttpServletResponse.class));        expect(cookie.getName()).andReturn("rememberMe");    expect(cookie.getValue()).andReturn(null);    expect(cookie.getComment()).andReturn(null);    expect(cookie.getDomain()).andReturn(null);    expect(cookie.getPath()).andReturn(null);    expect(cookie.getMaxAge()).andReturn(SimpleCookie.DEFAULT_MAX_AGE);    expect(cookie.getVersion()).andReturn(SimpleCookie.DEFAULT_VERSION);    expect(cookie.isSecure()).andReturn(false);    expect(cookie.isHttpOnly()).andReturn(true);    expect(cookie.getSameSite()).andReturn(org.apache.shiro.web.servlet.Cookie.SameSiteOptions.LAX);    UsernamePasswordToken token = new UsernamePasswordToken("user", "secret");    token.setRememberMe(true);    AuthenticationInfo account = new SimpleAuthenticationInfo("user", "secret", "test");    replay(mockSubject);    replay(mockRequest);    replay(cookie);    mgr.onSuccessfulLogin(mockSubject, token, account);    verify(mockRequest);    verify(mockSubject);    verify(cookie);}
0
public void getRememberedSerializedIdentityReturnsNullForDeletedCookie()
{    HttpServletRequest mockRequest = createMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createMock(HttpServletResponse.class);    WebSubjectContext context = new DefaultWebSubjectContext();    context.setServletRequest(mockRequest);    context.setServletResponse(mockResponse);    expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);    Cookie[] cookies = new Cookie[] { new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, org.apache.shiro.web.servlet.Cookie.DELETED_COOKIE_VALUE) };    expect(mockRequest.getCookies()).andReturn(cookies);    replay(mockRequest);    CookieRememberMeManager mgr = new CookieRememberMeManager();    assertNull(mgr.getRememberedSerializedIdentity(context));}
0
public void getRememberedPrincipals()
{    HttpServletRequest mockRequest = createMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createMock(HttpServletResponse.class);    WebSubjectContext context = new DefaultWebSubjectContext();    context.setServletRequest(mockRequest);    context.setServletResponse(mockResponse);    expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);            final String userPCAesBase64 = "WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj" + "jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr" + "7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza" + "zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr" + "xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y" + "A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT" + "xkVapw5UESl34YvA615cb+82ue1I=";    Cookie[] cookies = new Cookie[] { new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64) };    expect(mockRequest.getCookies()).andReturn(cookies);    replay(mockRequest);    CookieRememberMeManager mgr = new CookieRememberMeManager();    mgr.setCipherKey(Base64.decode("kPH+bIxk5D2deZiIxcaaaA=="));    PrincipalCollection collection = mgr.getRememberedPrincipals(context);    verify(mockRequest);    assertTrue(collection != null);        assertTrue(collection.iterator().next().equals("user"));}
0
public void getRememberedPrincipalsNoMoreDefaultCipher()
{    HttpServletRequest mockRequest = createMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createMock(HttpServletResponse.class);    WebSubjectContext context = new DefaultWebSubjectContext();    context.setServletRequest(mockRequest);    context.setServletResponse(mockResponse);    expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);    expect(mockRequest.getContextPath()).andReturn("/test");            final String userPCAesBase64 = "WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj" + "jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr" + "7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza" + "zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr" + "xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y" + "A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT" + "xkVapw5UESl34YvA615cb+82ue1I=";    Cookie[] cookies = new Cookie[] { new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64) };    expect(mockRequest.getCookies()).andReturn(cookies);    replay(mockRequest);    CookieRememberMeManager mgr = new CookieRememberMeManager();                mgr.getRememberedPrincipals(context);}
0
public void getRememberedPrincipalsDecryptionError()
{    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    WebSubjectContext context = new DefaultWebSubjectContext();    context.setServletRequest(mockRequest);    context.setServletResponse(mockResponse);    expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);        final String userPCAesBase64 = "garbage";    Cookie[] cookies = new Cookie[] { new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64) };    expect(mockRequest.getCookies()).andReturn(cookies).anyTimes();    replay(mockRequest);    CookieRememberMeManager mgr = new CookieRememberMeManager();    try {        mgr.getRememberedPrincipals(context);    } catch (CryptoException expected) {        return;    }    fail("CryptoException was expected to be thrown");}
0
public void onLogout()
{    CookieRememberMeManager mgr = new CookieRememberMeManager();    org.apache.shiro.web.servlet.Cookie cookie = createMock(org.apache.shiro.web.servlet.Cookie.class);    mgr.setCookie(cookie);    HttpServletRequest mockRequest = createMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createMock(HttpServletResponse.class);    WebSubject mockSubject = createNiceMock(WebSubject.class);    expect(mockSubject.getServletRequest()).andReturn(mockRequest).anyTimes();    expect(mockSubject.getServletResponse()).andReturn(mockResponse).anyTimes();    expect(mockRequest.getContextPath()).andReturn(null).anyTimes();    cookie.removeFrom(isA(HttpServletRequest.class), isA(HttpServletResponse.class));    replay(mockRequest);    replay(mockResponse);    replay(mockSubject);    replay(cookie);    mgr.onLogout(mockSubject);    verify(mockSubject);    verify(mockRequest);    verify(mockResponse);    verify(cookie);}
0
public void setup()
{    sm = new DefaultWebSecurityManager();    sm.setSessionMode(DefaultWebSecurityManager.NATIVE_SESSION_MODE);    Ini ini = new Ini();    Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);    section.put("lonestarr", "vespa");    sm.setRealm(new IniRealm(ini));}
0
public void tearDown()
{    sm.destroy();    super.tearDown();}
0
protected Subject newSubject(ServletRequest request, ServletResponse response)
{    return new WebSubject.Builder(sm, request, response).buildSubject();}
0
public void checkSessionManagerDeterminesContainerSessionMode()
{    sm.setSessionMode(DefaultWebSecurityManager.NATIVE_SESSION_MODE);    WebSessionManager sessionManager = createMock(WebSessionManager.class);    expect(sessionManager.isServletContainerSessions()).andReturn(true).anyTimes();    replay(sessionManager);    sm.setSessionManager(sessionManager);    assertTrue("The set SessionManager is not being used to determine isHttpSessionMode.", sm.isHttpSessionMode());    verify(sessionManager);}
0
public void shiroSessionModeInit()
{    sm.setSessionMode(DefaultWebSecurityManager.NATIVE_SESSION_MODE);}
0
protected void sleep(long millis)
{    try {        Thread.sleep(millis);    } catch (InterruptedException e) {        throw new IllegalStateException(e);    }}
0
public void testLogin()
{    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    expect(mockRequest.getCookies()).andReturn(null);    expect(mockRequest.getContextPath()).andReturn("/");    replay(mockRequest);    Subject subject = newSubject(mockRequest, mockResponse);    assertFalse(subject.isAuthenticated());    subject.login(new UsernamePasswordToken("lonestarr", "vespa"));    assertTrue(subject.isAuthenticated());    assertNotNull(subject.getPrincipal());    assertTrue(subject.getPrincipal().equals("lonestarr"));}
0
public void testSessionTimeout()
{    shiroSessionModeInit();    long globalTimeout = 100;    ((AbstractSessionManager) sm.getSessionManager()).setGlobalSessionTimeout(globalTimeout);    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    expect(mockRequest.getCookies()).andReturn(null);    expect(mockRequest.getContextPath()).andReturn("/");    replay(mockRequest);    Subject subject = newSubject(mockRequest, mockResponse);    Session session = subject.getSession();    assertEquals(session.getTimeout(), globalTimeout);    session.setTimeout(125);    assertEquals(session.getTimeout(), 125);    sleep(200);    try {        session.getTimeout();        fail("Session should have expired.");    } catch (ExpiredSessionException expected) {    }}
0
public void testGetSubjectByRequestResponsePair()
{    shiroSessionModeInit();    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    expect(mockRequest.getCookies()).andReturn(null);    replay(mockRequest);    replay(mockResponse);    Subject subject = newSubject(mockRequest, mockResponse);    verify(mockRequest);    verify(mockResponse);    assertNotNull(subject);    assertTrue(subject.getPrincipals() == null || subject.getPrincipals().isEmpty());    assertTrue(subject.getSession(false) == null);    assertFalse(subject.isAuthenticated());}
0
public void testGetSubjectByRequestSessionId()
{    shiroSessionModeInit();    HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);    HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);    replay(mockRequest);    replay(mockResponse);    Subject subject = newSubject(mockRequest, mockResponse);    Session session = subject.getSession();    Serializable sessionId = session.getId();    assertNotNull(sessionId);    verify(mockRequest);    verify(mockResponse);    mockRequest = createNiceMock(HttpServletRequest.class);    mockResponse = createNiceMock(HttpServletResponse.class);        Cookie[] cookies = new Cookie[] { new Cookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME, sessionId.toString()) };    expect(mockRequest.getCookies()).andReturn(cookies).anyTimes();    expect(mockRequest.getParameter(isA(String.class))).andReturn(null).anyTimes();    replay(mockRequest);    replay(mockResponse);    subject = newSubject(mockRequest, mockResponse);    session = subject.getSession(false);    assertNotNull(session);    assertEquals(sessionId, session.getId());    verify(mockRequest);    verify(mockResponse);}
0
public void testBuildNonWebSubjectWithDefaultServletContainerSessionManager()
{    Ini ini = new Ini();    Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);    section.put("user1", "user1");    WebIniSecurityManagerFactory factory = new WebIniSecurityManagerFactory(ini);    WebSecurityManager securityManager = (WebSecurityManager) factory.getInstance();    PrincipalCollection principals = new SimplePrincipalCollection("user1", "iniRealm");    Subject subject = new Subject.Builder(securityManager).principals(principals).buildSubject();    assertNotNull(subject);    assertEquals("user1", subject.getPrincipal());}
0
public void setup()
{    sm = new DefaultWebSecurityManager();    Ini ini = new Ini();    Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);    section.put("lonestarr", "vespa");    sm.setRealm(new IniRealm(ini));}
0
public void tearDown()
{    sm.destroy();    super.tearDown();}
0
public void testLoginNonWebSubject()
{    Subject.Builder builder = new Subject.Builder(sm);    Subject subject = builder.buildSubject();    subject.login(new UsernamePasswordToken("lonestarr", "vespa"));}
0
public void setUp()
{    FILTERED[0] = false;    filter = createTestInstance();    chain = createNiceMock(FilterChain.class);    request = createNiceMock(ServletRequest.class);    response = createNiceMock(ServletResponse.class);}
0
private OncePerRequestFilter createTestInstance()
{    OncePerRequestFilter filter = new OncePerRequestFilter() {        @Override        protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {            FILTERED[0] = true;        }    };    filter.setName(NAME);    return filter;}
0
protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException
{    FILTERED[0] = true;}
0
public void testEnabled() throws IOException, ServletException
{    expect(request.getAttribute(ATTR_NAME)).andReturn(null).anyTimes();    replay(request);    filter.doFilter(request, response, chain);    verify(request);    assertTrue("Filter should have executed", FILTERED[0]);}
0
public void testDisabled() throws IOException, ServletException
{        filter.setEnabled(false);    expect(request.getAttribute(ATTR_NAME)).andReturn(null).anyTimes();    replay(request);    filter.doFilter(request, response, chain);    verify(request);    assertFalse("Filter should NOT have executed", FILTERED[0]);}
0
public void setUp() throws Exception
{    this.mockRequest = createMock(HttpServletRequest.class);    this.mockContext = createMock(ServletContext.class);    this.mockSubject = createMock(Subject.class);    ThreadContext.bind(this.mockSubject);    this.request = new ShiroHttpServletRequest(mockRequest, mockContext, false);}
0
public void testRegetSession() throws Exception
{    Session session1 = createMock(Session.class);    Session session2 = createMock(Session.class);    mockSubject.logout();    expect(mockSubject.getSession(true)).andReturn(session1).times(1).andReturn(session2).times(1);    expect(mockSubject.getSession(false)).andReturn(session1).times(2).andReturn(null).times(3);    replay(mockSubject);    assertNotNull(request.getSession(true));    assertNotNull(request.getSession(false));    mockSubject.logout();    assertNull(request.getSession(false));    assertNotNull(request.getSession(true));    verify(mockSubject);}
0
public void setUp() throws Exception
{    this.mockRequest = createMock(HttpServletRequest.class);    this.mockResponse = createMock(HttpServletResponse.class);    this.cookie = new SimpleCookie("test");}
0
public void testRemoveValue() throws Exception
{                String name = "test";    String value = "deleteMe";    String path = "/somepath";    String headerValue = this.cookie.buildHeaderValue(name, value, null, null, path, 0, SimpleCookie.DEFAULT_VERSION, false, false, null);    String expectedStart = new StringBuilder().append(name).append(SimpleCookie.NAME_VALUE_DELIMITER).append(value).append(SimpleCookie.ATTRIBUTE_DELIMITER).append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(path).toString();    assertTrue(headerValue.startsWith(expectedStart));    expect(mockRequest.getContextPath()).andReturn(path).times(1);        mockResponse.addHeader(eq(SimpleCookie.COOKIE_HEADER_NAME), isA(String.class));    replay(mockRequest);    replay(mockResponse);    this.cookie.removeFrom(mockRequest, mockResponse);    verify(mockRequest);    verify(mockResponse);}
0
private void testRootContextPath(String contextPath)
{    this.cookie.setValue("blah");    String expectedCookieValue = new StringBuilder().append("test").append(SimpleCookie.NAME_VALUE_DELIMITER).append("blah").append(SimpleCookie.ATTRIBUTE_DELIMITER).append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.ROOT_PATH).append(SimpleCookie.ATTRIBUTE_DELIMITER).append(SimpleCookie.HTTP_ONLY_ATTRIBUTE_NAME).append(SimpleCookie.ATTRIBUTE_DELIMITER).append(SimpleCookie.SAME_SITE_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.SameSiteOptions.LAX.toString().toLowerCase(Locale.ENGLISH)).toString();    expect(mockRequest.getContextPath()).andReturn(contextPath);    mockResponse.addHeader(SimpleCookie.COOKIE_HEADER_NAME, expectedCookieValue);    replay(mockRequest);    replay(mockResponse);    this.cookie.saveTo(mockRequest, mockResponse);    verify(mockRequest);    verify(mockResponse);}
0
public void testEmptyContextPath() throws Exception
{    testRootContextPath("");}
0
public void testNullContextPath() throws Exception
{    testRootContextPath(null);}
0
public void testReadValueInvalidPath() throws Exception
{    expect(mockRequest.getRequestURI()).andStubReturn("/foo/index.jsp");    expect(mockRequest.getCookies()).andStubReturn(new javax.servlet.http.Cookie[] { new javax.servlet.http.Cookie(this.cookie.getName(), "value") });    replay(mockRequest);    replay(mockResponse);    this.cookie.setPath("/bar/index.jsp");    assertEquals(null, this.cookie.readValue(mockRequest, mockResponse));}
0
public void testReadValuePrefixPath() throws Exception
{    expect(mockRequest.getRequestURI()).andStubReturn("/bar/index.jsp");    expect(mockRequest.getCookies()).andStubReturn(new javax.servlet.http.Cookie[] { new javax.servlet.http.Cookie(this.cookie.getName(), "value") });    replay(mockRequest);    replay(mockResponse);    this.cookie.setPath("/bar");    assertEquals("value", this.cookie.readValue(mockRequest, mockResponse));}
0
public void testReadValueInvalidPrefixPath() throws Exception
{    expect(mockRequest.getRequestURI()).andStubReturn("/foobar/index.jsp");    expect(mockRequest.getCookies()).andStubReturn(new javax.servlet.http.Cookie[] { new javax.servlet.http.Cookie(this.cookie.getName(), "value") });    replay(mockRequest);    replay(mockResponse);    this.cookie.setPath("/foo");    assertEquals(null, this.cookie.readValue(mockRequest, mockResponse));}
0
private static T eqCookie(final T in)
{    reportMatcher(new IArgumentMatcher() {        public boolean matches(Object o) {            javax.servlet.http.Cookie c = (javax.servlet.http.Cookie) o;            return c.getName().equals(in.getName()) && c.getValue().equals(in.getValue()) && c.getPath().equals(in.getPath()) && c.getMaxAge() == in.getMaxAge() && c.getSecure() == in.getSecure() && c.getValue().equals(in.getValue());        }        public void appendTo(StringBuffer sb) {            sb.append("eqCookie(");            sb.append(in.getClass().getName());            sb.append(")");        }    });    return null;}
0
public boolean matches(Object o)
{    javax.servlet.http.Cookie c = (javax.servlet.http.Cookie) o;    return c.getName().equals(in.getName()) && c.getValue().equals(in.getValue()) && c.getPath().equals(in.getPath()) && c.getMaxAge() == in.getMaxAge() && c.getSecure() == in.getSecure() && c.getValue().equals(in.getValue());}
0
public void appendTo(StringBuffer sb)
{    sb.append("eqCookie(");    sb.append(in.getClass().getName());    sb.append(")");}
0
public void setUp() throws Exception
{    this.mockSession = createMock(HttpSession.class);}
0
public void testLongTimeout() throws Exception
{        final int expectedTimeoutInSeconds = 30 * 24 * 60 * 60;    final long expectedLongValue = expectedTimeoutInSeconds * 1000L;    Capture<Integer> capturedInt = Capture.newInstance();        mockSession.setMaxInactiveInterval(captureInt(capturedInt));    expect(mockSession.getMaxInactiveInterval()).andReturn(expectedTimeoutInSeconds);    replay(mockSession);    HttpServletSession servletSession = new HttpServletSession(mockSession, null);    servletSession.setTimeout(expectedLongValue);    long timeoutInMilliseconds = servletSession.getTimeout();    assertEquals(expectedLongValue, timeoutInMilliseconds);    assertEquals(expectedTimeoutInSeconds, capturedInt.getValue().intValue());}
0
protected FilterConfig createNiceMockFilterConfig()
{    FilterConfig mock = createNiceMock(FilterConfig.class);    ServletContext mockServletContext = createNiceMock(ServletContext.class);    expect(mock.getServletContext()).andReturn(mockServletContext);    return mock;}
0
