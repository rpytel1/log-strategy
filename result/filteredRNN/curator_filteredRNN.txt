public int getSimulatedSessionExpirationPercent()
{    return expirationPercent;}
0
public T callWithRetry(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    client.internalBlockUntilConnectedOrTimedOut();    T result = null;    RetryLoop retryLoop = client.newRetryLoop();    while (retryLoop.shouldContinue()) {        try {            result = proc.call();            retryLoop.markComplete();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            retryLoop.takeException(e);        }    }    return result;}
0
public CheckTimeoutsResult checkTimeouts(Callable<String> hasNewConnectionString, long connectionStartMs, int sessionTimeoutMs, int connectionTimeoutMs) throws Exception
{    if (hasNewConnectionString.call() != null) {        return CheckTimeoutsResult.NEW_CONNECTION_STRING;    }    return CheckTimeoutsResult.NOP;}
0
 ZooKeeper getZooKeeper() throws Exception
{    if (SessionFailRetryLoop.sessionForThreadHasFailed()) {        throw new SessionFailRetryLoop.SessionFailedException();    }    Exception exception = backgroundExceptions.poll();    if (exception != null) {        new EventTrace("background-exceptions", tracer.get()).commit();        throw exception;    }    boolean localIsConnected = isConnected.get();    if (!localIsConnected) {        checkTimeouts();    }    return zooKeeper.getZooKeeper();}
0
 boolean isConnected()
{    return isConnected.get();}
0
 void start() throws Exception
{        ensembleProvider.start();    reset();}
1
public void close() throws IOException
{    close(0);}
0
public void close(int waitForShutdownTimeoutMs) throws IOException
{        CloseableUtils.closeQuietly(ensembleProvider);    try {        zooKeeper.closeAndClear(waitForShutdownTimeoutMs);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        isConnected.set(false);    }}
1
 void addParentWatcher(Watcher watcher)
{    parentWatchers.offer(watcher);}
0
 void removeParentWatcher(Watcher watcher)
{    parentWatchers.remove(watcher);}
0
 long getInstanceIndex()
{    return instanceIndex.get();}
0
 int getLastNegotiatedSessionTimeoutMs()
{    return lastNegotiatedSessionTimeoutMs.get();}
0
public void process(WatchedEvent event)
{    if (LOG_EVENTS) {            }    if (event.getType() == Watcher.Event.EventType.None) {        boolean wasConnected = isConnected.get();        boolean newIsConnected = checkState(event.getState(), wasConnected);        if (newIsConnected != wasConnected) {            isConnected.set(newIsConnected);            connectionStartMs = System.currentTimeMillis();            if (newIsConnected) {                lastNegotiatedSessionTimeoutMs.set(zooKeeper.getNegotiatedSessionTimeoutMs());                            }        }    }    for (Watcher parentWatcher : parentWatchers) {        OperationTrace trace = new OperationTrace("connection-state-parent-process", tracer.get(), getSessionId());        parentWatcher.process(event);        trace.commit();    }}
1
 EnsembleProvider getEnsembleProvider()
{    return ensembleProvider;}
0
 synchronized void reset() throws Exception
{        instanceIndex.incrementAndGet();    isConnected.set(false);    connectionStartMs = System.currentTimeMillis();    zooKeeper.closeAndReset();        zooKeeper.getZooKeeper();}
1
private synchronized void checkTimeouts() throws Exception
{    final AtomicReference<String> newConnectionString = new AtomicReference<>();    Callable<String> hasNewConnectionString = new Callable<String>() {        @Override        public String call() {            newConnectionString.set(zooKeeper.getNewConnectionString());            return newConnectionString.get();        }    };    int lastNegotiatedSessionTimeoutMs = getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    ConnectionHandlingPolicy.CheckTimeoutsResult result = connectionHandlingPolicy.checkTimeouts(hasNewConnectionString, connectionStartMs, useSessionTimeoutMs, connectionTimeoutMs);    switch(result) {        default:        case NOP:            {                break;            }        case NEW_CONNECTION_STRING:            {                handleNewConnectionString(newConnectionString.get());                break;            }        case RESET_CONNECTION:            {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                    int maxTimeout = Math.max(useSessionTimeoutMs, connectionTimeoutMs);                                    }                reset();                break;            }        case CONNECTION_TIMEOUT:            {                KeeperException.ConnectionLossException connectionLossException = new CuratorConnectionLossException();                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                                    }                new EventTrace("connections-timed-out", tracer.get(), getSessionId()).commit();                throw connectionLossException;            }        case SESSION_TIMEOUT:            {                handleExpiredSession();                break;            }    }}
1
public String call()
{    newConnectionString.set(zooKeeper.getNewConnectionString());    return newConnectionString.get();}
0
public long getSessionId()
{    long sessionId = 0;    try {        ZooKeeper zk = zooKeeper.getZooKeeper();        if (zk != null) {            sessionId = zk.getSessionId();        }    } catch (Exception e) {        }    return sessionId;}
0
private boolean checkState(Event.KeeperState state, boolean wasConnected)
{    boolean isConnected = wasConnected;    boolean checkNewConnectionString = true;    switch(state) {        default:        case Disconnected:            {                isConnected = false;                break;            }        case SyncConnected:        case ConnectedReadOnly:            {                isConnected = true;                break;            }        case AuthFailed:            {                isConnected = false;                                break;            }        case Expired:            {                isConnected = false;                checkNewConnectionString = false;                handleExpiredSession();                break;            }        case SaslAuthenticated:            {                                break;            }    }        if (state != Event.KeeperState.Expired) {        new EventTrace(state.toString(), tracer.get(), getSessionId()).commit();    }    if (checkNewConnectionString) {        String newConnectionString = zooKeeper.getNewConnectionString();        if (newConnectionString != null) {            handleNewConnectionString(newConnectionString);        }    }    return isConnected;}
1
private void handleNewConnectionString(String newConnectionString)
{        new EventTrace("connection-string-changed", tracer.get(), getSessionId()).commit();    try {        ZooKeeper zooKeeper = this.zooKeeper.getZooKeeper();        if (zooKeeper == null) {                    } else {            if (ensembleProvider.updateServerListEnabled()) {                zooKeeper.updateServerList(newConnectionString);            } else {                reset();            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
1
private void handleExpiredSession()
{        new EventTrace("session-expired", tracer.get(), getSessionId()).commit();    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
1
private void queueBackgroundException(Exception e)
{    while (backgroundExceptions.size() >= MAX_BACKGROUND_EXCEPTIONS) {        backgroundExceptions.poll();    }    backgroundExceptions.offer(e);}
0
public ZooKeeper getZooKeeper() throws Exception
{    Preconditions.checkState(started.get(), "Client is not started");    return state.getZooKeeper();}
0
public RetryLoop newRetryLoop()
{    return new RetryLoop(retryPolicy.get(), tracer);}
0
public SessionFailRetryLoop newSessionFailRetryLoop(SessionFailRetryLoop.Mode mode)
{    return new SessionFailRetryLoop(this, mode);}
0
public boolean isConnected()
{    return state.isConnected();}
0
public boolean blockUntilConnectedOrTimedOut() throws InterruptedException
{    Preconditions.checkState(started.get(), "Client is not started");        OperationTrace trace = startAdvancedTracer("blockUntilConnectedOrTimedOut");    internalBlockUntilConnectedOrTimedOut();    trace.commit();    boolean localIsConnected = state.isConnected();        return localIsConnected;}
1
public void start() throws Exception
{        if (!started.compareAndSet(false, true)) {        throw new IllegalStateException("Already started");    }    state.start();}
1
public void close()
{    close(waitForShutdownTimeoutMs);}
0
public void close(int waitForShutdownTimeoutMs)
{        started.set(false);    try {        state.close(waitForShutdownTimeoutMs);    } catch (IOException e) {        ThreadUtils.checkInterrupted(e);            }}
1
public void setRetryPolicy(RetryPolicy policy)
{    Preconditions.checkNotNull(policy, "policy cannot be null");    retryPolicy.set(policy);}
0
public RetryPolicy getRetryPolicy()
{    return retryPolicy.get();}
0
public TimeTrace startTracer(String name)
{    return new TimeTrace(name, tracer.get());}
0
public OperationTrace startAdvancedTracer(String name)
{    return new OperationTrace(name, tracer.get(), state.getSessionId());}
0
public TracerDriver getTracerDriver()
{    return tracer.get();}
0
public void setTracerDriver(TracerDriver tracer)
{    this.tracer.set(tracer);}
0
public String getCurrentConnectionString()
{    return state.getEnsembleProvider().getConnectionString();}
0
public int getConnectionTimeoutMs()
{    return connectionTimeoutMs;}
0
public void reset() throws Exception
{    state.reset();}
0
public long getInstanceIndex()
{    return state.getInstanceIndex();}
0
public ConnectionHandlingPolicy getConnectionHandlingPolicy()
{    return connectionHandlingPolicy;}
0
public int getLastNegotiatedSessionTimeoutMs()
{    return state.getLastNegotiatedSessionTimeoutMs();}
0
 void addParentWatcher(Watcher watcher)
{    state.addParentWatcher(watcher);}
0
 void removeParentWatcher(Watcher watcher)
{    state.removeParentWatcher(watcher);}
0
public void internalBlockUntilConnectedOrTimedOut() throws InterruptedException
{    long waitTimeMs = connectionTimeoutMs;    while (!state.isConnected() && (waitTimeMs > 0)) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher tempWatcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        state.addParentWatcher(tempWatcher);        long startTimeMs = System.currentTimeMillis();        long timeoutMs = Math.min(waitTimeMs, 1000);        try {            latch.await(timeoutMs, TimeUnit.MILLISECONDS);        } finally {            state.removeParentWatcher(tempWatcher);        }        long elapsed = Math.max(1, System.currentTimeMillis() - startTimeMs);        waitTimeMs -= elapsed;    }}
0
public void process(WatchedEvent event)
{    latch.countDown();}
0
public final void addTrace(String name, long time, TimeUnit unit)
{}
0
public final void addCount(String name, int increment)
{}
0
public String getName()
{    return this.name;}
0
public long getSessionId()
{    return this.sessionId;}
0
public void commit()
{    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addEvent(this);    } else {        this.driver.addCount(this.name, 1);    }}
0
public OperationTrace setReturnCode(int returnCode)
{    this.returnCode = returnCode;    return this;}
0
public OperationTrace setRequestBytesLength(long length)
{    this.requestBytesLength = length;    return this;}
0
public OperationTrace setRequestBytesLength(String data)
{    if (data == null) {        return this;    }    try {        this.setRequestBytesLength(data.getBytes("UTF-8").length);    } catch (UnsupportedEncodingException e) {        }    return this;}
0
public OperationTrace setRequestBytesLength(byte[] data)
{    if (data == null) {        return this;    }    return this.setRequestBytesLength(data.length);}
0
public OperationTrace setResponseBytesLength(long length)
{    this.responseBytesLength = length;    return this;}
0
public OperationTrace setResponseBytesLength(byte[] data)
{    if (data == null) {        return this;    }    return this.setResponseBytesLength(data.length);}
0
public OperationTrace setPath(String path)
{    this.path = path;    return this;}
0
public OperationTrace setWithWatcher(boolean withWatcher)
{    this.withWatcher = withWatcher;    return this;}
0
public OperationTrace setStat(Stat stat)
{    this.stat = stat;    return this;}
0
public String getName()
{    return this.name;}
0
public int getReturnCode()
{    return this.returnCode;}
0
public long getLatencyMs()
{    return this.latencyMs;}
0
public long getRequestBytesLength()
{    return this.requestBytesLength;}
0
public long getResponseBytesLength()
{    return this.responseBytesLength;}
0
public long getSessionId()
{    return this.sessionId;}
0
public String getPath()
{    return this.path;}
0
public boolean isWithWatcher()
{    return this.withWatcher;}
0
public Stat getStat()
{    return this.stat;}
0
public void commit()
{    long elapsed = System.nanoTime() - startTimeNanos;    this.latencyMs = TimeUnit.MILLISECONDS.convert(elapsed, TimeUnit.NANOSECONDS);    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addTrace(this);    } else {        this.driver.addTrace(this.name, elapsed, TimeUnit.NANOSECONDS);    }}
0
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    URI uri = new URI(useSsl ? "https" : "http", null, hostname, port, uriPath, null, null);    HttpURLConnection connection = (HttpURLConnection) uri.toURL().openConnection();    connection.addRequestProperty("Accept", mimeType);    StringBuilder str = new StringBuilder();    InputStream in = new BufferedInputStream(connection.getInputStream());    try {        for (; ; ) {            int b = in.read();            if (b < 0) {                break;            }            str.append((char) (b & 0xff));        }    } finally {        CloseableUtils.closeQuietly(in);    }    return str.toString();}
0
public void setExhibitors(Exhibitors newExhibitors)
{    exhibitors.set(newExhibitors);    masterExhibitors.set(newExhibitors);}
0
public void pollForInitialEnsemble() throws Exception
{    Preconditions.checkState(state.get() == State.LATENT, "Cannot be called after start()");    poll();}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            poll();        }    }, pollingMs, pollingMs, TimeUnit.MILLISECONDS);}
0
public void run()
{    poll();}
0
public void close() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    service.shutdownNow();}
0
public String getConnectionString()
{    return connectionString.get();}
0
public void setConnectionString(String connectionString)
{    }
1
public boolean updateServerListEnabled()
{    return false;}
0
protected void poll()
{    Exhibitors localExhibitors = exhibitors.get();    Map<String, String> values = queryExhibitors(localExhibitors);    int count = getCountFromValues(values);    if (count == 0) {                values = useBackup(localExhibitors);        count = getCountFromValues(values);    }    if (count > 0) {        int port = Integer.parseInt(values.get(VALUE_PORT));        StringBuilder newConnectionString = new StringBuilder();        List<String> newHostnames = Lists.newArrayList();        for (int i = 0; i < count; ++i) {            if (newConnectionString.length() > 0) {                newConnectionString.append(",");            }            String server = values.get(VALUE_SERVER_PREFIX + i);            newConnectionString.append(server).append(":").append(port);            newHostnames.add(server);        }        String newConnectionStringValue = newConnectionString.toString();        if (!newConnectionStringValue.equals(connectionString.get())) {                    }        Exhibitors newExhibitors = new Exhibitors(newHostnames, localExhibitors.getRestPort(), new Exhibitors.BackupConnectionStringProvider() {            @Override            public String getBackupConnectionString() throws Exception {                                return masterExhibitors.get().getBackupConnectionString();            }        });        connectionString.set(newConnectionStringValue);        exhibitors.set(newExhibitors);    }}
1
public String getBackupConnectionString() throws Exception
{        return masterExhibitors.get().getBackupConnectionString();}
0
private int getCountFromValues(Map<String, String> values)
{    try {        return Integer.parseInt(values.get(VALUE_COUNT));    } catch (NumberFormatException e) {        }    return 0;}
0
private Map<String, String> useBackup(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    try {        String backupConnectionString = localExhibitors.getBackupConnectionString();        int thePort = -1;        int count = 0;        for (String spec : backupConnectionString.split(",")) {            spec = spec.trim();            String[] parts = spec.split(":");            if (parts.length == 2) {                String hostname = parts[0];                int port = Integer.parseInt(parts[1]);                if (thePort < 0) {                    thePort = port;                } else if (port != thePort) {                                    }                values.put(VALUE_SERVER_PREFIX + count, hostname);                ++count;            } else {                            }        }        values.put(VALUE_COUNT, Integer.toString(count));        values.put(VALUE_PORT, Integer.toString(thePort));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return values;}
1
private Map<String, String> newValues()
{    Map<String, String> values = Maps.newHashMap();    values.put(VALUE_COUNT, "0");    return values;}
0
private static Map<String, String> decodeExhibitorList(String str) throws UnsupportedEncodingException
{    Map<String, String> values = Maps.newHashMap();    for (String spec : str.split("&")) {        String[] parts = spec.split("=");        if (parts.length == 2) {            values.put(parts[0], URLDecoder.decode(parts[1], "UTF-8"));        }    }    return values;}
0
private Map<String, String> queryExhibitors(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    long start = System.currentTimeMillis();    int retries = 0;    boolean done = false;    while (!done) {        List<String> hostnames = Lists.newArrayList(localExhibitors.getHostnames());        if (hostnames.size() == 0) {            done = true;        } else {            String hostname = hostnames.get(random.nextInt(hostnames.size()));            try {                String encoded = restClient.getRaw(hostname, localExhibitors.getRestPort(), restUriPath, MIME_TYPE);                values.putAll(decodeExhibitorList(encoded));                done = true;            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                if (retryPolicy.allowRetry(retries++, System.currentTimeMillis() - start, RetryLoop.getDefaultRetrySleeper())) {                                    } else {                                        done = true;                }            }        }    }    return values;}
1
public Collection<String> getHostnames()
{    return hostnames;}
0
public int getRestPort()
{    return restPort;}
0
public String getBackupConnectionString() throws Exception
{    return backupConnectionStringProvider.getBackupConnectionString();}
0
public void start() throws Exception
{}
0
public void close() throws IOException
{}
0
public void setConnectionString(String connectionString)
{    this.connectionString.set(connectionString);}
0
public String getConnectionString()
{    return connectionString.get();}
0
public boolean updateServerListEnabled()
{    return updateServerListEnabled;}
0
 ZooKeeper getZooKeeper() throws Exception
{    return (helper != null) ? helper.getZooKeeper() : null;}
0
 int getNegotiatedSessionTimeoutMs()
{    return (helper != null) ? helper.getNegotiatedSessionTimeoutMs() : 0;}
0
 String getConnectionString()
{    return (helper != null) ? helper.getConnectionString() : null;}
0
 String getNewConnectionString()
{    String helperConnectionString = (helper != null) ? helper.getConnectionString() : null;    return ((helperConnectionString != null) && !ensembleProvider.getConnectionString().equals(helperConnectionString)) ? helperConnectionString : null;}
0
 void closeAndClear(int waitForShutdownTimeoutMs) throws Exception
{    internalClose(waitForShutdownTimeoutMs);    helper = null;}
0
 void closeAndReset() throws Exception
{    internalClose(0);            helper = new Helper() {        private volatile ZooKeeper zooKeeperHandle = null;        private volatile String connectionString = null;        @Override        public ZooKeeper getZooKeeper() throws Exception {            synchronized (this) {                if (zooKeeperHandle == null) {                    connectionString = ensembleProvider.getConnectionString();                    zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);                }                helper = new Helper() {                    @Override                    public ZooKeeper getZooKeeper() throws Exception {                        return zooKeeperHandle;                    }                    @Override                    public String getConnectionString() {                        return connectionString;                    }                    @Override                    public int getNegotiatedSessionTimeoutMs() {                        return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;                    }                };                return zooKeeperHandle;            }        }        @Override        public String getConnectionString() {            return connectionString;        }        @Override        public int getNegotiatedSessionTimeoutMs() {            return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;        }    };}
0
public ZooKeeper getZooKeeper() throws Exception
{    synchronized (this) {        if (zooKeeperHandle == null) {            connectionString = ensembleProvider.getConnectionString();            zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);        }        helper = new Helper() {            @Override            public ZooKeeper getZooKeeper() throws Exception {                return zooKeeperHandle;            }            @Override            public String getConnectionString() {                return connectionString;            }            @Override            public int getNegotiatedSessionTimeoutMs() {                return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;            }        };        return zooKeeperHandle;    }}
0
public ZooKeeper getZooKeeper() throws Exception
{    return zooKeeperHandle;}
0
public String getConnectionString()
{    return connectionString;}
0
public int getNegotiatedSessionTimeoutMs()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
0
public String getConnectionString()
{    return connectionString;}
0
public int getNegotiatedSessionTimeoutMs()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
0
private void internalClose(int waitForShutdownTimeoutMs) throws Exception
{    try {        ZooKeeper zooKeeper = (helper != null) ? helper.getZooKeeper() : null;        if (zooKeeper != null) {            Watcher dummyWatcher = new Watcher() {                @Override                public void process(WatchedEvent event) {                }            };                        zooKeeper.register(dummyWatcher);            if (waitForShutdownTimeoutMs == 0) {                                zooKeeper.close();            } else {                zooKeeper.close(waitForShutdownTimeoutMs);            }        }    } catch (InterruptedException dummy) {        Thread.currentThread().interrupt();    }}
0
public void process(WatchedEvent event)
{}
0
public int getMaxSleepTimeMs()
{    return maxSleepTimeMs;}
0
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return Math.min(maxSleepTimeMs, super.getSleepTimeMs(retryCount, elapsedTimeMs));}
0
public int getBaseSleepTimeMs()
{    return baseSleepTimeMs;}
0
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{        long sleepMs = baseSleepTimeMs * Math.max(1, random.nextInt(1 << (retryCount + 1)));    if (sleepMs > maxSleepMs) {                sleepMs = maxSleepMs;    }    return sleepMs;}
1
private static int validateMaxRetries(int maxRetries)
{    if (maxRetries > MAX_RETRIES_LIMIT) {                maxRetries = MAX_RETRIES_LIMIT;    }    return maxRetries;}
1
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    try {        sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();                return false;    }    return true;}
1
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
0
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return super.allowRetry(retryCount, elapsedTimeMs, sleeper) && (elapsedTimeMs < maxElapsedTimeMs);}
0
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
0
public int getN()
{    return n;}
0
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (retryCount < n) {        try {            sleeper.sleepFor(getSleepTimeMs(retryCount, elapsedTimeMs), TimeUnit.MILLISECONDS);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }        return true;    }    return false;}
0
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    unit.sleep(time);}
0
public static RetrySleeper getDefaultRetrySleeper()
{    return sleeper;}
0
public static T callWithRetry(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    return client.getConnectionHandlingPolicy().callWithRetry(client, proc);}
0
public boolean shouldContinue()
{    return !isDone;}
0
public void markComplete()
{    isDone = true;}
0
public static boolean shouldRetry(int rc)
{    return (rc == KeeperException.Code.CONNECTIONLOSS.intValue()) || (rc == KeeperException.Code.OPERATIONTIMEOUT.intValue()) || (rc == KeeperException.Code.SESSIONMOVED.intValue()) || (rc == KeeperException.Code.SESSIONEXPIRED.intValue()) ||     (rc == -13);}
0
public static boolean isRetryException(Throwable exception)
{    if (exception instanceof KeeperException) {        KeeperException keeperException = (KeeperException) exception;        return shouldRetry(keeperException.code().intValue());    }    return false;}
0
public void takeException(Exception exception) throws Exception
{    boolean rethrow = true;    if (isRetryException(exception)) {        if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    }        if (retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startTimeMs, sleeper)) {            new EventTrace("retries-allowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }            rethrow = false;        } else {            new EventTrace("retries-disallowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }        }    }    if (rethrow) {        throw exception;    }}
1
public void process(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        sessionHasFailed.set(true);        failedSessionThreads.add(ourThread);    }}
0
public static T callWithRetry(CuratorZookeeperClient client, Mode mode, Callable<T> proc) throws Exception
{    T result = null;    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(mode);    retryLoop.start();    try {        while (retryLoop.shouldContinue()) {            try {                result = proc.call();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                retryLoop.takeException(e);            }        }    } finally {        retryLoop.close();    }    return result;}
0
 static boolean sessionForThreadHasFailed()
{    return failedSessionThreads.contains(Thread.currentThread());}
0
public void start()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    client.addParentWatcher(watcher);}
0
public boolean shouldContinue()
{    boolean localIsDone = isDone.getAndSet(true);    return !localIsDone;}
0
public void close()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    failedSessionThreads.remove(ourThread);    client.removeParentWatcher(watcher);}
0
public void takeException(Exception exception) throws Exception
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    boolean passUp = true;    if (sessionHasFailed.get()) {        switch(mode) {            case RETRY:                {                    sessionHasFailed.set(false);                    failedSessionThreads.remove(ourThread);                    if (exception instanceof SessionFailedException) {                        isDone.set(false);                        passUp = false;                    }                    break;                }            case FAIL:                {                    break;                }        }    }    if (passUp) {        retryLoop.takeException(exception);    }}
0
public void commit()
{    long elapsed = System.nanoTime() - startTimeNanos;    driver.addTrace(name, elapsed, TimeUnit.NANOSECONDS);}
0
public boolean cancel(boolean mayInterruptIfRunning)
{    futures.remove(scheduledFuture);    return scheduledFuture.cancel(mayInterruptIfRunning);}
0
public boolean isCancelled()
{    return scheduledFuture.isCancelled();}
0
public boolean isDone()
{    return scheduledFuture.isDone();}
0
public Void get() throws InterruptedException, ExecutionException
{    return null;}
0
public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return null;}
0
protected void done()
{    futures.remove(task);}
0
public boolean isShutdown()
{    return !isOpen.get();}
0
 int size()
{    return futures.size();}
0
public void close()
{    isOpen.set(false);    Iterator<Future<?>> iterator = futures.iterator();    while (iterator.hasNext()) {        Future<?> future = iterator.next();        iterator.remove();        if (!future.isDone() && !future.isCancelled() && !future.cancel(true)) {                    }    }    if (shutdownOnClose) {        executorService.shutdownNow();    }}
1
public Future<V> submit(Callable<V> task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<V> futureTask = new InternalFutureTask<V>(new FutureTask<V>(task));    executorService.execute(futureTask);    return futureTask;}
0
public Future<?> submit(Runnable task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    executorService.execute(futureTask);    return futureTask;}
0
public Future<?> schedule(Runnable task, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    scheduledExecutorService.schedule(futureTask, delay, unit);    return futureTask;}
0
public Future<?> scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(task, initialDelay, delay, unit);    return new InternalScheduledFutureTask(scheduledFuture);}
0
public static void closeQuietly(Closeable closeable)
{    try {                Closeables.close(closeable, true);    } catch (IOException e) {                            }}
1
public static boolean isZK34()
{    return !hasZooKeeperAdmin;}
0
public static void injectSessionExpiration(ZooKeeper zooKeeper)
{    if (isZK34() || (queueEventMethod == null)) {        InjectSessionExpiration.injectSessionExpiration(zooKeeper);    } else {        try {            WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);            queueEventMethod.invoke(zooKeeper.getTestable(), event);        } catch (Exception e) {                    }    }}
1
public void addTrace(String name, long time, TimeUnit unit)
{    if (log.isTraceEnabled()) {        log.trace("Trace: " + name + " - " + TimeUnit.MILLISECONDS.convert(time, unit) + " ms");    }}
0
public void addCount(String name, int increment)
{    if (log.isTraceEnabled()) {        log.trace("Counter " + name + ": " + increment);    }}
0
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);}
0
public void ensure(CuratorZookeeperClient client, String path, final boolean makeLastNode) throws Exception
{}
0
public void ensure(CuratorZookeeperClient client) throws Exception
{    Helper localHelper = helper.get();    localHelper.ensure(client, path, makeLastNode);}
0
public EnsurePath excludingLast()
{    return new EnsurePath(path, helper, false, aclProvider);}
0
public String getPath()
{    return this.path;}
0
protected boolean asContainers()
{    return false;}
0
public synchronized void ensure(final CuratorZookeeperClient client, final String path, final boolean makeLastNode) throws Exception
{    if (!isSet) {        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());                helper.set(doNothingHelper);                isSet = true;                return null;            }        });    }}
0
public Object call() throws Exception
{    ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());    helper.set(doNothingHelper);    isSet = true;    return null;}
0
public void propagate()
{    if (mainEx != null) {        Throwables.propagate(mainEx);    }}
0
public void add(Throwable e)
{    if (e instanceof InterruptedException) {        if (mainEx != null) {            e.addSuppressed(mainEx);        }        Thread.currentThread().interrupt();    }    if (mainEx == null) {        mainEx = e;    } else {        mainEx.addSuppressed(e);    }}
0
public static void injectSessionExpiration(ZooKeeper zooKeeper)
{    try {        WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zooKeeper);        Object eventThread = eventThreadField.get(clientCnxn);        queueEventMethod.invoke(eventThread, event);        } catch (ReflectiveOperationException e) {        throw new RuntimeException("Could not inject session expiration using reflection", e);    }}
0
public static void validatePath(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
0
public static String validatePath(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return path;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c < '\u001f' || c > '\u007f' && c < '\u009F' || c > '\ud800' && c < '\uf8ff' || c > '\ufff0' && c < '\uffff') {            reason = "invalid charater @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }    return path;}
0
public static boolean checkInterrupted(Throwable e)
{    if (e instanceof InterruptedException) {        Thread.currentThread().interrupt();        return true;    }    return false;}
0
public static ExecutorService newSingleThreadExecutor(String processName)
{    return Executors.newSingleThreadExecutor(newThreadFactory(processName));}
0
public static ExecutorService newFixedThreadPool(int qty, String processName)
{    return Executors.newFixedThreadPool(qty, newThreadFactory(processName));}
0
public static ScheduledExecutorService newSingleThreadScheduledExecutor(String processName)
{    return Executors.newSingleThreadScheduledExecutor(newThreadFactory(processName));}
0
public static ScheduledExecutorService newFixedThreadScheduledPool(int qty, String processName)
{    return Executors.newScheduledThreadPool(qty, newThreadFactory(processName));}
0
public static ThreadFactory newThreadFactory(String processName)
{    return newGenericThreadFactory("Curator-" + processName);}
0
public static ThreadFactory newGenericThreadFactory(String processName)
{    Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {        @Override        public void uncaughtException(Thread t, Throwable e) {                        Throwables.propagate(e);        }    };    return new ThreadFactoryBuilder().setNameFormat(processName + "-%d").setDaemon(true).setUncaughtExceptionHandler(uncaughtExceptionHandler).build();}
1
public void uncaughtException(Thread t, Throwable e)
{        Throwables.propagate(e);}
1
public static String getProcessName(Class<?> clazz)
{    if (clazz.isAnonymousClass()) {        return getProcessName(clazz.getEnclosingClass());    }    return clazz.getSimpleName();}
0
public static CreateMode getContainerCreateMode()
{    return CreateModeHolder.containerCreateMode;}
0
public static boolean hasContainerSupport()
{    return getContainerCreateMode() != NON_CONTAINER_MODE;}
0
public static String fixForNamespace(String namespace, String path)
{    return fixForNamespace(namespace, path, false);}
0
public static String fixForNamespace(String namespace, String path, boolean isSequential)
{        PathUtils.validatePath(path, isSequential);    if (namespace != null) {        return makePath(namespace, path);    }    return path;}
0
public static String getNodeFromPath(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return path;    }    if ((i + 1) >= path.length()) {        return "";    }    return path.substring(i + 1);}
0
public String getPath()
{    return path;}
0
public String getNode()
{    return node;}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + node.hashCode();    result = prime * result + path.hashCode();    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PathAndNode other = (PathAndNode) obj;    if (!node.equals(other.node)) {        return false;    }    if (!path.equals(other.path)) {        return false;    }    return true;}
0
public String toString()
{    return "PathAndNode [path=" + path + ", node=" + node + "]";}
0
public static PathAndNode getPathAndNode(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return new PathAndNode(path, "");    }    if ((i + 1) >= path.length()) {        return new PathAndNode(PATH_SEPARATOR, "");    }    String node = path.substring(i + 1);    String parentPath = (i > 0) ? path.substring(0, i) : PATH_SEPARATOR;    return new PathAndNode(parentPath, node);}
0
public static String extractSequentialSuffix(String path)
{    int length = path.length();    return length > SEQUENTIAL_SUFFIX_DIGITS ? path.substring(length - SEQUENTIAL_SUFFIX_DIGITS) : path;}
0
public static List<String> split(String path)
{    PathUtils.validatePath(path);    return PATH_SPLITTER.splitToList(path);}
0
public static void mkdirs(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, true, null, false);}
0
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, null, false);}
0
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, aclProvider, false);}
0
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider, boolean asContainers) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);        int pos = 1;    do {        pos = path.indexOf(PATH_SEPARATOR_CHAR, pos + 1);        if (pos == -1) {            if (makeLastNode) {                pos = path.length();            } else {                break;            }        }        String subPath = path.substring(0, pos);        if (zookeeper.exists(subPath, false) == null) {            try {                List<ACL> acl = null;                if (aclProvider != null) {                    acl = aclProvider.getAclForPath(subPath);                    if (acl == null) {                        acl = aclProvider.getDefaultAcl();                    }                }                if (acl == null) {                    acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;                }                zookeeper.create(subPath, new byte[0], acl, getCreateMode(asContainers));            } catch (KeeperException.NodeExistsException e) {                        }        }    } while (pos < path.length());}
0
public static void deleteChildren(ZooKeeper zookeeper, String path, boolean deleteSelf) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    List<String> children;    try {        children = zookeeper.getChildren(path, null);    } catch (KeeperException.NoNodeException e) {                return;    }    for (String child : children) {        String fullPath = makePath(path, child);        deleteChildren(zookeeper, fullPath, true);    }    if (deleteSelf) {        try {            zookeeper.delete(path, -1);        } catch (KeeperException.NotEmptyException e) {                        deleteChildren(zookeeper, path, true);        } catch (KeeperException.NoNodeException e) {                }    }}
0
public static List<String> getSortedChildren(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    List<String> children = zookeeper.getChildren(path, false);    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList);    return sortedList;}
0
public static String makePath(String parent, String child)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(child) + 2;        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, child);    return path.toString();}
0
public static String makePath(String parent, String firstChild, String... restChildren)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(firstChild) + 2;    if (restChildren != null) {        for (String child : restChildren) {                        maxPathLength += nullableStringLength(child) + 1;        }    }        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, firstChild);    if (restChildren == null) {        return path.toString();    } else {        for (String child : restChildren) {            joinPath(path, "", child);        }        return path.toString();    }}
0
private static int nullableStringLength(String s)
{    return s != null ? s.length() : 0;}
0
private static void joinPath(StringBuilder path, String parent, String child)
{        if ((parent != null) && (parent.length() > 0)) {        if (parent.charAt(0) != PATH_SEPARATOR_CHAR) {            path.append(PATH_SEPARATOR_CHAR);        }        if (parent.charAt(parent.length() - 1) == PATH_SEPARATOR_CHAR) {            path.append(parent, 0, parent.length() - 1);        } else {            path.append(parent);        }    }    if ((child == null) || (child.length() == 0) || (child.length() == 1 && child.charAt(0) == PATH_SEPARATOR_CHAR)) {                if (path.length() == 0) {            path.append(PATH_SEPARATOR_CHAR);        }        return;    }        path.append(PATH_SEPARATOR_CHAR);    int childAppendBeginIndex;    if (child.charAt(0) == PATH_SEPARATOR_CHAR) {        childAppendBeginIndex = 1;    } else {        childAppendBeginIndex = 0;    }    int childAppendEndIndex;    if (child.charAt(child.length() - 1) == PATH_SEPARATOR_CHAR) {        childAppendEndIndex = child.length() - 1;    } else {        childAppendEndIndex = child.length();    }        path.append(child, childAppendBeginIndex, childAppendEndIndex);}
0
private static CreateMode getCreateMode(boolean asContainers)
{    return asContainers ? getContainerCreateMode() : CreateMode.PERSISTENT;}
0
public void testFactory() throws Exception
{    final ZooKeeper mockZookeeper = Mockito.mock(ZooKeeper.class);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            return mockZookeeper;        }    };    CuratorZookeeperClient client = new CuratorZookeeperClient(zookeeperFactory, new FixedEnsembleProvider(server.getConnectString()), 10000, 10000, null, new RetryOneTime(1), false);    client.start();    Assert.assertEquals(client.getZooKeeper(), mockZookeeper);}
0
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return mockZookeeper;}
0
public void testExpiredSession() throws Exception
{        final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getState() == Event.KeeperState.Expired) {                latch.countDown();            }        }    };    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), watcher, new RetryOneTime(2));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                if (firstTime.compareAndSet(true, false)) {                    try {                        client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (KeeperException.NodeExistsException ignore) {                                        }                    Compatibility.injectSessionExpiration(client.getZooKeeper());                    Assert.assertTrue(timing.awaitLatch(latch));                }                ZooKeeper zooKeeper = client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();                Assert.assertNotNull(zooKeeper.exists("/foo", false));                return null;            }        });    } finally {        client.close();    }}
0
public void process(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        latch.countDown();    }}
0
public Object call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        try {            client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ignore) {                }        Compatibility.injectSessionExpiration(client.getZooKeeper());        Assert.assertTrue(timing.awaitLatch(latch));    }    ZooKeeper zooKeeper = client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNotNull(zooKeeper.exists("/foo", false));    return null;}
0
public void testReconnect() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        byte[] writtenData = { 1, 2, 3 };        client.getZooKeeper().create("/test", writtenData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread.sleep(1000);        server.stop();        Thread.sleep(1000);        server.restart();        Assert.assertTrue(client.blockUntilConnectedOrTimedOut());        byte[] readData = client.getZooKeeper().getData("/test", false, null);        Assert.assertEquals(readData, writtenData);    } finally {        client.close();    }}
0
public void testSimple() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        String path = client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Assert.assertEquals(path, "/test");    } finally {        client.close();    }}
0
public void testBackgroundConnect() throws Exception
{    final int CONNECTION_TIMEOUT_MS = 4000;    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, CONNECTION_TIMEOUT_MS, null, new RetryOneTime(1));    try {        Assert.assertFalse(client.isConnected());        client.start();        outer: do {            for (int i = 0; i < (CONNECTION_TIMEOUT_MS / 1000); ++i) {                if (client.isConnected()) {                    break outer;                }                Thread.sleep(CONNECTION_TIMEOUT_MS);            }            Assert.fail();        } while (false);    } finally {        client.close();    }}
0
public String getBackupConnectionString() throws Exception
{    return null;}
0
public void testExhibitorFailures() throws Exception
{    final AtomicReference<String> backupConnectionString = new AtomicReference<String>("backup1:1");    final AtomicReference<String> connectionString = new AtomicReference<String>("count=1&port=2&server0=localhost");    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, new Exhibitors.BackupConnectionStringProvider() {        @Override        public String getBackupConnectionString() {            return backupConnectionString.get();        }    });    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            String localConnectionString = connectionString.get();            if (localConnectionString == null) {                throw new IOException();            }            return localConnectionString;        }    };    final Semaphore semaphore = new Semaphore(0);    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1)) {        @Override        protected void poll() {            super.poll();            semaphore.release();        }    };    provider.pollForInitialEnsemble();    try {        provider.start();        Assert.assertEquals(provider.getConnectionString(), "localhost:2");        connectionString.set(null);        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup1:1");        backupConnectionString.set("backup2:2");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup2:2");        connectionString.set("count=1&port=3&server0=localhost3");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "localhost3:3");    } finally {        CloseableUtils.closeQuietly(provider);    }}
0
public String getBackupConnectionString()
{    return backupConnectionString.get();}
0
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    String localConnectionString = connectionString.get();    if (localConnectionString == null) {        throw new IOException();    }    return localConnectionString;}
0
protected void poll()
{    super.poll();    semaphore.release();}
0
public void testChanging() throws Exception
{    TestingServer secondServer = new TestingServer();    try {        String mainConnectionString = "count=1&port=" + server.getPort() + "&server0=localhost";        String secondConnectionString = "count=1&port=" + secondServer.getPort() + "&server0=localhost";        final Semaphore semaphore = new Semaphore(0);        final AtomicReference<String> connectionString = new AtomicReference<String>(mainConnectionString);        Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);        ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {            @Override            public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {                semaphore.release();                return connectionString.get();            }        };        ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));        provider.pollForInitialEnsemble();        Timing timing = new Timing().multiple(4);        final CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new RetryOneTime(2));        client.start();        try {            RetryLoop.callWithRetry(client, new Callable<Object>() {                @Override                public Object call() throws Exception {                    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    return null;                }            });            connectionString.set(secondConnectionString);            semaphore.drainPermits();            semaphore.acquire();                        server.stop();            Stat stat = RetryLoop.callWithRetry(client, new Callable<Stat>() {                @Override                public Stat call() throws Exception {                    return client.getZooKeeper().exists("/test", false);                }            });                        Assert.assertNull(stat);        } finally {            client.close();        }    } finally {        CloseableUtils.closeQuietly(secondServer);    }}
0
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    semaphore.release();    return connectionString.get();}
0
public Object call() throws Exception
{    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    return null;}
0
public Stat call() throws Exception
{    return client.getZooKeeper().exists("/test", false);}
0
public void testSimple() throws Exception
{    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            return "count=1&port=" + server.getPort() + "&server0=localhost";        }    };    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));    provider.pollForInitialEnsemble();    Timing timing = new Timing();    CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new ExponentialBackoffRetry(timing.milliseconds(), 3));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        client.getZooKeeper().exists("/", false);    } catch (Exception e) {        Assert.fail("provider.getConnectionString(): " + provider.getConnectionString() + " server.getPort(): " + server.getPort(), e);    } finally {        client.close();    }}
0
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    return "count=1&port=" + server.getPort() + "&server0=localhost";}
0
public void testBasic() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    Stat fakeStat = mock(Stat.class);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenReturn(fakeStat);    EnsurePath ensurePath = new EnsurePath("/one/two/three");    ensurePath.ensure(curator);    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
0
public void testSimultaneous() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    final CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    final Stat fakeStat = mock(Stat.class);    final CountDownLatch startedLatch = new CountDownLatch(2);    final CountDownLatch finishedLatch = new CountDownLatch(2);    final Semaphore semaphore = new Semaphore(0);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenAnswer(new Answer<Stat>() {        @Override        public Stat answer(InvocationOnMock invocation) throws Throwable {            semaphore.acquire();            return fakeStat;        }    });    final EnsurePath ensurePath = new EnsurePath("/one/two/three");    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < 2; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                startedLatch.countDown();                ensurePath.ensure(curator);                finishedLatch.countDown();                return null;            }        });    }    Assert.assertTrue(startedLatch.await(10, TimeUnit.SECONDS));    semaphore.release(3);    Assert.assertTrue(finishedLatch.await(10, TimeUnit.SECONDS));    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
0
public Stat answer(InvocationOnMock invocation) throws Throwable
{    semaphore.acquire();    return fakeStat;}
0
public Void call() throws Exception
{    startedLatch.countDown();    ensurePath.ensure(curator);    finishedLatch.countDown();    return null;}
0
public void testExponentialBackoffRetryLimit()
{    RetrySleeper sleeper = new RetrySleeper() {        @Override        public void sleepFor(long time, TimeUnit unit) throws InterruptedException {            Assert.assertTrue(unit.toMillis(time) <= 100);        }    };    ExponentialBackoffRetry retry = new ExponentialBackoffRetry(1, Integer.MAX_VALUE, 100);    for (int i = 0; i >= 0; ++i) {        retry.allowRetry(i, 0, sleeper);    }}
0
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    Assert.assertTrue(unit.toMillis(time) <= 100);}
0
public void testRetryLoopWithFailure() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 5000, 5000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        outer: while (retryLoop.shouldContinue()) {            ++loopCount;            switch(loopCount) {                case 1:                    {                        server.stop();                        break;                    }                case 2:                    {                        server.restart();                        break;                    }                case 3:                case 4:                    {                                                break;                    }                default:                    {                        Assert.fail();                        break outer;                    }            }            try {                client.blockUntilConnectedOrTimedOut();                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount >= 2);    } finally {        client.close();    }}
0
public void testRetryLoop() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        while (retryLoop.shouldContinue()) {            if (++loopCount > 2) {                Assert.fail();                break;            }            try {                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount > 0);    } finally {        client.close();    }}
0
public void testRetryForever() throws Exception
{    int retryIntervalMs = 1;    RetrySleeper sleeper = Mockito.mock(RetrySleeper.class);    RetryForever retryForever = new RetryForever(retryIntervalMs);    for (int i = 0; i < 10; i++) {        boolean allowed = retryForever.allowRetry(i, 0, sleeper);        Assert.assertTrue(allowed);        Mockito.verify(sleeper, times(i + 1)).sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    }}
0
public void testRetry() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        while (retryLoop.shouldContinue()) {            try {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
0
public Void call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
0
public Void call() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
0
public void testRetryStatic() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.RETRY, new Callable<Object>() {            @Override            public Object call() throws Exception {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });                return null;            }        });        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
0
public Object call() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            if (firstTime.compareAndSet(true, false)) {                Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                Compatibility.injectSessionExpiration(client.getZooKeeper());                client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();            }            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertFalse(firstTime.get());            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            secondWasDone.set(true);            return null;        }    });    return null;}
0
public Void call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
0
public Void call() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
0
public void testBasic() throws Exception
{    final Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            while (retryLoop.shouldContinue()) {                try {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            timing.sleepABit();                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                } catch (Exception e) {                    retryLoop.takeException(e);                }            }            Assert.fail();        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
0
public Void call() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    timing.sleepABit();    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
0
public void testBasicStatic() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.FAIL, new Callable<Object>() {                @Override                public Object call() throws Exception {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                    return null;                }            });        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
0
public Object call() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            Compatibility.injectSessionExpiration(client.getZooKeeper());            client.getZooKeeper();            client.blockUntilConnectedOrTimedOut();            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    return null;}
0
public Void call() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
0
public void setup()
{    executorService = Executors.newFixedThreadPool(QTY * 2);}
0
public void tearDown()
{    executorService.shutdownNow();}
0
public void testBasicRunnable() throws InterruptedException
{    try {        CloseableExecutorService service = new CloseableExecutorService(executorService);        CountDownLatch startLatch = new CountDownLatch(QTY);        CountDownLatch latch = new CountDownLatch(QTY);        for (int i = 0; i < QTY; ++i) {            submitRunnable(service, startLatch, latch);        }        Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));        service.close();        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    } catch (AssertionError e) {        throw e;    } catch (Throwable e) {        e.printStackTrace();    }}
0
public void testBasicCallable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    final CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                } finally {                    latch.countDown();                }                return null;            }        });    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));}
0
public Void call() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }    return null;}
0
public void testListeningRunnable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    List<Future<?>> futures = Lists.newArrayList();    final CountDownLatch startLatch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Runnable() {            @Override            public void run() {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
0
public void run()
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
0
public void testListeningCallable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    List<Future<?>> futures = Lists.newArrayList();    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return null;            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
0
public Void call() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return null;}
0
public void testPartialRunnable() throws InterruptedException
{    final CountDownLatch outsideLatch = new CountDownLatch(1);    executorService.submit(new Runnable() {        @Override        public void run() {            try {                Thread.currentThread().join();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                outsideLatch.countDown();            }        }    });    CloseableExecutorService service = new CloseableExecutorService(executorService);    CountDownLatch startLatch = new CountDownLatch(QTY);    CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        submitRunnable(service, startLatch, latch);    }    while (service.size() < QTY) {        Thread.sleep(100);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    Assert.assertEquals(outsideLatch.getCount(), 1);}
0
public void run()
{    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        outsideLatch.countDown();    }}
0
private void submitRunnable(CloseableExecutorService service, final CountDownLatch startLatch, final CountDownLatch latch)
{    service.submit(new Runnable() {        @Override        public void run() {            try {                startLatch.countDown();                Thread.sleep(100000);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                latch.countDown();            }        }    });}
0
public void run()
{    try {        startLatch.countDown();        Thread.sleep(100000);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }}
0
public void setup()
{    executorService = Executors.newScheduledThreadPool(QTY * 2);}
0
public void tearDown()
{    executorService.shutdownNow();}
0
public void testCloseableScheduleWithFixedDelay() throws InterruptedException
{    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final CountDownLatch latch = new CountDownLatch(QTY);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            latch.countDown();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Assert.assertTrue(latch.await((QTY * 2) * DELAY_MS, TimeUnit.MILLISECONDS));}
0
public void run()
{    latch.countDown();}
0
public void testCloseableScheduleWithFixedDelayAndAdditionalTasks() throws InterruptedException
{    final AtomicInteger outerCounter = new AtomicInteger(0);    Runnable command = new Runnable() {        @Override        public void run() {            outerCounter.incrementAndGet();        }    };    executorService.scheduleWithFixedDelay(command, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final AtomicInteger innerCounter = new AtomicInteger(0);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            innerCounter.incrementAndGet();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Thread.sleep(DELAY_MS * 4);    service.close();    Thread.sleep(DELAY_MS * 2);    int innerValue = innerCounter.get();    Assert.assertTrue(innerValue > 0);    int value = outerCounter.get();    Thread.sleep(DELAY_MS * 2);    int newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());    value = newValue;    Thread.sleep(DELAY_MS * 2);    newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());}
0
public void run()
{    outerCounter.incrementAndGet();}
0
public void run()
{    innerCounter.incrementAndGet();}
0
public void testMakePath()
{    Assert.assertEquals(ZKPaths.makePath(null, "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", null), "/");    Assert.assertEquals(ZKPaths.makePath("/", null), "/");    Assert.assertEquals(ZKPaths.makePath(null, null), "/");    Assert.assertEquals(ZKPaths.makePath("/", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("/", ""), "/");    Assert.assertEquals(ZKPaths.makePath("", ""), "/");    Assert.assertEquals(ZKPaths.makePath("foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz", "qux"), "/foo/bar/baz/qux");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar", "/baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/", "/baz/"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", null, null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", null), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", null, "baz"), "/foo/baz");}
0
public void testSplit()
{    Assert.assertEquals(ZKPaths.split("/"), Collections.emptyList());    Assert.assertEquals(ZKPaths.split("/test"), Collections.singletonList("test"));    Assert.assertEquals(ZKPaths.split("/test/one"), Arrays.asList("test", "one"));    Assert.assertEquals(ZKPaths.split("/test/one/two"), Arrays.asList("test", "one", "two"));}
0
public static AsyncCuratorFramework wrap(CuratorFramework client)
{        return AsyncCuratorFramework.wrap(client);}
0
public static void create(CuratorFramework client, String path, byte[] payload)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath(path, payload).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            System.out.println("Created node name is: " + name);        }    });}
0
public static void createThenWatch(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                        async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            handleWatchedStage(async.watched().checkExists().forPath(path).event());        }    });}
0
public static void createThenWatchSimple(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {                                    async.with(WatchMode.successOnly).watched().checkExists().forPath(path).event().thenAccept(event -> {                System.out.println(event.getType());                System.out.println(event);            });        }    });}
0
private static void handleWatchedStage(CompletionStage<WatchedEvent> watchedStage)
{                watchedStage.thenAccept(event -> {        System.out.println(event.getType());        System.out.println(event);        });                watchedStage.exceptionally(exception -> {        AsyncEventException asyncEx = (AsyncEventException) exception;                asyncEx.printStackTrace();        handleWatchedStage(asyncEx.reset());        return null;    });}
0
public static void main(String[] args) throws Exception
{    TestingServer server = new TestingServer();    CuratorFramework client = null;    PathChildrenCache cache = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();                cache = new PathChildrenCache(client, PATH, true);        cache.start();        processCommands(client, cache);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
0
private static void addListener(PathChildrenCache cache)
{        PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            switch(event.getType()) {                case CHILD_ADDED:                    {                        System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_UPDATED:                    {                        System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_REMOVED:                    {                        System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }            }        }    };    cache.getListenable().addListener(listener);}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    switch(event.getType()) {        case CHILD_ADDED:            {                System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_UPDATED:            {                System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_REMOVED:            {                System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }    }}
0
private static void processCommands(CuratorFramework client, PathChildrenCache cache) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        addListener(cache);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("set")) {                setValue(client, command, args);            } else if (operation.equals("remove")) {                remove(client, command, args);            } else if (operation.equals("list")) {                list(cache);            }                        Thread.sleep(1000);        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
0
private static void list(PathChildrenCache cache)
{    if (cache.getCurrentData().size() == 0) {        System.out.println("* empty *");    } else {        for (ChildData data : cache.getCurrentData()) {            System.out.println(data.getPath() + " = " + new String(data.getData()));        }    }}
0
private static void remove(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected remove <path>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    try {        client.delete().forPath(path);    } catch (KeeperException.NoNodeException e) {        }}
0
private static void setValue(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("syntax error (expected set <path> <value>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    byte[] bytes = args[1].getBytes();    try {        client.setData().forPath(path, bytes);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentContainersIfNeeded().forPath(path, bytes);    }}
0
private static void printHelp()
{    System.out.println("An example of using PathChildrenCache. This example is driven by entering commands at the prompt:\n");    System.out.println("set <name> <value>: Adds or updates a node with the given name");    System.out.println("remove <name>: Deletes the node with the given name");    System.out.println("list: List the nodes/values in the cache");    System.out.println("quit: Quit the example");    System.out.println();}
0
public static void main(String[] args) throws Exception
{    CuratorFramework client = CreateClientExamples.createSimple("127.0.0.1:2181");    client.getUnhandledErrorListenable().addListener((message, e) -> {        System.err.println("error=" + message);        e.printStackTrace();    });    client.getConnectionStateListenable().addListener((c, newState) -> {        System.out.println("state=" + newState);    });    client.start();    TreeCache cache = TreeCache.newBuilder(client, "/").setCacheData(false).build();    cache.getListenable().addListener((c, event) -> {        if (event.getData() != null) {            System.out.println("type=" + event.getType() + " path=" + event.getData().getPath());        } else {            System.out.println("type=" + event.getType());        }    });    cache.start();    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    in.readLine();}
0
public static void main(String[] args) throws Exception
{        TestingServer server = new TestingServer();    CuratorFramework client = null;    ServiceDiscovery<InstanceDetails> serviceDiscovery = null;    Map<String, ServiceProvider<InstanceDetails>> providers = Maps.newHashMap();    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();        JsonInstanceSerializer<InstanceDetails> serializer = new JsonInstanceSerializer<InstanceDetails>(InstanceDetails.class);        serviceDiscovery = ServiceDiscoveryBuilder.builder(InstanceDetails.class).client(client).basePath(PATH).serializer(serializer).build();        serviceDiscovery.start();        processCommands(serviceDiscovery, providers, client);    } finally {        for (ServiceProvider<InstanceDetails> cache : providers.values()) {            CloseableUtils.closeQuietly(cache);        }        CloseableUtils.closeQuietly(serviceDiscovery);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
0
private static void processCommands(ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, CuratorFramework client) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("add")) {                addInstance(args, client, command, servers);            } else if (operation.equals("delete")) {                deleteInstance(args, command, servers);            } else if (operation.equals("random")) {                listRandomInstance(args, serviceDiscovery, providers, command);            } else if (operation.equals("list")) {                listInstances(serviceDiscovery);            }        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
0
private static void listRandomInstance(String[] args, ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, String command) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected random <name>): " + command);        return;    }    String serviceName = args[0];    ServiceProvider<InstanceDetails> provider = providers.get(serviceName);    if (provider == null) {        provider = serviceDiscovery.serviceProviderBuilder().serviceName(serviceName).providerStrategy(new RandomStrategy<InstanceDetails>()).build();        providers.put(serviceName, provider);        provider.start();                Thread.sleep(2500);    }    ServiceInstance<InstanceDetails> instance = provider.getInstance();    if (instance == null) {        System.err.println("No instances named: " + serviceName);    } else {        outputInstance(instance);    }}
0
private static void listInstances(ServiceDiscovery<InstanceDetails> serviceDiscovery) throws Exception
{    try {        Collection<String> serviceNames = serviceDiscovery.queryForNames();        System.out.println(serviceNames.size() + " type(s)");        for (String serviceName : serviceNames) {            Collection<ServiceInstance<InstanceDetails>> instances = serviceDiscovery.queryForInstances(serviceName);            System.out.println(serviceName);            for (ServiceInstance<InstanceDetails> instance : instances) {                outputInstance(instance);            }        }    } finally {        CloseableUtils.closeQuietly(serviceDiscovery);    }}
0
private static void outputInstance(ServiceInstance<InstanceDetails> instance)
{    System.out.println("\t" + instance.getPayload().getDescription() + ": " + instance.buildUriSpec());}
0
private static void deleteInstance(String[] args, String command, List<ExampleServer> servers)
{    if (args.length != 1) {        System.err.println("syntax error (expected delete <name>): " + command);        return;    }    final String serviceName = args[0];    ExampleServer server = Iterables.find(servers, new Predicate<ExampleServer>() {        @Override        public boolean apply(ExampleServer server) {            return server.getThisInstance().getName().endsWith(serviceName);        }    }, null);    if (server == null) {        System.err.println("No servers found named: " + serviceName);        return;    }    servers.remove(server);    CloseableUtils.closeQuietly(server);    System.out.println("Removed a random instance of: " + serviceName);}
0
public boolean apply(ExampleServer server)
{    return server.getThisInstance().getName().endsWith(serviceName);}
0
private static void addInstance(String[] args, CuratorFramework client, String command, List<ExampleServer> servers) throws Exception
{    if (args.length < 2) {        System.err.println("syntax error (expected add <name> <description>): " + command);        return;    }    StringBuilder description = new StringBuilder();    for (int i = 1; i < args.length; ++i) {        if (i > 1) {            description.append(' ');        }        description.append(args[i]);    }    String serviceName = args[0];    ExampleServer server = new ExampleServer(client, PATH, serviceName, description.toString());    servers.add(server);    server.start();    System.out.println(serviceName + " added");}
0
private static void printHelp()
{    System.out.println("An example of using the ServiceDiscovery APIs. This example is driven by entering commands at the prompt:\n");    System.out.println("add <name> <description>: Adds a mock service with the given name and description");    System.out.println("delete <name>: Deletes one of the mock services with the given name");    System.out.println("list: Lists all the currently registered services");    System.out.println("random <name>: Lists a random instance of the service with the given name");    System.out.println("quit: Quit the example");    System.out.println();}
0
public ServiceInstance<InstanceDetails> getThisInstance()
{    return thisInstance;}
0
public void start() throws Exception
{    serviceDiscovery.start();}
0
public void close() throws IOException
{    CloseableUtils.closeQuietly(serviceDiscovery);}
0
public void setDescription(String description)
{    this.description = description;}
0
public String getDescription()
{    return description;}
0
public static CuratorFramework createSimple(String connectionString)
{                ExponentialBackoffRetry retryPolicy = new ExponentialBackoffRetry(1000, 3);        return CuratorFrameworkFactory.newClient(connectionString, retryPolicy);}
0
public static CuratorFramework createWithOptions(String connectionString, RetryPolicy retryPolicy, int connectionTimeoutMs, int sessionTimeoutMs)
{        return CuratorFrameworkFactory.builder().connectString(connectionString).retryPolicy(retryPolicy).connectionTimeoutMs(connectionTimeoutMs).sessionTimeoutMs(sessionTimeoutMs).build();}
0
public static void create(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().forPath(path, payload);}
0
public static void createEphemeral(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().withMode(CreateMode.EPHEMERAL).forPath(path, payload);}
0
public static String createEphemeralSequential(CuratorFramework client, String path, byte[] payload) throws Exception
{    /*            Protection Mode:            It turns out there is an edge case that exists when creating sequential-ephemeral nodes. The creation            can succeed on the server, but the server can crash before the created node name is returned to the            client. However, the ZK session is still valid so the ephemeral node is not deleted. Thus, there is no            way for the client to determine what node was created for them.            Even without sequential-ephemeral, however, the create can succeed on the sever but the client (for various            reasons) will not know it. Putting the create builder into protection mode works around this. The name of            the node that is created is prefixed with a GUID. If node creation fails the normal retry mechanism will            occur. On the retry, the parent path is first searched for a node that has the GUID in it. If that node is            found, it is assumed to be the lost node that was successfully created on the first try and is returned to            the caller.         */    return client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, payload);}
0
public static void setData(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.setData().forPath(path, payload);}
0
public static void setDataAsync(CuratorFramework client, String path, byte[] payload) throws Exception
{        CuratorListener listener = new CuratorListener() {        @Override        public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                }    };    client.getCuratorListenable().addListener(listener);            client.setData().inBackground().forPath(path, payload);}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{}
0
public static void setDataAsyncWithCallback(CuratorFramework client, BackgroundCallback callback, String path, byte[] payload) throws Exception
{        client.setData().inBackground(callback).forPath(path, payload);}
0
public static void delete(CuratorFramework client, String path) throws Exception
{        client.delete().forPath(path);}
0
public static void guaranteedDelete(CuratorFramework client, String path) throws Exception
{        /*            Guaranteed Delete            Solves this edge case: deleting a node can fail due to connection issues. Further, if the node was            ephemeral, the node will not get auto-deleted as the session is still valid. This can wreak havoc            with lock implementations.            When guaranteed is set, Curator will record failed node deletions and attempt to delete them in the            background until successful. NOTE: you will still get an exception when the deletion fails. But, you            can be assured that as long as the CuratorFramework instance is open attempts will be made to delete            the node.         */    client.delete().guaranteed().forPath(path);}
0
public static List<String> watchedGetChildren(CuratorFramework client, String path) throws Exception
{    /**     * Get children and set a watcher on the node. The watcher notification will come through the     * CuratorListener (see setDataAsync() above).     */    return client.getChildren().watched().forPath(path);}
0
public static List<String> watchedGetChildren(CuratorFramework client, String path, Watcher watcher) throws Exception
{    /**     * Get children and set the given watcher on the node.     */    return client.getChildren().usingWatcher(watcher).forPath(path);}
0
public static Collection<CuratorTransactionResult> transaction(CuratorFramework client) throws Exception
{        CuratorOp createOp = client.transactionOp().create().forPath("/a/path", "some data".getBytes());    CuratorOp setDataOp = client.transactionOp().setData().forPath("/another/path", "other data".getBytes());    CuratorOp deleteOp = client.transactionOp().delete().forPath("/yet/another/path");    Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp, setDataOp, deleteOp);    for (CuratorTransactionResult result : results) {        System.out.println(result.getForPath() + " - " + result.getType());    }    return results;}
0
public void start() throws IOException
{            leaderSelector.start();}
0
public void close() throws IOException
{    leaderSelector.close();}
0
public void takeLeadership(CuratorFramework client) throws Exception
{        final int waitSeconds = (int) (5 * Math.random()) + 1;    System.out.println(name + " is now the leader. Waiting " + waitSeconds + " seconds...");    System.out.println(name + " has been leader " + leaderCount.getAndIncrement() + " time(s) before.");    try {        Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));    } catch (InterruptedException e) {        System.err.println(name + " was interrupted.");        Thread.currentThread().interrupt();    } finally {        System.out.println(name + " relinquishing leadership.\n");    }}
0
public static void main(String[] args) throws Exception
{        System.out.println("Create " + CLIENT_QTY + " clients, have each negotiate for leadership and then wait a random number of seconds before letting another leader election occur.");    System.out.println("Notice that leader election is fair: all clients will become leader and will do so the same number of times.");    List<CuratorFramework> clients = Lists.newArrayList();    List<ExampleClient> examples = Lists.newArrayList();    TestingServer server = new TestingServer();    try {        for (int i = 0; i < CLIENT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));            clients.add(client);            ExampleClient example = new ExampleClient(client, PATH, "Client #" + i);            examples.add(example);            client.start();            example.start();        }        System.out.println("Press enter/return to quit\n");        new BufferedReader(new InputStreamReader(System.in)).readLine();    } finally {        System.out.println("Shutting down...");        for (ExampleClient exampleClient : examples) {            CloseableUtils.closeQuietly(exampleClient);        }        for (CuratorFramework client : clients) {            CloseableUtils.closeQuietly(client);        }        CloseableUtils.closeQuietly(server);    }}
0
public void doWork(long time, TimeUnit unit) throws Exception
{    if (!lock.acquire(time, unit)) {        throw new IllegalStateException(clientName + " could not acquire the lock");    }    try {        System.out.println(clientName + " has the lock");        resource.use();    } finally {        System.out.println(clientName + " releasing the lock");                lock.release();    }}
0
public void use() throws InterruptedException
{    if (!inUse.compareAndSet(false, true)) {        throw new IllegalStateException("Needs to be used by one client at a time");    }    try {        Thread.sleep((long) (3 * Math.random()));    } finally {        inUse.set(false);    }}
0
public static void main(String[] args) throws Exception
{            final FakeLimitedResource resource = new FakeLimitedResource();    ExecutorService service = Executors.newFixedThreadPool(QTY);    final TestingServer server = new TestingServer();    try {        for (int i = 0; i < QTY; ++i) {            final int index = i;            Callable<Void> task = new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));                    try {                        client.start();                        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);                        for (int j = 0; j < REPETITIONS; ++j) {                            example.doWork(10, TimeUnit.SECONDS);                        }                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                    } catch (Exception e) {                        e.printStackTrace();                                        } finally {                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            };            service.submit(task);        }        service.shutdown();        service.awaitTermination(10, TimeUnit.MINUTES);    } finally {        CloseableUtils.closeQuietly(server);    }}
0
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));    try {        client.start();        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);        for (int j = 0; j < REPETITIONS; ++j) {            example.doWork(10, TimeUnit.SECONDS);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } catch (Exception e) {        e.printStackTrace();        } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
0
public int getTypeId()
{    return typeId;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ContainerType that = (ContainerType) o;    return typeId == that.typeId;}
0
public int hashCode()
{    return typeId;}
0
public String toString()
{    return "ContainerType{" + "typeId=" + typeId + '}';}
0
public static ModeledFramework<PersonModel> wrap(AsyncCuratorFramework client)
{    JacksonModelSerializer<PersonModel> serializer = JacksonModelSerializer.build(PersonModel.class);        ModelSpec<PersonModel> modelSpec = ModelSpec.builder(ZPath.parse("/example/path"), serializer).build();        return ModeledFramework.wrap(client, modelSpec);}
0
public static void createOrUpdate(ModeledFramework<PersonModel> modeled, PersonModel model)
{        ModeledFramework<PersonModel> atId = modeled.child(model.getId().getId());                atId.set(model);}
0
public static void readPerson(ModeledFramework<PersonModel> modeled, String id, Consumer<PersonModel> receiver)
{        modeled.child(id).read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
0
public static void createOrUpdate(PersonModelSpec modelSpec, PersonModel model)
{        ModeledFramework<PersonModel> resolved = modelSpec.resolved(model.getContainerType(), model.getId());                resolved.set(model);}
0
public static void readPerson(PersonModelSpec modelSpec, ContainerType containerType, PersonId id, Consumer<PersonModel> receiver)
{    ModeledFramework<PersonModel> resolved = modelSpec.resolved(containerType, id);        resolved.read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
0
public String getId()
{    return id;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonId personId = (PersonId) o;    return id.equals(personId.id);}
0
public int hashCode()
{    return id.hashCode();}
0
public String toString()
{    return "PersonId{" + "id='" + id + '\'' + '}';}
0
public PersonId getId()
{    return id;}
0
public ContainerType getContainerType()
{    return containerType;}
0
public String getFirstName()
{    return firstName;}
0
public String getLastName()
{    return lastName;}
0
public int getAge()
{    return age;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonModel that = (PersonModel) o;    if (age != that.age) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    if (!containerType.equals(that.containerType)) {        return false;    }        if (!firstName.equals(that.firstName)) {        return false;    }    return lastName.equals(that.lastName);}
0
public int hashCode()
{    int result = id.hashCode();    result = 31 * result + containerType.hashCode();    result = 31 * result + firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + age;    return result;}
0
public String toString()
{    return "PersonModel{" + "id=" + id + ", containerType=" + containerType + ", firstName='" + firstName + '\'' + ", lastName='" + lastName + '\'' + ", age=" + age + '}';}
0
public ModeledFramework<PersonModel> resolved(ContainerType containerType, PersonId personId)
{    ModelSpec<PersonModel> resolved = modelSpec.resolved(containerType.getTypeId(), personId.getId());    return ModeledFramework.wrap(client, resolved);}
0
private static ModelSpecBuilder<T> builder(Class<T> clazz)
{    return ModelSpec.builder(JacksonModelSerializer.build(clazz)).withTtl(    TimeUnit.MINUTES.toMillis(10)).withCreateMode(CreateMode.PERSISTENT_WITH_TTL);}
0
public String toString()
{    return "LocationAvailable{" + "name='" + name + '\'' + ", availableUntil=" + availableUntil + "} " + super.toString();}
0
public String getName()
{    return name;}
0
public String getPosition()
{    return position;}
0
public String toString()
{    return "UserCreated{" + "name='" + name + '\'' + ", position='" + position + '\'' + "} " + super.toString();}
0
public String getGroupName()
{    return groupName;}
0
public String nodeName()
{    return groupName;}
0
public String getId()
{    return id;}
0
public InstanceType getType()
{    return type;}
0
public String getHostname()
{    return hostname;}
0
public int getPort()
{    return port;}
0
public String nodeName()
{    return id;}
0
public String toString()
{    return "Instance{" + "id='" + id + '\'' + ", type=" + type + ", hostname='" + hostname + '\'' + ", port=" + port + '}';}
0
public String getId()
{    return id;}
0
public Priority getPriority()
{    return priority;}
0
public String nodeName()
{    return id;}
0
public String toString()
{    return "Message{" + "id='" + id + '\'' + ", priority=" + priority + '}';}
0
public void publishInstance(Instance instance)
{    ModeledFramework<Instance> resolvedClient = Clients.instanceClient.resolved(client, instance.getType());    resolvedClient.set(instance).exceptionally(e -> {                return null;    });}
1
public void publishInstances(List<Instance> instances)
{    List<CuratorOp> operations = instances.stream().map(instance -> Clients.instanceClient.resolved(client, instance.getType()).createOp(instance)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {                return null;    });}
1
public void publishLocationAvailable(Group group, LocationAvailable locationAvailable)
{    publishMessage(Clients.locationAvailableClient, group, locationAvailable);}
0
public void publishUserCreated(Group group, UserCreated userCreated)
{    publishMessage(Clients.userCreatedClient, group, userCreated);}
0
public void publishLocationsAvailable(Group group, List<LocationAvailable> locationsAvailable)
{    publishMessages(Clients.locationAvailableClient, group, locationsAvailable);}
0
public void publishUsersCreated(Group group, List<UserCreated> usersCreated)
{    publishMessages(Clients.userCreatedClient, group, usersCreated);}
0
private void publishMessage(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, T message)
{    ModeledFramework<T> resolvedClient = typedClient.resolved(client, group, message.getPriority());    resolvedClient.set(message).exceptionally(e -> {                return null;    });}
1
private void publishMessages(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, List<T> messages)
{    List<CuratorOp> operations = messages.stream().map(message -> typedClient.resolved(client, group, message.getPriority()).createOp(message)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {                return null;    });}
1
public static void main(String[] args)
{    try (SubPubTest subPubTest = new SubPubTest()) {        subPubTest.start();                TimeUnit.MINUTES.sleep(1);    } catch (Exception e) {        e.printStackTrace();    }}
0
public void start()
{    client.unwrap().start();    Publisher publisher = new Publisher(client);    Subscriber subscriber = new Subscriber(client);        instanceSubscribers.addAll(Arrays.stream(InstanceType.values()).map(subscriber::startInstanceSubscriber).collect(Collectors.toList()));        locationAvailableSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startLocationAvailableSubscriber(group, priority))).collect(Collectors.toList()));        userCreatedSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startUserCreatedSubscriber(group, priority))).collect(Collectors.toList()));        instanceSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    locationAvailableSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    userCreatedSubscribers.forEach(s -> s.listenable().addListener(generalListener()));        executorService.scheduleAtFixedRate(() -> publishSomething(publisher), 1, 1, TimeUnit.SECONDS);}
0
public void close() throws IOException
{    executorService.shutdownNow();    try {        executorService.awaitTermination(5, TimeUnit.SECONDS);    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    userCreatedSubscribers.forEach(CachedModeledFramework::close);    locationAvailableSubscribers.forEach(CachedModeledFramework::close);    instanceSubscribers.forEach(CachedModeledFramework::close);    client.unwrap().close();    testingServer.close();}
0
private void publishSomething(Publisher publisher)
{        switch(ThreadLocalRandom.current().nextInt(6)) {        case 0:            {                Instance instance = new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports));                System.out.println("Publishing 1 instance");                publisher.publishInstance(instance);                break;            }        case 1:            {                List<Instance> instances = IntStream.range(1, 10).mapToObj(__ -> new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d instances", instances.size()));                publisher.publishInstances(instances);                break;            }        case 2:            {                LocationAvailable locationAvailable = new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations));                System.out.println("Publishing 1 locationAvailable");                publisher.publishLocationAvailable(random(groups), locationAvailable);                break;            }        case 3:            {                List<LocationAvailable> locationsAvailable = IntStream.range(1, 10).mapToObj(__ -> new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d locationsAvailable", locationsAvailable.size()));                publisher.publishLocationsAvailable(random(groups), locationsAvailable);                break;            }        case 4:            {                UserCreated userCreated = new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions));                System.out.println("Publishing 1 userCreated");                publisher.publishUserCreated(random(groups), userCreated);                break;            }        case 5:            {                List<UserCreated> usersCreated = IntStream.range(1, 10).mapToObj(__ -> new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d usersCreated", usersCreated.size()));                publisher.publishUsersCreated(random(groups), usersCreated);                break;            }    }}
0
private ModeledCacheListener<T> generalListener()
{    return (type, path, stat, model) -> System.out.println(String.format("Subscribed %s @ %s", model.getClass().getSimpleName(), path));}
0
private final T random(T... tab)
{    int index = ThreadLocalRandom.current().nextInt(tab.length);    return tab[index];}
0
private String nextId()
{    return Long.toString(nextId.getAndIncrement());}
0
public CachedModeledFramework<LocationAvailable> startLocationAvailableSubscriber(Group group, Priority priority)
{    return startSubscriber(Clients.locationAvailableClient, group, priority);}
0
public CachedModeledFramework<UserCreated> startUserCreatedSubscriber(Group group, Priority priority)
{    return startSubscriber(Clients.userCreatedClient, group, priority);}
0
public CachedModeledFramework<Instance> startInstanceSubscriber(InstanceType instanceType)
{    CachedModeledFramework<Instance> resolved = Clients.instanceClient.resolved(client, instanceType).cached();    resolved.start();    return resolved;}
0
private CachedModeledFramework<T> startSubscriber(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, Priority priority)
{    CachedModeledFramework<T> resolved = typedClient.resolved(client, group, priority).cached();    resolved.start();    return resolved;}
0
public static Predicate<CuratorTransactionResult> ofTypeAndPath(final OperationType type, final String forPath)
{    return new Predicate<CuratorTransactionResult>() {        @Override        public boolean apply(CuratorTransactionResult result) {            return (result.getType() == type) && result.getForPath().equals(forPath);        }    };}
0
public boolean apply(CuratorTransactionResult result)
{    return (result.getType() == type) && result.getForPath().equals(forPath);}
0
public OperationType getType()
{    return type;}
0
public String getForPath()
{    return forPath;}
0
public String getResultPath()
{    return resultPath;}
0
public Stat getResultStat()
{    return resultStat;}
0
public int getError()
{    return error;}
0
public OperationType getType()
{    return type;}
0
public String getForPath()
{    return forPath;}
0
public String getScheme()
{    return scheme;}
0
public byte[] getAuth()
{    return auth;}
0
public String toString()
{    return "AuthInfo{" + "scheme='" + scheme + '\'' + ", auth=" + Arrays.toString(auth) + '}';}
0
 CompletableFuture<Void> postSafeNotify(Object monitorHolder)
{    return runSafe(() -> {        synchronized (monitorHolder) {            monitorHolder.notifyAll();        }    });}
0
public static Builder builder()
{    return new Builder();}
0
public static CuratorFramework newClient(String connectString, RetryPolicy retryPolicy)
{    return newClient(connectString, DEFAULT_SESSION_TIMEOUT_MS, DEFAULT_CONNECTION_TIMEOUT_MS, retryPolicy);}
0
public static CuratorFramework newClient(String connectString, int sessionTimeoutMs, int connectionTimeoutMs, RetryPolicy retryPolicy)
{    return builder().connectString(connectString).sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(retryPolicy).build();}
0
public static byte[] getLocalAddress()
{    try {        return InetAddress.getLocalHost().getHostAddress().getBytes();    } catch (UnknownHostException ignore) {        }    return new byte[0];}
0
public CuratorFramework build()
{    return new CuratorFrameworkImpl(this);}
0
public CuratorTempFramework buildTemp()
{    return buildTemp(DEFAULT_INACTIVE_THRESHOLD_MS, TimeUnit.MILLISECONDS);}
0
public CuratorTempFramework buildTemp(long inactiveThreshold, TimeUnit unit)
{    return new CuratorTempFrameworkImpl(this, unit.toMillis(inactiveThreshold));}
0
public Builder authorization(String scheme, byte[] auth)
{    return authorization(ImmutableList.of(new AuthInfo(scheme, (auth != null) ? Arrays.copyOf(auth, auth.length) : null)));}
0
public Builder authorization(List<AuthInfo> authInfos)
{    this.authInfos = ImmutableList.copyOf(authInfos);    return this;}
0
public Builder connectString(String connectString)
{    ensembleProvider = new FixedEnsembleProvider(connectString);    return this;}
0
public Builder ensembleProvider(EnsembleProvider ensembleProvider)
{    this.ensembleProvider = ensembleProvider;    return this;}
0
public Builder defaultData(byte[] defaultData)
{    this.defaultData = (defaultData != null) ? Arrays.copyOf(defaultData, defaultData.length) : null;    return this;}
0
public Builder namespace(String namespace)
{    this.namespace = namespace;    return this;}
0
public Builder sessionTimeoutMs(int sessionTimeoutMs)
{    this.sessionTimeoutMs = sessionTimeoutMs;    return this;}
0
public Builder connectionTimeoutMs(int connectionTimeoutMs)
{    this.connectionTimeoutMs = connectionTimeoutMs;    return this;}
0
public Builder maxCloseWaitMs(int maxCloseWaitMs)
{    this.maxCloseWaitMs = maxCloseWaitMs;    return this;}
0
public Builder retryPolicy(RetryPolicy retryPolicy)
{    this.retryPolicy = retryPolicy;    return this;}
0
public Builder threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
0
public Builder compressionProvider(CompressionProvider compressionProvider)
{    this.compressionProvider = compressionProvider;    return this;}
0
public Builder zookeeperFactory(ZookeeperFactory zookeeperFactory)
{    this.zookeeperFactory = zookeeperFactory;    return this;}
0
public Builder aclProvider(ACLProvider aclProvider)
{    this.aclProvider = aclProvider;    return this;}
0
public Builder canBeReadOnly(boolean canBeReadOnly)
{    this.canBeReadOnly = canBeReadOnly;    return this;}
0
public Builder dontUseContainerParents()
{    this.useContainerParentsIfAvailable = false;    return this;}
0
public Builder connectionStateErrorPolicy(ConnectionStateErrorPolicy connectionStateErrorPolicy)
{    this.connectionStateErrorPolicy = connectionStateErrorPolicy;    return this;}
0
public Builder zk34CompatibilityMode(boolean mode)
{    this.zk34CompatibilityMode = mode;    return this;}
0
public Builder waitForShutdownTimeoutMs(int waitForShutdownTimeoutMs)
{    this.waitForShutdownTimeoutMs = waitForShutdownTimeoutMs;    return this;}
0
public Builder connectionHandlingPolicy(ConnectionHandlingPolicy connectionHandlingPolicy)
{    this.connectionHandlingPolicy = connectionHandlingPolicy;    return this;}
0
public Builder schemaSet(SchemaSet schemaSet)
{    this.schemaSet = schemaSet;    return this;}
0
public Builder runSafeService(Executor runSafeService)
{    this.runSafeService = runSafeService;    return this;}
0
public Builder connectionStateListenerManagerFactory(ConnectionStateListenerManagerFactory connectionStateListenerManagerFactory)
{    this.connectionStateListenerManagerFactory = Objects.requireNonNull(connectionStateListenerManagerFactory, "connectionStateListenerManagerFactory cannot be null");    return this;}
0
public Executor getRunSafeService()
{    return runSafeService;}
0
public ACLProvider getAclProvider()
{    return aclProvider;}
0
public ZookeeperFactory getZookeeperFactory()
{    return zookeeperFactory;}
0
public CompressionProvider getCompressionProvider()
{    return compressionProvider;}
0
public ThreadFactory getThreadFactory()
{    return threadFactory;}
0
public EnsembleProvider getEnsembleProvider()
{    return ensembleProvider;}
0
public int getSessionTimeoutMs()
{    return sessionTimeoutMs;}
0
public int getConnectionTimeoutMs()
{    return connectionTimeoutMs;}
0
public int getWaitForShutdownTimeoutMs()
{    return waitForShutdownTimeoutMs;}
0
public int getMaxCloseWaitMs()
{    return maxCloseWaitMs;}
0
public RetryPolicy getRetryPolicy()
{    return retryPolicy;}
0
public String getNamespace()
{    return namespace;}
0
public boolean useContainerParentsIfAvailable()
{    return useContainerParentsIfAvailable;}
0
public ConnectionStateErrorPolicy getConnectionStateErrorPolicy()
{    return connectionStateErrorPolicy;}
0
public ConnectionHandlingPolicy getConnectionHandlingPolicy()
{    return connectionHandlingPolicy;}
0
public SchemaSet getSchemaSet()
{    return schemaSet;}
0
public boolean isZk34CompatibilityMode()
{    return zk34CompatibilityMode;}
0
public String getAuthScheme()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                return authInfos.get(0).scheme;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
0
public byte[] getAuthValue()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                byte[] bytes = authInfos.get(0).getAuth();                return (bytes != null) ? Arrays.copyOf(bytes, bytes.length) : null;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
0
public List<AuthInfo> getAuthInfos()
{    return authInfos;}
0
public byte[] getDefaultData()
{    return defaultData;}
0
public boolean canBeReadOnly()
{    return canBeReadOnly;}
0
public ConnectionStateListenerManagerFactory getConnectionStateListenerManagerFactory()
{    return connectionStateListenerManagerFactory;}
0
public void ensure() throws Exception
{    if (ensureNeeded.get()) {        internalEnsure();    }}
0
public void reset()
{    ensureNeeded.set(true);}
0
private synchronized void internalEnsure() throws Exception
{    if (ensureNeeded.compareAndSet(true, false)) {        client.createContainers(path);    }}
0
 InternalACLProvider getACLProviderForParents()
{    return applyToParents ? this : aclProvider;}
0
 List<ACL> getAclList(String path)
{    if (aclList != null)        return aclList;    if (path != null) {        List<ACL> localAclList = aclProvider.getAclForPath(path);        if (localAclList != null) {            return localAclList;        }    }    return aclProvider.getDefaultAcl();}
0
public List<ACL> getDefaultAcl()
{    return aclProvider.getDefaultAcl();}
0
public List<ACL> getAclForPath(String path)
{    return getAclList(path);}
0
 boolean inBackground()
{    return inBackground;}
0
 Object getContext()
{    return context;}
0
 BackgroundCallback getCallback()
{    return callback;}
0
 void checkError(Throwable e, Watching watching) throws Exception
{    if (e != null) {        if (errorListener != null) {            errorListener.unhandledError("n/a", e);        } else if (e instanceof Exception) {            throw (Exception) e;        } else {            Throwables.propagate(e);        }    }}
0
private static BackgroundCallback wrapCallback(final CuratorFrameworkImpl client, final BackgroundCallback callback, final Executor executor)
{    return new BackgroundCallback() {        @Override        public void processResult(CuratorFramework dummy, final CuratorEvent event) throws Exception {            executor.execute(new Runnable() {                @Override                public void run() {                    try {                        callback.processResult(client, event);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        if (e instanceof KeeperException) {                            client.validateConnection(client.codeToState(((KeeperException) e).code()));                        }                        client.logError("Background operation result handling threw exception", e);                    }                }            });        }    };}
0
public void processResult(CuratorFramework dummy, final CuratorEvent event) throws Exception
{    executor.execute(new Runnable() {        @Override        public void run() {            try {                callback.processResult(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                if (e instanceof KeeperException) {                    client.validateConnection(client.codeToState(((KeeperException) e).code()));                }                client.logError("Background operation result handling threw exception", e);            }        }    });}
0
public void run()
{    try {        callback.processResult(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if (e instanceof KeeperException) {            client.validateConnection(client.codeToState(((KeeperException) e).code()));        }        client.logError("Background operation result handling threw exception", e);    }}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("BackgroundSyncImpl");    final String data = operationAndData.getData();    client.getZooKeeper().sync(data, new AsyncCallback.VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            trace.setReturnCode(rc).setRequestBytesLength(data).commit();            CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);            client.processBackgroundOperation(operationAndData, event);        }    }, context);}
0
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setRequestBytesLength(data).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public void setSetDataIfExistsVersion(int version)
{    this.setDataIfExistsVersion = version;}
0
public CreateBuilder2 orSetData()
{    return orSetData(-1);}
0
public CreateBuilder2 orSetData(int version)
{    setDataIfExists = true;    setDataIfExistsVersion = version;    return this;}
0
public CreateBuilderMain withTtl(long ttl)
{    Preconditions.checkState(!client.isZk34CompatibilityMode(), "TTLs are not support when running in ZooKeeper 3.4 compatibility mode");    this.ttl = ttl;    return this;}
0
 TransactionCreateBuilder<T> asTransactionCreateBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCreateBuilder<T>() {        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public TransactionCreateBuilder2<T> withTtl(long ttl) {            CreateBuilderImpl.this.withTtl(ttl);            return this;        }        @Override        public ACLPathAndBytesable<T> withMode(CreateMode mode) {            CreateBuilderImpl.this.withMode(mode);            return this;        }        @Override        public ACLCreateModePathAndBytesable<T> compressed() {            CreateBuilderImpl.this.compressed();            return this;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            if (client.isZk34CompatibilityMode()) {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);            } else {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);            }            return context;        }    };}
0
public PathAndBytesable<T> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
0
public PathAndBytesable<T> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
0
public TransactionCreateBuilder2<T> withTtl(long ttl)
{    CreateBuilderImpl.this.withTtl(ttl);    return this;}
0
public ACLPathAndBytesable<T> withMode(CreateMode mode)
{    CreateBuilderImpl.this.withMode(mode);    return this;}
0
public ACLCreateModePathAndBytesable<T> compressed()
{    CreateBuilderImpl.this.compressed();    return this;}
0
public T forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
0
public T forPath(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    if (client.isZk34CompatibilityMode()) {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);    } else {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);    }    return context;}
0
public CreateBackgroundModeStatACLable compressed()
{    compress = true;    return new CreateBackgroundModeStatACLable() {        @Override        public CreateBackgroundModeACLable storingStatIn(Stat stat) {            storingStat = stat;            return asCreateBackgroundModeACLable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return creatingParentsIfNeeded();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
0
public CreateBackgroundModeACLable storingStatIn(Stat stat)
{    storingStat = stat;    return asCreateBackgroundModeACLable();}
0
public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
0
public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
0
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public ACLBackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
0
public ACLBackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    acling = new ACLing(client.getAclProvider(), aclList, applyToParents);    return new ACLBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public ProtectACLCreateModeStatPathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
0
private void setCreateParentsAsContainers()
{    if (client.useContainerParentsIfAvailable()) {        createParentsAsContainers = true;    }}
0
public ProtectACLCreateModeStatPathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return new ProtectACLCreateModeStatPathAndBytesable<String>() {        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
0
public ACLCreateModeBackgroundPathAndBytesable<String> withProtection()
{    return CreateBuilderImpl.this.withProtection();}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public ACLBackgroundPathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
0
public ACLCreateModeStatBackgroundPathAndBytesable<String> withProtection()
{    protectedMode.setProtectedMode();    return asACLCreateModeStatBackgroundPathAndBytesable();}
0
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    protectedMode.setProtectedMode();    createMode = CreateMode.EPHEMERAL_SEQUENTIAL;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
0
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    createMode = mode;    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public PathAndBytesable<String> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public String forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
0
public String forPath(final String givenPath, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(givenPath, data);    }    final String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));    List<ACL> aclList = acling.getAclList(adjustedPath);    client.getSchemaSet().getSchema(givenPath).validateCreate(createMode, givenPath, data, aclList);    String returnPath = null;    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath, data, givenPath);    } else {        String path = protectedPathInForeground(adjustedPath, data, aclList);        returnPath = client.unfixForNamespace(path);    }    return returnPath;}
0
private String protectedPathInForeground(String adjustedPath, byte[] data, List<ACL> aclList) throws Exception
{    try {        return pathInForeground(adjustedPath, data, aclList);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if ((e instanceof KeeperException.ConnectionLossException || !(e instanceof KeeperException)) && protectedMode.doProtected()) {            /*                 * CURATOR-45 + CURATOR-79: we don't know if the create operation was successful or not,                 * register the znode to be sure it is deleted later.                 */            new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(adjustedPath).getPath(), protectedMode.protectedId()).execute();            /*                 * The current UUID is scheduled to be deleted, it is not safe to use it again.                 * If this builder is used again later create a new UUID                 */            protectedMode.resetProtectedId();        }        throw e;    }}
0
public void performBackgroundOperation(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        final CompatibleCreateCallback mainCallback = new CompatibleCreateCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();                if ((stat != null) && (storingStat != null)) {                    DataTree.copyStat(stat, storingStat);                }                if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {                    backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);                } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {                    backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);                } else {                    sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);                }            }        };        if (client.isZk34CompatibilityMode()) {            AsyncCallback.StringCallback stringCallback = new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    mainCallback.processResult(rc, path, ctx, name, null);                }            };            client.getZooKeeper().create(operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, stringCallback, backgrounding.getContext());        } else {            CreateZK35.create(client.getZooKeeper(), operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, mainCallback, backgrounding.getContext(), ttl);        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();    if ((stat != null) && (storingStat != null)) {        DataTree.copyStat(stat, storingStat);    }    if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {        backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);    } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {        backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);    } else {        sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);    }}
0
public void processResult(int rc, String path, Object ctx, String name)
{    mainCallback.processResult(rc, path, ctx, name, null);}
0
public CreateProtectACLCreateModePathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return new CreateProtectACLCreateModePathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            return CreateBuilderImpl.this.creatingParentsIfNeeded();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            return CreateBuilderImpl.this.creatingParentContainersIfNeeded();        }    };}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
0
public ACLCreateModeBackgroundPathAndBytesable<String> withProtection()
{    return CreateBuilderImpl.this.withProtection();}
0
public ProtectACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    return CreateBuilderImpl.this.creatingParentsIfNeeded();}
0
public ProtectACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    return CreateBuilderImpl.this.creatingParentContainersIfNeeded();}
0
private static String getProtectedPrefix(String protectedId)
{    return PROTECTED_PREFIX + protectedId + "-";}
0
 static void backgroundCreateParentsThenNode(final CuratorFrameworkImpl client, final OperationAndData<T> mainOperationAndData, final String path, Backgrounding backgrounding, final InternalACLProvider aclProvider, final boolean createParentsAsContainers)
{    BackgroundOperation<T> operation = new BackgroundOperation<T>() {        @Override        public void performBackgroundOperation(OperationAndData<T> dummy) throws Exception {            try {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);            } catch (KeeperException e) {                if (!RetryLoop.isRetryException(e)) {                    throw e;                }                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<T> parentOperation = new OperationAndData<>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
0
public void performBackgroundOperation(OperationAndData<T> dummy) throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);    } catch (KeeperException e) {        if (!RetryLoop.isRetryException(e)) {            throw e;        }        }    client.queueOperation(mainOperationAndData);}
0
private void backgroundSetData(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
{    final AsyncCallback.StatCallback statCallback = new AsyncCallback.StatCallback() {        @Override        public void processResult(int rc, String path, Object ctx, Stat stat) {            if (rc == KeeperException.Code.NONODE.intValue()) {                                client.queueOperation(mainOperationAndData);            } else {                sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);            }        }    };    BackgroundOperation<PathAndBytes> operation = new BackgroundOperation<PathAndBytes>() {        @Override        public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception {            try {                client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());            } catch (KeeperException e) {                        }        }    };    client.queueOperation(new OperationAndData<>(operation, null, null, null, null, null));}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                client.queueOperation(mainOperationAndData);    } else {        sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);    }}
0
public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception
{    try {        client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());    } catch (KeeperException e) {        }}
0
private void sendBackgroundResponse(int rc, String path, Object ctx, String name, Stat stat, OperationAndData<PathAndBytes> operationAndData)
{    path = client.unfixForNamespace(path);    name = client.unfixForNamespace(name);    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.CREATE, rc, path, name, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
private ACLCreateModePathAndBytesable<String> asACLCreateModePathAndBytesable()
{    return new ACLCreateModePathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ACLPathAndBytesable<String> withMode(CreateMode mode) {            createMode = mode;            return new ACLPathAndBytesable<String>() {                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList) {                    return CreateBuilderImpl.this.withACL(aclList);                }                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {                    return CreateBuilderImpl.this.withACL(aclList, applyToParents);                }                @Override                public String forPath(String path, byte[] data) throws Exception {                    return CreateBuilderImpl.this.forPath(path, data);                }                @Override                public String forPath(String path) throws Exception {                    return CreateBuilderImpl.this.forPath(path);                }            };        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
0
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
0
public ACLPathAndBytesable<String> withMode(CreateMode mode)
{    createMode = mode;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
0
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
private CreateBackgroundModeACLable asCreateBackgroundModeACLable()
{    return new CreateBackgroundModeACLable() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return asACLCreateModePathAndBytesable();        }    };}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
0
public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
0
public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return asACLCreateModePathAndBytesable();}
0
private ACLCreateModeStatBackgroundPathAndBytesable<String> asACLCreateModeStatBackgroundPathAndBytesable()
{    return new ACLCreateModeStatBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
0
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
0
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
0
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
0
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
0
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
0
public ACLCreateModeBackgroundPathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
0
private void pathInBackground(final String path, final byte[] data, final String givenPath)
{    final AtomicBoolean firstTime = new AtomicBoolean(true);    OperationAndData<PathAndBytes> operationAndData = new OperationAndData<PathAndBytes>(this, new PathAndBytes(path, data), backgrounding.getCallback(), new OperationAndData.ErrorCallback<PathAndBytes>() {        public void retriesExhausted(OperationAndData<PathAndBytes> operationAndData) {            if (protectedMode.doProtected()) {                                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                                protectedMode.resetProtectedId();            }        }    }, backgrounding.getContext(), null) {        @Override        void callPerformBackgroundOperation() throws Exception {            boolean callSuper = true;            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                String createdPath = null;                try {                    createdPath = findProtectedNodeInForeground(path);                } catch (KeeperException.ConnectionLossException e) {                    sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);                    callSuper = false;                }                if (createdPath != null) {                    try {                        sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        client.logError("Processing protected create for path: " + givenPath, e);                    }                    callSuper = false;                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                                pathInForeground(path, data, acling.getAclList(path));                throw new KeeperException.ConnectionLossException();            }            if (callSuper) {                super.callPerformBackgroundOperation();            }        }    };    client.processBackgroundOperation(operationAndData, null);}
0
public void retriesExhausted(OperationAndData<PathAndBytes> operationAndData)
{    if (protectedMode.doProtected()) {                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                protectedMode.resetProtectedId();    }}
0
 void callPerformBackgroundOperation() throws Exception
{    boolean callSuper = true;    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        String createdPath = null;        try {            createdPath = findProtectedNodeInForeground(path);        } catch (KeeperException.ConnectionLossException e) {            sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);            callSuper = false;        }        if (createdPath != null) {            try {                sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Processing protected create for path: " + givenPath, e);            }            callSuper = false;        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;                pathInForeground(path, data, acling.getAclList(path));        throw new KeeperException.ConnectionLossException();    }    if (callSuper) {        super.callPerformBackgroundOperation();    }}
0
private String pathInForeground(final String path, final byte[] data, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Foreground");    final AtomicBoolean firstTime = new AtomicBoolean(true);    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            String createdPath = null;            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                createdPath = findProtectedNodeInForeground(path);            }            if (createdPath == null) {                try {                    if (client.isZk34CompatibilityMode()) {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode);                    } else {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);                    }                } catch (KeeperException.NoNodeException e) {                    if (createParentsIfNeeded) {                        ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                        if (client.isZk34CompatibilityMode()) {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                        } else {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                        }                    } else {                        throw e;                    }                } catch (KeeperException.NodeExistsException e) {                    if (setDataIfExists) {                        Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                        if (storingStat != null) {                            DataTree.copyStat(setStat, storingStat);                        }                        createdPath = path;                    } else {                        throw e;                    }                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                throw new KeeperException.ConnectionLossException();            }            return createdPath;        }    });    trace.setRequestBytesLength(data).setPath(path).commit();    return returnPath;}
0
public String call() throws Exception
{    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    String createdPath = null;    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        createdPath = findProtectedNodeInForeground(path);    }    if (createdPath == null) {        try {            if (client.isZk34CompatibilityMode()) {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode);            } else {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);            }        } catch (KeeperException.NoNodeException e) {            if (createParentsIfNeeded) {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                if (client.isZk34CompatibilityMode()) {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                } else {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                }            } else {                throw e;            }        } catch (KeeperException.NodeExistsException e) {            if (setDataIfExists) {                Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                if (storingStat != null) {                    DataTree.copyStat(setStat, storingStat);                }                createdPath = path;            } else {                throw e;            }        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;        throw new KeeperException.ConnectionLossException();    }    return createdPath;}
0
private String findProtectedNodeInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-findProtectedNodeInForeground");    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            String foundNode = null;            try {                final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);                List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);                foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());                                foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);            } catch (KeeperException.NoNodeException ignore) {                        }            return foundNode;        }    });    trace.setPath(path).commit();    return returnPath;}
1
public String call() throws Exception
{    String foundNode = null;    try {        final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);        foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());                foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);    } catch (KeeperException.NoNodeException ignore) {        }    return foundNode;}
1
 String adjustPath(String path) throws Exception
{    if (protectedMode.doProtected()) {        ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        String name = getProtectedPrefix(protectedMode.protectedId()) + pathAndNode.getNode();        path = ZKPaths.makePath(pathAndNode.getPath(), name);    }    return path;}
0
 static String findNode(final List<String> children, final String path, final String protectedId)
{    final String protectedPrefix = getProtectedPrefix(protectedId);    String foundNode = Iterables.find(children, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.startsWith(protectedPrefix);        }    }, null);    if (foundNode != null) {        foundNode = ZKPaths.makePath(path, foundNode);    }    return foundNode;}
0
public boolean apply(String node)
{    return node.startsWith(protectedPrefix);}
0
 static void create(ZooKeeper zooKeeper, String path, byte[] data, List<ACL> acl, CreateMode createMode, final CompatibleCreateCallback compatibleCallback, Object ctx, long ttl)
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            compatibleCallback.processResult(rc, path, ctx, name, stat);        }    };    zooKeeper.create(path, data, acl, createMode, callback, ctx, ttl);}
0
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    compatibleCallback.processResult(rc, path, ctx, name, stat);}
0
public CuratorEventType getType()
{    return type;}
0
public int getResultCode()
{    return resultCode;}
0
public String getPath()
{    return path;}
0
public Object getContext()
{    return context;}
0
public Stat getStat()
{    return stat;}
0
public byte[] getData()
{    return data;}
0
public String getName()
{    return name;}
0
public List<String> getChildren()
{    return children;}
0
public WatchedEvent getWatchedEvent()
{    return watchedEvent;}
0
public List<ACL> getACLList()
{    return aclList;}
0
public List<CuratorTransactionResult> getOpResults()
{    return opResults;}
0
public String toString()
{    return "CuratorEventImpl{" + "type=" + type + ", resultCode=" + resultCode + ", path='" + path + '\'' + ", name='" + name + '\'' + ", children=" + children + ", context=" + context + ", stat=" + stat + ", data=" + Arrays.toString(data) + ", watchedEvent=" + watchedEvent + ", aclList=" + aclList + ", opResults=" + opResults + '}';}
0
public void process(WatchedEvent watchedEvent)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), null, null, null, null, null, watchedEvent, null, null);    processEvent(event);}
0
private Executor makeRunSafeService(CuratorFrameworkFactory.Builder builder)
{    if (builder.getRunSafeService() != null) {        return builder.getRunSafeService();    }    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("SafeNotifyService");    }    return Executors.newSingleThreadExecutor(threadFactory);}
0
private List<AuthInfo> buildAuths(CuratorFrameworkFactory.Builder builder)
{    ImmutableList.Builder<AuthInfo> builder1 = ImmutableList.builder();    if (builder.getAuthInfos() != null) {        builder1.addAll(builder.getAuthInfos());    }    return builder1.build();}
0
public CompletableFuture<Void> runSafe(Runnable runnable)
{    return CompletableFuture.runAsync(runnable, runSafeService);}
0
public WatcherRemoveCuratorFramework newWatcherRemoveCuratorFramework()
{    return new WatcherRemovalFacade(this);}
0
public QuorumVerifier getCurrentConfig()
{    return (ensembleTracker != null) ? ensembleTracker.getCurrentConfig() : null;}
0
private ZookeeperFactory makeZookeeperFactory(final ZookeeperFactory actualZookeeperFactory)
{    return new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);            for (AuthInfo auth : authInfos) {                zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());            }            return zooKeeper;        }    };}
0
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);    for (AuthInfo auth : authInfos) {        zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());    }    return zooKeeper;}
0
private ThreadFactory getThreadFactory(CuratorFrameworkFactory.Builder builder)
{    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("Framework");    }    return threadFactory;}
0
public void createContainers(String path) throws Exception
{    checkExists().creatingParentContainersIfNeeded().forPath(ZKPaths.makePath(path, "foo"));}
0
public void clearWatcherReferences(Watcher watcher)
{}
0
public CuratorFrameworkState getState()
{    return state.get();}
0
public boolean isStarted()
{    return state.get() == CuratorFrameworkState.STARTED;}
0
public boolean blockUntilConnected(int maxWaitTime, TimeUnit units) throws InterruptedException
{    return connectionStateManager.blockUntilConnected(maxWaitTime, units);}
0
public void blockUntilConnected() throws InterruptedException
{    blockUntilConnected(0, null);}
0
public ConnectionStateErrorPolicy getConnectionStateErrorPolicy()
{    return connectionStateErrorPolicy;}
0
public void start()
{        if (!state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED)) {        throw new IllegalStateException("Cannot be started more than once");    }    try {                connectionStateManager.start();        final ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {                    logAsErrorConnectionErrors.set(true);                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        this.getConnectionStateListenable().addListener(listener);        client.start();        executorService = Executors.newSingleThreadScheduledExecutor(threadFactory);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                backgroundOperationsLoop();                return null;            }        });        if (ensembleTracker != null) {            ensembleTracker.start();        }            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(null, e);    }}
1
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {        logAsErrorConnectionErrors.set(true);    }}
0
public boolean doNotProxy()
{    return true;}
0
public Object call() throws Exception
{    backgroundOperationsLoop();    return null;}
0
public void close()
{        if (state.compareAndSet(CuratorFrameworkState.STARTED, CuratorFrameworkState.STOPPED)) {        listeners.forEach(new Function<CuratorListener, Void>() {            @Override            public Void apply(CuratorListener listener) {                CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);                try {                    listener.eventReceived(CuratorFrameworkImpl.this, event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });        if (executorService != null) {            executorService.shutdownNow();            try {                executorService.awaitTermination(maxCloseWaitMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                                Thread.currentThread().interrupt();            }        }        if (ensembleTracker != null) {            ensembleTracker.close();        }        listeners.clear();        unhandledErrorListeners.clear();        connectionStateManager.close();        client.close();    }}
1
public Void apply(CuratorListener listener)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);    try {        listener.eventReceived(CuratorFrameworkImpl.this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
1
public CuratorFramework nonNamespaceView()
{    return usingNamespace(null);}
0
public String getNamespace()
{    String str = namespace.getNamespace();    return (str != null) ? str : "";}
0
private void checkState()
{    CuratorFrameworkState state = getState();    Preconditions.checkState(state == CuratorFrameworkState.STARTED, "Expected state [%s] was [%s]", CuratorFrameworkState.STARTED, state);}
0
public CuratorFramework usingNamespace(String newNamespace)
{    checkState();    return namespaceFacadeCache.get(newNamespace);}
0
public CreateBuilder create()
{    checkState();    return new CreateBuilderImpl(this);}
0
public DeleteBuilder delete()
{    checkState();    return new DeleteBuilderImpl(this);}
0
public ExistsBuilder checkExists()
{    checkState();    return new ExistsBuilderImpl(this);}
0
public GetDataBuilder getData()
{    checkState();    return new GetDataBuilderImpl(this);}
0
public SetDataBuilder setData()
{    checkState();    return new SetDataBuilderImpl(this);}
0
public GetChildrenBuilder getChildren()
{    checkState();    return new GetChildrenBuilderImpl(this);}
0
public GetACLBuilder getACL()
{    checkState();    return new GetACLBuilderImpl(this);}
0
public SetACLBuilder setACL()
{    checkState();    return new SetACLBuilderImpl(this);}
0
public ReconfigBuilder reconfig()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new ReconfigBuilderImpl(this);}
0
public GetConfigBuilder getConfig()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new GetConfigBuilderImpl(this);}
0
public CuratorTransaction inTransaction()
{    checkState();    return new CuratorTransactionImpl(this);}
0
public CuratorMultiTransaction transaction()
{    checkState();    return new CuratorMultiTransactionImpl(this);}
0
public TransactionOp transactionOp()
{    checkState();    return new TransactionOpImpl(this);}
0
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return connectionStateManager.getListenable();}
0
public Listenable<CuratorListener> getCuratorListenable()
{    return listeners;}
0
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return unhandledErrorListeners;}
0
public void sync(String path, Object context)
{    checkState();    path = fixForNamespace(path);    internalSync(this, path, context);}
0
public SyncBuilder sync()
{    return new SyncBuilderImpl(this);}
0
public RemoveWatchesBuilder watches()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "Remove watches APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new RemoveWatchesBuilderImpl(this);}
0
protected void internalSync(CuratorFrameworkImpl impl, String path, Object context)
{    BackgroundOperation<String> operation = new BackgroundSyncImpl(impl, context);    performBackgroundOperation(new OperationAndData<String>(operation, path, null, null, context, null));}
0
public CuratorZookeeperClient getZookeeperClient()
{    return client;}
0
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
0
public SchemaSet getSchemaSet()
{    return schemaSet;}
0
 ACLProvider getAclProvider()
{    return aclProvider;}
0
 FailedDeleteManager getFailedDeleteManager()
{    return failedDeleteManager;}
0
 FailedRemoveWatchManager getFailedRemoveWatcherManager()
{    return failedRemoveWatcherManager;}
0
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
0
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
0
 CompressionProvider getCompressionProvider()
{    return compressionProvider;}
0
 boolean useContainerParentsIfAvailable()
{    return useContainerParentsIfAvailable;}
0
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean isInitialExecution = (event == null);    if (isInitialExecution) {        performBackgroundOperation(operationAndData);        return;    }    boolean doQueueOperation = false;    do {        if (RetryLoop.shouldRetry(event.getResultCode())) {            doQueueOperation = checkBackgroundRetry(operationAndData, event);            break;        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);            break;        }        processEvent(event);    } while (false);    if (doQueueOperation) {        queueOperation(operationAndData);    }}
0
 boolean queueOperation(OperationAndData<DATA_TYPE> operationAndData)
{    if (getState() == CuratorFrameworkState.STARTED) {        backgroundOperations.offer(operationAndData);        return true;    }    return false;}
0
 void logError(String reason, final Throwable e)
{    if ((reason == null) || (reason.length() == 0)) {        reason = "n/a";    }    if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES) || !(e instanceof KeeperException)) {        if (e instanceof KeeperException.ConnectionLossException) {            if (LOG_ALL_CONNECTION_ISSUES_AS_ERROR_LEVEL || logAsErrorConnectionErrors.compareAndSet(true, false)) {                            } else {                            }        } else {                    }    }    final String localReason = reason;    unhandledErrorListeners.forEach(new Function<UnhandledErrorListener, Void>() {        @Override        public Void apply(UnhandledErrorListener listener) {            listener.unhandledError(localReason, e);            return null;        }    });    if (debugUnhandledErrorListener != null) {        debugUnhandledErrorListener.unhandledError(reason, e);    }}
1
public Void apply(UnhandledErrorListener listener)
{    listener.unhandledError(localReason, e);    return null;}
0
 String unfixForNamespace(String path)
{    return namespace.unfixForNamespace(path);}
0
 String fixForNamespace(String path)
{    return namespace.fixForNamespace(path, false);}
0
 String fixForNamespace(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
0
 byte[] getDefaultData()
{    return defaultData;}
0
 NamespaceFacadeCache getNamespaceFacadeCache()
{    return namespaceFacadeCache;}
0
 void validateConnection(Watcher.Event.KeeperState state)
{    if (state == Watcher.Event.KeeperState.Disconnected) {        internalConnectionHandler.suspendConnection(this);    } else if (state == Watcher.Event.KeeperState.Expired) {        connectionStateManager.addStateChange(ConnectionState.LOST);    } else if (state == Watcher.Event.KeeperState.SyncConnected) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.RECONNECTED);        unSleepBackgroundOperations();    } else if (state == Watcher.Event.KeeperState.ConnectedReadOnly) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);    }}
0
 void checkInstanceIndex()
{    long instanceIndex = client.getInstanceIndex();    long newInstanceIndex = currentInstanceIndex.getAndSet(instanceIndex);    if (    (newInstanceIndex >= 0) && (instanceIndex != newInstanceIndex)) {        connectionStateManager.addStateChange(ConnectionState.LOST);    }}
0
 Watcher.Event.KeeperState codeToState(KeeperException.Code code)
{    switch(code) {        case AUTHFAILED:        case NOAUTH:            {                return Watcher.Event.KeeperState.AuthFailed;            }        case CONNECTIONLOSS:        case OPERATIONTIMEOUT:            {                return Watcher.Event.KeeperState.Disconnected;            }        case SESSIONEXPIRED:            {                return Watcher.Event.KeeperState.Expired;            }        case OK:        case SESSIONMOVED:            {                return Watcher.Event.KeeperState.SyncConnected;            }    }    return Watcher.Event.KeeperState.fromInt(-1);}
0
 WatcherRemovalManager getWatcherRemovalManager()
{    return null;}
0
 boolean setToSuspended()
{    return connectionStateManager.setToSuspended();}
0
 void addStateChange(ConnectionState newConnectionState)
{    connectionStateManager.addStateChange(newConnectionState);}
0
public boolean isZk34CompatibilityMode()
{    return zk34CompatibilityMode;}
0
 EnsembleTracker getEnsembleTracker()
{    return ensembleTracker;}
0
private boolean checkBackgroundRetry(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean doRetry = false;    if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {        doRetry = true;    } else {        if (operationAndData.getErrorCallback() != null) {            operationAndData.getErrorCallback().retriesExhausted(operationAndData);        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);        }        KeeperException.Code code = KeeperException.Code.get(event.getResultCode());        Exception e = null;        try {            e = (code != null) ? KeeperException.create(code) : null;        } catch (Throwable t) {            ThreadUtils.checkInterrupted(t);        }        if (e == null) {            e = new Exception("Unknown result codegetResultCode()");        }        validateConnection(codeToState(code));        logError("Background operation retry gave up", e);    }    return doRetry;}
0
private void sendToBackgroundCallback(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    try {        operationAndData.getCallback().processResult(this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(operationAndData, e);    }}
0
private void handleBackgroundOperationException(OperationAndData<DATA_TYPE> operationAndData, Throwable e)
{    do {        if ((operationAndData != null) && RetryLoop.isRetryException(e)) {            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }            if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                                    }                backgroundOperations.offer(operationAndData);                break;            } else {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                                    }                if (operationAndData.getErrorCallback() != null) {                    operationAndData.getErrorCallback().retriesExhausted(operationAndData);                }            }        }        logError("Background exception was not retry-able or retry gave up", e);    } while (false);}
1
private void backgroundOperationsLoop()
{    try {        while (state.get() == CuratorFrameworkState.STARTED) {            OperationAndData<?> operationAndData;            try {                operationAndData = backgroundOperations.take();                if (debugListener != null) {                    debugListener.listen(operationAndData);                }                performBackgroundOperation(operationAndData);            } catch (InterruptedException e) {                                                }        }    } finally {            }}
1
 void performBackgroundOperation(OperationAndData<?> operationAndData)
{    try {        if (!operationAndData.isConnectionRequired() || client.isConnected()) {            operationAndData.callPerformBackgroundOperation();        } else {                        client.getZooKeeper();            if (operationAndData.getElapsedTimeMs() >= client.getConnectionTimeoutMs()) {                throw new CuratorConnectionLossException();            }            sleepAndQueueOperation(operationAndData);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        /**         * Fix edge case reported as CURATOR-52. ConnectionState.checkTimeouts() throws KeeperException.ConnectionLossException         * when the initial (or previously failed) connection cannot be re-established. This needs to be run through the retry policy         * and callbacks need to get invoked, etc.         */        if (e instanceof CuratorConnectionLossException) {            WatchedEvent watchedEvent = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Disconnected, null);            CuratorEvent event = new CuratorEventImpl(this, CuratorEventType.WATCHED, KeeperException.Code.CONNECTIONLOSS.intValue(), null, null, operationAndData.getContext(), null, null, null, watchedEvent, null, null);            if (checkBackgroundRetry(operationAndData, event)) {                queueOperation(operationAndData);            } else {                logError("Background retry gave up", e);            }        } else {            handleBackgroundOperationException(operationAndData, e);        }    }}
0
private void sleepAndQueueOperation(OperationAndData<?> operationAndData) throws InterruptedException
{    operationAndData.sleepFor(sleepAndQueueOperationSeconds, TimeUnit.SECONDS);    if (queueOperation(operationAndData)) {        forcedSleepOperations.add(operationAndData);    }}
0
private void unSleepBackgroundOperations()
{    Collection<OperationAndData<?>> drain = new ArrayList<>(forcedSleepOperations.size());    forcedSleepOperations.drainTo(drain);        for (OperationAndData<?> operation : drain) {        operation.clearSleep();        if (        backgroundOperations.remove(operation)) {            backgroundOperations.offer(operation);        }    }}
1
private void processEvent(final CuratorEvent curatorEvent)
{    if (curatorEvent.getType() == CuratorEventType.WATCHED) {        validateConnection(curatorEvent.getWatchedEvent().getState());    }    listeners.forEach(new Function<CuratorListener, Void>() {        @Override        public Void apply(CuratorListener listener) {            try {                OperationTrace trace = client.startAdvancedTracer("EventListener");                listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);                trace.commit();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                logError("Event listener threw exception", e);            }            return null;        }    });}
0
public Void apply(CuratorListener listener)
{    try {        OperationTrace trace = client.startAdvancedTracer("EventListener");        listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);        trace.commit();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        logError("Event listener threw exception", e);    }    return null;}
0
public ErrorListenerMultiTransactionMain inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerMultiTransactionMain inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
0
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public CuratorMultiTransactionMain withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public List<CuratorTransactionResult> forOperations(CuratorOp... operations) throws Exception
{    List<CuratorOp> ops = (operations != null) ? Arrays.asList(operations) : Lists.<CuratorOp>newArrayList();    return forOperations(ops);}
0
public List<CuratorTransactionResult> forOperations(List<CuratorOp> operations) throws Exception
{    operations = Preconditions.checkNotNull(operations, "operations cannot be null");    Preconditions.checkArgument(!operations.isEmpty(), "operations list cannot be empty");    CuratorMultiTransactionRecord record = new CuratorMultiTransactionRecord();    for (CuratorOp curatorOp : operations) {        Schema schema = client.getSchemaSet().getSchema(curatorOp.getTypeAndPath().getForPath());        record.add(curatorOp.get(), curatorOp.getTypeAndPath().getType(), curatorOp.getTypeAndPath().getForPath());        if ((curatorOp.get().getType() == ZooDefs.OpCode.create) || (curatorOp.get().getType() == ZooDefs.OpCode.createContainer)) {            CreateRequest createRequest = (CreateRequest) curatorOp.get().toRequestRecord();            CreateMode createMode;            if (client.isZk34CompatibilityMode()) {                try {                    createMode = CreateMode.fromFlag(createRequest.getFlags());                } catch (KeeperException.BadArgumentsException dummy) {                    createMode = CreateMode.PERSISTENT;                }            } else {                createMode = CreateMode.fromFlag(createRequest.getFlags(), CreateMode.PERSISTENT);            }            schema.validateCreate(createMode, createRequest.getPath(), createRequest.getData(), createRequest.getAcl());        } else if ((curatorOp.get().getType() == ZooDefs.OpCode.delete) || (curatorOp.get().getType() == ZooDefs.OpCode.deleteContainer)) {            DeleteRequest deleteRequest = (DeleteRequest) curatorOp.get().toRequestRecord();            schema.validateDelete(deleteRequest.getPath());        } else if (curatorOp.get().getType() == ZooDefs.OpCode.setData) {            SetDataRequest setDataRequest = (SetDataRequest) curatorOp.get().toRequestRecord();            schema.validateGeneral(setDataRequest.getPath(), setDataRequest.getData(), null);        }    }    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, record, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return null;    } else {        return forOperationsInForeground(record);    }}
0
public void performBackgroundOperation(final OperationAndData<CuratorMultiTransactionRecord> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Background");        AsyncCallback.MultiCallback callback = new AsyncCallback.MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                trace.commit();                List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().multi(operationAndData.getData(), callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    trace.commit();    List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);    client.processBackgroundOperation(operationAndData, event);}
0
private List<CuratorTransactionResult> forOperationsInForeground(final CuratorMultiTransactionRecord record) throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Foreground");    List<OpResult> responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return client.getZooKeeper().multi(record);        }    });    trace.commit();    return CuratorTransactionImpl.wrapResults(client, responseData, record);}
0
public List<OpResult> call() throws Exception
{    return client.getZooKeeper().multi(record);}
0
public final void add(Op op)
{    throw new UnsupportedOperationException();}
0
 void add(Op op, OperationType type, String forPath)
{    super.add(op);    metadata.add(new TypeAndPath(type, forPath));}
0
 TypeAndPath getMetadata(int index)
{    return metadata.get(index);}
0
 int metadataSize()
{    return metadata.size();}
0
 void addToDigest(MessageDigest digest)
{    for (Op op : this) {        digest.update(op.getPath().getBytes());        digest.update(Integer.toString(op.getType()).getBytes());        digest.update(op.toRequestRecord().toString().getBytes());    }}
0
public void close()
{    closeClient();}
0
public CuratorTransaction inTransaction() throws Exception
{    openConnectionIfNeeded();    return new CuratorTransactionImpl(client);}
0
public TempGetDataBuilder getData() throws Exception
{    openConnectionIfNeeded();    return new TempGetDataBuilderImpl(client);}
0
 synchronized CuratorFrameworkImpl getClient()
{    return client;}
0
 synchronized ScheduledExecutorService getCleanup()
{    return cleanup;}
0
 synchronized void updateLastAccess()
{    lastAccess = System.currentTimeMillis();}
0
private synchronized void openConnectionIfNeeded() throws Exception
{    if (client == null) {                client = (CuratorFrameworkImpl) factory.build();        client.start();    }    if (cleanup == null) {        ThreadFactory threadFactory = factory.getThreadFactory();        if (threadFactory == null) {            threadFactory = ThreadUtils.newGenericThreadFactory("CuratorTempFrameworkImpl");        }        cleanup = Executors.newScheduledThreadPool(1, threadFactory);        Runnable command = new Runnable() {            @Override            public void run() {                checkInactive();            }        };        cleanup.scheduleAtFixedRate(command, inactiveThresholdMs, inactiveThresholdMs, TimeUnit.MILLISECONDS);    }    updateLastAccess();}
0
public void run()
{    checkInactive();}
0
private synchronized void checkInactive()
{    long elapsed = System.currentTimeMillis() - lastAccess;    if (elapsed >= inactiveThresholdMs) {        closeClient();    }}
0
private synchronized void closeClient()
{    if (cleanup != null) {        cleanup.shutdownNow();        cleanup = null;    }    if (client != null) {        CloseableUtils.closeQuietly(client);        client = null;    }}
0
public CuratorTransactionFinal and()
{    return this;}
0
public TransactionCreateBuilder<CuratorTransactionBridge> create()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new CreateBuilderImpl(client).asTransactionCreateBuilder(asBridge, transaction);}
0
public TransactionDeleteBuilder<CuratorTransactionBridge> delete()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new DeleteBuilderImpl(client).asTransactionDeleteBuilder(asBridge, transaction);}
0
public TransactionSetDataBuilder<CuratorTransactionBridge> setData()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new SetDataBuilderImpl(client).asTransactionSetDataBuilder(asBridge, transaction);}
0
public TransactionCheckBuilder<CuratorTransactionBridge> check()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return makeTransactionCheckBuilder(client, asBridge, transaction);}
0
 static TransactionCheckBuilder<T> makeTransactionCheckBuilder(final CuratorFrameworkImpl client, final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCheckBuilder<T>() {        private int version = -1;        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            this.version = version;            return this;        }    };}
0
public T forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);    return context;}
0
public Pathable<T> withVersion(int version)
{    this.version = version;    return this;}
0
public Collection<CuratorTransactionResult> commit() throws Exception
{    Preconditions.checkState(!isCommitted, "transaction already committed");    isCommitted = true;    List<OpResult> resultList = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return doOperation();        }    });    if (resultList.size() != transaction.metadataSize()) {        throw new IllegalStateException(String.format("Result size (%d) doesn't match input size (%d)", resultList.size(), transaction.metadataSize()));    }    return wrapResults(client, resultList, transaction);}
0
public List<OpResult> call() throws Exception
{    return doOperation();}
0
 static List<CuratorTransactionResult> wrapResults(CuratorFrameworkImpl client, List<OpResult> resultList, CuratorMultiTransactionRecord transaction)
{    ImmutableList.Builder<CuratorTransactionResult> builder = ImmutableList.builder();    for (int i = 0; i < resultList.size(); ++i) {        OpResult opResult = resultList.get(i);        TypeAndPath metadata = transaction.getMetadata(i);        CuratorTransactionResult curatorResult = makeCuratorResult(client, opResult, metadata);        builder.add(curatorResult);    }    return builder.build();}
0
 static CuratorTransactionResult makeCuratorResult(CuratorFrameworkImpl client, OpResult opResult, TypeAndPath metadata)
{    String resultPath = null;    Stat resultStat = null;    int error = 0;    switch(opResult.getType()) {        default:            {                                break;            }        case ZooDefs.OpCode.create:            {                OpResult.CreateResult createResult = (OpResult.CreateResult) opResult;                resultPath = client.unfixForNamespace(createResult.getPath());                break;            }        case ZooDefs.OpCode.setData:            {                OpResult.SetDataResult setDataResult = (OpResult.SetDataResult) opResult;                resultStat = setDataResult.getStat();                break;            }        case ZooDefs.OpCode.error:            {                OpResult.ErrorResult errorResult = (OpResult.ErrorResult) opResult;                error = errorResult.getErr();                break;            }    }    return new CuratorTransactionResult(metadata.getType(), metadata.getForPath(), resultPath, resultStat, error);}
0
private List<OpResult> doOperation() throws Exception
{    List<OpResult> opResults = client.getZooKeeper().multi(transaction);    if (opResults.size() > 0) {        OpResult firstResult = opResults.get(0);        if (firstResult.getType() == ZooDefs.OpCode.error) {            OpResult.ErrorResult error = (OpResult.ErrorResult) firstResult;            KeeperException.Code code = KeeperException.Code.get(error.getErr());            if (code == null) {                code = KeeperException.Code.UNIMPLEMENTED;            }            throw KeeperException.create(code);        }    }    return opResults;}
0
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
0
public List<ACL> getAclForPath(String path)
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
0
 TransactionDeleteBuilder<T> asTransactionDeleteBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionDeleteBuilder<T>() {        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            DeleteBuilderImpl.this.withVersion(version);            return this;        }    };}
0
public T forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);    return context;}
0
public Pathable<T> withVersion(int version)
{    DeleteBuilderImpl.this.withVersion(version);    return this;}
0
public DeleteBuilderMain quietly()
{    quietly = true;    return this;}
0
public ChildrenDeletable guaranteed()
{    guaranteed = true;    return this;}
0
public BackgroundVersionable deletingChildrenIfNeeded()
{    deletingChildrenIfNeeded = true;    return this;}
0
public BackgroundPathable<Void> withVersion(int version)
{    this.version = version;    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<Void> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Background");        client.getZooKeeper().delete(operationAndData.getData(), version, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {                    backgroundDeleteChildrenThenNode(operationAndData);                } else {                    if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {                        rc = KeeperException.Code.OK.intValue();                    }                    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);                    client.processBackgroundOperation(operationAndData, event);                }            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {        backgroundDeleteChildrenThenNode(operationAndData);    } else {        if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {            rc = KeeperException.Code.OK.intValue();        }        CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
0
private void backgroundDeleteChildrenThenNode(final OperationAndData<String> mainOperationAndData)
{    BackgroundOperation<String> operation = new BackgroundOperation<String>() {        @Override        public void performBackgroundOperation(OperationAndData<String> dummy) throws Exception {            try {                ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);            } catch (KeeperException e) {                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<String> parentOperation = new OperationAndData<String>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
0
public void performBackgroundOperation(OperationAndData<String> dummy) throws Exception
{    try {        ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);    } catch (KeeperException e) {        }    client.queueOperation(mainOperationAndData);}
0
public Void forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateDelete(path);    final String unfixedPath = path;    path = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {            errorCallback = new OperationAndData.ErrorCallback<String>() {                @Override                public void retriesExhausted(OperationAndData<String> operationAndData) {                    client.getFailedDeleteManager().addFailedOperation(unfixedPath);                }            };        }        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), null), null);    } else {        pathInForeground(path, unfixedPath);    }    return null;}
0
public void retriesExhausted(OperationAndData<String> operationAndData)
{    client.getFailedDeleteManager().addFailedOperation(unfixedPath);}
0
protected int getVersion()
{    return version;}
0
private void pathInForeground(final String path, String unfixedPath) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Foreground");    try {        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    client.getZooKeeper().delete(path, version);                } catch (KeeperException.NoNodeException e) {                    if (!quietly) {                        throw e;                    }                } catch (KeeperException.NotEmptyException e) {                    if (deletingChildrenIfNeeded) {                        ZKPaths.deleteChildren(client.getZooKeeper(), path, true);                    } else {                        throw e;                    }                }                return null;            }        });    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                if ((RetryLoop.isRetryException(e) || (e instanceof InterruptedException)) && guaranteed) {            client.getFailedDeleteManager().addFailedOperation(unfixedPath);        }        throw e;    }    trace.setPath(path).commit();}
0
public Void call() throws Exception
{    try {        client.getZooKeeper().delete(path, version);    } catch (KeeperException.NoNodeException e) {        if (!quietly) {            throw e;        }    } catch (KeeperException.NotEmptyException e) {        if (deletingChildrenIfNeeded) {            ZKPaths.deleteChildren(client.getZooKeeper(), path, true);        } else {            throw e;        }    }    return null;}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        try {            reset();        } catch (Exception e) {                    }    }}
1
public boolean doNotProxy()
{    return true;}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    reset();}
0
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);    }}
0
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        reset();    }}
0
public QuorumVerifier getCurrentConfig()
{    return currentConfig.get();}
0
public boolean hasOutstanding()
{    return outstanding.get() > 0;}
0
private void reset() throws Exception
{    if ((client.getState() == CuratorFrameworkState.STARTED) && (state.get() == State.STARTED)) {        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                outstanding.decrementAndGet();                if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    processConfigData(event.getData());                }            }        };        outstanding.incrementAndGet();        try {            client.getConfig().usingWatcher(this).inBackground(backgroundCallback).forEnsemble();                        outstanding.incrementAndGet();        } finally {            outstanding.decrementAndGet();        }    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    outstanding.decrementAndGet();    if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        processConfigData(event.getData());    }}
0
public static String configToConnectionString(QuorumVerifier data) throws Exception
{    StringBuilder sb = new StringBuilder();    for (QuorumPeer.QuorumServer server : data.getAllMembers().values()) {        if (server.clientAddr == null) {                        continue;        }        if (sb.length() != 0) {            sb.append(",");        }        String hostAddress;        if (server.clientAddr.getAddress().isAnyLocalAddress()) {            hostAddress = server.addr.getAddress().getHostAddress();        } else {            hostAddress = server.clientAddr.getAddress().getHostAddress();        }        sb.append(hostAddress).append(":").append(server.clientAddr.getPort());    }    return sb.toString();}
0
private void processConfigData(byte[] data) throws Exception
{    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(data));        if (!properties.isEmpty()) {        QuorumMaj newConfig = new QuorumMaj(properties);        String connectionString = configToConnectionString(newConfig);        if (connectionString.trim().length() > 0) {            currentConfig.set(newConfig);            ensembleProvider.setConnectionString(connectionString);        } else {                    }    } else {            }}
1
public ACLableExistBuilderMain creatingParentsIfNeeded()
{    createParentContainersIfNeeded = false;    createParentsIfNeeded = true;    return this;}
0
public ACLableExistBuilderMain creatingParentContainersIfNeeded()
{    createParentContainersIfNeeded = true;    createParentsIfNeeded = false;    return this;}
0
public ExistsBuilderMain withACL(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, true);    return this;}
0
public BackgroundPathable<Stat> watched()
{    watching = new Watching(client, true);    return this;}
0
public BackgroundPathable<Stat> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public BackgroundPathable<Stat> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public Pathable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Background");        AsyncCallback.StatCallback callback = new AsyncCallback.StatCallback() {            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                watching.commitWatcher(rc, true);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().exists(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().exists(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    watching.commitWatcher(rc, true);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public Stat forPath(String path) throws Exception
{    path = client.fixForNamespace(path);    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    Stat returnStat = null;    if (backgrounding.inBackground()) {        OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching);        if (createParentContainersIfNeeded || createParentsIfNeeded) {            CreateBuilderImpl.backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData(), backgrounding, acling.getACLProviderForParents(), createParentContainersIfNeeded);        } else {            client.processBackgroundOperation(operationAndData, null);        }    } else {        returnStat = pathInForeground(path);    }    return returnStat;}
0
private Stat pathInForeground(final String path) throws Exception
{    if (createParentContainersIfNeeded || createParentsIfNeeded) {        final String parent = ZKPaths.getPathAndNode(path).getPath();        if (!parent.equals(ZKPaths.PATH_SEPARATOR)) {            OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground-CreateParents");            RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);                    } catch (KeeperException.NodeExistsException e) {                                        } catch (KeeperException.NoNodeException e) {                                        }                    return null;                }            });            trace.setPath(path).commit();        }    }    return pathInForegroundStandard(path);}
0
public Void call() throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.NoNodeException e) {        }    return null;}
0
private Stat pathInForegroundStandard(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground");    Stat returnStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            Stat returnStat;            if (watching.isWatched()) {                returnStat = client.getZooKeeper().exists(path, true);            } else {                returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));                int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();                watching.commitWatcher(rc, true);            }            return returnStat;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(returnStat).commit();    return returnStat;}
0
public Stat call() throws Exception
{    Stat returnStat;    if (watching.isWatched()) {        returnStat = client.getZooKeeper().exists(path, true);    } else {        returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));        int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();        watching.commitWatcher(rc, true);    }    return returnStat;}
0
 CuratorMultiTransactionRecord getRecord()
{    return record;}
0
public TypeAndPath getTypeAndPath()
{    validate();    return record.getMetadata(0);}
0
public Op get()
{    validate();    return record.iterator().next();}
0
public void addToDigest(MessageDigest digest)
{    record.addToDigest(digest);}
0
private void validate()
{    Preconditions.checkArgument(record.size() > 0, "No operation has been added");    Preconditions.checkArgument(record.size() == 1, "Multiple operations added");}
0
protected void executeGuaranteedOperationInBackground(String path) throws Exception
{    client.delete().guaranteed().inBackground().forPath(path);}
0
 void addFailedOperation(T details)
{    if (debugListener != null) {        debugListener.pathAddedForGuaranteedOperation(details);    }    if (client.getState() == CuratorFrameworkState.STARTED) {                try {            executeGuaranteedOperationInBackground(details);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            addFailedOperation(details);        }    }}
1
protected void executeGuaranteedOperationInBackground(FailedRemoveWatchDetails details) throws Exception
{    if (details.watcher == null) {        client.watches().removeAll().guaranteed().inBackground().forPath(details.path);    } else {        client.watches().remove(details.watcher).guaranteed().inBackground().forPath(details.path);    }}
0
 void execute()
{    OperationAndData.ErrorCallback<Void> errorCallback = new OperationAndData.ErrorCallback<Void>() {        @Override        public void retriesExhausted(OperationAndData<Void> operationAndData) {            operationAndData.reset();            client.processBackgroundOperation(operationAndData, null);        }    };    OperationAndData<Void> operationAndData = new OperationAndData<Void>(this, null, null, errorCallback, null, null);    client.processBackgroundOperation(operationAndData, null);}
0
public void retriesExhausted(OperationAndData<Void> operationAndData)
{    operationAndData.reset();    client.processBackgroundOperation(operationAndData, null);}
0
public void performBackgroundOperation(final OperationAndData<Void> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("FindAndDeleteProtectedNodeInBackground");    AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {        @Override        public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {            trace.setReturnCode(rc).setPath(path).setStat(stat).commit();            if (debugInsertError.compareAndSet(true, false)) {                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }            if (rc == KeeperException.Code.OK.intValue()) {                                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);                if (node != null) {                    try {                        String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                        client.delete().guaranteed().inBackground().forPath(deletePath);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                                                rc = KeeperException.Code.CONNECTIONLOSS.intValue();                    }                }            }            if (rc != KeeperException.Code.OK.intValue()) {                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }    };    client.getZooKeeper().getChildren(namespaceAdjustedParentPath, false, callback, null);}
1
public void processResult(int rc, String path, Object o, List<String> strings, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    if (debugInsertError.compareAndSet(true, false)) {        rc = KeeperException.Code.CONNECTIONLOSS.intValue();    }    if (rc == KeeperException.Code.OK.intValue()) {                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);        if (node != null) {            try {                String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                client.delete().guaranteed().inBackground().forPath(deletePath);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }        }    }    if (rc != KeeperException.Code.OK.intValue()) {        CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
1
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<List<ACL>> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<List<ACL>> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public Pathable<List<ACL>> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public Pathable<List<ACL>> storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Background");        AsyncCallback.ACLCallback callback = new AsyncCallback.ACLCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().getACL(operationAndData.getData(), responseStat, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);    client.processBackgroundOperation(operationAndData, event);}
0
public List<ACL> forPath(String path) throws Exception
{    path = client.fixForNamespace(path);    List<ACL> result = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        result = pathInForeground(path);    }    return result;}
0
private List<ACL> pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Foreground");    List<ACL> result = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<ACL>>() {        @Override        public List<ACL> call() throws Exception {            return client.getZooKeeper().getACL(path, responseStat);        }    });    trace.setPath(path).setStat(responseStat).commit();    return result;}
0
public List<ACL> call() throws Exception
{    return client.getZooKeeper().getACL(path, responseStat);}
0
public WatchPathable<List<String>> storingStatIn(Stat stat)
{    responseStat = stat;    return new WatchPathable<List<String>>() {        @Override        public List<String> forPath(String path) throws Exception {            return GetChildrenBuilderImpl.this.forPath(path);        }        @Override        public Pathable<List<String>> watched() {            GetChildrenBuilderImpl.this.watched();            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(Watcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(CuratorWatcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }    };}
0
public List<String> forPath(String path) throws Exception
{    return GetChildrenBuilderImpl.this.forPath(path);}
0
public Pathable<List<String>> watched()
{    GetChildrenBuilderImpl.this.watched();    return GetChildrenBuilderImpl.this;}
0
public Pathable<List<String>> usingWatcher(Watcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
0
public Pathable<List<String>> usingWatcher(CuratorWatcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
0
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<List<String>> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<List<String>> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public Pathable<List<String>> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public BackgroundPathable<List<String>> watched()
{    watching = new Watching(client, true);    return this;}
0
public BackgroundPathable<List<String>> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public BackgroundPathable<List<String>> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Background");        AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {            @Override            public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if (strings == null) {                    strings = Lists.newArrayList();                }                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getChildren(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getChildren(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
0
public void processResult(int rc, String path, Object o, List<String> strings, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if (strings == null) {        strings = Lists.newArrayList();    }    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public List<String> forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    List<String> children = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        children = pathInForeground(path);    }    return children;}
0
private List<String> pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Foreground");    List<String> children = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<String>>() {        @Override        public List<String> call() throws Exception {            List<String> children;            if (watching.isWatched()) {                children = client.getZooKeeper().getChildren(path, true, responseStat);            } else {                children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return children;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return children;}
0
public List<String> call() throws Exception
{    List<String> children;    if (watching.isWatched()) {        children = client.getZooKeeper().getChildren(path, true, responseStat);    } else {        children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return children;}
0
public WatchBackgroundEnsembleable<byte[]> storingStatIn(Stat stat)
{    this.stat = stat;    return new WatchBackgroundEnsembleable<byte[]>() {        @Override        public ErrorListenerEnsembleable<byte[]> inBackground() {            return GetConfigBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(Object context) {            return GetConfigBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback) {            return GetConfigBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetConfigBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public byte[] forEnsemble() throws Exception {            return GetConfigBuilderImpl.this.forEnsemble();        }        @Override        public BackgroundEnsembleable<byte[]> watched() {            return GetConfigBuilderImpl.this.watched();        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }    };}
0
public ErrorListenerEnsembleable<byte[]> inBackground()
{    return GetConfigBuilderImpl.this.inBackground();}
0
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
0
public byte[] forEnsemble() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
0
public BackgroundEnsembleable<byte[]> watched()
{    return GetConfigBuilderImpl.this.watched();}
0
public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
0
public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
0
public BackgroundEnsembleable<byte[]> watched()
{    watching = new Watching(client, true);    return new InternalBackgroundEnsembleable();}
0
public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
0
public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
0
public ErrorListenerEnsembleable<byte[]> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public Ensembleable<byte[]> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public byte[] forEnsemble() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<Void>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);        return null;    } else {        return configInForeground();    }}
0
public void performBackgroundOperation(final OperationAndData<Void> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getConfig(true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
0
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
private byte[] configInForeground() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("GetConfigBuilderImpl-Foreground");    try {        return RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {            @Override            public byte[] call() throws Exception {                if (watching.isWatched()) {                    return client.getZooKeeper().getConfig(true, stat);                }                byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);                return config;            }        });    } finally {        trace.commit();    }}
0
public byte[] call() throws Exception
{    if (watching.isWatched()) {        return client.getZooKeeper().getConfig(true, stat);    }    byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);    watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    return config;}
0
public ErrorListenerEnsembleable<byte[]> inBackground()
{    return GetConfigBuilderImpl.this.inBackground();}
0
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
0
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
0
public byte[] forEnsemble() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
0
public GetDataWatchBackgroundStatable decompressed()
{    decompress = true;    return new GetDataWatchBackgroundStatable() {        @Override        public ErrorListenerPathable<byte[]> inBackground() {            return GetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(Object context) {            return GetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback) {            return GetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public WatchPathable<byte[]> storingStatIn(Stat stat) {            return GetDataBuilderImpl.this.storingStatIn(stat);        }        @Override        public BackgroundPathable<byte[]> watched() {            return GetDataBuilderImpl.this.watched();        }        @Override        public BackgroundPathable<byte[]> usingWatcher(Watcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }    };}
0
public ErrorListenerPathable<byte[]> inBackground()
{    return GetDataBuilderImpl.this.inBackground();}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetDataBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathable<byte[]> inBackground(Object context)
{    return GetDataBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback)
{    return GetDataBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, executor);}
0
public byte[] forPath(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
0
public WatchPathable<byte[]> storingStatIn(Stat stat)
{    return GetDataBuilderImpl.this.storingStatIn(stat);}
0
public BackgroundPathable<byte[]> watched()
{    return GetDataBuilderImpl.this.watched();}
0
public BackgroundPathable<byte[]> usingWatcher(Watcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
0
public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
0
public WatchPathable<byte[]> storingStatIn(Stat stat)
{    this.responseStat = stat;    return new WatchPathable<byte[]>() {        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public Pathable<byte[]> watched() {            GetDataBuilderImpl.this.watched();            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(Watcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(CuratorWatcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }    };}
0
public byte[] forPath(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
0
public Pathable<byte[]> watched()
{    GetDataBuilderImpl.this.watched();    return GetDataBuilderImpl.this;}
0
public Pathable<byte[]> usingWatcher(Watcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
0
public Pathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<byte[]> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<byte[]> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public Pathable<byte[]> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public BackgroundPathable<byte[]> watched()
{    watching = new Watching(client, true);    return this;}
0
public BackgroundPathable<byte[]> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                if (decompress && (data != null)) {                    try {                        data = client.getCompressionProvider().decompress(path, data);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                                                rc = KeeperException.Code.DATAINCONSISTENCY.intValue();                    }                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getData(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getData(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
1
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    if (decompress && (data != null)) {        try {            data = client.getCompressionProvider().decompress(path, data);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                        rc = KeeperException.Code.DATAINCONSISTENCY.intValue();        }    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
1
public byte[] forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    byte[] responseData = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        responseData = pathInForeground(path);    }    return responseData;}
0
private byte[] pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            byte[] responseData;            if (watching.isWatched()) {                responseData = client.getZooKeeper().getData(path, true, responseStat);            } else {                responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return responseData;        }    });    trace.setResponseBytesLength(responseData).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
0
public byte[] call() throws Exception
{    byte[] responseData;    if (watching.isWatched()) {        responseData = client.getZooKeeper().getData(path, true, responseStat);    } else {        responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return responseData;}
0
private static Deflater acquireDeflater()
{    Deflater deflater = DEFLATER_POOL.poll();    if (deflater == null) {                deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true);    }    return deflater;}
0
private static Inflater acquireInflater()
{    Inflater inflater = INFLATER_POOL.poll();    if (inflater == null) {                inflater = new Inflater(true);    }    return inflater;}
0
public byte[] compress(String path, byte[] data)
{    if (data.length == 0) {                return COMPRESSED_EMPTY_BYTES.clone();    }    return doCompress(data);}
0
 static byte[] doCompress(byte[] data)
{    byte[] result = Arrays.copyOf(GZIP_HEADER, conservativeGZippedSizeEstimate(data.length));    Deflater deflater = acquireDeflater();    try {        deflater.setInput(data);        deflater.finish();        int offset = GZIP_HEADER_SIZE;        while (true) {            int available = result.length - GZIP_TRAILER_SIZE - offset;            int numCompressedBytes = deflater.deflate(result, offset, available);            offset += numCompressedBytes;            if (deflater.finished()) {                break;            }            int newResultLength = result.length + (result.length / 2);            result = Arrays.copyOf(result, newResultLength);        }                CRC32 crc = new CRC32();        crc.update(data, 0, data.length);        writeLittleEndianInt(result, offset, (int) crc.getValue());        writeLittleEndianInt(result, offset + 4, data.length);        int endOffset = offset + GZIP_TRAILER_SIZE;        if (result.length != endOffset) {            result = Arrays.copyOf(result, endOffset);        }        return result;    } finally {        deflater.reset();        DEFLATER_POOL.add(deflater);    }}
0
private static int conservativeGZippedSizeEstimate(int dataSize)
{    int conservativeCompressedDataSizeEstimate;    if (dataSize < 512) {                conservativeCompressedDataSizeEstimate = Math.max(dataSize, MIN_COMPRESSED_DATA_SIZE);    } else {                conservativeCompressedDataSizeEstimate = Math.max(512, dataSize / 2);    }    return GZIP_HEADER_SIZE + conservativeCompressedDataSizeEstimate + GZIP_TRAILER_SIZE;}
0
private static void writeLittleEndianInt(byte[] b, int offset, int v)
{    b[offset] = (byte) v;    b[offset + 1] = (byte) (v >> 8);    b[offset + 2] = (byte) (v >> 16);    b[offset + 3] = (byte) (v >> 24);}
0
public byte[] decompress(String path, byte[] gzippedDataBytes) throws IOException
{    if (Arrays.equals(gzippedDataBytes, COMPRESSED_EMPTY_BYTES)) {                return new byte[0];    }    ByteBuffer gzippedData = ByteBuffer.wrap(gzippedDataBytes);    gzippedData.order(ByteOrder.LITTLE_ENDIAN);    int headerSize = readGzipHeader(gzippedData);    if (gzippedDataBytes.length < headerSize + MIN_COMPRESSED_DATA_SIZE + GZIP_TRAILER_SIZE) {        throw new EOFException("Too short GZipped data");    }    int compressedDataSize = gzippedDataBytes.length - headerSize - GZIP_TRAILER_SIZE;            int initialResultLength = (int) Math.min(compressedDataSize * 3L, MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);    byte[] result = new byte[initialResultLength];    Inflater inflater = acquireInflater();    try {        inflater.setInput(gzippedDataBytes, headerSize, compressedDataSize);        CRC32 crc = new CRC32();        int offset = 0;        while (true) {            int numDecompressedBytes;            try {                numDecompressedBytes = inflater.inflate(result, offset, result.length - offset);            } catch (DataFormatException e) {                String s = e.getMessage();                throw new ZipException(s != null ? s : "Invalid ZLIB data format");            }            crc.update(result, offset, numDecompressedBytes);            offset += numDecompressedBytes;            if (inflater.finished() || inflater.needsDictionary()) {                break;            } else             if (numDecompressedBytes == 0 && inflater.needsInput()) {                throw new ZipException("Corrupt GZipped data");            }                        if (result.length == MAX_SAFE_JAVA_BYTE_ARRAY_SIZE && numDecompressedBytes == 0) {                throw new OutOfMemoryError("Unable to uncompress that much data into a single byte[] array");            }            int newResultLength = (int) Math.min((long) result.length + (result.length / 2), MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);            if (result.length != newResultLength) {                result = Arrays.copyOf(result, newResultLength);            }        }        if (inflater.getRemaining() != 0) {            throw new ZipException("Expected just one GZip block, without garbage in the end");        }        int checksum = gzippedData.getInt(gzippedDataBytes.length - GZIP_TRAILER_SIZE);        int numUncompressedBytes = gzippedData.getInt(gzippedDataBytes.length - Integer.BYTES);        if (checksum != (int) crc.getValue() || numUncompressedBytes != offset) {            throw new ZipException("Corrupt GZIP trailer");        }        if (result.length != offset) {            result = Arrays.copyOf(result, offset);        }        return result;    } finally {        inflater.reset();        INFLATER_POOL.add(inflater);    }}
0
private static int readGzipHeader(ByteBuffer gzippedData) throws IOException
{    try {        return doReadHeader(gzippedData);    } catch (BufferUnderflowException e) {        throw new EOFException();    }}
0
private static int doReadHeader(ByteBuffer gzippedData) throws IOException
{    if (gzippedData.getChar() != GZIP_MAGIC) {        throw new ZipException("Not in GZip format");    }    if (gzippedData.get() != Deflater.DEFLATED) {        throw new ZipException("Unsupported compression method");    }    int flags = gzippedData.get();        skip(gzippedData, Integer.BYTES + Byte.BYTES + Byte.BYTES);    if ((flags & FEXTRA) != 0) {        int extraBytes = gzippedData.getChar();        skip(gzippedData, extraBytes);    }    if ((flags & FNAME) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FCOMMENT) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FHCRC) != 0) {        CRC32 crc = new CRC32();        crc.update(gzippedData.array(), 0, gzippedData.position());        if (gzippedData.getChar() != (char) crc.getValue()) {            throw new ZipException("Corrupt GZIP header");        }    }    return gzippedData.position();}
0
private static void skip(ByteBuffer gzippedData, int skipBytes) throws IOException
{    try {        gzippedData.position(gzippedData.position() + skipBytes);    } catch (IllegalArgumentException e) {        throw new EOFException();    }}
0
private static void skipZeroTerminatedString(ByteBuffer gzippedData)
{    while (gzippedData.get() != 0) {        }}
0
public CuratorFramework nonNamespaceView()
{    return usingNamespace(null);}
0
public CuratorFramework usingNamespace(String newNamespace)
{    return client.getNamespaceFacadeCache().get(newNamespace);}
0
public String getNamespace()
{    return namespace.getNamespace();}
0
public void start()
{    throw new UnsupportedOperationException();}
0
public void close()
{    throw new UnsupportedOperationException();}
0
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return client.getConnectionStateListenable();}
0
public Listenable<CuratorListener> getCuratorListenable()
{    throw new UnsupportedOperationException("getCuratorListenable() is only available from a non-namespaced CuratorFramework instance");}
0
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return client.getUnhandledErrorListenable();}
0
public void sync(String path, Object context)
{    internalSync(this, path, context);}
0
public CuratorZookeeperClient getZookeeperClient()
{    return client.getZookeeperClient();}
0
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
0
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
0
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
0
 void logError(String reason, Throwable e)
{    client.logError(reason, e);}
0
 String unfixForNamespace(String path)
{    return namespace.unfixForNamespace(path);}
0
 String fixForNamespace(String path)
{    return namespace.fixForNamespace(path, false);}
0
 String fixForNamespace(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
0
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
0
 FailedDeleteManager getFailedDeleteManager()
{    return failedDeleteManager;}
0
public NamespaceFacade load(String namespace) throws Exception
{    return new NamespaceFacade(client, namespace);}
0
 NamespaceFacade get(String namespace)
{    try {        return (namespace != null) ? cache.get(namespace) : nullNamespace;    } catch (ExecutionException e) {                throw new RuntimeException(e);    }}
0
 String getNamespace()
{    return namespace;}
0
 String unfixForNamespace(String path)
{    if ((namespace != null) && (path != null)) {        String namespacePath = ZKPaths.makePath(namespace, null);        if (!namespacePath.equals("/") && path.startsWith(namespacePath)) {            path = (path.length() > namespacePath.length()) ? path.substring(namespacePath.length()) : "/";        }    }    return path;}
0
 String fixForNamespace(String path, boolean isSequential)
{    if (ensurePathNeeded.get()) {        try {            final CuratorZookeeperClient zookeeperClient = client.getZookeeperClient();            RetryLoop.callWithRetry(zookeeperClient, new Callable<Object>() {                @Override                public Object call() throws Exception {                    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);                    return null;                }            });            ensurePathNeeded.set(false);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            client.logError("Ensure path threw exception", e);        }    }    return ZKPaths.fixForNamespace(namespace, path, isSequential);}
0
public Object call() throws Exception
{    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);    return null;}
0
 EnsurePath newNamespaceAwareEnsurePath(String path)
{    return new EnsurePath(fixForNamespace(path, false), client.getAclProvider());}
0
 String getUnfixedPath()
{    return unfixedPath;}
0
public void close()
{    client = null;    actualWatcher = null;    curatorWatcher = null;}
0
public void process(WatchedEvent event)
{    if (client != null) {        if ((event.getType() != Event.EventType.None) && (client.getWatcherRemovalManager() != null)) {            client.getWatcherRemovalManager().noteTriggeredWatcher(this);        }        if (actualWatcher != null) {            actualWatcher.process(new NamespaceWatchedEvent(client, event));        } else if (curatorWatcher != null) {            try {                curatorWatcher.process(new NamespaceWatchedEvent(client, event));            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Watcher exception", e);            }        }    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null) {        return false;    }    if (getClass() == o.getClass()) {        NamespaceWatcher watcher = (NamespaceWatcher) o;        return Objects.equal(unfixedPath, watcher.getUnfixedPath()) && Objects.equal(actualWatcher, watcher.actualWatcher) && Objects.equal(curatorWatcher, watcher.curatorWatcher);    }    return false;}
0
public int hashCode()
{    return Objects.hashCode(actualWatcher, unfixedPath, curatorWatcher);}
0
 void reset()
{    retryCount.set(0);    ordinal.set(nextOrdinal.getAndIncrement());}
0
 Object getContext()
{    return context;}
0
 boolean isConnectionRequired()
{    return connectionRequired;}
0
 void callPerformBackgroundOperation() throws Exception
{    operation.performBackgroundOperation(this);}
0
 T getData()
{    return data;}
0
 long getElapsedTimeMs()
{    return System.currentTimeMillis() - startTimeMs;}
0
 int getThenIncrementRetryCount()
{    return retryCount.getAndIncrement();}
0
 BackgroundCallback getCallback()
{    return callback;}
0
 ErrorCallback<T> getErrorCallback()
{    return errorCallback;}
0
 BackgroundOperation<T> getOperation()
{    return operation;}
0
 void clearSleep()
{    sleepUntilTimeMs.set(0);}
0
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    sleepUntilTimeMs.set(System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(time, unit));}
0
public long getDelay(TimeUnit unit)
{    return unit.convert(sleepUntilTimeMs.get() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);}
0
public int compareTo(Delayed o)
{    if (o == this) {        return 0;    }    long diff = getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);    if (diff == 0) {        if (o instanceof OperationAndData) {            diff = ordinal.get() - ((OperationAndData) o).ordinal.get();        }    }    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
0
 String getPath()
{    return path;}
0
 byte[] getData()
{    return data;}
0
 void setProtectedMode()
{    doProtected = true;    resetProtectedId();}
0
 void resetProtectedId()
{    protectedId = UUID.randomUUID().toString();}
0
 boolean doProtected()
{    return doProtected;}
0
 String protectedId()
{    return protectedId;}
0
 void checkSetSessionId(CuratorFrameworkImpl client, CreateMode createMode) throws Exception
{    if (doProtected && (sessionId == 0) && createMode.isEphemeral()) {        sessionId = client.getZooKeeper().getSessionId();    }}
0
 String validateFoundNode(CuratorFrameworkImpl client, CreateMode createMode, String foundNode) throws Exception
{    if (doProtected && createMode.isEphemeral()) {        long clientSessionId = client.getZooKeeper().getSessionId();        if (this.sessionId != clientSessionId) {                        if (foundNode != null) {                                client.getFailedDeleteManager().executeGuaranteedOperationInBackground(foundNode);                foundNode = null;            }            this.sessionId = clientSessionId;        }    }    return foundNode;}
1
public byte[] forEnsemble() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return new byte[0];    } else {        return ensembleInForeground();    }}
0
public ErrorListenerReconfigBuilderMain inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerReconfigBuilderMain inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
0
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ReconfigBuilderMain withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public StatConfigureEnsembleable withNewMembers(String... server)
{    return withNewMembers((server != null) ? Arrays.asList(server) : null);}
0
public StatConfigureEnsembleable withNewMembers(List<String> servers)
{    newMembers = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new StatConfigureEnsembleable() {        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }    };}
0
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
0
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
0
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
0
public LeaveStatConfigEnsembleable joining(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
0
public LeaveStatConfigEnsembleable joining(List<String> servers)
{    joining = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new LeaveStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public JoinStatConfigEnsembleable leaving(String... server) {            return ReconfigBuilderImpl.this.leaving(server);        }        @Override        public JoinStatConfigEnsembleable leaving(List<String> servers) {            return ReconfigBuilderImpl.this.leaving(servers);        }    };}
0
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
0
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
0
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
0
public JoinStatConfigEnsembleable leaving(String... server)
{    return ReconfigBuilderImpl.this.leaving(server);}
0
public JoinStatConfigEnsembleable leaving(List<String> servers)
{    return ReconfigBuilderImpl.this.leaving(servers);}
0
public JoinStatConfigEnsembleable leaving(String... server)
{    return leaving((server != null) ? Arrays.asList(server) : null);}
0
public JoinStatConfigEnsembleable leaving(List<String> servers)
{    leaving = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new JoinStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public LeaveStatConfigEnsembleable joining(String... server) {            return joining((server != null) ? Arrays.asList(server) : null);        }        @Override        public LeaveStatConfigEnsembleable joining(List<String> servers) {            return ReconfigBuilderImpl.this.joining(servers);        }    };}
0
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
0
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
0
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
0
public LeaveStatConfigEnsembleable joining(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
0
public LeaveStatConfigEnsembleable joining(List<String> servers)
{    return ReconfigBuilderImpl.this.joining(servers);}
0
public void performBackgroundOperation(final OperationAndData<Void> data) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat) {                trace.commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);                client.processBackgroundOperation(data, event);            }        };        client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat)
{    trace.commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);    client.processBackgroundOperation(data, event);}
0
private byte[] ensembleInForeground() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);        }    });    trace.commit();    return responseData;}
0
public byte[] call() throws Exception
{    return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);}
0
 void internalRemoval(Watcher watcher, String path) throws Exception
{    this.watcher = watcher;    watcherType = WatcherType.Any;    quietly = true;    guaranteed = true;    if (Boolean.getBoolean(DebugUtils.PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND)) {        this.backgrounding = new Backgrounding();        pathInForeground(path);    } else {        this.backgrounding = new Backgrounding(true);        pathInBackground(path);    }}
0
public RemoveWatchesType remove(Watcher watcher)
{    this.watcher = watcher;    this.curatorWatcher = null;    return this;}
0
public RemoveWatchesType remove(CuratorWatcher watcher)
{    this.watcher = null;    this.curatorWatcher = watcher;    return this;}
0
public RemoveWatchesType removeAll()
{    this.watcher = null;    this.curatorWatcher = null;    return this;}
0
public RemoveWatchesLocal ofType(WatcherType watcherType)
{    this.watcherType = watcherType;    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<Void> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public RemoveWatchesLocal guaranteed()
{    guaranteed = true;    return this;}
0
public BackgroundPathableQuietlyable<Void> locally()
{    local = true;    return this;}
0
public BackgroundPathable<Void> quietly()
{    quietly = true;    return this;}
0
public Void forPath(String path) throws Exception
{    final String adjustedPath = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath);    } else {        pathInForeground(adjustedPath);    }    return null;}
0
private void pathInBackground(final String path)
{    OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {        errorCallback = new OperationAndData.ErrorCallback<String>() {            @Override            public void retriesExhausted(OperationAndData<String> operationAndData) {                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));            }        };    }    client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), !local), null);}
0
public void retriesExhausted(OperationAndData<String> operationAndData)
{    client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));}
0
private void pathInForeground(final String path) throws Exception
{    NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(path);        if (local) {        ZooKeeper zkClient = client.getZooKeeper();        if (namespaceWatcher != null) {            zkClient.removeWatches(path, namespaceWatcher, watcherType, local);        } else {            zkClient.removeAllWatches(path, watcherType, local);        }    } else {        final NamespaceWatcher finalNamespaceWatcher = namespaceWatcher;        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();                    if (finalNamespaceWatcher != null) {                        zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);                    } else {                        zkClient.removeAllWatches(path, watcherType, false);                    }                } catch (Exception e) {                    if (RetryLoop.isRetryException(e) && guaranteed) {                                                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));                        throw e;                    } else if (e instanceof KeeperException.NoWatcherException && quietly) {                                        } else {                                                throw e;                    }                }                return null;            }        });    }}
0
public Void call() throws Exception
{    try {        ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();        if (finalNamespaceWatcher != null) {            zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);        } else {            zkClient.removeAllWatches(path, watcherType, false);        }    } catch (Exception e) {        if (RetryLoop.isRetryException(e) && guaranteed) {                        client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));            throw e;        } else if (e instanceof KeeperException.NoWatcherException && quietly) {                } else {                        throw e;        }    }    return null;}
0
private NamespaceWatcher makeNamespaceWatcher(String path)
{    NamespaceWatcher namespaceWatcher = null;    if (watcher != null) {        if (watcher instanceof NamespaceWatcher) {            namespaceWatcher = (NamespaceWatcher) watcher;        } else {            namespaceWatcher = new NamespaceWatcher(client, watcher, path);        }    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, path);    }    return namespaceWatcher;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("RemoteWatches-Background");        AsyncCallback.VoidCallback callback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        ZooKeeper zkClient = client.getZooKeeper();        NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(operationAndData.getData());        if (namespaceWatcher == null) {            zkClient.removeAllWatches(operationAndData.getData(), watcherType, local, callback, operationAndData.getContext());        } else {            zkClient.removeWatches(operationAndData.getData(), namespaceWatcher, watcherType, local, callback, operationAndData.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx)
{    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public BackgroundPathable<Stat> withACL(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, false);    return this;}
0
public ACLable<BackgroundPathable<Stat>> withVersion(int version)
{    this.version = version;    return this;}
0
public ErrorListenerPathable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public Pathable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public Stat forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    List<ACL> aclList = acling.getAclList(fixedPath);    client.getSchemaSet().getSchema(path).validateGeneral(path, null, aclList);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, fixedPath, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(fixedPath, aclList);    }    return resultStat;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Background");        String path = operationAndData.getData();        client.getZooKeeper().setACL(path, acling.getAclList(path), version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
private Stat pathInForeground(final String path, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setACL(path, aclList, version);        }    });    trace.setPath(path).setStat(resultStat).commit();    return resultStat;}
0
public Stat call() throws Exception
{    return client.getZooKeeper().setACL(path, aclList, version);}
0
 TransactionSetDataBuilder<T> asTransactionSetDataBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionSetDataBuilder<T>() {        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);            return context;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public PathAndBytesable<T> withVersion(int version) {            SetDataBuilderImpl.this.withVersion(version);            return this;        }        @Override        public VersionPathAndBytesable<T> compressed() {            compress = true;            return this;        }    };}
0
public T forPath(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);    return context;}
0
public T forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
0
public PathAndBytesable<T> withVersion(int version)
{    SetDataBuilderImpl.this.withVersion(version);    return this;}
0
public VersionPathAndBytesable<T> compressed()
{    compress = true;    return this;}
0
public SetDataBackgroundVersionable compressed()
{    compress = true;    return new SetDataBackgroundVersionable() {        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground() {            return SetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context) {            return SetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(Object context) {            return SetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback) {            return SetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public Stat forPath(String path, byte[] data) throws Exception {            return SetDataBuilderImpl.this.forPath(path, data);        }        @Override        public Stat forPath(String path) throws Exception {            return SetDataBuilderImpl.this.forPath(path);        }        @Override        public BackgroundPathAndBytesable<Stat> withVersion(int version) {            return SetDataBuilderImpl.this.withVersion(version);        }    };}
0
public ErrorListenerPathAndBytesable<Stat> inBackground()
{    return SetDataBuilderImpl.this.inBackground();}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context)
{    return SetDataBuilderImpl.this.inBackground(callback, context);}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, context, executor);}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(Object context)
{    return SetDataBuilderImpl.this.inBackground(context);}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback)
{    return SetDataBuilderImpl.this.inBackground(callback);}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, executor);}
0
public Stat forPath(String path, byte[] data) throws Exception
{    return SetDataBuilderImpl.this.forPath(path, data);}
0
public Stat forPath(String path) throws Exception
{    return SetDataBuilderImpl.this.forPath(path);}
0
public BackgroundPathAndBytesable<Stat> withVersion(int version)
{    return SetDataBuilderImpl.this.withVersion(version);}
0
public BackgroundPathAndBytesable<Stat> withVersion(int version)
{    this.version = version;    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public PathAndBytesable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public void performBackgroundOperation(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        client.getZooKeeper().setData(operationAndData.getData().getPath(), data, version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public Stat forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
0
public Stat forPath(String path, byte[] data) throws Exception
{    client.getSchemaSet().getSchema(path).validateGeneral(path, data, null);    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    path = client.fixForNamespace(path);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, new PathAndBytes(path, data), backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(path, data);    }    return resultStat;}
0
 int getVersion()
{    return version;}
0
private Stat pathInForeground(final String path, final byte[] data) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setData(path, data, version);        }    });    trace.setRequestBytesLength(data).setPath(path).setStat(resultStat).commit();    return resultStat;}
0
public Stat call() throws Exception
{    return client.getZooKeeper().setData(path, data, version);}
0
public void suspendConnection(CuratorFrameworkImpl client)
{    client.setToSuspended();}
0
public void checkNewConnection(CuratorFrameworkImpl client)
{    client.checkInstanceIndex();}
0
public ErrorListenerPathable<Void> inBackground()
{        return this;}
0
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
0
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
0
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SyncBuilderImpl-Background");        final String path = operationAndData.getData();        String adjustedPath = client.fixForNamespace(path);        AsyncCallback.VoidCallback voidCallback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().sync(adjustedPath, voidCallback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
0
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
0
public Void forPath(String path) throws Exception
{    OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null);    client.processBackgroundOperation(operationAndData, null);    return null;}
0
public StatPathable<byte[]> decompressed()
{    decompress = true;    return this;}
0
public Pathable<byte[]> storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
0
public byte[] forPath(String path) throws Exception
{    final String localPath = client.fixForNamespace(path);    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().getData(localPath, false, responseStat);        }    });    trace.setResponseBytesLength(responseData).setPath(path).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
0
public byte[] call() throws Exception
{    return client.getZooKeeper().getData(localPath, false, responseStat);}
0
public TransactionCreateBuilder<CuratorOp> create()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new CreateBuilderImpl(client).<CuratorOp>asTransactionCreateBuilder(op, op.getRecord());}
0
public TransactionDeleteBuilder<CuratorOp> delete()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new DeleteBuilderImpl(client).<CuratorOp>asTransactionDeleteBuilder(op, op.getRecord());}
0
public TransactionSetDataBuilder<CuratorOp> setData()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new SetDataBuilderImpl(client).<CuratorOp>asTransactionSetDataBuilder(op, op.getRecord());}
0
public TransactionCheckBuilder<CuratorOp> check()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return CuratorTransactionImpl.<CuratorOp>makeTransactionCheckBuilder(client, op, op.getRecord());}
0
public WatcherRemoveCuratorFramework newWatcherRemoveCuratorFramework()
{    return client.newWatcherRemoveCuratorFramework();}
0
 WatcherRemovalManager getRemovalManager()
{    return removalManager;}
0
public QuorumVerifier getCurrentConfig()
{    return client.getCurrentConfig();}
0
public void removeWatchers()
{    removalManager.removeWatchers();}
0
 WatcherRemovalManager getWatcherRemovalManager()
{    return removalManager;}
0
public CuratorFramework nonNamespaceView()
{    return client.nonNamespaceView();}
0
public CuratorFramework usingNamespace(String newNamespace)
{    return client.usingNamespace(newNamespace);}
0
public String getNamespace()
{    return client.getNamespace();}
0
public void start()
{    throw new UnsupportedOperationException();}
0
public void close()
{    throw new UnsupportedOperationException();}
0
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return client.getConnectionStateListenable();}
0
public Listenable<CuratorListener> getCuratorListenable()
{    return client.getCuratorListenable();}
0
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return client.getUnhandledErrorListenable();}
0
public void sync(String path, Object context)
{    client.sync(path, context);}
0
public CuratorZookeeperClient getZookeeperClient()
{    return client.getZookeeperClient();}
0
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
0
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
0
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
0
 void logError(String reason, Throwable e)
{    client.logError(reason, e);}
0
 String unfixForNamespace(String path)
{    return client.unfixForNamespace(path);}
0
 String fixForNamespace(String path)
{    return client.fixForNamespace(path);}
0
 String fixForNamespace(String path, boolean isSequential)
{    return client.fixForNamespace(path, isSequential);}
0
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return client.newNamespaceAwareEnsurePath(path);}
0
 FailedDeleteManager getFailedDeleteManager()
{    return client.getFailedDeleteManager();}
0
 void add(NamespaceWatcher watcher)
{    watcher = Preconditions.checkNotNull(watcher, "watcher cannot be null");    entries.add(watcher);}
0
 Set<? extends Watcher> getEntries()
{    return Sets.newHashSet(entries);}
0
 void removeWatchers()
{    if (client.isZk34CompatibilityMode()) {        return;    }    List<NamespaceWatcher> localEntries = Lists.newArrayList(entries);    while (localEntries.size() > 0) {        NamespaceWatcher watcher = localEntries.remove(0);        if (entries.remove(watcher) && !client.isZk34CompatibilityMode()) {            try {                                RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client);                builder.internalRemoval(watcher, watcher.getUnfixedPath());            } catch (Exception e) {                            }        }    }}
1
 void noteTriggeredWatcher(NamespaceWatcher watcher)
{    entries.remove(watcher);}
0
 Watcher getWatcher(String unfixedPath)
{    namespaceWatcher = null;    if (watcher != null) {        namespaceWatcher = new NamespaceWatcher(client, this.watcher, unfixedPath);    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, unfixedPath);    }    return namespaceWatcher;}
0
 boolean hasWatcher()
{    return (watcher != null) || (curatorWatcher != null);}
0
 boolean isWatched()
{    return watched;}
0
 void commitWatcher(int rc, boolean isExists)
{    boolean doCommit = false;    if (isExists) {        doCommit = ((rc == KeeperException.Code.OK.intValue()) || (rc == KeeperException.Code.NONODE.intValue()));    } else {        doCommit = (rc == KeeperException.Code.OK.intValue());    }    if (doCommit && (namespaceWatcher != null)) {        if (client.getWatcherRemovalManager() != null) {            client.getWatcherRemovalManager().add(namespaceWatcher);        }    }}
0
public void addListener(T listener)
{    addListener(listener, MoreExecutors.directExecutor());}
0
public void addListener(T listener, Executor executor)
{    listeners.put(listener, new ListenerEntry<T>(listener, executor));}
0
public void removeListener(T listener)
{    if (listener != null) {        listeners.remove(listener);    }}
0
public void clear()
{    listeners.clear();}
0
public int size()
{    return listeners.size();}
0
public void forEach(final Function<T, Void> function)
{    for (final ListenerEntry<T> entry : listeners.values()) {        entry.executor.execute(new Runnable() {            @Override            public void run() {                try {                    function.apply(entry.listener);                } catch (Throwable e) {                    ThreadUtils.checkInterrupted(e);                                    }            }        });    }}
1
public void run()
{    try {        function.apply(entry.listener);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);            }}
1
 boolean isEmpty()
{    return size() == 0;}
0
public static ListenerManager<K, V> mapping(Function<K, V> mapper)
{    return new MappingListenerManager<>(mapper);}
0
public void addListener(K listener)
{    addListener(listener, Runnable::run);}
0
public void addListener(K listener, Executor executor)
{    V mapped = mapper.apply(listener);    listeners.put(listener, new ListenerEntry<>(mapped, executor));}
0
public void removeListener(K listener)
{    if (listener != null) {        listeners.remove(listener);    }}
0
public void clear()
{    listeners.clear();}
0
public int size()
{    return listeners.size();}
0
public void forEach(Consumer<V> function)
{    for (ListenerEntry<V> entry : listeners.values()) {        entry.executor.execute(() -> {            try {                function.accept(entry.listener);            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                            }        });    }}
1
public static StandardListenerManager<T> standard()
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(Function.identity());    return new StandardListenerManager<>(container);}
0
public static StandardListenerManager<T> mappingStandard(UnaryOperator<T> mapper)
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(mapper);    return new StandardListenerManager<>(container);}
0
public void addListener(T listener)
{    container.addListener(listener);}
0
public void addListener(T listener, Executor executor)
{    container.addListener(listener, executor);}
0
public void removeListener(T listener)
{    container.removeListener(listener);}
0
public void clear()
{    container.clear();}
0
public int size()
{    return container.size();}
0
public void forEach(Consumer<T> function)
{    container.forEach(function);}
0
public boolean isTtl(CreateMode mode)
{    return mode.isTTL();}
0
public static boolean isTtl(CreateMode mode)
{    return !Compatibility.isZK34() && Internal.instance.isTtl(mode);}
0
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return true;}
0
public static SchemaBuilder builder(String path)
{    return new SchemaBuilder(null, path);}
0
public static SchemaBuilder builder(Pattern pathRegex)
{    return new SchemaBuilder(pathRegex, null);}
0
public static SchemaBuilder builderForRecipeParent(String parentPath)
{    return new SchemaBuilder(null, parentPath).sequential(Allowance.CANNOT).ephemeral(Allowance.CANNOT);}
0
public static SchemaBuilder builderForRecipe(String parentPath)
{    return new SchemaBuilder(Pattern.compile(ZKPaths.makePath(parentPath, ".*")), null).sequential(Allowance.MUST).ephemeral(Allowance.MUST).watched(Allowance.MUST).canBeDeleted(true);}
0
private String fixPath(String path)
{    if (path != null) {        if (path.endsWith(ZKPaths.PATH_SEPARATOR)) {            return (path.length() > 1) ? path.substring(0, path.length() - 1) : "";        }        return path;    }    return null;}
0
public void validateDelete(String path)
{    if (!canBeDeleted) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be deleted");    }}
0
public void validateWatch(String path, boolean isWatching)
{    if (isWatching && (watched == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be watched");    }    if (!isWatching && (watched == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Must be watched");    }}
0
public void validateCreate(CreateMode mode, String path, byte[] data, List<ACL> acl)
{    if (mode.isEphemeral() && (ephemeral == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be ephemeral");    }    if (!mode.isEphemeral() && (ephemeral == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be ephemeral");    }    if (mode.isSequential() && (sequential == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be sequential");    }    if (!mode.isSequential() && (sequential == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be sequential");    }    validateGeneral(path, data, acl);}
0
public void validateGeneral(String path, byte[] data, List<ACL> acl)
{    if (!schemaValidator.isValid(this, path, data, acl)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Data is not valid");    }}
0
public String getName()
{    return name;}
0
public String getRawPath()
{    return (fixedPath != null) ? fixedPath : pathRegex.pattern();}
0
public Map<String, String> getMetadata()
{    return metadata;}
0
public Pattern getPathRegex()
{    return pathRegex;}
0
public String getPath()
{    return fixedPath;}
0
public String getDocumentation()
{    return documentation;}
0
public SchemaValidator getSchemaValidator()
{    return schemaValidator;}
0
public Allowance getEphemeral()
{    return ephemeral;}
0
public Allowance getSequential()
{    return sequential;}
0
public Allowance getWatched()
{    return watched;}
0
public boolean canBeDeleted()
{    return canBeDeleted;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Schema schema = (Schema) o;        if (!pathRegex.equals(schema.pathRegex)) {        return false;    }    return fixedPath.equals(schema.fixedPath);}
0
public int hashCode()
{    int result = pathRegex.hashCode();    result = 31 * result + fixedPath.hashCode();    return result;}
0
public String toString()
{    return "Schema{" + "name='" + name + '\'' + ", pathRegex=" + pathRegex + ", path='" + fixedPath + '\'' + ", documentation='" + documentation + '\'' + ", dataValidator=" + schemaValidator.getClass() + ", ephemeral=" + ephemeral + ", sequential=" + sequential + ", watched=" + watched + ", canBeDeleted=" + canBeDeleted + ", metadata=" + metadata + '}';}
0
public String toDocumentation()
{    String pathLabel = (pathRegex != null) ? "Path Regex: " : "Path: ";    return "Name: " + name + '\n' + pathLabel + getRawPath() + '\n' + "Doc: " + documentation + '\n' + "Validator: " + schemaValidator.getClass().getSimpleName() + '\n' + "Meta: " + metadata + '\n' + String.format("ephemeral: %s | sequential: %s | watched: %s | canBeDeleted: %s", ephemeral, sequential, watched, canBeDeleted) + '\n';}
0
public Schema build()
{    return new Schema(name, pathRegex, path, documentation, schemaValidator, ephemeral, sequential, watched, canBeDeleted, metadata);}
0
public SchemaBuilder name(String name)
{    this.name = Preconditions.checkNotNull(name, "name cannot be null");    return this;}
0
public SchemaBuilder documentation(String documentation)
{    this.documentation = Preconditions.checkNotNull(documentation, "documentation cannot be null");    return this;}
0
public SchemaBuilder dataValidator(SchemaValidator schemaValidator)
{    this.schemaValidator = Preconditions.checkNotNull(schemaValidator, "dataValidator cannot be null");    return this;}
0
public SchemaBuilder ephemeral(Schema.Allowance ephemeral)
{    this.ephemeral = Preconditions.checkNotNull(ephemeral, "ephemeral cannot be null");    return this;}
0
public SchemaBuilder sequential(Schema.Allowance sequential)
{    this.sequential = Preconditions.checkNotNull(sequential, "sequential cannot be null");    return this;}
0
public SchemaBuilder watched(Schema.Allowance watched)
{    this.watched = watched;    return this;}
0
public SchemaBuilder canBeDeleted(boolean canBeDeleted)
{    this.canBeDeleted = canBeDeleted;    return this;}
0
public SchemaBuilder metadata(Map<String, String> metadata)
{    this.metadata = ImmutableMap.copyOf(metadata);    return this;}
0
public Schema load(String path) throws Exception
{    for (Schema schema : regexSchemas) {        if (schema.getPathRegex().matcher(path).matches()) {                        return schema;        }    }    return nullSchema;}
1
public static SchemaSet getDefaultSchemaSet()
{    return new SchemaSet(Collections.<Schema>emptyList(), true) {        @Override        public String toDocumentation() {            return "Default schema";        }    };}
0
public String toDocumentation()
{    return "Default schema";}
0
public String apply(Schema schema)
{    return schema.getName();}
0
public Collection<Schema> getSchemas()
{    return schemas.values();}
0
public Schema getSchema(String path)
{    if (schemas.size() > 0) {        Schema schema = pathToSchemas.get(path);        if (schema == null) {            try {                schema = regexCache.get(path);                if (schema.equals(nullSchema)) {                    schema = useDefaultSchema ? defaultSchema : null;                }            } catch (ExecutionException e) {                throw new RuntimeException(e);            }        }        if (schema != null) {            return schema;        }    }    if (useDefaultSchema) {        return defaultSchema;    }    throw new SchemaViolation(null, new SchemaViolation.ViolatorData(path, null, null), "No schema found for: " + path);}
0
public static String getNamedPath(CuratorFramework client, String name)
{    return client.getSchemaSet().getNamedSchema(name).getRawPath();}
0
public Schema getNamedSchema(String name)
{    return schemas.get(name);}
0
public String toDocumentation()
{    StringBuilder str = new StringBuilder("Curator Schemas:\n\n");    for (Map.Entry<String, Schema> schemaEntry : schemas.entrySet()) {        str.append(schemaEntry.getKey()).append('\n').append(schemaEntry.getValue().toDocumentation()).append('\n');    }    return str.toString();}
0
public SchemaSet toSchemaSet(boolean useDefaultSchema)
{    return new SchemaSet(schemas, useDefaultSchema);}
0
public List<Schema> getSchemas()
{    return schemas;}
0
private static JsonNode getRoot(Reader in)
{    try {        return new ObjectMapper().readTree(in);    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
private void read(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    for (JsonNode child : node) {        readNode(builder, child, schemaValidatorMapper);    }}
0
private void readNode(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    String name = getText(node, "name", null);    String path = getText(node, "path", null);    boolean isRegex = getBoolean(node, "isRegex");    if (name == null) {        throw new RuntimeException("name is required at: " + node);    }    if (path == null) {        throw new RuntimeException("path is required at: " + node);    }    SchemaBuilder schemaBuilder = isRegex ? Schema.builder(Pattern.compile(path)) : Schema.builder(path);    String schemaValidatorName = getText(node, "schemaValidator", null);    if (schemaValidatorName != null) {        if (schemaValidatorMapper == null) {            throw new RuntimeException("No SchemaValidatorMapper provided but needed at: " + node);        }        schemaBuilder.dataValidator(schemaValidatorMapper.getSchemaValidator(schemaValidatorName));    }    Map<String, String> metadata = Maps.newHashMap();    if (node.has("metadata")) {        JsonNode metadataNode = node.get("metadata");        Iterator<String> fieldNameIterator = metadataNode.fieldNames();        while (fieldNameIterator.hasNext()) {            String fieldName = fieldNameIterator.next();            metadata.put(fieldName, getText(metadataNode, fieldName, ""));        }    }    Schema schema = schemaBuilder.name(name).documentation(getText(node, "documentation", "")).ephemeral(getAllowance(node, "ephemeral")).sequential(getAllowance(node, "sequential")).watched(getAllowance(node, "watched")).canBeDeleted(getBoolean(node, "canBeDeleted")).metadata(metadata).build();    builder.add(schema);}
0
private String getText(JsonNode node, String name, String defaultValue)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) ? namedNode.asText() : defaultValue;}
0
private boolean getBoolean(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) && namedNode.asBoolean();}
0
private Schema.Allowance getAllowance(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    try {        return (namedNode != null) ? Schema.Allowance.valueOf(namedNode.asText().toUpperCase()) : Schema.Allowance.CAN;    } catch (IllegalArgumentException ignore) {        throw new RuntimeException("Must be one of: " + Arrays.toString(Schema.Allowance.values()) + " at " + node);    }}
0
public String getPath()
{    return path;}
0
public byte[] getData()
{    return data;}
0
public List<ACL> getAcl()
{    return acl;}
0
public String toString()
{    String dataString = (data != null) ? new String(data) : "";    return "ViolatorData{" + "path='" + path + '\'' + ", data=" + dataString + ", acl=" + acl + '}';}
0
public Schema getSchema()
{    return schema;}
0
public String getViolation()
{    return violation;}
0
public ViolatorData getViolatorData()
{    return violatorData;}
0
public String toString()
{    return toString(schema, violation, violatorData) + super.toString();}
0
private static String toString(Schema schema, String violation, ViolatorData violatorData)
{    return (violation != null ? violation : "") + " " + schema + " " + violatorData;}
0
 static CircuitBreaker build(RetryPolicy retryPolicy)
{    return new CircuitBreaker(retryPolicy, ThreadUtils.newSingleThreadScheduledExecutor("CircuitBreakingConnectionStateListener"));}
0
 static CircuitBreaker build(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return new CircuitBreaker(retryPolicy, service);}
0
 boolean isOpen()
{    return isOpen;}
0
 int getRetryCount()
{    return retryCount;}
0
 boolean tryToOpen(Runnable completion)
{    if (isOpen) {        return false;    }    isOpen = true;    retryCount = 0;    startNanos = System.nanoTime();    if (tryToRetry(completion)) {        return true;    }    close();    return false;}
0
 boolean tryToRetry(Runnable completion)
{    if (!isOpen) {        return false;    }    long[] sleepTimeNanos = new long[] { 0L };    RetrySleeper retrySleeper = (time, unit) -> sleepTimeNanos[0] = unit.toNanos(time);    Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startNanos);    if (retryPolicy.allowRetry(retryCount, elapsedTime.toMillis(), retrySleeper)) {        ++retryCount;        service.schedule(completion, sleepTimeNanos[0], TimeUnit.NANOSECONDS);        return true;    }    return false;}
0
 boolean close()
{    boolean wasOpen = isOpen;    retryCount = 0;    isOpen = false;    startNanos = 0;    return wasOpen;}
0
public synchronized void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (circuitBreaker.isOpen()) {        handleOpenStateChange(newState);    } else {        handleClosedStateChange(newState);    }}
0
public synchronized boolean isOpen()
{    return circuitBreaker.isOpen();}
0
private synchronized void handleClosedStateChange(ConnectionState newState)
{    if (!newState.isConnected()) {        if (circuitBreaker.tryToOpen(this::checkCloseCircuit)) {                        circuitLastState = circuitInitialState = newState;            circuitLostHasBeenSent = (newState == ConnectionState.LOST);        } else {                    }    }    callListener(newState);}
1
private synchronized void handleOpenStateChange(ConnectionState newState)
{    if (circuitLostHasBeenSent || (newState != ConnectionState.LOST)) {                circuitLastState = newState;    } else {                circuitLostHasBeenSent = true;        circuitLastState = circuitInitialState = ConnectionState.LOST;        callListener(ConnectionState.LOST);    }}
1
private synchronized void checkCloseCircuit()
{    if ((circuitLastState == null) || circuitLastState.isConnected()) {                closeCircuit();    } else if (circuitBreaker.tryToRetry(this::checkCloseCircuit)) {            } else {                closeCircuit();    }}
1
private synchronized void callListener(ConnectionState newState)
{    if (newState != null) {        listener.stateChanged(client, newState);    }}
0
private synchronized void closeCircuit()
{    ConnectionState stateToSend = (circuitLastState == circuitInitialState) ? null : circuitLastState;    reset();    callListener(stateToSend);}
0
private synchronized void reset()
{    circuitLastState = null;    circuitInitialState = null;    circuitLostHasBeenSent = false;    circuitBreaker.close();}
0
public void clear()
{    doNotProxyContainer.clear();    mainContainer.clear();}
0
public int size()
{    return mainContainer.size() + doNotProxyContainer.size();}
0
public void forEach(Consumer<ConnectionStateListener> function)
{    doNotProxyContainer.forEach(function);    function.accept(masterListener);}
0
public void addListener(ConnectionStateListener listener)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener);    } else {        mainContainer.addListener(listener);    }}
0
public void addListener(ConnectionStateListener listener, Executor executor)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener, executor);    } else {        mainContainer.addListener(listener, executor);    }}
0
public void removeListener(ConnectionStateListener listener)
{    mainContainer.removeListener(listener);    doNotProxyContainer.removeListener(listener);}
0
public boolean isConnected()
{    return true;}
0
public boolean isConnected()
{    return false;}
0
public boolean isConnected()
{    return true;}
0
public boolean isConnected()
{    return false;}
0
public boolean isConnected()
{    return true;}
0
 boolean doNotProxy()
{    return false;}
0
 static ConnectionStateListenerManagerFactory circuitBreaking(RetryPolicy retryPolicy)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy));}
0
 static ConnectionStateListenerManagerFactory circuitBreaking(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy, service));}
0
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.submit(new Callable<Object>() {        @Override        public Object call() throws Exception {            processEvents();            return null;        }    });}
0
public Object call() throws Exception
{    processEvents();    return null;}
0
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        listeners.clear();    }}
0
public Listenable<ConnectionStateListener> getListenable()
{    return listeners;}
0
public synchronized boolean setToSuspended()
{    if (state.get() != State.STARTED) {        return false;    }    if ((currentConnectionState == ConnectionState.LOST) || (currentConnectionState == ConnectionState.SUSPENDED)) {        return false;    }    setCurrentConnectionState(ConnectionState.SUSPENDED);    postState(ConnectionState.SUSPENDED);    return true;}
0
public synchronized boolean addStateChange(ConnectionState newConnectionState)
{    if (state.get() != State.STARTED) {        return false;    }    ConnectionState previousState = currentConnectionState;    if (previousState == newConnectionState) {        return false;    }    setCurrentConnectionState(newConnectionState);    ConnectionState localState = newConnectionState;    boolean isNegativeMessage = ((newConnectionState == ConnectionState.LOST) || (newConnectionState == ConnectionState.SUSPENDED) || (newConnectionState == ConnectionState.READ_ONLY));    if (!isNegativeMessage && initialConnectMessageSent.compareAndSet(false, true)) {        localState = ConnectionState.CONNECTED;    }    postState(localState);    return true;}
0
public synchronized boolean blockUntilConnected(int maxWaitTime, TimeUnit units) throws InterruptedException
{    long startTime = System.currentTimeMillis();    boolean hasMaxWait = (units != null);    long maxWaitTimeMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWaitTime, units) : 0;    while (!isConnected()) {        if (hasMaxWait) {            long waitTime = maxWaitTimeMs - (System.currentTimeMillis() - startTime);            if (waitTime <= 0) {                return isConnected();            }            wait(waitTime);        } else {            wait();        }    }    return isConnected();}
0
public synchronized boolean isConnected()
{    return (currentConnectionState != null) && currentConnectionState.isConnected();}
0
private void postState(ConnectionState state)
{        notifyAll();    while (!eventQueue.offer(state)) {        eventQueue.poll();            }}
1
private void processEvents()
{    while (state.get() == State.STARTED) {        try {            int useSessionTimeoutMs = getUseSessionTimeoutMs();            long elapsedMs = startOfSuspendedEpoch == 0 ? useSessionTimeoutMs / 2 : System.currentTimeMillis() - startOfSuspendedEpoch;            long pollMaxMs = useSessionTimeoutMs - elapsedMs;            final ConnectionState newState = eventQueue.poll(pollMaxMs, TimeUnit.MILLISECONDS);            if (newState != null) {                if (listeners.isEmpty()) {                                    }                listeners.forEach(listener -> listener.stateChanged(client, newState));            } else if (sessionExpirationPercent > 0) {                synchronized (this) {                    checkSessionExpiration();                }            }        } catch (InterruptedException e) {                                }    }}
1
private void checkSessionExpiration()
{    if ((currentConnectionState == ConnectionState.SUSPENDED) && (startOfSuspendedEpoch != 0)) {        long elapsedMs = System.currentTimeMillis() - startOfSuspendedEpoch;        int useSessionTimeoutMs = getUseSessionTimeoutMs();        if (elapsedMs >= useSessionTimeoutMs) {                        startOfSuspendedEpoch = System.currentTimeMillis();                        try {                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());            } catch (Exception e) {                            }        }    } else if (currentConnectionState == ConnectionState.LOST) {        try {                        client.getZookeeperClient().getZooKeeper();        } catch (Exception e) {                    }    }}
1
private void setCurrentConnectionState(ConnectionState newConnectionState)
{    currentConnectionState = newConnectionState;    startOfSuspendedEpoch = (currentConnectionState == ConnectionState.SUSPENDED) ? System.currentTimeMillis() : 0;}
0
private int getUseSessionTimeoutMs()
{    int lastNegotiatedSessionTimeoutMs = client.getZookeeperClient().getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    useSessionTimeoutMs = sessionExpirationPercent > 0 && startOfSuspendedEpoch != 0 ? (useSessionTimeoutMs * sessionExpirationPercent) / 100 : useSessionTimeoutMs;    return useSessionTimeoutMs;}
0
public boolean isErrorState(ConnectionState state)
{    return state == ConnectionState.LOST;}
0
public boolean isErrorState(ConnectionState state)
{    return ((state == ConnectionState.SUSPENDED) || (state == ConnectionState.LOST));}
0
public void testBasic()
{    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        client.start();        Assert.assertTrue(timing.acquireSemaphore(counter));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testAfterSessionExpiration() throws Exception
{    TestingServer oldServer = server;    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        counter.drainPermits();        for (int i = 0; i < 5; ++i) {                        Assert.assertTrue(timing.acquireSemaphore(counter), "Failed when i is: " + i);        }                server = new TestingServer();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(oldServer);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
private CuratorFramework newClient(Semaphore counter)
{    return CuratorFrameworkFactory.builder().ensembleProvider(new CountingEnsembleProvider(counter)).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).build();}
0
public void start()
{}
0
public String getConnectionString()
{    getConnectionStringCounter.release();    return server.getConnectString();}
0
public void close()
{}
0
public void setConnectionString(String connectionString)
{}
0
public boolean updateServerListEnabled()
{    return false;}
0
public void testBlockUntilConnectedCurrentlyConnected() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState.isConnected()) {                    connectedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch), "Timed out awaiting latch");        Assert.assertTrue(client.blockUntilConnected(1, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState.isConnected()) {        connectedLatch.countDown();    }}
0
public void testBlockUntilConnectedCurrentlyNeverConnected()
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBlockUntilConnectedCurrentlyAwaitingReconnect()
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    final CountDownLatch lostLatch = new CountDownLatch(1);    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        }    });    try {        client.start();                Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Failed to connect");                CloseableUtils.closeQuietly(server);                Assert.assertTrue(timing.awaitLatch(lostLatch), "Failed to reach LOST state");        server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (Exception e) {        Assert.fail("Unexpected exception " + e);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
0
public void testBlockUntilConnectedConnectTimeout()
{        CloseableUtils.closeQuietly(server);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertFalse(client.blockUntilConnected(5, TimeUnit.SECONDS), "Connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBlockUntilConnectedInterrupt()
{        CloseableUtils.closeQuietly(server);    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final Thread threadToInterrupt = Thread.currentThread();        Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                threadToInterrupt.interrupt();            }        }, 3000);        client.blockUntilConnected(5, TimeUnit.SECONDS);        Assert.fail("Expected interruption did not occur");    } catch (InterruptedException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void run()
{    threadToInterrupt.interrupt();}
0
public void testBlockUntilConnectedTightLoop() throws InterruptedException
{    CuratorFramework client;    for (int i = 0; i < 50; i++) {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(100));        try {            client.start();            client.blockUntilConnected();            Assert.assertTrue(client.getZookeeperClient().isConnected(), "Not connected after blocking for connection #" + i);        } finally {            client.close();        }    }}
0
public static void closeAndTestClean(CuratorFramework client)
{    if (client == null) {        return;    }    if (Compatibility.isZK34()) {        CloseableUtils.closeQuietly(client);        return;    }    try {        Timing2 timing = new Timing2();        CuratorFrameworkImpl internalClient = (CuratorFrameworkImpl) client;        EnsembleTracker ensembleTracker = internalClient.getEnsembleTracker();        if (ensembleTracker != null) {            while (ensembleTracker.hasOutstanding()) {                Thread.sleep(100);            }            ensembleTracker.close();        }        ZooKeeper zooKeeper = internalClient.getZooKeeper();        if (zooKeeper != null) {            final int maxLoops = 3;            for (            int i = 0;             i < maxLoops;             ++i) {                if (i > 0) {                    timing.multiple(.5).sleepABit();                }                boolean isLast = (i + 1) == maxLoops;                if (WatchersDebug.getChildWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more child watchers are still registered: " + WatchersDebug.getChildWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getExistWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more exists watchers are still registered: " + WatchersDebug.getExistWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getDataWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more data watchers are still registered: " + WatchersDebug.getDataWatches(zooKeeper));                    }                    continue;                }                break;            }        }    } catch (IllegalStateException ignore) {        } catch (Exception e) {                e.printStackTrace();    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public static void test(CuratorFramework client, Callable<Void> proc) throws Exception
{    boolean succeeded = false;    try {        proc.call();        succeeded = true;    } finally {        if (succeeded) {            closeAndTestClean(client);        } else {            CloseableUtils.closeQuietly(client);        }    }}
0
public void testCompressionProvider() throws Exception
{    final byte[] data = "here's a string".getBytes();    final AtomicInteger compressCounter = new AtomicInteger();    final AtomicInteger decompressCounter = new AtomicInteger();    CompressionProvider compressionProvider = new CompressionProvider() {        @Override        public byte[] compress(String path, byte[] data) throws Exception {            compressCounter.incrementAndGet();            byte[] bytes = new byte[data.length * 2];            System.arraycopy(data, 0, bytes, 0, data.length);            System.arraycopy(data, 0, bytes, data.length, data.length);            return bytes;        }        @Override        public byte[] decompress(String path, byte[] compressedData) throws Exception {            decompressCounter.incrementAndGet();            byte[] bytes = new byte[compressedData.length / 2];            System.arraycopy(compressedData, 0, bytes, 0, bytes.length);            return bytes;        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().compressionProvider(compressionProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }    Assert.assertEquals(compressCounter.get(), 1);    Assert.assertEquals(decompressCounter.get(), 1);}
0
public byte[] compress(String path, byte[] data) throws Exception
{    compressCounter.incrementAndGet();    byte[] bytes = new byte[data.length * 2];    System.arraycopy(data, 0, bytes, 0, data.length);    System.arraycopy(data, 0, bytes, data.length, data.length);    return bytes;}
0
public byte[] decompress(String path, byte[] compressedData) throws Exception
{    decompressCounter.incrementAndGet();    byte[] bytes = new byte[compressedData.length / 2];    System.arraycopy(compressedData, 0, bytes, 0, bytes.length);    return bytes;}
0
public void testSetData() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertEquals(data, client.getData().forPath("/a/b/c"));        client.setData().compressed().forPath("/a/b/c", data);        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSetData() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op = client.transactionOp().create().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().forPath(path));                op = client.transactionOp().setData().compressed().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSetCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1);        CuratorOp op2 = client.transactionOp().create().forPath(path2);        client.transaction().forOperations(op1, op2);                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                op1 = client.transactionOp().setData().compressed().forPath(path1, data1);        op2 = client.transactionOp().setData().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().compressed().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSetData() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().forPath(path));                client.inTransaction().setData().compressed().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSetCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().compressed().forPath(path1).and().create().forPath(path2).and().commit();                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                client.inTransaction().setData().compressed().forPath(path1, data1).and().setData().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().compressed().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
0
public List<ACL> getAclForPath(String path)
{    switch(path) {        case "/bar":            return READ_CREATE;        case "/bar/foo":            return READ_CREATE_WRITE;    }    return null;}
0
private CuratorFramework createClient(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
0
public void testCreateWithParentsWithAcl() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateWithParentsWithAclApplyToParents() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl, true).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateWithParentsWithAclInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testCreateWithParentsWithAclApplyToParentsInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl, true).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testCreateWithParentsWithoutAcl() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().forPath(path);        List<ACL> actual_bar_foo_boo = client.getACL().forPath("/bar/foo/boo");        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateWithParentsWithoutAclInBackground() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        final String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo_boo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
private CuratorFramework createClient()
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
0
private void compare(CuratorFramework client, String path, Stat expected) throws Exception
{    Stat queriedStat = client.checkExists().forPath(path);    Assert.assertEquals(queriedStat, expected);}
0
public void testOrSetDataStoringStatIn() throws Exception
{    try (CuratorFramework client = createClient()) {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final String path = "/test";        final Stat versionZeroStat = new Stat();        client.create().orSetData().storingStatIn(versionZeroStat).forPath(path);        Assert.assertEquals(0, versionZeroStat.getVersion());        final Stat versionOneStat = new Stat();        client.create().orSetData().storingStatIn(versionOneStat).forPath(path);        Assert.assertEquals(versionZeroStat.getAversion(), versionOneStat.getAversion());        Assert.assertEquals(versionZeroStat.getCtime(), versionOneStat.getCtime());        Assert.assertEquals(versionZeroStat.getCversion(), versionOneStat.getCversion());        Assert.assertEquals(versionZeroStat.getCzxid(), versionOneStat.getCzxid());        Assert.assertEquals(versionZeroStat.getDataLength(), versionOneStat.getDataLength());        Assert.assertEquals(versionZeroStat.getEphemeralOwner(), versionOneStat.getEphemeralOwner());        Assert.assertTrue(versionZeroStat.getMtime() <= versionOneStat.getMtime());        Assert.assertNotEquals(versionZeroStat.getMzxid(), versionOneStat.getMzxid());        Assert.assertEquals(versionZeroStat.getNumChildren(), versionOneStat.getNumChildren());        Assert.assertEquals(versionZeroStat.getPzxid(), versionOneStat.getPzxid());        Assert.assertEquals(1, versionOneStat.getVersion());    }}
0
public void testCreateReturningStat() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateReturningStatIncludingParents() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().creatingParentsIfNeeded().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateReturningStatIncludingParentsReverse() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).creatingParentsIfNeeded().forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateReturningStatCompressed() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().compressed().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateReturningStatWithProtected() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        path = client.create().withProtection().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateReturningStatInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        final CountDownLatch latch = new CountDownLatch(1);        final AtomicReference<Stat> statRef = new AtomicReference<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    statRef.set(event.getStat());                    latch.countDown();                }            }        };        client.create().storingStatIn(stat).inBackground(callback).forPath(path);        if (!timing.awaitLatch(latch)) {            Assert.fail("Timed out awaing latch");        }        compare(client, path, statRef.get());        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        statRef.set(event.getStat());        latch.countDown();    }}
0
public void setup() throws Exception
{    super.setup();    client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    client.start();    states = Queues.newLinkedBlockingQueue();    ConnectionStateListener listener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            states.add(newState);        }    };    client.getConnectionStateListenable().addListener(listener);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
0
public void teardown() throws Exception
{    try {        CloseableUtils.closeQuietly(client);    } finally {        super.teardown();    }}
0
public void testResetCausesLost() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        client.checkExists().forPath("/");    client.getZookeeperClient().reset();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
0
public void testInjectedWatchedEvent() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.None) {                if (event.getState() == Event.KeeperState.Expired) {                    latch.countDown();                }            }        }    };    client.checkExists().usingWatcher(watcher).forPath("/");    server.stop();    Assert.assertTrue(timing.forSessionSleep().awaitLatch(latch));}
0
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.None) {        if (event.getState() == Event.KeeperState.Expired) {            latch.countDown();        }    }}
0
public void testKillSession() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
0
public void testReconnectWithoutExpiration() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    try {                client.checkExists().forPath("/");    } catch (KeeperException.ConnectionLossException ignore) {    }    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
0
public void testSessionExpirationFromTimeout() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);}
0
public void testSessionExpirationFromTimeoutWithRestart() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    timing.forSessionSleep().sleep();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        Assert.assertNull(states.poll(timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSingleExecution() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three");        ensureContainers.ensure();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testExistsWithParentsWithAclApplyToParents() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        assertNull(client.checkExists().creatingParentsIfNeeded().withACL(acl).forPath(path));        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testExistsWithParentsWithAclApplyToParentsInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
private CuratorFramework createClient(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
0
public void testLostSession() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
0
public void testWithNamespaceAndLostSession() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("aisa").build();    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
0
public void testWithNamespaceAndLostSessionAlt() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        client.start();        CuratorFramework namespaceClient = client.usingNamespace("foo");        namespaceClient.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        namespaceClient.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            namespaceClient.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(namespaceClient.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
0
public void testBasic() throws Exception
{    final String PATH = "/one/two/three";    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session());    CuratorFrameworkImpl client = new CuratorFrameworkImpl(builder);    client.start();    try {        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().guaranteed().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        final int TRIES = 5;        for (int i = 0; i < TRIES; ++i) {            if (client.checkExists().forPath(PATH) != null) {                timing.sleepABit();            }        }        Assert.assertNull(client.checkExists().forPath(PATH));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGuaranteedDeleteOnNonExistentNodeInForeground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    try {        client.delete().guaranteed().forPath("/nonexistent");        Assert.fail();    } catch (NoNodeException e) {                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
0
public void pathAddedForGuaranteedOperation(String path)
{    pathAdded.set(true);}
0
public void testGuaranteedDeleteOnNonExistentNodeInBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    final CountDownLatch backgroundLatch = new CountDownLatch(1);    BackgroundCallback background = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            backgroundLatch.countDown();        }    };    try {        client.delete().guaranteed().inBackground(background).forPath("/nonexistent");        backgroundLatch.await();                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
0
public void pathAddedForGuaranteedOperation(String path)
{    pathAdded.set(true);}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    backgroundLatch.countDown();}
0
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
0
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
0
public void testWaitForShutdownTimeoutMs() throws Exception
{    final BlockingQueue<Integer> timeoutQueue = new ArrayBlockingQueue<>(1);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException {            return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {                @Override                public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {                    timeoutQueue.add(waitForShutdownTimeoutMs);                    return super.close(waitForShutdownTimeoutMs);                }            };        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).zookeeperFactory(zookeeperFactory).waitForShutdownTimeoutMs(10064).build();    try {        client.start();        client.checkExists().forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }    Integer polledValue = timeoutQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);    Assert.assertNotNull(polledValue);    Assert.assertEquals(10064, polledValue.intValue());}
0
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {        @Override        public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {            timeoutQueue.add(waitForShutdownTimeoutMs);            return super.close(waitForShutdownTimeoutMs);        }    };}
0
public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException
{    timeoutQueue.add(waitForShutdownTimeoutMs);    return super.close(waitForShutdownTimeoutMs);}
0
public void testSessionLossWithLongTimeout() throws Exception
{    final Timing timing = new Timing();    try (final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1))) {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(lostLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
0
public void testConnectionState() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = new LinkedBlockingQueue<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                queue.add(newState);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    queue.add(newState);}
0
public void testCreateOrSetData() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        String name = client.create().forPath("/hey", "there".getBytes());        Assert.assertEquals(name, "/hey");        name = client.create().orSetData().forPath("/hey", "other".getBytes());        Assert.assertEquals(name, "/hey");        Assert.assertEquals(client.getData().forPath("/hey"), "other".getBytes());        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "there".getBytes());        Assert.assertEquals(name, "/a/b/c");        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "what".getBytes());        Assert.assertEquals(name, "/a/b/c");        Assert.assertEquals(client.getData().forPath("/a/b/c"), "what".getBytes());        final BlockingQueue<CuratorEvent> queue = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event);            }        };        client.create().orSetData().inBackground(backgroundCallback).forPath("/a/b/c", "another".getBytes());        CuratorEvent event = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertEquals(event.getResultCode(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getType(), CuratorEventType.CREATE);        Assert.assertEquals(event.getPath(), "/a/b/c");        Assert.assertEquals(event.getName(), "/a/b/c");                CuratorEvent unexpectedEvent = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNull(unexpectedEvent);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event);}
0
public void testQuietDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.delete().quietly().forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                rc.add(event.getResultCode());            }        };        client.delete().quietly().inBackground(backgroundCallback).forPath("/foo/bar/hey");        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    rc.add(event.getResultCode());}
0
public void testNamespaceWithWatcher() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                try {                    queue.put(event.getPath());                } catch (InterruptedException e) {                    throw new Error(e);                }            }        };        client.create().forPath("/base");        client.getChildren().usingWatcher(watcher).forPath("/base");        client.create().forPath("/base/child");        String path = new Timing2().takeFromQueue(queue);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void process(WatchedEvent event)
{    try {        queue.put(event.getPath());    } catch (InterruptedException e) {        throw new Error(e);    }}
0
public void testNamespaceInBackground() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        CuratorListener listener = new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    queue.put(event.getPath());                }            }        };        client.getCuratorListenable().addListener(listener);        client.create().forPath("/base");        client.checkExists().inBackground().forPath("/base");        String path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");        client.getCuratorListenable().removeListener(listener);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        client.getChildren().inBackground(callback).forPath("/base");        path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        queue.put(event.getPath());    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
0
public void testCreateACLSingleAuth() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testACLDeprecatedApis() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    Assert.assertNull(builder.getAuthScheme());    Assert.assertNull(builder.getAuthValue());    builder = builder.authorization("digest", "me1:pass1".getBytes());    Assert.assertEquals(builder.getAuthScheme(), "digest");    Assert.assertEquals(builder.getAuthValue(), "me1:pass1".getBytes());}
0
public void testCreateACLMultipleAuths() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateACLWithReset() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail("Connection should be down");        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
0
public void testCreateParents() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.create().creatingParentsIfNeeded().forPath("/one/two/another", "bar".getBytes());        data = client.getData().forPath("/one/two/another");        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testOverrideCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).dontUseContainerParents().build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
private boolean checkForContainers()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
0
public void testCreatingParentsTheSame() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        client.delete().deletingChildrenIfNeeded().forPath("/one");        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testExistsCreatingParents() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testExistsCreatingParentsInBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentContainersIfNeeded().inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testEnsurePathWithNamespace() throws Exception
{    final String namespace = "jz";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        EnsurePath ensurePath = new EnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));        ensurePath = client.newNamespaceAwareEnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateContainersWithNamespace() throws Exception
{    final String namespace = "container1";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    try {        client.start();        String path = "/path1/path2";        client.createContainers(path);        Assert.assertNotNull(client.checkExists().forPath(path));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateContainersUsingNamespace() throws Exception
{    final String namespace = "container2";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        CuratorFramework nsClient = client.usingNamespace(namespace);        String path = "/path1/path2";        nsClient.createContainers(path);        Assert.assertNotNull(nsClient.checkExists().forPath(path));        Assert.assertNotNull(nsClient.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testNamespace() throws Exception
{    final String namespace = "TestNamespace";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        String actualPath = client.create().forPath("/test");        Assert.assertEquals(actualPath, "/test");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + "/test", false));        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/test", false));        actualPath = client.usingNamespace(null).create().forPath("/non");        Assert.assertEquals(actualPath, "/non");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/non", false));        client.create().forPath("/test/child", "hey".getBytes());        byte[] bytes = client.getData().forPath("/test/child");        Assert.assertEquals(bytes, "hey".getBytes());        bytes = client.usingNamespace(null).getData().forPath("/" + namespace + "/test/child");        Assert.assertEquals(bytes, "hey".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCustomCallback() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    if (event.getPath().equals("/head")) {                        latch.countDown();                    }                }            }        };        client.create().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        if (event.getPath().equals("/head")) {            latch.countDown();        }    }}
0
public void testSync() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.sync("/head", latch);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
0
public void testSyncNew() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    latch.countDown();                }            }        };        client.sync().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        latch.countDown();    }}
0
public void testBackgroundDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().inBackground(latch).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
0
public void testBackgroundDeleteWithChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/one/two");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three/four"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().deletingChildrenIfNeeded().inBackground(latch).forPath("/one/two");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/one/two");        ((CountDownLatch) event.getContext()).countDown();    }}
0
public void testDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        client.delete().forPath("/head");        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testDeleteWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testDeleteGuaranteedWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGetSequentialChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        for (int i = 0; i < 10; ++i) {            client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child");        }        List<String> children = client.getChildren().forPath("/head");        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBackgroundGetDataWithWatch() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch watchedLatch = new CountDownLatch(1);        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.GET_DATA) {                    Assert.assertEquals(event.getPath(), "/test");                    Assert.assertEquals(event.getData(), data1);                    ((CountDownLatch) event.getContext()).countDown();                } else if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        Assert.assertEquals(event.getPath(), "/test");                        watchedLatch.countDown();                    }                }            }        });        client.create().forPath("/test", data1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        client.getData().watched().inBackground(backgroundLatch).forPath("/test");        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        client.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = client.getData().forPath("/test");        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.GET_DATA) {        Assert.assertEquals(event.getPath(), "/test");        Assert.assertEquals(event.getData(), data1);        ((CountDownLatch) event.getContext()).countDown();    } else if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();        }    }}
0
public void testBackgroundCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    Assert.assertEquals(event.getPath(), "/test");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.create().inBackground(latch).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        Assert.assertEquals(event.getPath(), "/test");        ((CountDownLatch) event.getContext()).countDown();    }}
0
public void testCreateModes() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        byte[] writtenBytes = { 1, 2, 3 };                client.create().forPath("/test", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        byte[] readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/ghost", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        Stat stat = client.checkExists().forPath("/ghost");        Assert.assertNull(stat);        String realPath = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/pseq", writtenBytes);        Assert.assertNotSame(realPath, "/pseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath(realPath);        Assert.assertEquals(writtenBytes, readBytes);        realPath = client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/eseq", writtenBytes);        Assert.assertNotSame(realPath, "/eseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        stat = client.checkExists().forPath(realPath);        Assert.assertNull(stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        String path = client.create().withMode(CreateMode.PERSISTENT).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertEquals(path, "/test");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSequentialWithTrailingSeparator() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");                String path = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test/");        Assert.assertTrue(path.startsWith("/test/"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testErrorListener() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof UnsupportedOperationException) {                    errorLatch.countDown();                }            }        };        client.create().inBackground().withUnhandledErrorListener(listener).forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
0
public List<ACL> getAclForPath(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
0
public void unhandledError(String message, Throwable e)
{    if (e instanceof UnsupportedOperationException) {        errorLatch.countDown();    }}
0
public void testListenerConnectedAtStart() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (firstListenerAction.compareAndSet(true, false)) {                    firstListenerState.set(newState);                    System.out.println("First listener state is " + newState);                }                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);                client.create().inBackground().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (firstListenerAction.compareAndSet(true, false)) {        firstListenerState.set(newState);        System.out.println("First listener state is " + newState);    }    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
0
public void testRetries() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                    long now = System.currentTimeMillis();                    times.add(now - start.get());                    start.set(now);                    latch.countDown();                }            }        };        server.stop();        client.create().inBackground().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void listen(OperationAndData<?> data)
{    if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {        long now = System.currentTimeMillis();        times.add(now - start.get());        start.set(now);        latch.countDown();    }}
0
public void testBasic() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final BlockingQueue<String> paths = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.add(event.getPath());            }        };        client.create().inBackground(callback).forPath("/one");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one");        client.create().inBackground(callback).forPath("/one/two");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two");        client.create().inBackground(callback).forPath("/one/two/three");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two/three");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.add(event.getPath());}
0
public void testCuratorCallbackOnError() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build();    final CountDownLatch latch = new CountDownLatch(1);    try {        client.start();        BackgroundCallback curatorCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        };                server.stop();                client.getChildren().inBackground(curatorCallback).forPath("/");                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    } finally {        client.close();    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
0
public void testShutdown() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof IllegalStateException) {                    hadIllegalStateException.set(true);                }            }        };        client.start();        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                try {                    operationReadyLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        };                client.create().inBackground().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void unhandledError(String message, Throwable e)
{    if (e instanceof IllegalStateException) {        hadIllegalStateException.set(true);    }}
0
public void listen(OperationAndData<?> data)
{    try {        operationReadyLatch.await();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
0
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
0
public void testInjectSessionExpiration() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        CountDownLatch expiredLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                expiredLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/foobar");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(expiredLatch));    }}
0
public void testProtectionWithKilledSession() throws Exception
{        server.stop();    try (TestingCluster cluster = new TestingCluster(3)) {        cluster.start();        InstanceSpec instanceSpec0 = cluster.getServers().get(0).getInstanceSpec();        CountDownLatch serverStoppedLatch = new CountDownLatch(1);        RetryPolicy retryPolicy = new RetryForever(100) {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                if (serverStoppedLatch.getCount() > 0) {                    try {                        cluster.killServer(instanceSpec0);                    } catch (Exception e) {                                        }                    serverStoppedLatch.countDown();                }                return super.allowRetry(retryCount, elapsedTimeMs, sleeper);            }        };        try (CuratorFramework client = CuratorFrameworkFactory.newClient(instanceSpec0.getConnectString(), timing.session(), timing.connection(), retryPolicy)) {            BlockingQueue<String> createdNode = new LinkedBlockingQueue<>();            BackgroundCallback callback = (__, event) -> {                if (event.getType() == CuratorEventType.CREATE) {                    createdNode.offer(event.getPath());                }            };            client.start();            client.create().forPath("/test");            ErrorListenerPathAndBytesable<String> builder = client.create().withProtection().withMode(CreateMode.EPHEMERAL).inBackground(callback);            ((CreateBuilderImpl) builder).failNextCreateForTesting = true;            builder.forPath("/test/hey");            Assert.assertTrue(timing.awaitLatch(serverStoppedLatch));                        timing.forSessionSleep().sleep();            cluster.restartServer(instanceSpec0);            String path = timing.takeFromQueue(createdNode);            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(Collections.singletonList(ZKPaths.getNodeFromPath(path)), children);        }    }}
0
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (serverStoppedLatch.getCount() > 0) {        try {            cluster.killServer(instanceSpec0);        } catch (Exception e) {                }        serverStoppedLatch.countDown();    }    return super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
0
public void testBackgroundLatencyUnSleep() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ((CuratorFrameworkImpl) client).sleepAndQueueOperationSeconds = Integer.MAX_VALUE;        final CountDownLatch latch = new CountDownLatch(3);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    latch.countDown();                }            }        };                client.create().inBackground(callback).forPath("/test");        client.create().inBackground(callback).forPath("/test/one");        client.create().inBackground(callback).forPath("/test/two");        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        latch.countDown();    }}
0
public void testCreateContainersForBadConnect() throws Exception
{    final int serverPort = server.getPort();    server.close();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryNTimes(10, timing.forSleepingABit().milliseconds()));    try {        new Thread() {            @Override            public void run() {                try {                    Thread.sleep(3000);                    server = new TestingServer(serverPort, true);                } catch (Exception e) {                    e.printStackTrace();                }            }        }.start();        client.start();        client.createContainers("/this/does/not/exist");        Assert.assertNotNull(client.checkExists().forPath("/this/does/not/exist"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void run()
{    try {        Thread.sleep(3000);        server = new TestingServer(serverPort, true);    } catch (Exception e) {        e.printStackTrace();    }}
0
public void testQuickClose() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        client.close();    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testProtectedCreateNodeDeletion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        for (int i = 0; i < 2; ++i) {            CuratorFramework localClient = (i == 0) ? client : client.usingNamespace("nm");            localClient.create().forPath("/parent");            Assert.assertEquals(localClient.getChildren().forPath("/parent").size(), 0);            CreateBuilderImpl createBuilder = (CreateBuilderImpl) localClient.create();            createBuilder.failNextCreateForTesting = true;            FindAndDeleteProtectedNodeInBackground.debugInsertError.set(true);            try {                createBuilder.withProtection().forPath("/parent/test");                Assert.fail("failNextCreateForTesting should have caused a ConnectionLossException");            } catch (KeeperException.ConnectionLossException e) {                        }            timing.sleepABit();            List<String> children = localClient.getChildren().forPath("/parent");                        Assert.assertEquals(children.size(), 0, children.toString());            localClient.delete().forPath("/parent");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testPathsFromProtectingInBackground() throws Exception
{    for (CreateMode mode : CreateMode.values()) {        internalTestPathsFromProtectingInBackground(mode);    }}
0
private void internalTestPathsFromProtectingInBackground(CreateMode mode) throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c");        final BlockingQueue<String> paths = new ArrayBlockingQueue<String>(2);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.put(event.getName());                paths.put(event.getPath());            }        };        final String TEST_PATH = "/a/b/c/test-";        long ttl = timing.forWaiting().milliseconds() * 1000;        CreateBuilder firstCreateBuilder = client.create();        if (SafeIsTtlMode.isTtl(mode)) {            firstCreateBuilder.withTtl(ttl);        }        firstCreateBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name1 = timing.takeFromQueue(paths);        String path1 = timing.takeFromQueue(paths);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));        client.start();        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.withProtection();        if (SafeIsTtlMode.isTtl(mode)) {            createBuilder.withTtl(ttl);        }        client.create().forPath(createBuilder.adjustPath(TEST_PATH));        createBuilder.debugForceFindProtectedNode = true;        createBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name2 = timing.takeFromQueue(paths);        String path2 = timing.takeFromQueue(paths);        Assert.assertEquals(ZKPaths.getPathAndNode(name1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(name2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        client.delete().deletingChildrenIfNeeded().forPath("/a/b/c");        client.delete().forPath("/a/b");        client.delete().forPath("/a");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.put(event.getName());    paths.put(event.getPath());}
0
public void connectionLossWithBackgroundTest() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        final CountDownLatch latch = new CountDownLatch(1);        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        server.close();        client.getChildren().inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        }).forPath("/");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testReconnectAfterLoss() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.checkExists().forPath("/");        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        client.checkExists().forPath("/");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
0
public void testGetAclNoStat() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try {            client.getACL().forPath("/");        } catch (NullPointerException e) {            Assert.fail();        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testMissedResponseOnBackgroundESCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        final BlockingQueue<String> queue = Queues.newArrayBlockingQueue(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath("/");        String ourPath = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
0
public void testMissedResponseOnESCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        String ourPath = createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/");        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSessionKilled() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/sessionTest");        CountDownLatch sessionDiedLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                sessionDiedLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/sessionTest");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(sessionDiedLatch));        Assert.assertNotNull(client.checkExists().forPath("/sessionTest"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testNestedCalls() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    Stat stat = client.checkExists().forPath("/yo/yo/yo");                    Assert.assertNull(stat);                    client.create().inBackground(event.getContext()).forPath("/what");                } else if (event.getType() == CuratorEventType.CREATE) {                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.checkExists().inBackground(latch).forPath("/hey");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        Stat stat = client.checkExists().forPath("/yo/yo/yo");        Assert.assertNull(stat);        client.create().inBackground(event.getContext()).forPath("/what");    } else if (event.getType() == CuratorEventType.CREATE) {        ((CountDownLatch) event.getContext()).countDown();    }}
0
public void testBackgroundFailure() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
0
public void testFailure() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 100, 100, new RetryOneTime(1));    client.start();    try {        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().forPath("/hey");        Assert.fail();    } catch (KeeperException.ConnectionLossException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRetry() throws Exception
{    final int MAX_RETRIES = 3;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(10));    client.start();    try {        final AtomicInteger retries = new AtomicInteger(0);        final Semaphore semaphore = new Semaphore(0);        RetryPolicy policy = new RetryPolicy() {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                semaphore.release();                if (retries.incrementAndGet() == MAX_RETRIES) {                    try {                        server.restart();                    } catch (Exception e) {                        throw new Error(e);                    }                }                try {                    sleeper.sleepFor(100, TimeUnit.MILLISECONDS);                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return true;            }        };        client.getZookeeperClient().setRetryPolicy(policy);        server.stop();                client.checkExists().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());                client.getZookeeperClient().setRetryPolicy(new RetryOneTime(100));        client.checkExists().forPath("/hey");        client.getZookeeperClient().setRetryPolicy(policy);        semaphore.drainPermits();        retries.set(0);        server.stop();                client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    semaphore.release();    if (retries.incrementAndGet() == MAX_RETRIES) {        try {            server.restart();        } catch (Exception e) {            throw new Error(e);        }    }    try {        sleeper.sleepFor(100, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return true;}
0
public void testNotStarted() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.getData();        Assert.fail();    } catch (Exception e) {        } catch (Throwable e) {        Assert.fail("", e);    }}
0
public void testStopped() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getData();    } finally {        CloseableUtils.closeQuietly(client);    }    try {        client.getData();        Assert.fail();    } catch (Exception e) {        }}
0
public void testDeleteChildrenConcurrently() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        client2.start();        client2.getZookeeperClient().blockUntilConnectedOrTimedOut();        int childCount = 5000;        for (int i = 0; i < childCount; i++) {            client.create().creatingParentsIfNeeded().forPath("/parent/child" + i);        }        final CountDownLatch latch = new CountDownLatch(1);        new Thread(new Runnable() {            @Override            public void run() {                long start = System.currentTimeMillis();                try {                    client.delete().deletingChildrenIfNeeded().forPath("/parent");                } catch (Exception e) {                    if (e instanceof KeeperException.NoNodeException) {                        Assert.fail("client delete failed, shouldn't throw NoNodeException", e);                    } else {                        Assert.fail("unexpected exception", e);                    }                } finally {                                        latch.countDown();                }            }        }).start();        boolean threadDeleted = false;        boolean client2Deleted = false;        Random random = new Random();        for (int i = 0; i < childCount; i++) {            String child = "/parent/child" + random.nextInt(childCount);            try {                if (!threadDeleted) {                    Stat stat = client2.checkExists().forPath(child);                    if (stat == null) {                                                threadDeleted = true;                                            }                } else {                    try {                        client2.delete().forPath(child);                        client2Deleted = true;                                                break;                    } catch (Exception e) {                        if (e instanceof KeeperException.NoNodeException) {                                                } else {                            Assert.fail("unexpected exception", e);                        }                    }                }            } catch (Exception e) {                Assert.fail("unexpected exception", e);            }        }                Assert.assertTrue(client2Deleted);        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertNull(client2.checkExists().forPath("/parent"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(client2);    }}
1
public void run()
{    long start = System.currentTimeMillis();    try {        client.delete().deletingChildrenIfNeeded().forPath("/parent");    } catch (Exception e) {        if (e instanceof KeeperException.NoNodeException) {            Assert.fail("client delete failed, shouldn't throw NoNodeException", e);        } else {            Assert.fail("unexpected exception", e);        }    } finally {                latch.countDown();    }}
1
public void testSimple() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] data = "Hello, world!".getBytes();    byte[] compressedData = provider.compress(null, data);    byte[] jdkCompressedData = jdkCompress(data);    Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertTrue(Arrays.equals(decompressedData, data));}
0
public void testEmpty() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] compressedData = provider.compress(null, new byte[0]);    byte[] compressedData2 = GzipCompressionProvider.doCompress(new byte[0]);    byte[] jdkCompress = jdkCompress(new byte[0]);        Assert.assertTrue(Arrays.equals(compressedData, compressedData2));    Assert.assertTrue(Arrays.equals(compressedData, jdkCompress));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertEquals(0, decompressedData.length);}
0
public void testDecompressCorrupt()
{    GzipCompressionProvider provider = new GzipCompressionProvider();    try {        provider.decompress(null, new byte[100]);        Assert.fail("Expected IOException");    } catch (IOException ignore) {        }    byte[] compressedData = provider.compress(null, new byte[0]);    for (int i = 0; i < compressedData.length; i++) {        try {            provider.decompress(null, Arrays.copyOf(compressedData, i));        } catch (IOException ignore) {                }        for (int change = 1; change < 256; change++) {            byte b = compressedData[i];            compressedData[i] = (byte) (b + change);            try {                provider.decompress(null, compressedData);                        } catch (IOException ignore) {                        }                        compressedData[i] = b;        }    }}
0
public void smokeTestRandomDataWithJdk() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    ThreadLocalRandom random = ThreadLocalRandom.current();    for (int len = 1; len < 100; len++) {        byte[] data = new byte[len];        for (int i = 0; i < 100; i++) {            byte[] compressedData = provider.compress(null, data);            byte[] jdkCompressedData = jdkCompress(data);            Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));            byte[] decompressedData = provider.decompress(null, compressedData);            Assert.assertTrue(Arrays.equals(decompressedData, data));                        random.nextBytes(data);        }    }}
0
private static byte[] jdkCompress(byte[] data) throws IOException
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    try (GZIPOutputStream out = new GZIPOutputStream(bytes)) {        out.write(data);        out.finish();    }    return bytes.toByteArray();}
0
public void testNotify() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client1.start();        client2.start();        final CountDownLatch latch = new CountDownLatch(1);        client1.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        if (event.getPath().equals("/test")) {                            latch.countDown();                        }                    }                }            }        });        client1.create().forPath("/test", new byte[] { 1, 2, 3 });        client1.checkExists().watched().forPath("/test");        client2.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    client.setData().forPath("/test", new byte[] { 10, 20 });                }            }        });        client2.sync().forPath("/test");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/test")) {                latch.countDown();            }        }    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        client.setData().forPath("/test", new byte[] { 10, 20 });    }}
0
public void testInvalid() throws Exception
{    try {        CuratorFrameworkFactory.builder().namespace("/snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();        Assert.fail();    } catch (IllegalArgumentException e) {        }}
0
public void testGetNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.builder().namespace("snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        Assert.assertEquals(client.getNamespace(), "");        Assert.assertEquals(client2.getNamespace(), "snafu");        Assert.assertEquals(fooClient.getNamespace(), "foo");        Assert.assertEquals(barClient.getNamespace(), "bar");    } finally {        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
0
public void testSimultaneous() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        fooClient.create().forPath("/one");        barClient.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/foo/one", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/bar/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCache() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertSame(client.usingNamespace("foo"), client.usingNamespace("foo"));        Assert.assertNotSame(client.usingNamespace("foo"), client.usingNamespace("bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        client.usingNamespace("space").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/space", false));        client.usingNamespace("name").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRootAccess() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        Assert.assertNotNull(client.checkExists().forPath("/"));        try {            client.checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }        Assert.assertNotNull(client.usingNamespace("one").checkExists().forPath("/"));        try {            client.usingNamespace("one").checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testIsStarted() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    CuratorFramework namespaced = client.usingNamespace(null);    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to start.");    client.close();    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to close.");}
0
public void testACL() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    client.getZookeeperClient().blockUntilConnectedOrTimedOut();    client.create().creatingParentsIfNeeded().forPath("/parent/child", "A string".getBytes());    CuratorFramework client2 = client.usingNamespace("parent");    Assert.assertNotNull(client2.getData().forPath("/child"));    client.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/parent/child");        try {        List<ACL> acls = client2.getACL().forPath("/child");        Assert.assertNotNull(acls);        Assert.assertEquals(acls.size(), 1);        Assert.assertEquals(acls.get(0).getId(), ZooDefs.Ids.ANYONE_ID_UNSAFE);        Assert.assertEquals(acls.get(0).getPerms(), ZooDefs.Perms.WRITE);        client2.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/child");        Assert.fail("Expected auth exception was not thrown");    } catch (NoAuthException e) {        }}
0
public void testUnfixForEmptyNamespace()
{    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    CuratorFrameworkImpl clientImpl = (CuratorFrameworkImpl) client;    Assert.assertEquals(clientImpl.unfixForNamespace("/foo/bar"), "/foo/bar");    CloseableUtils.closeQuietly(client);}
0
public void testNeverConnected() throws Exception
{    Timing timing = new Timing();        CuratorFramework client = CuratorFrameworkFactory.newClient("localhost:1111", 100, 100, new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState state) {                queue.add(state);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        client.create().inBackground().forPath("/");        ConnectionState polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.SUSPENDED);        polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState state)
{    queue.add(state);}
0
public void setup()
{    System.setProperty("readonlymode.enabled", "true");}
0
public void tearDown()
{    System.setProperty("readonlymode.enabled", "false");}
0
public void testConnectionStateNewClient() throws Exception
{    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    CuratorFramework client = null;    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));        client.start();        client.checkExists().forPath("/");        client.close();        client = null;        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        for (int i = 0; i < 2; ++i) {            cluster.killServer(iterator.next());        }        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryNTimes(3, timing.milliseconds())).canBeReadOnly(true).build();        final BlockingQueue<ConnectionState> states = Queues.newLinkedBlockingQueue();        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState);            }        });        client.start();        client.checkExists().forPath("/");        ConnectionState state = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertEquals(state, ConnectionState.READ_ONLY);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
0
public void testReadOnly() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(2);    try {        cluster.start();        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).canBeReadOnly(true).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();        client.start();        client.create().forPath("/test");        final CountDownLatch readOnlyLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.READ_ONLY) {                    readOnlyLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        InstanceSpec ourInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        InstanceSpec killInstance = iterator.next();        if (killInstance.equals(ourInstance)) {                        killInstance = iterator.next();        }        cluster.killServer(killInstance);        Assert.assertEquals(reconnectedLatch.getCount(), 1);        Assert.assertTrue(timing.awaitLatch(readOnlyLatch));        Assert.assertEquals(reconnectedLatch.getCount(), 1);        cluster.restartServer(killInstance);        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.READ_ONLY) {        readOnlyLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
public void setup() throws Exception
{    super.setup();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", superUserPasswordDigest);    CloseableUtils.closeQuietly(server);    server = null;    cluster = new TestingCluster(3);    cluster.start();}
0
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(cluster);    ensembleProvider = null;    System.clearProperty("zookeeper.DigestAuthenticationProvider.superDigest");    super.teardown();}
0
public void testApiPermutations() throws Exception
{        Watcher watcher = null;    Stat stat = null;    CuratorFramework client = null;    client.getConfig().forEnsemble();    client.getConfig().inBackground().forEnsemble();    client.getConfig().usingWatcher(watcher).forEnsemble();    client.getConfig().usingWatcher(watcher).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).forEnsemble();    client.getConfig().storingStatIn(stat).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).inBackground().forEnsemble();        client.reconfig().leaving().forEnsemble();    client.reconfig().joining().forEnsemble();    client.reconfig().leaving().joining().forEnsemble();    client.reconfig().joining().leaving().forEnsemble();    client.reconfig().withNewMembers().forEnsemble();    client.reconfig().leaving().fromConfig(0).forEnsemble();    client.reconfig().joining().fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().joining().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().forEnsemble();    client.reconfig().inBackground().joining().forEnsemble();    client.reconfig().inBackground().leaving().joining().forEnsemble();    client.reconfig().inBackground().joining().leaving().forEnsemble();    client.reconfig().inBackground().withNewMembers().forEnsemble();    client.reconfig().inBackground().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();}
0
public void testBasicGetConfig() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        byte[] configData = client.getConfig().forEnsemble();        QuorumVerifier quorumVerifier = toQuorumVerifier(configData);        System.out.println(quorumVerifier);        assertConfig(quorumVerifier, cluster.getInstances());        Assert.assertEquals(EnsembleTracker.configToConnectionString(quorumVerifier), ensembleProvider.getConnectionString());    }}
0
public void testAdd() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            client.reconfig().joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
0
public void testAddAsync() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            final CountDownLatch callbackLatch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    if (event.getType() == CuratorEventType.RECONFIG) {                        callbackLatch.countDown();                    }                }            };            client.reconfig().inBackground(callback).joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(callbackLatch));            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.RECONFIG) {        callbackLatch.countDown();    }}
0
public void testAddAndRemove() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            Collection<InstanceSpec> oldInstances = cluster.getInstances();            InstanceSpec us = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());            InstanceSpec removeSpec = oldInstances.iterator().next();            if (us.equals(removeSpec)) {                Iterator<InstanceSpec> iterator = oldInstances.iterator();                iterator.next();                removeSpec = iterator.next();            }            Collection<InstanceSpec> instances = newCluster.getInstances();            client.reconfig().leaving(Integer.toString(removeSpec.getServerId())).joining(toReconfigSpec(instances)).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            ArrayList<InstanceSpec> newInstances = Lists.newArrayList(oldInstances);            newInstances.addAll(instances);            newInstances.remove(removeSpec);            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
0
public void testNewMembers() throws Exception
{    cluster.close();    cluster = null;    TestingCluster smallCluster = null;    TestingCluster localCluster = new TestingCluster(5);    try {        List<TestingZooKeeperServer> servers = localCluster.getServers();        List<InstanceSpec> smallClusterInstances = Lists.newArrayList();        for (        int i = 0;         i < 3;         ++i) {            TestingZooKeeperServer server = servers.get(i);            server.start();            smallClusterInstances.add(server.getInstanceSpec());        }        smallCluster = new TestingCluster(smallClusterInstances);        try (CuratorFramework client = newClient(smallCluster.getConnectString())) {            client.start();            QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());            Assert.assertEquals(oldConfig.getAllMembers().size(), 5);            assertConfig(oldConfig, localCluster.getInstances());            CountDownLatch latch = setChangeWaiter(client);            client.reconfig().withNewMembers(toReconfigSpec(smallClusterInstances)).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            Assert.assertEquals(newConfig.getAllMembers().size(), 3);            assertConfig(newConfig, smallClusterInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    } finally {        CloseableUtils.closeQuietly(smallCluster);        CloseableUtils.closeQuietly(localCluster);    }}
0
public void testConfigToConnectionStringIPv4Normal() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;10.2.3.4:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.2.3.4:2181", configString);}
0
public void testConfigToConnectionStringIPv6Normal() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[2001:db8:85a3:0:0:8a2e:370:7334]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
0
public void testConfigToConnectionStringIPv4NoClientAddr() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
0
public void testConfigToConnectionStringIPv4WildcardClientAddr() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;0.0.0.0:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
0
public void testConfigToConnectionStringNoClientAddrOrPort() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("", configString);}
0
public void testIPv6Wildcard1() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
0
public void testIPv6Wildcard2() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[::0]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("1010:1:2:3:4:5:6:7:2181", configString);}
0
public void testMixedIPv1() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
0
public void testMixedIPv2() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;127.0.0.1:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("127.0.0.1:2181", configString);}
0
private CuratorFramework newClient()
{    return newClient(cluster.getConnectString());}
0
private CuratorFramework newClient(String connectionString)
{    final AtomicReference<String> connectString = new AtomicReference<>(connectionString);    ensembleProvider = new EnsembleProvider() {        @Override        public void start() throws Exception {        }        @Override        public boolean updateServerListEnabled() {            return false;        }        @Override        public String getConnectionString() {            return connectString.get();        }        @Override        public void close() throws IOException {        }        @Override        public void setConnectionString(String connectionString) {            connectString.set(connectionString);        }    };    return CuratorFrameworkFactory.builder().ensembleProvider(ensembleProvider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", superUserPassword.getBytes()).retryPolicy(new ExponentialBackoffRetry(timing.forSleepingABit().milliseconds(), 3)).build();}
0
public void start() throws Exception
{}
0
public boolean updateServerListEnabled()
{    return false;}
0
public String getConnectionString()
{    return connectString.get();}
0
public void close() throws IOException
{}
0
public void setConnectionString(String connectionString)
{    connectString.set(connectionString);}
0
private CountDownLatch setChangeWaiter(CuratorFramework client) throws Exception
{    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.NodeDataChanged) {                latch.countDown();            }        }    };    client.getConfig().usingWatcher(watcher).forEnsemble();    return latch;}
0
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeDataChanged) {        latch.countDown();    }}
0
private void assertConfig(QuorumVerifier config, Collection<InstanceSpec> instances)
{    for (InstanceSpec instance : instances) {        QuorumPeer.QuorumServer quorumServer = config.getAllMembers().get((long) instance.getServerId());        Assert.assertNotNull(quorumServer, String.format("Looking for %s - found %s", instance.getServerId(), config.getAllMembers()));        Assert.assertEquals(quorumServer.clientAddr.getPort(), instance.getPort());    }}
0
private List<String> toReconfigSpec(Collection<InstanceSpec> instances) throws Exception
{    String localhost = new InetSocketAddress((InetAddress) null, 0).getAddress().getHostAddress();    List<String> specs = Lists.newArrayList();    for (InstanceSpec instance : instances) {        specs.add("server." + instance.getServerId() + "=" + localhost + ":" + instance.getElectionPort() + ":" + instance.getQuorumPort() + ";" + instance.getPort());    }    return specs;}
0
private static QuorumVerifier toQuorumVerifier(byte[] bytes) throws Exception
{    Assert.assertNotNull(bytes);    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(bytes));    return new QuorumMaj(properties);}
0
private AtomicReference<ConnectionState> registerConnectionStateListener(CuratorFramework client)
{    final AtomicReference<ConnectionState> state = new AtomicReference<ConnectionState>();    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            state.set(newState);            synchronized (state) {                state.notify();            }        }    });    return state;}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    state.set(newState);    synchronized (state) {        state.notify();    }}
0
private boolean blockUntilDesiredConnectionState(AtomicReference<ConnectionState> stateRef, Timing timing, final ConnectionState desiredState)
{    if (stateRef.get() == desiredState) {        return true;    }        synchronized (stateRef) {        if (stateRef.get() == desiredState) {            return true;        }        try {            stateRef.wait(timing.milliseconds());            return stateRef.get() == desiredState;        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }    }}
0
public void testRemoveCuratorDefaultWatcher() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        });        client.checkExists().watched().forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
0
public void testRemoveCuratorWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        CuratorWatcher watcher = new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void process(WatchedEvent event) throws Exception
{    if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
0
public void testRemoveWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveWatchInBackgroundWithCallback() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();                final CountDownLatch removedLatch = new CountDownLatch(2);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).ofType(WatcherType.Any).inBackground(callback).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {        removedLatch.countDown();    }}
0
public void testRemoveWatchInBackgroundWithNoCallback() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveAllWatches() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(2);        Watcher watcher1 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveAllDataWatches() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Data).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveAllChildWatches() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.DataWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        client.checkExists().usingWatcher(watcher1).forPath(path);        client.getChildren().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Children).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveLocalWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveLocalWatchInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveUnregisteredWatcher() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {            }        };        try {            client.watches().remove(watcher).forPath(path);            Assert.fail("Expected KeeperException.NoWatcherException");        } catch (KeeperException.NoWatcherException expected) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testRemoveUnregisteredWatcherQuietly() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final AtomicBoolean watcherRemoved = new AtomicBoolean(false);        final String path = "/";        Watcher watcher = new BooleanWatcher(path, watcherRemoved, EventType.DataWatchRemoved);        client.watches().remove(watcher).quietly().forPath(path);        timing.sleepABit();                Assert.assertEquals(watcherRemoved.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGuaranteedRemoveWatch() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                try {            client.watches().remove(watcher).guaranteed().forPath(path);            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGuaranteedRemoveWatchInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final CountDownLatch guaranteeAddedLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).getFailedRemoveWatcherManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<FailedRemoveWatchManager.FailedRemoveWatchDetails>() {            @Override            public void pathAddedForGuaranteedOperation(FailedRemoveWatchDetails detail) {                guaranteeAddedLatch.countDown();            }        };        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                client.watches().remove(watcher).guaranteed().inBackground().forPath(path);        timing.awaitLatch(guaranteeAddedLatch);        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void pathAddedForGuaranteedOperation(FailedRemoveWatchDetails detail)
{    guaranteeAddedLatch.countDown();}
0
public void process(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removeLatch.countDown();    }}
0
public void process(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removedFlag.set(true);    }}
0
public void testBasic() throws Exception
{    CuratorTempFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp();    try {        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        byte[] bytes = client.getData().forPath("/foo");        Assert.assertEquals(bytes, "data".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testInactivity() throws Exception
{    final CuratorTempFrameworkImpl client = (CuratorTempFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp(1, TimeUnit.SECONDS);    try {        ScheduledExecutorService service = Executors.newScheduledThreadPool(1);        Runnable command = new Runnable() {            @Override            public void run() {                client.updateLastAccess();            }        };        service.scheduleAtFixedRate(command, 10, 10, TimeUnit.MILLISECONDS);        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        service.shutdownNow();        Thread.sleep(2000);        Assert.assertNull(client.getCleanup());        Assert.assertNull(client.getClient());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void run()
{    client.updateLastAccess();}
0
public void testErrors() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/bar");        CuratorOp createOp2 = client.transactionOp().create().forPath("/z/blue");        final BlockingQueue<CuratorEvent> callbackQueue = new LinkedBlockingQueue<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                callbackQueue.add(event);            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        CuratorEvent event = callbackQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertNotNull(event.getOpResults());        Assert.assertEquals(event.getOpResults().size(), 2);        Assert.assertEquals(event.getOpResults().get(0).getError(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getOpResults().get(1).getError(), KeeperException.Code.NONODE.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    callbackQueue.add(event);}
0
public void testCheckVersion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        CuratorOp statOp = client.transactionOp().check().withVersion(stat.getVersion() + 1).forPath("/foo");        CuratorOp createOp = client.transactionOp().create().forPath("/bar");        try {            client.transaction().forOperations(statOp, createOp);            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
0
public void testBackgroundWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
0
public void testCheckVersion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        try {            client.inTransaction().check().withVersion(stat.getVersion() + 1).forPath(            "/foo").and().create().forPath("/bar").and().commit();            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo", "one".getBytes()).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes()).and().setData().forPath("/foo", "two".getBytes()).and().create().forPath("/foo/bar").and().delete().forPath("/foo/bar").and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testWithCompression() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    client.start();    try {        Collection<CuratorTransactionResult> results = client.inTransaction().create().compressed().forPath("/foo", "one".getBytes()).and().create().compressed().withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/bar", "two".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "three".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT).withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/baz", "four".getBytes()).and().setData().compressed().withVersion(0).forPath("/foo", "five".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/foo"), "five".getBytes());        Assert.assertTrue(client.checkExists().forPath("/bar") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/bar"), "two".getBytes());        Assert.assertEquals(client.getACL().forPath("/bar"), ZooDefs.Ids.READ_ACL_UNSAFE);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));        Assert.assertTrue(client.checkExists().forPath("/baz") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/baz"), "four".getBytes());        Assert.assertEquals(client.getACL().forPath("/baz"), ZooDefs.Ids.READ_ACL_UNSAFE);    } finally {        client.close();    }}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo").and().create().forPath("/foo/bar", "snafu".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
0
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
0
public void teardown() throws Exception
{    super.teardown();    System.clearProperty("znode.container.checkIntervalMs");}
0
public void testBasic() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).forPath("/a/b/c");        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
0
public void testBasicInBackground() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).inBackground(callback).forPath("/a/b/c");        Assert.assertTrue(new Timing().awaitLatch(latch));        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void process(WatchedEvent event) throws Exception
{    count.incrementAndGet();}
0
public void process(WatchedEvent event)
{    count.incrementAndGet();}
0
public void testSameWatcherPerZKDocs() throws Exception
{    CountZKWatcher actualWatcher = new CountZKWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSameCuratorWatcherPerZKDocs() throws Exception
{    CountCuratorWatcher actualWatcher = new CountCuratorWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSetAddition()
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {        }    };    NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, "/foo");    NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, "/foo");    Assert.assertEquals(namespaceWatcher1, namespaceWatcher2);    Assert.assertFalse(namespaceWatcher1.equals(watcher));    Assert.assertFalse(watcher.equals(namespaceWatcher1));    Set<Watcher> set = Sets.newHashSet();    set.add(namespaceWatcher1);    set.add(namespaceWatcher2);    Assert.assertEquals(set.size(), 1);}
0
public void process(WatchedEvent event)
{}
0
public void testCuratorWatcher() throws Exception
{    Timing timing = new Timing();    CountCuratorWatcher watcher = new CountCuratorWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testZKWatcher() throws Exception
{    Timing timing = new Timing();    CountZKWatcher watcher = new CountZKWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSameWatcherDifferentPaths1Triggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        removerClient.create().creatingParentsIfNeeded().forPath("/d/e/f");        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{    latch.countDown();}
0
public void testSameWatcherDifferentPaths() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 2);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testSameWatcherDifferentKinds1Triggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.setData().forPath("/a/b/c", "new".getBytes());        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{    latch.countDown();}
0
public void testSameWatcherDifferentKinds() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testWithRetry() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.checkExists().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown ConnectionLossException");        } catch (KeeperException.ConnectionLossException expected) {                }        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testWithRetryInBackground() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(w).inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testMissingNode() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.getData().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown NoNodeException");        } catch (KeeperException.NoNodeException expected) {                }        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testMissingNodeInBackground() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Callable<Void> proc = new Callable<Void>() {        @Override        public Void call() throws Exception {            client.start();            WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();            Watcher w = new Watcher() {                @Override                public void process(WatchedEvent event) {                                }            };            final CountDownLatch latch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    latch.countDown();                }            };            removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");            Assert.assertTrue(new Timing().awaitLatch(latch));            Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);            removerClient.removeWatchers();            return null;        }    };    TestCleanState.test(client, proc);}
0
public Void call() throws Exception
{    client.start();    WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();    Watcher w = new Watcher() {        @Override        public void process(WatchedEvent event) {                }    };    final CountDownLatch latch = new CountDownLatch(1);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            latch.countDown();        }    };    removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");    Assert.assertTrue(new Timing().awaitLatch(latch));    Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    removerClient.removeWatchers();    return null;}
0
public void process(WatchedEvent event)
{}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testBasicNamespace1() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client.usingNamespace("foo"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testBasicNamespace2() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testBasicNamespace3() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client.usingNamespace("lakjsf"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testSameWatcher() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{}
0
public void testTriggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    latch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        latch.countDown();    }}
0
public void testResetFromWatcher() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch createdLatch = new CountDownLatch(1);        final CountDownLatch deletedLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    try {                        removerClient.checkExists().usingWatcher(this).forPath("/yo");                    } catch (Exception e) {                        e.printStackTrace();                    }                    createdLatch.countDown();                } else if (event.getType() == Event.EventType.NodeDeleted) {                    deletedLatch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(createdLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.delete().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(deletedLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        try {            removerClient.checkExists().usingWatcher(this).forPath("/yo");        } catch (Exception e) {            e.printStackTrace();        }        createdLatch.countDown();    } else if (event.getType() == Event.EventType.NodeDeleted) {        deletedLatch.countDown();    }}
0
private void internalTryBasic(CuratorFramework client) throws Exception
{    WatcherRemoveCuratorFramework removerClient = client.newWatcherRemoveCuratorFramework();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.DataWatchRemoved) {                latch.countDown();            }        }    };    removerClient.checkExists().usingWatcher(watcher).forPath("/hey");    List<String> existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 1);    removerClient.removeWatchers();    Assert.assertTrue(new Timing().awaitLatch(latch));    existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 0);}
0
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.DataWatchRemoved) {        latch.countDown();    }}
0
public void testSessionSurvives() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        client.start();        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                    ;                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/temp", "value".getBytes());        Assert.assertNotNull(client.checkExists().forPath("/temp"));        for (InstanceSpec spec : cluster.getInstances()) {            cluster.killServer(spec);            timing.sleepABit();            cluster.restartServer(spec);            timing.sleepABit();        }        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertNotNull(client.checkExists().forPath("/temp"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();        ;    }}
0
public void testSplitBrain() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {                for (InstanceSpec instanceSpec : cluster.getInstances()) {            client = CuratorFrameworkFactory.newClient(instanceSpec.getConnectString(), new RetryOneTime(1));            client.start();            client.checkExists().forPath("/");            client.close();            client = null;        }        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final CountDownLatch latch = new CountDownLatch(2);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/");        for (InstanceSpec instanceSpec : cluster.getInstances()) {            if (!instanceSpec.equals(cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper()))) {                Assert.assertTrue(cluster.killServer(instanceSpec));            }        }        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        latch.countDown();    }}
0
public void testBasics() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema1.json", null);    Schema schema = schemaSet.getNamedSchema("test");    Assert.assertNotNull(schema);    Map<String, String> expectedMetadata = Maps.newHashMap();    expectedMetadata.put("one", "1");    expectedMetadata.put("two", "2");    Assert.assertEquals(schema.getMetadata(), expectedMetadata);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            String rawPath = schema.getRawPath();            Assert.assertEquals(rawPath, "/a/b/c");            client.create().creatingParentsIfNeeded().forPath(rawPath);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSchemaValidator() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema3.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().forPath("/test", new byte[0]);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().forPath("/test", "good".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
0
public SchemaValidator getSchemaValidator(String name)
{    return schemaValidator;}
0
public void testMulti() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema2.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().forPath("/a/b/c");            Assert.fail("Should've violated schema: test");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c/d/e");            Assert.fail("Should've violated schema: test2");        } catch (SchemaViolation dummy) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testTransaction() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema4.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        CuratorOp createAPersistent = client.transactionOp().create().forPath("/a");        CuratorOp createAEphemeral = client.transactionOp().create().withMode(CreateMode.EPHEMERAL).forPath("/a");        CuratorOp deleteA = client.transactionOp().delete().forPath("/a");        CuratorOp createBEmptyData = client.transactionOp().create().forPath("/b", new byte[0]);        CuratorOp createBWithData = client.transactionOp().create().forPath("/b", new byte[10]);        CuratorOp setBEmptyData = client.transactionOp().setData().forPath("/b", new byte[0]);        CuratorOp setBWithData = client.transactionOp().setData().forPath("/b", new byte[10]);        try {            client.transaction().forOperations(createAPersistent, createAEphemeral);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createAEphemeral);        try {            client.transaction().forOperations(deleteA);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.transaction().forOperations(createBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createBWithData);        try {            client.transaction().forOperations(setBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(setBWithData);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
0
public SchemaValidator getSchemaValidator(String name)
{    return schemaValidator;}
0
public void testYaml() throws Exception
{    String yaml = Resources.toString(Resources.getResource("schema.yaml"), Charsets.UTF_8);    JsonNode root = new ObjectMapper(new YAMLFactory()).readTree(yaml);    List<Schema> schemas = new SchemaSetLoader(root, null).getSchemas();    Assert.assertEquals(schemas.size(), 2);    Assert.assertEquals(schemas.get(0).getName(), "test");    Assert.assertEquals(schemas.get(0).getMetadata().size(), 0);    Assert.assertEquals(schemas.get(1).getName(), "test2");    Assert.assertEquals(schemas.get(1).getMetadata().size(), 2);    Assert.assertEquals(schemas.get(1).getMetadata().get("two"), "2");}
0
public void testOrdering() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema5.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/match");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/foo/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/other/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }                client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/match");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/other/thing");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
private CuratorFramework newClient(SchemaSet schemaSet)
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();}
0
private SchemaSet loadSchemaSet(String name, SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper) throws IOException
{    String json = Resources.toString(Resources.getResource(name), Charsets.UTF_8);    return new SchemaSetLoader(json, schemaValidatorMapper).toSchemaSet(true);}
0
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)
{    lastDelay[0] = Duration.of(unit.toNanos(delay), ChronoUnit.NANOS);    command.run();    return null;}
0
public void tearDown()
{    service.shutdownNow();}
0
public void testBasic()
{    final int retryQty = 1;    final Duration delay = Duration.ofSeconds(10);    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryNTimes(retryQty, (int) delay.toMillis()), service);    AtomicInteger counter = new AtomicInteger(0);    Assert.assertTrue(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(lastDelay[0], delay);    Assert.assertFalse(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertFalse(circuitBreaker.tryToRetry(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertTrue(circuitBreaker.close());    Assert.assertEquals(circuitBreaker.getRetryCount(), 0);    Assert.assertFalse(circuitBreaker.close());}
0
public void testVariousOpenRetryFails()
{    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryForever(1), service);    Assert.assertFalse(circuitBreaker.tryToRetry(() -> {    }));    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertFalse(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertTrue(circuitBreaker.close());    Assert.assertFalse(circuitBreaker.close());}
0
public void testWithRetryUntilElapsed()
{    RetryPolicy retryPolicy = new RetryUntilElapsed(10000, 10000);    CircuitBreaker circuitBreaker = CircuitBreaker.build(retryPolicy, service);    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertEquals(lastDelay[0], Duration.ofMillis(10000));}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    stateChanges.offer(newState);}
0
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return isRetrying && super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
0
public void setup()
{    service = new ScheduledThreadPoolExecutor(1);}
0
public void tearDown()
{    service.shutdownNow();}
0
public void testBasic() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    synchronized (    listener) {                listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);                listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);                listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    }    retryTiming.multiple(2).sleep();    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        retryPolicy.isRetrying = false;    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);}
0
public void testResetsAfterReconnect() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.LOST);    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);}
0
public void testRetryNever() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryNever = (retryCount, elapsedTimeMs, sleeper) -> false;    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryNever, service);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());}
0
public void testRetryOnce() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryOnce = new RetryOneTime(retryTiming.milliseconds());    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryOnce, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);        Assert.assertTrue(listener.isOpen());    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    Assert.assertFalse(listener.isOpen());}
0
public void testSuspendedToLostRatcheting() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryInfinite = new RetryForever(Integer.MAX_VALUE);    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryInfinite, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertFalse(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());}
0
public void testSessionConnectionStateErrorPolicyWithExpirationPercent30() throws Exception
{    Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).connectionHandlingPolicy(new StandardConnectionHandlingPolicy(30)).build();        final int lostStateExpectedMs = (timing.session() / 3) + timing.forSleepingABit().milliseconds();    try {        CountDownLatch connectedLatch = new CountDownLatch(1);        CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        timing.sleepABit();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.close();        Assert.assertTrue(lostLatch.await(lostStateExpectedMs, TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
0
public static Future<?> execute(final CuratorFramework client, final Runnable runAfterConnection) throws Exception
{        final ExecutorService executor = ThreadUtils.newSingleThreadExecutor(ThreadUtils.getProcessName(runAfterConnection.getClass()));    Runnable internalCall = new Runnable() {        @Override        public void run() {            try {                client.blockUntilConnected();                runAfterConnection.run();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            } finally {                executor.shutdown();            }        }    };    return executor.submit(internalCall);}
1
public void run()
{    try {        client.blockUntilConnected();        runAfterConnection.run();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            } finally {        executor.shutdown();    }}
1
public int getOptimisticTries()
{    return optimisticTries;}
0
public int getPromotedLockTries()
{    return promotedLockTries;}
0
public long getOptimisticTimeMs()
{    return optimisticTimeMs;}
0
public long getPromotedTimeMs()
{    return promotedTimeMs;}
0
 void incrementOptimisticTries()
{    ++optimisticTries;}
0
 void incrementPromotedTries()
{    ++promotedLockTries;}
0
 void setOptimisticTimeMs(long optimisticTimeMs)
{    this.optimisticTimeMs = optimisticTimeMs;}
0
 void setPromotedTimeMs(long promotedTimeMs)
{    this.promotedTimeMs = promotedTimeMs;}
0
public AtomicValue<Integer> next() throws Exception
{    MutableAtomicValue<Integer> result = new MutableAtomicValue<Integer>(0, 0);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
0
public AtomicValue<Long> next() throws Exception
{    MutableAtomicValue<Long> result = new MutableAtomicValue<Long>(0L, 0L);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
0
public AtomicValue<Integer> get() throws Exception
{    return new AtomicInteger(value.get());}
0
public void forceSet(Integer newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
0
public AtomicValue<Integer> compareAndSet(Integer expectedValue, Integer newValue) throws Exception
{    return new AtomicInteger(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
0
public AtomicValue<Integer> trySet(Integer newValue) throws Exception
{    return new AtomicInteger(value.trySet(valueToBytes(newValue)));}
0
public boolean initialize(Integer initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
0
public AtomicValue<Integer> increment() throws Exception
{    return worker(1);}
0
public AtomicValue<Integer> decrement() throws Exception
{    return worker(-1);}
0
public AtomicValue<Integer> add(Integer delta) throws Exception
{    return worker(delta);}
0
public AtomicValue<Integer> subtract(Integer delta) throws Exception
{    return worker(-1 * delta);}
0
 byte[] valueToBytes(Integer newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[4];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putInt(newValue);    return newData;}
0
 int bytesToValue(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getInt();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
0
private AtomicValue<Integer> worker(final Integer addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            int previousValue = (previous != null) ? bytesToValue(previous) : 0;            int newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicInteger(result);}
0
public byte[] makeFrom(byte[] previous)
{    int previousValue = (previous != null) ? bytesToValue(previous) : 0;    int newValue = previousValue + addAmount;    return valueToBytes(newValue);}
0
public boolean succeeded()
{    return bytes.succeeded();}
0
public Integer preValue()
{    return bytesToValue(bytes.preValue());}
0
public Integer postValue()
{    return bytesToValue(bytes.postValue());}
0
public AtomicStats getStats()
{    return bytes.getStats();}
0
public AtomicValue<Long> get() throws Exception
{    return new AtomicLong(value.get());}
0
public void forceSet(Long newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
0
public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception
{    return new AtomicLong(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
0
public AtomicValue<Long> trySet(Long newValue) throws Exception
{    return new AtomicLong(value.trySet(valueToBytes(newValue)));}
0
public boolean initialize(Long initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
0
public AtomicValue<Long> increment() throws Exception
{    return worker(1L);}
0
public AtomicValue<Long> decrement() throws Exception
{    return worker(-1L);}
0
public AtomicValue<Long> add(Long delta) throws Exception
{    return worker(delta);}
0
public AtomicValue<Long> subtract(Long delta) throws Exception
{    return worker(-1 * delta);}
0
 byte[] valueToBytes(Long newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[8];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putLong(newValue);    return newData;}
0
 long bytesToValue(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getLong();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
0
private AtomicValue<Long> worker(final Long addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            long previousValue = (previous != null) ? bytesToValue(previous) : 0;            long newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicLong(result);}
0
public byte[] makeFrom(byte[] previous)
{    long previousValue = (previous != null) ? bytesToValue(previous) : 0;    long newValue = previousValue + addAmount;    return valueToBytes(newValue);}
0
public boolean succeeded()
{    return bytes.succeeded();}
0
public Long preValue()
{    return bytesToValue(bytes.preValue());}
0
public Long postValue()
{    return bytesToValue(bytes.postValue());}
0
public AtomicStats getStats()
{    return bytes.getStats();}
0
public AtomicValue<byte[]> get() throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    getCurrentValue(result, new Stat());    result.postValue = result.preValue;    result.succeeded = true;    return result;}
0
public void forceSet(byte[] newValue) throws Exception
{    try {        client.setData().forPath(path, newValue);    } catch (KeeperException.NoNodeException dummy) {        try {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } catch (KeeperException.NodeExistsException dummy2) {            client.setData().forPath(path, newValue);        }    }}
0
public AtomicValue<byte[]> compareAndSet(byte[] expectedValue, byte[] newValue) throws Exception
{    Stat stat = new Stat();    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    boolean createIt = getCurrentValue(result, stat);    if (!createIt && Arrays.equals(expectedValue, result.preValue)) {        try {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);            result.succeeded = true;            result.postValue = newValue;        } catch (KeeperException.BadVersionException dummy) {            result.succeeded = false;        } catch (KeeperException.NoNodeException dummy) {            result.succeeded = false;        }    } else {        result.succeeded = false;    }    return result;}
0
public AtomicValue<byte[]> trySet(final byte[] newValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            return newValue;        }    };    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
0
public byte[] makeFrom(byte[] previous)
{    return newValue;}
0
public boolean initialize(byte[] value) throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(path, value);    } catch (KeeperException.NodeExistsException ignore) {                return false;    }    return true;}
0
 AtomicValue<byte[]> trySet(MakeValue makeValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
0
 RuntimeException createCorruptionException(byte[] bytes)
{    StringBuilder str = new StringBuilder();    str.append('[');    boolean first = true;    for (byte b : bytes) {        if (first) {            first = false;        } else {            str.append(", ");        }        str.append("0x").append(Integer.toHexString((b & 0xff)));    }    str.append(']');    return new RuntimeException(String.format("Corrupted data for node \"%s\": %s", path, str.toString()));}
0
private boolean getCurrentValue(MutableAtomicValue<byte[]> result, Stat stat) throws Exception
{    boolean createIt = false;    try {        result.preValue = client.getData().storingStatIn(stat).forPath(path);    } catch (KeeperException.NoNodeException e) {        result.preValue = null;        createIt = true;    }    return createIt;}
0
private void tryWithMutex(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    if (mutex.acquire(promotedToLock.getMaxLockTime(), promotedToLock.getMaxLockTimeUnit())) {        try {            boolean done = false;            while (!done) {                result.stats.incrementPromotedTries();                if (tryOnce(result, makeValue)) {                    result.succeeded = true;                    done = true;                } else {                    if (!promotedToLock.getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                        done = true;                    }                }            }        } finally {            mutex.release();        }    }    result.stats.setPromotedTimeMs(System.currentTimeMillis() - startMs);}
0
private void tryOptimistic(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    boolean done = false;    while (!done) {        result.stats.incrementOptimisticTries();        if (tryOnce(result, makeValue)) {            result.succeeded = true;            done = true;        } else {            if (!retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                done = true;            }        }    }    result.stats.setOptimisticTimeMs(System.currentTimeMillis() - startMs);}
0
private boolean tryOnce(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    Stat stat = new Stat();    boolean createIt = getCurrentValue(result, stat);    boolean success = false;    try {        byte[] newValue = makeValue.makeFrom(result.preValue);        if (createIt) {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } else {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);        }        result.postValue = Arrays.copyOf(newValue, newValue.length);        success = true;    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.BadVersionException e) {        } catch (KeeperException.NoNodeException e) {        }    return success;}
0
public T preValue()
{    return preValue;}
0
public T postValue()
{    return postValue;}
0
public boolean succeeded()
{    return succeeded;}
0
public AtomicStats getStats()
{    return stats;}
0
public static Builder builder()
{    return new Builder();}
0
public PromotedToLock build()
{    Preconditions.checkNotNull(instance.path, "path cannot be null");    Preconditions.checkNotNull(instance.retryPolicy, "retryPolicy cannot be null");    return new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);}
0
public Builder lockPath(String path)
{    instance = new PromotedToLock(PathUtils.validatePath(path), instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);    return this;}
0
public Builder retryPolicy(RetryPolicy retryPolicy)
{    instance = new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, retryPolicy);    return this;}
0
public Builder timeout(long maxLockTime, TimeUnit maxLockTimeUnit)
{    instance = new PromotedToLock(instance.path, maxLockTime, maxLockTimeUnit, instance.retryPolicy);    return this;}
0
 String getPath()
{    return path;}
0
 long getMaxLockTime()
{    return maxLockTime;}
0
 TimeUnit getMaxLockTimeUnit()
{    return maxLockTimeUnit;}
0
 RetryPolicy getRetryPolicy()
{    return retryPolicy;}
0
public void process(WatchedEvent event)
{    client.postSafeNotify(DistributedBarrier.this);}
0
public synchronized void setBarrier() throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(barrierPath);    } catch (KeeperException.NodeExistsException ignore) {        }}
0
public synchronized void removeBarrier() throws Exception
{    try {        client.delete().forPath(barrierPath);    } catch (KeeperException.NoNodeException ignore) {        }}
0
public synchronized void waitOnBarrier() throws Exception
{    waitOnBarrier(-1, null);}
0
public synchronized boolean waitOnBarrier(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean result;    for (; ; ) {        result = (client.checkExists().usingWatcher(watcher).forPath(barrierPath) == null);        if (result) {            break;        }        if (hasMaxWait) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return result;}
0
public void process(WatchedEvent event)
{    connectionLost.set(event.getState() != Event.KeeperState.SyncConnected);    client.runSafe(() -> {        synchronized (DistributedDoubleBarrier.this) {            hasBeenNotified.set(true);            DistributedDoubleBarrier.this.notifyAll();        }    });}
0
public void enter() throws Exception
{    enter(-1, null);}
0
public boolean enter(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean readyPathExists = (client.checkExists().usingWatcher(watcher).forPath(readyPath) != null);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(ourPath);    boolean result = (readyPathExists || internalEnter(startMs, hasMaxWait, maxWaitMs));    if (connectionLost.get()) {        throw new KeeperException.ConnectionLossException();    }    return result;}
0
public synchronized void leave() throws Exception
{    leave(-1, null);}
0
public synchronized boolean leave(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    return internalLeave(startMs, hasMaxWait, maxWaitMs);}
0
protected List<String> getChildrenForEntering() throws Exception
{    return client.getChildren().forPath(barrierPath);}
0
private List<String> filterAndSortChildren(List<String> children)
{    Iterable<String> filtered = Iterables.filter(children, new Predicate<String>() {        @Override        public boolean apply(String name) {            return !name.equals(READY_NODE);        }    });    ArrayList<String> filteredList = Lists.newArrayList(filtered);    Collections.sort(filteredList);    return filteredList;}
0
public boolean apply(String name)
{    return !name.equals(READY_NODE);}
0
private boolean internalLeave(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    String ourPathName = ZKPaths.getNodeFromPath(ourPath);    boolean ourNodeShouldExist = true;    boolean result = true;    for (; ; ) {        if (connectionLost.get()) {            throw new KeeperException.ConnectionLossException();        }        List<String> children;        try {            children = client.getChildren().forPath(barrierPath);        } catch (KeeperException.NoNodeException dummy) {            children = Lists.newArrayList();        }        children = filterAndSortChildren(children);        if ((children == null) || (children.size() == 0)) {            break;        }        int ourIndex = children.indexOf(ourPathName);        if ((ourIndex < 0) && ourNodeShouldExist) {            if (connectionLost.get()) {                                break;            } else {                throw new IllegalStateException(String.format("Our path (%s) is missing", ourPathName));            }        }        if (children.size() == 1) {            if (ourNodeShouldExist && !children.get(0).equals(ourPathName)) {                throw new IllegalStateException(String.format("Last path (%s) is not ours (%s)", children.get(0), ourPathName));            }            checkDeleteOurPath(ourNodeShouldExist);            break;        }        Stat stat;        boolean IsLowestNode = (ourIndex == 0);        if (IsLowestNode) {            String highestNodePath = ZKPaths.makePath(barrierPath, children.get(children.size() - 1));            stat = client.checkExists().usingWatcher(watcher).forPath(highestNodePath);        } else {            String lowestNodePath = ZKPaths.makePath(barrierPath, children.get(0));            stat = client.checkExists().usingWatcher(watcher).forPath(lowestNodePath);            checkDeleteOurPath(ourNodeShouldExist);            ourNodeShouldExist = false;        }        if (stat != null) {            if (hasMaxWait) {                long elapsed = System.currentTimeMillis() - startMs;                long thisWaitMs = maxWaitMs - elapsed;                if (thisWaitMs <= 0) {                    result = false;                    break;                } else {                    wait(thisWaitMs);                }            } else {                wait();            }        }    }    try {        client.delete().forPath(readyPath);    } catch (KeeperException.NoNodeException ignore) {        }    return result;}
0
private void checkDeleteOurPath(boolean shouldExist) throws Exception
{    if (shouldExist) {        client.delete().forPath(ourPath);    }}
0
private synchronized boolean internalEnter(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    boolean result = true;    do {        List<String> children = getChildrenForEntering();        int count = (children != null) ? children.size() : 0;        if (count >= memberQty) {            try {                client.create().forPath(readyPath);            } catch (KeeperException.NodeExistsException ignore) {                        }            break;        }        if (hasMaxWait && !hasBeenNotified.get()) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                result = false;            } else {                wait(thisWaitMs);            }            if (!hasBeenNotified.get()) {                result = false;            }        } else {            wait();        }    } while (false);    return result;}
0
public int compareTo(ChildData rhs)
{    if (this == rhs) {        return 0;    }    if (rhs == null || getClass() != rhs.getClass()) {        return -1;    }    return path.compareTo(rhs.path);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ChildData childData = (ChildData) o;    if (!Arrays.equals(data, childData.data)) {        return false;    }    if (path != null ? !path.equals(childData.path) : childData.path != null) {        return false;    }    if (stat != null ? !stat.equals(childData.stat) : childData.stat != null) {        return false;    }    return true;}
0
public int hashCode()
{    int result = path != null ? path.hashCode() : 0;    result = 31 * result + (stat != null ? stat.hashCode() : 0);    result = 31 * result + Arrays.hashCode(data);    return result;}
0
public String getPath()
{    return path;}
0
public Stat getStat()
{    return stat;}
0
public byte[] getData()
{    return data;}
0
public String toString()
{    return "ChildData{" + "path='" + path + '\'' + ", stat=" + stat + ", data=" + Arrays.toString(data) + '}';}
0
public boolean traverseChildren(String fullPath)
{    return true;}
0
public boolean acceptChild(String fullPath)
{    return true;}
0
public void invoke()
{    cache.callListeners(event);}
0
public String toString()
{    return "EventOperation{" + "event=" + event + '}';}
0
public void invoke() throws Exception
{    cache.getDataAndStat(fullPath);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    GetDataOperation that = (GetDataOperation) o;        if (!fullPath.equals(that.fullPath)) {        return false;    }    return true;}
0
public int hashCode()
{    return fullPath.hashCode();}
0
public String toString()
{    return "GetDataOperation{" + "fullPath='" + fullPath + '\'' + '}';}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        if (isConnected.compareAndSet(false, true)) {            try {                reset();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }        }    } else {        isConnected.set(false);    }}
1
public void process(WatchedEvent event)
{    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    processBackgroundResult(event);}
0
public CuratorFramework getClient()
{    return client;}
0
public void start() throws Exception
{    start(false);}
0
public void start(boolean buildInitial) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    if (buildInitial) {        client.checkExists().creatingParentContainersIfNeeded().forPath(path);        internalRebuild();    }    reset();}
0
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        listeners.clear();        client.getConnectionStateListenable().removeListener(connectionStateListener);                                        connectionStateListener = null;        watcher = null;    }}
0
public ListenerContainer<NodeCacheListener> getListenable()
{    Preconditions.checkState(state.get() != State.CLOSED, "Closed");    return listeners;}
0
public void rebuild() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    internalRebuild();    reset();}
0
public ChildData getCurrentData()
{    return data.get();}
0
public String getPath()
{    return path;}
0
private void reset() throws Exception
{    if ((state.get() == State.STARTED) && isConnected.get()) {        client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);    }}
0
private void internalRebuild() throws Exception
{    try {        Stat stat = new Stat();        byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(path) : client.getData().storingStatIn(stat).forPath(path);        data.set(new ChildData(path, stat, bytes));    } catch (KeeperException.NoNodeException e) {        data.set(null);    }}
0
private void processBackgroundResult(CuratorEvent event) throws Exception
{    switch(event.getType()) {        case GET_DATA:            {                if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    ChildData childData = new ChildData(path, event.getStat(), event.getData());                    setNewData(childData);                }                break;            }        case EXISTS:            {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                    setNewData(null);                } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    if (dataIsCompressed) {                        client.getData().decompressed().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    } else {                        client.getData().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    }                }                break;            }    }}
0
private void setNewData(ChildData newData) throws InterruptedException
{    ChildData previousData = data.getAndSet(newData);    if (!Objects.equal(previousData, newData)) {        listeners.forEach(new Function<NodeCacheListener, Void>() {            @Override            public Void apply(NodeCacheListener listener) {                try {                    listener.nodeChanged();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });        if (rebuildTestExchanger != null) {            try {                rebuildTestExchanger.exchange(new Object());            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }    }}
1
public Void apply(NodeCacheListener listener)
{    try {        listener.nodeChanged();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
1
protected void handleException(Throwable e)
{    }
1
public void process(WatchedEvent event)
{    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.STANDARD));}
0
public void process(WatchedEvent event)
{    try {        if (event.getType() == Event.EventType.NodeDeleted) {            remove(event.getPath());        } else if (event.getType() == Event.EventType.NodeDataChanged) {            offerOperation(new GetDataOperation(PathChildrenCache.this, event.getPath()));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
0
public void start() throws Exception
{    start(StartMode.NORMAL);}
0
public void start(boolean buildInitial) throws Exception
{    start(buildInitial ? StartMode.BUILD_INITIAL_CACHE : StartMode.NORMAL);}
0
public void start(StartMode mode) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "already started");    mode = Preconditions.checkNotNull(mode, "mode cannot be null");    client.getConnectionStateListenable().addListener(connectionStateListener);    switch(mode) {        case NORMAL:            {                offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));                break;            }        case BUILD_INITIAL_CACHE:            {                rebuild();                break;            }        case POST_INITIALIZED_EVENT:            {                initialSet.set(Maps.<String, ChildData>newConcurrentMap());                offerOperation(new RefreshOperation(this, RefreshMode.POST_INITIALIZED));                break;            }    }}
0
public void rebuild() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    clear();    List<String> children = client.getChildren().forPath(path);    for (String child : children) {        String fullPath = ZKPaths.makePath(path, child);        internalRebuildNode(fullPath);        if (rebuildTestExchanger != null) {            rebuildTestExchanger.exchange(new Object());        }    }        offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
0
public void rebuildNode(String fullPath) throws Exception
{    Preconditions.checkArgument(ZKPaths.getPathAndNode(fullPath).getPath().equals(path), "Node is not part of this cache: " + fullPath);    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    internalRebuildNode(fullPath);            offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
0
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.close();        client.removeWatchers();                                connectionStateListener = null;        childrenWatcher = null;        dataWatcher = null;    }}
0
public ListenerContainer<PathChildrenCacheListener> getListenable()
{    return listeners;}
0
public List<ChildData> getCurrentData()
{    return ImmutableList.copyOf(Sets.<ChildData>newTreeSet(currentData.values()));}
0
public ChildData getCurrentData(String fullPath)
{    return currentData.get(fullPath);}
0
public void clearDataBytes(String fullPath)
{    clearDataBytes(fullPath, -1);}
0
public boolean clearDataBytes(String fullPath, int ifVersion)
{    ChildData data = currentData.get(fullPath);    if (data != null) {        if ((ifVersion < 0) || (ifVersion == data.getStat().getVersion())) {            if (data.getData() != null) {                currentData.replace(fullPath, data, new ChildData(data.getPath(), data.getStat(), null));            }            return true;        }    }    return false;}
0
public void clearAndRefresh() throws Exception
{    currentData.clear();    offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));}
0
public void clear()
{    currentData.clear();}
0
 void refresh(final RefreshMode mode) throws Exception
{    ensurePath();    final BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                processChildren(event.getChildren(), mode);            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                if (mode == RefreshMode.NO_NODE_EXCEPTION) {                                        ensureContainers.reset();                } else {                                        ensureContainers.reset();                    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));                }            }        }    };    client.getChildren().usingWatcher(childrenWatcher).inBackground(callback).forPath(path);}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        processChildren(event.getChildren(), mode);    } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {        if (mode == RefreshMode.NO_NODE_EXCEPTION) {                        ensureContainers.reset();        } else {                        ensureContainers.reset();            offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));        }    }}
1
 void callListeners(final PathChildrenCacheEvent event)
{    listeners.forEach(new Function<PathChildrenCacheListener, Void>() {        @Override        public Void apply(PathChildrenCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
0
public Void apply(PathChildrenCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
0
 void getDataAndStat(final String fullPath) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);        }    };    if (USE_EXISTS && !cacheData) {        client.checkExists().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);    } else {                if (dataIsCompressed && cacheData) {            client.getData().decompressed().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        } else {            client.getData().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        }    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);}
0
protected void handleException(Throwable e)
{    }
1
protected void ensurePath() throws Exception
{    ensureContainers.ensure();}
0
protected void remove(String fullPath)
{    ChildData data = currentData.remove(fullPath);    if (data != null) {        offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_REMOVED, data)));    }    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.remove(ZKPaths.getNodeFromPath(fullPath));        maybeOfferInitializedEvent(localInitialSet);    }}
0
private boolean reRemoveWatchersOnBackgroundClosed()
{    if (state.get().equals(State.CLOSED)) {        client.removeWatchers();        return true;    }    return false;}
0
private void internalRebuildNode(String fullPath) throws Exception
{    if (cacheData) {        try {            Stat stat = new Stat();            byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(fullPath) : client.getData().storingStatIn(stat).forPath(fullPath);            currentData.put(fullPath, new ChildData(fullPath, stat, bytes));        } catch (KeeperException.NoNodeException ignore) {                        currentData.remove(fullPath);        }    } else {        Stat stat = client.checkExists().forPath(fullPath);        if (stat != null) {            currentData.put(fullPath, new ChildData(fullPath, stat, null));        } else {                        currentData.remove(fullPath);        }    }}
0
private void handleStateChange(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED, null)));                break;            }        case LOST:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_LOST, null)));                break;            }        case CONNECTED:        case RECONNECTED:            {                try {                    offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));                    offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED, null)));                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }                break;            }    }}
0
private void processChildren(List<String> children, RefreshMode mode) throws Exception
{    Set<String> removedNodes = Sets.newHashSet(currentData.keySet());    for (String child : children) {        removedNodes.remove(ZKPaths.makePath(path, child));    }    for (String fullPath : removedNodes) {        remove(fullPath);    }    for (String name : children) {        String fullPath = ZKPaths.makePath(path, name);        if ((mode == RefreshMode.FORCE_GET_DATA_AND_STAT) || !currentData.containsKey(fullPath)) {            getDataAndStat(fullPath);        }        updateInitialSet(name, NULL_CHILD_DATA);    }    maybeOfferInitializedEvent(initialSet.get());}
0
private void applyNewData(String fullPath, int resultCode, Stat stat, byte[] bytes)
{    if (    resultCode == KeeperException.Code.OK.intValue()) {        ChildData data = new ChildData(fullPath, stat, bytes);        ChildData previousData = currentData.put(fullPath, data);        if (        previousData == null) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_ADDED, data)));        } else if (stat.getMzxid() != previousData.getStat().getMzxid()) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_UPDATED, data)));        }        updateInitialSet(ZKPaths.getNodeFromPath(fullPath), data);    } else if (resultCode == KeeperException.Code.NONODE.intValue()) {                remove(fullPath);    }}
1
private void updateInitialSet(String name, ChildData data)
{    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.put(name, data);        maybeOfferInitializedEvent(localInitialSet);    }}
0
private void maybeOfferInitializedEvent(Map<String, ChildData> localInitialSet)
{    if (!hasUninitialized(localInitialSet)) {        if (        initialSet.getAndSet(null) != null) {            final List<ChildData> children = ImmutableList.copyOf(localInitialSet.values());            PathChildrenCacheEvent event = new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.INITIALIZED, null) {                @Override                public List<ChildData> getInitialData() {                    return children;                }            };            offerOperation(new EventOperation(this, event));        }    }}
0
public List<ChildData> getInitialData()
{    return children;}
0
private boolean hasUninitialized(Map<String, ChildData> localInitialSet)
{    if (localInitialSet == null) {        return false;    }    Map<String, ChildData> uninitializedChildren = Maps.filterValues(localInitialSet, new Predicate<ChildData>() {        @Override        public boolean apply(ChildData input) {                        return (input == NULL_CHILD_DATA);        }    });    return (uninitializedChildren.size() != 0);}
0
public boolean apply(ChildData input)
{        return (input == NULL_CHILD_DATA);}
0
 void offerOperation(final Operation operation)
{    if (operationsQuantizer.add(operation)) {        submitToExecutor(new Runnable() {            @Override            public void run() {                try {                    operationsQuantizer.remove(operation);                    operation.invoke();                } catch (InterruptedException e) {                                        if (state.get() != State.CLOSED) {                        handleException(e);                    }                    Thread.currentThread().interrupt();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
0
public void run()
{    try {        operationsQuantizer.remove(operation);        operation.invoke();    } catch (InterruptedException e) {                if (state.get() != State.CLOSED) {            handleException(e);        }        Thread.currentThread().interrupt();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
0
private synchronized void submitToExecutor(final Runnable command)
{    if (state.get() == State.STARTED) {        executorService.submit(command);    }}
0
public Type getType()
{    return type;}
0
public ChildData getData()
{    return data;}
0
public List<ChildData> getInitialData()
{    return null;}
0
public String toString()
{    return "PathChildrenCacheEvent{" + "type=" + type + ", data=" + data + '}';}
0
public void invoke() throws Exception
{    cache.refresh(mode);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    RefreshOperation that = (RefreshOperation) o;        if (mode != that.mode) {        return false;    }    return true;}
0
public int hashCode()
{    return mode.hashCode();}
0
public String toString()
{    return "RefreshOperation(" + mode + "){}";}
0
public TreeCache build()
{    ExecutorService executor = executorService;    if (executor == null) {        executor = Executors.newSingleThreadExecutor(defaultThreadFactory);    }    return new TreeCache(client, path, cacheData, dataIsCompressed, maxDepth, executor, createParentNodes, disableZkWatches, selector);}
0
public Builder setCacheData(boolean cacheData)
{    this.cacheData = cacheData;    return this;}
0
public Builder setDataIsCompressed(boolean dataIsCompressed)
{    this.dataIsCompressed = dataIsCompressed;    return this;}
0
public Builder setExecutor(ThreadFactory threadFactory)
{    return setExecutor(Executors.newSingleThreadExecutor(threadFactory));}
0
public Builder setExecutor(ExecutorService executorService)
{    this.executorService = checkNotNull(executorService);    return this;}
0
public Builder setMaxDepth(int maxDepth)
{    this.maxDepth = maxDepth;    return this;}
0
public Builder setCreateParentNodes(boolean createParentNodes)
{    this.createParentNodes = createParentNodes;    return this;}
0
public Builder disableZkWatches(boolean disableZkWatches)
{    this.disableZkWatches = disableZkWatches;    return this;}
0
public Builder setSelector(TreeCacheSelector selector)
{    this.selector = selector;    return this;}
0
public static Builder newBuilder(CuratorFramework client, String path)
{    return new Builder(client, path);}
0
private static boolean isLive(ChildData cd)
{    return cd != null && cd != DEAD;}
0
private void refresh() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.addAndGet(2);        doRefreshData();        doRefreshChildren();    } else {        refreshData();    }}
0
private void refreshChildren() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.incrementAndGet();        doRefreshChildren();    }}
0
private void refreshData() throws Exception
{    outstandingOps.incrementAndGet();    doRefreshData();}
0
private void doRefreshChildren() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        maybeWatch(client.getChildren()).forPath(path);    }}
0
private void doRefreshData() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        if (dataIsCompressed) {            maybeWatch(client.getData().decompressed()).forPath(path);        } else {            maybeWatch(client.getData()).forPath(path);        }    }}
0
private Pathable<T> maybeWatch(P dataBuilder)
{    if (disableZkWatches) {        return dataBuilder.inBackground(this);    } else {        return dataBuilder.usingWatcher(this).inBackground(this);    }}
0
 void wasReconnected() throws Exception
{    refresh();    ConcurrentMap<String, TreeNode> childMap = children;    if (childMap != null) {        for (TreeNode child : childMap.values()) {            child.wasReconnected();        }    }}
0
 void wasCreated() throws Exception
{    refresh();}
0
 void wasDeleted() throws Exception
{    ChildData oldChildData = childDataUpdater.getAndSet(this, DEAD);    if (oldChildData == DEAD) {        return;    }    ConcurrentMap<String, TreeNode> childMap = childrenUpdater.getAndSet(this, null);    if (childMap != null) {        ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());        childMap.clear();        for (TreeNode child : childCopy) {            child.wasDeleted();        }    }    if (treeState.get() == TreeState.CLOSED) {        return;    }    if (isLive(oldChildData)) {        publishEvent(TreeCacheEvent.Type.NODE_REMOVED, oldChildData);    }    if (parent == null) {                maybeWatch(client.checkExists()).forPath(path);    } else {                ConcurrentMap<String, TreeNode> parentChildMap = parent.children;        if (parentChildMap != null) {            parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);        }    }}
0
public void process(WatchedEvent event)
{        try {        switch(event.getType()) {            case NodeCreated:                Preconditions.checkState(parent == null, "unexpected NodeCreated on non-root node");                wasCreated();                break;            case NodeChildrenChanged:                refreshChildren();                break;            case NodeDataChanged:                refreshData();                break;            case NodeDeleted:                wasDeleted();                break;        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{        Stat newStat = event.getStat();    switch(event.getType()) {        case EXISTS:            Preconditions.checkState(parent == null, "unexpected EXISTS on non-root node");            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                childDataUpdater.compareAndSet(this, DEAD, null);                wasCreated();            }            break;        case CHILDREN:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                ChildData oldChildData = childData;                                if (isLive(oldChildData) && oldChildData.getStat().getMzxid() == newStat.getMzxid()) {                                                            childDataUpdater.compareAndSet(this, oldChildData, new ChildData(oldChildData.getPath(), newStat, oldChildData.getData()));                }                if (event.getChildren().isEmpty()) {                    break;                }                ConcurrentMap<String, TreeNode> childMap = children;                while (childMap == null) {                    childMap = Maps.newConcurrentMap();                    if (!childrenUpdater.compareAndSet(this, null, childMap)) {                        childMap = children;                    }                }                                List<String> newChildren = new ArrayList<String>();                for (String child : event.getChildren()) {                    if (!childMap.containsKey(child) && selector.acceptChild(ZKPaths.makePath(path, child))) {                        newChildren.add(child);                    }                }                Collections.sort(newChildren);                for (String child : newChildren) {                    String fullPath = ZKPaths.makePath(path, child);                    TreeNode node = new TreeNode(fullPath, this);                    if (childMap.putIfAbsent(child, node) == null) {                        node.wasCreated();                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        case GET_DATA:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                String eventPath = event.getPath();                ChildData toPublish = new ChildData(eventPath, newStat, event.getData());                ChildData toUpdate = cacheData ? toPublish : new ChildData(eventPath, newStat, null);                while (true) {                    final ChildData oldChildData = childData;                                        if (isLive(oldChildData) && newStat.getMzxid() <= oldChildData.getStat().getMzxid()) {                        break;                    }                                        if (parent != null && oldChildData == DEAD) {                        break;                    }                    if (childDataUpdater.compareAndSet(this, oldChildData, toUpdate)) {                        publishEvent(isLive(oldChildData) ? TreeCacheEvent.Type.NODE_UPDATED : TreeCacheEvent.Type.NODE_ADDED, toPublish);                        break;                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        default:                                                outstandingOps.decrementAndGet();            return;    }    if (outstandingOps.decrementAndGet() == 0) {        if (isInitialized.compareAndSet(false, true)) {            publishEvent(TreeCacheEvent.Type.INITIALIZED);        }    }}
1
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
0
public TreeCache start() throws Exception
{    Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), "already started");    if (createParentNodes) {        client.createContainers(root.path);    }    client.getConnectionStateListenable().addListener(connectionStateListener);    if (client.getZookeeperClient().isConnected()) {        root.wasCreated();    }    return this;}
0
public void close()
{    if (treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.shutdown();        try {            root.wasDeleted();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            handleException(e);        }    }}
0
public Listenable<TreeCacheListener> getListenable()
{    return listeners;}
0
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return errorListeners;}
0
private TreeNode find(String findPath)
{    PathUtils.validatePath(findPath);    LinkedList<String> rootElements = new LinkedList<String>(ZKPaths.split(root.path));    LinkedList<String> findElements = new LinkedList<String>(ZKPaths.split(findPath));    while (!rootElements.isEmpty()) {        if (findElements.isEmpty()) {                        return null;        }        String nextRoot = rootElements.removeFirst();        String nextFind = findElements.removeFirst();        if (!nextFind.equals(nextRoot)) {                        return null;        }    }    TreeNode current = root;    while (!findElements.isEmpty()) {        String nextFind = findElements.removeFirst();        ConcurrentMap<String, TreeNode> map = current.children;        if (map == null) {            return null;        }        current = map.get(nextFind);        if (current == null) {            return null;        }    }    return current;}
0
public Map<String, ChildData> getCurrentChildren(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null || !isLive(node.childData)) {        return null;    }    ConcurrentMap<String, TreeNode> map = node.children;    Map<String, ChildData> result;    if (map == null) {        result = ImmutableMap.of();    } else {        ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();        for (Map.Entry<String, TreeNode> entry : map.entrySet()) {            ChildData childData = entry.getValue().childData;                        if (isLive(childData)) {                builder.put(entry.getKey(), childData);            }        }        result = builder.build();    }        return isLive(node.childData) ? result : null;}
0
public ChildData getCurrentData(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null) {        return null;    }    ChildData result = node.childData;    return isLive(result) ? result : null;}
0
private void callListeners(final TreeCacheEvent event)
{    listeners.forEach(new Function<TreeCacheListener, Void>() {        @Override        public Void apply(TreeCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
0
public Void apply(TreeCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
0
private void handleException(final Throwable e)
{    if (errorListeners.size() == 0) {            } else {        errorListeners.forEach(new Function<UnhandledErrorListener, Void>() {            @Override            public Void apply(UnhandledErrorListener listener) {                try {                    listener.unhandledError("", e);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });    }}
1
public Void apply(UnhandledErrorListener listener)
{    try {        listener.unhandledError("", e);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
1
private void handleStateChange(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);            break;        case LOST:            isInitialized.set(false);            publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);            break;        case CONNECTED:            try {                root.wasCreated();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;        case RECONNECTED:            try {                root.wasReconnected();                publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;    }}
0
private void publishEvent(TreeCacheEvent.Type type)
{    publishEvent(new TreeCacheEvent(type, null));}
0
private void publishEvent(TreeCacheEvent.Type type, ChildData data)
{    publishEvent(new TreeCacheEvent(type, data));}
0
private void publishEvent(final TreeCacheEvent event)
{    if (treeState.get() != TreeState.CLOSED) {                executorService.submit(new Runnable() {            @Override            public void run() {                try {                    callListeners(event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
1
public void run()
{    try {        callListeners(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
0
public Type getType()
{    return type;}
0
public ChildData getData()
{    return data;}
0
public String toString()
{    return TreeCacheEvent.class.getSimpleName() + "{" + "type=" + type + ", data=" + data + '}';}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
0
public String fixForSorting(String str, String lockName)
{    return StandardLockInternalsDriver.standardFixForSorting(str, lockName);}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    startTask.set(AfterConnectionEstablished.execute(client, new Runnable() {        @Override        public void run() {            try {                internalStart();            } finally {                startTask.set(null);            }        }    }));}
0
public void run()
{    try {        internalStart();    } finally {        startTask.set(null);    }}
0
public void close() throws IOException
{    close(closeMode);}
0
public synchronized void close(CloseMode closeMode) throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    Preconditions.checkNotNull(closeMode, "closeMode cannot be null");    cancelStartTask();    try {        setNode(null);        client.removeWatchers();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        client.getConnectionStateListenable().removeListener(listener);        switch(closeMode) {            case NOTIFY_LEADER:                {                    setLeadership(false);                    listeners.clear();                    break;                }            default:                {                    listeners.clear();                    setLeadership(false);                    break;                }        }    }}
0
protected boolean cancelStartTask()
{    Future<?> localStartTask = startTask.getAndSet(null);    if (localStartTask != null) {        localStartTask.cancel(true);        return true;    }    return false;}
0
public void addListener(LeaderLatchListener listener)
{    listeners.addListener(listener);}
0
public void addListener(LeaderLatchListener listener, Executor executor)
{    listeners.addListener(listener, executor);}
0
public void removeListener(LeaderLatchListener listener)
{    listeners.removeListener(listener);}
0
public void await() throws InterruptedException, EOFException
{    synchronized (this) {        while ((state.get() == State.STARTED) && !hasLeadership.get()) {            wait();        }    }    if (state.get() != State.STARTED) {        throw new EOFException();    }}
0
public boolean await(long timeout, TimeUnit unit) throws InterruptedException
{    long waitNanos = TimeUnit.NANOSECONDS.convert(timeout, unit);    synchronized (this) {        while (true) {            if (state.get() != State.STARTED) {                return false;            }            if (hasLeadership()) {                return true;            }            if (waitNanos <= 0) {                return false;            }            long startNanos = System.nanoTime();            TimeUnit.NANOSECONDS.timedWait(this, waitNanos);            long elapsed = System.nanoTime() - startNanos;            waitNanos -= elapsed;        }    }}
0
public String getId()
{    return id;}
0
public State getState()
{    return state.get();}
0
public Collection<Participant> getParticipants() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getParticipants(client, participantNodes);}
0
public Participant getLeader() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getLeader(client, participantNodes);}
0
public boolean hasLeadership()
{    return (state.get() == State.STARTED) && hasLeadership.get();}
0
public String getOurPath()
{    return ourPath.get();}
0
 void reset() throws Exception
{    setLeadership(false);    setNode(null);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (debugResetWaitLatch != null) {                debugResetWaitLatch.await();                debugResetWaitLatch = null;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                setNode(event.getName());                if (state.get() == State.CLOSED) {                    setNode(null);                } else {                    getChildren();                }            } else {                            }        }    };    client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath(ZKPaths.makePath(latchPath, LOCK_NAME), LeaderSelector.getIdBytes(id));}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (debugResetWaitLatch != null) {        debugResetWaitLatch.await();        debugResetWaitLatch = null;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNode(event.getName());        if (state.get() == State.CLOSED) {            setNode(null);        } else {            getChildren();        }    } else {            }}
1
private synchronized void internalStart()
{    if (state.get() == State.STARTED) {        client.getConnectionStateListenable().addListener(listener);        try {            reset();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                    }    }}
1
private void checkLeadership(List<String> children) throws Exception
{    if (debugCheckLeaderShipLatch != null) {        debugCheckLeaderShipLatch.await();    }    final String localOurPath = ourPath.get();    List<String> sortedChildren = LockInternals.getSortedChildren(LOCK_NAME, sorter, children);    int ourIndex = (localOurPath != null) ? sortedChildren.indexOf(ZKPaths.getNodeFromPath(localOurPath)) : -1;    if (ourIndex < 0) {                reset();    } else if (ourIndex == 0) {        setLeadership(true);    } else {        String watchPath = sortedChildren.get(ourIndex - 1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {                    try {                        getChildren();                    } catch (Exception ex) {                        ThreadUtils.checkInterrupted(ex);                                            }                }            }        };        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                                        reset();                }            }        };                client.getData().usingWatcher(watcher).inBackground(callback).forPath(ZKPaths.makePath(latchPath, watchPath));    }}
1
public void process(WatchedEvent event)
{    if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {        try {            getChildren();        } catch (Exception ex) {            ThreadUtils.checkInterrupted(ex);                    }    }}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                reset();    }}
0
private void getChildren() throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                checkLeadership(event.getChildren());            }        }    };    client.getChildren().inBackground(callback).forPath(ZKPaths.makePath(latchPath, null));}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        checkLeadership(event.getChildren());    }}
0
protected void handleStateChange(ConnectionState newState)
{    switch(newState) {        default:            {                                break;            }        case RECONNECTED:            {                try {                    if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get()) {                        reset();                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                        setLeadership(false);                }                break;            }        case SUSPENDED:            {                if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED)) {                    setLeadership(false);                }                break;            }        case LOST:            {                setLeadership(false);                break;            }    }}
1
private synchronized void setLeadership(boolean newValue)
{    boolean oldValue = hasLeadership.getAndSet(newValue);    if (oldValue && !newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener listener) {                listener.notLeader();                return null;            }        });    } else if (!oldValue && newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener input) {                input.isLeader();                return null;            }        });    }    notifyAll();}
0
public Void apply(LeaderLatchListener listener)
{    listener.notLeader();    return null;}
0
public Void apply(LeaderLatchListener input)
{    input.isLeader();    return null;}
0
private void setNode(String newValue) throws Exception
{    String oldPath = ourPath.getAndSet(newValue);    if (oldPath != null) {        client.delete().guaranteed().inBackground().forPath(oldPath);    }}
0
protected byte[] getLockNodeBytes()
{    return (id.length() > 0) ? getIdBytes(id) : null;}
0
 static byte[] getIdBytes(String id)
{    try {        return id.getBytes("UTF-8");    } catch (UnsupportedEncodingException e) {                throw new Error(e);    }}
0
public void autoRequeue()
{    autoRequeue.set(true);}
0
public void setId(String id)
{    Preconditions.checkNotNull(id, "id cannot be null");    this.id = id;}
0
public String getId()
{    return id;}
0
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    Preconditions.checkState(!executorService.isShutdown(), "Already started");    Preconditions.checkState(!hasLeadership, "Already has leadership");    client.getConnectionStateListenable().addListener(listener);    requeue();}
0
public boolean requeue()
{    Preconditions.checkState(state.get() == State.STARTED, "close() has already been called");    return internalRequeue();}
0
private synchronized boolean internalRequeue()
{    if (!isQueued && (state.get() == State.STARTED)) {        isQueued = true;        Future<Void> task = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    doWorkLoop();                } finally {                    clearIsQueued();                    if (autoRequeue.get()) {                        internalRequeue();                    }                }                return null;            }        });        ourTask.set(task);        return true;    }    return false;}
0
public Void call() throws Exception
{    try {        doWorkLoop();    } finally {        clearIsQueued();        if (autoRequeue.get()) {            internalRequeue();        }    }    return null;}
0
public synchronized void close()
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    client.getConnectionStateListenable().removeListener(listener);    executorService.close();    ourTask.set(null);}
0
public Collection<Participant> getParticipants() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getParticipants(client, participantNodes);}
0
 static Collection<Participant> getParticipants(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    ImmutableList.Builder<Participant> builder = ImmutableList.builder();    boolean isLeader = true;    for (String path : participantNodes) {        Participant participant = participantForPath(client, path, isLeader);        if (participant != null) {            builder.add(participant);                        isLeader = false;        }    }    return builder.build();}
0
public Participant getLeader() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getLeader(client, participantNodes);}
0
 static Participant getLeader(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    Participant result = null;    if (participantNodes.size() > 0) {        Iterator<String> iter = participantNodes.iterator();        while (iter.hasNext()) {            result = participantForPath(client, iter.next(), true);            if (result != null) {                break;            }        }    }    if (result == null) {        result = new Participant();    }    return result;}
0
public boolean hasLeadership()
{    return hasLeadership;}
0
public synchronized void interruptLeadership()
{    Future<?> task = ourTask.get();    if (task != null) {        task.cancel(true);    }}
0
private static Participant participantForPath(CuratorFramework client, String path, boolean markAsLeader) throws Exception
{    try {        byte[] bytes = client.getData().forPath(path);        String thisId = new String(bytes, "UTF-8");        return new Participant(thisId, markAsLeader);    } catch (KeeperException.NoNodeException e) {        return null;    }}
0
 void doWork() throws Exception
{    hasLeadership = false;    try {        mutex.acquire();        hasLeadership = true;        try {            if (debugLeadershipLatch != null) {                debugLeadershipLatch.countDown();            }            if (debugLeadershipWaitLatch != null) {                debugLeadershipWaitLatch.await();            }            listener.takeLeadership(client);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            throw e;        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);        } finally {            clearIsQueued();        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    } finally {        if (hasLeadership) {            hasLeadership = false;                        boolean wasInterrupted = Thread.interrupted();            try {                mutex.release();            } catch (Exception e) {                if (failedMutexReleaseCount != null) {                    failedMutexReleaseCount.incrementAndGet();                }                ThreadUtils.checkInterrupted(e);                                        } finally {                if (wasInterrupted) {                    Thread.currentThread().interrupt();                }            }        }    }}
1
private void doWorkLoop() throws Exception
{    KeeperException exception = null;    try {        doWork();    } catch (KeeperException.ConnectionLossException e) {        exception = e;    } catch (KeeperException.SessionExpiredException e) {        exception = e;    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    if (    (exception != null) && !autoRequeue.get()) {        throw exception;    }}
0
private synchronized void clearIsQueued()
{    isQueued = false;}
0
private static ExecutorService wrapExecutor(final Executor executor)
{    return new AbstractExecutorService() {        private volatile boolean isShutdown = false;        private volatile boolean isTerminated = false;        @Override        public void shutdown() {            isShutdown = true;        }        @Override        public List<Runnable> shutdownNow() {            return Lists.newArrayList();        }        @Override        public boolean isShutdown() {            return isShutdown;        }        @Override        public boolean isTerminated() {            return isTerminated;        }        @Override        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {            throw new UnsupportedOperationException();        }        @Override        public void execute(Runnable command) {            try {                executor.execute(command);            } finally {                isShutdown = true;                isTerminated = true;            }        }    };}
0
public void shutdown()
{    isShutdown = true;}
0
public List<Runnable> shutdownNow()
{    return Lists.newArrayList();}
0
public boolean isShutdown()
{    return isShutdown;}
0
public boolean isTerminated()
{    return isTerminated;}
0
public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
{    throw new UnsupportedOperationException();}
0
public void execute(Runnable command)
{    try {        executor.execute(command);    } finally {        isShutdown = true;        isTerminated = true;    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    listener.takeLeadership(client);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    try {        listener.stateChanged(client, newState);    } catch (CancelLeadershipException dummy) {        leaderSelector.interruptLeadership();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (client.getConnectionStateErrorPolicy().isErrorState(newState)) {        throw new CancelLeadershipException();    }}
0
public String getId()
{    return id;}
0
public boolean isLeader()
{    return isLeader;}
0
public String toString()
{    return "Participant{" + "id='" + id + '\'' + ", isLeader=" + isLeader + '}';}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Participant that = (Participant) o;    if (isLeader != that.isLeader) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    return true;}
0
public int hashCode()
{    int result = id.hashCode();    result = 31 * result + (isLeader ? 1 : 0);    return result;}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    task = executor.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, reapingThresholdMs, reapingThresholdMs, TimeUnit.MILLISECONDS);    if (leaderLatch != null) {        leaderLatch.start();    }    reaper.start();}
0
public void run()
{    doWork();}
0
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        CloseableUtils.closeQuietly(reaper);        if (leaderLatch != null) {            CloseableUtils.closeQuietly(leaderLatch);        }        task.cancel(true);    }}
0
public ChildReaper addPath(String path)
{    paths.add(PathUtils.validatePath(path));    return this;}
0
public boolean removePath(String path)
{    return paths.remove(PathUtils.validatePath(path));}
0
public void setMaxChildren(int maxChildren)
{    this.maxChildren.set(maxChildren);}
0
public static ScheduledExecutorService newExecutorService()
{    return ThreadUtils.newFixedThreadScheduledPool(2, "ChildReaper");}
0
protected void warnMaxChildren(String path, Stat stat)
{    }
1
private void doWork()
{    if (shouldDoWork()) {        if ((pathIterator == null) || !pathIterator.hasNext()) {            pathIterator = paths.iterator();        }        while (pathIterator.hasNext()) {            String path = pathIterator.next();            try {                int maxChildren = this.maxChildren.get();                if (maxChildren > 0) {                    Stat stat = client.checkExists().forPath(path);                    if ((stat != null) && (stat.getNumChildren() > maxChildren)) {                        warnMaxChildren(path, stat);                        continue;                    }                }                List<String> children = client.getChildren().forPath(path);                                for (String name : children) {                    String childPath = ZKPaths.makePath(path, name);                    addPathToReaperIfEmpty(childPath);                    for (String subNode : lockSchema) {                        addPathToReaperIfEmpty(ZKPaths.makePath(childPath, subNode));                    }                }            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }        }    }}
1
private void addPathToReaperIfEmpty(String path) throws Exception
{    Stat stat = client.checkExists().forPath(path);    if ((stat != null) && (stat.getNumChildren() == 0)) {                reaper.addPath(path, mode);    }}
1
private boolean shouldDoWork()
{    return this.leaderLatch == null || this.leaderLatch.hasLeadership();}
0
private static List<InterProcessLock> makeLocks(CuratorFramework client, List<String> paths)
{    ImmutableList.Builder<InterProcessLock> builder = ImmutableList.builder();    for (String path : paths) {        InterProcessLock lock = new InterProcessMutex(client, path);        builder.add(lock);    }    return builder.build();}
0
public void acquire() throws Exception
{    acquire(-1, null);}
0
public boolean acquire(long time, TimeUnit unit) throws Exception
{    Exception exception = null;    List<InterProcessLock> acquired = Lists.newArrayList();    boolean success = true;    for (InterProcessLock lock : locks) {        try {            if (unit == null) {                lock.acquire();                acquired.add(lock);            } else {                if (lock.acquire(time, unit)) {                    acquired.add(lock);                } else {                    success = false;                    break;                }            }        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            success = false;            exception = e;        }    }    if (!success) {        for (InterProcessLock lock : reverse(acquired)) {            try {                lock.release();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                        }        }    }    if (exception != null) {        throw exception;    }    return success;}
0
public synchronized void release() throws Exception
{    Exception baseException = null;    for (InterProcessLock lock : reverse(locks)) {        try {            lock.release();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            if (baseException == null) {                baseException = e;            } else {                baseException = new Exception(baseException);            }        }    }    if (baseException != null) {        throw baseException;    }}
0
public synchronized boolean isAcquiredInThisProcess()
{    for (InterProcessLock lock : locks) {        if (!lock.isAcquiredInThisProcess()) {            return false;        }    }    return true;}
0
public void acquire() throws Exception
{    if (!internalLock(-1, null)) {        throw new IOException("Lost connection while trying to acquire lock: " + basePath);    }}
0
public boolean acquire(long time, TimeUnit unit) throws Exception
{    return internalLock(time, unit);}
0
public boolean isAcquiredInThisProcess()
{    return (threadData.size() > 0);}
0
public void release() throws Exception
{    /*            Note on concurrency: a given lockData instance            can be only acted on by a single thread so locking isn't necessary         */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData == null) {        throw new IllegalMonitorStateException("You do not own the lock: " + basePath);    }    int newLockCount = lockData.lockCount.decrementAndGet();    if (newLockCount > 0) {        return;    }    if (newLockCount < 0) {        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + basePath);    }    try {        internals.releaseLock(lockData.lockPath);    } finally {        threadData.remove(currentThread);    }}
0
public Collection<String> getParticipantNodes() throws Exception
{    return LockInternals.getParticipantNodes(internals.getClient(), basePath, internals.getLockName(), internals.getDriver());}
0
public void makeRevocable(RevocationListener<InterProcessMutex> listener)
{    makeRevocable(listener, MoreExecutors.directExecutor());}
0
public void makeRevocable(final RevocationListener<InterProcessMutex> listener, Executor executor)
{    internals.makeRevocable(new RevocationSpec(executor, new Runnable() {        @Override        public void run() {            listener.revocationRequested(InterProcessMutex.this);        }    }));}
0
public void run()
{    listener.revocationRequested(InterProcessMutex.this);}
0
public boolean isOwnedByCurrentThread()
{    LockData lockData = threadData.get(Thread.currentThread());    return (lockData != null) && (lockData.lockCount.get() > 0);}
0
protected byte[] getLockNodeBytes()
{    return null;}
0
protected String getLockPath()
{    LockData lockData = threadData.get(Thread.currentThread());    return lockData != null ? lockData.lockPath : null;}
0
private boolean internalLock(long time, TimeUnit unit) throws Exception
{    /*           Note on concurrency: a given lockData instance           can be only acted on by a single thread so locking isn't necessary        */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData != null) {                lockData.lockCount.incrementAndGet();        return true;    }    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());    if (lockPath != null) {        LockData newLockData = new LockData(currentThread, lockPath);        threadData.put(currentThread, newLockData);        return true;    }    return false;}
0
public final String fixForSorting(String str, String lockName)
{    str = super.fixForSorting(str, READ_LOCK_NAME);    str = super.fixForSorting(str, WRITE_LOCK_NAME);    return str;}
0
public Collection<String> getParticipantNodes() throws Exception
{    Collection<String> nodes = super.getParticipantNodes();    Iterable<String> filtered = Iterables.filter(nodes, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.contains(lockName);        }    });    return ImmutableList.copyOf(filtered);}
0
public boolean apply(String node)
{    return node.contains(lockName);}
0
protected byte[] getLockNodeBytes()
{    return lockData;}
0
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return super.getsTheLock(client, children, sequenceNodeName, maxLeases);}
0
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return readLockPredicate(children, sequenceNodeName);}
0
public InterProcessMutex readLock()
{    return readMutex;}
0
public InterProcessMutex writeLock()
{    return writeMutex;}
0
private PredicateResults readLockPredicate(List<String> children, String sequenceNodeName) throws Exception
{    if (writeMutex.isOwnedByCurrentThread()) {        return new PredicateResults(null, true);    }    int index = 0;    int firstWriteIndex = Integer.MAX_VALUE;    int ourIndex = -1;    for (String node : children) {        if (node.contains(WRITE_LOCK_NAME)) {            firstWriteIndex = Math.min(index, firstWriteIndex);        } else if (node.startsWith(sequenceNodeName)) {            ourIndex = index;            break;        }        ++index;    }    StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = (ourIndex < firstWriteIndex);    String pathToWatch = getsTheLock ? null : children.get(firstWriteIndex);    return new PredicateResults(pathToWatch, getsTheLock);}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    internals.setMaxLeases(newCount);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void returnAll(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
0
public void returnLease(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
0
public Lease acquire() throws Exception
{    String path = internals.attemptLock(-1, null, null);    return makeLease(path);}
0
public Collection<Lease> acquire(int qty) throws Exception
{    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            String path = internals.attemptLock(-1, null, null);            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
0
public Lease acquire(long time, TimeUnit unit) throws Exception
{    String path = internals.attemptLock(time, unit, null);    return (path != null) ? makeLease(path) : null;}
0
public Collection<Lease> acquire(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    long waitMs = TimeUnit.MILLISECONDS.convert(time, unit);    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = waitMs - elapsedMs;            String path = (thisWaitMs > 0) ? internals.attemptLock(thisWaitMs, TimeUnit.MILLISECONDS, null) : null;            if (path == null) {                returnAll(builder.build());                return null;            }            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
0
private Lease makeLease(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                internals.releaseLock(path);            } catch (KeeperException.NoNodeException e) {                            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return internals.getClient().getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
1
public void close() throws IOException
{    try {        internals.releaseLock(path);    } catch (KeeperException.NoNodeException e) {            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
1
public byte[] getData() throws Exception
{    return internals.getClient().getData().forPath(path);}
0
public String getNodeName()
{    return ZKPaths.getNodeFromPath(path);}
0
public void acquire() throws Exception
{    lease = semaphore.acquire();}
0
public boolean acquire(long time, TimeUnit unit) throws Exception
{    Lease acquiredLease = semaphore.acquire(time, unit);    if (acquiredLease == null) {                return false;    }    lease = acquiredLease;    return true;}
0
public void release() throws Exception
{    Lease lease = this.lease;    Preconditions.checkState(lease != null, "Not acquired");    this.lease = null;    lease.close();    watcherRemoveClient.removeWatchers();}
0
public boolean isAcquiredInThisProcess()
{    return (lease != null);}
0
public void process(WatchedEvent event)
{    client.postSafeNotify(InterProcessSemaphoreV2.this);}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    InterProcessSemaphoreV2.this.maxLeases = newCount;    client.postSafeNotify(InterProcessSemaphoreV2.this);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void setNodeData(byte[] nodeData)
{    this.nodeData = (nodeData != null) ? Arrays.copyOf(nodeData, nodeData.length) : null;}
0
public Collection<String> getParticipantNodes() throws Exception
{    return client.getChildren().forPath(leasesPath);}
0
public void returnAll(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
0
public void returnLease(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
0
public Lease acquire() throws Exception
{    Collection<Lease> leases = acquire(1, 0, null);    return leases.iterator().next();}
0
public Collection<Lease> acquire(int qty) throws Exception
{    return acquire(qty, 0, null);}
0
public Lease acquire(long time, TimeUnit unit) throws Exception
{    Collection<Lease> leases = acquire(1, time, unit);    return (leases != null) ? leases.iterator().next() : null;}
0
public Collection<Lease> acquire(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasWait = (unit != null);    long waitMs = hasWait ? TimeUnit.MILLISECONDS.convert(time, unit) : 0;    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    boolean success = false;    try {        while (qty-- > 0) {            int retryCount = 0;            long startMillis = System.currentTimeMillis();            boolean isDone = false;            while (!isDone) {                switch(internalAcquire1Lease(builder, startMs, hasWait, waitMs)) {                    case CONTINUE:                        {                            isDone = true;                            break;                        }                    case RETURN_NULL:                        {                            return null;                        }                    case RETRY_DUE_TO_MISSING_NODE:                        {                                                        if (!client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                                throw new KeeperException.NoNodeException("Sequential path not found - possible session loss");                            }                                                        break;                        }                }            }        }        success = true;    } finally {        if (!success) {            returnAll(builder.build());        }    }    return builder.build();}
0
private InternalAcquireResult internalAcquire1Lease(ImmutableList.Builder<Lease> builder, long startMs, boolean hasWait, long waitMs) throws Exception
{    if (client.getState() != CuratorFrameworkState.STARTED) {        return InternalAcquireResult.RETURN_NULL;    }    if (hasWait) {        long thisWaitMs = getThisWaitMs(startMs, waitMs);        if (!lock.acquire(thisWaitMs, TimeUnit.MILLISECONDS)) {            return InternalAcquireResult.RETURN_NULL;        }    } else {        lock.acquire();    }    Lease lease = null;    boolean success = false;    try {        PathAndBytesable<String> createBuilder = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL);        String path = (nodeData != null) ? createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME), nodeData) : createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME));        String nodeName = ZKPaths.getNodeFromPath(path);        lease = makeLease(path);        if (debugAcquireLatch != null) {            debugAcquireLatch.await();        }        try {            synchronized (this) {                for (; ; ) {                    List<String> children;                    try {                        children = client.getChildren().usingWatcher(watcher).forPath(leasesPath);                    } catch (Exception e) {                        if (debugFailedGetChildrenLatch != null) {                            debugFailedGetChildrenLatch.countDown();                        }                        throw e;                    }                    if (!children.contains(nodeName)) {                                                return InternalAcquireResult.RETRY_DUE_TO_MISSING_NODE;                    }                    if (children.size() <= maxLeases) {                        break;                    }                    if (hasWait) {                        long thisWaitMs = getThisWaitMs(startMs, waitMs);                        if (thisWaitMs <= 0) {                            return InternalAcquireResult.RETURN_NULL;                        }                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait(thisWaitMs);                    } else {                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait();                    }                }                success = true;            }        } finally {            if (!success) {                returnLease(lease);            }            client.removeWatchers();        }    } finally {        lock.release();    }    builder.add(Preconditions.checkNotNull(lease));    return InternalAcquireResult.CONTINUE;}
1
private long getThisWaitMs(long startMs, long waitMs)
{    long elapsedMs = System.currentTimeMillis() - startMs;    return waitMs - elapsedMs;}
0
private Lease makeLease(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException e) {                            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return client.getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
1
public void close() throws IOException
{    try {        client.delete().guaranteed().forPath(path);    } catch (KeeperException.NoNodeException e) {            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
1
public byte[] getData() throws Exception
{    return client.getData().forPath(path);}
0
public String getNodeName()
{    return ZKPaths.getNodeFromPath(path);}
0
public void close() throws Exception
{    if (acquired.compareAndSet(true, false)) {        releaseLock();    }}
0
protected void releaseLock() throws Exception
{    lock.release();}
0
protected void acquireLock(InterProcessLock lock) throws Exception
{    lock.acquire();}
0
protected boolean acquireLock(InterProcessLock lock, long timeout, TimeUnit unit) throws Exception
{    return lock.acquire(timeout, unit);}
0
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        checkRevocableWatcher(event.getPath());    }}
0
public void process(WatchedEvent event)
{    client.postSafeNotify(LockInternals.this);}
0
public void clean() throws Exception
{    try {        client.delete().forPath(basePath);    } catch (KeeperException.BadVersionException ignore) {        } catch (KeeperException.NotEmptyException ignore) {        }}
0
 synchronized void setMaxLeases(int maxLeases)
{    this.maxLeases = maxLeases;    notifyAll();}
0
 void makeRevocable(RevocationSpec entry)
{    revocable.set(entry);}
0
 final void releaseLock(String lockPath) throws Exception
{    client.removeWatchers();    revocable.set(null);    deleteOurPath(lockPath);}
0
 CuratorFramework getClient()
{    return client;}
0
public static Collection<String> getParticipantNodes(CuratorFramework client, final String basePath, String lockName, LockInternalsSorter sorter) throws Exception
{    List<String> names = getSortedChildren(client, basePath, lockName, sorter);    Iterable<String> transformed = Iterables.transform(names, new Function<String, String>() {        @Override        public String apply(String name) {            return ZKPaths.makePath(basePath, name);        }    });    return ImmutableList.copyOf(transformed);}
0
public String apply(String name)
{    return ZKPaths.makePath(basePath, name);}
0
public static List<String> getSortedChildren(CuratorFramework client, String basePath, final String lockName, final LockInternalsSorter sorter) throws Exception
{    try {        List<String> children = client.getChildren().forPath(basePath);        List<String> sortedList = Lists.newArrayList(children);        Collections.sort(sortedList, new Comparator<String>() {            @Override            public int compare(String lhs, String rhs) {                return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));            }        });        return sortedList;    } catch (KeeperException.NoNodeException ignore) {        return Collections.emptyList();    }}
0
public int compare(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
0
public static List<String> getSortedChildren(final String lockName, final LockInternalsSorter sorter, List<String> children)
{    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList, new Comparator<String>() {        @Override        public int compare(String lhs, String rhs) {            return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));        }    });    return sortedList;}
0
public int compare(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
0
 List<String> getSortedChildren() throws Exception
{    return getSortedChildren(client, basePath, lockName, driver);}
0
 String getLockName()
{    return lockName;}
0
 LockInternalsDriver getDriver()
{    return driver;}
0
 String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception
{    final long startMillis = System.currentTimeMillis();    final Long millisToWait = (unit != null) ? unit.toMillis(time) : null;    final byte[] localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;    int retryCount = 0;    String ourPath = null;    boolean hasTheLock = false;    boolean isDone = false;    while (!isDone) {        isDone = true;        try {            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);        } catch (KeeperException.NoNodeException e) {                        if (client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                isDone = false;            } else {                throw e;            }        }    }    if (hasTheLock) {        return ourPath;    }    return null;}
0
private void checkRevocableWatcher(String path) throws Exception
{    RevocationSpec entry = revocable.get();    if (entry != null) {        try {            byte[] bytes = client.getData().usingWatcher(revocableWatcher).forPath(path);            if (Arrays.equals(bytes, REVOKE_MESSAGE)) {                entry.getExecutor().execute(entry.getRunnable());            }        } catch (KeeperException.NoNodeException ignore) {                }    }}
0
private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception
{    boolean haveTheLock = false;    boolean doDelete = false;    try {        if (revocable.get() != null) {            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);        }        while ((client.getState() == CuratorFrameworkState.STARTED) && !haveTheLock) {            List<String> children = getSortedChildren();                        String sequenceNodeName = ourPath.substring(basePath.length() + 1);            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);            if (predicateResults.getsTheLock()) {                haveTheLock = true;            } else {                String previousSequencePath = basePath + "/" + predicateResults.getPathToWatch();                synchronized (this) {                    try {                                                client.getData().usingWatcher(watcher).forPath(previousSequencePath);                        if (millisToWait != null) {                            millisToWait -= (System.currentTimeMillis() - startMillis);                            startMillis = System.currentTimeMillis();                            if (millisToWait <= 0) {                                                                doDelete = true;                                break;                            }                            wait(millisToWait);                        } else {                            wait();                        }                    } catch (KeeperException.NoNodeException e) {                                        }                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        doDelete = true;        throw e;    } finally {        if (doDelete) {            deleteOurPath(ourPath);        }    }    return haveTheLock;}
0
private void deleteOurPath(String ourPath) throws Exception
{    try {        client.delete().guaranteed().forPath(ourPath);    } catch (KeeperException.NoNodeException e) {        }}
0
public String getPathToWatch()
{    return pathToWatch;}
0
public boolean getsTheLock()
{    return getsTheLock;}
0
public void run()
{    reap(this);}
0
public void addPath(String path)
{    addPath(path, Mode.REAP_INDEFINITELY);}
0
public void addPath(String path, Mode mode)
{    PathHolder pathHolder = new PathHolder(path, mode, 0);    activePaths.put(path, pathHolder);    schedule(pathHolder, reapingThresholdMs);}
0
public boolean removePath(String path)
{    return activePaths.remove(path) != null;}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    if (leaderLatch != null && ownsLeaderLatch) {        leaderLatch.start();    }}
0
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        executor.close();        if (leaderLatch != null && ownsLeaderLatch) {            leaderLatch.close();        }    }}
0
protected Future<?> schedule(PathHolder pathHolder, int reapingThresholdMs)
{    if (reapingIsActive.get()) {        return executor.schedule(pathHolder, reapingThresholdMs, TimeUnit.MILLISECONDS);    }    return null;}
0
protected void reap(PathHolder holder)
{    if (!activePaths.containsKey(holder.path)) {        return;    }    boolean addBack = true;    int newEmptyCount = 0;    try {        Stat stat = client.checkExists().forPath(holder.path);        if (        stat != null) {            if (stat.getNumChildren() == 0) {                if ((holder.emptyCount + 1) >= EMPTY_COUNT_THRESHOLD) {                    try {                        client.delete().forPath(holder.path);                                                if (holder.mode == Mode.REAP_UNTIL_DELETE || holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NoNodeException ignore) {                                                if (holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NotEmptyException ignore) {                                        }                } else {                    newEmptyCount = holder.emptyCount + 1;                }            }        } else {            if (holder.mode == Mode.REAP_UNTIL_GONE) {                addBack = false;            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    if (!addBack) {        activePaths.remove(holder.path);    } else if (!Thread.currentThread().isInterrupted() && (state.get() == State.STARTED) && activePaths.containsKey(holder.path)) {        activePaths.put(holder.path, holder);        schedule(new PathHolder(holder.path, holder.mode, newEmptyCount), reapingThresholdMs);    }}
1
public static ScheduledExecutorService newExecutorService()
{    return ThreadUtils.newSingleThreadScheduledExecutor("Reaper");}
0
private void addListenerToLeaderLatch(LeaderLatch leaderLatch)
{    LeaderLatchListener listener = new LeaderLatchListener() {        @Override        public void isLeader() {            reapingIsActive.set(true);            for (PathHolder holder : activePaths.values()) {                schedule(holder, reapingThresholdMs);            }        }        @Override        public void notLeader() {            reapingIsActive.set(false);        }    };    leaderLatch.addListener(listener);    reapingIsActive.set(leaderLatch.hasLeadership());}
0
public void isLeader()
{    reapingIsActive.set(true);    for (PathHolder holder : activePaths.values()) {        schedule(holder, reapingThresholdMs);    }}
0
public void notLeader()
{    reapingIsActive.set(false);}
0
private static LeaderLatch makeLeaderLatchIfPathNotNull(CuratorFramework client, String leaderPath)
{    if (leaderPath == null) {        return null;    } else {        return new LeaderLatch(client, leaderPath);    }}
0
 Runnable getRunnable()
{    return runnable;}
0
 Executor getExecutor()
{    return executor;}
0
public static void attemptRevoke(CuratorFramework client, String path) throws Exception
{    try {        client.setData().forPath(path, LockInternals.REVOKE_MESSAGE);    } catch (KeeperException.NoNodeException ignore) {        }}
0
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    int ourIndex = children.indexOf(sequenceNodeName);    validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = ourIndex < maxLeases;    String pathToWatch = getsTheLock ? null : children.get(ourIndex - maxLeases);    return new PredicateResults(pathToWatch, getsTheLock);}
0
public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);    }    return ourPath;}
0
public String fixForSorting(String str, String lockName)
{    return standardFixForSorting(str, lockName);}
0
public static String standardFixForSorting(String str, String lockName)
{    int index = str.lastIndexOf(lockName);    if (index >= 0) {        index += lockName.length();        return index <= str.length() ? str.substring(index) : "";    }    return str;}
0
 static void validateOurIndex(String sequenceNodeName, int ourIndex) throws KeeperException
{    if (ourIndex < 0) {        throw new KeeperException.NoNodeException("Sequential path not found: " + sequenceNodeName);    }}
0
public void start()
{    pen.start();    try {        cache.start();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
0
public void setThisData(byte[] data)
{    try {        pen.setData(data);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
0
public void close()
{    CloseableUtils.closeQuietly(cache);    CloseableUtils.closeQuietly(pen);}
0
public Map<String, byte[]> getCurrentMembers()
{    ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();    boolean thisIdAdded = false;    for (ChildData data : cache.getCurrentData()) {        String id = idFromPath(data.getPath());        thisIdAdded = thisIdAdded || id.equals(thisId);        builder.put(id, data.getData());    }    if (!thisIdAdded) {                builder.put(thisId, pen.getData());    }    return builder.build();}
0
public String idFromPath(String path)
{    return ZKPaths.getNodeFromPath(path);}
0
protected PersistentEphemeralNode newPersistentEphemeralNode(CuratorFramework client, String membershipPath, String thisId, byte[] payload)
{    return new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, ZKPaths.makePath(membershipPath, thisId), payload);}
0
protected PathChildrenCache newPathChildrenCache(CuratorFramework client, String membershipPath)
{    return new PathChildrenCache(client, membershipPath, true);}
0
protected CreateMode getCreateMode(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
0
protected boolean isProtected()
{    return false;}
0
protected CreateMode getCreateMode(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
0
protected boolean isProtected()
{    return false;}
0
protected CreateMode getCreateMode(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
0
protected boolean isProtected()
{    return true;}
0
protected CreateMode getCreateMode(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
0
protected boolean isProtected()
{    return true;}
0
public void process(WatchedEvent event) throws Exception
{    if (isActive()) {        if (event.getType() == EventType.NodeDeleted) {            createNode();        } else if (event.getType() == EventType.NodeDataChanged) {            watchNode();        }    }}
0
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {            createNode();        } else {            boolean isEphemeral = event.getStat().getEphemeralOwner() != 0;            if (isEphemeral != mode.isEphemeral()) {                            }        }    } else {        client.removeWatchers();    }}
1
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                initialisationComplete();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {                authFailure.set(true);    }}
1
public void stateChanged(CuratorFramework dummy, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) && isActive()) {        createNode();    }}
0
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        processBackgroundCallback(event);    } else {        processBackgroundCallbackClosedState(event);    }}
0
private void processBackgroundCallbackClosedState(CuratorEvent event)
{    String path = null;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    }    if (path != null) {        try {            client.delete().guaranteed().inBackground().forPath(path);        } catch (Exception e) {                    }    }}
1
private void processBackgroundCallback(CuratorEvent event) throws Exception
{    String path = null;    boolean nodeExists = false;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();        nodeExists = true;    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {                authFailure.set(true);        return;    }    if (path != null) {        authFailure.set(false);        nodePath.set(path);        watchNode();        if (nodeExists) {            client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());        } else {            initialisationComplete();            notifyListeners();        }    } else {        createNode();    }}
1
private void initialisationComplete()
{    CountDownLatch localLatch = initialCreateLatch.getAndSet(null);    if (localLatch != null) {        localLatch.countDown();    }}
0
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Already started");    client.getConnectionStateListenable().addListener(connectionStateListener);    createNode();}
0
public boolean waitForInitialCreate(long timeout, TimeUnit unit) throws InterruptedException
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    CountDownLatch localLatch = initialCreateLatch.get();    return (localLatch == null) || localLatch.await(timeout, unit);}
0
public void close() throws IOException
{    if (debugWaitMsForBackgroundBeforeClose.get() > 0) {        try {            Thread.sleep(debugWaitMsForBackgroundBeforeClose.get());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    if (!state.compareAndSet(State.STARTED, State.CLOSED)) {        return;    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    try {        deleteNode();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }    client.removeWatchers();}
0
public ListenerContainer<PersistentNodeListener> getListenable()
{    return listeners;}
0
public String getActualPath()
{    return nodePath.get();}
0
public void setData(byte[] data) throws Exception
{    data = Preconditions.checkNotNull(data, "data cannot be null");    Preconditions.checkState(nodePath.get() != null, "initial create has not been processed. Call waitForInitialCreate() to ensure.");    this.data.set(Arrays.copyOf(data, data.length));    if (isActive()) {        client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());    }}
0
public byte[] getData()
{    return this.data.get();}
0
protected void deleteNode() throws Exception
{    String localNodePath = nodePath.getAndSet(null);    if (localNodePath != null) {        try {            client.delete().guaranteed().forPath(localNodePath);        } catch (KeeperException.NoNodeException ignore) {                }    }}
0
private void createNode()
{    if (!isActive()) {        return;    }    if (debugCreateNodeLatch != null) {        try {            debugCreateNodeLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return;        }    }    try {        String existingPath = nodePath.get(), createPath;        if (existingPath != null && !useProtection) {            createPath = existingPath;        } else if (existingPath != null && mode.isSequential()) {            createPath = basePath + ZKPaths.extractSequentialSuffix(existingPath);        } else {            createPath = basePath;        }        CreateModable<ACLBackgroundPathAndBytesable<String>> localCreateMethod = createMethod.get();        if (localCreateMethod == null) {            CreateBuilderMain createBuilder = SafeIsTtlMode.isTtl(mode) ? client.create().withTtl(ttl) : client.create();            CreateModable<ACLBackgroundPathAndBytesable<String>> tempCreateMethod = useProtection ? createBuilder.creatingParentContainersIfNeeded().withProtection() : createBuilder.creatingParentContainersIfNeeded();            createMethod.compareAndSet(null, tempCreateMethod);            localCreateMethod = createMethod.get();        }        localCreateMethod.withMode(getCreateMode(existingPath != null)).inBackground(backgroundCallback).forPath(createPath, data.get());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                throw new RuntimeException("Creating node. BasePath: " + basePath, e);    }}
0
private CreateMode getCreateMode(boolean pathIsSet)
{    if (pathIsSet) {        switch(mode) {            default:                {                    break;                }            case EPHEMERAL_SEQUENTIAL:                {                                        return CreateMode.EPHEMERAL;                }            case PERSISTENT_SEQUENTIAL:                {                                        return CreateMode.PERSISTENT;                }            case PERSISTENT_SEQUENTIAL_WITH_TTL:                {                                        return CreateMode.PERSISTENT_WITH_TTL;                }        }    }    return mode;}
0
private void watchNode() throws Exception
{    if (!isActive()) {        return;    }    String localNodePath = nodePath.get();    if (localNodePath != null) {        client.checkExists().usingWatcher(watcher).inBackground(checkExistsCallback).forPath(localNodePath);    }}
0
private void notifyListeners()
{    final String path = getActualPath();    listeners.forEach(new Function<PersistentNodeListener, Void>() {        @Override        public Void apply(PersistentNodeListener listener) {            try {                listener.nodeCreated(path);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }            return null;        }    });}
1
public Void apply(PersistentNodeListener listener)
{    try {        listener.nodeCreated(path);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
1
private boolean isActive()
{    return (state.get() == State.STARTED);}
0
 boolean isAuthFailure()
{    return authFailure.get();}
0
protected void deleteNode()
{}
0
public void start()
{    node.start();    Runnable touchTask = new Runnable() {        @Override        public void run() {            try {                try {                    client.setData().forPath(childPath);                } catch (KeeperException.NoNodeException e) {                    client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);                }            } catch (KeeperException.NoNodeException ignore) {                        } catch (Exception e) {                if (!ThreadUtils.checkInterrupted(e)) {                                    }            }        }    };    Future<?> future = executorService.scheduleAtFixedRate(touchTask, ttlMs / touchScheduleFactor, ttlMs / touchScheduleFactor, TimeUnit.MILLISECONDS);    futureRef.set(future);}
1
public void run()
{    try {        try {            client.setData().forPath(childPath);        } catch (KeeperException.NoNodeException e) {            client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);        }    } catch (KeeperException.NoNodeException ignore) {        } catch (Exception e) {        if (!ThreadUtils.checkInterrupted(e)) {                    }    }}
1
public boolean waitForInitialCreate(long timeout, TimeUnit unit) throws InterruptedException
{    return node.waitForInitialCreate(timeout, unit);}
0
public void setData(byte[] data) throws Exception
{    node.setData(data);}
0
public byte[] getData()
{    return node.getData();}
0
public void close()
{    Future<?> future = futureRef.getAndSet(null);    if (future != null) {        future.cancel(true);    }    try {        node.close();    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
public void consumeMessage(T message) throws Exception
{    items.add(message);}
0
public List<T> getItems()
{    return ImmutableList.copyOf(items);}
0
public int size()
{    return items.size();}
0
public T take() throws InterruptedException
{    return items.take();}
0
public T take(int time, TimeUnit unit) throws InterruptedException
{    return items.poll(time, unit);}
0
public int drainTo(Collection<? super T> c)
{    return items.drainTo(c);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    connectionStateListener.stateChanged(client, newState);}
0
public void process(WatchedEvent event) throws Exception
{    if (!isClosed.get()) {        sync(true);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNewChildren(event.getChildren());    }}
0
 void start() throws Exception
{    sync(true);}
0
public void close() throws IOException
{    client.removeWatchers();    isClosed.set(true);    notifyFromCallback();}
0
 Data getData()
{    return children.get();}
0
 Data blockingNextGetData(long startVersion) throws InterruptedException
{    return blockingNextGetData(startVersion, 0, null);}
0
 synchronized Data blockingNextGetData(long startVersion, long maxWait, TimeUnit unit) throws InterruptedException
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? unit.toMillis(maxWait) : -1;    while (startVersion == children.get().version) {        if (hasMaxWait) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return children.get();}
0
private synchronized void notifyFromCallback()
{    notifyAll();}
0
private synchronized void sync(boolean watched) throws Exception
{    if (watched) {        client.getChildren().usingWatcher(watcher).inBackground(callback).forPath(path);    } else {        client.getChildren().inBackground(callback).forPath(path);    }}
0
private synchronized void setNewChildren(List<String> newChildren)
{    if (newChildren != null) {        Data currentData = children.get();        children.set(new Data(newChildren, currentData.version + 1));        notifyFromCallback();    }}
0
protected long getDelay(String itemNode)
{    return getDelay(itemNode, System.currentTimeMillis());}
0
private long getDelay(String itemNode, long sortTime)
{    long epoch = getEpoch(itemNode);    return epoch - sortTime;}
0
protected void sortChildren(List<String> children)
{    final long sortTime = System.currentTimeMillis();    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);            return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);        }    });}
0
public int compare(String o1, String o2)
{    long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
0
public void start() throws Exception
{    queue.start();}
0
public void close() throws IOException
{    queue.close();}
0
public void put(T item, long delayUntilEpoch) throws Exception
{    put(item, delayUntilEpoch, 0, null);}
0
public boolean put(T item, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(item, null, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
0
public void putMulti(MultiItem<T> items, long delayUntilEpoch) throws Exception
{    putMulti(items, delayUntilEpoch, 0, null);}
0
public boolean putMulti(MultiItem<T> items, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(null, items, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
0
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
0
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
0
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
0
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
0
 static String epochToString(long epoch)
{    return SEPARATOR + String.format("%08X", epoch) + SEPARATOR;}
0
private static long getEpoch(String itemNode)
{    int index2 = itemNode.lastIndexOf(SEPARATOR);    int index1 = (index2 > 0) ? itemNode.lastIndexOf(SEPARATOR, index2 - 1) : -1;    if ((index1 > 0) && (index2 > (index1 + 1))) {        try {            String epochStr = itemNode.substring(index1 + 1, index2);            return Long.parseLong(epochStr, 16);        } catch (NumberFormatException ignore) {                }    }    return 0;}
0
protected void sortChildren(List<String> children)
{    internalSortChildren(children);}
0
protected String makeRequeueItemPath(String itemPath)
{    return makeIdPath(parseId(itemPath).id);}
0
public void start() throws Exception
{    queue.start();}
0
public void close() throws IOException
{    queue.close();}
0
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
0
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
0
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
0
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
0
public void put(T item, String itemId) throws Exception
{    put(item, itemId, 0, null);}
0
public boolean put(T item, String itemId, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(isValidId(itemId), "Invalid id: " + itemId);    queue.checkState();    return queue.internalPut(item, null, makeIdPath(itemId), maxWait, unit);}
0
public int remove(String id) throws Exception
{    id = Preconditions.checkNotNull(id, "id cannot be null");    queue.checkState();    int count = 0;    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            if (queue.tryRemove(name)) {                ++count;            }        }    }    return count;}
0
 boolean debugIsQueued(String id) throws Exception
{    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            return true;        }    }    return false;}
0
private String makeIdPath(String itemId)
{    return queue.makeItemPath() + SEPARATOR + fixId(itemId) + SEPARATOR;}
0
private void internalSortChildren(List<String> children)
{    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);        }    });}
0
public int compare(String o1, String o2)
{    return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);}
0
private boolean isValidId(String id)
{    return (id != null) && (id.length() > 0);}
0
private static String fixId(String id)
{    String fixed = id.replace('/', '_');    return fixed.replace(SEPARATOR, '_');}
0
private Parts parseId(String name)
{    int firstIndex = name.indexOf(SEPARATOR);    int secondIndex = name.indexOf(SEPARATOR, firstIndex + 1);    if ((firstIndex < 0) || (secondIndex < 0)) {                return new Parts(name, name);    }    return new Parts(name.substring(firstIndex + 1, secondIndex), name.substring(0, firstIndex) + name.substring(secondIndex + 1));}
1
public void start() throws Exception
{    queue.start();}
0
public void close() throws IOException
{    queue.close();}
0
public void put(T item, int priority) throws Exception
{    put(item, priority, 0, null);}
0
public boolean put(T item, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(item, null, queue.makeItemPath() + priorityHex, maxWait, unit);}
0
public void putMulti(MultiItem<T> items, int priority) throws Exception
{    putMulti(items, priority, 0, null);}
0
public boolean putMulti(MultiItem<T> items, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(null, items, queue.makeItemPath() + priorityHex, maxWait, unit);}
0
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
0
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
0
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
0
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
0
 ChildrenCache getCache()
{    return queue.getCache();}
0
 static String priorityToString(int priority)
{            long l = (long) priority & 0xFFFFFFFFL;    return String.format("%s%08X", (priority >= 0) ? "1" : "0", l);}
0
public void start() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        throw new IllegalStateException();    }    try {        client.create().creatingParentContainersIfNeeded().forPath(queuePath);    } catch (KeeperException.NodeExistsException ignore) {        }    if (lockPath != null) {        try {            client.create().creatingParentContainersIfNeeded().forPath(lockPath);        } catch (KeeperException.NodeExistsException ignore) {                }    }    if (!isProducerOnly || (maxItems != QueueBuilder.NOT_SET)) {        childrenCache.start();    }    if (!isProducerOnly) {        service.submit(new Callable<Object>() {            @Override            public Object call() {                runLoop();                return null;            }        });    }}
0
public Object call()
{    runLoop();    return null;}
0
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        if (finalFlushMs > 0) {            try {                flushPuts(finalFlushMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }        CloseableUtils.closeQuietly(childrenCache);        putListenerContainer.clear();        service.shutdownNow();    }}
0
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return putListenerContainer;}
0
public void setErrorMode(ErrorMode newErrorMode)
{    Preconditions.checkNotNull(lockPath, "lockPath cannot be null");    if (newErrorMode == ErrorMode.REQUEUE) {            }    errorMode.set(newErrorMode);}
1
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    long msWaitRemaining = TimeUnit.MILLISECONDS.convert(waitTime, timeUnit);    synchronized (putCount) {        while (putCount.get() > 0) {            if (msWaitRemaining <= 0) {                return false;            }            long startMs = System.currentTimeMillis();            putCount.wait(msWaitRemaining);            long elapsedMs = System.currentTimeMillis() - startMs;            msWaitRemaining -= elapsedMs;        }    }    return true;}
0
public void put(T item) throws Exception
{    put(item, 0, null);}
0
public boolean put(T item, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(item, null, path, maxWait, unit);}
0
public void putMulti(MultiItem<T> items) throws Exception
{    putMulti(items, 0, null);}
0
public boolean putMulti(MultiItem<T> items, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(null, items, path, maxWait, unit);}
0
public int getLastMessageCount()
{    return lastChildCount.get();}
0
 boolean internalPut(final T item, MultiItem<T> multiItem, String path, int maxWait, TimeUnit unit) throws Exception
{    if (!blockIfMaxed(maxWait, unit)) {        return false;    }    final MultiItem<T> givenMultiItem = multiItem;    if (item != null) {        final AtomicReference<T> ref = new AtomicReference<T>(item);        multiItem = new MultiItem<T>() {            @Override            public T nextItem() throws Exception {                return ref.getAndSet(null);            }        };    }    putCount.incrementAndGet();    byte[] bytes = ItemSerializer.serialize(multiItem, serializer);    if (putInBackground) {        doPutInBackground(item, path, givenMultiItem, bytes);    } else {        doPutInForeground(item, path, givenMultiItem, bytes);    }    return true;}
0
public T nextItem() throws Exception
{    return ref.getAndSet(null);}
0
private void doPutInForeground(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(path, bytes);    synchronized (putCount) {        putCount.decrementAndGet();        putCount.notifyAll();    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
0
public Void apply(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
0
private void doPutInBackground(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() != KeeperException.Code.OK.intValue()) {                return;            }            if (event.getType() == CuratorEventType.CREATE) {                synchronized (putCount) {                    putCount.decrementAndGet();                    putCount.notifyAll();                }            }            putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {                @Override                public Void apply(QueuePutListener<T> listener) {                    if (item != null) {                        listener.putCompleted(item);                    } else {                        listener.putMultiCompleted(givenMultiItem);                    }                    return null;                }            });        }    };    internalCreateNode(path, bytes, callback);}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() != KeeperException.Code.OK.intValue()) {        return;    }    if (event.getType() == CuratorEventType.CREATE) {        synchronized (putCount) {            putCount.decrementAndGet();            putCount.notifyAll();        }    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
0
public Void apply(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
0
 void internalCreateNode(String path, byte[] bytes, BackgroundCallback callback) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);}
0
 void checkState() throws Exception
{    if (state.get() != State.STARTED) {        throw new IllegalStateException();    }}
0
 String makeItemPath()
{    return ZKPaths.makePath(queuePath, QUEUE_ITEM_NAME);}
0
 ChildrenCache getCache()
{    return childrenCache;}
0
protected void sortChildren(List<String> children)
{    Collections.sort(children);}
0
protected List<String> getChildren() throws Exception
{    return client.getChildren().forPath(queuePath);}
0
protected long getDelay(String itemNode)
{    return 0;}
0
protected boolean tryRemove(String itemNode) throws Exception
{    boolean isUsingLockSafety = (lockPath != null);    if (isUsingLockSafety) {        return processWithLockSafety(itemNode, ProcessType.REMOVE);    }    return processNormally(itemNode, ProcessType.REMOVE);}
0
private boolean blockIfMaxed(int maxWait, TimeUnit unit) throws Exception
{    ChildrenCache.Data data = childrenCache.getData();    while (data.children.size() >= maxItems) {        long previousVersion = data.version;        data = childrenCache.blockingNextGetData(data.version, maxWait, unit);        if (data.version == previousVersion) {            return false;        }    }    return true;}
0
private void runLoop()
{    long currentVersion = -1;    long maxWaitMs = -1;    try {        while (state.get() == State.STARTED) {            try {                ChildrenCache.Data data = (maxWaitMs > 0) ? childrenCache.blockingNextGetData(currentVersion, maxWaitMs, TimeUnit.MILLISECONDS) : childrenCache.blockingNextGetData(currentVersion);                currentVersion = data.version;                List<String> children = Lists.newArrayList(data.children);                                sortChildren(children);                if (children.size() > 0) {                    maxWaitMs = getDelay(children.get(0));                    if (maxWaitMs > 0) {                        continue;                    }                } else {                    continue;                }                processChildren(children, currentVersion);            } catch (InterruptedException e) {                                                }        }    } catch (Exception e) {            }}
1
private void processChildren(List<String> children, long currentVersion) throws Exception
{    final Semaphore processedLatch = new Semaphore(0);    final boolean isUsingLockSafety = (lockPath != null);    int min = minItemsBeforeRefresh;    for (final String itemNode : children) {        if (Thread.currentThread().isInterrupted()) {            processedLatch.release(children.size());            break;        }        if (!itemNode.startsWith(QUEUE_ITEM_NAME)) {                        processedLatch.release();            continue;        }        if (min-- <= 0) {            if (refreshOnWatch && (currentVersion != childrenCache.getData().version)) {                processedLatch.release(children.size());                break;            }        }        if (getDelay(itemNode) > 0) {            processedLatch.release();            continue;        }        executor.execute(new Runnable() {            @Override            public void run() {                try {                    if (isUsingLockSafety) {                        processWithLockSafety(itemNode, ProcessType.NORMAL);                    } else {                        processNormally(itemNode, ProcessType.NORMAL);                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    } finally {                    processedLatch.release();                }            }        });    }    processedLatch.acquire(children.size());}
1
public void run()
{    try {        if (isUsingLockSafety) {            processWithLockSafety(itemNode, ProcessType.NORMAL);        } else {            processNormally(itemNode, ProcessType.NORMAL);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            } finally {        processedLatch.release();    }}
1
private ProcessMessageBytesCode processMessageBytes(String itemNode, byte[] bytes) throws Exception
{    ProcessMessageBytesCode resultCode = ProcessMessageBytesCode.NORMAL;    MultiItem<T> items;    try {        items = ItemSerializer.deserialize(bytes, serializer);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);                return resultCode;    }    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        try {            consumer.consumeMessage(item);        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);                        if (errorMode.get() == ErrorMode.REQUEUE) {                resultCode = ProcessMessageBytesCode.REQUEUE;                break;            }        }    }    return resultCode;}
1
private boolean processNormally(String itemNode, ProcessType type) throws Exception
{    try {        String itemPath = ZKPaths.makePath(queuePath, itemNode);        Stat stat = new Stat();        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().storingStatIn(stat).forPath(itemPath);        }        if (client.getState() == CuratorFrameworkState.STARTED) {            client.delete().withVersion(stat.getVersion()).forPath(itemPath);        }        if (type == ProcessType.NORMAL) {            processMessageBytes(itemNode, bytes);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        }    return false;}
0
protected boolean processWithLockSafety(String itemNode, ProcessType type) throws Exception
{    String lockNodePath = ZKPaths.makePath(lockPath, itemNode);    boolean lockCreated = false;    try {        client.create().withMode(CreateMode.EPHEMERAL).forPath(lockNodePath);        lockCreated = true;        String itemPath = ZKPaths.makePath(queuePath, itemNode);        boolean requeue = false;        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().forPath(itemPath);            requeue = (processMessageBytes(itemNode, bytes) == ProcessMessageBytesCode.REQUEUE);        }        if (requeue) {            client.inTransaction().delete().forPath(itemPath).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(makeRequeueItemPath(itemPath), bytes).and().commit();        } else {            client.delete().forPath(itemPath);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        } finally {        if (lockCreated) {            client.delete().guaranteed().forPath(lockNodePath);        }    }    return false;}
0
protected String makeRequeueItemPath(String itemPath)
{    return makeItemPath();}
0
 static MultiItem<T> deserialize(byte[] bytes, QueueSerializer<T> serializer) throws Exception
{    DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));    int version = in.readInt();    if (version != VERSION) {        throw new IOException(String.format("Incorrect version. Expected %d - Found: %d", VERSION, version));    }    List<T> items = Lists.newArrayList();    for (; ; ) {        byte opcode = in.readByte();        if (opcode == EOF_OPCODE) {            break;        }        if (opcode != ITEM_OPCODE) {            throw new IOException(String.format("Incorrect opcode. Expected %d - Found: %d", ITEM_OPCODE, opcode));        }        int size = in.readInt();        if (size < 0) {            throw new IOException(String.format("Bad size: %d", size));        }        byte[] itemBytes = new byte[size];        if (size > 0) {            in.readFully(itemBytes);        }        items.add(serializer.deserialize(itemBytes));    }    final Iterator<T> iterator = items.iterator();    return new MultiItem<T>() {        @Override        public T nextItem() {            return iterator.hasNext() ? iterator.next() : null;        }    };}
0
public T nextItem()
{    return iterator.hasNext() ? iterator.next() : null;}
0
 static byte[] serialize(MultiItem<T> items, QueueSerializer<T> serializer) throws Exception
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);    DataOutputStream out = new DataOutputStream(bytes);    out.writeInt(VERSION);    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        byte[] itemBytes = serializer.serialize(item);        out.writeByte(ITEM_OPCODE);        out.writeInt(itemBytes.length);        if (itemBytes.length > 0) {            out.write(itemBytes);        }    }    out.writeByte(EOF_OPCODE);    out.close();    return bytes.toByteArray();}
0
public static QueueBuilder<T> builder(CuratorFramework client, QueueConsumer<T> consumer, QueueSerializer<T> serializer, String queuePath)
{    return new QueueBuilder<T>(client, consumer, serializer, queuePath);}
0
public DistributedQueue<T> buildQueue()
{    return new DistributedQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
0
public DistributedIdQueue<T> buildIdQueue()
{    return new DistributedIdQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
0
public DistributedPriorityQueue<T> buildPriorityQueue(int minItemsBeforeRefresh)
{    return new DistributedPriorityQueue<T>(client, consumer, serializer, queuePath, factory, executor, minItemsBeforeRefresh, lockPath, maxItems, putInBackground, finalFlushMs);}
0
public DistributedDelayQueue<T> buildDelayQueue()
{    return new DistributedDelayQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, lockPath, maxItems, putInBackground, finalFlushMs);}
0
public QueueBuilder<T> threadFactory(ThreadFactory factory)
{    Preconditions.checkNotNull(factory, "factory cannot be null");    this.factory = factory;    return this;}
0
public QueueBuilder<T> executor(Executor executor)
{    Preconditions.checkNotNull(executor, "executor cannot be null");    this.executor = executor;    return this;}
0
public QueueBuilder<T> lockPath(String path)
{    lockPath = PathUtils.validatePath(path);    return this;}
0
public QueueBuilder<T> maxItems(int maxItems)
{    this.maxItems = maxItems;    putInBackground = false;    return this;}
0
public QueueBuilder<T> putInBackground(boolean putInBackground)
{    this.putInBackground = putInBackground;    return this;}
0
public QueueBuilder<T> finalFlushTime(int time, TimeUnit unit)
{    finalFlushMs = (int) unit.toMillis(time);    return this;}
0
 String getLockPath()
{    return lockPath;}
0
 QueueConsumer<T> getConsumer()
{    return consumer;}
0
 BlockingQueue<T> getQueue()
{    return queue;}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.createContainers(queuePath);    getInitialQueues();    leaderLatch.start();    service.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            while (state.get() == State.STARTED) {                try {                    Thread.sleep(policies.getThresholdCheckMs());                    checkThreshold();                } catch (InterruptedException e) {                                                                }            }            return null;        }    });}
0
public Void call() throws Exception
{    while (state.get() == State.STARTED) {        try {            Thread.sleep(policies.getThresholdCheckMs());            checkThreshold();        } catch (InterruptedException e) {                                }    }    return null;}
0
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        CloseableUtils.closeQuietly(leaderLatch);        for (T queue : queues.values()) {            try {                queue.close();            } catch (IOException e) {                            }        }    }}
1
public T getQueue()
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    List<String> localPreferredQueues = Lists.newArrayList(preferredQueues);    if (localPreferredQueues.size() > 0) {        String key = localPreferredQueues.get(random.nextInt(localPreferredQueues.size()));        return queues.get(key);    }    List<String> keys = Lists.newArrayList(queues.keySet());    String key = keys.get(random.nextInt(keys.size()));    return queues.get(key);}
0
public int getShardQty()
{    return queues.size();}
0
public Collection<String> getQueuePaths()
{    return ImmutableSet.copyOf(queues.keySet());}
0
private void getInitialQueues() throws Exception
{    List<String> children = client.getChildren().forPath(queuePath);    for (String child : children) {        String queuePath = ZKPaths.makePath(this.queuePath, child);        addNewQueueIfNeeded(queuePath);    }    if (children.size() == 0) {        addNewQueueIfNeeded(null);    }}
0
private void addNewQueueIfNeeded(String newQueuePath) throws Exception
{    if (newQueuePath == null) {        newQueuePath = ZKPaths.makePath(queuePath, QUEUE_PREFIX + UUID.randomUUID().toString());    }    if (!queues.containsKey(newQueuePath)) {        T queue = queueAllocator.allocateQueue(client, newQueuePath);        if (queues.putIfAbsent(newQueuePath, queue) == null) {            queue.start();            preferredQueues.add(newQueuePath);        }    }}
0
private void checkThreshold()
{    try {        boolean addAQueueIfLeader = false;        int size = 0;        List<String> children = client.getChildren().forPath(queuePath);        for (String child : children) {            String queuePath = ZKPaths.makePath(this.queuePath, child);            addNewQueueIfNeeded(queuePath);            Stat stat = client.checkExists().forPath(queuePath);            if (stat.getNumChildren() >= policies.getNewQueueThreshold()) {                size = stat.getNumChildren();                addAQueueIfLeader = true;                preferredQueues.remove(queuePath);            } else if (stat.getNumChildren() <= (policies.getNewQueueThreshold() / 2)) {                preferredQueues.add(queuePath);            }        }        if (addAQueueIfLeader && leaderLatch.hasLeadership()) {            if (queues.size() < policies.getMaxQueues()) {                                addNewQueueIfNeeded(null);            } else {                            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
1
public Builder newQueueThreshold(int newQueueThreshold)
{    Preconditions.checkArgument(newQueueThreshold > 0, "newQueueThreshold must be a positive number");    policies.newQueueThreshold = newQueueThreshold;    return this;}
0
public Builder thresholdCheckMs(int thresholdCheckMs)
{    Preconditions.checkArgument(thresholdCheckMs > 0, "thresholdCheckMs must be a positive number");    policies.thresholdCheckMs = thresholdCheckMs;    return this;}
0
public Builder maxQueues(int maxQueues)
{    Preconditions.checkArgument(maxQueues > 0, "thresholdCheckMs must be a positive number");    policies.maxQueues = maxQueues;    return this;}
0
public Builder threadFactory(ThreadFactory threadFactory)
{    policies.threadFactory = Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return this;}
0
public QueueSharderPolicies build()
{    try {        return policies;    } finally {        policies = new QueueSharderPolicies();    }}
0
public static Builder builder()
{    return new Builder();}
0
 int getNewQueueThreshold()
{    return newQueueThreshold;}
0
 int getThresholdCheckMs()
{    return thresholdCheckMs;}
0
 int getMaxQueues()
{    return maxQueues;}
0
 ThreadFactory getThreadFactory()
{    return threadFactory;}
0
public byte[] element() throws Exception
{    byte[] bytes = internalElement(false, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
0
public byte[] remove() throws Exception
{    byte[] bytes = internalElement(true, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
0
public byte[] take() throws Exception
{    return internalPoll(0, null);}
0
public boolean offer(byte[] data) throws Exception
{    String thisPath = ZKPaths.makePath(path, PREFIX);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(thisPath, data);    return true;}
0
public byte[] peek() throws Exception
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
0
public byte[] poll(long timeout, TimeUnit unit) throws Exception
{    return internalPoll(timeout, unit);}
0
public byte[] poll() throws Exception
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
0
protected void ensurePath() throws Exception
{    ensureContainers.ensure();}
0
private byte[] internalPoll(long timeout, TimeUnit unit) throws Exception
{    ensurePath();    long startMs = System.currentTimeMillis();    boolean hasTimeout = (unit != null);    long maxWaitMs = hasTimeout ? TimeUnit.MILLISECONDS.convert(timeout, unit) : Long.MAX_VALUE;    for (; ; ) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        byte[] bytes;        try {            bytes = internalElement(true, watcher);        } catch (NoSuchElementException dummy) {                        ensureContainers.reset();            continue;        }        if (bytes != null) {            return bytes;        }        if (hasTimeout) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                return null;            }            latch.await(thisWaitMs, TimeUnit.MILLISECONDS);        } else {            latch.await();        }    }}
1
public void process(WatchedEvent event)
{    latch.countDown();}
0
private byte[] internalElement(boolean removeIt, Watcher watcher) throws Exception
{    ensurePath();    List<String> nodes;    try {        nodes = (watcher != null) ? client.getChildren().usingWatcher(watcher).forPath(path) : client.getChildren().forPath(path);    } catch (KeeperException.NoNodeException dummy) {        throw new NoSuchElementException();    }    Collections.sort(nodes);    for (String node : nodes) {        if (!node.startsWith(PREFIX)) {                        continue;        }        String thisPath = ZKPaths.makePath(path, node);        try {            byte[] bytes = client.getData().forPath(thisPath);            if (removeIt) {                client.delete().forPath(thisPath);            }            return bytes;        } catch (KeeperException.NoNodeException ignore) {                }    }    return null;}
1
public int getCount()
{    return fromBytes(sharedValue.getValue());}
0
public VersionedValue<Integer> getVersionedValue()
{    VersionedValue<byte[]> localValue = sharedValue.getVersionedValue();    return new VersionedValue<Integer>(localValue.getVersion(), fromBytes(localValue.getValue()));}
0
public void setCount(int newCount) throws Exception
{    sharedValue.setValue(toBytes(newCount));}
0
public boolean trySetCount(int newCount) throws Exception
{    return sharedValue.trySetValue(toBytes(newCount));}
0
public boolean trySetCount(VersionedValue<Integer> previous, int newCount) throws Exception
{    VersionedValue<byte[]> previousCopy = new VersionedValue<byte[]>(previous.getVersion(), toBytes(previous.getValue()));    return sharedValue.trySetValue(previousCopy, toBytes(newCount));}
0
public void addListener(SharedCountListener listener)
{    addListener(listener, MoreExecutors.directExecutor());}
0
public void addListener(final SharedCountListener listener, Executor executor)
{    SharedValueListener valueListener = new SharedValueListener() {        @Override        public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception {            listener.countHasChanged(SharedCount.this, fromBytes(newValue));        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            listener.stateChanged(client, newState);        }    };    sharedValue.getListenable().addListener(valueListener, executor);    listeners.put(listener, valueListener);}
0
public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception
{    listener.countHasChanged(SharedCount.this, fromBytes(newValue));}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    listener.stateChanged(client, newState);}
0
public void removeListener(SharedCountListener listener)
{    SharedValueListener valueListener = listeners.remove(listener);    if (valueListener != null) {        sharedValue.getListenable().removeListener(valueListener);    }}
0
public void start() throws Exception
{    sharedValue.start();}
0
public void close() throws IOException
{    sharedValue.close();}
0
 static byte[] toBytes(int value)
{    byte[] bytes = new byte[4];    ByteBuffer.wrap(bytes).putInt(value);    return bytes;}
0
private static int fromBytes(byte[] bytes)
{    return ByteBuffer.wrap(bytes).getInt();}
0
public void process(WatchedEvent event) throws Exception
{    if (state.get() == State.STARTED && event.getType() != Watcher.Event.EventType.None) {                readValueAndNotifyListenersInBackground();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    notifyListenerOfStateChanged(newState);    if (newState.isConnected()) {        try {            readValueAndNotifyListenersInBackground();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                    }    }}
1
public byte[] getValue()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length);}
0
public VersionedValue<byte[]> getVersionedValue()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return new VersionedValue<byte[]>(localCopy.getVersion(), Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length));}
0
public void setValue(byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    Stat result = client.setData().forPath(path, newValue);    updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));}
0
public boolean trySetValue(byte[] newValue) throws Exception
{    return trySetValue(currentValue.get(), newValue);}
0
public boolean trySetValue(VersionedValue<byte[]> previous, byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    VersionedValue<byte[]> current = currentValue.get();    if (previous.getVersion() != current.getVersion() || !Arrays.equals(previous.getValue(), current.getValue())) {        return false;    }    try {        Stat result = client.setData().withVersion(previous.getVersion()).forPath(path, newValue);        updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));        return true;    } catch (KeeperException.BadVersionException ignore) {        }    readValue();    return false;}
0
private void updateValue(int version, byte[] bytes)
{    while (true) {        VersionedValue<byte[]> current = currentValue.get();        if (current.getVersion() >= version) {                        return;        }        if (currentValue.compareAndSet(current, new VersionedValue<byte[]>(version, bytes))) {                        return;        }        }}
0
public ListenerContainer<SharedValueListener> getListenable()
{    return listeners;}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    try {        client.create().creatingParentContainersIfNeeded().forPath(path, seedValue);    } catch (KeeperException.NodeExistsException ignore) {        }    readValue();}
0
public void close() throws IOException
{    state.set(State.CLOSED);    client.removeWatchers();    client.getConnectionStateListenable().removeListener(connectionStateListener);    listeners.clear();}
0
private void readValue() throws Exception
{    Stat localStat = new Stat();    byte[] bytes = client.getData().storingStatIn(localStat).usingWatcher(watcher).forPath(path);    updateValue(localStat.getVersion(), bytes);}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        updateValue(event.getStat().getVersion(), event.getData());        notifyListeners();    }}
0
private void readValueAndNotifyListenersInBackground() throws Exception
{    client.getData().usingWatcher(watcher).inBackground(upadateAndNotifyListenerCallback).forPath(path);}
0
private void notifyListeners()
{    final byte[] localValue = getValue();    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            try {                listener.valueHasChanged(SharedValue.this, localValue);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }            return null;        }    });}
1
public Void apply(SharedValueListener listener)
{    try {        listener.valueHasChanged(SharedValue.this, localValue);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
1
private void notifyListenerOfStateChanged(final ConnectionState newState)
{    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            listener.stateChanged(client, newState);            return null;        }    });}
0
public Void apply(SharedValueListener listener)
{    listener.stateChanged(client, newState);    return null;}
0
public int getVersion()
{    return version;}
0
public T getValue()
{    return value;}
0
public void testListenersReconnectedIsOK() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server = new TestingServer(server.getPort());        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(node);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
public void testConnectionStateListener() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(timing.milliseconds()));    try {        client.start();        final BlockingQueue<ConnectionState> stateVector = Queues.newLinkedBlockingQueue(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                stateVector.offer(newState);            }        };        Timing waitingTiming = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener);        server = new TestingServer(server.getPort());        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);        server.restart();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        server.close();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    stateVector.offer(newState);}
0
public void testConnectionStateListener() throws Exception
{    server.stop();    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        timing.sleepABit();        LeaderSelectorListener listenerLeader = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listenerLeader);        selector.autoRequeue();        selector.start();        final BlockingQueue<ConnectionState> listenerSequence = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener1 = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                listenerSequence.add(newState);            }        };        Timing forWaiting = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener1);                server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);                server.stop();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);                server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);                server.close();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
1
public void takeLeadership(CuratorFramework client) throws Exception
{    Thread.currentThread().join();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    listenerSequence.add(newState);}
0
public void testWithError() throws Exception
{    final int FACTOR = 100;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AtomicValue<Long> value = new MutableAtomicValue<Long>(0L, (long) FACTOR, true);        final AtomicReference<AtomicValue<Long>> fakeValueRef = new AtomicReference<AtomicValue<Long>>(value);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/", null, null) {            @Override            public AtomicValue<Long> trySet(Long newValue) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> get() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> increment() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> decrement() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> add(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> subtract(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public void forceSet(Long newValue) throws Exception {            }            @Override            public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception {                return fakeValueRef.get();            }        };        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, FACTOR);        for (int i = 0; i < FACTOR; ++i) {            value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);            if (i == 0) {                MutableAtomicValue<Long> badValue = new MutableAtomicValue<Long>(0L, 0L);                badValue.succeeded = false;                fakeValueRef.set(badValue);            }        }        value = cachedLong.next();        Assert.assertFalse(value.succeeded());    } finally {        client.close();    }}
0
public AtomicValue<Long> trySet(Long newValue) throws Exception
{    return fakeValueRef.get();}
0
public AtomicValue<Long> get() throws Exception
{    return fakeValueRef.get();}
0
public AtomicValue<Long> increment() throws Exception
{    return fakeValueRef.get();}
0
public AtomicValue<Long> decrement() throws Exception
{    return fakeValueRef.get();}
0
public AtomicValue<Long> add(Long delta) throws Exception
{    return fakeValueRef.get();}
0
public AtomicValue<Long> subtract(Long delta) throws Exception
{    return fakeValueRef.get();}
0
public void forceSet(Long newValue) throws Exception
{}
0
public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception
{    return fakeValueRef.get();}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, 100);        for (long i = 0; i < 200; ++i) {            AtomicValue<Long> value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);        }    } finally {        client.close();    }}
0
public void testCorruptedValue() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/counter", "foo".getBytes());        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {            dal.get().postValue();        } catch (BufferUnderflowException e) {            Assert.fail("", e);        } catch (BufferOverflowException e) {            Assert.fail("", e);        } catch (RuntimeException e) {                }    } finally {        client.close();    }}
0
public void testCompareAndSetWithFreshInstance() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        AtomicValue<Long> result = dal.compareAndSet(0L, 1L);        Assert.assertFalse(result.succeeded());        Assert.assertTrue(dal.initialize(0L));        result = dal.compareAndSet(0L, 1L);        Assert.assertTrue(result.succeeded());        Assert.assertFalse(dal.initialize(0L));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCompareAndSet() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean doIncrement = new AtomicBoolean(false);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1)) {            @Override            public byte[] valueToBytes(Long newValue) {                if (doIncrement.get()) {                    DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));                    try {                                                inc.increment();                    } catch (Exception e) {                        throw new Error(e);                    }                }                return super.valueToBytes(newValue);            }        };        dal.forceSet(1L);        Assert.assertTrue(dal.compareAndSet(1L, 5L).succeeded());        Assert.assertFalse(dal.compareAndSet(1L, 5L).succeeded());        doIncrement.set(true);        Assert.assertFalse(dal.compareAndSet(5L, 10L).succeeded());    } finally {        client.close();    }}
0
public byte[] valueToBytes(Long newValue)
{    if (doIncrement.get()) {        DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {                        inc.increment();        } catch (Exception e) {            throw new Error(e);        }    }    return super.valueToBytes(newValue);}
0
public void testForceSet() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        ExecutorService executorService = Executors.newFixedThreadPool(2);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.increment();                    Thread.sleep(10);                }                return null;            }        });        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.forceSet(0L);                    Thread.sleep(10);                }                return null;            }        });        Assert.assertTrue(dal.get().preValue() < 10);    } finally {        client.close();    }}
0
public Object call() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.increment();        Thread.sleep(10);    }    return null;}
0
public Object call() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.forceSet(0L);        Thread.sleep(10);    }    return null;}
0
public void testSimulation() throws Exception
{    final int threadQty = 20;    final int executionQty = 50;    final AtomicInteger optimisticTries = new AtomicInteger();    final AtomicInteger promotedLockTries = new AtomicInteger();    final AtomicInteger failures = new AtomicInteger();    final AtomicInteger errors = new AtomicInteger();    final SummaryStatistics timingStats = new SynchronizedSummaryStatistics();    List<Future<Void>> procs = Lists.newArrayList();    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    for (int i = 0; i < threadQty; ++i) {        Callable<Void> proc = new Callable<Void>() {            @Override            public Void call() throws Exception {                doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);                return null;            }        };        procs.add(executorService.submit(proc));    }    for (Future<Void> f : procs) {        f.get();    }    System.out.println("OptimisticTries: " + optimisticTries.get());    System.out.println("PromotedLockTries: " + promotedLockTries.get());    System.out.println("Failures: " + failures.get());    System.out.println("Errors: " + errors.get());    System.out.println();    System.out.println("Avg time: " + timingStats.getMean());    System.out.println("Max time: " + timingStats.getMax());    System.out.println("Min time: " + timingStats.getMin());    System.out.println("Qty: " + timingStats.getN());    Assert.assertEquals(errors.get(), 0);    Assert.assertTrue(optimisticTries.get() > 0);    Assert.assertTrue(promotedLockTries.get() > 0);}
0
public Void call() throws Exception
{    doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);    return null;}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/foo/bar/counter", new RetryOneTime(1));        AtomicValue<Long> value = dal.increment();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 1L);        value = dal.decrement();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 1L);        Assert.assertEquals(value.postValue().longValue(), 0L);        value = dal.add(10L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 10L);        value = dal.subtract(5L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 10L);        Assert.assertEquals(value.postValue().longValue(), 5L);    } finally {        client.close();    }}
0
private void doSimulation(int executionQty, SummaryStatistics timingStats, AtomicInteger optimisticTries, AtomicInteger promotedLockTries, AtomicInteger failures, AtomicInteger errors) throws Exception
{    Random random = new Random();    long previousValue = -1;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3, 3);        PromotedToLock.Builder builder = PromotedToLock.builder().lockPath("/lock").retryPolicy(retryPolicy);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", retryPolicy, builder.build());        for (int i = 0; i < executionQty; ++i) {            Thread.sleep(random.nextInt(10));            long start = System.currentTimeMillis();            AtomicValue<Long> value = dal.increment();            long elapsed = System.currentTimeMillis() - start;            timingStats.addValue(elapsed);            if (value.succeeded()) {                if (value.postValue() <= previousValue) {                    errors.incrementAndGet();                }                previousValue = value.postValue();            } else {                failures.incrementAndGet();            }            optimisticTries.addAndGet(value.getStats().getOptimisticTries());            promotedLockTries.addAndGet(value.getStats().getPromotedLockTries());        }    } finally {        client.close();    }}
0
public void testServerCrash() throws Exception
{    final int TIMEOUT = 1000;    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(TIMEOUT).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        final ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(TIMEOUT / 2);                server.stop();                return null;            }        });        barrier.waitOnBarrier(TIMEOUT * 2, TimeUnit.SECONDS);        future.get();        Assert.fail();    } catch (KeeperException.ConnectionLossException expected) {        } finally {        client.close();    }}
0
public Object call() throws Exception
{    Thread.sleep(TIMEOUT / 2);    server.stop();    return null;}
0
public void testMultiClient() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.setBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        List<Future<Object>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (final CuratorFramework c : new CuratorFramework[] { client1, client2 }) {            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    c.start();                    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");                    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);                    return null;                }            });            futures.add(future);        }        Thread.sleep(1000);        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.removeBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        for (Future<Object> f : futures) {            f.get();        }    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
0
public Object call() throws Exception
{    c.start();    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);    return null;}
0
public void testNoBarrier() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));                ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                barrier.waitOnBarrier();                return "";            }        });        Assert.assertTrue(future.get(10, TimeUnit.SECONDS) != null);    } finally {        client.close();    }}
0
public Object call() throws Exception
{    barrier.waitOnBarrier();    return "";}
0
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        ExecutorService service = Executors.newSingleThreadExecutor();        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(1000);                barrier.removeBarrier();                return null;            }        });        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));    } finally {        client.close();    }}
0
public Object call() throws Exception
{    Thread.sleep(1000);    barrier.removeBarrier();    return null;}
0
public void testMultiClient() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch postEnterLatch = new CountDownLatch(QTY);    final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);    final AtomicInteger count = new AtomicInteger(0);    final AtomicInteger max = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < QTY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                try {                    client.start();                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                } finally {                    CloseableUtils.closeQuietly(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> f : futures) {        f.get();    }    Assert.assertEquals(count.get(), 0);    Assert.assertEquals(max.get(), QTY);}
0
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);        Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));        synchronized (TestDistributedDoubleBarrier.this) {            int thisCount = count.incrementAndGet();            if (thisCount > max.get()) {                max.set(thisCount);            }        }        postEnterLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));        Assert.assertEquals(count.get(), QTY);        Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));        count.decrementAndGet();        postLeaveLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
0
public void testOverSubscribed() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService service = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(service);    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch latch = new CountDownLatch(1);        for (int i = 0; i < (QTY + 1); ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {                        @Override                        protected List<String> getChildrenForEntering() throws Exception {                            semaphore.release();                            Assert.assertTrue(timing.awaitLatch(latch));                            return super.getChildrenForEntering();                        }                    };                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    return null;                }            });        }                Assert.assertTrue(semaphore.tryAcquire(QTY + 1, timing.seconds(), TimeUnit.SECONDS));        latch.countDown();        for (int i = 0; i < (QTY + 1); ++i) {                        completionService.take().get();        }    } finally {        service.shutdown();        CloseableUtils.closeQuietly(client);    }}
0
public Void call() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {        @Override        protected List<String> getChildrenForEntering() throws Exception {            semaphore.release();            Assert.assertTrue(timing.awaitLatch(latch));            return super.getChildrenForEntering();        }    };    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));    return null;}
0
protected List<String> getChildrenForEntering() throws Exception
{    semaphore.release();    Assert.assertTrue(timing.awaitLatch(latch));    return super.getChildrenForEntering();}
0
public void testBasic() throws Exception
{    final Timing timing = new Timing();    final List<Closeable> closeables = Lists.newArrayList();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        closeables.add(client);        client.start();        final CountDownLatch postEnterLatch = new CountDownLatch(QTY);        final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);        final AtomicInteger count = new AtomicInteger(0);        final AtomicInteger max = new AtomicInteger(0);        List<Future<Void>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < QTY; ++i) {            Future<Void> future = service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));                    return null;                }            });            futures.add(future);        }        for (Future<Void> f : futures) {            f.get();        }        Assert.assertEquals(count.get(), 0);        Assert.assertEquals(max.get(), QTY);    } finally {        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public Void call() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    synchronized (TestDistributedDoubleBarrier.this) {        int thisCount = count.incrementAndGet();        if (thisCount > max.get()) {            max.set(thisCount);        }    }    postEnterLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postEnterLatch));    Assert.assertEquals(count.get(), QTY);    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));    count.decrementAndGet();    postLeaveLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));    return null;}
0
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{        if (event.getData() != null && event.getData().getPath().startsWith("/zookeeper")) {        return;    }    events.add(event);}
0
public void unhandledError(String message, Throwable e)
{    hadBackgroundException.set(true);    e.printStackTrace(System.err);}
0
protected TreeCache newTreeCacheWithListeners(CuratorFramework client, String path)
{    TreeCache result = new TreeCache(client, path);    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
0
protected TreeCache buildWithListeners(TreeCache.Builder builder)
{    TreeCache result = builder.build();    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
0
public void setup() throws Exception
{    super.setup();    initCuratorFramework();}
0
 void initCuratorFramework()
{    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    client.getUnhandledErrorListenable().addListener(errorListener);}
0
public void teardown() throws Exception
{    try {        try {            Assert.assertFalse(hadBackgroundException.get(), "Background exceptions were thrown, see stderr for details");            assertNoMoreEvents();        } finally {            CloseableUtils.closeQuietly(cache);            TestCleanState.closeAndTestClean(client);        }    } finally {        super.teardown();    }}
0
 void assertNoMoreEvents() throws InterruptedException
{    timing.sleepABit();    Assert.assertTrue(events.isEmpty(), String.format("Expected no events, found %d; first event: %s", events.size(), events.peek()));}
0
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType) throws InterruptedException
{    return assertEvent(expectedType, null);}
0
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, null);}
0
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, expectedData, false);}
0
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData, boolean ignoreConnectionEvents) throws InterruptedException
{    TreeCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(event, String.format("Expected type: %s, path: %s", expectedType, expectedPath));    if (ignoreConnectionEvents) {        if ((event.getType() == TreeCacheEvent.Type.CONNECTION_SUSPENDED) || (event.getType() == TreeCacheEvent.Type.CONNECTION_LOST) || (event.getType() == TreeCacheEvent.Type.CONNECTION_RECONNECTED)) {            return assertEvent(expectedType, expectedPath, expectedData, ignoreConnectionEvents);        }    }    String message = event.toString();    Assert.assertEquals(event.getType(), expectedType, message);    if (expectedPath == null) {        Assert.assertNull(event.getData(), message);    } else {        Assert.assertNotNull(event.getData(), message);        Assert.assertEquals(event.getData().getPath(), expectedPath, message);    }    if (expectedData != null) {        Assert.assertEquals(event.getData().getData(), expectedData, message);    }    return event;}
0
public void testEventOrdering() throws Exception
{    ExecutorService executorService = Executors.newFixedThreadPool(THREAD_QTY);    BlockingQueue<Event> events = Queues.newLinkedBlockingQueue();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    T cache = null;    try {        client.start();        client.create().forPath("/root");        cache = newCache(client, "/root", events);        final Random random = new Random();        final Callable<Void> task = new Callable<Void>() {            @Override            public Void call() throws Exception {                for (int i = 0; i < ITERATIONS; ++i) {                    String node = "/root/" + random.nextInt(NODE_QTY);                    try {                        switch(random.nextInt(3)) {                            default:                            case 0:                                client.create().forPath(node);                                break;                            case 1:                                client.setData().forPath(node, "new".getBytes());                                break;                            case 2:                                client.delete().forPath(node);                                break;                        }                    } catch (KeeperException ignore) {                                        }                }                return null;            }        };        final CountDownLatch latch = new CountDownLatch(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            Callable<Void> wrapped = new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        return task.call();                    } finally {                        latch.countDown();                    }                }            };            executorService.submit(wrapped);        }        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        List<Event> localEvents = Lists.newArrayList();        int eventSuggestedQty = 0;        while (events.size() > 0) {            Event event = timing.takeFromQueue(events);            localEvents.add(event);            eventSuggestedQty += (event.eventType == EventType.ADDED) ? 1 : -1;        }        int actualQty = getActualQty(cache);        Assert.assertEquals(actualQty, eventSuggestedQty, String.format("actual %s expected %s:\n %s", actualQty, eventSuggestedQty, asString(localEvents)));    } finally {        executorService.shutdownNow();                executorService.awaitTermination(timing.milliseconds(), TimeUnit.MILLISECONDS);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
0
public Void call() throws Exception
{    for (int i = 0; i < ITERATIONS; ++i) {        String node = "/root/" + random.nextInt(NODE_QTY);        try {            switch(random.nextInt(3)) {                default:                case 0:                    client.create().forPath(node);                    break;                case 1:                    client.setData().forPath(node, "new".getBytes());                    break;                case 2:                    client.delete().forPath(node);                    break;            }        } catch (KeeperException ignore) {                }    }    return null;}
0
public Void call() throws Exception
{    try {        return task.call();    } finally {        latch.countDown();    }}
0
private String asString(List<Event> events)
{    int qty = 0;    StringBuilder str = new StringBuilder();    for (Event event : events) {        qty += (event.eventType == EventType.ADDED) ? 1 : -1;        str.append(event.eventType).append(" ").append(event.path).append(" @ ").append(event.time - start).append(' ').append(qty);        str.append("\n");    }    return str.toString();}
0
public void testDeleteThenCreate() throws Exception
{    NodeCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final Semaphore semaphore = new Semaphore(0);        cache = new NodeCache(client, "/test/foo");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        cache.start(true);        Assert.assertEquals(cache.getCurrentData().getData(), "one".getBytes());        client.delete().forPath("/test/foo");        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        client.create().forPath("/test/foo", "two".getBytes());        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        Throwable t = error.get();        if (t != null) {            Assert.fail("Assert", t);        }        Assert.assertEquals(cache.getCurrentData().getData(), "two".getBytes());        cache.close();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void unhandledError(String message, Throwable e)
{    error.set(e);}
0
public void nodeChanged() throws Exception
{    semaphore.release();}
0
public void testRebuildAgainstOtherProcesses() throws Exception
{    Timing2 timing2 = new Timing2();    NodeCache cache = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        cache = new NodeCache(client, "/test/snafu");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        cache.rebuildTestExchanger = new Exchanger<Object>();        ExecutorService service = Executors.newSingleThreadExecutor();        final NodeCache finalCache = cache;        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                                client.setData().forPath("/test/snafu", "other".getBytes());                ChildData currentData = finalCache.getCurrentData();                Assert.assertNotNull(currentData);                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                return null;            }        });        cache.start(false);        future.get();        Assert.assertTrue(timing2.awaitLatch(latch));        Assert.assertNotNull(cache.getCurrentData());        Assert.assertEquals(cache.getCurrentData().getData(), "other".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void nodeChanged() throws Exception
{    latch.countDown();}
0
public Object call() throws Exception
{    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);        client.setData().forPath("/test/snafu", "other".getBytes());    ChildData currentData = finalCache.getCurrentData();    Assert.assertNotNull(currentData);    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);    return null;}
0
public void testKilledSession() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/node", "start".getBytes());        cache = new NodeCache(client, "/test/node");        cache.start(true);        final CountDownLatch latch = new CountDownLatch(1);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(cache.getCurrentData().getData(), "start".getBytes());        client.setData().forPath("/test/node", "new data".getBytes());        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void nodeChanged() throws Exception
{    latch.countDown();}
0
public void testBasics() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        cache = new NodeCache(client, "/test/node");        cache.start(true);        final Semaphore semaphore = new Semaphore(0);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        Assert.assertNull(cache.getCurrentData());        client.create().forPath("/test/node", "a".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "a".getBytes());        client.setData().forPath("/test/node", "b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "b".getBytes());        client.delete().forPath("/test/node");        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertNull(cache.getCurrentData());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void nodeChanged() throws Exception
{    semaphore.release();}
0
public void testParentContainerMissing() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true);    try {        client.start();                client.blockUntilConnected();        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client.create().forPath("/a/b/test/one");        client.create().forPath("/a/b/test/two");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        client.delete().forPath("/a/b/test/one");        client.delete().forPath("/a/b/test/two");        client.delete().forPath("/a/b/test");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        timing.sleepABit();        client.create().creatingParentContainersIfNeeded().forPath("/a/b/test/new");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
0
public void testInitializedEvenIfChildDeleted() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true) {        @Override        void getDataAndStat(final String fullPath) throws Exception {                        client.delete().forPath("/a/b/test/one");            super.getDataAndStat(fullPath);        }    };    Timing timing = new Timing();    try {        client.start();        final CountDownLatch cacheInitialized = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    cacheInitialized.countDown();                }            }        };        cache.getListenable().addListener(listener);        client.create().creatingParentsIfNeeded().forPath("/a/b/test/one");        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(cacheInitialized));        Assert.assertEquals(cache.getCurrentData().size(), 0);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
0
 void getDataAndStat(final String fullPath) throws Exception
{        client.delete().forPath("/a/b/test/one");    super.getDataAndStat(fullPath);}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        cacheInitialized.countDown();    }}
0
public void testWithBadConnect() throws Exception
{    final int serverPort = server.getPort();    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryOneTime(1));    try {        client.start();        final CountDownLatch ensurePathLatch = new CountDownLatch(1);        PathChildrenCache cache = new PathChildrenCache(client, "/", true) {            @Override            protected void ensurePath() throws Exception {                try {                    super.ensurePath();                } catch (Exception e) {                    ensurePathLatch.countDown();                    throw e;                }            }        };        final CountDownLatch addedLatch = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {                    addedLatch.countDown();                }            }        };        cache.getListenable().addListener(listener);        cache.start();        Assert.assertTrue(timing.awaitLatch(ensurePathLatch));        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        });        server = new TestingServer(serverPort, true);        Assert.assertTrue(timing.awaitLatch(connectedLatch));        client.create().creatingParentContainersIfNeeded().forPath("/baz", new byte[] { 1, 2, 3 });        assertNotNull("/baz does not exist", client.checkExists().forPath("/baz"));        Assert.assertTrue(timing.awaitLatch(addedLatch));        assertNotNull("cache doesn't see /baz", cache.getCurrentData("/baz"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
protected void ensurePath() throws Exception
{    try {        super.ensurePath();    } catch (Exception e) {        ensurePathLatch.countDown();        throw e;    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {        addedLatch.countDown();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
0
public void testPostInitializedForEmpty() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    latch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        latch.countDown();    }}
0
public void testAsyncInitialPopulation() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        client.create().forPath("/test/one", "hey there".getBytes());        final BlockingQueue<PathChildrenCacheEvent> events = new LinkedBlockingQueue<PathChildrenCacheEvent>();        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.offer(event);            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        PathChildrenCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.CHILD_ADDED);        event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);        Assert.assertEquals(event.getInitialData().size(), 1);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.offer(event);}
0
public void testChildrenInitialized() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        final CountDownLatch initLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    initLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertTrue(timing.awaitLatch(initLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        initLatch.countDown();    }}
0
public void testChildrenInitializedNormal() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.NORMAL);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
0
public void testUpdateWhenNotCachingData() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch updatedLatch = new CountDownLatch(1);        final CountDownLatch addedLatch = new CountDownLatch(1);        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                    updatedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.create().forPath("/test/foo", "first".getBytes());        Assert.assertTrue(timing.awaitLatch(addedLatch));        client.setData().forPath("/test/foo", "something new".getBytes());        Assert.assertTrue(timing.awaitLatch(updatedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        updatedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
0
public void testEnsurePath() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try (PathChildrenCache cache = new PathChildrenCache(client, "/one/two/three", false)) {            cache.start();            timing.sleepABit();            try {                client.create().forPath("/one/two/three/four");            } catch (KeeperException.NoNodeException e) {                Assert.fail("Path should exist", e);            }        }        timing.sleepABit();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testDeleteThenCreate() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final CountDownLatch removedLatch = new CountDownLatch(1);        final CountDownLatch postRemovedLatch = new CountDownLatch(1);        final CountDownLatch dataLatch = new CountDownLatch(1);        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                        removedLatch.countDown();                        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));                    } else {                        try {                            Assert.assertEquals(event.getData().getData(), "two".getBytes());                        } finally {                            dataLatch.countDown();                        }                    }                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            client.delete().forPath("/test/foo");            Assert.assertTrue(timing.awaitLatch(removedLatch));            client.create().forPath("/test/foo", "two".getBytes());            postRemovedLatch.countDown();            Assert.assertTrue(timing.awaitLatch(dataLatch));            Throwable t = error.get();            if (t != null) {                Assert.fail("Assert", t);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void unhandledError(String message, Throwable e)
{    error.set(e);}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));    } else {        try {            Assert.assertEquals(event.getData().getData(), "two".getBytes());        } finally {            dataLatch.countDown();        }    }}
0
public void testRebuildAgainstOtherProcesses() throws Exception
{    Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo");        client.create().forPath("/test/bar");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch addedLatch = new CountDownLatch(2);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                        if (event.getData().getPath().equals("/test/test")) {                            addedLatch.countDown();                        }                    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                        if (event.getData().getPath().equals("/test/snafu")) {                            addedLatch.countDown();                        }                    }                }            });            cache.rebuildTestExchanger = new Exchanger<Object>();            ExecutorService service = Executors.newSingleThreadExecutor();            final AtomicReference<String> deletedPath = new AtomicReference<String>();            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    cache.rebuildTestExchanger.exchange(new Object());                                        client.create().forPath("/test/test");                    List<ChildData> currentData = cache.getCurrentData();                    Assert.assertTrue(currentData.size() > 0);                                        client.delete().forPath(currentData.get(0).getPath());                    deletedPath.set(currentData.get(0).getPath());                    cache.rebuildTestExchanger.exchange(new Object());                    ChildData childData = null;                    while (childData == null) {                        childData = cache.getCurrentData("/test/snafu");                        Thread.sleep(1000);                    }                    Assert.assertEquals(childData.getData(), "original".getBytes());                    client.setData().forPath("/test/snafu", "grilled".getBytes());                    cache.rebuildTestExchanger.exchange(new Object());                    return null;                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            future.get();            Assert.assertTrue(timing.awaitLatch(addedLatch));            Assert.assertNotNull(cache.getCurrentData("/test/test"));            Assert.assertNull(cache.getCurrentData(deletedPath.get()));            Assert.assertEquals(cache.getCurrentData("/test/snafu").getData(), "grilled".getBytes());        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        if (event.getData().getPath().equals("/test/test")) {            addedLatch.countDown();        }    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        if (event.getData().getPath().equals("/test/snafu")) {            addedLatch.countDown();        }    }}
0
public Object call() throws Exception
{    cache.rebuildTestExchanger.exchange(new Object());        client.create().forPath("/test/test");    List<ChildData> currentData = cache.getCurrentData();    Assert.assertTrue(currentData.size() > 0);        client.delete().forPath(currentData.get(0).getPath());    deletedPath.set(currentData.get(0).getPath());    cache.rebuildTestExchanger.exchange(new Object());    ChildData childData = null;    while (childData == null) {        childData = cache.getCurrentData("/test/snafu");        Thread.sleep(1000);    }    Assert.assertEquals(childData.getData(), "original".getBytes());    client.setData().forPath("/test/snafu", "grilled".getBytes());    cache.rebuildTestExchanger.exchange(new Object());    return null;}
0
public void testIssue27() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 3));        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
0
public void testIssue27Alt() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
0
public void testKilledSession() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        cache.start();        final CountDownLatch childAddedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final CountDownLatch removedLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    childAddedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {                    lostLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                    removedLatch.countDown();                }            }        });        client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());        Assert.assertTrue(timing.awaitLatch(childAddedLatch));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(lostLatch));        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertTrue(timing.awaitLatch(removedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        childAddedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {        lostLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();    }}
0
public void testModes() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        for (boolean cacheData : new boolean[] { false, true }) {            internalTestMode(client, cacheData);            client.delete().forPath("/test/one");            client.delete().forPath("/test/two");        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testRebuildNode() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one", "one".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        final AtomicInteger counter = new AtomicInteger();        final Semaphore semaphore = new Semaphore(1);        cache = new PathChildrenCache(client, "/test", true) {            @Override            void getDataAndStat(String fullPath) throws Exception {                semaphore.acquire();                counter.incrementAndGet();                super.getDataAndStat(fullPath);                latch.countDown();            }        };        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        Assert.assertTrue(timing.awaitLatch(latch));        int saveCounter = counter.get();        client.setData().forPath("/test/one", "alt".getBytes());        cache.rebuildNode("/test/one");        Assert.assertEquals(cache.getCurrentData("/test/one").getData(), "alt".getBytes());        Assert.assertEquals(saveCounter, counter.get());        semaphore.release(1000);        timing.sleepABit();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
0
 void getDataAndStat(String fullPath) throws Exception
{    semaphore.acquire();    counter.incrementAndGet();    super.getDataAndStat(fullPath);    latch.countDown();}
0
private void internalTestMode(CuratorFramework client, boolean cacheData) throws Exception
{    try (PathChildrenCache cache = new PathChildrenCache(client, "/test", cacheData)) {        final CountDownLatch latch = new CountDownLatch(2);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.countDown();                }            }        });        cache.start();        client.create().forPath("/test/one", "one".getBytes());        client.create().forPath("/test/two", "two".getBytes());        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        for (ChildData data : cache.getCurrentData()) {            if (cacheData) {                Assert.assertNotNull(data.getData());                Assert.assertNotNull(data.getStat());            } else {                Assert.assertNull(data.getData());                Assert.assertNotNull(data.getStat());            }        }    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.countDown();    }}
0
public void testBasics() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);            client.setData().forPath("/test/one", "sup!".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");            client.delete().forPath("/test/one");            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
0
public void testBasicsOnTwoCachesWithSameExecutor() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        final ExecutorService exec = Executors.newSingleThreadExecutor();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            final BlockingQueue<PathChildrenCacheEvent.Type> events2 = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();            try (PathChildrenCache cache2 = new PathChildrenCache(client, "/test", true, false, exec)) {                cache2.getListenable().addListener(new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if (event.getData().getPath().equals("/test/one")) {                            events2.offer(event.getType());                        }                    }                });                cache2.start();                client.create().forPath("/test/one", "hey there".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                client.setData().forPath("/test/one", "sup!".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");                Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");                client.delete().forPath("/test/one");                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events2.offer(event.getType());    }}
0
public void testDeleteNodeAfterCloseDoesntCallExecutor() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            cache.rebuild();            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");            Assert.assertTrue(exec.isExecuteCalled());            exec.setExecuteCalled(false);        }        Assert.assertFalse(exec.isExecuteCalled());        client.delete().forPath("/test/one");        timing.sleepABit();        Assert.assertFalse(exec.isExecuteCalled());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testInterruptedOperationOnShutdown() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 30000, 30000, new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", false) {            @Override            protected void handleException(Throwable e) {                latch.countDown();            }        }) {            cache.start();            cache.offerOperation(new Operation() {                @Override                public void invoke() throws Exception {                    Thread.sleep(5000);                }            });            Thread.sleep(1000);        }        latch.await(5, TimeUnit.SECONDS);        Assert.assertTrue(latch.getCount() == 1, "Unexpected exception occurred");    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
protected void handleException(Throwable e)
{    latch.countDown();}
0
public void invoke() throws Exception
{    Thread.sleep(5000);}
0
protected int getActualQty(PathChildrenCache cache)
{    return cache.getCurrentData().size();}
0
protected PathChildrenCache newCache(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    PathChildrenCache cache = new PathChildrenCache(client, path, false);    PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                events.add(new Event(EventType.ADDED, event.getData().getPath()));            }            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                events.add(new Event(EventType.DELETED, event.getData().getPath()));            }        }    };    cache.getListenable().addListener(listener);    cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);    return cache;}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        events.add(new Event(EventType.ADDED, event.getData().getPath()));    }    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        events.add(new Event(EventType.DELETED, event.getData().getPath()));    }}
0
public void testMissedDelete() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client1 = null;    CuratorFramework client2 = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();                InstanceSpec client1Instance = cluster.getInstances().iterator().next();        client1 = CuratorFrameworkFactory.newClient(client1Instance.getConnectString(), 1000, 1000, new RetryOneTime(1));        cache = new PathChildrenCache(client1, "/test", true);        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        client2 = CuratorFrameworkFactory.newClient(cluster.getConnectString(), 1000, 1000, new RetryOneTime(1));        client1.start();        client2.start();        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client2.create().creatingParentsIfNeeded().forPath("/test/node", "first".getBytes());        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        cluster.killServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_LOST);        client2.delete().forPath("/test/node");        client2.create().forPath("/test/node", "second".getBytes());        cluster.restartServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);                Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(cluster);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
0
public void testServerLoss() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    PathChildrenCache cache = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.start();        final CountDownLatch resetLatch = new CountDownLatch(1);        final CountDownLatch reconnectLatch = new CountDownLatch(1);        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(3));        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {                    resetLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.get().countDown();                }            }        });        client.create().forPath("/test/one");        client.create().forPath("/test/two");        client.create().forPath("/test/three");        Assert.assertTrue(latch.get().await(10, TimeUnit.SECONDS));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.awaitLatch(reconnectLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {        resetLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.get().countDown();    }}
0
public void testSelector() throws Exception
{    client.create().forPath("/root");    client.create().forPath("/root/n1-a");    client.create().forPath("/root/n1-b");    client.create().forPath("/root/n1-b/n2-a");    client.create().forPath("/root/n1-b/n2-b");    client.create().forPath("/root/n1-b/n2-b/n3-a");    client.create().forPath("/root/n1-c");    client.create().forPath("/root/n1-d");    TreeCacheSelector selector = new TreeCacheSelector() {        @Override        public boolean traverseChildren(String fullPath) {            return !fullPath.equals("/root/n1-b/n2-b");        }        @Override        public boolean acceptChild(String fullPath) {            return !fullPath.equals("/root/n1-c");        }    };    cache = buildWithListeners(TreeCache.newBuilder(client, "/root").setSelector(selector));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-d");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-b");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
0
public boolean traverseChildren(String fullPath)
{    return !fullPath.equals("/root/n1-b/n2-b");}
0
public boolean acceptChild(String fullPath)
{    return !fullPath.equals("/root/n1-c");}
0
public void testStartup() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2/sub", "two-sub".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of("sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
0
public void testCreateParents() throws Exception
{    cache = newTreeCacheWithListeners(client, "/one/two/three");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNull(client.checkExists().forPath("/one/two/three"));    cache.close();    cache = buildWithListeners(TreeCache.newBuilder(client, "/one/two/three").setCreateParentNodes(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/one/two/three");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));}
0
public void testStartEmpty() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
0
public void testStartEmptyDeeper() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test/foo/bar");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().creatingParentsIfNeeded().forPath("/test/foo");    assertNoMoreEvents();    client.create().forPath("/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertNoMoreEvents();}
0
public void testDepth0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(0));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/1"));    Assert.assertNull(cache.getCurrentChildren("/test/1"));    Assert.assertNull(cache.getCurrentData("/test/non_exist"));}
0
public void testDepth1() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
0
public void testDepth1Deeper() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo");    client.create().forPath("/test/foo/bar");    client.create().forPath("/test/foo/bar/1", "one".getBytes());    client.create().forPath("/test/foo/bar/2", "two".getBytes());    client.create().forPath("/test/foo/bar/3", "three".getBytes());    client.create().forPath("/test/foo/bar/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test/foo/bar").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
0
public void testAsyncInitialPopulation() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
0
public void testFromRoot() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
0
public void testFromRootWithDepth() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/one"));    Assert.assertNull(cache.getCurrentChildren("/test/one"));}
0
public void testWithNamespace() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
0
public void testWithNamespaceAtRoot() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/foo");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/").keySet(), ImmutableSet.of("foo", "test"));    Assert.assertEquals(cache.getCurrentChildren("/foo").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
0
public void testSyncInitialPopulation() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertNoMoreEvents();}
0
public void testChildrenInitialized() throws Exception
{    client.create().forPath("/test", "".getBytes());    client.create().forPath("/test/1", "1".getBytes());    client.create().forPath("/test/2", "2".getBytes());    client.create().forPath("/test/3", "3".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
0
public void testUpdateWhenNotCachingData() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setCacheData(false));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "first".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.setData().forPath("/test/foo", "something new".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/foo");    assertNoMoreEvents();    Assert.assertNotNull(cache.getCurrentData("/test/foo"));        Assert.assertNull(cache.getCurrentData("/test/foo").getData());}
0
public void testDeleteThenCreate() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "one".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "two".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
0
public void testDeleteThenCreateRoot() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test/foo");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
0
public void testKilledSession() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "foo".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/me");    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/me", "data".getBytes(), true);    assertEvent(TreeCacheEvent.Type.INITIALIZED, null, null, true);    assertNoMoreEvents();}
0
public void testBasics() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    client.setData().forPath("/test/one", "sup!".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");    client.delete().forPath("/test/one");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    assertNoMoreEvents();}
0
public void testBasicsWithNoZkWatches() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").disableZkWatches(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    assertNoMoreEvents();}
0
public void testBasicsOnTwoCaches() throws Exception
{    TreeCache cache2 = newTreeCacheWithListeners(client, "/test");        cache2.getListenable().removeListener(eventListener);        final Semaphore semaphore = new Semaphore(0);    cache2.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            semaphore.release();        }    });    try {        client.create().forPath("/test");        cache = newTreeCacheWithListeners(client, "/test");        cache.start();        cache2.start();        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");        assertEvent(TreeCacheEvent.Type.INITIALIZED);        semaphore.acquire(2);        client.create().forPath("/test/one", "hey there".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "hey there");        client.setData().forPath("/test/one", "sup!".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");        client.delete().forPath("/test/one");        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());        Assert.assertNull(cache.getCurrentData("/test/one"));        semaphore.acquire();        Assert.assertNull(cache2.getCurrentData("/test/one"));        assertNoMoreEvents();        Assert.assertEquals(semaphore.availablePermits(), 0);    } finally {        CloseableUtils.closeQuietly(cache2);    }}
0
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    semaphore.release();}
0
public void testDeleteNodeAfterCloseDoesntCallExecutor() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    cache.close();    assertNoMoreEvents();    client.delete().forPath("/test/one");    assertNoMoreEvents();}
0
public void testServerNotStartedYet() throws Exception
{        server.stop();        client.close();    initCuratorFramework();        cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertNoMoreEvents();        server.restart();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
0
public void testErrorListener() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test"));        cache.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if (event.getType() == Type.NODE_UPDATED) {                throw new RuntimeException("Test Exception");            }        }    });    cache.getUnhandledErrorListenable().removeListener(errorListener);    final AtomicBoolean isProcessed = new AtomicBoolean(false);    cache.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {        @Override        public void unhandledError(String message, Throwable e) {            Assert.assertFalse(isProcessed.compareAndSet(false, true));        }    });    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.setData().forPath("/test", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test");    assertNoMoreEvents();}
0
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if (event.getType() == Type.NODE_UPDATED) {        throw new RuntimeException("Test Exception");    }}
0
public void unhandledError(String message, Throwable e)
{    Assert.assertFalse(isProcessed.compareAndSet(false, true));}
0
protected int getActualQty(TreeCache cache)
{    return cache.getCurrentChildren("/root").size();}
0
protected TreeCache newCache(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    TreeCache cache = new TreeCache(client, path);    TreeCacheListener listener = new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {                if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {                    events.add(new Event(EventType.ADDED, event.getData().getPath()));                }                if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {                    events.add(new Event(EventType.DELETED, event.getData().getPath()));                }            }        }    };    cache.getListenable().addListener(listener);    cache.start();    return cache;}
0
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {        if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {            events.add(new Event(EventType.ADDED, event.getData().getPath()));        }        if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {            events.add(new Event(EventType.DELETED, event.getData().getPath()));        }    }}
0
public void testGiantRandomDeepTree() throws Exception
{    doTestGiantRandomDeepTree();}
0
public void testGiantRandomDeepTreeWithDepth() throws Exception
{    withDepth = true;    doTestGiantRandomDeepTree();}
0
private void doTestGiantRandomDeepTree() throws Exception
{    client.create().forPath("/tree", null);    CuratorFramework cl = client.usingNamespace("tree");    if (withDepth) {        cache = buildWithListeners(TreeCache.newBuilder(cl, "/").setMaxDepth(TEST_DEPTH));    } else {        cache = newTreeCacheWithListeners(cl, "/");    }    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    TestNode root = new TestNode("/", null);    int maxDepth = 0;    int adds = 0;    int removals = 0;    int updates = 0;    for (int i = 0; i < ITERATIONS; ++i) {                int depth = 0;        TestNode last = null;        TestNode node = root;        while (!node.children.isEmpty() && random.nextDouble() < DIVE_CHANCE) {                        last = node;            node = Iterables.get(node.children.values(), random.nextInt(node.children.size()));            ++depth;        }        maxDepth = Math.max(depth, maxDepth);                switch(random.nextInt(3)) {            case 0:                                if (node != root && node.children.isEmpty()) {                                        TestNode removed = last.children.remove(ZKPaths.getNodeFromPath(node.fullPath));                    Assert.assertSame(node, removed);                                        cl.delete().forPath(node.fullPath);                                        if (shouldSeeEventAt(node.fullPath)) {                        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, node.fullPath);                    }                    ++removals;                }                break;            case 1:                                byte[] newData = new byte[10];                random.nextBytes(newData);                if (Arrays.equals(node.data, newData)) {                                        continue;                }                                node.data = newData;                                cl.setData().forPath(node.fullPath, node.data);                                if (shouldSeeEventAt(node.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, node.fullPath, node.data);                }                ++updates;                break;            case 2:                                String name = Long.toHexString(random.nextLong());                if (node.children.containsKey(name)) {                                        continue;                }                                byte[] data = new byte[10];                random.nextBytes(data);                TestNode child = new TestNode(ZKPaths.makePath(node.fullPath, name), data);                node.children.put(name, child);                                cl.create().forPath(child.fullPath, child.data);                                if (shouldSeeEventAt(child.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_ADDED, child.fullPath, child.data);                }                ++adds;                break;        }                assertNodeEquals(cache.getCurrentData("/"), root);        assertTreeEquals(cache, root, 0);    }            System.out.println(String.format("maxDepth: %s, adds: %s, removals: %s, updates: %s", maxDepth, adds, removals, updates));    assertNoMoreEvents();}
0
private boolean shouldSeeEventAt(String fullPath)
{    return !withDepth || ZKPaths.split(fullPath).size() <= TEST_DEPTH;}
0
private void assertTreeEquals(TreeCache cache, TestNode expectedNode, int depth)
{    String path = expectedNode.fullPath;    Map<String, ChildData> cacheChildren = cache.getCurrentChildren(path);    Assert.assertNotNull(cacheChildren, path);    if (withDepth && depth == TEST_DEPTH) {        return;    }    Assert.assertEquals(cacheChildren.keySet(), expectedNode.children.keySet(), path);    for (Map.Entry<String, TestNode> entry : expectedNode.children.entrySet()) {        String nodeName = entry.getKey();        ChildData childData = cacheChildren.get(nodeName);        TestNode expectedChild = entry.getValue();        assertNodeEquals(childData, expectedChild);        assertTreeEquals(cache, expectedChild, depth + 1);    }}
0
private static void assertNodeEquals(ChildData actualChild, TestNode expectedNode)
{    String path = expectedNode.fullPath;    Assert.assertNotNull(actualChild, path);    Assert.assertEquals(actualChild.getData(), expectedNode.data, path);}
0
public void startup(ZooKeeperServer zks) throws IOException, InterruptedException
{    super.startup(new ChaosMonkeyZookeeperServer(zks));}
0
public void startup()
{    super.startup();    if (zks instanceof TestingZooKeeperMain.TestZooKeeperServer) {        ((TestingZooKeeperMain.TestZooKeeperServer) zks).noteStartup();    } else {        throw new RuntimeException("Unknown ZooKeeperServer: " + zks.getClass());    }}
0
public void submitRequest(Request si)
{    long remaining = firstError != 0 ? LOCKOUT_DURATION_MS - (System.currentTimeMillis() - firstError) : 0;    if (si.type != ZooDefs.OpCode.createSession && si.type != ZooDefs.OpCode.sync && si.type != ZooDefs.OpCode.ping && firstError != 0 && remaining > 0) {                                ((NIOServerCnxn) si.cnxn).close();        return;    }            super.submitRequest(si);        if ((si.type == ZooDefs.OpCode.create) || (si.type == ZooDefs.OpCode.create2)) {        CreateRequest createRequest = new CreateRequest();        try {            ByteBuffer duplicate = si.request.duplicate();            duplicate.rewind();            ByteBufferInputStream.byteBuffer2Record(duplicate, createRequest);            if (createRequest.getPath().startsWith(CHAOS_ZNODE_PREFIX) && firstError == 0) {                firstError = System.currentTimeMillis();                                                ((NIOServerCnxn) si.cnxn).close();            }        } catch (Exception e) {                        ((NIOServerCnxn) si.cnxn).close();        }    }}
1
public void testAclErrorWithLeader() throws Exception
{    ACLProvider provider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            return ZooDefs.Ids.OPEN_ACL_UNSAFE;        }        @Override        public List<ACL> getAclForPath(String path) {            if (path.equals("/base")) {                try {                    String testDigest = DigestAuthenticationProvider.generateDigest("test:test");                    return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));                } catch (NoSuchAlgorithmException e) {                    e.printStackTrace();                }            }            return getDefaultAcl();        }    };    RetryPolicy retryPolicy = new ExponentialBackoffRetry(timing.milliseconds(), 3);    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).authorization("digest", "test:test".getBytes());    CuratorFramework client = builder.build();    LeaderLatch latch = null;    try {        client.start();        latch = new LeaderLatch(client, "/base");        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.close();        latch = null;        CuratorFramework noAuthClient = CuratorFrameworkFactory.newClient(server.getConnectString(), retryPolicy);        try {            noAuthClient.start();            final CountDownLatch noAuthLatch = new CountDownLatch(1);            UnhandledErrorListener listener = new UnhandledErrorListener() {                @Override                public void unhandledError(String message, Throwable e) {                    if (e instanceof KeeperException.NoAuthException) {                        noAuthLatch.countDown();                    }                }            };            noAuthClient.getUnhandledErrorListenable().addListener(listener);                                    latch = new LeaderLatch(noAuthClient, "/base/second");            latch.start();            Assert.assertTrue(timing.awaitLatch(noAuthLatch));        } finally {            CloseableUtils.closeQuietly(noAuthClient);        }    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
0
public List<ACL> getAclForPath(String path)
{    if (path.equals("/base")) {        try {            String testDigest = DigestAuthenticationProvider.generateDigest("test:test");            return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }    }    return getDefaultAcl();}
0
public void unhandledError(String message, Throwable e)
{    if (e instanceof KeeperException.NoAuthException) {        noAuthLatch.countDown();    }}
0
public void testWithCircuitBreaker() throws Exception
{    final int threadQty = 5;    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    List<Holder> holders = Collections.emptyList();    Timing2 timing = new Timing2();    ConnectionStateListenerManagerFactory managerFactory = ConnectionStateListenerManagerFactory.circuitBreaking(new RetryForever(timing.multiple(2).milliseconds()));    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionStateListenerManagerFactory(managerFactory).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).build();    try {        client.start();        client.create().forPath("/hey");        Semaphore lostSemaphore = new Semaphore(0);        ConnectionStateListener unProxiedListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostSemaphore.release();                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        client.getConnectionStateListenable().addListener(unProxiedListener);        holders = IntStream.range(0, threadQty).mapToObj(index -> {            Holder holder = new Holder();            holder.latch = new LeaderLatch(client, "/foo/bar/" + index) {                @Override                protected void handleStateChange(ConnectionState newState) {                    holder.stateChanges.offer(newState);                    super.handleStateChange(newState);                }            };            return holder;        }).collect(Collectors.toList());        holders.forEach(holder -> {            executorService.submit(() -> {                holder.latch.start();                Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));                holder.isLockedLatch.countDown();                return null;            });            timing.awaitLatch(holder.isLockedLatch);        });        for (        int i = 0;         i < 4;         ++i) {            server.stop();            Assert.assertTrue(timing.acquireSemaphore(lostSemaphore));            server.restart();            timing.sleepABit();        }        for (Holder holder : holders) {            Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.SUSPENDED);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.LOST);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.RECONNECTED);        }    } finally {        holders.forEach(holder -> CloseableUtils.closeQuietly(holder.latch));        CloseableUtils.closeQuietly(client);        executorService.shutdownNow();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostSemaphore.release();    }}
0
public boolean doNotProxy()
{    return true;}
0
protected void handleStateChange(ConnectionState newState)
{    holder.stateChanges.offer(newState);    super.handleStateChange(newState);}
0
public void testUncreatedPathGetLeader() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch = new LeaderLatch(client, "/foo/bar");                latch.getLeader();    }}
0
public void testWatchedNodeDeletedOnReconnect() throws Exception
{    final String latchPath = "/foo/bar";    Timing2 timing = new Timing2();    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch1 = new LeaderLatch(client, latchPath, "1");        try (LeaderLatch latch2 = new LeaderLatch(client, latchPath, "2")) {            latch1.start();            latch1.await();                        latch2.start();            timing.sleepABit();            latch2.debugCheckLeaderShipLatch = new CountDownLatch(1);                        latch1.close();            latch1 = null;                        timing.sleepABit();                        latch2.reset();                        latch2.debugCheckLeaderShipLatch.countDown();            Assert.assertTrue(latch2.await(timing.forSessionSleep().forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            timing.sleepABit();            Assert.assertEquals(client.getChildren().forPath(latchPath).size(), 1);        } finally {            CloseableUtils.closeQuietly(latch1);        }    }}
0
public void testSessionErrorPolicy() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = null;    for (int i = 0; i < 2; ++i) {        boolean isSessionIteration = (i == 0);        try {            client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(10000).sessionTimeoutMs(60000).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(isSessionIteration ? new SessionConnectionStateErrorPolicy() : new StandardConnectionStateErrorPolicy()).build();            final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();            ConnectionStateListener stateListener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    states.add(newState.name());                }            };            client.getConnectionStateListenable().addListener(stateListener);            client.start();            latch = new LeaderLatch(client, "/test");            LeaderLatchListener listener = new LeaderLatchListener() {                @Override                public void isLeader() {                    states.add("true");                }                @Override                public void notLeader() {                    states.add("false");                }            };            latch.addListener(listener);            latch.start();            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            server.stop();            if (isSessionIteration) {                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertNull(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS));            } else {                String s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            }        } finally {            CloseableUtils.closeQuietly(latch);            CloseableUtils.closeQuietly(client);        }    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
0
public void isLeader()
{    states.add("true");}
0
public void notLeader()
{    states.add("false");}
0
public void testErrorPolicies() throws Exception
{    Timing2 timing = new Timing2();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        LeaderLatchListener listener = new LeaderLatchListener() {            @Override            public void isLeader() {                states.add("true");            }            @Override            public void notLeader() {                states.add("false");            }        };        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        List<String> next = Lists.newArrayList();        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        latch.close();        client.close();        timing.sleepABit();        states.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
0
public void isLeader()
{    states.add("true");}
0
public void notLeader()
{    states.add("false");}
0
public void testProperCloseWithoutConnectionEstablished() throws Exception
{    server.stop();    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean resetCalled = new AtomicBoolean(false);        final CountDownLatch cancelStartTaskLatch = new CountDownLatch(1);        latch = new LeaderLatch(client, PATH_NAME) {            @Override            void reset() throws Exception {                resetCalled.set(true);                super.reset();            }            @Override            protected boolean cancelStartTask() {                if (super.cancelStartTask()) {                    cancelStartTaskLatch.countDown();                    return true;                }                return false;            }        };        latch.start();        latch.close();        latch = null;        Assert.assertTrue(timing.awaitLatch(cancelStartTaskLatch));        Assert.assertFalse(resetCalled.get());    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
0
 void reset() throws Exception
{    resetCalled.set(true);    super.reset();}
0
protected boolean cancelStartTask()
{    if (super.cancelStartTask()) {        cancelStartTaskLatch.countDown();        return true;    }    return false;}
0
public void testResetRace() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);                latch.start();                latch.reset();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 1);    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
0
public void testCreateDeleteRace() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH_NAME);        LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);        latch.start();        latch.close();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testLostConnection() throws Exception
{    final int PARTICIPANT_QTY = 10;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch countDownLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    countDownLatch.countDown();                }            }        });        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);        }        waitForALeader(latches, timing);        server.stop();        Assert.assertTrue(timing.awaitLatch(countDownLatch));        timing.forWaiting().sleepABit();        Assert.assertEquals(getLeaders(latches).size(), 0);        server.restart();                Assert.assertEquals(waitForALeader(latches, timing).size(), 1);    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        countDownLatch.countDown();    }}
0
public void testCorrectWatching() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int PARTICIPANT_ID = 2;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);            waitForALeader(latches, timing);        }                latches.get(PARTICIPANT_ID).close();                        Assert.assertTrue(!latches.get(PARTICIPANT_ID - 1).hasLeadership());    } finally {                latches.remove(PARTICIPANT_ID);        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
0
public void testWaiting() throws Exception
{    final int LOOPS = 10;    for (int i = 0; i < LOOPS; ++i) {        System.out.println("TRY #" + i);        internalTestWaitingOnce();        Thread.sleep(10);    }}
0
private void internalTestWaitingOnce() throws Exception
{    final int PARTICIPANT_QTY = 10;    ExecutorService executorService = Executors.newFixedThreadPool(PARTICIPANT_QTY);    ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean thereIsALeader = new AtomicBoolean(false);        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);                    try {                        latch.start();                        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));                        Thread.sleep((int) (10 * Math.random()));                        thereIsALeader.set(false);                    } finally {                        latch.close();                    }                    return null;                }            });        }        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.take().get();        }    } finally {        executorService.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
0
public Void call() throws Exception
{    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);    try {        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));        Thread.sleep((int) (10 * Math.random()));        thereIsALeader.set(false);    } finally {        latch.close();    }    return null;}
0
public void testBasic() throws Exception
{    basic(Mode.START_IMMEDIATELY);}
0
public void testBasicAlt() throws Exception
{    basic(Mode.START_IN_THREADS);}
0
public void testCallbackSanity() throws Exception
{    final int PARTICIPANT_QTY = 10;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackSanity-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
0
public void isLeader()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
0
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
0
public void testCallbackNotifyLeader() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int SILENT_QTY = 3;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackNotifyLeader-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        LeaderLatch.CloseMode closeMode = i < SILENT_QTY ? LeaderLatch.CloseMode.SILENT : LeaderLatch.CloseMode.NOTIFY_LEADER;        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME, "", closeMode);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY * 2 - SILENT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
0
public void isLeader()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
0
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
0
public void testCallbackDontNotify() throws Exception
{    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final LeaderLatch notifiedLeader = new LeaderLatch(client, PATH_NAME, "", LeaderLatch.CloseMode.NOTIFY_LEADER);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            masterCounter.incrementAndGet();        }    });    notifiedLeader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            notLeaderCounter.incrementAndGet();        }    });    try {        client.start();        leader.start();        timing.sleepABit();        notifiedLeader.start();        timing.sleepABit();        notifiedLeader.close();        timing.sleepABit();                leader.close(LeaderLatch.CloseMode.NOTIFY_LEADER);        Assert.assertEquals(leader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(notifiedLeader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(masterCounter.get(), 1);        Assert.assertEquals(notLeaderCounter.get(), 0);    } finally {        if (leader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(leader);        }        if (notifiedLeader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(notifiedLeader);        }        TestCleanState.closeAndTestClean(client);    }}
0
public void isLeader()
{}
0
public void notLeader()
{    masterCounter.incrementAndGet();}
0
public void isLeader()
{}
0
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
0
public void testNoServerAtStart()
{    CloseableUtils.closeQuietly(server);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(5, 1000));    client.start();    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final CountDownLatch leaderCounter = new CountDownLatch(1);    final AtomicInteger leaderCount = new AtomicInteger(0);    final AtomicInteger notLeaderCount = new AtomicInteger(0);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {            leaderCounter.countDown();            leaderCount.incrementAndGet();        }        @Override        public void notLeader() {            notLeaderCount.incrementAndGet();        }    });    try {        leader.start();        timing.sleepABit();                server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(timing.awaitLatch(leaderCounter), "Not elected leader");        Assert.assertEquals(leaderCount.get(), 1, "Elected too many times");        Assert.assertEquals(notLeaderCount.get(), 0, "Unelected too many times");    } catch (Exception e) {        Assert.fail("Unexpected exception", e);    } finally {        CloseableUtils.closeQuietly(leader);        TestCleanState.closeAndTestClean(client);        CloseableUtils.closeQuietly(server);    }}
0
public void isLeader()
{    leaderCounter.countDown();    leaderCount.incrementAndGet();}
0
public void notLeader()
{    notLeaderCount.incrementAndGet();}
0
private void basic(Mode mode) throws Exception
{        final int PARTICIPANT_QTY = 1;    List<LeaderLatch> latches = Lists.newArrayList();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            if (mode == Mode.START_IMMEDIATELY) {                latch.start();            }            latches.add(latch);        }        if (mode == Mode.START_IN_THREADS) {            ExecutorService service = Executors.newFixedThreadPool(latches.size());            for (final LeaderLatch latch : latches) {                service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        Thread.sleep((int) (100 * Math.random()));                        latch.start();                        return null;                    }                });            }            service.shutdown();        }        while (latches.size() > 0) {            List<LeaderLatch> leaders = waitForALeader(latches, timing);                        Assert.assertEquals(leaders.size(), 1);            LeaderLatch theLeader = leaders.get(0);            if (mode == Mode.START_IMMEDIATELY) {                                Assert.assertEquals(latches.indexOf(theLeader), 0);            }            theLeader.close();            latches.remove(theLeader);        }    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    Thread.sleep((int) (100 * Math.random()));    latch.start();    return null;}
0
private List<LeaderLatch> waitForALeader(List<LeaderLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<LeaderLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders;        }        timing.sleepABit();    }    return Lists.newArrayList();}
0
private List<LeaderLatch> getLeaders(Collection<LeaderLatch> latches)
{    List<LeaderLatch> leaders = Lists.newArrayList();    for (LeaderLatch latch : latches) {        if (latch.hasLeadership()) {            leaders.add(latch);        }    }    return leaders;}
0
public void testRelativePath() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    new LeaderLatch(client, "parent");}
0
public void testInCluster() throws Exception
{    final int PARTICIPANT_QTY = 3;    List<ClientAndLatch> clients = Lists.newArrayList();    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(PARTICIPANT_QTY);    try {        cluster.start();        List<InstanceSpec> instances = Lists.newArrayList(cluster.getInstances());        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(instances.get(i).getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));            LeaderLatch latch = new LeaderLatch(client, "/latch");            clients.add(new ClientAndLatch(client, latch, i));            client.start();            latch.start();        }        ClientAndLatch leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        cluster.killServer(instances.get(leader.index));        Thread.sleep(timing.multiple(2).session());        leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        Assert.assertEquals(getLeaders(clients).size(), 1);    } finally {        for (ClientAndLatch client : clients) {            CloseableUtils.closeQuietly(client.latch);            CloseableUtils.closeQuietly(client.client);        }        CloseableUtils.closeQuietly(cluster);    }}
0
private ClientAndLatch waitForALeader(List<ClientAndLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<ClientAndLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders.get(0);        }        timing.sleepABit();    }    return null;}
0
private List<ClientAndLatch> getLeaders(Collection<ClientAndLatch> latches)
{    List<ClientAndLatch> leaders = Lists.newArrayList();    for (ClientAndLatch clientAndLatch : latches) {        if (clientAndLatch.latch.hasLeadership()) {            leaders.add(clientAndLatch);        }    }    return leaders;}
0
public void testInterruption() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CountDownLatch exitLatch = new CountDownLatch(1);        BlockingQueue<Thread> threadExchange = new ArrayBlockingQueue<>(1);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                threadExchange.put(Thread.currentThread());                try {                    Thread.currentThread().join();                } finally {                    exitLatch.countDown();                }            }        };        selector = new LeaderSelector(client, PATH_NAME, listener);        selector.failedMutexReleaseCount = new AtomicInteger();        selector.start();        Thread leaderThread = timing.takeFromQueue(threadExchange);        leaderThread.interrupt();        Assert.assertTrue(timing.awaitLatch(exitLatch));                timing.sleepABit();        Assert.assertEquals(0, selector.failedMutexReleaseCount.get());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    threadExchange.put(Thread.currentThread());    try {        Thread.currentThread().join();    } finally {        exitLatch.countDown();    }}
0
public void testErrorPolicies() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> changes = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                changes.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                changes.add("leader");                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    changes.add("release");                    Thread.currentThread().interrupt();                }            }        };        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.close();        List<String> next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        selector.close();        client.close();        timing.sleepABit();        changes.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.stop();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    changes.add(newState.name());}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    changes.add("leader");    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        changes.add("release");        Thread.currentThread().interrupt();    }}
0
public void testLeaderNodeDeleteOnInterrupt() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener connectionStateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(connectionStateListener);        client.start();        final BlockingQueue<Thread> queue = new ArrayBlockingQueue<Thread>(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                queue.add(Thread.currentThread());                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Thread leaderThread = timing.takeFromQueue(queue);        server.stop();        leaderThread.interrupt();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/leader").size(), 0);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    queue.add(Thread.currentThread());    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testInterruptLeadershipWithRequeue() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        selector.interruptLeadership();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.currentThread().join();}
0
public void testInterruptLeadership() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch isLeaderLatch = new CountDownLatch(1);        final CountDownLatch losingLeaderLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                isLeaderLatch.countDown();                try {                    Thread.currentThread().join();                } finally {                    losingLeaderLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.awaitLatch(isLeaderLatch));        selector.interruptLeadership();        Assert.assertTrue(timing.awaitLatch(losingLeaderLatch));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    isLeaderLatch.countDown();    try {        Thread.currentThread().join();    } finally {        losingLeaderLatch.countDown();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testRaceAtStateChanged() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch takeLeadershipLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                                takeLeadershipLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                    throw new CancelLeadershipException();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        CountDownLatch debugLeadershipLatch = new CountDownLatch(1);        CountDownLatch debugLeadershipWaitLatch = new CountDownLatch(1);        selector.debugLeadershipLatch = debugLeadershipLatch;        selector.debugLeadershipWaitLatch = debugLeadershipWaitLatch;        selector.start();        Assert.assertTrue(timing.awaitLatch(debugLeadershipLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        timing.sleepABit();        debugLeadershipWaitLatch.countDown();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertFalse(takeLeadershipLatch.await(3, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{        takeLeadershipLatch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();        throw new CancelLeadershipException();    }}
0
public void testAutoRequeue() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.sleep(10);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 2));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    Thread.sleep(10);    semaphore.release();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testServerDying() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.sleep(Integer.MAX_VALUE);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    semaphore.release();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        timing.acquireSemaphore(semaphore);        server.close();        timing.acquireSemaphore(semaphore);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.sleep(Integer.MAX_VALUE);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        semaphore.release();    }}
0
public void testKillSessionThenCloseShouldElectNewLeader() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        boolean requeued1 = leaderSelector1.requeue();        boolean requeued2 = leaderSelector2.requeue();        Assert.assertTrue(requeued1);        Assert.assertTrue(requeued2);        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
0
public void testKillServerThenCloseShouldElectNewLeader() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.autoRequeue();        leaderSelector2.autoRequeue();        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        int port = server.getPort();        server.stop();        timing.sleepABit();        server = new TestingServer(port);        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
0
public void testClosing() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        leaderSelector1.start();        leaderSelector2.start();        while (!leaderSelector1.hasLeadership() && !leaderSelector2.hasLeadership()) {            Thread.sleep(1000);        }        Assert.assertNotSame(leaderSelector1.hasLeadership(), leaderSelector2.hasLeadership());        LeaderSelector positiveLeader;        LeaderSelector negativeLeader;        if (leaderSelector1.hasLeadership()) {            positiveLeader = leaderSelector1;            negativeLeader = leaderSelector2;        } else {            positiveLeader = leaderSelector2;            negativeLeader = leaderSelector1;        }        negativeLeader.close();        Thread.sleep(1000);        Assert.assertNotSame(positiveLeader.hasLeadership(), negativeLeader.hasLeadership());        Assert.assertTrue(positiveLeader.hasLeadership());        positiveLeader.close();        Thread.sleep(1000);        Assert.assertFalse(positiveLeader.hasLeadership());    } finally {        client.close();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
0
public void testRotatingLeadership() throws Exception
{    final int LEADER_QTY = 5;    final int REPEAT_QTY = 3;    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> leaderList = new LinkedBlockingQueue<Integer>();        List<LeaderSelector> selectors = Lists.newArrayList();        for (int i = 0; i < LEADER_QTY; ++i) {            final int ourIndex = i;            LeaderSelector leaderSelector = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {                @Override                public void takeLeadership(CuratorFramework client) throws Exception {                    timing.sleepABit();                    leaderList.add(ourIndex);                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            });            selectors.add(leaderSelector);        }        List<Integer> localLeaderList = Lists.newArrayList();        for (int i = 1; i <= REPEAT_QTY; ++i) {            for (LeaderSelector leaderSelector : selectors) {                if (i > 1) {                    leaderSelector.requeue();                } else {                    leaderSelector.start();                }            }            while (localLeaderList.size() != (i * selectors.size())) {                Integer polledIndex = leaderList.poll(10, TimeUnit.SECONDS);                Assert.assertNotNull(polledIndex);                localLeaderList.add(polledIndex);            }            timing.sleepABit();        }        for (LeaderSelector leaderSelector : selectors) {            leaderSelector.close();        }        System.out.println(localLeaderList);        for (int i = 0; i < REPEAT_QTY; ++i) {            Set<Integer> uniques = Sets.newHashSet();            for (int j = 0; j < selectors.size(); ++j) {                Assert.assertTrue(localLeaderList.size() > 0);                int thisIndex = localLeaderList.remove(0);                Assert.assertFalse(uniques.contains(thisIndex));                uniques.add(thisIndex);            }        }    } finally {        client.close();    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    timing.sleepABit();    leaderList.add(ourIndex);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testRestart() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                List<String> names = client.getChildren().forPath("/leader");                Assert.assertTrue(names.size() > 0);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    List<String> names = client.getChildren().forPath("/leader");    Assert.assertTrue(names.size() > 0);    semaphore.release();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testLostRestart() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.sync().forPath("/");        final AtomicReference<Exception> error = new AtomicReference<Exception>(null);        final AtomicReference<String> lockNode = new AtomicReference<String>(null);        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch internalLostLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                try {                    List<String> names = client.getChildren().forPath("/leader");                    if (names.size() != 1) {                        semaphore.release();                        Exception exception = new Exception("Names size isn't 1: " + names.size());                        error.set(exception);                        return;                    }                    lockNode.set(names.get(0));                    semaphore.release();                    if (!timing.multiple(4).awaitLatch(internalLostLatch)) {                        error.set(new Exception("internalLostLatch await failed"));                    }                } finally {                    lostLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    internalLostLatch.countDown();                }            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));        if (error.get() != null) {            throw new AssertionError(error.get());        }        Collection<InstanceSpec> instances = cluster.getInstances();        cluster.stop();        Assert.assertTrue(timing.multiple(4).awaitLatch(lostLatch));        timing.sleepABit();        Assert.assertFalse(selector.hasLeadership());        Assert.assertNotNull(lockNode.get());        cluster = new TestingCluster(instances.toArray(new InstanceSpec[instances.size()]));        cluster.start();        try {                        client.delete().forPath(ZKPaths.makePath("/leader", lockNode.get()));        } catch (Exception ignore) {                }        Assert.assertTrue(semaphore.availablePermits() == 0);        Assert.assertFalse(selector.hasLeadership());        selector.requeue();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    try {        List<String> names = client.getChildren().forPath("/leader");        if (names.size() != 1) {            semaphore.release();            Exception exception = new Exception("Names size isn't 1: " + names.size());            error.set(exception);            return;        }        lockNode.set(names.get(0));        semaphore.release();        if (!timing.multiple(4).awaitLatch(internalLostLatch)) {            error.set(new Exception("internalLostLatch await failed"));        }    } finally {        lostLatch.countDown();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        internalLostLatch.countDown();    }}
0
public static void setCNXFactory()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ChaosMonkeyCnxnFactory.class.getName());}
0
public static void resetCNXFactory()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
0
public void flappingTest() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(1, 500)).sessionTimeoutMs(30000).build();    final TestLeaderSelectorListener listener = new TestLeaderSelectorListener();    LeaderSelector leaderSelector1 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);    LeaderSelector leaderSelector2 = null;    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        leaderSelector1.start();                        Assert.assertTrue(listener.reconnected.await(10, TimeUnit.SECONDS), "Connection has not been lost");                Assert.assertEquals(listener.takeLeadership.getCount(), 1);                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");                leaderSelector2 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);        leaderSelector2.start();        Assert.assertTrue(listener.takeLeadership.await(1, TimeUnit.SECONDS));    } finally {        try {            leaderSelector1.close();        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        try {            if (leaderSelector2 != null) {                leaderSelector2.close();            }        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        client.close();    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{        takeLeadership.countDown();    }
1
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnected.countDown();    }}
0
public void createProtectedNodeInBackgroundTest() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(2, 100)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
1
public void createProtectedNodeInBackgroundTestNoRetry() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(0, 0)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
1
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
1
public void testId() throws Exception
{    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/ls", listener);        selector.setId("A is A");        selector.start();        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Participant leader = selector.getLeader();        Assert.assertTrue(leader.isLeader());        Assert.assertEquals(leader.getId(), "A is A");        Collection<Participant> participants = selector.getParticipants();        Assert.assertEquals(participants.size(), 1);        Assert.assertEquals(participants.iterator().next().getId(), "A is A");        Assert.assertEquals(participants.iterator().next().getId(), selector.getId());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.countDown();    Thread.currentThread().join();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testBasic() throws Exception
{    final int SELECTOR_QTY = 10;    List<LeaderSelector> selectors = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch leaderLatch = new CountDownLatch(1);        final CountDownLatch workingLatch = new CountDownLatch(SELECTOR_QTY);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderLatch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < SELECTOR_QTY; ++i) {            LeaderSelector selector = new LeaderSelector(client, "/ls", listener) {                @Override                void doWork() throws Exception {                    workingLatch.countDown();                    super.doWork();                }            };            selector.setId(Integer.toString(i));            selectors.add(selector);        }        for (LeaderSelector selector : selectors) {            selector.start();        }        Assert.assertTrue(leaderLatch.await(10, TimeUnit.SECONDS));        Assert.assertTrue(workingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Collection<Participant> participants = selectors.get(0).getParticipants();        for (int i = 1; i < selectors.size(); ++i) {            Assert.assertEquals(participants, selectors.get(i).getParticipants());        }        Set<String> ids = Sets.newHashSet();        int leaderCount = 0;        for (Participant participant : participants) {            if (participant.isLeader()) {                ++leaderCount;            }            Assert.assertFalse(ids.contains(participant.getId()));            ids.add(participant.getId());        }        Assert.assertEquals(leaderCount, 1);        Set<String> expectedIds = Sets.newHashSet();        for (int i = 0; i < SELECTOR_QTY; ++i) {            expectedIds.add(Integer.toString(i));        }        Assert.assertEquals(expectedIds, ids);    } finally {        for (LeaderSelector selector : selectors) {            CloseableUtils.closeQuietly(selector);        }        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderLatch.countDown();    Thread.currentThread().join();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
 void doWork() throws Exception
{    workingLatch.countDown();    super.doWork();}
0
public void test() throws Exception
{    Timing timing = new Timing();    LeaderSelector leaderSelector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().retryPolicy(new ExponentialBackoffRetry(100, 3)).connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).build();    try {        client.start();        MyLeaderSelectorListener listener = new MyLeaderSelectorListener();        ExecutorService executorPool = Executors.newFixedThreadPool(20);        leaderSelector = new LeaderSelector(client, "/test", threadFactory, executorPool, listener);        leaderSelector.autoRequeue();        leaderSelector.start();        timing.sleepABit();        Assert.assertEquals(listener.getLeaderCount(), 1);    } finally {        CloseableUtils.closeQuietly(leaderSelector);        CloseableUtils.closeQuietly(client);    }}
0
public int getLeaderCount()
{    return leaderCount.get();}
0
public void takeLeadership(CuratorFramework curatorFramework) throws Exception
{    ourThread = Thread.currentThread();    try {        leaderCount.incrementAndGet();        while (!Thread.currentThread().isInterrupted()) {            Thread.sleep(1000);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        leaderCount.decrementAndGet();    }}
0
public void stateChanged(CuratorFramework curatorFramework, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        if (ourThread != null) {            ourThread.interrupt();        }    }}
0
public void close() throws IOException
{    shouldRun = false;}
0
 boolean hasAcquired()
{    return hasAcquired;}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    hasAcquired = false;}
0
 static SemaphoreClient getActiveClient()
{    return activeClient.get();}
0
public Void call() throws Exception
{    shouldRun = true;    client.getConnectionStateListenable().addListener(this);    try {        while (shouldRun) {            try {                acquireAndRun();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();                                throw e;            } catch (Exception e) {                Thread.sleep(CLIENT_EXCEPTION_HANDLER_SLEEP_TIME_SECS * 1000L);            }        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
0
private void acquireAndRun() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, semaphorePath, MAX_SEMAPHORE_LEASES);    Lease lease = semaphore.acquire();    try {        hasAcquired = true;        if (activeClient.compareAndSet(null, this)) {            throw new Exception("Multiple acquirers");        }        try {            while (hasAcquired && shouldRun) {                operation.call();            }        } finally {            if (activeClient.compareAndSet(this, null)) {                                throw new Exception("Bad release");            }        }    } finally {        semaphore.returnLease(lease);    }}
0
 synchronized void await() throws InterruptedException
{    while (available == 0) {        wait();    }    --available;    notifyAll();}
0
 synchronized void countDown(int qty)
{    available += qty;    notifyAll();}
0
public void testMaxChildren() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);            }            try {                client.getChildren().forPath("/big");                Assert.fail("Should have been a connection loss");            } catch (KeeperException.ConnectionLossException e) {                        }            final CountDownLatch latch = new CountDownLatch(1);            reaper = new ChildReaper(client, "/big", Reaper.Mode.REAP_UNTIL_DELETE, 1) {                @Override                protected void warnMaxChildren(String path, Stat stat) {                    latch.countDown();                    super.warnMaxChildren(path, stat);                }            };            reaper.setMaxChildren(100);            reaper.start();            Assert.assertTrue(timing.awaitLatch(latch));        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
0
protected void warnMaxChildren(String path, Stat stat)
{    latch.countDown();    super.warnMaxChildren(path, stat);}
0
public void testLargeNodes() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    final int SMALL_QTY = 100;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);                if (i < SMALL_QTY) {                    client.create().creatingParentsIfNeeded().forPath("/small/node-" + i);                }            }            reaper = new ChildReaper(client, "/foo", Reaper.Mode.REAP_UNTIL_DELETE, 1);            reaper.start();            reaper.addPath("/big");            reaper.addPath("/small");            int count = -1;            for (int i = 0; (i < 10) && (count != 0); ++i) {                timing.sleepABit();                count = client.checkExists().forPath("/small").getNumChildren();            }            Assert.assertEquals(count, 0);        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
0
public void testSomeNodes() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        Random r = new Random();        int nonEmptyNodes = 0;        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));            if (r.nextBoolean()) {                client.create().forPath("/test/" + Integer.toString(i) + "/foo");                ++nonEmptyNodes;            }        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), nonEmptyNodes);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
public void testLeaderElection() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    LeaderLatch otherLeader = null;    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        otherLeader = new LeaderLatch(client, "/test-leader");        otherLeader.start();        otherLeader.await();        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, ChildReaper.newExecutorService(), 1, "/test-leader");        reaper.start();        timing.forWaiting().sleepABit();                Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 10);        CloseableUtils.closeQuietly(otherLeader);        timing.forWaiting().sleepABit();        stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        if (otherLeader != null && otherLeader.getState() == LeaderLatch.State.STARTED) {            CloseableUtils.closeQuietly(otherLeader);        }        CloseableUtils.closeQuietly(client);    }}
0
public void testMultiPath() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test1/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test2/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test3/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test2", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        reaper.addPath("/test1");        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test1");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test2");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test3");        Assert.assertEquals(stat.getNumChildren(), 10);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
public void testNamespace() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).namespace("foo").build();    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.usingNamespace(null).checkExists().forPath("/foo/test");        Assert.assertNotNull(stat);        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessMultiLock(client, Arrays.asList(LOCK_PATH_1, LOCK_PATH_2));}
0
public void testSomeReleasesFail() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        final InterProcessLock otherGoodLock = new InterProcessMutex(client, LOCK_PATH_2);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                otherGoodLock.acquire();            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                return otherGoodLock.acquire(time, unit);            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return otherGoodLock.isAcquiredInThisProcess();            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            lock.release();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(otherGoodLock.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void acquire() throws Exception
{    otherGoodLock.acquire();}
0
public boolean acquire(long time, TimeUnit unit) throws Exception
{    return otherGoodLock.acquire(time, unit);}
0
public void release() throws Exception
{    throw new Exception("foo");}
0
public boolean isAcquiredInThisProcess()
{    return otherGoodLock.isAcquiredInThisProcess();}
0
public void testSomeLocksFailToLock() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean goodLockWasLocked = new AtomicBoolean(false);        final InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                if (goodLock.isAcquiredInThisProcess()) {                    goodLockWasLocked.set(true);                }                throw new Exception("foo");            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                throw new Exception("foo");            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return false;            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(goodLockWasLocked.get());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void acquire() throws Exception
{    if (goodLock.isAcquiredInThisProcess()) {        goodLockWasLocked.set(true);    }    throw new Exception("foo");}
0
public boolean acquire(long time, TimeUnit unit) throws Exception
{    throw new Exception("foo");}
0
public void release() throws Exception
{    throw new Exception("foo");}
0
public boolean isAcquiredInThisProcess()
{    return false;}
0
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessMutex(client, LOCK_PATH);}
0
public void testWithSchema() throws Exception
{    Schema schemaRoot = Schema.builderForRecipeParent("/foo").name("root").build();    Schema schemaLocks = Schema.builderForRecipe("/foo").name("locks").build();    SchemaSet schemaSet = new SchemaSet(Lists.newArrayList(schemaRoot, schemaLocks), false);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();    try {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/foo");        lock.acquire();        lock.release();    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRevoking() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);        ExecutorService executorService = Executors.newCachedThreadPool();        final CountDownLatch revokeLatch = new CountDownLatch(1);        final CountDownLatch lockLatch = new CountDownLatch(1);        Future<Void> f1 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {                    @Override                    public void revocationRequested(InterProcessMutex lock) {                        revokeLatch.countDown();                    }                };                lock.makeRevocable(listener);                lock.acquire();                lockLatch.countDown();                revokeLatch.await();                lock.release();                return null;            }        });        Future<Void> f2 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));                Collection<String> nodes = lock.getParticipantNodes();                Assert.assertEquals(nodes.size(), 1);                Revoker.attemptRevoke(client, nodes.iterator().next());                InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);                Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));                l2.release();                return null;            }        });        f2.get();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Void call() throws Exception
{    RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {        @Override        public void revocationRequested(InterProcessMutex lock) {            revokeLatch.countDown();        }    };    lock.makeRevocable(listener);    lock.acquire();    lockLatch.countDown();    revokeLatch.await();    lock.release();    return null;}
0
public void revocationRequested(InterProcessMutex lock)
{    revokeLatch.countDown();}
0
public Void call() throws Exception
{    Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));    Collection<String> nodes = lock.getParticipantNodes();    Assert.assertEquals(nodes.size(), 1);    Revoker.attemptRevoke(client, nodes.iterator().next());    InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);    Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));    l2.release();    return null;}
0
public void testPersistentLock() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH, new StandardLockInternalsDriver() {            @Override            public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception {                String ourPath;                if (lockNodeBytes != null) {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);                } else {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);                }                return ourPath;            }        });                lock.acquire(10, TimeUnit.SECONDS);        Assert.assertTrue(lock.isAcquiredInThisProcess());                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertNotNull(client.checkExists().forPath(LOCK_PATH));                String actualLockPath = lock.getLockPath();        lock.release();        Assert.assertNull(client.checkExists().forPath(actualLockPath));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);    }    return ourPath;}
0
public void testLocker() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        InterProcessLock lock = makeLock(client);        try (Locker locker = new Locker(lock, timing.milliseconds(), TimeUnit.MILLISECONDS)) {            Assert.assertTrue(lock.isAcquiredInThisProcess());        }        Assert.assertFalse(lock.isAcquiredInThisProcess());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testWaitingProcessKilledServer() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (!newState.isConnected()) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Object result = new Object();        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        for (int i = 0; i < 2; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessLock lock = makeLock(client);                    lock.acquire();                    try {                        if (isFirst.compareAndSet(true, false)) {                            timing.sleepABit();                            server.stop();                            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));                            server.restart();                        }                    } finally {                        try {                            lock.release();                        } catch (KeeperException.SessionExpiredException dummy) {                                                }                    }                    return result;                }            });        }        for (int i = 0; i < 2; ++i) {            Assert.assertEquals(service.take().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), result);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (!newState.isConnected()) {        latch.countDown();    }}
0
public Object call() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        if (isFirst.compareAndSet(true, false)) {            timing.sleepABit();            server.stop();            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));            server.restart();        }    } finally {        try {            lock.release();        } catch (KeeperException.SessionExpiredException dummy) {                }    }    return result;}
0
public void testKilledSession() throws Exception
{    final Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final InterProcessLock mutex1 = makeLock(client);        final InterProcessLock mutex2 = makeLock(client);        final Semaphore semaphore = new Semaphore(0);        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex1.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex2.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.forSessionSleep().acquireSemaphore(semaphore, 1));    } finally {        client.close();    }}
0
public Object call() throws Exception
{    mutex1.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
0
public Object call() throws Exception
{    mutex2.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
0
public void testContainerCleanup() throws Exception
{    if (!ZKPaths.hasContainerSupport()) {        System.out.println("ZooKeeper version does not support Containers. Skipping test");        return;    }    server.close();    System.setProperty("znode.container.checkIntervalMs", "10");    try {        server = new TestingServer();        final int THREAD_QTY = 10;        ExecutorService service = null;        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            List<Future<Object>> threads = Lists.newArrayList();            service = Executors.newCachedThreadPool();            for (int i = 0; i < THREAD_QTY; ++i) {                Future<Object> t = service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        InterProcessLock lock = makeLock(client);                        lock.acquire();                        try {                            Thread.sleep(10);                        } finally {                            lock.release();                        }                        return null;                    }                });                threads.add(t);            }            for (Future<Object> t : threads) {                t.get();            }            new Timing().sleepABit();            Assert.assertNull(client.checkExists().forPath(LOCK_BASE_PATH));        } finally {            if (service != null) {                service.shutdownNow();            }            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("znode.container.checkIntervalMs");    }}
0
public Object call() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        Thread.sleep(10);    } finally {        lock.release();    }    return null;}
0
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("test").build();    client.start();    try {        InterProcessLock mutex = makeLock(client);        mutex.acquire(10, TimeUnit.SECONDS);        Thread.sleep(100);        mutex.release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testReentrantSingleLock() throws Exception
{    final int THREAD_QTY = 10;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final AtomicBoolean hasLock = new AtomicBoolean(false);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Semaphore semaphore = new Semaphore(1);        final InterProcessLock mutex = makeLock(client);        List<Future<Object>> threads = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < THREAD_QTY; ++i) {            Future<Object> t = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    semaphore.acquire();                    mutex.acquire();                    Assert.assertTrue(hasLock.compareAndSet(false, true));                    try {                        if (isFirst.compareAndSet(true, false)) {                            semaphore.release(THREAD_QTY - 1);                            while (semaphore.availablePermits() > 0) {                                Thread.sleep(100);                            }                        } else {                            Thread.sleep(100);                        }                    } finally {                        mutex.release();                        hasLock.set(false);                    }                    return null;                }            });            threads.add(t);        }        for (Future<Object> t : threads) {            t.get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    semaphore.acquire();    mutex.acquire();    Assert.assertTrue(hasLock.compareAndSet(false, true));    try {        if (isFirst.compareAndSet(true, false)) {            semaphore.release(THREAD_QTY - 1);            while (semaphore.availablePermits() > 0) {                Thread.sleep(100);            }        } else {            Thread.sleep(100);        }    } finally {        mutex.release();        hasLock.set(false);    }    return null;}
0
public void testReentrant2Threads() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        waitLatchForBar = new CountDownLatch(1);        countLatchForBar = new CountDownLatch(1);        final InterProcessLock mutex = makeLock(client);        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));                try {                    mutex.acquire(10, TimeUnit.SECONDS);                    Assert.fail();                } catch (Exception e) {                                } finally {                    waitLatchForBar.countDown();                }                return null;            }        });        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));    try {        mutex.acquire(10, TimeUnit.SECONDS);        Assert.fail();    } catch (Exception e) {        } finally {        waitLatchForBar.countDown();    }    return null;}
0
public void testReentrant() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        InterProcessLock mutex = makeLock(client);        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
private void foo(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    bar(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
0
private void bar(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    if (countLatchForBar != null) {        countLatchForBar.countDown();        waitLatchForBar.await(10, TimeUnit.SECONDS);    }    snafu(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
0
private void snafu(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();    Assert.assertTrue(mutex.isAcquiredInThisProcess());}
0
public void test2Clients() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client1.start();        client2.start();        final InterProcessLock mutexForClient1 = makeLock(client1);        final InterProcessLock mutexForClient2 = makeLock(client2);        final CountDownLatch latchForClient1 = new CountDownLatch(1);        final CountDownLatch latchForClient2 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient1 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient2 = new CountDownLatch(1);        final AtomicReference<Exception> exceptionRef = new AtomicReference<Exception>();        ExecutorService service = Executors.newCachedThreadPool();        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient1.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient1.countDown();                    latchForClient1.await(10, TimeUnit.SECONDS);                    mutexForClient1.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient2.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient2.countDown();                    latchForClient2.await(10, TimeUnit.SECONDS);                    mutexForClient2.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        while (!mutexForClient1.isAcquiredInThisProcess() && !mutexForClient2.isAcquiredInThisProcess()) {            Thread.sleep(1000);            Assert.assertFalse(future1.isDone() && future2.isDone());        }        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Thread.sleep(1000);        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() || mutexForClient2.isAcquiredInThisProcess());        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Exception exception = exceptionRef.get();        if (exception != null) {            throw exception;        }        if (mutexForClient1.isAcquiredInThisProcess()) {            latchForClient1.countDown();            Assert.assertTrue(acquiredLatchForClient2.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient2.isAcquiredInThisProcess());        } else {            latchForClient2.countDown();            Assert.assertTrue(acquiredLatchForClient1.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess());        }        future1.get();        future2.get();    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
0
public Object call() throws Exception
{    try {        mutexForClient1.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient1.countDown();        latchForClient1.await(10, TimeUnit.SECONDS);        mutexForClient1.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
0
public Object call() throws Exception
{    try {        mutexForClient2.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient2.countDown();        latchForClient2.await(10, TimeUnit.SECONDS);        mutexForClient2.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
0
public void testGetParticipantNodes() throws Exception
{    final int READERS = 20;    final int WRITERS = 8;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(READERS + WRITERS);        final CountDownLatch readLatch = new CountDownLatch(READERS);        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        final CountDownLatch exitLatch = new CountDownLatch(1);        ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(Executors.newCachedThreadPool());        for (int i = 0; i < READERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    lock.readLock().acquire();                    try {                        latch.countDown();                        readLatch.countDown();                        exitLatch.await();                    } finally {                        lock.readLock().release();                    }                    return null;                }            });        }        for (int i = 0; i < WRITERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));                                        latch.countDown();                    lock.writeLock().acquire();                    try {                        exitLatch.await();                    } finally {                        lock.writeLock().release();                    }                    return null;                }            });        }        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Collection<String> readers = lock.readLock().getParticipantNodes();        Collection<String> writers = lock.writeLock().getParticipantNodes();        Assert.assertEquals(readers.size(), READERS);        Assert.assertEquals(writers.size(), WRITERS);        exitLatch.countDown();        for (int i = 0; i < (READERS + WRITERS); ++i) {            service.take().get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Void call() throws Exception
{    lock.readLock().acquire();    try {        latch.countDown();        readLatch.countDown();        exitLatch.await();    } finally {        lock.readLock().release();    }    return null;}
0
public Void call() throws Exception
{    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));        latch.countDown();    lock.writeLock().acquire();    try {        exitLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
0
public void testThatUpgradingIsDisallowed() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.readLock().acquire();        Assert.assertFalse(lock.writeLock().acquire(5, TimeUnit.SECONDS));        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testThatDowngradingRespectsThreads() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        ExecutorService t1 = Executors.newSingleThreadExecutor();        ExecutorService t2 = Executors.newSingleThreadExecutor();        final CountDownLatch latch = new CountDownLatch(1);        final CountDownLatch releaseLatch = new CountDownLatch(1);        Future<Object> f1 = t1.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                lock.writeLock().acquire();                latch.countDown();                try {                    releaseLatch.await();                } finally {                    lock.writeLock().release();                }                return null;            }        });        Future<Object> f2 = t2.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));                Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));                return null;            }        });        f2.get();        releaseLatch.countDown();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    lock.writeLock().acquire();    latch.countDown();    try {        releaseLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
0
public Object call() throws Exception
{    Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));    return null;}
0
public void testDowngrading() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.writeLock().acquire();        Assert.assertTrue(lock.readLock().acquire(5, TimeUnit.SECONDS));        lock.writeLock().release();        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testBasic() throws Exception
{    final int CONCURRENCY = 8;    final int ITERATIONS = 100;    final Random random = new Random();    final AtomicInteger concurrentCount = new AtomicInteger(0);    final AtomicInteger maxConcurrentCount = new AtomicInteger(0);    final AtomicInteger writeCount = new AtomicInteger(0);    final AtomicInteger readCount = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < CONCURRENCY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                client.start();                try {                    InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");                    for (int i = 0; i < ITERATIONS; ++i) {                        if (random.nextInt(100) < 10) {                            doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                            writeCount.incrementAndGet();                        } else {                            doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                            readCount.incrementAndGet();                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> future : futures) {        future.get();    }    System.out.println("Writes: " + writeCount.get() + " - Reads: " + readCount.get() + " - Max Reads: " + maxConcurrentCount.get());    Assert.assertTrue(writeCount.get() > 0);    Assert.assertTrue(readCount.get() > 0);    Assert.assertTrue(maxConcurrentCount.get() > 1);}
0
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        for (int i = 0; i < ITERATIONS; ++i) {            if (random.nextInt(100) < 10) {                doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                writeCount.incrementAndGet();            } else {                doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                readCount.incrementAndGet();            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
0
public void testSetNodeData() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final byte[] nodeData = new byte[] { 1, 2, 3, 4 };        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock", nodeData);                nodeData[0] = 5;        lock.writeLock().acquire();        List<String> children = client.getChildren().forPath("/lock");        Assert.assertEquals(1, children.size());        byte[] dataInZk = client.getData().forPath("/lock/" + children.get(0));        Assert.assertNotNull(dataInZk);        Assert.assertEquals(new byte[] { 1, 2, 3, 4 }, dataInZk);        lock.writeLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
private void doLocking(InterProcessLock lock, AtomicInteger concurrentCount, AtomicInteger maxConcurrentCount, Random random, int maxAllowed) throws Exception
{    try {        Assert.assertTrue(lock.acquire(10, TimeUnit.SECONDS));        int localConcurrentCount;        synchronized (this) {            localConcurrentCount = concurrentCount.incrementAndGet();            if (localConcurrentCount > maxConcurrentCount.get()) {                maxConcurrentCount.set(localConcurrentCount);            }        }        Assert.assertTrue(localConcurrentCount <= maxAllowed, "" + localConcurrentCount);        Thread.sleep(random.nextInt(9) + 1);    } finally {        synchronized (this) {            concurrentCount.decrementAndGet();            lock.release();        }    }}
0
public void testAcquireAfterLostServer() throws Exception
{        final String SEMAPHORE_PATH = "/test";    final int MAX_SEMAPHORES = 1;    final int NUM_CLIENTS = 10;    ExecutorService executor = Executors.newFixedThreadPool(NUM_CLIENTS);    final Timing timing = new Timing();        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1));    try {        client.start();                InterProcessSemaphoreV2.debugAcquireLatch = new CountDownLatch(1);                InterProcessSemaphoreV2.debugFailedGetChildrenLatch = new CountDownLatch(1);        final CountDownLatch isReadyLatch = new CountDownLatch(NUM_CLIENTS);        final BlockingQueue<Boolean> acquiredQueue = Queues.newLinkedBlockingQueue();        Runnable runner = new Runnable() {            @Override            public void run() {                while (!Thread.currentThread().isInterrupted()) {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);                    Lease lease = null;                    try {                        isReadyLatch.countDown();                        lease = semaphore.acquire();                        acquiredQueue.add(true);                        timing.sleepABit();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        break;                    } catch (KeeperException e) {                        try {                            timing.sleepABit();                        } catch (InterruptedException e2) {                            Thread.currentThread().interrupt();                            break;                        }                    } catch (Exception ignore) {                                        } finally {                        if (lease != null) {                            semaphore.returnLease(lease);                        }                    }                }            }        };        for (int i = 0; i < NUM_CLIENTS; ++i) {            executor.execute(runner);        }        Assert.assertTrue(timing.awaitLatch(isReadyLatch));        timing.sleepABit();        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        server.stop();        Assert.assertTrue(timing.multiple(1.25).awaitLatch(lostLatch));                InterProcessSemaphoreV2.debugAcquireLatch.countDown();                Assert.assertTrue(timing.awaitLatch(InterProcessSemaphoreV2.debugFailedGetChildrenLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));        for (int i = 0; i < NUM_CLIENTS; ++i) {                        Boolean polled = acquiredQueue.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            if ((polled == null) || !polled) {                Assert.fail("Semaphores not reacquired after restart");            }        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
0
public void run()
{    while (!Thread.currentThread().isInterrupted()) {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);        Lease lease = null;        try {            isReadyLatch.countDown();            lease = semaphore.acquire();            acquiredQueue.add(true);            timing.sleepABit();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        } catch (KeeperException e) {            try {                timing.sleepABit();            } catch (InterruptedException e2) {                Thread.currentThread().interrupt();                break;            }        } catch (Exception ignore) {                } finally {            if (lease != null) {                semaphore.returnLease(lease);            }        }    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
0
public void testThreadedLeaseIncrease() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final SharedCount count = new SharedCount(client, "/foo/count", 1);        count.start();        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", count);        ExecutorService service = Executors.newCachedThreadPool();        final CountDownLatch latch1 = new CountDownLatch(1);        final CountDownLatch latch2 = new CountDownLatch(1);        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch1.countDown();                lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch2.countDown();                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                                timing.sleepABit();                Assert.assertTrue(count.trySetCount(2));                                timing.sleepABit();                Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));                return null;            }        });        future1.get();        future2.get();        count.close();    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch1.countDown();    lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch2.countDown();    return null;}
0
public Object call() throws Exception
{    Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        timing.sleepABit();    Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();    Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));    return null;}
0
public void testClientClose() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client1 = null;    CuratorFramework client2 = null;    InterProcessSemaphoreV2 semaphore1;    InterProcessSemaphoreV2 semaphore2;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client1.start();        client2.start();        semaphore1 = new InterProcessSemaphoreV2(client1, "/test", 1);        semaphore2 = new InterProcessSemaphoreV2(client2, "/test", 1);        Lease lease = semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        lease.close();        lease = semaphore1.acquire(10, TimeUnit.SECONDS);        Assert.assertNotNull(lease);                client1.close();        client1 = null;        Assert.assertNotNull(semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
0
public void testMaxPerSession() throws Exception
{    final int CLIENT_QTY = 10;    final int LOOP_QTY = 100;    final Random random = new Random();    final int SESSION_MAX = random.nextInt(75) + 25;    final Timing timing = new Timing();    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    final Counter counter = new Counter();    final AtomicInteger available = new AtomicInteger(SESSION_MAX);    for (int i = 0; i < CLIENT_QTY; ++i) {        futures.add(service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);                    for (int i = 0; i < LOOP_QTY; ++i) {                        long start = System.currentTimeMillis();                        int thisQty;                        synchronized (available) {                            if ((System.currentTimeMillis() - start) > 10000) {                                throw new TimeoutException();                            }                            while (available.get() == 0) {                                available.wait(timing.forWaiting().milliseconds());                            }                            thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                            available.addAndGet(-1 * thisQty);                            Assert.assertTrue(available.get() >= 0);                        }                        Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);                        Assert.assertNotNull(leases);                        try {                            synchronized (counter) {                                counter.currentCount += thisQty;                                if (counter.currentCount > counter.maxCount) {                                    counter.maxCount = counter.currentCount;                                }                            }                            Thread.sleep(random.nextInt(25));                        } finally {                            synchronized (counter) {                                counter.currentCount -= thisQty;                            }                            semaphore.returnAll(leases);                            synchronized (available) {                                available.addAndGet(thisQty);                                available.notifyAll();                            }                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        }));    }    for (Future<Object> f : futures) {        f.get();    }    synchronized (counter) {        Assert.assertTrue(counter.currentCount == 0);        Assert.assertTrue(counter.maxCount > 0);        Assert.assertTrue(counter.maxCount <= SESSION_MAX);        System.out.println(counter.maxCount);    }}
0
public Object call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);        for (int i = 0; i < LOOP_QTY; ++i) {            long start = System.currentTimeMillis();            int thisQty;            synchronized (available) {                if ((System.currentTimeMillis() - start) > 10000) {                    throw new TimeoutException();                }                while (available.get() == 0) {                    available.wait(timing.forWaiting().milliseconds());                }                thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                available.addAndGet(-1 * thisQty);                Assert.assertTrue(available.get() >= 0);            }            Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(leases);            try {                synchronized (counter) {                    counter.currentCount += thisQty;                    if (counter.currentCount > counter.maxCount) {                        counter.maxCount = counter.currentCount;                    }                }                Thread.sleep(random.nextInt(25));            } finally {                synchronized (counter) {                    counter.currentCount -= thisQty;                }                semaphore.returnAll(leases);                synchronized (available) {                    available.addAndGet(thisQty);                    available.notifyAll();                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
0
public void testRelease1AtATime() throws Exception
{    final Timing timing = new Timing();    final int CLIENT_QTY = 10;    final int MAX = CLIENT_QTY / 2;    final AtomicInteger maxLeases = new AtomicInteger(0);    final AtomicInteger activeQty = new AtomicInteger(0);    final AtomicInteger uses = new AtomicInteger(0);    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newFixedThreadPool(CLIENT_QTY);    for (int i = 0; i < CLIENT_QTY; ++i) {        Future<Object> f = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    Assert.assertNotNull(lease);                    uses.incrementAndGet();                    try {                        synchronized (maxLeases) {                            int qty = activeQty.incrementAndGet();                            if (qty > maxLeases.get()) {                                maxLeases.set(qty);                            }                        }                        timing.sleepABit();                    } finally {                        activeQty.decrementAndGet();                        lease.close();                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(f);    }    for (Future<Object> f : futures) {        f.get();    }    Assert.assertEquals(uses.get(), CLIENT_QTY);    Assert.assertEquals(maxLeases.get(), MAX);}
0
public Object call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        uses.incrementAndGet();        try {            synchronized (maxLeases) {                int qty = activeQty.incrementAndGet();                if (qty > maxLeases.get()) {                    maxLeases.set(qty);                }            }            timing.sleepABit();        } finally {            activeQty.decrementAndGet();            lease.close();        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
0
public void testReleaseInChunks() throws Exception
{    final Timing timing = new Timing();    final int MAX_LEASES = 11;    final int THREADS = 100;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Stepper latch = new Stepper();        final Random random = new Random();        final Counter counter = new Counter();        ExecutorService service = Executors.newCachedThreadPool();        ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);        for (int i = 0; i < THREADS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    if (lease == null) {                        throw new Exception("timed out");                    }                    try {                        synchronized (counter) {                            ++counter.currentCount;                            if (counter.currentCount > counter.maxCount) {                                counter.maxCount = counter.currentCount;                            }                            counter.notifyAll();                        }                        latch.await();                    } finally {                        synchronized (counter) {                            --counter.currentCount;                        }                        semaphore.returnLease(lease);                    }                    return null;                }            });        }        int remaining = THREADS;        while (remaining > 0) {            int times = Math.min(random.nextInt(5) + 1, remaining);            latch.countDown(times);            remaining -= times;            Thread.sleep(random.nextInt(100) + 1);        }        for (int i = 0; i < THREADS; ++i) {            completionService.take();        }        timing.sleepABit();        synchronized (counter) {            Assert.assertTrue(counter.currentCount == 0);            Assert.assertTrue(counter.maxCount > 0);            Assert.assertTrue(counter.maxCount <= MAX_LEASES);            System.out.println(counter.maxCount);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    if (lease == null) {        throw new Exception("timed out");    }    try {        synchronized (counter) {            ++counter.currentCount;            if (counter.currentCount > counter.maxCount) {                counter.maxCount = counter.currentCount;            }            counter.notifyAll();        }        latch.await();    } finally {        synchronized (counter) {            --counter.currentCount;        }        semaphore.returnLease(lease);    }    return null;}
0
public void testThreads() throws Exception
{    final int THREAD_QTY = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        ExecutorService service = Executors.newFixedThreadPool(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    Lease lease = semaphore.acquire();                    try {                        Thread.sleep(1);                    } finally {                        lease.close();                    }                    return null;                }            });        }        service.shutdown();        Assert.assertTrue(service.awaitTermination(10, TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    Lease lease = semaphore.acquire();    try {        Thread.sleep(1);    } finally {        lease.close();    }    return null;}
0
public void testSimple() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testSimple2() throws Exception
{    final int MAX_LEASES = 3;    Timing timing = new Timing();    List<Lease> leases = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        for (int i = 0; i < MAX_LEASES; ++i) {            InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);            Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(lease);            leases.add(lease);        }        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNull(lease);        leases.remove(0).close();        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
0
public void testGetParticipantNodes() throws Exception
{    final int LEASES = 3;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    List<Lease> leases = Lists.newArrayList();    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", LEASES);        for (int i = 0; i < LEASES; ++i) {            leases.add(semaphore.acquire());        }        Assert.assertEquals(semaphore.getParticipantNodes().size(), LEASES);    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
0
public void testChildReaperCleansUpLockNodes() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    ChildReaper childReaper = null;    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test/lock", 1);        semaphore.returnLease(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(client.getChildren().forPath("/test").size() > 0);        childReaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_GONE, ChildReaper.newExecutorService(), 1, "/test-leader", InterProcessSemaphoreV2.LOCK_SCHEMA);        childReaper.start();        timing.forWaiting().sleepABit();        try {            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(children.size(), 0, "All children of /test should have been reaped");        } catch (KeeperException.NoNodeException ok) {                }    } finally {        CloseableUtils.closeQuietly(childReaper);        CloseableUtils.closeQuietly(client);    }}
0
public void testNoOrphanedNodes() throws Exception
{    final Timing timing = new Timing();    final ExecutorService executor = Executors.newFixedThreadPool(1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        final List<String> childNodes = client.getChildren().forPath("/test/leases");        Assert.assertEquals(childNodes.size(), 1);        final CountDownLatch nodeCreatedLatch = new CountDownLatch(1);        client.getChildren().usingWatcher(new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getType() == Watcher.Event.EventType.NodeCreated) {                    nodeCreatedLatch.countDown();                }            }        }).forPath("/test/leases");        final Future<Lease> leaseFuture = executor.submit(new Callable<Lease>() {            @Override            public Lease call() throws Exception {                return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);            }        });                timing.awaitLatch(nodeCreatedLatch);        String newNode = null;        for (String c : client.getChildren().forPath("/test/leases")) {            if (!childNodes.contains(c)) {                newNode = c;            }        }        Assert.assertNotNull(newNode);                client.delete().forPath("/test/leases/" + newNode);                lease.close();        lease = leaseFuture.get();        Assert.assertNotNull(lease);        lease.close();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 0);                Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        executor.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeCreated) {        nodeCreatedLatch.countDown();    }}
0
public Lease call() throws Exception
{    return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);}
0
public void testInterruptAcquire() throws Exception
{        final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 s1 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s2 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s3 = new InterProcessSemaphoreV2(client, "/test", 1);        final CountDownLatch debugWaitLatch = s2.debugWaitLatch = new CountDownLatch(1);                Lease lease = s1.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);                Future<Object> handle = Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                s2.acquire();                return null;            }        });                Assert.assertTrue(timing.awaitLatch(debugWaitLatch));                handle.cancel(true);                timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 1);                s1.returnLease(lease);        Assert.assertNotNull(s3.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public Object call() throws Exception
{    s2.acquire();    return null;}
0
public void testKilledServerWithEnsembleProvider() throws Exception
{    final int CLIENT_QTY = 10;    final Timing timing = new Timing();    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(CLIENT_QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        final AtomicReference<String> connectionString = new AtomicReference<String>(cluster.getConnectString());        final EnsembleProvider provider = new EnsembleProvider() {            @Override            public void setConnectionString(String connectionString) {            }            @Override            public boolean updateServerListEnabled() {                return false;            }            @Override            public void start() throws Exception {            }            @Override            public String getConnectionString() {                return connectionString.get();            }            @Override            public void close() throws IOException {            }        };        final Semaphore acquiredSemaphore = new Semaphore(0);        final AtomicInteger acquireCount = new AtomicInteger(0);        final CountDownLatch suspendedLatch = new CountDownLatch(CLIENT_QTY);        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();                    try {                        final Semaphore suspendedSemaphore = new Semaphore(0);                        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {                            @Override                            public void stateChanged(CuratorFramework client, ConnectionState newState) {                                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                                    suspendedLatch.countDown();                                    suspendedSemaphore.release();                                }                            }                        });                        client.start();                        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);                        while (!Thread.currentThread().isInterrupted()) {                            Lease lease = null;                            try {                                lease = semaphore.acquire();                                acquiredSemaphore.release();                                acquireCount.incrementAndGet();                                suspendedSemaphore.acquire();                            } catch (Exception e) {                                                        } finally {                                if (lease != null) {                                    acquireCount.decrementAndGet();                                    CloseableUtils.closeQuietly(lease);                                }                            }                        }                    } finally {                        TestCleanState.closeAndTestClean(client);                    }                    return null;                }            });        }        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        Assert.assertEquals(1, acquireCount.get());        cluster.close();        timing.awaitLatch(suspendedLatch);        timing.forWaiting().sleepABit();        Assert.assertEquals(0, acquireCount.get());        cluster = new TestingCluster(3);        cluster.start();        connectionString.set(cluster.getConnectString());        timing.forWaiting().sleepABit();        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        timing.forWaiting().sleepABit();        Assert.assertEquals(1, acquireCount.get());    } finally {        executorService.shutdown();        executorService.awaitTermination(10, TimeUnit.SECONDS);        executorService.shutdownNow();        CloseableUtils.closeQuietly(cluster);    }}
0
public void setConnectionString(String connectionString)
{}
0
public boolean updateServerListEnabled()
{    return false;}
0
public void start() throws Exception
{}
0
public String getConnectionString()
{    return connectionString.get();}
0
public void close() throws IOException
{}
0
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        final Semaphore suspendedSemaphore = new Semaphore(0);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    suspendedLatch.countDown();                    suspendedSemaphore.release();                }            }        });        client.start();        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);        while (!Thread.currentThread().isInterrupted()) {            Lease lease = null;            try {                lease = semaphore.acquire();                acquiredSemaphore.release();                acquireCount.incrementAndGet();                suspendedSemaphore.acquire();            } catch (Exception e) {                        } finally {                if (lease != null) {                    acquireCount.decrementAndGet();                    CloseableUtils.closeQuietly(lease);                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        suspendedLatch.countDown();        suspendedSemaphore.release();    }}
0
public void testCluster() throws Exception
{    final int QTY = 20;    final int OPERATION_TIME_MS = 1000;    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    List<SemaphoreClient> semaphoreClients = Lists.newArrayList();    try {        cluster.start();        final AtomicInteger opCount = new AtomicInteger(0);        for (int i = 0; i < QTY; ++i) {            SemaphoreClient semaphoreClient = new SemaphoreClient(cluster.getConnectString(), PATH, new Callable<Void>() {                @Override                public Void call() throws Exception {                    opCount.incrementAndGet();                    Thread.sleep(OPERATION_TIME_MS);                    return null;                }            });            completionService.submit(semaphoreClient);            semaphoreClients.add(semaphoreClient);        }        timing.forWaiting().sleepABit();        Assert.assertNotNull(SemaphoreClient.getActiveClient());        final CountDownLatch latch = new CountDownLatch(1);        CuratorFramework client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        try {            client.getZookeeperClient().blockUntilConnectedOrTimedOut();            cluster.stop();            latch.await();        } finally {            CloseableUtils.closeQuietly(client);        }        long startTicks = System.currentTimeMillis();        for (; ; ) {            int thisOpCount = opCount.get();            Thread.sleep(2 * OPERATION_TIME_MS);            if (thisOpCount == opCount.get()) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }        int thisOpCount = opCount.get();        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        cluster = new TestingCluster(iterator.next(), iterator.next());        cluster.start();        timing.forWaiting().sleepABit();        startTicks = System.currentTimeMillis();        for (; ; ) {            Thread.sleep(2 * OPERATION_TIME_MS);            if (opCount.get() > thisOpCount) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }    } finally {        for (SemaphoreClient semaphoreClient : semaphoreClients) {            CloseableUtils.closeQuietly(semaphoreClient);        }        CloseableUtils.closeQuietly(cluster);        executorService.shutdownNow();    }}
0
public Void call() throws Exception
{    opCount.incrementAndGet();    Thread.sleep(OPERATION_TIME_MS);    return null;}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
0
public void testReentrant()
{}
0
public void testReentrant2Threads()
{}
0
public void testReentrantSingleLock()
{}
0
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessSemaphoreMutex(client, LOCK_PATH);}
0
private CuratorFramework createClient(ACLProvider provider) throws Exception
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("ns").connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).build();    client.start();    return client;}
0
public void testLockACLs() throws Exception
{    CuratorFramework client = createClient(new TestLockACLsProvider());    try {        client.create().forPath("/foo");        Assert.assertNotNull(client.checkExists().forPath("/foo"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/foo").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/foo").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/foo").get(0).getId().getId());        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/bar");        InterProcessMutex writeLock = lock.writeLock();        writeLock.acquire();        Assert.assertNotNull(client.checkExists().forPath("/bar"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/bar").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/bar").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/bar").get(0).getId().getId());    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void testACLsCreatingParents() throws Exception
{    CuratorFramework client = createClient(new TestACLsCreatingParentsProvider());    try {        client.create().creatingParentsIfNeeded().forPath("/parent/foo");        Assert.assertEquals(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, client.getACL().forPath("/parent").get(0).getPerms());        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/parent/foo").get(0).getPerms());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    return ACLS1;}
0
public List<ACL> getAclForPath(String path)
{    if (path.equals("/ns/parent")) {        return ACLS2;    }    return ACLS1;}
0
public List<ACL> getDefaultAcl()
{    return ACLS1;}
0
public List<ACL> getAclForPath(String path)
{    return ACLS1;}
0
public void testNodeDeleted() throws Exception
{    final String PATH = "/foo/bar";    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(0, 0));        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);        LockInternals internals = new LockInternals(client, new StandardLockInternalsDriver(), PATH, "lock-", 1) {            @Override            List<String> getSortedChildren() throws Exception {                throw new KeeperException.NoNodeException();            }        };        try {            internals.attemptLock(0, null, null);            Assert.fail();        } catch (KeeperException.NoNodeException dummy) {                }                Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
 List<String> getSortedChildren() throws Exception
{    throw new KeeperException.NoNodeException();}
0
public void testUsingLeaderPath() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        CloseableUtils.closeQuietly(client);    }}
0
protected void reap(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
0
protected void reap(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
0
public void testUsingLeaderLatch() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    LeaderLatch leaderLatch1 = null;    LeaderLatch leaderLatch2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        leaderLatch1 = new LeaderLatch(client, "/reaper/leader");        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch1) {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        leaderLatch2 = new LeaderLatch(client, "/reaper/leader");        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch2) {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        leaderLatch1.start();        leaderLatch2.start();        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        LeaderLatch activeLeaderLeatch;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            activeLeaderLeatch = leaderLatch1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            activeLeaderLeatch = leaderLatch2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        activeLeaderLeatch.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        if (leaderLatch1 != null && LeaderLatch.State.STARTED == leaderLatch1.getState()) {            CloseableUtils.closeQuietly(leaderLatch1);        }        if (leaderLatch2 != null && LeaderLatch.State.STARTED == leaderLatch2.getState()) {            CloseableUtils.closeQuietly(leaderLatch2);        }        CloseableUtils.closeQuietly(client);    }}
0
protected void reap(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
0
protected void reap(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
0
public void testUsingManualLeader() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = makeClient(timing, null);    final CountDownLatch latch = new CountDownLatch(1);    LeaderSelectorListener listener = new LeaderSelectorListener() {        @Override        public void takeLeadership(CuratorFramework client) throws Exception {            Reaper reaper = new Reaper(client, 1);            try {                reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);                reaper.start();                timing.sleepABit();                latch.countDown();            } finally {                CloseableUtils.closeQuietly(reaper);            }        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    LeaderSelector selector = new LeaderSelector(client, "/leader", listener);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        selector.start();        timing.awaitLatch(latch);        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
0
public void takeLeadership(CuratorFramework client) throws Exception
{    Reaper reaper = new Reaper(client, 1);    try {        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        reaper.start();        timing.sleepABit();        latch.countDown();    } finally {        CloseableUtils.closeQuietly(reaper);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testSparseUseNoReap() throws Exception
{    final int THRESHOLD = 3000;    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, null);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        final Queue<Reaper.PathHolder> holders = new ConcurrentLinkedQueue<Reaper.PathHolder>();        final ExecutorService pool = Executors.newCachedThreadPool();        ScheduledExecutorService service = new ScheduledThreadPoolExecutor(1);        reaper = new Reaper(client, service, THRESHOLD) {            @Override            protected Future<Void> schedule(final PathHolder pathHolder, int reapingThresholdMs) {                holders.add(pathHolder);                final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);                pool.submit(new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        f.get();                        holders.remove(pathHolder);                        return null;                    }                });                return null;            }        };        reaper.start();        reaper.addPath("/one/two/three");        long start = System.currentTimeMillis();        boolean emptyCountIsCorrect = false;        while (        ((System.currentTimeMillis() - start) < timing.forWaiting().milliseconds()) && !emptyCountIsCorrect) {            for (Reaper.PathHolder holder : holders) {                if (holder.path.endsWith("/one/two/three")) {                    emptyCountIsCorrect = (holder.emptyCount > 0);                    break;                }            }            Thread.sleep(1);        }        Assert.assertTrue(emptyCountIsCorrect);        client.create().forPath("/one/two/three/foo");        Thread.sleep(2 * (THRESHOLD / Reaper.EMPTY_COUNT_THRESHOLD));        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three/foo");        Thread.sleep(THRESHOLD);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
protected Future<Void> schedule(final PathHolder pathHolder, int reapingThresholdMs)
{    holders.add(pathHolder);    final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);    pool.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            f.get();            holders.remove(pathHolder);            return null;        }    });    return null;}
0
public Void call() throws Exception
{    f.get();    holders.remove(pathHolder);    return null;}
0
public void testReapUntilDelete() throws Exception
{    testReapUntilDelete(null);}
0
public void testReapUntilDeleteNamespace() throws Exception
{    testReapUntilDelete("test");}
0
public void testReapUntilGone() throws Exception
{    testReapUntilGone(null);}
0
public void testReapUntilGoneNamespace() throws Exception
{    testReapUntilGone("test");}
0
public void testRemove() throws Exception
{    testRemove(null);}
0
public void testRemoveNamespace() throws Exception
{    testRemove("test");}
0
public void testSimulationWithLocks() throws Exception
{    testSimulationWithLocks(null);}
0
public void testSimulationWithLocksNamespace() throws Exception
{    testSimulationWithLocks("test");}
0
public void testWithEphemerals() throws Exception
{    testWithEphemerals(null);}
0
public void testWithEphemeralsNamespace() throws Exception
{    testWithEphemerals("test");}
0
public void testBasic() throws Exception
{    testBasic(null);}
0
public void testBasicNamespace() throws Exception
{    testBasic("test");}
0
private void testReapUntilDelete(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
private void testReapUntilGone(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
private CuratorFramework makeClient(Timing timing, String namespace) throws IOException
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    if (namespace != null) {        builder = builder.namespace(namespace);    }    return builder.build();}
0
private void testRemove(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertTrue(reaper.removePath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
private void testSimulationWithLocks(String namespace) throws Exception
{    final int LOCK_CLIENTS = 10;    final int ITERATIONS = 250;    final int MAX_WAIT_MS = 10;    ExecutorService service = Executors.newFixedThreadPool(LOCK_CLIENTS);    ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);    Timing timing = new Timing();    Reaper reaper = null;    final CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, MAX_WAIT_MS / 2);        reaper.start();        reaper.addPath("/a/b");        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");                    for (int i = 0; i < ITERATIONS; ++i) {                        lock.acquire();                        try {                            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));                        } finally {                            lock.release();                        }                    }                    return null;                }            });        }        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.take().get();        }        Thread.sleep(timing.session());        timing.sleepABit();        Stat stat = client.checkExists().forPath("/a/b");        Assert.assertNull(stat, "Child qty: " + ((stat != null) ? stat.getNumChildren() : 0));    } finally {        service.shutdownNow();        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
public Object call() throws Exception
{    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");    for (int i = 0; i < ITERATIONS; ++i) {        lock.acquire();        try {            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));        } finally {            lock.release();        }    }    return null;}
0
private void testWithEphemerals(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client2 = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client2 = makeClient(timing, namespace);        client2.start();        for (int i = 0; i < 10; ++i) {            client2.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/one/two/three/foo-");        }        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));                client2.close();        client2 = null;        Thread.sleep(timing.session());        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
0
private void testBasic(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    Timing timing = new Timing();    GroupMember groupMember1 = null;    GroupMember groupMember2 = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        groupMember1 = new GroupMember(client, "/member", "1");        Assert.assertTrue(groupMember1.getCurrentMembers().containsKey("1"));        groupMember1.start();        groupMember2 = new GroupMember(client, "/member", "2");        groupMember2.start();        timing.sleepABit();        Map<String, byte[]> currentMembers1 = groupMember1.getCurrentMembers();        Map<String, byte[]> currentMembers2 = groupMember2.getCurrentMembers();        Map<String, String> convertMembers1 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Map<String, String> convertMembers2 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Assert.assertEquals(convertMembers1.size(), 2);        Assert.assertEquals(convertMembers2.size(), 2);        Assert.assertEquals(convertMembers1, convertMembers2);        Assert.assertTrue(convertMembers1.containsKey("1"));        Assert.assertTrue(convertMembers1.containsKey("2"));        groupMember2.close();        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertEquals(currentMembers1.size(), 1);        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertFalse(currentMembers1.containsKey("2"));        groupMember1.setThisData("something".getBytes());        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertEquals(currentMembers1.get("1"), "something".getBytes());    } finally {        CloseableUtils.closeQuietly(groupMember1);        CloseableUtils.closeQuietly(groupMember2);        CloseableUtils.closeQuietly(client);    }}
0
public String apply(byte[] input)
{    return new String(input);}
0
public String apply(byte[] input)
{    return new String(input);}
0
public void teardown() throws Exception
{    try {        for (PersistentEphemeralNode node : createdNodes) {            CloseableUtils.closeQuietly(node);        }        for (CuratorFramework curator : curatorInstances) {            TestCleanState.closeAndTestClean(curator);        }    } finally {        super.teardown();    }}
0
public void testListenersReconnectedIsFast() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        try (PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes())) {            node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());            node.start();            final CountDownLatch connectedLatch = new CountDownLatch(1);            final CountDownLatch reconnectedLatch = new CountDownLatch(1);            ConnectionStateListener listener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    if (newState == ConnectionState.CONNECTED) {                        connectedLatch.countDown();                    }                    if (newState == ConnectionState.RECONNECTED) {                        reconnectedLatch.countDown();                    }                }            };            client.getConnectionStateListenable().addListener(listener);            timing.sleepABit();            server.restart();            Assert.assertTrue(timing.awaitLatch(connectedLatch));            timing.sleepABit();            Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            server.stop();            timing.sleepABit();            server.restart();            timing.sleepABit();            Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
public void testNoServerAtStart() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
0
public void testNullCurator() throws Exception
{    new PersistentEphemeralNode(null, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);}
0
public void testNullPath() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, null, new byte[0]);}
0
public void testNullData() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, null);}
0
public void testNullMode() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, null, PATH, new byte[0]);}
0
public void testSettingDataSequential() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL);}
0
public void testSettingData() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL);}
0
protected void setDataTest(PersistentEphemeralNode.Mode mode) throws Exception
{    PersistentEphemeralNode node = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        node = new PersistentEphemeralNode(client, mode, PATH, "a".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertEquals(client.getData().forPath(node.getActualPath()), "a".getBytes());        final Semaphore semaphore = new Semaphore(0);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent arg0) {                semaphore.release();            }        };        client.checkExists().usingWatcher(watcher).forPath(node.getActualPath());        node.setData("b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "b".getBytes());        node.setData("c".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "c".getBytes());        node.close();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
0
public void process(WatchedEvent arg0)
{    semaphore.release();}
0
public void testDeletesNodeWhenClosed() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    String path = null;    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        path = node.getActualPath();        assertNodeExists(curator, path);    } finally {        CloseableUtils.closeQuietly(node);    }    assertNodeDoesNotExist(curator, path);}
0
public void testClosingMultipleTimes() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);    String path = node.getActualPath();    node.close();    assertNodeDoesNotExist(curator, path);    node.close();    assertNodeDoesNotExist(curator, path);}
0
public void testDeletesNodeWhenSessionDisconnects() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());                Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testRecreatesNodeWhenSessionReconnects() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testRecreatesNodeWhenSessionReconnectsMultipleTimes() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path = node.getActualPath();        assertNodeExists(observer, path);                for (int i = 0; i < 5; i++) {            Trigger deletionTrigger = Trigger.deletedOrSetData();            Stat stat = observer.checkExists().usingWatcher(deletionTrigger).forPath(path);            Assert.assertNotNull(stat, "node should exist: " + path);            node.debugCreateNodeLatch = new CountDownLatch(1);                        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                        assertTrue(deletionTrigger.firedWithin(timing.multiple(1.5).forSessionSleep().seconds(), TimeUnit.SECONDS));            node.debugCreateNodeLatch.countDown();                        Trigger creationTrigger = Trigger.created();            stat = observer.checkExists().usingWatcher(creationTrigger).forPath(path);            assertTrue(stat != null || creationTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        }    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testRecreatesNodeWhenEphemeralOwnerSessionExpires() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework nodeCreator = newCurator();    CuratorFramework observer = newCurator();    nodeCreator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, new byte[0]);    Trigger dataChangedTrigger = Trigger.dataChanged();    observer.getData().usingWatcher(dataChangedTrigger).forPath(PATH);    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        assertTrue(dataChangedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        Compatibility.injectSessionExpiration(nodeCreator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        node.close();    }}
0
public void testRecreatesNodeWhenItGetsDeleted() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String originalNode = node.getActualPath();        assertNodeExists(curator, originalNode);                curator.delete().forPath(originalNode);                        Trigger createdWatchTrigger = Trigger.created();        Stat stat = curator.checkExists().usingWatcher(createdWatchTrigger).forPath(originalNode);        assertTrue(stat != null || createdWatchTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testNodesCreateUniquePaths() throws Exception
{    CuratorFramework curator = newCurator();    try (PersistentEphemeralNode node1 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0])) {        node1.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node1.start();        node1.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path1 = node1.getActualPath();        PersistentEphemeralNode node2 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0]);        node2.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node2.start();        try {            node2.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);            String path2 = node2.getActualPath();            assertFalse(path1.equals(path2));        } finally {            node2.close();        }    }}
0
public void testData() throws Exception
{    CuratorFramework curator = newCurator();    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testSetDataWhenNodeExists() throws Exception
{    CuratorFramework curator = newCurator();    curator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, "InitialData".getBytes());    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testSetDataWhenDisconnected() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        server.stop();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == EventType.NodeDataChanged) {                    dataUpdateLatch.countDown();                }            }        };        curator.getData().usingWatcher(watcher).inBackground().forPath(node.getActualPath());        node.setData(updatedData);        server.restart();        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void process(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        dataUpdateLatch.countDown();    }}
0
public void testSetUpdatedDataWhenReconnected() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        node.setData(updatedData);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));        server.restart();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        curator.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                dataUpdateLatch.countDown();            }        }).forPath(node.getActualPath());        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    dataUpdateLatch.countDown();}
0
public void testProtected() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.PROTECTED_EPHEMERAL, PATH, new byte[0]);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());        server.restart();        curator.blockUntilConnected(5, TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());                List<String> children = curator.getChildren().forPath(DIR);        assertFalse(children == null);        assertEquals(children.size(), 1);    } finally {        CloseableUtils.closeQuietly(node);    }}
0
public void testNoCreatePermission() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath(DIR, new byte[0]);        client.close();                client = newCurator();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS);        assertNodeDoesNotExist(client, PATH);        assertTrue(node.isAuthFailure());    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
0
public void testNoWritePermission() throws Exception
{    final ACLProvider aclProvider = new ACLProvider() {        final ACL acl = new ACL(ZooDefs.Perms.READ | ZooDefs.Perms.CREATE | ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE);        final List<ACL> aclList = Collections.singletonList(acl);        @Override        public List<ACL> getDefaultAcl() {            return aclList;        }        @Override        public List<ACL> getAclForPath(String path) {            return aclList;        }    };    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).aclProvider(aclProvider).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.start();        assertTrue(node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS), "Node not created");        assertNodeExists(client, PATH);        assertFalse(node.isAuthFailure(), "AuthFailure when creating node.");        byte[] NEW_DATA = "NEW_DATA".getBytes();        node.setData(NEW_DATA);        timing.sleepABit();        byte[] read_data = client.getData().forPath(PATH);        assertNotEquals(read_data, NEW_DATA, "Data matches - write went through.");        assertTrue(node.isAuthFailure(), "AuthFailure response not received.");    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    return aclList;}
0
public List<ACL> getAclForPath(String path)
{    return aclList;}
0
private void assertNodeExists(CuratorFramework curator, String path) throws Exception
{    assertNotNull(path);    assertTrue(curator.checkExists().forPath(path) != null);}
0
private void assertNodeDoesNotExist(CuratorFramework curator, String path) throws Exception
{    assertTrue(curator.checkExists().forPath(path) == null);}
0
private CuratorFramework newCurator() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    curatorInstances.add(client);    return client;}
0
public void process(WatchedEvent event)
{    if (types.contains(event.getType())) {        latch.countDown();    } else if (event.getType() != EventType.None) {            }}
1
public boolean firedWithin(long duration, TimeUnit unit)
{    try {        return latch.await(duration, unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw Throwables.propagate(e);    }}
0
private static Trigger created()
{    return new Trigger(Event.EventType.NodeCreated);}
0
private static Trigger deletedOrSetData()
{    return new Trigger(Event.EventType.NodeDeleted, EventType.NodeDataChanged);}
0
private static Trigger dataChanged()
{    return new Trigger(EventType.NodeDataChanged);}
0
public void testListenersReconnectedIsOK() throws Exception
{    server.stop();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
0
public void testQuickSetData() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    final byte[] ALT_TEST_DATA = "there".getBytes();    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.start();        try {            pen.setData(ALT_TEST_DATA);            Assert.fail("IllegalStateException should have been thrown");        } catch (IllegalStateException dummy) {                }    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    Timing2 timing = new Timing2();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        pen.start();        Assert.assertTrue(pen.waitForInitialCreate(timing.milliseconds(), TimeUnit.MILLISECONDS));                client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        byte[] bytes = client.getData().forPath("/test");        Assert.assertEquals(bytes, TEST_DATA);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
0
public void testQuickClose() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
0
public void testQuickCloseNodeExists() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one/two");        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
0
public void testEphemeralSequentialWithProtectionReconnection() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one");        pen = new PersistentNode(client, CreateMode.EPHEMERAL_SEQUENTIAL, true, "/test/one/two", new byte[0]);        pen.start();        List<String> children = client.getChildren().forPath("/test/one");        System.out.println("children before restart: " + children);        Assert.assertEquals(1, children.size());        server.stop();        timing.sleepABit();        server.restart();        timing.sleepABit();        List<String> childrenAfter = client.getChildren().forPath("/test/one");        System.out.println("children after restart: " + childrenAfter);        Assert.assertEquals(children, childrenAfter, "unexpected znodes: " + childrenAfter);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
0
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
0
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
0
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
0
public void testBasic() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                                Thread.sleep(ttlMs + (ttlMs / 2));                Assert.assertNotNull(client.checkExists().forPath("/test"));            }        }        Assert.assertNotNull(client.checkExists().forPath("/test"));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
0
public void testForcedDeleteOfTouchNode() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                Thread.sleep(ttlMs);                client.delete().quietly().forPath(ZKPaths.makePath("test", PersistentTtlNode.DEFAULT_CHILD_NODE_NAME));            }            timing.sleepABit();            Assert.assertNotNull(client.checkExists().forPath("/test"));        }    }}
0
public void testEventsOnParent() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            try (PathChildrenCache cache = new PathChildrenCache(client, "/", true)) {                final Semaphore changes = new Semaphore(0);                PathChildrenCacheListener listener = new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {                            changes.release();                        }                    }                };                cache.getListenable().addListener(listener);                node.start();                Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));                cache.start(BUILD_INITIAL_CACHE);                Assert.assertEquals(changes.availablePermits(), 0);                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);                client.setData().forPath("/test", "changed".getBytes());                Assert.assertTrue(timing.acquireSemaphore(changes));                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);            }        }        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {        changes.release();    }}
0
public byte[] serialize(TestQueueItem item)
{    return item.str.getBytes();}
0
public TestQueueItem deserialize(byte[] bytes)
{    return new TestQueueItem(new String(bytes));}
0
public Void call() throws Exception
{    int count = 0;    while (!Thread.currentThread().isInterrupted() && (count < itemQty)) {        queue.put(new TestQueueItem(Integer.toString(count + startIndex)));        ++count;    }    return null;}
0
public byte[] serialize(String item)
{    return item.getBytes();}
0
public String deserialize(byte[] bytes)
{    return new String(bytes);}
0
public void testMulti() throws Exception
{    final String PATH = "/queue";    final int CLIENT_QTY = 4;    final int MAX_ITEMS = 10;    final int ADD_ITEMS = MAX_ITEMS * 100;    final QueueConsumer<String> consumer = new QueueConsumer<String>() {        @Override        public void consumeMessage(String message) throws Exception {            Thread.sleep(10);        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    final Timing timing = new Timing();    final ExecutorService executor = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executor);    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);        final CountDownLatch isWaitingLatch = new CountDownLatch(1);        final AtomicBoolean isDone = new AtomicBoolean(false);        final List<Integer> counts = new CopyOnWriteArrayList<Integer>();        final Object lock = new Object();        executor.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Watcher watcher = new Watcher() {                    @Override                    public void process(WatchedEvent event) {                        synchronized (lock) {                            lock.notifyAll();                        }                    }                };                while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {                    synchronized (lock) {                        int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();                        counts.add(size);                        isWaitingLatch.countDown();                        lock.wait();                    }                }                return null;            }        });        isWaitingLatch.await();        for (int i = 0; i < CLIENT_QTY; ++i) {            final int index = i;            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = null;                    DistributedQueue<String> queue = null;                    try {                        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                        client.start();                        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();                        queue.start();                        for (int i = 0; i < ADD_ITEMS; ++i) {                            queue.put("" + index + "-" + i);                        }                    } finally {                        CloseableUtils.closeQuietly(queue);                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            });        }        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.take().get();        }        isDone.set(true);        synchronized (lock) {            lock.notifyAll();        }        for (int count : counts) {            Assert.assertTrue(count <= (MAX_ITEMS * CLIENT_QTY), counts.toString());        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(String message) throws Exception
{    Thread.sleep(10);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public Void call() throws Exception
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            synchronized (lock) {                lock.notifyAll();            }        }    };    while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {        synchronized (lock) {            int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();            counts.add(size);            isWaitingLatch.countDown();            lock.wait();        }    }    return null;}
0
public void process(WatchedEvent event)
{    synchronized (lock) {        lock.notifyAll();    }}
0
public Void call() throws Exception
{    CuratorFramework client = null;    DistributedQueue<String> queue = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();        queue.start();        for (int i = 0; i < ADD_ITEMS; ++i) {            queue.put("" + index + "-" + i);        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }    return null;}
0
public void testSimple() throws Exception
{    Timing timing = new Timing();    DistributedQueue<String> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final List<String> messages = new CopyOnWriteArrayList<String>();        final CountDownLatch latch = new CountDownLatch(2);        final Semaphore semaphore = new Semaphore(0);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                messages.add(message);                semaphore.acquire();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, "/queue").executor(Executors.newSingleThreadExecutor()).maxItems(1).buildQueue();        queue.start();        QueuePutListener<String> listener = new QueuePutListener<String>() {            @Override            public void putCompleted(String item) {                latch.countDown();            }            @Override            public void putMultiCompleted(MultiItem<String> items) {            }        };        queue.getPutListenerContainer().addListener(listener);                Assert.assertTrue(queue.put("1", timing.milliseconds(), TimeUnit.MILLISECONDS));                Assert.assertTrue(queue.put("2", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertFalse(queue.put("3", timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));        semaphore.release(100);        Assert.assertTrue(queue.put("3", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("4", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("5", timing.milliseconds(), TimeUnit.MILLISECONDS));        for (int i = 0; i < 5; ++i) {            if (messages.size() == 3) {                break;            }            timing.sleepABit();        }        timing.sleepABit();        Assert.assertEquals(messages, Arrays.asList("1", "2", "3", "4", "5"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(String message) throws Exception
{    messages.add(message);    semaphore.acquire();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void putCompleted(String item)
{    latch.countDown();}
0
public void putMultiCompleted(MultiItem<String> items)
{}
0
public void testLateAddition() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();                queue.put(1L, System.currentTimeMillis() + Integer.MAX_VALUE);        Long value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);        queue.put(2L, System.currentTimeMillis());        value = consumer.take(timing.seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(2));        value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        queue.put(1L, System.currentTimeMillis() + 1000);        Thread.sleep(100);                Assert.assertEquals(consumer.size(), 0);        Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testSimple() throws Exception
{    final int QTY = 10;    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        Random random = new Random();        for (int i = 0; i < QTY; ++i) {            long delay = System.currentTimeMillis() + random.nextInt(100);            queue.put(delay, delay);        }        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(value);            Assert.assertTrue(value >= lastValue);            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testSorting() throws Exception
{    Timing timing = new Timing();        final int QTY = 1000;    final int DELAY_MS = timing.multiple(.1).milliseconds();    DistributedDelayQueue<Long> putQueue = null;    DistributedDelayQueue<Long> getQueue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        putQueue = QueueBuilder.builder(client, null, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        putQueue.start();        Map<Long, Long> data = new HashMap<Long, Long>();                                        long delay = System.currentTimeMillis() + DELAY_MS;        for (long i = 0; i < QTY; ++i) {            data.put(delay, i);                        delay += 1;        }                List<Long> keys = new ArrayList<Long>(data.keySet());        Collections.shuffle(keys);                for (Long key : keys) {            putQueue.put(data.get(key), key);        }        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        getQueue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        getQueue.start();        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(DELAY_MS * 2, TimeUnit.MILLISECONDS);            Assert.assertNotNull(value);            Assert.assertEquals(value, new Long(lastValue + 1));            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(putQueue);        CloseableUtils.closeQuietly(getQueue);        CloseableUtils.closeQuietly(client);    }}
0
public byte[] serialize(Long item)
{    return Long.toString(item).getBytes();}
0
public Long deserialize(byte[] bytes)
{    return Long.parseLong(new String(bytes));}
0
public void testDeletingWithLock() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        final CountDownLatch waitLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                waitLatch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(queue.remove("id"), 0);        waitLatch.countDown();    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(TestQueueItem message) throws Exception
{    consumingLatch.countDown();    waitLatch.await();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testOrdering() throws Exception
{    final int ITEM_QTY = 100;    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildIdQueue();        queue.start();        List<String> ids = Lists.newArrayList();        for (int i = 0; i < ITEM_QTY; ++i) {            String id = Double.toString(Math.random());            ids.add(id);            queue.put(new TestQueueItem(id), id);        }        int iteration = 0;        while (consumer.size() < ITEM_QTY) {            Assert.assertTrue(++iteration < ITEM_QTY);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, ids.get(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testRequeuingWithLock() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                                throw new Exception("Consumer failed");            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Assert.assertTrue(queue.debugIsQueued("id"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(TestQueueItem message) throws Exception
{    consumingLatch.countDown();        throw new Exception("Consumer failed");}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testMinItemsBeforeRefresh() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int minItemsBeforeRefresh = 3;        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(minItemsBeforeRefresh);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10 + i);        }        Assert.assertEquals(consumer.take(1, TimeUnit.SECONDS), new Integer(0));                queue.put(1000, 1);        int count = 0;        while (consumer.take(1, TimeUnit.SECONDS) < 1000) {            ++count;        }                Assert.assertTrue(Math.abs(minItemsBeforeRefresh - count) < minItemsBeforeRefresh, String.format("Diff: %d - min: %d", Math.abs(minItemsBeforeRefresh - count), minItemsBeforeRefresh));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testSortingWhileTaking() throws Exception
{    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> blockingQueue = new SynchronousQueue<Integer>();        QueueConsumer<Integer> consumer = new QueueConsumer<Integer>() {            @Override            public void consumeMessage(Integer message) throws Exception {                blockingQueue.put(message);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10);        }        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(0));        timing.sleepABit();                queue.put(1000, 1);        timing.sleepABit();                Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1));        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1000));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(Integer message) throws Exception
{    blockingQueue.put(message);}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testAdditions() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        QueueSerializer<Integer> serializer = new IntSerializer() {            @Override            public Integer deserialize(byte[] bytes) {                                try {                    latch.await();                } catch (InterruptedException e) {                                }                return super.deserialize(bytes);            }        };        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, "/test").buildPriorityQueue(1);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(10, 10);            if (i == 0) {                queue.put(1, 1);                latch.countDown();            }        }        assertOrdering(consumer, 10);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public Integer deserialize(byte[] bytes)
{        try {        latch.await();    } catch (InterruptedException e) {        }    return super.deserialize(bytes);}
0
public void testSimple() throws Exception
{    List<Integer> nums = new ArrayList<Integer>();    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch hasConsumedLatch = new CountDownLatch(1);        final CountDownLatch okToConsumeLatch = new CountDownLatch(1);        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class)) {            @Override            public void consumeMessage(Integer message) throws Exception {                hasConsumedLatch.countDown();                okToConsumeLatch.await();                super.consumeMessage(message);            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        nums.add(Integer.MIN_VALUE);                queue.put(Integer.MIN_VALUE, Integer.MIN_VALUE);        Assert.assertTrue(timing.awaitLatch(hasConsumedLatch));        Random random = new Random();        for (int i = 0; i < 100; ++i) {            int priority = random.nextInt();            nums.add(priority);            queue.put(priority, priority);        }        while (        queue.getCache().getData().children.size() < (nums.size() - 1)) {                        timing.sleepABit();        }        okToConsumeLatch.countDown();        assertOrdering(consumer, nums.size());    } catch (AssertionError e) {        StringBuilder message = new StringBuilder(e.getMessage());        for (int i : nums) {            message.append(i).append("\t").append(DistributedPriorityQueue.priorityToString(i)).append("\n");        }        Assert.fail(message.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(Integer message) throws Exception
{    hasConsumedLatch.countDown();    okToConsumeLatch.await();    super.consumeMessage(message);}
0
private void assertOrdering(BlockingQueueConsumer<Integer> consumer, int qty) throws Exception
{    int previous = 0;    for (int i = 0; i < qty; ++i) {        Integer value = consumer.take(10, TimeUnit.SECONDS);        Assert.assertNotNull(value);        if (i > 0) {            Assert.assertTrue(value >= previous, String.format("Value: (%d:%s) Previous: (%d:%s)", value, DistributedPriorityQueue.priorityToString(value), previous, DistributedPriorityQueue.priorityToString(previous)));        }        previous = value;    }}
0
public byte[] serialize(Integer item)
{    return Integer.toString(item).getBytes();}
0
public Integer deserialize(byte[] bytes)
{    return Integer.parseInt(new String(bytes));}
0
public void testRetryAfterFailure_Curator56() throws Exception
{    /*            https://issues.apache.org/jira/browse/CURATOR-56            This tests against ever growing node name bug         */    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int RETRY_COUNT = 1;        final CountDownLatch retryCounter = new CountDownLatch(RETRY_COUNT + 1);        final List<String> names = new ArrayList<String>();        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem messsage) throws Exception {                List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);                names.add(queueItems.get(0));                if (retryCounter.getCount() > 1) {                    retryCounter.countDown();                    throw new Exception("Something went wrong");                } else {                    retryCounter.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/lock").buildQueue();        queue.start();        queue.put(new TestQueueItem("test"));        retryCounter.await(10, TimeUnit.SECONDS);        Assert.assertEquals(retryCounter.getCount(), 0, "Queue item was not consumed. Retry counter is " + retryCounter.getCount());        Assert.assertEquals(names.size(), 2);        Assert.assertEquals(names.get(0).length(), names.get(1).length(), "name1: " + names.get(0) + " - " + "name2: " + names.get(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(TestQueueItem messsage) throws Exception
{    List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);    names.add(queueItems.get(0));    if (retryCounter.getCount() > 1) {        retryCounter.countDown();        throw new Exception("Something went wrong");    } else {        retryCounter.countDown();    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testCustomExecutor() throws Exception
{    final int ITERATIONS = 1000;    Timing timing = new Timing();    DistributedQueue<String> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(ITERATIONS);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueSerializer<String> serializer = new QueueSerializer<String>() {            @Override            public byte[] serialize(String item) {                return item.getBytes();            }            @Override            public String deserialize(byte[] bytes) {                return new String(bytes);            }        };        Executor executor = Executors.newCachedThreadPool();        final Set<String> used = Sets.newHashSet();        final Set<String> doubleUsed = Sets.newHashSet();        queue = new DistributedQueue<String>(client, consumer, serializer, QUEUE_PATH, QueueBuilder.defaultThreadFactory, executor, Integer.MAX_VALUE, false, "/lock", QueueBuilder.NOT_SET, true, timing.milliseconds()) {            @SuppressWarnings("SimplifiableConditionalExpression")            @Override            protected boolean processWithLockSafety(String itemNode, DistributedQueue.ProcessType type) throws Exception {                if (used.contains(itemNode)) {                    doubleUsed.add(itemNode);                } else {                    used.add(itemNode);                }                return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;            }        };        queue.start();        for (int i = 0; i < ITERATIONS; ++i) {            queue.put(Integer.toString(i));        }        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertTrue(doubleUsed.size() == 0, doubleUsed.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(String message) throws Exception
{    latch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public byte[] serialize(String item)
{    return item.getBytes();}
0
public String deserialize(byte[] bytes)
{    return new String(bytes);}
0
protected boolean processWithLockSafety(String itemNode, DistributedQueue.ProcessType type) throws Exception
{    if (used.contains(itemNode)) {        doubleUsed.add(itemNode);    } else {        used.add(itemNode);    }    return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;}
0
public void testPutListener() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        final AtomicInteger listenerCalls = new AtomicInteger(0);        QueuePutListener<TestQueueItem> listener = new QueuePutListener<TestQueueItem>() {            @Override            public void putCompleted(TestQueueItem item) {                listenerCalls.incrementAndGet();            }            @Override            public void putMultiCompleted(MultiItem<TestQueueItem> items) {            }        };        queue.getPutListenerContainer().addListener(listener);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertEquals(listenerCalls.get(), itemQty);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void putCompleted(TestQueueItem item)
{    listenerCalls.incrementAndGet();}
0
public void putMultiCompleted(MultiItem<TestQueueItem> items)
{}
0
public void testErrorMode() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(1));        final AtomicInteger count = new AtomicInteger(0);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                if (count.incrementAndGet() < 2) {                    throw new Exception();                }                latch.get().countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        DistributedQueue<TestQueueItem> queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildQueue();        try {            queue.start();            TestQueueItem item = new TestQueueItem("1");            queue.put(item);            Assert.assertTrue(timing.awaitLatch(latch.get()));            Assert.assertEquals(count.get(), 2);            queue.setErrorMode(ErrorMode.DELETE);            count.set(0);            latch.set(new CountDownLatch(1));            item = new TestQueueItem("1");            queue.put(item);                        Assert.assertFalse(latch.get().await(5, TimeUnit.SECONDS));            Assert.assertEquals(count.get(), 1);        } finally {            queue.close();        }    } finally {        client.close();    }}
0
public void consumeMessage(TestQueueItem message) throws Exception
{    if (count.incrementAndGet() < 2) {        throw new Exception();    }    latch.get().countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testNoDuplicateProcessing() throws Exception
{    final int itemQty = 1000;    final int consumerQty = 4;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        DistributedQueue<TestQueueItem> producerQueue = QueueBuilder.builder(client, null, serializer, QUEUE_PATH).buildQueue();        try {            producerQueue.start();            for (int i = 0; i < itemQty; ++i) {                TestQueueItem item = new TestQueueItem(Integer.toString(i));                producerQueue.put(item);            }            producerQueue.flushPuts(timing.multiple(2).seconds(), TimeUnit.SECONDS);        } finally {            producerQueue.close();        }    } finally {        client.close();    }    final Set<String> consumedMessages = Sets.newHashSet();    final Set<String> duplicateMessages = Sets.newHashSet();    final CountDownLatch latch = new CountDownLatch(itemQty);    List<DistributedQueue<TestQueueItem>> consumers = Lists.newArrayList();    List<CuratorFramework> consumerClients = Lists.newArrayList();    try {        final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) {                synchronized (consumedMessages) {                    if (consumedMessages.contains(message.str)) {                        duplicateMessages.add(message.str);                    }                    consumedMessages.add(message.str);                }                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < consumerQty; ++i) {            CuratorFramework thisClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            consumerClients.add(thisClient);            thisClient.start();            DistributedQueue<TestQueueItem> thisConsumer = QueueBuilder.builder(thisClient, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumers.add(thisConsumer);        }        for (DistributedQueue<TestQueueItem> consumer : consumers) {            consumer.start();        }        timing.awaitLatch(latch);        Assert.assertTrue(duplicateMessages.size() == 0, duplicateMessages.toString());    } finally {        for (DistributedQueue<TestQueueItem> consumer : consumers) {            CloseableUtils.closeQuietly(consumer);        }        for (CuratorFramework curatorFramework : consumerClients) {            CloseableUtils.closeQuietly(curatorFramework);        }    }}
0
public void consumeMessage(TestQueueItem message)
{    synchronized (consumedMessages) {        if (consumedMessages.contains(message.str)) {            duplicateMessages.add(message.str);        }        consumedMessages.add(message.str);    }    latch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testSafetyWithCrash() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> producerQueue = null;    DistributedQueue<TestQueueItem> consumerQueue1 = null;    DistributedQueue<TestQueueItem> consumerQueue2 = null;    CuratorFramework producerClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        producerClient.start();        consumerClient1.start();        consumerClient2.start();        ExecutorService service = Executors.newCachedThreadPool();                {            producerQueue = QueueBuilder.builder(producerClient, null, serializer, QUEUE_PATH).buildQueue();            producerQueue.start();            QueueTestProducer producer = new QueueTestProducer(producerQueue, itemQty, 0);            service.submit(producer);        }        final Set<TestQueueItem> takenItems = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer1 = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer2 = Sets.newTreeSet();        final AtomicReference<TestQueueItem> thrownItemFromConsumer1 = new AtomicReference<TestQueueItem>(null);                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    synchronized (takenItems) {                        if (takenItems.size() > 10) {                            thrownItemFromConsumer1.set(message);                                                        throw new Exception("dummy");                        }                    }                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer1) {                        takenItemsForConsumer1.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue1 = QueueBuilder.builder(consumerClient1, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue1.start();        }                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer2) {                        takenItemsForConsumer2.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue2 = QueueBuilder.builder(consumerClient2, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue2.start();        }        synchronized (takenItems) {            while (takenItems.size() < itemQty) {                takenItems.wait(1000);            }        }        int i = 0;        for (TestQueueItem item : takenItems) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertNotNull(thrownItemFromConsumer1.get());        Assert.assertTrue((takenItemsForConsumer2.contains(thrownItemFromConsumer1.get())));        Assert.assertTrue(Sets.intersection(takenItemsForConsumer1, takenItemsForConsumer2).size() == 0);    } finally {        CloseableUtils.closeQuietly(producerQueue);        CloseableUtils.closeQuietly(consumerQueue1);        CloseableUtils.closeQuietly(consumerQueue2);        CloseableUtils.closeQuietly(producerClient);        CloseableUtils.closeQuietly(consumerClient1);        CloseableUtils.closeQuietly(consumerClient2);    }}
0
public void consumeMessage(TestQueueItem message) throws Exception
{    synchronized (takenItems) {        if (takenItems.size() > 10) {            thrownItemFromConsumer1.set(message);                        throw new Exception("dummy");        }    }    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer1) {        takenItemsForConsumer1.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void consumeMessage(TestQueueItem message) throws Exception
{    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer2) {        takenItemsForConsumer2.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
private void addToTakenItems(TestQueueItem message, Set<TestQueueItem> takenItems, int itemQty)
{    synchronized (takenItems) {        takenItems.add(message);        if (takenItems.size() > itemQty) {            takenItems.notifyAll();        }    }}
0
public void testSafetyBasic() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        final CountDownLatch latch = new CountDownLatch(1);        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < itemQty; ++i) {                    TestQueueItem item = consumer.take();                    Assert.assertEquals(item.str, Integer.toString(i));                }                latch.countDown();                return null;            }        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public Object call() throws Exception
{    for (int i = 0; i < itemQty; ++i) {        TestQueueItem item = consumer.take();        Assert.assertEquals(item.str, Integer.toString(i));    }    latch.countDown();    return null;}
0
public void testPutMulti() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        MultiItem<TestQueueItem> items = new MultiItem<TestQueueItem>() {            private int index = 0;            @Override            public TestQueueItem nextItem() throws Exception {                if (index >= itemQty) {                    return null;                }                return new TestQueueItem(Integer.toString(index++));            }        };        queue.putMulti(items);        for (int i = 0; i < itemQty; ++i) {            TestQueueItem queueItem = consumer.take(1, TimeUnit.SECONDS);            Assert.assertNotNull(queueItem);            Assert.assertEquals(queueItem, new TestQueueItem(Integer.toString(i)));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public TestQueueItem nextItem() throws Exception
{    if (index >= itemQty) {        return null;    }    return new TestQueueItem(Integer.toString(index++));}
0
public void testMultiPutterSingleGetter() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer1 = new QueueTestProducer(queue, itemQty / 2, 0);        QueueTestProducer producer2 = new QueueTestProducer(queue, ((itemQty + 1) / 2), itemQty / 2);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer1);        service.submit(producer2);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        List<TestQueueItem> items = consumer.getItems();                Assert.assertEquals(com.google.common.collect.Sets.<TestQueueItem>newHashSet(items).size(), items.size());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public void testFlush() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        queue = new DistributedQueue<TestQueueItem>(client, null, serializer, "/test", new ThreadFactoryBuilder().build(), MoreExecutors.directExecutor(), 10, true, null, QueueBuilder.NOT_SET, true, 0) {            @Override            void internalCreateNode(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception {                if (firstTime.compareAndSet(true, false)) {                    Executors.newSingleThreadExecutor().submit(new Callable<Object>() {                        @Override                        public Object call() throws Exception {                            latch.await();                            timing.sleepABit();                            client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                            return null;                        }                    });                } else {                    super.internalCreateNode(path, bytes, callback);                }            }        };        queue.start();        queue.put(new TestQueueItem("1"));        Assert.assertFalse(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.countDown();        Assert.assertTrue(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        if (latch.getCount() > 0) {            latch.countDown();        }        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
 void internalCreateNode(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                latch.await();                timing.sleepABit();                client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                return null;            }        });    } else {        super.internalCreateNode(path, bytes, callback);    }}
0
public Object call() throws Exception
{    latch.await();    timing.sleepABit();    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);    return null;}
0
public void testSimple() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0
public int compareTo(TestQueueItem rhs)
{    if (this == rhs) {        return 0;    }    int val = Integer.parseInt(str);    int rhsVal = Integer.parseInt(rhs.str);    int diff = val - rhsVal;    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestQueueItem that = (TestQueueItem) o;    return str.equals(that.str);}
0
public int hashCode()
{    return str.hashCode();}
0
public void testDistribution() throws Exception
{    final int threshold = 100;    final int factor = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    QueueSharder<String, DistributedQueue<String>> sharder = null;    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);        QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(threshold).thresholdCheckMs(1).build();        sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        for (int i = 0; i < (factor * threshold); ++i) {            sharder.getQueue().put(Integer.toString(i));            Thread.sleep(5);        }        timing.forWaiting().sleepABit();        SummaryStatistics statistics = new SummaryStatistics();        for (String path : sharder.getQueuePaths()) {            int numChildren = client.checkExists().forPath(path).getNumChildren();            Assert.assertTrue(numChildren > 0);            Assert.assertTrue(numChildren >= (threshold * .1));            statistics.addValue(numChildren);        }        latch.countDown();        Assert.assertTrue(statistics.getMean() >= (threshold * .9));    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
0
public void consumeMessage(String message) throws Exception
{    latch.await();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testSharderWatchSync() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final BlockingQueueConsumer<String> consumer = makeConsumer(null);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder1 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    QueueSharder<String, DistributedQueue<String>> sharder2 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder1.start();        sharder2.start();        for (int i = 0; i < 20; ++i) {            sharder1.getQueue().put(Integer.toString(i));        }        timing.sleepABit();        Assert.assertTrue((sharder1.getShardQty() > 1) || (sharder2.getShardQty() > 1));        timing.forWaiting().sleepABit();        Assert.assertEquals(sharder1.getShardQty(), sharder2.getShardQty());    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder1);        CloseableUtils.closeQuietly(sharder2);        CloseableUtils.closeQuietly(client);    }}
0
public void testSimpleDistributedQueue() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final CountDownLatch latch = new CountDownLatch(1);    final BlockingQueueConsumer<String> consumer = makeConsumer(latch);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder.start();        sharder.getQueue().put("one");        sharder.getQueue().put("two");        sharder.getQueue().put("three");        sharder.getQueue().put("four");        latch.countDown();        timing.sleepABit();        sharder.getQueue().put("five");        sharder.getQueue().put("six");        sharder.getQueue().put("seven");        sharder.getQueue().put("eight");        timing.sleepABit();        Assert.assertTrue(sharder.getShardQty() > 1);        Set<String> consumed = Sets.newHashSet();        for (int i = 0; i < 8; ++i) {            String s = consumer.take(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            Assert.assertNotNull(s);            consumed.add(s);        }        Assert.assertEquals(consumed, Sets.newHashSet("one", "two", "three", "four", "five", "six", "seven", "eight"));        int shardQty = sharder.getShardQty();        sharder.close();                sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        Assert.assertEquals(sharder.getShardQty(), shardQty);    } finally {        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
0
private QueueAllocator<String, DistributedQueue<String>> makeAllocator(final QueueConsumer<String> consumer)
{    final QueueSerializer<String> serializer = new QueueSerializer<String>() {        @Override        public byte[] serialize(String item) {            return item.getBytes();        }        @Override        public String deserialize(byte[] bytes) {            return new String(bytes);        }    };    return new QueueAllocator<String, DistributedQueue<String>>() {        @Override        public DistributedQueue<String> allocateQueue(CuratorFramework client, String queuePath) {            return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();        }    };}
0
public byte[] serialize(String item)
{    return item.getBytes();}
0
public String deserialize(byte[] bytes)
{    return new String(bytes);}
0
public DistributedQueue<String> allocateQueue(CuratorFramework client, String queuePath)
{    return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();}
0
private BlockingQueueConsumer<String> makeConsumer(final CountDownLatch latch)
{    ConnectionStateListener connectionStateListener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    return new BlockingQueueConsumer<String>(connectionStateListener) {        @Override        public void consumeMessage(String message) throws Exception {            if (latch != null) {                latch.await();            }            super.consumeMessage(message);        }    };}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void consumeMessage(String message) throws Exception
{    if (latch != null) {        latch.await();    }    super.consumeMessage(message);}
0
public void run()
{    try {        for (int i = 0; i < ITEM_COUNT; i++) {            processItem(i);            Thread.sleep(sleepMillis);        }    } catch (Exception e) {        throw new RuntimeException(e);    }}
0
public void testHangFromContainerLoss() throws Exception
{        server.close();    System.setProperty("znode.container.checkIntervalMs", "100");    server = new TestingServer();    Timing timing = new Timing().multiple(.1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ExecutorService executor = Executors.newFixedThreadPool(2);        executor.execute(new QueueUser(client, timing.milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Offering item");                queue.offer(new byte[] { (byte) itemNumber });            }        });        executor.execute(new QueueUser(client, timing.multiple(.5).milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Taking item " + itemNumber);                byte[] item = queue.take();                if (item == null) {                    throw new IllegalStateException("Null result for item " + itemNumber);                }                System.out.println("Got item " + item[0]);            }        });        executor.shutdown();        Assert.assertTrue(executor.awaitTermination((QueueUser.ITEM_COUNT * 2) * timing.milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);        System.clearProperty("znode.container.checkIntervalMs");    }}
0
protected void processItem(int itemNumber) throws Exception
{    System.out.println("Offering item");    queue.offer(new byte[] { (byte) itemNumber });}
0
protected void processItem(int itemNumber) throws Exception
{    System.out.println("Taking item " + itemNumber);    byte[] item = queue.take();    if (item == null) {        throw new IllegalStateException("Null result for item " + itemNumber);    }    System.out.println("Got item " + item[0]);}
0
public void testPollWithTimeout() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        Assert.assertNull(queueHandles[0].poll(3, TimeUnit.SECONDS));    } finally {        closeAll(clients);    }}
0
public void testOffer1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
0
public void testOffer2() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer2";        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[1].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
0
public void testTake1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTake1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].take();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
0
public void testRemova1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testRemove1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        try {            queueHandles[0].remove();        } catch (NoSuchElementException e) {            return;        }        assertTrue(false);    } finally {        closeAll(clients);    }}
0
public void createNremoveMtest(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        byte[] data = null;        for (int i = 0; i < m; i++) {            data = queueHandles[1].remove();        }        assertEquals(new String(data), testString + (m - 1));    } finally {        closeAll(clients);    }}
0
public void testRemove2() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
0
public void testRemove3() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
0
public void createNremoveMelementTest(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        for (int i = 0; i < m; i++) {            queueHandles[1].remove();        }        assertEquals(new String(queueHandles[1].element()), testString + m);    } finally {        closeAll(clients);    }}
0
public void testElement1() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
0
public void testElement2() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
0
public void testElement3() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
0
public void testElement4() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
0
public void testTakeWait1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTakeWait1";        final String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        final byte[][] takeResult = new byte[1][];        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(testString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), testString);    } finally {        closeAll(clients);    }}
0
public void run()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
0
public void run()
{    try {        queueHandles[0].offer(testString.getBytes());    } catch (Exception e) {        }}
0
public void testTakeWait2() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int num_clients = 1;    final CuratorFramework[] clients = new CuratorFramework[num_clients];    final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];    for (int i = 0; i < clients.length; i++) {        clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients[i].start();        queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);    }    int num_attempts = 2;    for (int i = 0; i < num_attempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(threadTestString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), threadTestString);    }}
0
public void run()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
0
public void run()
{    try {        queueHandles[0].offer(threadTestString.getBytes());    } catch (Exception e) {        }}
0
private void closeAll(CuratorFramework[] clients)
{    if (clients != null) {        for (CuratorFramework c : clients) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void testMultiClients() throws Exception
{    final int CLIENT_QTY = 5;    List<Future<List<Integer>>> futures = Lists.newArrayList();    final List<CuratorFramework> clients = new CopyOnWriteArrayList<CuratorFramework>();    final List<SharedCount> counts = new CopyOnWriteArrayList<SharedCount>();    try {        final CountDownLatch startLatch = new CountDownLatch(CLIENT_QTY);        final Semaphore semaphore = new Semaphore(0);        ExecutorService service = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("Test-%d").build());        for (int i = 0; i < CLIENT_QTY; ++i) {            Future<List<Integer>> future = service.submit(new Callable<List<Integer>>() {                @Override                public List<Integer> call() throws Exception {                    final List<Integer> countList = Lists.newArrayList();                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                    clients.add(client);                    client.start();                                        client.checkExists().forPath("/");                    SharedCount count = new SharedCount(client, "/count", 10);                    counts.add(count);                    final CountDownLatch latch = new CountDownLatch(1);                    count.addListener(new SharedCountListener() {                        @Override                        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                            if (newCount < 0) {                                latch.countDown();                            } else {                                countList.add(newCount);                            }                            semaphore.release();                        }                        @Override                        public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }                    });                    count.start();                    startLatch.countDown();                    latch.await();                    return countList;                }            });            futures.add(future);        }        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients.add(client);        client.start();                client.checkExists().forPath("/");        Assert.assertTrue(startLatch.await(10, TimeUnit.SECONDS));        SharedCount count = new SharedCount(client, "/count", 10);        counts.add(count);        count.start();        List<Integer> countList = Lists.newArrayList();        Random random = new Random();        for (int i = 0; i < 100; ++i) {            Thread.sleep(random.nextInt(10));            int next = random.nextInt(100);            countList.add(next);            count.setCount(next);            Assert.assertTrue(semaphore.tryAcquire(CLIENT_QTY, 10, TimeUnit.SECONDS));        }        count.setCount(-1);        for (Future<List<Integer>> future : futures) {            List<Integer> thisCountList = future.get();            Assert.assertEquals(thisCountList, countList);        }    } finally {        for (SharedCount count : counts) {            CloseableUtils.closeQuietly(count);        }        for (CuratorFramework client : clients) {            TestCleanState.closeAndTestClean(client);        }    }}
0
public List<Integer> call() throws Exception
{    final List<Integer> countList = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    clients.add(client);    client.start();        client.checkExists().forPath("/");    SharedCount count = new SharedCount(client, "/count", 10);    counts.add(count);    final CountDownLatch latch = new CountDownLatch(1);    count.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            if (newCount < 0) {                latch.countDown();            } else {                countList.add(newCount);            }            semaphore.release();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    });    count.start();    startLatch.countDown();    latch.await();    return countList;}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    if (newCount < 0) {        latch.countDown();    } else {        countList.add(newCount);    }    semaphore.release();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testSimple() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    try {        client.start();        count.start();        final CountDownLatch setLatch = new CountDownLatch(3);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count.addListener(listener);        Assert.assertTrue(count.trySetCount(1));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(10));        timing.sleepABit();        Assert.assertEquals(count.getCount(), 10);        Assert.assertTrue(new Timing().awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testSimpleVersioned() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    client.start();    try {        count.start();        VersionedValue<Integer> current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 0);        Assert.assertTrue(count.trySetCount(current, 1));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 1);        Assert.assertEquals(count.getCount(), 1);        Assert.assertTrue(count.trySetCount(current, 5));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 2);        Assert.assertEquals(count.getCount(), 5);        Assert.assertTrue(count.trySetCount(current, 10));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 3);        Assert.assertEquals(count.getCount(), 10);                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(3, 20), 7));                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(10, 10), 7));                client.setData().forPath("/count", SharedCount.toBytes(88));        Assert.assertFalse(count.trySetCount(current, 234));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
0
public void testMultiClientVersioned() throws Exception
{    Timing timing = new Timing();    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 0);    SharedCount count2 = new SharedCount(client2, "/count", 0);    try {        client1.start();        client2.start();        count1.start();        count2.start();        VersionedValue<Integer> versionedValue = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue, 10));        timing.sleepABit();        versionedValue = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue, 20));        timing.sleepABit();        final CountDownLatch setLatch = new CountDownLatch(2);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count1.addListener(listener);        VersionedValue<Integer> versionedValue1 = count1.getVersionedValue();        VersionedValue<Integer> versionedValue2 = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue2, 30));        Assert.assertFalse(count1.trySetCount(versionedValue1, 40));        versionedValue1 = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue1, 40));        Assert.assertTrue(timing.awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        TestCleanState.closeAndTestClean(client2);        TestCleanState.closeAndTestClean(client1);    }}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testMultiClientDifferentSeed() throws Exception
{    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 10);    SharedCount count2 = new SharedCount(client2, "/count", 20);    try {        client1.start();        client2.start();        count1.start();        count2.start();        Assert.assertEquals(count1.getCount(), 10);        Assert.assertEquals(count2.getCount(), 10);    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client1);    }}
0
public void testDisconnectEventOnWatcherDoesNotRetry() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 1000));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.start();    curatorFramework.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            }        }    });    try {        server.stop();                Assert.assertTrue(gotSuspendEvent.await(5, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    }}
0
public void testDisconnectReconnectEventDoesNotFireValueWatcher() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    final CountDownLatch gotChangeEvent = new CountDownLatch(1);    final CountDownLatch getReconnectEvent = new CountDownLatch(1);    final AtomicInteger numChangeEvents = new AtomicInteger(0);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.countDown();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.countDown();            }        }    });    sharedCount.start();    try {        sharedCount.setCount(11);        Assert.assertTrue(gotChangeEvent.await(2, TimeUnit.SECONDS));        server.stop();        Assert.assertTrue(gotSuspendEvent.await(2, TimeUnit.SECONDS));        server.restart();        Assert.assertTrue(getReconnectEvent.await(2, TimeUnit.SECONDS));        Assert.assertEquals(numChangeEvents.get(), 1);        sharedCount.trySetCount(sharedCount.getVersionedValue(), 12);                final CountDownLatch flushDone = new CountDownLatch(1);        curatorFramework.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                flushDone.countDown();            }        }).forPath("/count");        flushDone.await(5, TimeUnit.SECONDS);                        Assert.assertEquals(numChangeEvents.get(), 3);    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.countDown();    }}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    flushDone.countDown();}
0
public void testDisconnectReconnectWithMultipleClients() throws Exception
{    Timing timing = new Timing();    CuratorFramework curatorFramework1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    CuratorFramework curatorFramework2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework1.start();        curatorFramework1.checkExists().forPath("/");    curatorFramework2.start();        curatorFramework2.checkExists().forPath("/");    final String sharedCountPath = "/count";    final int initialCount = 10;    SharedCount sharedCount1 = new SharedCount(curatorFramework1, sharedCountPath, initialCount);    SharedCount sharedCountWithFaultyWatcher = createSharedCountWithFaultyWatcher(curatorFramework2, sharedCountPath, initialCount);    class MySharedCountListener implements SharedCountListener {        final public Phaser gotSuspendEvent = new Phaser(1);        final public Phaser gotChangeEvent = new Phaser(1);        final public Phaser getReconnectEvent = new Phaser(1);        final public AtomicInteger numChangeEvents = new AtomicInteger(0);        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.arrive();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.arrive();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.arrive();            }        }    }    MySharedCountListener listener1 = new MySharedCountListener();    sharedCount1.addListener(listener1);    sharedCount1.start();    MySharedCountListener listener2 = new MySharedCountListener();    sharedCountWithFaultyWatcher.addListener(listener2);    try {        sharedCount1.setCount(12);        Assert.assertEquals(listener1.gotChangeEvent.awaitAdvanceInterruptibly(0, timing.seconds(), TimeUnit.SECONDS), 1);        Assert.assertEquals(sharedCount1.getCount(), 12);        Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 10);                sharedCountWithFaultyWatcher.start();        for (int i = 0; i < 10; i++) {            sharedCount1.setCount(13 + i);            Assert.assertEquals(sharedCount1.getCount(), 13 + i);            server.restart();            Assert.assertEquals(listener2.getReconnectEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);                                    Assert.assertEquals(listener2.gotChangeEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);            Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 13 + i);        }    } finally {        CloseableUtils.closeQuietly(sharedCount1);        CloseableUtils.closeQuietly(curatorFramework1);        CloseableUtils.closeQuietly(sharedCountWithFaultyWatcher);        CloseableUtils.closeQuietly(curatorFramework2);    }}
0
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.arrive();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.arrive();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.arrive();    }}
0
private SharedCount createSharedCountWithFaultyWatcher(CuratorFramework curatorFramework, String path, int val)
{    final CuratorWatcher faultyWatcher = new CuratorWatcher() {        @Override        public void process(WatchedEvent event) throws Exception {                }    };    class FaultySharedValue extends SharedValue {        public FaultySharedValue(CuratorFramework client, String path, byte[] seedValue) {            super(client.newWatcherRemoveCuratorFramework(), path, seedValue, faultyWatcher);        }    }    ;    final SharedValue faultySharedValue = new FaultySharedValue(curatorFramework, path, SharedCount.toBytes(val));    class FaultySharedCount extends SharedCount {        public FaultySharedCount(CuratorFramework client, String path, int val) {            super(client, path, faultySharedValue);        }    }    ;    return new FaultySharedCount(curatorFramework, path, val);}
0
public void process(WatchedEvent event) throws Exception
{}
0
public void beforeSuite(ITestContext context)
{    IInvokedMethodListener2 methodListener2 = new IInvokedMethodListener2() {        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {            method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);        }        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {            beforeInvocation(method, testResult);        }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {                }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult) {                }    };    context.getSuite().addListener(methodListener2);}
0
public void beforeInvocation(IInvokedMethod method, ITestResult testResult)
{    method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);}
0
public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context)
{    beforeInvocation(method, testResult);}
0
public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context)
{}
0
public void afterInvocation(IInvokedMethod method, ITestResult testResult)
{}
0
public void setup() throws Exception
{    if (INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES != null) {        System.setProperty(INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES, "true");    }    System.setProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND, "true");    System.setProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY, "true");    createServer();}
0
protected void createServer() throws Exception
{    while (server == null) {        try {            server = new TestingServer();        } catch (BindException e) {            System.err.println("Getting bind exception - retrying to allocate server");            server = null;        }    }}
0
public void teardown() throws Exception
{    System.clearProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY);    System.clearProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND);    if (server != null) {        try {            server.close();        } catch (IOException e) {            e.printStackTrace();        } finally {            server = null;        }    }}
0
private boolean retry(ITestResult result)
{    if (result.isSuccess() || isRetrying.get()) {        isRetrying.set(false);        return false;    }    result.setStatus(ITestResult.SKIP);    if (result.getThrowable() != null) {            } else {            }    isRetrying.set(true);    return true;}
1
public int milliseconds()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
0
public int seconds()
{    return (int) value;}
0
public boolean awaitLatch(CountDownLatch latch)
{    Timing2 m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public T takeFromQueue(BlockingQueue<T> queue) throws Exception
{    Timing2 m = forWaiting();    try {        T value = queue.poll(m.value, m.unit);        if (value == null) {            throw new TimeoutException("Timed out trying to take from queue");        }        return value;    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    }}
0
public boolean acquireSemaphore(Semaphore semaphore)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public boolean acquireSemaphore(Semaphore semaphore, int n)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public Timing2 multiple(double n)
{    return new Timing2((int) (value * n), unit);}
0
public Timing2 multiple(double n, int waitingMultiple)
{    return new Timing2((int) (value * n), unit, waitingMultiple);}
0
public Timing2 forWaiting()
{    return multiple(waitingMultiple);}
0
public Timing2 forSessionSleep()
{    return multiple(SESSION_SLEEP_MULTIPLE, 1);}
0
public Timing2 forSleepingABit()
{    return multiple(.25);}
0
public void sleepABit() throws InterruptedException
{    forSleepingABit().sleep();}
0
public void sleep() throws InterruptedException
{    unit.sleep(value);}
0
public int session()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
0
public int connection()
{    return milliseconds();}
0
private static Integer getWaitingMultiple()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
0
public List<IMethodInstance> intercept(List<IMethodInstance> methods, ITestContext context)
{    if (!Compatibility.isZK34()) {        return methods;    }    List<IMethodInstance> filteredMethods = new ArrayList<>();    for (IMethodInstance method : methods) {        if (!isInGroup(method.getMethod().getGroups())) {            filteredMethods.add(method);        }    }    return filteredMethods;}
0
private boolean isInGroup(String[] groups)
{    return (groups != null) && Arrays.asList(groups).contains(zk35Group);}
0
public static boolean isZK34()
{    return false;}
0
public void shutdown()
{    delegate.shutdown();}
0
public List<Runnable> shutdownNow()
{    return delegate.shutdownNow();}
0
public boolean isShutdown()
{    return delegate.isShutdown();}
0
public boolean isTerminated()
{    return delegate.isTerminated();}
0
public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.awaitTermination(timeout, unit);}
0
public Future<T> submit(Callable<T> task)
{    return delegate.submit(task);}
0
public Future<T> submit(Runnable task, T result)
{    return delegate.submit(task, result);}
0
public Future<?> submit(Runnable task)
{    return delegate.submit(task);}
0
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
{    return delegate.invokeAll(tasks);}
0
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.invokeAll(tasks, timeout, unit);}
0
public T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
{    return delegate.invokeAny(tasks);}
0
public T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return delegate.invokeAny(tasks, timeout, unit);}
0
public void execute(Runnable command)
{    delegate.execute(command);}
0
public static void deleteRecursively(File file) throws IOException
{    if (file.isDirectory()) {        deleteDirectoryContents(file);    }    if (!file.delete()) {            }}
1
public static void deleteDirectoryContents(File directory) throws IOException
{    Preconditions.checkArgument(directory.isDirectory(), "Not a directory: %s", directory);    File[] files = directory.listFiles();    if (files == null) {                return;    }    for (File file : files) {        deleteRecursively(file);    }}
1
public synchronized void execute(Runnable command)
{    executeCalled = true;    super.execute(command);}
0
public synchronized boolean isExecuteCalled()
{    return executeCalled;}
0
public synchronized void setExecuteCalled(boolean executeCalled)
{    this.executeCalled = executeCalled;}
0
public static void reset()
{    nextServerId.set(1);}
0
public static InstanceSpec newInstanceSpec()
{    return new InstanceSpec(null, -1, -1, -1, true, -1, -1, -1);}
0
public static int getRandomPort()
{    ServerSocket server = null;    try {        server = new ServerSocket(0);        return server.getLocalPort();    } catch (IOException e) {        throw new Error(e);    } finally {        if (server != null) {            try {                server.close();            } catch (IOException ignore) {                        }        }    }}
0
public int getServerId()
{    return serverId;}
0
public File getDataDirectory()
{    return dataDirectory;}
0
public int getPort()
{    return port;}
0
public int getElectionPort()
{    return electionPort;}
0
public int getQuorumPort()
{    return quorumPort;}
0
public String getConnectString()
{    return hostname + ":" + port;}
0
public int getTickTime()
{    return tickTime;}
0
public int getMaxClientCnxns()
{    return maxClientCnxns;}
0
public boolean deleteDataDirectoryOnClose()
{    return deleteDataDirectoryOnClose;}
0
public Map<String, Object> getCustomProperties()
{    return customProperties;}
0
public String getHostname()
{    return hostname;}
0
public String toString()
{    return "InstanceSpec{" + "dataDirectory=" + dataDirectory + ", port=" + port + ", electionPort=" + electionPort + ", quorumPort=" + quorumPort + ", deleteDataDirectoryOnClose=" + deleteDataDirectoryOnClose + ", serverId=" + serverId + ", tickTime=" + tickTime + ", maxClientCnxns=" + maxClientCnxns + ", customProperties=" + customProperties + ", hostname=" + hostname + "} " + super.toString();}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    InstanceSpec that = (InstanceSpec) o;    return hostname.equals(that.getHostname()) && port == that.port;}
0
public int hashCode()
{    return hostname.hashCode() + port;}
0
public static void kill(ZooKeeper client)
{    client.getTestable().injectSessionExpiration();}
0
public static void kill(ZooKeeper client, String connectString) throws Exception
{    kill(client);}
0
public static void kill(ZooKeeper client, String connectString, int maxMs) throws Exception
{    kill(client);}
0
public boolean isFromRandom()
{    return fromRandom;}
0
public QuorumPeerConfig buildConfig() throws Exception
{    return buildConfig(0);}
0
public InstanceSpec getInstanceSpec(int index)
{    return instanceSpecs.get(index);}
0
public List<InstanceSpec> getInstanceSpecs()
{    return instanceSpecs;}
0
public int size()
{    return instanceSpecs.size();}
0
public void close()
{    if (fakeConfigFile != null) {                fakeConfigFile.delete();    }}
0
public QuorumPeerConfig buildConfig(int instanceIndex) throws Exception
{    boolean isCluster = (instanceSpecs.size() > 1);    InstanceSpec spec = instanceSpecs.get(instanceIndex);    if (isCluster) {        Files.write(Integer.toString(spec.getServerId()).getBytes(), new File(spec.getDataDirectory(), "myid"));    }    Properties properties = new Properties();    properties.setProperty("initLimit", "10");    properties.setProperty("syncLimit", "5");    properties.setProperty("dataDir", spec.getDataDirectory().getCanonicalPath());    properties.setProperty("clientPort", Integer.toString(spec.getPort()));    int tickTime = spec.getTickTime();    if (tickTime >= 0) {        properties.setProperty("tickTime", Integer.toString(tickTime));    }    int maxClientCnxns = spec.getMaxClientCnxns();    if (maxClientCnxns >= 0) {        properties.setProperty("maxClientCnxns", Integer.toString(maxClientCnxns));    }    if (isCluster) {        for (InstanceSpec thisSpec : instanceSpecs) {            properties.setProperty("server." + thisSpec.getServerId(), String.format("%s:%d:%d;%s:%d", thisSpec.getHostname(), thisSpec.getQuorumPort(), thisSpec.getElectionPort(), thisSpec.getHostname(), thisSpec.getPort()));        }    }    Map<String, Object> customProperties = spec.getCustomProperties();    if (customProperties != null) {        for (Map.Entry<String, Object> property : customProperties.entrySet()) {            properties.put(property.getKey(), property.getValue());        }    }    QuorumPeerConfig config = new QuorumPeerConfig() {        {            if (fakeConfigFile != null) {                configFileStr = fakeConfigFile.getPath();            }        }    };    config.parseProperties(properties);    return config;}
0
 static Object makeFactory(ZooKeeperServer server, int port) throws Exception
{    Object factory;    if (nioServerCnxn != null) {        factory = nioServerCnxn.constructor.newInstance(new InetSocketAddress(port));        if (server != null) {            nioServerCnxn.startupMethod.invoke(factory, server);        }    } else {        factory = serverCnxnFactoryMethods.constructor.newInstance();        serverCnxnFactoryMethods.configureMethod.invoke(factory, new InetSocketAddress(port), 0);        if (server != null) {            serverCnxnFactoryMethods.startupMethod.invoke(factory, server);        }    }    return factory;}
0
 static void shutdownFactory(Object factory)
{    try {        if (nioServerCnxn != null) {            nioServerCnxn.shutdownMethod.invoke(factory);        } else {            serverCnxnFactoryMethods.shutdownMethod.invoke(factory);        }    } catch (Exception e) {        e.printStackTrace();        throw new Error(e);    }}
0
public Collection<InstanceSpec> getInstances()
{    Iterable<InstanceSpec> transformed = Iterables.transform(servers, new Function<TestingZooKeeperServer, InstanceSpec>() {        @Override        public InstanceSpec apply(TestingZooKeeperServer server) {            return server.getInstanceSpec();        }    });    return Lists.newArrayList(transformed);}
0
public InstanceSpec apply(TestingZooKeeperServer server)
{    return server.getInstanceSpec();}
0
public List<TestingZooKeeperServer> getServers()
{    return Lists.newArrayList(servers);}
0
public String getConnectString()
{    StringBuilder str = new StringBuilder();    for (InstanceSpec spec : getInstances()) {        if (str.length() > 0) {            str.append(",");        }        str.append(spec.getConnectString());    }    return str.toString();}
0
public void start() throws Exception
{    for (TestingZooKeeperServer server : servers) {        server.start();    }}
0
public void stop() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.stop();    }}
0
public void close() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.close();    }}
0
public boolean killServer(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.kill();            return true;        }    }    return false;}
0
public boolean restartServer(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.restart();            return true;        }    }    return false;}
0
public InstanceSpec findConnectionInstance(ZooKeeper client) throws Exception
{    Method m = client.getClass().getDeclaredMethod("testableRemoteSocketAddress");    m.setAccessible(true);    InetSocketAddress address = (InetSocketAddress) m.invoke(client);    if (address != null) {        for (TestingZooKeeperServer server : servers) {            if (server.getInstanceSpec().getPort() == address.getPort()) {                return server.getInstanceSpec();            }        }    }    return null;}
0
public static Map<InstanceSpec, Collection<InstanceSpec>> makeSpecs(int instanceQty)
{    return makeSpecs(instanceQty, true);}
0
public static Map<InstanceSpec, Collection<InstanceSpec>> makeSpecs(int instanceQty, boolean resetServerIds)
{    if (resetServerIds) {        InstanceSpec.reset();    }    ImmutableList.Builder<InstanceSpec> builder = ImmutableList.builder();    for (int i = 0; i < instanceQty; ++i) {        builder.add(InstanceSpec.newInstanceSpec());    }    return listToMap(builder.build());}
0
private static Map<InstanceSpec, Collection<InstanceSpec>> listToMap(Collection<InstanceSpec> list)
{    ImmutableMap.Builder<InstanceSpec, Collection<InstanceSpec>> mapBuilder = ImmutableMap.builder();    for (InstanceSpec spec : list) {        mapBuilder.put(spec, list);    }    return mapBuilder.build();}
0
public void kill()
{    try {        if (quorumPeer != null) {            Field cnxnFactoryField = QuorumPeer.class.getDeclaredField("cnxnFactory");            cnxnFactoryField.setAccessible(true);            ServerCnxnFactory cnxnFactory = (ServerCnxnFactory) cnxnFactoryField.get(quorumPeer);            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {        e.printStackTrace();    }}
0
public QuorumPeer getTestingQuorumPeer()
{    return quorumPeer;}
0
public void close() throws IOException
{    if ((quorumPeer != null) && !isClosed) {        isClosed = true;        quorumPeer.shutdown();    }}
0
public void blockUntilStarted() throws Exception
{    long startTime = System.currentTimeMillis();    while ((quorumPeer == null) && ((System.currentTimeMillis() - startTime) <= TestingZooKeeperMain.MAX_WAIT_MS)) {        try {            Thread.sleep(10);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        }    }    if (quorumPeer == null) {        throw new Exception("quorumPeer never got set");    }}
0
public int getPort()
{    return spec.getPort();}
0
public File getTempDirectory()
{    return spec.getDataDirectory();}
0
public void start() throws Exception
{    testingZooKeeperServer.start();}
0
public void stop() throws IOException
{    testingZooKeeperServer.stop();}
0
public void restart() throws Exception
{    testingZooKeeperServer.restart();}
0
public void close() throws IOException
{    testingZooKeeperServer.close();}
0
public String getConnectString()
{    return spec.getConnectString();}
0
public void kill()
{    try {        if (cnxnFactory != null) {            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {                e.printStackTrace();    }}
0
public void runFromConfig(QuorumPeerConfig config) throws Exception
{    try {        Field instance = MBeanRegistry.class.getDeclaredField("instance");        instance.setAccessible(true);        MBeanRegistry nopMBeanRegistry = new MBeanRegistry() {            @Override            public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {                        }            @Override            public void unregister(ZKMBeanInfo bean) {                        }        };        instance.set(null, nopMBeanRegistry);    } catch (Exception e) {            }    ServerConfig serverConfig = new ServerConfig();    serverConfig.readFrom(config);    try {        internalRunFromConfig(serverConfig);    } catch (IOException e) {        startingException.set(e);        throw e;    }}
1
public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{}
0
public void unregister(ZKMBeanInfo bean)
{}
0
public void blockUntilStarted() throws Exception
{    if (!timing.awaitLatch(latch))        throw new IllegalStateException("Timed out waiting for watch removal");    if (zkServer != null) {                synchronized (zkServer) {            while (!zkServer.isRunning()) {                zkServer.wait();            }        }    } else {        throw new Exception("No zkServer.");    }    Exception exception = startingException.get();    if (exception != null) {        throw exception;    }}
0
public void close() throws IOException
{    try {        cnxnFactory.shutdown();    } catch (Throwable e) {                e.printStackTrace();    } finally {        cnxnFactory = null;    }    if (containerManager != null) {        containerManager.stop();        containerManager = null;    }    try {        if (zkServer != null) {            zkServer.shutdown();            ZKDatabase zkDb = zkServer.getZKDatabase();            if (zkDb != null) {                                zkDb.close();            }        }    } catch (Throwable e) {                e.printStackTrace();    } finally {        zkServer = null;    }}
0
private void internalRunFromConfig(ServerConfig config) throws IOException
{        FileTxnSnapLog txnLog = null;    try {                                        txnLog = new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir());        zkServer = new TestZooKeeperServer(txnLog, config);        try {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        } catch (IOException e) {                        timing.sleepABit();            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        }        cnxnFactory.startup(zkServer);        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.getFirstProcessor(), Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1L)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();        latch.countDown();        cnxnFactory.join();        if ((zkServer != null) && zkServer.isRunning()) {            zkServer.shutdown();        }    } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {        if (txnLog != null) {            txnLog.close();        }    }}
1
public RequestProcessor getFirstProcessor()
{    return firstProcessor;}
0
protected void setState(State state)
{    this.state = state;}
0
protected void registerJMX()
{}
0
protected void unregisterJMX()
{}
0
public boolean isRunning()
{    return isRunning.get() || super.isRunning();}
0
public void noteStartup()
{    synchronized (this) {        isRunning.set(true);        this.notifyAll();    }}
0
private boolean isCluster()
{    return configBuilder.size() > 1;}
0
public QuorumPeer getQuorumPeer()
{    if (isCluster()) {        return ((TestingQuorumPeerMain) main).getTestingQuorumPeer();    }    throw new UnsupportedOperationException();}
0
public Collection<InstanceSpec> getInstanceSpecs()
{    return configBuilder.getInstanceSpecs();}
0
public void kill()
{    main.kill();    state.set(State.STOPPED);}
0
public void restart() throws Exception
{        if (state.get() == State.CLOSED) {        throw new IllegalStateException("Cannot restart a closed instance");    }        if (state.get() == State.STARTED) {        stop();    }        state.set(State.LATENT);    main = isCluster() ? new TestingQuorumPeerMain() : new TestingZooKeeperMain();    start();}
0
public void stop() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        main.close();    }}
0
public InstanceSpec getInstanceSpec()
{    return configBuilder.getInstanceSpec(thisInstanceIndex);}
0
public void close() throws IOException
{    stop();    if (state.compareAndSet(State.STOPPED, State.CLOSED)) {        configBuilder.close();        InstanceSpec spec = getInstanceSpec();        if (spec.deleteDataDirectoryOnClose()) {            DirectoryUtils.deleteRecursively(spec.getDataDirectory());        }    }}
0
public void start() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        return;    }    new Thread(new Runnable() {        public void run() {            try {                QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);                main.runFromConfig(config);            } catch (Exception e) {                            }        }    }).start();    main.blockUntilStarted();}
1
public void run()
{    try {        QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);        main.runFromConfig(config);    } catch (Exception e) {            }}
1
public int milliseconds()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
0
public int seconds()
{    return (int) value;}
0
public boolean awaitLatch(CountDownLatch latch)
{    Timing m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public boolean acquireSemaphore(Semaphore semaphore)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public boolean acquireSemaphore(Semaphore semaphore, int n)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
0
public Timing multiple(double n)
{    return new Timing((int) (value * n), unit);}
0
public Timing forWaiting()
{    return multiple(waitingMultiple);}
0
public void sleepABit() throws InterruptedException
{    unit.sleep(value / 4);}
0
public int session()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
0
public int connection()
{    return milliseconds();}
0
private static Integer getWaitingMultiple()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
0
public static List<String> getDataWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, WatchersDebug.getDataWatches);}
0
public static List<String> getExistWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getExistWatches);}
0
public static List<String> getChildWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getChildWatches);}
0
private static Method getMethod(String name) throws NoSuchMethodException
{    Method m = ZooKeeper.class.getDeclaredMethod(name);    m.setAccessible(true);    return m;}
0
private static List<String> callMethod(ZooKeeper zooKeeper, Method method)
{    if (zooKeeper == null) {        return null;    }    try {                return (List<String>) method.invoke(zooKeeper);    } catch (Exception e) {        throw new RuntimeException(e);    }}
0
public void testCustomProperties() throws Exception
{    Map<String, Object> customProperties = new HashMap<String, Object>();    customProperties.put("authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    customProperties.put("kerberos.removeHostFromPrincipal", "true");    customProperties.put("kerberos.removeRealmFromPrincipal", "true");    InstanceSpec spec = new InstanceSpec(null, -1, -1, -1, true, 1, -1, -1, customProperties);    TestingServer server = new TestingServer(spec, true);    try {        assertEquals("org.apache.zookeeper.server.auth.SASLAuthenticationProvider", System.getProperty("zookeeper.authProvider.1"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeHostFromPrincipal"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeRealmFromPrincipal"));    } finally {        server.close();    }}
0
public static boolean isZK34()
{    return true;}
0
public void testAutoState()
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Assert.assertTrue(client.isZk34CompatibilityMode());}
0
public void testTtl() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().withTtl(100).forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testReconfig() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.reconfig().withNewMembers("a", "b");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGetConfig() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getConfig().forEnsemble();    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRemoveWatches() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.watches().removeAll();    } finally {        CloseableUtils.closeQuietly(client);    }}
0
 static AsyncCuratorFramework wrap(CuratorFramework client)
{    return new AsyncCuratorFrameworkImpl(client);}
0
 static CompletionStage<AsyncResult<T>> of(AsyncStage<T> stage)
{    return stage.handle((value, ex) -> {        if (ex != null) {            if (ex instanceof KeeperException) {                return new AsyncResultImpl<T>(((KeeperException) ex).code());            }            return new AsyncResultImpl<T>(ex);        }        return new AsyncResultImpl<T>(value);    });}
0
public static CompletionStage<Map<String, byte[]>> childrenWithData(AsyncCuratorFramework client, String path)
{    return childrenWithData(client, path, false);}
0
public static CompletionStage<Map<String, byte[]>> childrenWithData(AsyncCuratorFramework client, String path, boolean isCompressed)
{    CompletableFuture<Map<String, byte[]>> future = new CompletableFuture<>();    client.getChildren().forPath(path).handle((children, e) -> {        if (e != null) {            if (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException) {                future.complete(Maps.newHashMap());            } else {                future.completeExceptionally(e);            }        } else {            completeChildren(client, future, path, children, isCompressed);        }        return null;    });    return future;}
0
public static CompletionStage<Void> asyncEnsureParents(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsIfNeeded);}
0
public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsAsContainers);}
0
public static CompletionStage<Void> lockAsync(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Void> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit), executor);    }    return future;}
0
public static CompletionStage<Boolean> lockAsyncIf(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Boolean> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit), executor);    }    return future;}
0
public static CompletionStage<Void> lockAsync(InterProcessLock lock, Executor executor)
{    return lockAsync(lock, 0, null, executor);}
0
public static CompletionStage<Void> lockAsync(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsync(lock, timeout, unit, null);}
0
public static CompletionStage<Boolean> lockAsyncIf(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsyncIf(lock, timeout, unit, null);}
0
public static CompletionStage<Void> lockAsync(InterProcessLock lock)
{    return lockAsync(lock, 0, null, null);}
0
public static void release(InterProcessLock lock)
{    release(lock, true);}
0
public static void release(InterProcessLock lock, boolean ignoreNoLockExceptions)
{    try {        lock.release();    } catch (IllegalStateException e) {        if (!ignoreNoLockExceptions) {            throw new RuntimeException(e);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new RuntimeException(e);    }}
0
private static void lockIf(CompletableFuture<Boolean> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        future.complete(lock.acquire(timeout, unit));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
0
private static void lock(CompletableFuture<Void> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        if (unit != null) {            if (lock.acquire(timeout, unit)) {                future.complete(null);            } else {                future.completeExceptionally(new TimeoutException());            }        } else {            lock.acquire();            future.complete(null);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
0
private static void completeChildren(AsyncCuratorFramework client, CompletableFuture<Map<String, byte[]>> future, String parentPath, List<String> children, boolean isCompressed)
{    Map<String, byte[]> nodes = Maps.newHashMap();    if (children.size() == 0) {        future.complete(nodes);        return;    }    children.forEach(node -> {        String path = ZKPaths.makePath(parentPath, node);        AsyncStage<byte[]> stage = isCompressed ? client.getData().decompressed().forPath(path) : client.getData().forPath(path);        stage.handle((data, e) -> {            if (e != null) {                future.completeExceptionally(e);            } else {                nodes.put(path, data);                if (nodes.size() == children.size()) {                    future.complete(nodes);                }            }            return null;        });    });}
0
private static CompletionStage<Void> ensure(AsyncCuratorFramework client, String path, ExistsOption option)
{    String localPath = ZKPaths.makePath(path, "foo");    return client.checkExists().withOptions(Collections.singleton(option)).forPath(localPath).thenApply(__ -> null);}
0
public AsyncPathAndBytesable<AsyncStage<String>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withMode(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withSetDataVersion(int version)
{    this.setDataVersion = version;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl, int setDataVersion)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    this.setDataVersion = setDataVersion;    return this;}
0
public AsyncStage<String> forPath(String path)
{    return internalForPath(path, null, false);}
0
public AsyncStage<String> forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
0
private AsyncStage<String> internalForPath(String path, byte[] data, boolean useData)
{    BuilderCommon<String> common = new BuilderCommon<>(filters, nameProc);    CreateBuilderImpl builder = new CreateBuilderImpl(client, createMode, common.backgrounding, options.contains(CreateOption.createParentsIfNeeded) || options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.doProtected), options.contains(CreateOption.compress), options.contains(CreateOption.setDataIfExists), aclList, stat, ttl);    builder.setSetDataIfExistsVersion(setDataVersion);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
0
private static CuratorFrameworkImpl reveal(CuratorFramework client)
{    try {        return (CuratorFrameworkImpl) Objects.requireNonNull(client, "client cannot be null");    } catch (Exception e) {        throw new IllegalArgumentException("Only Curator clients created through CuratorFrameworkFactory are supported: " + client.getClass().getName());    }}
0
public AsyncCreateBuilder create()
{    return new AsyncCreateBuilderImpl(client, filters);}
0
public AsyncDeleteBuilder delete()
{    return new AsyncDeleteBuilderImpl(client, filters);}
0
public AsyncSetDataBuilder setData()
{    return new AsyncSetDataBuilderImpl(client, filters);}
0
public AsyncGetACLBuilder getACL()
{    return new AsyncGetACLBuilder() {        private Stat stat = null;        @Override        public AsyncPathable<AsyncStage<List<ACL>>> storingStatIn(Stat stat) {            this.stat = stat;            return this;        }        @Override        public AsyncStage<List<ACL>> forPath(String path) {            BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);            GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);            return safeCall(common.internalCallback, () -> builder.forPath(path));        }    };}
0
public AsyncPathable<AsyncStage<List<ACL>>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
0
public AsyncStage<List<ACL>> forPath(String path)
{    BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);    GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncSetACLBuilder setACL()
{    return new AsyncSetACLBuilderImpl(client, filters);}
0
public AsyncReconfigBuilder reconfig()
{    return new AsyncReconfigBuilderImpl(client, filters);}
0
public AsyncMultiTransaction transaction()
{    return operations -> {        BuilderCommon<List<CuratorTransactionResult>> common = new BuilderCommon<>(filters, opResultsProc);        CuratorMultiTransactionImpl builder = new CuratorMultiTransactionImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forOperations(operations));    };}
0
public AsyncSyncBuilder sync()
{    return path -> {        BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);        SyncBuilderImpl builder = new SyncBuilderImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forPath(path));    };}
0
public AsyncRemoveWatchesBuilder removeWatches()
{    return new AsyncRemoveWatchesBuilderImpl(client, filters);}
0
public CuratorFramework unwrap()
{    return client;}
0
public WatchableAsyncCuratorFramework watched()
{    return new AsyncCuratorFrameworkImpl(client, filters, watchMode, true);}
0
public AsyncCuratorFrameworkDsl with(WatchMode mode)
{    return new AsyncCuratorFrameworkImpl(client, filters, mode, watched);}
0
public AsyncCuratorFrameworkDsl with(WatchMode mode, UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), mode, watched);}
0
public AsyncCuratorFrameworkDsl with(UnhandledErrorListener listener)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), watchMode, watched);}
0
public AsyncCuratorFrameworkDsl with(UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(filters.getListener(), resultFilter, watcherFilter), watchMode, watched);}
0
public AsyncCuratorFrameworkDsl with(UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, resultFilter, watcherFilter), watchMode, watched);}
0
public AsyncTransactionOp transactionOp()
{    return new AsyncTransactionOpImpl(client);}
0
public AsyncExistsBuilder checkExists()
{    return new AsyncExistsBuilderImpl(client, filters, getBuilderWatchMode());}
0
public AsyncGetDataBuilder getData()
{    return new AsyncGetDataBuilderImpl(client, filters, getBuilderWatchMode());}
0
public AsyncGetChildrenBuilder getChildren()
{    return new AsyncGetChildrenBuilderImpl(client, filters, getBuilderWatchMode());}
0
public AsyncGetConfigBuilder getConfig()
{    return new AsyncGetConfigBuilderImpl(client, filters, getBuilderWatchMode());}
0
private WatchMode getBuilderWatchMode()
{    return watched ? watchMode : null;}
0
public AsyncPathable<AsyncStage<Void>> withOptions(Set<DeleteOption> options)
{    return withOptionsAndVersion(options, -1);}
0
public AsyncPathable<AsyncStage<Void>> withOptionsAndVersion(Set<DeleteOption> options, int version)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.version = version;    return this;}
0
public AsyncPathable<AsyncStage<Void>> withVersion(int version)
{    this.version = version;    return this;}
0
public AsyncStage<Void> forPath(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    DeleteBuilderImpl builder = new DeleteBuilderImpl(client, version, common.backgrounding, options.contains(DeleteOption.deletingChildrenIfNeeded), options.contains(DeleteOption.guaranteed), options.contains(DeleteOption.quietly));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncPathable<AsyncStage<Stat>> withOptions(Set<ExistsOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
0
public AsyncStage<Stat> forPath(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, watchMode, safeStatProc);    ExistsBuilderImpl builder = new ExistsBuilderImpl(client, common.backgrounding, common.watcher, options.contains(ExistsOption.createParentsIfNeeded), options.contains(ExistsOption.createParentsAsContainers));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncStage<List<String>> forPath(String path)
{    BuilderCommon<List<String>> common = new BuilderCommon<>(filters, watchMode, childrenProc);    GetChildrenBuilderImpl builder = new GetChildrenBuilderImpl(client, common.watcher, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncPathable<AsyncStage<List<String>>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
0
public AsyncEnsemblable<AsyncStage<byte[]>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
0
public AsyncStage<byte[]> forEnsemble()
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetConfigBuilderImpl builder = new GetConfigBuilderImpl(client, common.backgrounding, common.watcher, stat);    return safeCall(common.internalCallback, builder::forEnsemble);}
0
public AsyncPathable<AsyncStage<byte[]>> decompressed()
{    decompressed = true;    return this;}
0
public AsyncPathable<AsyncStage<byte[]>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
0
public AsyncPathable<AsyncStage<byte[]>> decompressedStoringStatIn(Stat stat)
{    decompressed = true;    this.stat = stat;    return this;}
0
public AsyncStage<byte[]> forPath(String path)
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetDataBuilderImpl builder = new GetDataBuilderImpl(client, stat, common.watcher, common.backgrounding, decompressed);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers)
{    this.newMembers = servers;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving)
{    this.joining = joining;    this.leaving = leaving;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, Stat stat)
{    this.newMembers = servers;    this.stat = stat;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, Stat stat)
{    this.joining = joining;    this.leaving = leaving;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, Stat stat, long fromConfig)
{    this.newMembers = servers;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, Stat stat, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, long fromConfig)
{    this.newMembers = servers;    this.fromConfig = fromConfig;    return this;}
0
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.fromConfig = fromConfig;    return this;}
0
public AsyncStage<Void> forEnsemble()
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    ReconfigBuilderImpl builder = new ReconfigBuilderImpl(client, common.backgrounding, stat, fromConfig, newMembers, joining, leaving);    return safeCall(common.internalCallback, () -> {        builder.forEnsemble();        return null;    });}
0
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.curatorWatcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removingAll()
{    this.curatorWatcher = null;    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removingAll(Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removingAll(Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Watcher.WatcherType watcherType)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Watcher.WatcherType watcherType)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
0
public AsyncPathable<AsyncStage<Void>> removingAll(Watcher.WatcherType watcherType)
{    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
0
public AsyncStage<Void> forPath(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client, watcher, curatorWatcher, watcherType, options.contains(RemoveWatcherOption.guaranteed), options.contains(RemoveWatcherOption.local), options.contains(RemoveWatcherOption.guaranteed), common.backgrounding);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public T getRawValue()
{    return value;}
0
public Optional<T> getValue()
{    return Optional.ofNullable(value);}
0
public KeeperException.Code getCode()
{    return code;}
0
public Throwable getRawException()
{    return exception;}
0
public Optional<Throwable> getException()
{    return Optional.ofNullable(exception);}
0
public void checkException()
{    if (exception != null) {        throw new RuntimeException(exception);    }}
0
public void checkError()
{    checkException();    if (code != KeeperException.Code.OK) {        throw new RuntimeException(KeeperException.create(code));    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AsyncResultImpl<?> that = (AsyncResultImpl<?>) o;    if (value != null ? !value.equals(that.value) : that.value != null) {        return false;    }        if (code != that.code) {        return false;    }    return exception != null ? exception.equals(that.exception) : that.exception == null;}
0
public int hashCode()
{    int result = value != null ? value.hashCode() : 0;    result = 31 * result + code.hashCode();    result = 31 * result + (exception != null ? exception.hashCode() : 0);    return result;}
0
public String toString()
{    return "AsyncResult{" + "value=" + value + ", code=" + code + ", exception=" + exception + '}';}
0
public AsyncPathable<AsyncStage<Stat>> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
0
public AsyncPathable<AsyncStage<Stat>> withACL(List<ACL> aclList, int version)
{    this.aclList = aclList;    this.version = version;    return this;}
0
public AsyncStage<Stat> forPath(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetACLBuilderImpl builder = new SetACLBuilderImpl(client, common.backgrounding, aclList, version);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
0
public AsyncStage<Stat> forPath(String path)
{    return internalForPath(path, null, false);}
0
public AsyncStage<Stat> forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
0
public AsyncPathAndBytesable<AsyncStage<Stat>> compressed()
{    compressed = true;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<Stat>> compressedWithVersion(int version)
{    compressed = true;    this.version = version;    return this;}
0
public AsyncPathAndBytesable<AsyncStage<Stat>> withVersion(int version)
{    this.version = version;    return this;}
0
private AsyncStage<Stat> internalForPath(String path, byte[] data, boolean useData)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetDataBuilderImpl builder = new SetDataBuilderImpl(client, common.backgrounding, version, compressed);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
0
public AsyncTransactionCreateBuilder create()
{    return new AsyncTransactionCreateBuilder() {        private List<ACL> aclList = null;        private CreateMode createMode = CreateMode.PERSISTENT;        private boolean compressed = false;        private long ttl = -1;        @Override        public AsyncPathAndBytesable<CuratorOp> withMode(CreateMode createMode) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withACL(List<ACL> aclList) {            this.aclList = aclList;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withTtl(long ttl) {            this.ttl = ttl;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed) {            return withOptions(createMode, aclList, compressed, ttl);        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            this.aclList = aclList;            this.compressed = compressed;            this.ttl = ttl;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();            ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);            PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
0
public AsyncPathAndBytesable<CuratorOp> withMode(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
0
public AsyncPathAndBytesable<CuratorOp> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
0
public AsyncPathAndBytesable<CuratorOp> compressed()
{    compressed = true;    return this;}
0
public AsyncPathAndBytesable<CuratorOp> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
0
public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed)
{    return withOptions(createMode, aclList, compressed, ttl);}
0
public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.aclList = aclList;    this.compressed = compressed;    this.ttl = ttl;    return this;}
0
public CuratorOp forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
0
public CuratorOp forPath(String path)
{    return internalForPath(path, null, false);}
0
private CuratorOp internalForPath(String path, byte[] data, boolean useData)
{    TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();    ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);    PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
0
public AsyncTransactionDeleteBuilder delete()
{    return new AsyncTransactionDeleteBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().delete().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
0
public AsyncPathable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
0
public CuratorOp forPath(String path)
{    try {        return client.transactionOp().delete().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
0
public AsyncTransactionSetDataBuilder setData()
{    return new AsyncTransactionSetDataBuilder() {        private int version = -1;        private boolean compressed = false;        @Override        public AsyncPathAndBytesable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withVersionCompressed(int version) {            this.version = version;            compressed = true;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();            VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;            PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
0
public AsyncPathAndBytesable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
0
public AsyncPathAndBytesable<CuratorOp> compressed()
{    compressed = true;    return this;}
0
public AsyncPathAndBytesable<CuratorOp> withVersionCompressed(int version)
{    this.version = version;    compressed = true;    return this;}
0
public CuratorOp forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
0
public CuratorOp forPath(String path)
{    return internalForPath(path, null, false);}
0
private CuratorOp internalForPath(String path, byte[] data, boolean useData)
{    TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();    VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;    PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
0
public AsyncTransactionCheckBuilder check()
{    return new AsyncTransactionCheckBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().check().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
0
public AsyncPathable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
0
public CuratorOp forPath(String path)
{    try {        return client.transactionOp().check().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
0
 static BackgroundProc<T> makeProc(Function<CuratorEvent, T> proc)
{    return (event, future) -> {        if (event.getResultCode() == 0) {            future.complete(proc.apply(event));        } else {            future.completeExceptionally(KeeperException.create(KeeperException.Code.get(event.getResultCode()), event.getPath()));        }        return null;    };}
0
 static InternalCallback<T> safeCall(InternalCallback<T> callback, Callable<?> proc)
{    try {        proc.call();    } catch (Exception e) {        callback.toCompletableFuture().completeExceptionally(e);    }    return callback;}
0
public UnhandledErrorListener getListener()
{    return listener;}
0
public UnaryOperator<CuratorEvent> getResultFilter()
{    return resultFilter;}
0
public UnaryOperator<WatchedEvent> getWatcherFilter()
{    return watcherFilter;}
0
public CompletionStage<WatchedEvent> event()
{    return (watcher != null) ? watcher.getFuture() : null;}
0
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    event = (resultFilter != null) ? resultFilter.apply(event) : event;    resultFunction.apply(event, this);}
0
 CompletableFuture<WatchedEvent> getFuture()
{    return future;}
0
public void process(WatchedEvent event)
{    final WatchedEvent localEvent = (watcherFilter != null) ? watcherFilter.apply(event) : event;    switch(localEvent.getState()) {        default:            {                if ((watchMode != WatchMode.stateChangeOnly) && (localEvent.getType() != Event.EventType.None)) {                    if (!future.complete(localEvent)) {                        future.obtrudeValue(localEvent);                    }                }                break;            }        case Disconnected:        case AuthFailed:        case Expired:            {                if (watchMode != WatchMode.successOnly) {                    AsyncEventException exception = new AsyncEventException() {                        private final AtomicBoolean isReset = new AtomicBoolean(false);                        @Override                        public Event.KeeperState getKeeperState() {                            return localEvent.getState();                        }                        @Override                        public CompletionStage<WatchedEvent> reset() {                            Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");                            future = new CompletableFuture<>();                            return future;                        }                    };                    future.completeExceptionally(exception);                }                break;            }    }}
0
public Event.KeeperState getKeeperState()
{    return localEvent.getState();}
0
public CompletionStage<WatchedEvent> reset()
{    Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");    future = new CompletableFuture<>();    return future;}
0
public String getMigrationId()
{    return migrationId;}
0
public CompletionStage<Void> migrate(MigrationSet set)
{    InterProcessLock lock = new InterProcessSemaphoreMutex(client.unwrap(), ZKPaths.makePath(lockPath, set.id()));    CompletionStage<Void> lockStage = lockAsync(lock, lockMax.toMillis(), TimeUnit.MILLISECONDS, executor);    return lockStage.thenCompose(__ -> runMigrationInLock(lock, set));}
0
protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    if (operationHashesInOrder.size() > set.migrations().size()) {        throw new MigrationException(set.id(), String.format("More metadata than migrations. Migration ID: %s", set.id()));    }    int compareSize = Math.min(set.migrations().size(), operationHashesInOrder.size());    for (int i = 0; i < compareSize; ++i) {        byte[] setHash = hash(set.migrations().get(i).operations());        if (!Arrays.equals(setHash, operationHashesInOrder.get(i))) {            throw new MigrationException(set.id(), String.format("Metadata mismatch. Migration ID: %s", set.id()));        }    }    return set.migrations().subList(operationHashesInOrder.size(), set.migrations().size());}
0
private byte[] hash(List<CuratorOp> operations)
{    MessageDigest digest;    try {        digest = MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }    operations.forEach(op -> {        if (op instanceof ExtractingCuratorOp) {            ((ExtractingCuratorOp) op).addToDigest(digest);        } else {            digest.update(op.toString().getBytes());        }    });    return digest.digest();}
0
private CompletionStage<Void> runMigrationInLock(InterProcessLock lock, MigrationSet set)
{    String thisMetaDataPath = ZKPaths.makePath(metaDataPath, set.id());    return childrenWithData(client, thisMetaDataPath).thenCompose(metaData -> applyMetaData(set, metaData, thisMetaDataPath)).handle((v, e) -> {        release(lock, true);        if (e != null) {            Throwables.propagate(e);        }        return v;    });}
0
private CompletionStage<Void> applyMetaData(MigrationSet set, Map<String, byte[]> metaData, String thisMetaDataPath)
{    List<byte[]> sortedMetaData = metaData.keySet().stream().sorted(Comparator.naturalOrder()).map(metaData::get).collect(Collectors.toList());    List<Migration> toBeApplied;    try {        toBeApplied = filter(set, sortedMetaData);    } catch (MigrationException e) {        CompletableFuture<Void> future = new CompletableFuture<>();        future.completeExceptionally(e);        return future;    }    if (toBeApplied.size() == 0) {        return CompletableFuture.completedFuture(null);    }    return asyncEnsureContainers(client, thisMetaDataPath).thenCompose(__ -> applyMetaDataAfterEnsure(toBeApplied, thisMetaDataPath));}
0
private CompletionStage<Void> applyMetaDataAfterEnsure(List<Migration> toBeApplied, String thisMetaDataPath)
{    if (debugCount != null) {        debugCount.incrementAndGet();    }    List<CuratorOp> operations = new ArrayList<>();    String metaDataBasePath = ZKPaths.makePath(thisMetaDataPath, META_DATA_NODE_NAME);    toBeApplied.forEach(migration -> {        List<CuratorOp> thisMigrationOperations = migration.operations();        operations.addAll(thisMigrationOperations);        operations.add(client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(metaDataBasePath, hash(thisMigrationOperations)));    });    return client.transaction().forOperations(operations).thenApply(__ -> null);}
0
 static MigrationSet build(String id, List<Migration> migrations)
{    Objects.requireNonNull(id, "id cannot be null");    final List<Migration> migrationsCopy = ImmutableList.copyOf(migrations);    return new MigrationSet() {        @Override        public String id() {            return id;        }        @Override        public List<Migration> migrations() {            return migrationsCopy;        }    };}
0
public String id()
{    return id;}
0
public List<Migration> migrations()
{    return migrationsCopy;}
0
 void initialized()
{}
0
 void handleException(Exception e)
{    LoggerFactory.getLogger(getClass()).error("Could not process cache message", e);}
0
 ModeledCacheListener<T> postInitializedOnly()
{    return new ModeledCacheListener<T>() {        private volatile boolean isInitialized = false;        @Override        public void accept(Type type, ZPath path, Stat stat, T model) {            if (isInitialized) {                ModeledCacheListener.this.accept(type, path, stat, model);            }        }        @Override        public void initialized() {            isInitialized = true;            ModeledCacheListener.this.initialized();        }    };}
0
public void accept(Type type, ZPath path, Stat stat, T model)
{    if (isInitialized) {        ModeledCacheListener.this.accept(type, path, stat, model);    }}
0
public void initialized()
{    isInitialized = true;    ModeledCacheListener.this.initialized();}
0
public ModeledCache<T> cache()
{    return cache;}
0
public void start()
{    cache.start();}
0
public void close()
{    cache.close();}
0
public Listenable<ModeledCacheListener<T>> listenable()
{    return cache.listenable();}
0
public CachedModeledFramework<T> cached()
{    throw new UnsupportedOperationException("Already a cached instance");}
0
public CachedModeledFramework<T> cached(ExecutorService executor)
{    throw new UnsupportedOperationException("Already a cached instance");}
0
public VersionedModeledFramework<T> versioned()
{    return new VersionedModeledFrameworkImpl<>(this);}
0
public AsyncCuratorFramework unwrap()
{    return client.unwrap();}
0
public ModelSpec<T> modelSpec()
{    return client.modelSpec();}
0
public CachedModeledFramework<T> child(Object child)
{    return new CachedModeledFrameworkImpl<>(client.child(child), cache, executor);}
0
public ModeledFramework<T> parent()
{    throw new UnsupportedOperationException("Not supported for CachedModeledFramework. Instead, call parent() on the ModeledFramework before calling cached()");}
0
public CachedModeledFramework<T> withPath(ZPath path)
{    return new CachedModeledFrameworkImpl<>(client.withPath(path), cache, executor);}
0
public AsyncStage<String> set(T model)
{    return client.set(model);}
0
public AsyncStage<String> set(T model, Stat storingStatIn)
{    return client.set(model, storingStatIn);}
0
public AsyncStage<String> set(T model, Stat storingStatIn, int version)
{    return client.set(model, storingStatIn, version);}
0
public AsyncStage<String> set(T model, int version)
{    return client.set(model, version);}
0
public AsyncStage<T> read()
{    return internalRead(ZNode::model, this::exceptionally);}
0
public AsyncStage<T> read(Stat storingStatIn)
{    return internalRead(n -> {        if (storingStatIn != null) {            DataTree.copyStat(n.stat(), storingStatIn);        }        return n.model();    }, this::exceptionally);}
0
public AsyncStage<ZNode<T>> readAsZNode()
{    return internalRead(Function.identity(), this::exceptionally);}
0
public AsyncStage<T> readThrough()
{    return internalRead(ZNode::model, client::read);}
0
public AsyncStage<T> readThrough(Stat storingStatIn)
{    return internalRead(ZNode::model, () -> client.read(storingStatIn));}
0
public AsyncStage<ZNode<T>> readThroughAsZNode()
{    return internalRead(Function.identity(), client::readAsZNode);}
0
public AsyncStage<List<T>> list()
{    List<T> children = cache.currentChildren().values().stream().map(ZNode::model).collect(Collectors.toList());    return ModelStage.completed(children);}
0
public AsyncStage<Stat> update(T model)
{    return client.update(model);}
0
public AsyncStage<Stat> update(T model, int version)
{    return client.update(model, version);}
0
public AsyncStage<Void> delete()
{    return client.delete();}
0
public AsyncStage<Void> delete(int version)
{    return client.delete(version);}
0
public AsyncStage<Stat> checkExists()
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(node.stat())).orElseGet(() -> completed(null));}
0
public AsyncStage<List<ZPath>> children()
{    List<ZPath> paths = cache.currentChildren(client.modelSpec().path()).keySet().stream().filter(path -> !path.isRoot() && path.parent().equals(client.modelSpec().path())).collect(Collectors.toList());    return completed(paths);}
0
public AsyncStage<List<ZNode<T>>> childrenAsZNodes()
{    List<ZNode<T>> nodes = cache.currentChildren(client.modelSpec().path()).entrySet().stream().filter(e -> !e.getKey().isRoot() && e.getKey().parent().equals(client.modelSpec().path())).map(Map.Entry::getValue).collect(Collectors.toList());    return completed(nodes);}
0
public CuratorOp createOp(T model)
{    return client.createOp(model);}
0
public CuratorOp updateOp(T model)
{    return client.updateOp(model);}
0
public CuratorOp updateOp(T model, int version)
{    return client.updateOp(model, version);}
0
public CuratorOp deleteOp()
{    return client.deleteOp();}
0
public CuratorOp deleteOp(int version)
{    return client.deleteOp(version);}
0
public CuratorOp checkExistsOp()
{    return client.checkExistsOp();}
0
public CuratorOp checkExistsOp(int version)
{    return client.checkExistsOp(version);}
0
public AsyncStage<List<CuratorTransactionResult>> inTransaction(List<CuratorOp> operations)
{    return client.inTransaction(operations);}
0
private AsyncStage<U> completed(U value)
{    return ModelStage.completed(value);}
0
private AsyncStage<U> exceptionally()
{    KeeperException.NoNodeException exception = new KeeperException.NoNodeException(client.modelSpec().path().fullPath());    return ModelStage.exceptionally(exception);}
0
private AsyncStage<U> internalRead(Function<ZNode<T>, U> resolver, Supplier<AsyncStage<U>> elseProc)
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(resolver.apply(node))).orElseGet(elseProc);}
0
public void start()
{    try {        cache.getListenable().addListener(this);        cache.start();    } catch (Exception e) {        throw new RuntimeException(e);    }}
0
public void close()
{    cache.getListenable().removeListener(this);    cache.close();    entries.clear();}
0
public Optional<ZNode<T>> currentData(ZPath path)
{    Entry<T> entry = entries.remove(path);    if (entry != null) {        return Optional.of(new ZNodeImpl<>(path, entry.stat, entry.model));    }    return Optional.empty();}
0
 ZPath basePath()
{    return basePath;}
0
 Map<ZPath, ZNode<T>> currentChildren()
{    return currentChildren(basePath);}
0
public Map<ZPath, ZNode<T>> currentChildren(ZPath path)
{    return entries.entrySet().stream().filter(entry -> entry.getKey().startsWith(path)).map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(), new ZNodeImpl<>(entry.getKey(), entry.getValue().stat, entry.getValue().model))).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));}
0
public Listenable<ModeledCacheListener<T>> listenable()
{    return listenerContainer;}
0
public void childEvent(CuratorFramework client, TreeCacheEvent event)
{    try {        internalChildEvent(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        listenerContainer.forEach(l -> {            l.handleException(e);            return null;        });    }}
0
private void internalChildEvent(TreeCacheEvent event) throws Exception
{    switch(event.getType()) {        case NODE_ADDED:        case NODE_UPDATED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    byte[] bytes = event.getData().getData();                    if (                    (bytes != null) && (bytes.length > 0)) {                        T model = serializer.deserialize(bytes);                        entries.put(path, new Entry<>(event.getData().getStat(), model));                        ModeledCacheListener.Type type = (event.getType() == TreeCacheEvent.Type.NODE_ADDED) ? ModeledCacheListener.Type.NODE_ADDED : ModeledCacheListener.Type.NODE_UPDATED;                        accept(type, path, event.getData().getStat(), model);                    }                }                break;            }        case NODE_REMOVED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    Entry<T> entry = entries.remove(path);                    T model = (entry != null) ? entry.model : serializer.deserialize(event.getData().getData());                    Stat stat = (entry != null) ? entry.stat : event.getData().getStat();                    accept(ModeledCacheListener.Type.NODE_REMOVED, path, stat, model);                }                break;            }        case INITIALIZED:            {                listenerContainer.forEach(l -> {                    l.initialized();                    return null;                });                break;            }        default:                        break;    }}
0
private void accept(ModeledCacheListener.Type type, ZPath path, Stat stat, T model)
{    listenerContainer.forEach(l -> {        l.accept(type, path, stat, model);        return null;    });}
0
public static ModeledFrameworkImpl<T> build(AsyncCuratorFramework client, ModelSpec<T> model, WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter, UnhandledErrorListener unhandledErrorListener, UnaryOperator<CuratorEvent> resultFilter, Set<ModeledOptions> modeledOptions)
{    boolean isWatched = (watchMode != null);    Objects.requireNonNull(client, "client cannot be null");    Objects.requireNonNull(model, "model cannot be null");    modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "modeledOptions cannot be null"));    watchMode = (watchMode != null) ? watchMode : WatchMode.stateChangeAndSuccess;    AsyncCuratorFrameworkDsl dslClient = client.with(watchMode, unhandledErrorListener, resultFilter, watcherFilter);    WatchableAsyncCuratorFramework watchableClient = isWatched ? dslClient.watched() : dslClient;    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, model, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
0
public CachedModeledFramework<T> cached()
{    return cached(ThreadUtils.newSingleThreadExecutor("CachedModeledFramework"));}
0
public CachedModeledFramework<T> cached(ExecutorService executor)
{    Preconditions.checkState(!isWatched, "CachedModeledFramework cannot be used with watched instances as the internal cache would bypass the watchers.");    return new CachedModeledFrameworkImpl<>(this, Objects.requireNonNull(executor, "executor cannot be null"));}
0
public VersionedModeledFramework<T> versioned()
{    return new VersionedModeledFrameworkImpl<>(this);}
0
public ModelSpec<T> modelSpec()
{    return modelSpec;}
0
public AsyncCuratorFramework unwrap()
{    return client;}
0
public AsyncStage<String> set(T item)
{    return set(item, null, -1);}
0
public AsyncStage<String> set(T item, Stat storingStatIn)
{    return set(item, storingStatIn, -1);}
0
public AsyncStage<String> set(T item, int version)
{    return set(item, null, version);}
0
public AsyncStage<String> set(T item, Stat storingStatIn, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        return dslClient.create().withOptions(modelSpec.createOptions(), modelSpec.createMode(), fixAclList(modelSpec.aclList()), storingStatIn, modelSpec.ttl(), version).forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
0
public AsyncStage<T> read()
{    return internalRead(ZNode::model, null);}
0
public AsyncStage<T> read(Stat storingStatIn)
{    return internalRead(ZNode::model, storingStatIn);}
0
public AsyncStage<ZNode<T>> readAsZNode()
{    return internalRead(Function.identity(), null);}
0
public AsyncStage<Stat> update(T item)
{    return update(item, -1);}
0
public AsyncStage<Stat> update(T item, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        AsyncPathAndBytesable<AsyncStage<Stat>> next = isCompressed() ? dslClient.setData().compressedWithVersion(version) : dslClient.setData();        return next.forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
0
public AsyncStage<Stat> checkExists()
{    return watchableClient.checkExists().forPath(modelSpec.path().fullPath());}
0
public AsyncStage<Void> delete()
{    return delete(-1);}
0
public AsyncStage<Void> delete(int version)
{    return dslClient.delete().withVersion(version).forPath(modelSpec.path().fullPath());}
0
public AsyncStage<List<ZPath>> children()
{    return internalGetChildren(modelSpec.path());}
0
public AsyncStage<List<ZNode<T>>> childrenAsZNodes()
{    ModelStage<List<ZNode<T>>> modelStage = ModelStage.make();    Preconditions.checkState(!isWatched, "childrenAsZNodes() cannot be used with watched instances.");    children().handle((children, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            completeChildrenAsZNodes(modelStage, children);        }        return null;    });    return modelStage;}
0
private void completeChildrenAsZNodes(ModelStage<List<ZNode<T>>> modelStage, List<ZPath> children)
{    List<ZNode<T>> nodes = Lists.newArrayList();    if (children.size() == 0) {        modelStage.complete(nodes);        return;    }    children.forEach(path -> withPath(path).readAsZNode().handle((node, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            nodes.add(node);            if (nodes.size() == children.size()) {                modelStage.complete(nodes);            }        }        return null;    }));}
0
private AsyncStage<List<ZPath>> internalGetChildren(ZPath path)
{    AsyncStage<List<String>> asyncStage = watchableClient.getChildren().forPath(path.fullPath());    ModelStage<List<ZPath>> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((children, e) -> {        if (e != null) {            if (modeledOptions.contains(ModeledOptions.ignoreMissingNodesForChildren) && (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException)) {                modelStage.complete(Collections.emptyList());            } else {                modelStage.completeExceptionally(e);            }        } else {            modelStage.complete(children.stream().map(path::child).collect(Collectors.toList()));        }    });    return modelStage;}
0
public ModeledFramework<T> parent()
{    ModelSpec<T> newModelSpec = modelSpec.parent();    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
0
public ModeledFramework<T> child(Object child)
{    ModelSpec<T> newModelSpec = modelSpec.child(child);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
0
public ModeledFramework<T> withPath(ZPath path)
{    ModelSpec<T> newModelSpec = modelSpec.withPath(path);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
0
public static boolean isCompressed(Set<CreateOption> createOptions)
{    return createOptions.contains(CreateOption.compress);}
0
public CuratorOp createOp(T model)
{    return client.transactionOp().create().withOptions(modelSpec.createMode(), fixAclList(modelSpec.aclList()), modelSpec.createOptions().contains(CreateOption.compress), modelSpec.ttl()).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
0
public CuratorOp updateOp(T model)
{    return updateOp(model, -1);}
0
public CuratorOp updateOp(T model, int version)
{    AsyncTransactionSetDataBuilder builder = client.transactionOp().setData();    if (isCompressed()) {        return builder.withVersionCompressed(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));    }    return builder.withVersion(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
0
public CuratorOp deleteOp()
{    return deleteOp(-1);}
0
public CuratorOp deleteOp(int version)
{    return client.transactionOp().delete().withVersion(version).forPath(modelSpec.path().fullPath());}
0
public CuratorOp checkExistsOp()
{    return checkExistsOp(-1);}
0
public CuratorOp checkExistsOp(int version)
{    return client.transactionOp().check().withVersion(version).forPath(modelSpec.path().fullPath());}
0
public AsyncStage<List<CuratorTransactionResult>> inTransaction(List<CuratorOp> operations)
{    return client.transaction().forOperations(operations);}
0
private boolean isCompressed()
{    return modelSpec.createOptions().contains(CreateOption.compress);}
0
private ModelStage<U> internalRead(Function<ZNode<T>, U> resolver, Stat storingStatIn)
{    Stat stat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncPathable<AsyncStage<byte[]>> next = isCompressed() ? watchableClient.getData().decompressedStoringStatIn(stat) : watchableClient.getData().storingStatIn(stat);    AsyncStage<byte[]> asyncStage = next.forPath(modelSpec.path().fullPath());    ModelStage<U> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((value, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            try {                ZNode<T> node = new ZNodeImpl<>(modelSpec.path(), stat, modelSpec.serializer().deserialize(value));                modelStage.complete(resolver.apply(node));            } catch (Exception deserializeException) {                modelStage.completeExceptionally(deserializeException);            }        }    });    return modelStage;}
0
private String resolveForSet(T model)
{    if (modelSpec.path().isResolved()) {        return modelSpec.path().fullPath();    }    return modelSpec.path().resolved(model).fullPath();}
0
private List<ACL> fixAclList(List<ACL> aclList)
{        return (aclList.size() > 0) ? aclList : null;}
0
public ModelSpec<T> child(Object child)
{    return withPath(path.child(child));}
0
public ModelSpec<T> parent()
{    return withPath(path.parent());}
0
public ModelSpec<T> resolved(Object... parameters)
{    return withPath(path.resolved(parameters));}
0
public ModelSpec<T> resolved(List<Object> parameters)
{    return withPath(path.resolved(parameters));}
0
public ModelSpec<T> withPath(ZPath newPath)
{    return new ModelSpecImpl<>(newPath, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
0
public ZPath path()
{    return path;}
0
public ModelSerializer<T> serializer()
{    return serializer;}
0
public CreateMode createMode()
{    return createMode;}
0
public List<ACL> aclList()
{    return aclList;}
0
public Set<CreateOption> createOptions()
{    return createOptions;}
0
public Set<DeleteOption> deleteOptions()
{    return deleteOptions;}
0
public long ttl()
{    return ttl;}
0
public Schema schema()
{    if (schema == null) {        schema = Schema.builder(path.toSchemaPathPattern()).dataValidator(this).ephemeral(createMode.isEphemeral() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).canBeDeleted(true).sequential(createMode.isSequential() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).watched(Schema.Allowance.CAN).build();    }    return schema;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ModelSpecImpl<?> modelSpec = (ModelSpecImpl<?>) o;    if (ttl != modelSpec.ttl) {        return false;    }    if (!path.equals(modelSpec.path)) {        return false;    }    if (!serializer.equals(modelSpec.serializer)) {        return false;    }    if (createMode != modelSpec.createMode) {        return false;    }    if (!aclList.equals(modelSpec.aclList)) {        return false;    }    if (!createOptions.equals(modelSpec.createOptions)) {        return false;    }        if (!deleteOptions.equals(modelSpec.deleteOptions)) {        return false;    }    return schema.equals(modelSpec.schema);}
0
public int hashCode()
{    int result = path.hashCode();    result = 31 * result + serializer.hashCode();    result = 31 * result + createMode.hashCode();    result = 31 * result + aclList.hashCode();    result = 31 * result + createOptions.hashCode();    result = 31 * result + deleteOptions.hashCode();    result = 31 * result + (int) (ttl ^ (ttl >>> 32));    result = 31 * result + schema.hashCode();    return result;}
0
public String toString()
{    return "ModelSpecImpl{" + "path=" + path + ", serializer=" + serializer + ", createMode=" + createMode + ", aclList=" + aclList + ", createOptions=" + createOptions + ", deleteOptions=" + deleteOptions + ", ttl=" + ttl + ", schema=" + schema + '}';}
0
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    if (acl != null) {        List<ACL> localAclList = (aclList.size() > 0) ? aclList : ZooDefs.Ids.OPEN_ACL_UNSAFE;        if (!acl.equals(localAclList)) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "ACLs do not match model ACLs");        }    }    if (data != null) {        try {            serializer.deserialize(data);        } catch (RuntimeException e) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "Data cannot be deserialized into a model");        }    }    return true;}
0
 static ModelStage<U> make()
{    return new ModelStage<>(null);}
0
 static ModelStage<U> make(CompletionStage<WatchedEvent> event)
{    return new ModelStage<>(event);}
0
 static ModelStage<U> completed(U value)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.complete(value);    return stage;}
0
 static ModelStage<U> exceptionally(Exception e)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.completeExceptionally(e);    return stage;}
0
 static ModelStage<U> async(Executor executor)
{    return new AsyncModelStage<>(executor);}
0
 static ModelStage<U> asyncCompleted(U value, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.complete(value);    return stage;}
0
 static ModelStage<U> asyncExceptionally(Exception e, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.completeExceptionally(e);    return stage;}
0
public CompletionStage<WatchedEvent> event()
{    return event;}
0
public CompletableFuture<U1> thenApplyAsync(Function<? super U, ? extends U1> fn)
{    return super.thenApplyAsync(fn, executor);}
0
public CompletableFuture<Void> thenAcceptAsync(Consumer<? super U> action)
{    return super.thenAcceptAsync(action, executor);}
0
public CompletableFuture<Void> thenRunAsync(Runnable action)
{    return super.thenRunAsync(action, executor);}
0
public CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U1> other, BiFunction<? super U, ? super U1, ? extends V> fn)
{    return super.thenCombineAsync(other, fn, executor);}
0
public CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U1> other, BiConsumer<? super U, ? super U1> action)
{    return super.thenAcceptBothAsync(other, action, executor);}
0
public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action)
{    return super.runAfterBothAsync(other, action, executor);}
0
public CompletableFuture<U1> applyToEitherAsync(CompletionStage<? extends U> other, Function<? super U, U1> fn)
{    return super.applyToEitherAsync(other, fn, executor);}
0
public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends U> other, Consumer<? super U> action)
{    return super.acceptEitherAsync(other, action, executor);}
0
public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action)
{    return super.runAfterEitherAsync(other, action, executor);}
0
public CompletableFuture<U1> thenComposeAsync(Function<? super U, ? extends CompletionStage<U1>> fn)
{    return super.thenComposeAsync(fn, executor);}
0
public CompletableFuture<U> whenCompleteAsync(BiConsumer<? super U, ? super Throwable> action)
{    return super.whenCompleteAsync(action, executor);}
0
public CompletableFuture<U1> handleAsync(BiFunction<? super U, Throwable, ? extends U1> fn)
{    return super.handleAsync(fn, executor);}
0
public AsyncStage<String> set(Versioned<T> model)
{    return client.set(model.model(), model.version());}
0
public AsyncStage<String> set(Versioned<T> model, Stat storingStatIn)
{    return client.set(model.model(), storingStatIn, model.version());}
0
public AsyncStage<Versioned<T>> read()
{    return read(null);}
0
public AsyncStage<Versioned<T>> read(Stat storingStatIn)
{    Stat localStat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncStage<T> stage = client.read(localStat);    ModelStage<Versioned<T>> modelStage = ModelStage.make(stage.event());    stage.whenComplete((model, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            modelStage.complete(Versioned.from(model, localStat.getVersion()));        }    });    return modelStage;}
0
public AsyncStage<Stat> update(Versioned<T> model)
{    return client.update(model.model(), model.version());}
0
public CuratorOp updateOp(Versioned<T> model)
{    return client.updateOp(model.model(), model.version());}
0
public ZPath path()
{    return path;}
0
public Stat stat()
{    return stat;}
0
public T model()
{    return model;}
0
public static ZPath parse(String fullPath, UnaryOperator<String> nameFilter)
{    return parseInternal(fullPath, nameFilter);}
0
private static ZPathImpl parseInternal(String fullPath, UnaryOperator<String> nameFilter)
{    List<String> nodes = ImmutableList.<String>builder().add(PATH_SEPARATOR).addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(fullPath).stream().map(nameFilter).collect(Collectors.toList())).build();    nodes.forEach(ZPathImpl::validate);    return new ZPathImpl(nodes, null);}
0
public static ZPath from(String[] names)
{    return from(null, Arrays.asList(names));}
0
public static ZPath from(List<String> names)
{    return from(null, names);}
0
public static ZPath from(ZPath base, String[] names)
{    return from(base, Arrays.asList(names));}
0
public static ZPath from(ZPath base, List<String> names)
{    names = Objects.requireNonNull(names, "names cannot be null");    names.forEach(ZPathImpl::validate);    ImmutableList.Builder<String> builder = ImmutableList.builder();    if (base != null) {        if (base instanceof ZPathImpl) {            builder.addAll(((ZPathImpl) base).nodes);        } else {            builder.addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(base.fullPath()));        }    } else {        builder.add(PATH_SEPARATOR);    }    List<String> nodes = builder.addAll(names).build();    return new ZPathImpl(nodes, null);}
0
public ZPath child(Object child)
{    return new ZPathImpl(nodes, NodeName.nameFrom(child));}
0
public ZPath parent()
{    checkRootAccess();    if (parent == null) {        parent = new ZPathImpl(nodes.subList(0, nodes.size() - 1), null);    }    return parent;}
0
public boolean isRoot()
{    return nodes.size() == 1;}
0
public boolean startsWith(ZPath path)
{    ZPathImpl rhs;    if (path instanceof ZPathImpl) {        rhs = (ZPathImpl) path;    } else {        rhs = parseInternal(path.fullPath(), s -> s);    }    return (nodes.size() >= rhs.nodes.size()) && nodes.subList(0, rhs.nodes.size()).equals(rhs.nodes);}
0
public Pattern toSchemaPathPattern()
{    if (schema == null) {        schema = Pattern.compile(buildFullPath(s -> isParameter(s) ? ".*" : s));    }    return schema;}
0
public String fullPath()
{    checkResolved();    if (fullPath == null) {        fullPath = buildFullPath(s -> s);    }    return fullPath;}
0
public String nodeName()
{    return nodes.get(nodes.size() - 1);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZPathImpl zPaths = (ZPathImpl) o;    return nodes.equals(zPaths.nodes);}
0
public int hashCode()
{    return nodes.hashCode();}
0
public String toString()
{    return nodes.subList(1, nodes.size()).stream().map(name -> isParameter(name) ? name.substring(1) : name).collect(Collectors.joining(PATH_SEPARATOR, PATH_SEPARATOR, ""));}
0
public ZPath resolved(List<Object> parameters)
{    Iterator<Object> iterator = parameters.iterator();    List<String> nodeNames = nodes.stream().map(name -> {        if (isParameter(name) && iterator.hasNext()) {            return NodeName.nameFrom(iterator.next());        }        return name;    }).collect(Collectors.toList());    return new ZPathImpl(nodeNames, null);}
0
public boolean isResolved()
{    return isResolved;}
0
private static boolean isParameter(String name)
{    return (name.length() > 1) && name.startsWith(PATH_SEPARATOR);}
0
private void checkRootAccess()
{    if (isRoot()) {        throw new NoSuchElementException("The root has no parent");    }}
0
private void checkResolved()
{    if (!isResolved) {        throw new IllegalStateException("This ZPath has not been resolved: " + toString());    }}
0
private static void validate(String nodeName)
{    if (isParameter(Objects.requireNonNull(nodeName, "nodeName cannot be null"))) {        return;    }    if (nodeName.equals(PATH_SEPARATOR)) {        return;    }    PathUtils.validatePath(PATH_SEPARATOR + nodeName);}
0
private String buildFullPath(UnaryOperator<String> filter)
{    boolean addSeparator = false;    StringBuilder str = new StringBuilder();    int size = nodes.size();    int parameterIndex = 0;    for (int i = 0; i < size; ++i) {        if (i > 1) {            str.append(PATH_SEPARATOR);        }        str.append(filter.apply(nodes.get(i)));    }    return str.toString();}
0
public static JacksonModelSerializer<T> build(Class<T> modelClass)
{    return new JacksonModelSerializer<>(modelClass);}
0
public static JacksonModelSerializer<T> build(JavaType type)
{    return new JacksonModelSerializer<>(type);}
0
public static JacksonModelSerializer<T> build(TypeReference type)
{    return new JacksonModelSerializer<>(type);}
0
public byte[] serialize(T model)
{    try {        return writer.writeValueAsBytes(model);    } catch (JsonProcessingException e) {        throw new RuntimeException(String.format("Could not serialize value: %s", model), e);    }}
0
public T deserialize(byte[] bytes)
{    try {        return reader.readValue(bytes);    } catch (IOException e) {        throw new RuntimeException(String.format("Could not deserialize value: %s", Arrays.toString(bytes)), e);    }}
0
 static ModeledFramework<T> wrap(AsyncCuratorFramework client, ModelSpec<T> model)
{    return builder(client, model).build();}
0
 static ModeledFrameworkBuilder<T> builder(AsyncCuratorFramework client, ModelSpec<T> model)
{    return new ModeledFrameworkBuilder<>(client, model);}
0
 static ModeledFrameworkBuilder<T> builder()
{    return new ModeledFrameworkBuilder<>();}
0
public ModeledFramework<T> build()
{    return ModeledFrameworkImpl.build(client, modelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, modeledOptions);}
0
public ModeledFrameworkBuilder<T> watched()
{    this.watchMode = WatchMode.stateChangeAndSuccess;    return this;}
0
public ModeledFrameworkBuilder<T> watched(WatchMode watchMode)
{    this.watchMode = watchMode;    return this;}
0
public ModeledFrameworkBuilder<T> watched(WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter)
{    this.watchMode = watchMode;    this.watcherFilter = watcherFilter;    return this;}
0
public ModeledFrameworkBuilder<T> withUnhandledErrorListener(UnhandledErrorListener unhandledErrorListener)
{    this.unhandledErrorListener = unhandledErrorListener;    return this;}
0
public ModeledFrameworkBuilder<T> withResultFilter(UnaryOperator<CuratorEvent> resultFilter)
{    this.resultFilter = resultFilter;    return this;}
0
public ModeledFrameworkBuilder<T> withModelSpec(ModelSpec<T> modelSpec)
{    this.modelSpec = Objects.requireNonNull(modelSpec, "modelSpec cannot be null");    return this;}
0
public ModeledFrameworkBuilder<T> withClient(AsyncCuratorFramework client)
{    this.client = Objects.requireNonNull(client, "client cannot be null");    return this;}
0
public ModeledFrameworkBuilder<T> withOptions(Set<ModeledOptions> modeledOptions)
{    this.modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "client cannot be null"));    return this;}
0
public byte[] serialize(byte[] model)
{    return model;}
0
public byte[] deserialize(byte[] bytes)
{    return bytes;}
0
 static ModelSpecBuilder<T> builder(ZPath path, ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(path, serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
0
 static ModelSpecBuilder<T> builder(ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
0
public ModelSpec<T> build()
{    return new ModelSpecImpl<>(path, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
0
public ModelSpecBuilder<T> withCreateMode(CreateMode createMode)
{    this.createMode = createMode;    return this;}
0
public ModelSpecBuilder<T> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
0
public ModelSpecBuilder<T> withAclList(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
0
public ModelSpecBuilder<T> withCreateOptions(Set<CreateOption> createOptions)
{    this.createOptions = (createOptions != null) ? ImmutableSet.copyOf(createOptions) : null;    return this;}
0
public ModelSpecBuilder<T> withDeleteOptions(Set<DeleteOption> deleteOptions)
{    this.deleteOptions = (deleteOptions != null) ? ImmutableSet.copyOf(deleteOptions) : null;    return this;}
0
public ModelSpecBuilder<T> withPath(ZPath path)
{    this.path = Objects.requireNonNull(path, "path cannot be null");    return this;}
0
 static String nameFrom(Object obj)
{    if (obj instanceof NodeName) {        return ((NodeName) obj).nodeName();    }    return String.valueOf(obj);}
0
 Object resolved(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
0
 static TypedModeledFramework<M, P1> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec<M, P1> modelSpec)
{    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1)).build();}
0
 static TypedModeledFramework<M, P1> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec<M, P1> typedModelSpec = TypedModelSpec.from(modelSpecBuilder, pathWithIds);    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1)).build();}
0
 static TypedModeledFramework0<M> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec0<M> modelSpec)
{    return (client) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved()).build();}
0
 static TypedModeledFramework0<M> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec0<M> typedModelSpec = TypedModelSpec0.from(modelSpecBuilder, pathWithIds);    return (client) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved()).build();}
0
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
0
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> typedModelSpec = TypedModelSpec10.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
0
 static TypedModeledFramework2<M, P1, P2> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec2<M, P1, P2> modelSpec)
{    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2)).build();}
0
 static TypedModeledFramework2<M, P1, P2> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec2<M, P1, P2> typedModelSpec = TypedModelSpec2.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2)).build();}
0
 static TypedModeledFramework3<M, P1, P2, P3> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec3<M, P1, P2, P3> modelSpec)
{    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3)).build();}
0
 static TypedModeledFramework3<M, P1, P2, P3> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec3<M, P1, P2, P3> typedModelSpec = TypedModelSpec3.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3)).build();}
0
 static TypedModeledFramework4<M, P1, P2, P3, P4> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec4<M, P1, P2, P3, P4> modelSpec)
{    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4)).build();}
0
 static TypedModeledFramework4<M, P1, P2, P3, P4> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec4<M, P1, P2, P3, P4> typedModelSpec = TypedModelSpec4.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4)).build();}
0
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec5<M, P1, P2, P3, P4, P5> modelSpec)
{    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5)).build();}
0
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec5<M, P1, P2, P3, P4, P5> typedModelSpec = TypedModelSpec5.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5)).build();}
0
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
0
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> typedModelSpec = TypedModelSpec6.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
0
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
0
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> typedModelSpec = TypedModelSpec7.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
0
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
0
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> typedModelSpec = TypedModelSpec8.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
0
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
0
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> typedModelSpec = TypedModelSpec9.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
0
 static TypedModelSpec<M, P1> from(ModelSpecBuilder<M> builder, TypedZPath<P1> path)
{    return p1 -> builder.withPath(path.resolved(p1)).build();}
0
 static TypedModelSpec<M, P1> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath<P1> zPath = TypedZPath.from(pathWithIds);    return p1 -> builder.withPath(zPath.resolved(p1)).build();}
0
 static TypedModelSpec0<M> from(ModelSpecBuilder<M> builder, TypedZPath0 path)
{    return () -> builder.withPath(path.resolved()).build();}
0
 static TypedModelSpec0<M> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath0 zPath = TypedZPath0.from(pathWithIds);    return () -> builder.withPath(zPath.resolved()).build();}
0
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModelSpecBuilder<M> builder, TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
0
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> zPath = TypedZPath10.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
0
 static TypedModelSpec2<M, P1, P2> from(ModelSpecBuilder<M> builder, TypedZPath2<P1, P2> path)
{    return (p1, p2) -> builder.withPath(path.resolved(p1, p2)).build();}
0
 static TypedModelSpec2<M, P1, P2> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath2<P1, P2> zPath = TypedZPath2.from(pathWithIds);    return (p1, p2) -> builder.withPath(zPath.resolved(p1, p2)).build();}
0
 static TypedModelSpec3<M, P1, P2, P3> from(ModelSpecBuilder<M> builder, TypedZPath3<P1, P2, P3> path)
{    return (p1, p2, p3) -> builder.withPath(path.resolved(p1, p2, p3)).build();}
0
 static TypedModelSpec3<M, P1, P2, P3> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath3<P1, P2, P3> zPath = TypedZPath3.from(pathWithIds);    return (p1, p2, p3) -> builder.withPath(zPath.resolved(p1, p2, p3)).build();}
0
 static TypedModelSpec4<M, P1, P2, P3, P4> from(ModelSpecBuilder<M> builder, TypedZPath4<P1, P2, P3, P4> path)
{    return (p1, p2, p3, p4) -> builder.withPath(path.resolved(p1, p2, p3, p4)).build();}
0
 static TypedModelSpec4<M, P1, P2, P3, P4> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath4<P1, P2, P3, P4> zPath = TypedZPath4.from(pathWithIds);    return (p1, p2, p3, p4) -> builder.withPath(zPath.resolved(p1, p2, p3, p4)).build();}
0
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> from(ModelSpecBuilder<M> builder, TypedZPath5<P1, P2, P3, P4, P5> path)
{    return (p1, p2, p3, p4, p5) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5)).build();}
0
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath5<P1, P2, P3, P4, P5> zPath = TypedZPath5.from(pathWithIds);    return (p1, p2, p3, p4, p5) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5)).build();}
0
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> from(ModelSpecBuilder<M> builder, TypedZPath6<P1, P2, P3, P4, P5, P6> path)
{    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6)).build();}
0
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath6<P1, P2, P3, P4, P5, P6> zPath = TypedZPath6.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6)).build();}
0
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> from(ModelSpecBuilder<M> builder, TypedZPath7<P1, P2, P3, P4, P5, P6, P7> path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
0
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath7<P1, P2, P3, P4, P5, P6, P7> zPath = TypedZPath7.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
0
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModelSpecBuilder<M> builder, TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
0
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> zPath = TypedZPath8.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
0
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModelSpecBuilder<M> builder, TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
0
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> zPath = TypedZPath9.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
0
 static TypedZPath<T> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath<T> from(ZPath path)
{    return path::resolved;}
0
 static TypedZPath0 from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath0 from(ZPath path)
{    return path::resolved;}
0
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);}
0
 static TypedZPath2<T1, T2> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath2<T1, T2> from(ZPath path)
{    return (p1, p2) -> path.resolved(p1, p2);}
0
 static TypedZPath3<T1, T2, T3> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath3<T1, T2, T3> from(ZPath path)
{    return (p1, p2, p3) -> path.resolved(p1, p2, p3);}
0
 static TypedZPath4<T1, T2, T3, T4> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath4<T1, T2, T3, T4> from(ZPath path)
{    return (p1, p2, p3, p4) -> path.resolved(p1, p2, p3, p4);}
0
 static TypedZPath5<T1, T2, T3, T4, T5> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath5<T1, T2, T3, T4, T5> from(ZPath path)
{    return (p1, p2, p3, p4, p5) -> path.resolved(p1, p2, p3, p4, p5);}
0
 static TypedZPath6<T1, T2, T3, T4, T5, T6> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath6<T1, T2, T3, T4, T5, T6> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6) -> path.resolved(p1, p2, p3, p4, p5, p6);}
0
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> path.resolved(p1, p2, p3, p4, p5, p6, p7);}
0
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8);}
0
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
0
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9);}
0
 int version()
{    return -1;}
0
 static Versioned<T> from(T model, int version)
{    return new Versioned<T>() {        @Override        public int version() {            return version;        }        @Override        public T model() {            return model;        }    };}
0
public int version()
{    return version;}
0
public T model()
{    return model;}
0
 static CompletionStage<List<T>> models(AsyncStage<List<ZNode<T>>> from)
{    return from.thenApply(nodes -> nodes.stream().map(ZNode::model).collect(Collectors.toList()));}
0
 static CompletionStage<T> model(AsyncStage<ZNode<T>> from)
{    return from.thenApply(ZNode::model);}
0
 static String parameter()
{    return parameter("id");}
0
 static String parameter(String name)
{    return PATH_SEPARATOR + "{" + name + "}";}
0
 static ZPath parse(String fullPath)
{    return ZPathImpl.parse(fullPath, s -> s);}
0
 static ZPath parseWithIds(String fullPath)
{        return ZPathImpl.parse(fullPath, s -> isId(s) ? (PATH_SEPARATOR + s) : s);}
0
 static boolean isId(String s)
{    return s.startsWith("{") && s.endsWith("}");}
0
 static ZPath parse(String fullPath, UnaryOperator<String> nameFilter)
{    return ZPathImpl.parse(fullPath, nameFilter);}
0
 static ZPath from(String... names)
{    return ZPathImpl.from(names);}
0
 static ZPath from(List<String> names)
{    return ZPathImpl.from(names);}
0
 static ZPath from(ZPath base, String... names)
{    return ZPathImpl.from(base, names);}
0
 static ZPath from(ZPath base, List<String> names)
{    return ZPathImpl.from(base, names);}
0
 ZPath resolved(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
0
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
0
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
0
public void testQuietDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = (client1, event) -> rc.add(event.getResultCode());        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar/hey").handle((v, e) -> {            if (e == null) {                rc.add(KeeperException.Code.OK.intValue());            } else {                rc.add(((KeeperException) e).code().intValue());            }            return null;        });        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testNamespaceWithWatcher() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        async.create().forPath("/base").thenRun(() -> async.watched().getChildren().forPath("/base").event().handle((event, x) -> {            try {                queue.put(event.getPath());            } catch (InterruptedException e) {                throw new Error(e);            }            return null;        })).thenRun(() -> async.create().forPath("/base/child"));        String path = queue.take();        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateACLSingleAuth() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateACLMultipleAuths() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateACLWithReset() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new ExponentialBackoffRetry(100, 5)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = (client1, newState) -> {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.checkExists().forPath("/").toCompletableFuture().get();            Assert.fail("Connection should be down");        } catch (ExecutionException e) {                }        server.restart();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed", e);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateParents() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/another", "bar".getBytes());        data = async.getData().forPath("/one/two/another").toCompletableFuture().get();        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.delete().forPath("/one/two/three").toCompletableFuture().get();        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCreateWithProtection() throws ExecutionException, InterruptedException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        String path = async.create().withOptions(Collections.singleton(CreateOption.doProtected)).forPath("/yo").toCompletableFuture().get();        String node = ZKPaths.getNodeFromPath(path);        Assert.assertTrue(node.startsWith(CreateBuilderImpl.PROTECTED_PREFIX), node);                        int expectedProtectedIdLength = 36;                int delimeterLength = 1;        int expectedNodeLength = CreateBuilderImpl.PROTECTED_PREFIX.length() + expectedProtectedIdLength + delimeterLength + "yo".length();        Assert.assertEquals(node.length(), expectedNodeLength);        int uuidStart = CreateBuilderImpl.PROTECTED_PREFIX.length();        String protectedId = node.substring(uuidStart, uuidStart + expectedProtectedIdLength);                UUID.fromString(protectedId);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
private boolean checkForContainers()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
0
public void testCreatingParentsTheSame() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(client.checkExists().forPath("/one/two"));        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one").toCompletableFuture().get();        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testExistsCreatingParents() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());        Assert.assertNull(async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testSyncNew() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.sync().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBackgroundDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        CountDownLatch latch = new CountDownLatch(1);        async.create().forPath("/head").thenRun(() -> async.delete().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBackgroundDeleteWithChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener((client1, event) -> {            if (event.getType() == CuratorEventType.DELETE) {                Assert.assertEquals(event.getPath(), "/one/two");                ((CountDownLatch) event.getContext()).countDown();            }        });        CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four").thenRun(() -> async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testDeleteGuaranteedWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four/five/six", "foo".getBytes()).toCompletableFuture().get();        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two/three/four/five").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two/three/four/five").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testGetSequentialChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        Semaphore semaphore = new Semaphore(0);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/head").thenRun(() -> {            for (int i = 0; i < 10; ++i) {                async.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child").thenRun(semaphore::release);            }        });        Assert.assertTrue(new Timing().acquireSemaphore(semaphore, 10));        List<String> children = async.getChildren().forPath("/head").toCompletableFuture().get();        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testBackgroundGetDataWithWatch() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/test", data1).toCompletableFuture().get();        CountDownLatch watchedLatch = new CountDownLatch(1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        AsyncStage<byte[]> stage = async.watched().getData().forPath("/test");        stage.event().handle((event, x) -> {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();            return null;        });        stage.handle((d, x) -> {            Assert.assertEquals(d, data1);            backgroundLatch.countDown();            return null;        });        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        async.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = async.getData().forPath("/test").toCompletableFuture().get();        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testErrorListener() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = (message, e) -> {            if (e instanceof UnsupportedOperationException) {                errorLatch.countDown();            }        };        async.with(listener).create().forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public List<ACL> getDefaultAcl()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
0
public List<ACL> getAclForPath(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
0
public void testListenerConnectedAtStart() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<>();        ConnectionStateListener listener = (client1, newState) -> {            if (firstListenerAction.compareAndSet(true, false)) {                firstListenerState.set(newState);                System.out.println("First listener state is " + newState);            }            if (newState == ConnectionState.CONNECTED) {                connectedLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);                async.create().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testRetries() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = data -> {            if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                long now = System.currentTimeMillis();                times.add(now - start.get());                start.set(now);                latch.countDown();            }        };        server.stop();        async.create().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
0
public void testCuratorCallbackOnError() throws Exception
{    Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    try (CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build()) {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                server.stop();                async.getChildren().forPath("/").handle((children, e) -> {            if (e instanceof KeeperException.ConnectionLossException) {                latch.countDown();            }            return null;        });                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    }}
0
public void testShutdown() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = (message, e) -> {            if (e instanceof IllegalStateException) {                hadIllegalStateException.set(true);            }        };        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = data -> {            try {                operationReadyLatch.await();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        };                async.create().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
0
protected void complete(CompletionStage<T> stage)
{    complete(stage, (v, e) -> {        if (e != null) {            Throwables.propagate(e);        }    });}
0
protected void complete(CompletionStage<T> stage, BiConsumer<? super T, Throwable> handler)
{    try {        stage.handle((v, e) -> {            handler.accept(v, e);            return null;        }).toCompletableFuture().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.interrupted();    } catch (ExecutionException e) {        if (e.getCause() instanceof AssertionError) {            throw (AssertionError) e.getCause();        }        Assert.fail("get() failed", e);    } catch (TimeoutException e) {        Assert.fail("get() timed out");    }}
0
public String getName()
{    return name;}
0
public String getName()
{    return name;}
0
public int getAge()
{    return age;}
0
public String getFirstName()
{    return firstName;}
0
public String getLastName()
{    return lastName;}
0
public int getAge()
{    return age;}
0
public void setup() throws Exception
{    super.setup();    filterIsSetLatch = new CountDownLatch(1);    CuratorFramework rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));    rawClient.start();    this.client = AsyncCuratorFramework.wrap(rawClient);    ZPath modelPath = ZPath.parse("/test/it");    v1Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV1.class)).build();    v2Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV2.class)).build();    v3Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV3.class)).build();    v1opA = client.unwrap().transactionOp().create().forPath(v1Spec.path().parent().fullPath());    v1opB = ModeledFramework.wrap(client, v1Spec).createOp(new ModelV1("Test"));    v2op = ModeledFramework.wrap(client, v2Spec).updateOp(new ModelV2("Test 2", 10));    v3op = ModeledFramework.wrap(client, v3Spec).updateOp(new ModelV3("One", "Two", 30));    executor = Executors.newCachedThreadPool();    manager = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMinutes(10)) {        @Override        protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException {            CountDownLatch localLatch = filterLatch.getAndSet(null);            if (localLatch != null) {                filterIsSetLatch.countDown();                try {                    localLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                    Throwables.propagate(e);                }            }            return super.filter(set, operationHashesInOrder);        }    };    manager.debugCount = new AtomicInteger();}
0
protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    CountDownLatch localLatch = filterLatch.getAndSet(null);    if (localLatch != null) {        filterIsSetLatch.countDown();        try {            localLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            Throwables.propagate(e);        }    }    return super.filter(set, operationHashesInOrder);}
0
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    executor.shutdownNow();    super.teardown();}
0
public void testBasic()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    Migration m2 = () -> Collections.singletonList(v2op);    Migration m3 = () -> Collections.singletonList(v3op);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });    int count = manager.debugCount.get();    complete(manager.migrate(migrationSet));        Assert.assertEquals(manager.debugCount.get(), count);}
0
public void testStaged()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(m1));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV1> v1Client = ModeledFramework.wrap(client, v1Spec);    complete(v1Client.read(), (m, e) -> Assert.assertEquals(m.getName(), "Test"));    Migration m2 = () -> Collections.singletonList(v2op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV2> v2Client = ModeledFramework.wrap(client, v2Spec);    complete(v2Client.read(), (m, e) -> {        Assert.assertEquals(m.getName(), "Test 2");        Assert.assertEquals(m.getAge(), 10);    });    Migration m3 = () -> Collections.singletonList(v3op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });}
0
public void testDocExample() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/parent");    CuratorOp op2 = client.transactionOp().create().forPath("/parent/one");    CuratorOp op3 = client.transactionOp().create().forPath("/parent/two");    CuratorOp op4 = client.transactionOp().create().forPath("/parent/three");    CuratorOp op5 = client.transactionOp().create().forPath("/main", "hey".getBytes());    Migration initialMigration = () -> Arrays.asList(op1, op2, op3, op4, op5);    MigrationSet migrationSet = MigrationSet.build("main", Collections.singletonList(initialMigration));    complete(manager.migrate(migrationSet));    Assert.assertNotNull(client.unwrap().checkExists().forPath("/parent/three"));    Assert.assertEquals(client.unwrap().getData().forPath("/main"), "hey".getBytes());    CuratorOp newOp1 = client.transactionOp().create().forPath("/new");        CuratorOp newOp2 = client.transactionOp().delete().forPath("/main");    Migration newMigration = () -> Arrays.asList(newOp1, newOp2);    migrationSet = MigrationSet.build("main", Arrays.asList(initialMigration, newMigration));    complete(manager.migrate(migrationSet));    Assert.assertNull(client.unwrap().checkExists().forPath("/main"));}
0
public void testChecksumDataError()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar", "second".getBytes());    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
0
public void testChecksumPathError()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2");    CuratorOp op2 = client.transactionOp().create().forPath("/test2/bar");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar");    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
0
public void testPartialApplyForBadOps() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c");    Migration m1 = () -> Collections.singletonList(op1);    Migration m2 = () -> Collections.singletonList(op2);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }        Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
0
public void testTransactionForBadOps() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c/d");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }    Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
0
public void testConcurrency1() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    MigrationManager manager2 = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMillis(timing.forSleepingABit().milliseconds()));    try {        complete(manager2.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof AsyncWrappers.TimeoutException, "Should throw AsyncWrappers.TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());}
0
public void testConcurrency2() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    CompletionStage<Void> second = manager.migrate(migrationSet);    try {        second.toCompletableFuture().get(timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS);        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof TimeoutException, "Should throw TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());    complete(second);    Assert.assertEquals(manager.debugCount.get(), 1);}
0
public String getFirstName()
{    return firstName;}
0
public String getLastName()
{    return lastName;}
0
public String getAddress()
{    return address;}
0
public int getAge()
{    return age;}
0
public BigInteger getSalary()
{    return salary;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestModel testModel = (TestModel) o;    if (age != testModel.age) {        return false;    }    if (!firstName.equals(testModel.firstName)) {        return false;    }    if (!lastName.equals(testModel.lastName)) {        return false;    }        if (!address.equals(testModel.address)) {        return false;    }    return salary.equals(testModel.salary);}
0
public int hashCode()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    return result;}
0
public String getFirstName()
{    return firstName;}
0
public String getLastName()
{    return lastName;}
0
public String getAddress()
{    return address;}
0
public int getAge()
{    return age;}
0
public BigInteger getSalary()
{    return salary;}
0
public long getNewField()
{    return newField;}
0
public boolean equalsOld(TestModel model)
{    return firstName.equals(model.getFirstName()) && lastName.equals(model.getLastName()) && address.equals(model.getAddress()) && salary.equals(model.getSalary()) && age == model.getAge();}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestNewerModel that = (TestNewerModel) o;    if (age != that.age) {        return false;    }    if (newField != that.newField) {        return false;    }    if (!firstName.equals(that.firstName)) {        return false;    }    if (!lastName.equals(that.lastName)) {        return false;    }        if (!address.equals(that.address)) {        return false;    }    return salary.equals(that.salary);}
0
public int hashCode()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    result = 31 * result + (int) (newField ^ (newField >>> 32));    return result;}
0
public String getName()
{    return name;}
0
public int getAge()
{    return age;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestSimpleModel that = (TestSimpleModel) o;        if (age != that.age) {        return false;    }    return name.equals(that.name);}
0
public int hashCode()
{    int result = name.hashCode();    result = 31 * result + age;    return result;}
0
public String toString()
{    return "TestSimpleModel{" + "name='" + name + '\'' + ", age=" + age + '}';}
0
public void testDownServer() throws IOException
{    Timing timing = new Timing();    TestModel model = new TestModel("a", "b", "c", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    client.listenable().addListener((t, p, s, m) -> semaphore.release());    client.start();    try {        client.child(model).set(model);        Assert.assertTrue(timing.acquireSemaphore(semaphore));        CountDownLatch latch = new CountDownLatch(1);        rawClient.getConnectionStateListenable().addListener((__, state) -> {            if (state == ConnectionState.LOST) {                latch.countDown();            }        });        server.stop();        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child(model).read().whenComplete((value, e) -> {            Assert.assertNotNull(value);            Assert.assertNull(e);        }));    } finally {        client.close();    }}
0
public void testPostInitializedFilter()
{    TestModel model1 = new TestModel("a", "b", "c", 1, BigInteger.ONE);    TestModel model2 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    ModeledCacheListener<TestModel> listener = (t, p, s, m) -> semaphore.release();    client.listenable().addListener(listener.postInitializedOnly());        complete(client.child("1").set(model1));    client.start();    try {        Assert.assertFalse(timing.forSleepingABit().acquireSemaphore(semaphore));                client.child("2").set(model2);        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        client.close();    }}
0
public void testChildren()
{    TestModel parent = new TestModel("a", "b", "c", 20, BigInteger.ONE);    TestModel child1 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    TestModel child2 = new TestModel("g", "h", "i", 1, BigInteger.ONE);    TestModel grandChild1 = new TestModel("j", "k", "l", 10, BigInteger.ONE);    TestModel grandChild2 = new TestModel("m", "n", "0", 5, BigInteger.ONE);    try (CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached()) {        CountDownLatch latch = new CountDownLatch(5);        client.listenable().addListener((t, p, s, m) -> latch.countDown());        client.start();        complete(client.child("p").set(parent));        complete(client.child("p").child("c1").set(child1));        complete(client.child("p").child("c2").set(child2));        complete(client.child("p").child("c1").child("g1").set(grandChild1));        complete(client.child("p").child("c2").child("g2").set(grandChild2));        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child("p").children(), (v, e) -> {            List<ZPath> paths = Arrays.asList(client.child("p").child("c1").modelSpec().path(), client.child("p").child("c2").modelSpec().path());            Assert.assertEquals(v, paths);        });        complete(client.child("p").childrenAsZNodes(), (v, e) -> {            Set<TestModel> cachedModels = toSet(v.stream(), ZNode::model);            Assert.assertEquals(cachedModels, Sets.newHashSet(child1, child2));                        complete(ModeledFramework.wrap(async, modelSpec).child("p").childrenAsZNodes(), (v2, e2) -> {                Set<TestModel> uncachedModels = toSet(v2.stream(), ZNode::model);                Assert.assertEquals(cachedModels, uncachedModels);            });        });        complete(client.child("p").child("c1").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild1));        });        complete(client.child("p").child("c2").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild2));        });    }}
0
private Set<R> toSet(Stream<T> stream, Function<? super T, ? extends R> mapper)
{    return stream.map(mapper).collect(Collectors.toSet());}
0
public void testCrud()
{    TestModel rawModel = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    TestModel rawModel2 = new TestModel("Wayne", "Rooney", "Old Trafford", 10, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    AsyncStage<String> stage = client.set(rawModel);    Assert.assertNull(stage.event());    complete(stage, (s, e) -> Assert.assertNotNull(s));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel));    complete(client.update(rawModel2));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel2));    complete(client.delete());    complete(client.checkExists(), (stat, e) -> Assert.assertNull(stat));}
0
public void testBackwardCompatibility()
{    TestNewerModel rawNewModel = new TestNewerModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1), 100);    ModeledFramework<TestNewerModel> clientForNew = ModeledFramework.wrap(async, newModelSpec);    complete(clientForNew.set(rawNewModel), (s, e) -> Assert.assertNotNull(s));    ModeledFramework<TestModel> clientForOld = ModeledFramework.wrap(async, modelSpec);    complete(clientForOld.read(), (model, e) -> Assert.assertTrue(rawNewModel.equalsOld(model)));}
0
public void testWatched() throws InterruptedException
{    CountDownLatch latch = new CountDownLatch(1);    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    client.checkExists().event().whenComplete((event, ex) -> latch.countDown());    timing.sleepABit();    Assert.assertEquals(latch.getCount(), 1);    client.set(new TestModel());    Assert.assertTrue(timing.awaitLatch(latch));}
0
public void testGetChildren()
{    TestModel model = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).build();    complete(client.child("one").set(model));    complete(client.child("two").set(model));    complete(client.child("three").set(model));    Set<ZPath> expected = Sets.newHashSet(path.child("one"), path.child("two"), path.child("three"));    complete(client.children(), (children, e) -> Assert.assertEquals(Sets.newHashSet(children), expected));}
0
public void testBadNode()
{    complete(async.create().forPath(modelSpec.path().fullPath(), "fubar".getBytes()), (v, e) -> {    });        ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    complete(client.read(), (model, e) -> Assert.assertTrue(e instanceof KeeperException.NoNodeException));}
0
public void testSchema() throws Exception
{    Schema schema = modelSpec.schema();    try (CuratorFramework schemaClient = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(new SchemaSet(Collections.singletonList(schema), false)).build()) {        schemaClient.start();        try {            schemaClient.create().forPath(modelSpec.path().fullPath(), "asflasfas".getBytes());            Assert.fail("Should've thrown SchemaViolation");        } catch (SchemaViolation dummy) {                }        ModeledFramework<TestModel> modeledSchemaClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(schemaClient), modelSpec);        complete(modeledSchemaClient.set(new TestModel("one", "two", "three", 4, BigInteger.ONE)), (dummy, e) -> Assert.assertNull(e));    }}
0
public void testVersioned()
{    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    TestModel model = new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101));    complete(client.set(model));        complete(client.set(model));    VersionedModeledFramework<TestModel> versioned = client.versioned();    complete(versioned.read().whenComplete((v, e) -> {        Assert.assertNull(e);        Assert.assertTrue(v.version() > 0);    }).thenCompose(versioned::set),     (s, e) -> Assert.assertNull(e));    Versioned<TestModel> badVersion = Versioned.from(model, 100000);    complete(versioned.set(badVersion), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));    final Stat stat = new Stat();    complete(client.read(stat));        complete(client.delete(stat.getVersion() + 1), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));        complete(client.delete(stat.getVersion()));}
0
public void testAcl() throws NoSuchAlgorithmException
{    List<ACL> aclList = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", DigestAuthenticationProvider.generateDigest("test:test"))));    ModelSpec<TestModel> aclModelSpec = ModelSpec.builder(modelSpec.path(), modelSpec.serializer()).withAclList(aclList).build();    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, aclModelSpec);    complete(client.set(new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101))));    complete(client.update(new TestModel("John", "Galt", "Galt's Gulch", 54, BigInteger.valueOf(88))), (__, e) -> Assert.assertNotNull(e, "Should've gotten an auth failure"));    try (CuratorFramework authCurator = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).authorization("digest", "test:test".getBytes()).build()) {        authCurator.start();        ModeledFramework<TestModel> authClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(authCurator), aclModelSpec);        complete(authClient.update(new TestModel("John", "Galt", "Galt's Gulch", 42, BigInteger.valueOf(66))), (__, e) -> Assert.assertNull(e, "Should've succeeded"));    }}
0
public void setup() throws Exception
{    super.setup();    rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    rawClient.start();    async = AsyncCuratorFramework.wrap(rawClient);    JacksonModelSerializer<TestModel> serializer = JacksonModelSerializer.build(TestModel.class);    JacksonModelSerializer<TestNewerModel> newSerializer = JacksonModelSerializer.build(TestNewerModel.class);    modelSpec = ModelSpec.builder(path, serializer).build();    newModelSpec = ModelSpec.builder(path, newSerializer).build();}
0
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(rawClient);    super.teardown();}
0
public void testRoot()
{    Assert.assertEquals(ZPath.root.nodeName(), ZKPaths.PATH_SEPARATOR);    Assert.assertEquals(ZPath.root, ZPathImpl.root);    Assert.assertTrue(ZPath.root.isRoot());    Assert.assertEquals(ZPath.root.child("foo").parent(), ZPath.root);    Assert.assertTrue(ZPath.root.child("foo").parent().isRoot());}
0
public void testBasic()
{    ZPath path = ZPath.root.child("one").child("two");    Assert.assertFalse(path.isRoot());    Assert.assertEquals(path, ZPath.root.child("one").child("two"));    Assert.assertNotEquals(path, ZPath.root.child("onex").child("two"));    Assert.assertEquals(path.nodeName(), "two");    Assert.assertEquals(path.fullPath(), "/one/two");    Assert.assertEquals(path.parent().fullPath(), "/one");        Assert.assertEquals(path.fullPath(), "/one/two");        Assert.assertEquals(path.parent().fullPath(), "/one");    Assert.assertTrue(path.startsWith(ZPath.root.child("one")));    Assert.assertFalse(path.startsWith(ZPath.root.child("two")));    ZPath checkIdLike = ZPath.parse("/one/{two}/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter() + "/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter("others") + "/three");    Assert.assertTrue(checkIdLike.isResolved());}
0
public void testParsing()
{    Assert.assertEquals(ZPath.parse("/"), ZPath.root);    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.root.child("one").child("two").child("three"));    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.from("one", "two", "three"));    Assert.assertEquals(ZPath.parseWithIds("/one/{id}/two/{id}"), ZPath.from("one", parameter(), "two", parameter()));}
0
public void testUnresolvedPath()
{    ZPath path = ZPath.from("one", parameter(), "two");    path.fullPath();}
0
public void testResolvedPath()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.resolved("a", "b"), ZPath.from("one", "a", "two", "b"));}
0
public void testSchema()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/two/.*");    path = ZPath.parse("/one/two/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/two/three");    path = ZPath.parseWithIds("/one/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/three");    path = ZPath.parseWithIds("/{id}/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/.*/.*/three");}
0
public void testCustomIds()
{    Assert.assertEquals(ZPath.parseWithIds("/a/{a}/bee/{bee}/c/{c}").toString(), "/a/{a}/bee/{bee}/c/{c}");    Assert.assertEquals(ZPath.from("a", parameter(), "b", parameter()).toString(), "/a/{id}/b/{id}");    Assert.assertEquals(ZPath.from("a", parameter("foo"), "b", parameter("bar")).toString(), "/a/{foo}/b/{bar}");}
0
public void testPartialResolution()
{    ZPath path = ZPath.parseWithIds("/one/{1}/two/{2}");    Assert.assertFalse(path.parent().isResolved());    Assert.assertFalse(path.parent().parent().isResolved());    Assert.assertTrue(path.parent().parent().parent().isResolved());    Assert.assertFalse(path.isResolved());    path = path.resolved("p1");    Assert.assertFalse(path.isResolved());    Assert.assertTrue(path.parent().isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/{2}");    path = path.resolved("p2");    Assert.assertTrue(path.isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/p2");}
0
public void testBasic()
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/one/two");        complete(AsyncWrappers.lockAsync(lock), (__, e) -> {            Assert.assertNull(e);            AsyncWrappers.release(lock);        });    }}
0
public void testContention() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock1 = new InterProcessMutex(client, "/one/two");        InterProcessMutex lock2 = new InterProcessMutex(client, "/one/two");        CountDownLatch latch = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock1).thenAccept(__ -> {                        latch.countDown();        });        Assert.assertTrue(timing.awaitLatch(latch));        CountDownLatch latch2 = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock2, timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS).exceptionally(e -> {            if (e instanceof AsyncWrappers.TimeoutException) {                                latch2.countDown();            }            return null;        });        Assert.assertTrue(timing.awaitLatch(latch2));    }}
0
public void setup() throws Exception
{    super.setup();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(timing.forSleepingABit().milliseconds()));    client.start();    this.client = AsyncCuratorFramework.wrap(client);}
0
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    super.teardown();}
0
public void testCreateTransactionWithMode() throws Exception
{    complete(AsyncWrappers.asyncEnsureContainers(client, "/test"));    CuratorOp op1 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    CuratorOp op2 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    complete(client.transaction().forOperations(Arrays.asList(op1, op2)));    Assert.assertEquals(client.unwrap().getChildren().forPath("/test").size(), 2);}
0
public void testCrud()
{    AsyncStage<String> createStage = client.create().forPath("/test", "one".getBytes());    complete(createStage, (path, e) -> Assert.assertEquals(path, "/test"));    AsyncStage<byte[]> getStage = client.getData().forPath("/test");    complete(getStage, (data, e) -> Assert.assertEquals(data, "one".getBytes()));    CompletionStage<byte[]> combinedStage = client.setData().forPath("/test", "new".getBytes()).thenCompose(__ -> client.getData().forPath("/test"));    complete(combinedStage, (data, e) -> Assert.assertEquals(data, "new".getBytes()));    CompletionStage<Void> combinedDelete = client.create().withMode(EPHEMERAL_SEQUENTIAL).forPath("/deleteme").thenCompose(path -> client.delete().forPath(path));    complete(combinedDelete, (v, e) -> Assert.assertNull(e));    CompletionStage<byte[]> setDataIfStage = client.create().withOptions(of(compress, setDataIfExists)).forPath("/test", "last".getBytes()).thenCompose(__ -> client.getData().decompressed().forPath("/test"));    complete(setDataIfStage, (data, e) -> Assert.assertEquals(data, "last".getBytes()));}
0
public void testException()
{    CountDownLatch latch = new CountDownLatch(1);    client.getData().forPath("/woop").exceptionally(e -> {        Assert.assertTrue(e instanceof KeeperException);        Assert.assertEquals(((KeeperException) e).code(), KeeperException.Code.NONODE);        latch.countDown();        return null;    });    Assert.assertTrue(timing.awaitLatch(latch));}
0
public void testWatching()
{    CountDownLatch latch = new CountDownLatch(1);    client.watched().checkExists().forPath("/test").event().whenComplete((event, exception) -> {        Assert.assertNull(exception);        Assert.assertEquals(event.getType(), Watcher.Event.EventType.NodeCreated);        latch.countDown();    });    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
0
public void testWatchingWithServerLoss() throws Exception
{    AsyncStage<Stat> stage = client.watched().checkExists().forPath("/test");    stage.thenRun(() -> {        try {            server.stop();        } catch (IOException e) {                }    });    CountDownLatch latch = new CountDownLatch(1);    complete(stage.event(), (v, e) -> {        Assert.assertTrue(e instanceof AsyncEventException);        Assert.assertEquals(((AsyncEventException) e).getKeeperState(), Watcher.Event.KeeperState.Disconnected);        ((AsyncEventException) e).reset().thenRun(latch::countDown);    });    server.restart();    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
0
public void testResultWrapper() throws Exception
{    CompletionStage<AsyncResult<String>> resultStage = AsyncResult.of(client.create().forPath("/first"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertEquals(v.getRawValue(), "/first");        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.OK);    });    resultStage = AsyncResult.of(client.create().forPath("/foo/bar"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.NONODE);    });    resultStage = AsyncResult.of(client.create().forPath("illegal path"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNotNull(v.getRawException());        Assert.assertTrue(v.getRawException() instanceof IllegalArgumentException);        Assert.assertEquals(v.getCode(), KeeperException.Code.SYSTEMERROR);    });    server.stop();    resultStage = AsyncResult.of(client.create().forPath("/second"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.CONNECTIONLOSS);    });}
0
public void testGetDataWithStat()
{    complete(client.create().forPath("/test", "hey".getBytes()));    Stat stat = new Stat();    complete(client.getData().storingStatIn(stat).forPath("/test"));    Assert.assertEquals(stat.getDataLength(), "hey".length());}
0
 void add(ServiceInstance<?> instance)
{    purge();    Status newStatus = new Status();    Status oldStatus = statuses.putIfAbsent(instance, newStatus);    Status useStatus = (oldStatus != null) ? oldStatus : newStatus;    useStatus.errorCount.incrementAndGet();}
0
public boolean apply(ServiceInstance<T> instance)
{    purge();    Status status = statuses.get(instance);    return (status == null) || (status.errorCount.get() < downInstancePolicy.getErrorThreshold());}
0
private void purge()
{    long localLastPurge = lastPurge.get();    long ticksSinceLastPurge = System.currentTimeMillis() - localLastPurge;    if (ticksSinceLastPurge < (downInstancePolicy.getTimeoutMs() / 2)) {        return;    }    if (!lastPurge.compareAndSet(localLastPurge, System.currentTimeMillis())) {        return;    }    Iterator<Entry<ServiceInstance<?>, Status>> it = statuses.entrySet().iterator();    while (it.hasNext()) {        Entry<ServiceInstance<?>, Status> entry = it.next();        long elapsedMs = System.currentTimeMillis() - entry.getValue().startMs;        if (elapsedMs >= downInstancePolicy.getTimeoutMs()) {            it.remove();        }    }}
0
public List<ServiceInstance<T>> getInstances() throws Exception
{    Iterable<ServiceInstance<T>> filtered = Iterables.filter(instanceProvider.getInstances(), predicates);    return ImmutableList.copyOf(filtered);}
0
public ServiceInstance<T> deserialize(byte[] bytes) throws Exception
{    ServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        payloadClass.cast(rawServiceInstance.getPayload());    return (ServiceInstance<T>) rawServiceInstance;}
0
public byte[] serialize(ServiceInstance<T> instance) throws Exception
{    if (compatibleSerializationMode) {        OldServiceInstance<T> compatible = new OldServiceInstance<T>(instance.getName(), instance.getId(), instance.getAddress(), instance.getPort(), instance.getSslPort(), instance.getPayload(), instance.getRegistrationTimeUTC(), instance.getServiceType(), instance.getUriSpec());        return mapper.writeValueAsBytes(compatible);    }    return mapper.writeValueAsBytes(instance);}
0
 synchronized void set()
{    laden = true;    notifyAll();}
0
 synchronized void await() throws InterruptedException
{    while (!laden) {        wait();    }    laden = false;}
0
public String getName()
{    return name;}
0
public String getId()
{    return id;}
0
public String getAddress()
{    return address;}
0
public Integer getPort()
{    return port;}
0
public Integer getSslPort()
{    return sslPort;}
0
public T getPayload()
{    return payload;}
0
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
0
public ServiceType getServiceType()
{    return serviceType;}
0
public UriSpec getUriSpec()
{    return uriSpec;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    OldServiceInstance that = (OldServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    return true;}
0
public int hashCode()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    return result;}
0
public String toString()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + '}';}
0
public ServiceCache<T> build()
{    if (executorService != null) {        return new ServiceCacheImpl<T>(discovery, name, executorService);    } else {        return new ServiceCacheImpl<T>(discovery, name, threadFactory);    }}
0
public ServiceCacheBuilder<T> name(String name)
{    this.name = name;    return this;}
0
public ServiceCacheBuilder<T> threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    this.executorService = null;    return this;}
0
public ServiceCacheBuilder<T> executorService(ExecutorService executorService)
{    this.executorService = new CloseableExecutorService(executorService);    this.threadFactory = null;    return this;}
0
public ServiceCacheBuilder<T> executorService(CloseableExecutorService executorService)
{    this.executorService = executorService;    this.threadFactory = null;    return this;}
0
private static CloseableExecutorService convertThreadFactory(ThreadFactory threadFactory)
{    Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory));}
0
public List<ServiceInstance<T>> getInstances()
{    return Lists.newArrayList(instances.values());}
0
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    cache.start(true);    if (debugStartLatch != null) {        debugStartLatch.countDown();        debugStartLatch = null;    }    if (debugStartWaitLatch != null) {        debugStartWaitLatch.await();        debugStartWaitLatch = null;    }    for (ChildData childData : cache.getCurrentData()) {        if (        childData.getData() != null) {            addInstance(childData, true);        }    }    discovery.cacheOpened(this);}
0
public void close() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.STOPPED), "Already closed or has not been started");    listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {        @Override        public Void apply(ServiceCacheListener listener) {            discovery.getClient().getConnectionStateListenable().removeListener(listener);            return null;        }    });    listenerContainer.clear();    CloseableUtils.closeQuietly(cache);    discovery.cacheClosed(this);}
0
public Void apply(ServiceCacheListener listener)
{    discovery.getClient().getConnectionStateListenable().removeListener(listener);    return null;}
0
public void addListener(ServiceCacheListener listener)
{    listenerContainer.addListener(listener);    discovery.getClient().getConnectionStateListenable().addListener(listener);}
0
public void addListener(ServiceCacheListener listener, Executor executor)
{    listenerContainer.addListener(listener, executor);    discovery.getClient().getConnectionStateListenable().addListener(listener, executor);}
0
public void removeListener(ServiceCacheListener listener)
{    listenerContainer.removeListener(listener);    discovery.getClient().getConnectionStateListenable().removeListener(listener);}
0
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    boolean notifyListeners = false;    switch(event.getType()) {        case CHILD_ADDED:        case CHILD_UPDATED:            {                addInstance(event.getData(), false);                notifyListeners = true;                break;            }        case CHILD_REMOVED:            {                instances.remove(instanceIdFromData(event.getData()));                notifyListeners = true;                break;            }    }    if (notifyListeners) {        listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {            @Override            public Void apply(ServiceCacheListener listener) {                listener.cacheChanged();                return null;            }        });    }}
0
public Void apply(ServiceCacheListener listener)
{    listener.cacheChanged();    return null;}
0
private String instanceIdFromData(ChildData childData)
{    return ZKPaths.getNodeFromPath(childData.getPath());}
0
private void addInstance(ChildData childData, boolean onlyIfAbsent) throws Exception
{    String instanceId = instanceIdFromData(childData);    ServiceInstance<T> serviceInstance = discovery.getSerializer().deserialize(childData.getData());    if (onlyIfAbsent) {        instances.putIfAbsent(instanceId, serviceInstance);    } else {        instances.put(instanceId, serviceInstance);    }    cache.clearDataBytes(childData.getPath(), childData.getStat().getVersion());}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) || (newState == ConnectionState.CONNECTED)) {        try {                        reRegisterServices();        } catch (InterruptedException ex) {            Thread.currentThread().interrupt();        } catch (Exception e) {                    }    }}
1
public void start() throws Exception
{    try {        reRegisterServices();    } catch (KeeperException e) {            }    client.getConnectionStateListenable().addListener(connectionStateListener);}
1
public void close() throws IOException
{    ExceptionAccumulator accumulator = new ExceptionAccumulator();    for (ServiceProvider<T> provider : Lists.newArrayList(providers)) {        CloseableUtils.closeQuietly(provider);    }    for (Entry<T> entry : services.values()) {        try {            internalUnregisterService(entry);        } catch (KeeperException.NoNodeException ignore) {                } catch (Exception e) {            accumulator.add(e);                    }    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    accumulator.propagate();}
1
public void registerService(ServiceInstance<T> service) throws Exception
{    Entry<T> newEntry = new Entry<T>(service);    Entry<T> oldEntry = services.putIfAbsent(service.getId(), newEntry);    Entry<T> useEntry = (oldEntry != null) ? oldEntry : newEntry;    synchronized (useEntry) {        if (        useEntry == newEntry) {            useEntry.cache = makeNodeCache(service);        }        internalRegisterService(service);    }}
0
public void updateService(final ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.get(service.getId());    if (entry == null) {        throw new Exception("Service not registered: " + service);    }    synchronized (entry) {        entry.service = service;        byte[] bytes = serializer.serialize(service);        String path = pathForInstance(service.getName(), service.getId());        client.setData().forPath(path, bytes);    }}
0
protected void internalRegisterService(ServiceInstance<T> service) throws Exception
{    byte[] bytes = serializer.serialize(service);    String path = pathForInstance(service.getName(), service.getId());    final int MAX_TRIES = 2;    boolean isDone = false;    for (int i = 0; !isDone && (i < MAX_TRIES); ++i) {        try {            CreateMode mode;            switch(service.getServiceType()) {                case DYNAMIC:                    mode = CreateMode.EPHEMERAL;                    break;                case DYNAMIC_SEQUENTIAL:                    mode = CreateMode.EPHEMERAL_SEQUENTIAL;                    break;                default:                    mode = CreateMode.PERSISTENT;                    break;            }            client.create().creatingParentContainersIfNeeded().withMode(mode).forPath(path, bytes);            isDone = true;        } catch (KeeperException.NodeExistsException e) {                        client.delete().forPath(path);        }    }}
0
public void unregisterService(ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.remove(service.getId());    internalUnregisterService(entry);}
0
public ServiceProviderBuilder<T> serviceProviderBuilder()
{    return new ServiceProviderBuilderImpl<T>(this).providerStrategy(new RoundRobinStrategy<T>()).threadFactory(ThreadUtils.newThreadFactory("ServiceProvider"));}
0
public ServiceCacheBuilder<T> serviceCacheBuilder()
{    return new ServiceCacheBuilderImpl<T>(this).threadFactory(ThreadUtils.newThreadFactory("ServiceCache"));}
0
public Collection<String> queryForNames() throws Exception
{    List<String> names = client.getChildren().forPath(basePath);    return ImmutableList.copyOf(names);}
0
public Collection<ServiceInstance<T>> queryForInstances(String name) throws Exception
{    return queryForInstances(name, null);}
0
public ServiceInstance<T> queryForInstance(String name, String id) throws Exception
{    String path = pathForInstance(name, id);    try {        byte[] bytes = client.getData().forPath(path);        return serializer.deserialize(bytes);    } catch (KeeperException.NoNodeException ignore) {        }    return null;}
0
 void cacheOpened(ServiceCache<T> cache)
{    caches.add(cache);}
0
 void cacheClosed(ServiceCache<T> cache)
{    caches.remove(cache);}
0
 void providerOpened(ServiceProvider<T> provider)
{    providers.add(provider);}
0
 void providerClosed(ServiceProvider<T> cache)
{    providers.remove(cache);}
0
 CuratorFramework getClient()
{    return client;}
0
 String pathForName(String name)
{    return ZKPaths.makePath(basePath, name);}
0
 InstanceSerializer<T> getSerializer()
{    return serializer;}
0
 List<ServiceInstance<T>> queryForInstances(String name, Watcher watcher) throws Exception
{    ImmutableList.Builder<ServiceInstance<T>> builder = ImmutableList.builder();    String path = pathForName(name);    List<String> instanceIds;    if (watcher != null) {        instanceIds = getChildrenWatched(path, watcher, true);    } else {        try {            instanceIds = client.getChildren().forPath(path);        } catch (KeeperException.NoNodeException e) {            instanceIds = Lists.newArrayList();        }    }    for (String id : instanceIds) {        ServiceInstance<T> instance = queryForInstance(name, id);        if (instance != null) {            builder.add(instance);        }    }    return builder.build();}
0
 int debugServicesQty()
{    return services.size();}
0
private List<String> getChildrenWatched(String path, Watcher watcher, boolean recurse) throws Exception
{    List<String> instanceIds;    try {        instanceIds = client.getChildren().usingWatcher(watcher).forPath(path);    } catch (KeeperException.NoNodeException e) {        if (recurse) {            try {                client.create().creatingParentContainersIfNeeded().forPath(path);            } catch (KeeperException.NodeExistsException ignore) {                        }            instanceIds = getChildrenWatched(path, watcher, false);        } else {            throw e;        }    }    return instanceIds;}
0
 String pathForInstance(String name, String id)
{    return ZKPaths.makePath(pathForName(name), id);}
0
 ServiceInstance<T> getRegisteredService(String id)
{    Entry<T> entry = services.get(id);    return (entry != null) ? entry.service : null;}
0
private void reRegisterServices() throws Exception
{    for (final Entry<T> entry : services.values()) {        synchronized (entry) {            internalRegisterService(entry.service);        }    }}
0
private NodeCache makeNodeCache(final ServiceInstance<T> instance)
{    if (!watchInstances) {        return null;    }    final NodeCache nodeCache = new NodeCache(client, pathForInstance(instance.getName(), instance.getId()));    try {        nodeCache.start(true);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        return null;    } catch (Exception e) {            }    NodeCacheListener listener = new NodeCacheListener() {        @Override        public void nodeChanged() throws Exception {            if (nodeCache.getCurrentData() != null) {                ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());                Entry<T> entry = services.get(newInstance.getId());                if (entry != null) {                    synchronized (entry) {                        entry.service = newInstance;                    }                }            } else {                            }        }    };    nodeCache.getListenable().addListener(listener);    return nodeCache;}
1
public void nodeChanged() throws Exception
{    if (nodeCache.getCurrentData() != null) {        ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());        Entry<T> entry = services.get(newInstance.getId());        if (entry != null) {            synchronized (entry) {                entry.service = newInstance;            }        }    } else {            }}
1
private void internalUnregisterService(final Entry<T> entry) throws Exception
{    if (entry != null) {        synchronized (entry) {            if (entry.cache != null) {                CloseableUtils.closeQuietly(entry.cache);                entry.cache = null;            }            String path = pathForInstance(entry.service.getName(), entry.service.getId());            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException ignore) {                        }        }    }}
0
public ServiceProvider<T> build()
{    return new ServiceProviderImpl<T>(discovery, serviceName, providerStrategy, threadFactory, filters, downInstancePolicy);}
0
public ServiceProviderBuilder<T> serviceName(String serviceName)
{    this.serviceName = serviceName;    return this;}
0
public ServiceProviderBuilder<T> providerStrategy(ProviderStrategy<T> providerStrategy)
{    this.providerStrategy = providerStrategy;    return this;}
0
public ServiceProviderBuilder<T> threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
0
public ServiceProviderBuilder<T> downInstancePolicy(DownInstancePolicy downInstancePolicy)
{    this.downInstancePolicy = downInstancePolicy;    return this;}
0
public ServiceProviderBuilder<T> additionalFilter(InstanceFilter<T> filter)
{    filters.add(filter);    return this;}
0
public boolean apply(ServiceInstance<T> instance)
{    return instance.isEnabled();}
0
public void start() throws Exception
{    cache.start();    discovery.providerOpened(this);}
0
public void close() throws IOException
{    discovery.providerClosed(this);    cache.close();}
0
public Collection<ServiceInstance<T>> getAllInstances() throws Exception
{    return instanceProvider.getInstances();}
0
public ServiceInstance<T> getInstance() throws Exception
{    return providerStrategy.getInstance(instanceProvider);}
0
public void noteError(ServiceInstance<T> instance)
{    downInstanceManager.add(instance);}
0
public long getTimeoutMs()
{    return timeoutMs;}
0
public int getErrorThreshold()
{    return errorThreshold;}
0
public static ServiceDiscoveryBuilder<T> builder(Class<T> payloadClass)
{    return new ServiceDiscoveryBuilder<T>(payloadClass);}
0
public ServiceDiscovery<T> build()
{    if (serializer == null) {        serializer(new JsonInstanceSerializer<T>(payloadClass));    }    return new ServiceDiscoveryImpl<T>(client, basePath, serializer, thisInstance, watchInstances);}
0
public ServiceDiscoveryBuilder<T> client(CuratorFramework client)
{    this.client = client;    return this;}
0
public ServiceDiscoveryBuilder<T> basePath(String basePath)
{    this.basePath = basePath;    return this;}
0
public ServiceDiscoveryBuilder<T> serializer(InstanceSerializer<T> serializer)
{    this.serializer = serializer;    return this;}
0
public ServiceDiscoveryBuilder<T> thisInstance(ServiceInstance<T> thisInstance)
{    this.thisInstance = thisInstance;    return this;}
0
public ServiceDiscoveryBuilder<T> watchInstances(boolean watchInstances)
{    this.watchInstances = watchInstances;    return this;}
0
public static ServiceInstanceBuilder<T> builder() throws Exception
{    String address = null;    Collection<InetAddress> ips = ServiceInstanceBuilder.getAllLocalIPs();    if (ips.size() > 0) {                address = ips.iterator().next().getHostAddress();    }    String id = UUID.randomUUID().toString();    return new ServiceInstanceBuilder<T>().address(address).id(id).registrationTimeUTC(System.currentTimeMillis());}
0
public String getName()
{    return name;}
0
public String getId()
{    return id;}
0
public String getAddress()
{    return address;}
0
public Integer getPort()
{    return port;}
0
public Integer getSslPort()
{    return sslPort;}
0
public T getPayload()
{    return payload;}
0
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
0
public ServiceType getServiceType()
{    return serviceType;}
0
public UriSpec getUriSpec()
{    return uriSpec;}
0
public boolean isEnabled()
{    return enabled;}
0
public String buildUriSpec()
{    return buildUriSpec(Maps.<String, Object>newHashMap());}
0
public String buildUriSpec(Map<String, Object> variables)
{    return (uriSpec != null) ? uriSpec.build(this, variables) : "";}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ServiceInstance that = (ServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    if (enabled != that.enabled) {        return false;    }    return true;}
0
public int hashCode()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    result = 31 * result + (enabled ? 1 : 0);    return result;}
0
public String toString()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + ", enabled=" + enabled + '}';}
0
public boolean use(NetworkInterface nif, InetAddress adr) throws SocketException
{    return (adr != null) && !adr.isLoopbackAddress() && (nif.isPointToPoint() || !adr.isLinkLocalAddress());}
0
public static void setLocalIpFilter(LocalIpFilter newLocalIpFilter)
{    localIpFilter.set(newLocalIpFilter);}
0
public static LocalIpFilter getLocalIpFilter()
{    return localIpFilter.get();}
0
public ServiceInstance<T> build()
{    return new ServiceInstance<T>(name, id, address, port, sslPort, payload, registrationTimeUTC, serviceType, uriSpec, enabled);}
0
public ServiceInstanceBuilder<T> name(String name)
{    this.name = name;    return this;}
0
public ServiceInstanceBuilder<T> address(String address)
{    this.address = address;    return this;}
0
public ServiceInstanceBuilder<T> id(String id)
{    this.id = id;    return this;}
0
public ServiceInstanceBuilder<T> port(int port)
{    this.port = port;    return this;}
0
public ServiceInstanceBuilder<T> sslPort(int port)
{    this.sslPort = port;    return this;}
0
public ServiceInstanceBuilder<T> payload(T payload)
{    this.payload = payload;    return this;}
0
public ServiceInstanceBuilder<T> serviceType(ServiceType serviceType)
{    this.serviceType = serviceType;    return this;}
0
public ServiceInstanceBuilder<T> registrationTimeUTC(long registrationTimeUTC)
{    this.registrationTimeUTC = registrationTimeUTC;    return this;}
0
public ServiceInstanceBuilder<T> uriSpec(UriSpec uriSpec)
{    this.uriSpec = uriSpec;    return this;}
0
public ServiceInstanceBuilder<T> enabled(boolean enabled)
{    this.enabled = enabled;    return this;}
0
public static Collection<InetAddress> getAllLocalIPs() throws SocketException
{    List<InetAddress> listAdr = Lists.newArrayList();    Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();    if (nifs == null)        return listAdr;    while (nifs.hasMoreElements()) {        NetworkInterface nif = nifs.nextElement();                Enumeration<InetAddress> adrs = nif.getInetAddresses();        while (adrs.hasMoreElements()) {            InetAddress adr = adrs.nextElement();            if (localIpFilter.get().use(nif, adr)) {                listAdr.add(adr);            }        }    }    return listAdr;}
0
public boolean isDynamic()
{    return this == DYNAMIC || this == DYNAMIC_SEQUENTIAL;}
0
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = random.nextInt(instances.size());    return instances.get(thisIndex);}
0
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = Math.abs(index.getAndIncrement());    return instances.get(thisIndex % instances.size());}
0
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    final List<ServiceInstance<T>> instances = instanceProvider.getInstances();    {        ServiceInstance<T> localOurInstance = ourInstance.get();        if (!instances.contains(localOurInstance)) {            ourInstance.compareAndSet(localOurInstance, null);        }    }    if (ourInstance.get() == null) {        ServiceInstance<T> instance = masterStrategy.getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (ourInstance.compareAndSet(null, instance)) {            instanceNumber.incrementAndGet();        }    }    return ourInstance.get();}
0
public List<ServiceInstance<T>> getInstances() throws Exception
{    return instances;}
0
public int getInstanceNumber()
{    return instanceNumber.get();}
0
public String getValue()
{    return value;}
0
public boolean isVariable()
{    return variable;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Part part = (Part) o;    if (variable != part.variable) {        return false;    }    if (!value.equals(part.value)) {        return false;    }    return true;}
0
public int hashCode()
{    int result = value.hashCode();    result = 31 * result + (variable ? 1 : 0);    return result;}
0
public String build()
{    return build(null, Maps.<String, Object>newHashMap());}
0
public String build(ServiceInstance<?> serviceInstance)
{    return build(serviceInstance, Maps.<String, Object>newHashMap());}
0
public String build(Map<String, Object> variables)
{    return build(null, variables);}
0
public String build(ServiceInstance<?> serviceInstance, Map<String, Object> variables)
{    Map<String, Object> localVariables = Maps.newHashMap();    localVariables.put(FIELD_OPEN_BRACE, "{");    localVariables.put(FIELD_CLOSE_BRACE, "}");    localVariables.put(FIELD_SCHEME, "http");    if (serviceInstance != null) {        localVariables.put(FIELD_NAME, nullCheck(serviceInstance.getName()));        localVariables.put(FIELD_ID, nullCheck(serviceInstance.getId()));        localVariables.put(FIELD_ADDRESS, nullCheck(serviceInstance.getAddress()));        localVariables.put(FIELD_PORT, nullCheck(serviceInstance.getPort()));        localVariables.put(FIELD_SSL_PORT, nullCheck(serviceInstance.getSslPort()));        localVariables.put(FIELD_REGISTRATION_TIME_UTC, nullCheck(serviceInstance.getRegistrationTimeUTC()));        localVariables.put(FIELD_SERVICE_TYPE, (serviceInstance.getServiceType() != null) ? serviceInstance.getServiceType().name().toLowerCase() : "");        if (serviceInstance.getSslPort() != null) {            localVariables.put(FIELD_SCHEME, "https");        }    }    localVariables.putAll(variables);    StringBuilder str = new StringBuilder();    for (Part p : parts) {        if (p.isVariable()) {            Object value = localVariables.get(p.getValue());            if (value == null) {                            } else {                str.append(value);            }        } else {            str.append(p.getValue());        }    }    return str.toString();}
1
public Iterator<Part> iterator()
{    return Iterators.unmodifiableIterator(parts.iterator());}
0
public List<Part> getParts()
{    return ImmutableList.copyOf(parts);}
0
public void add(Part part)
{    parts.add(part);}
0
public void remove(Part part)
{    parts.remove(part);}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    UriSpec spec = (UriSpec) o;    if (!parts.equals(spec.parts)) {        return false;    }    return true;}
0
public int hashCode()
{    return parts.hashCode();}
0
private Object nullCheck(Object o)
{    return (o != null) ? o : "";}
0
public void testBasic() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
0
public void testThreshold() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugMultiDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
0
public void testExpiration() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    Thread.sleep(debugDownInstancePolicy.getTimeoutMs());    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
0
public void testCompatibilityMode() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldBytes = mapper.writeValueAsBytes(oldInstance);    Assert.assertEquals(bytes, oldBytes, String.format("%s vs %s", new String(bytes), new String(oldBytes)));}
0
public void testBackwardCompatibility() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    instance = serializer.deserialize(bytes);        Assert.assertTrue(instance.isEnabled());    ObjectMapper mapper = new ObjectMapper();    JavaType type = mapper.getTypeFactory().constructType(OldServiceInstance.class);    OldServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        TestJsonInstanceSerializer.Payload.class.cast(rawServiceInstance.getPayload());        OldServiceInstance<TestJsonInstanceSerializer.Payload> check = (OldServiceInstance<TestJsonInstanceSerializer.Payload>) rawServiceInstance;    Assert.assertEquals(check.getName(), instance.getName());    Assert.assertEquals(check.getId(), instance.getId());    Assert.assertEquals(check.getAddress(), instance.getAddress());    Assert.assertEquals(check.getPort(), instance.getPort());    Assert.assertEquals(check.getSslPort(), instance.getSslPort());    Assert.assertEquals(check.getPayload(), instance.getPayload());    Assert.assertEquals(check.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(check.getServiceType(), instance.getServiceType());    Assert.assertEquals(check.getUriSpec(), instance.getUriSpec());}
0
public void testForwardCompatibility() throws Exception
{    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldJson = mapper.writeValueAsBytes(oldInstance);    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = serializer.deserialize(oldJson);    Assert.assertEquals(oldInstance.getName(), instance.getName());    Assert.assertEquals(oldInstance.getId(), instance.getId());    Assert.assertEquals(oldInstance.getAddress(), instance.getAddress());    Assert.assertEquals(oldInstance.getPort(), instance.getPort());    Assert.assertEquals(oldInstance.getSslPort(), instance.getSslPort());    Assert.assertEquals(oldInstance.getPayload(), instance.getPayload());    Assert.assertEquals(oldInstance.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(oldInstance.getServiceType(), instance.getServiceType());    Assert.assertEquals(oldInstance.getUriSpec(), instance.getUriSpec());    Assert.assertTrue(instance.isEnabled());}
0
public void testFutureChanges() throws Exception
{    TestNewServiceInstance<String> newInstance = new TestNewServiceInstance<String>("name", "id", "address", 10, 20, "hey", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false, "what", 10101L, new Date(), new URI("http://hey"));    byte[] newInstanceBytes = new ObjectMapper().writeValueAsBytes(newInstance);    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = serializer.deserialize(newInstanceBytes);    Assert.assertEquals(instance.getName(), "name");    Assert.assertEquals(instance.getPayload(), "hey");    Assert.assertEquals(instance.isEnabled(), false);}
0
public String getName()
{    return name;}
0
public String getId()
{    return id;}
0
public String getAddress()
{    return address;}
0
public Integer getPort()
{    return port;}
0
public Integer getSslPort()
{    return sslPort;}
0
public T getPayload()
{    return payload;}
0
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
0
public ServiceType getServiceType()
{    return serviceType;}
0
public UriSpec getUriSpec()
{    return uriSpec;}
0
public boolean isEnabled()
{    return enabled;}
0
public String getNew1()
{    return new1;}
0
public Long getNew2()
{    return new2;}
0
public Date getNew3()
{    return new3;}
0
public URI getNew4()
{    return new4;}
0
public void testRaceOnInitialLoad() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        CountDownLatch cacheStartLatch = new CountDownLatch(1);        CountDownLatch cacheWaitLatch = new CountDownLatch(1);        final ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);                ((ServiceCacheImpl) cache).debugStartLatch = cacheStartLatch;                ((ServiceCacheImpl) cache).debugStartWaitLatch = cacheWaitLatch;        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        discovery.registerService(instance1);        CloseableExecutorService closeableExecutorService = new CloseableExecutorService(Executors.newSingleThreadExecutor());        closeables.add(closeableExecutorService);        final CountDownLatch startCompletedLatch = new CountDownLatch(1);        Runnable proc = new Runnable() {            @Override            public void run() {                try {                    cache.start();                    startCompletedLatch.countDown();                } catch (Exception e) {                    LoggerFactory.getLogger(getClass()).error("Start failed", e);                    throw new RuntimeException(e);                }            }        };        closeableExecutorService.submit(proc);                Assert.assertTrue(timing.awaitLatch(cacheStartLatch));        final CountDownLatch cacheChangedLatch = new CountDownLatch(1);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                cacheChangedLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        cache.addListener(listener);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();                discovery.registerService(instance2);        Assert.assertTrue(timing.awaitLatch(cacheChangedLatch));        cacheWaitLatch.countDown();        Assert.assertTrue(timing.awaitLatch(startCompletedLatch));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void run()
{    try {        cache.start();        startCompletedLatch.countDown();    } catch (Exception e) {        LoggerFactory.getLogger(getClass()).error("Start failed", e);        throw new RuntimeException(e);    }}
0
public void cacheChanged()
{    cacheChangedLatch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public int compare(ServiceInstance<Void> o1, ServiceInstance<Void> o2)
{    return o1.getId().compareTo(o2.getId());}
0
public void testCrashedServerMultiInstances() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance1, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        discovery.registerService(instance2);        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
protected void internalRegisterService(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
0
public void testCrashedServer() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
protected void internalRegisterService(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
0
public void testCrashedInstance() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false);        discovery.start();        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public void testMultipleInstances() throws Exception
{    final String SERVICE_ONE = "one";    final String SERVICE_TWO = "two";    CuratorFramework client = null;    ServiceDiscovery<Void> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<Void> s1_i1 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s1_i2 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s2_i1 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        ServiceInstance<Void> s2_i2 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        discovery = ServiceDiscoveryBuilder.builder(Void.class).client(client).basePath("/test").build();        discovery.start();        discovery.registerService(s1_i1);        discovery.registerService(s1_i2);        discovery.registerService(s2_i1);        discovery.registerService(s2_i2);        Assert.assertEquals(Sets.newHashSet(discovery.queryForNames()), Sets.newHashSet(SERVICE_ONE, SERVICE_TWO));        List<ServiceInstance<Void>> list = Lists.newArrayList();        list.add(s1_i1);        list.add(s1_i2);        Collections.sort(list, comparator);        List<ServiceInstance<Void>> queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_ONE));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal l: %s - d: %s", list, queriedInstances));        list.clear();        list.add(s2_i1);        list.add(s2_i2);        Collections.sort(list, comparator);        queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_TWO));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal 2: %s - d: %s", list, queriedInstances));    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public void testBasic() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public void testNoServerOnStart() throws Exception
{    Timing timing = new Timing();    server.stop();    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        server.restart();        timing.sleepABit();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public void testUnregisterService() throws Exception
{    final String name = "name";    final CountDownLatch restartLatch = new CountDownLatch(1);    InstanceSerializer<String> slowSerializer = new JsonInstanceSerializer<String>(String.class) {        private boolean first = true;        @Override        public byte[] serialize(ServiceInstance<String> instance) throws Exception {            if (first) {                System.out.println("Serializer first registration.");                first = false;            } else {                System.out.println("Waiting for reconnect to finish.");                                                restartLatch.await();            }            return super.serialize(instance);        }    };    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name(name).port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).serializer(slowSerializer).watchInstances(true).build();        discovery.start();        Assert.assertFalse(discovery.queryForInstances(name).isEmpty(), "Service should start registered.");        server.stop();        server.restart();        discovery.unregisterService(instance);        restartLatch.countDown();                new Timing().sleepABit();        Assert.assertTrue(discovery.queryForInstances(name).isEmpty(), "Service should have unregistered.");    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public byte[] serialize(ServiceInstance<String> instance) throws Exception
{    if (first) {        System.out.println("Serializer first registration.");        first = false;    } else {        System.out.println("Waiting for reconnect to finish.");                        restartLatch.await();    }    return super.serialize(instance);}
0
public void testCleaning() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        discovery.unregisterService(instance);        Assert.assertEquals(((ServiceDiscoveryImpl) discovery).debugServicesQty(), 0);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0
public void testDefaultSerializer() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertTrue(discovery.getSerializer() instanceof JsonInstanceSerializer, "default serializer not JSON");}
0
public void testSetSerializer() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    builder.serializer(new InstanceSerializer<Object>() {        @Override        public byte[] serialize(ServiceInstance<Object> instance) {            return null;        }        @Override        public ServiceInstance<Object> deserialize(byte[] bytes) {            return null;        }    });    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertFalse(discovery.getSerializer() instanceof JsonInstanceSerializer, "set serializer is JSON");}
0
public byte[] serialize(ServiceInstance<Object> instance)
{    return null;}
0
public ServiceInstance<Object> deserialize(byte[] bytes)
{    return null;}
0
public void testBasic() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), instance);        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(provider.getAllInstances(), list);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void testDisabledInstance() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).enabled(false).build();        InstanceSerializer<String> serializer = new JsonInstanceSerializer<>(String.class, false);        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).serializer(serializer).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), null);        Assert.assertTrue(provider.getAllInstances().isEmpty(), "Disabled instance still appears available via service provider");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void testWatchedInstances() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).watchInstances(true).build();        closeables.add(discovery);        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Arrays.asList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);        ServiceDiscoveryImpl<String> discoveryImpl = (ServiceDiscoveryImpl<String>) discovery;        ServiceInstance<String> changedInstance = ServiceInstance.<String>builder().id(instance.getId()).address(instance.getAddress()).payload("different").name(instance.getName()).port(instance.getPort()).build();        String path = discoveryImpl.pathForInstance("test", instance.getId());        byte[] bytes = discoveryImpl.getSerializer().serialize(changedInstance);        client.setData().forPath(path, bytes);        timing.sleepABit();        ServiceInstance<String> registeredService = discoveryImpl.getRegisteredService(instance.getId());        Assert.assertNotNull(registeredService);        Assert.assertEquals(registeredService.getPayload(), "different");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public static void main(String[] args) throws Exception
{    TestingServer testingServer = new TestingServer();    final CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(testingServer.getConnectString(), new RetryOneTime(1));    try {        curatorFramework.start();        doWork(curatorFramework);        System.gc();        System.out.println("Done - get dump");        Thread.currentThread().join();    } finally {        CloseableUtils.closeQuietly(curatorFramework);        CloseableUtils.closeQuietly(testingServer);    }}
0
private static void doWork(CuratorFramework curatorFramework) throws Exception
{    ServiceInstance<Void> thisInstance = ServiceInstance.<Void>builder().name("myservice").build();    final ServiceDiscovery<Void> serviceDiscovery = ServiceDiscoveryBuilder.builder(Void.class).client(curatorFramework.usingNamespace("dev")).basePath("/instances").thisInstance(thisInstance).build();    serviceDiscovery.start();    for (int i = 0; i < 100000; i++) {        final ServiceProvider<Void> s = serviceProvider(serviceDiscovery, "myservice");        s.start();        try {            s.getInstance().buildUriSpec();        } finally {            s.close();        }    }}
0
private static ServiceProvider<Void> serviceProvider(ServiceDiscovery<Void> serviceDiscovery, String name) throws Exception
{    return serviceDiscovery.serviceProviderBuilder().serviceName(name).providerStrategy(new RandomStrategy<Void>()).build();}
0
public void testBasic() throws Exception
{    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<String> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
0
public void testWrongPayloadType() throws Exception
{    JsonInstanceSerializer<String> stringSerializer = new JsonInstanceSerializer<String>(String.class);    JsonInstanceSerializer<Double> doubleSerializer = new JsonInstanceSerializer<Double>(Double.class);    byte[] bytes = stringSerializer.serialize(new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true));    try {        doubleSerializer.deserialize(bytes);        Assert.fail();    } catch (ClassCastException e) {        }}
0
public void testNoPayload() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    ServiceInstance<Void> instance = new ServiceInstance<Void>("name", "id", "address", 10, 20, null, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Void> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
0
public void testNoEnabledState() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    byte[] bytes = "{}".getBytes("utf-8");    ServiceInstance<Void> instance = serializer.deserialize(bytes);    Assert.assertTrue(instance.isEnabled(), "Instance that has no 'enabled' should be assumed enabled");}
0
public void testPayloadAsList() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    List<String> payload = new ArrayList<String>();    payload.add("Test value 1");    payload.add("Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
0
public void testPayloadAsMap() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    Map<String, String> payload = new HashMap<String, String>();    payload.put("1", "Test value 1");    payload.put("2", "Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
0
public void testPayloadClass() throws Exception
{    JsonInstanceSerializer<Payload> serializer = new JsonInstanceSerializer<Payload>(Payload.class);    Payload payload = new Payload();    payload.setVal("Test value");    ServiceInstance<Payload> instance = new ServiceInstance<Payload>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Payload> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
0
public String getVal()
{    return val;}
0
public void setVal(String val)
{    this.val = val;}
0
public boolean equals(Object other)
{    if (other == null || !(other instanceof Payload))        return false;    String otherVal = ((Payload) other).getVal();    if (val == null)        return val == otherVal;    return val.equals(otherVal);}
0
public void testFilterEverything() throws SocketException
{    LocalIpFilter localIpFilter = ServiceInstanceBuilder.getLocalIpFilter();    try {        ServiceInstanceBuilder.setLocalIpFilter(new LocalIpFilter() {            @Override            public boolean use(NetworkInterface networkInterface, InetAddress address) throws SocketException {                return false;            }        });        List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());        Assert.assertEquals(allLocalIPs.size(), 0);    } finally {        ServiceInstanceBuilder.setLocalIpFilter(localIpFilter);    }    List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());    Assert.assertTrue(allLocalIPs.size() > 0);}
0
public boolean use(NetworkInterface networkInterface, InetAddress address) throws SocketException
{    return false;}
0
public void testInitialLoad() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        final CountDownLatch latch = new CountDownLatch(3);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("test").name("test").port(10066).build();        discovery.registerService(instance1);        discovery.registerService(instance2);        discovery.registerService(instance3);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        ServiceCache<String> cache2 = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache2);        cache2.start();        Assert.assertEquals(cache2.getInstances().size(), 3);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void cacheChanged()
{    latch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testViaProvider() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> serviceProvider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(serviceProvider);        serviceProvider.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance);        int count = 0;        ServiceInstance<String> foundInstance = null;        while (foundInstance == null) {            Assert.assertTrue(count++ < 5);            foundInstance = serviceProvider.getInstance();            timing.sleepABit();        }        Assert.assertEquals(foundInstance, instance);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().address("foo").payload("thing").name("test").port(10064).build();        discovery.registerService(instance2);        timing.sleepABit();        Collection<ServiceInstance<String>> allInstances = serviceProvider.getAllInstances();        Assert.assertEquals(allInstances.size(), 2);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void testUpdate() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        final CountDownLatch latch = new CountDownLatch(1);        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        instance = ServiceInstance.<String>builder().payload("changed").name("test").port(10064).id(instance.getId()).build();        discovery.updateService(instance);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(cache.getInstances().size(), 1);        Assert.assertEquals(cache.getInstances().get(0).getPayload(), instance.getPayload());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void cacheChanged()
{    latch.countDown();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testCache() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        discovery.registerService(instance2);        Assert.assertTrue(semaphore.tryAcquire(3, TimeUnit.SECONDS));        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("thing").name("another").port(10064).build();        discovery.registerService(instance3);                Assert.assertFalse(semaphore.tryAcquire(3, TimeUnit.SECONDS));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void cacheChanged()
{    semaphore.release();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public void testExecutorServiceIsInvoked() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        Assert.assertFalse(exec.isExecuteCalled());        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").executorService(exec).build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        Assert.assertTrue(exec.isExecuteCalled());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
0
public void cacheChanged()
{    semaphore.release();}
0
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
0
public List<ServiceInstance<Void>> getInstances() throws Exception
{    return instances;}
0
public void testRandom() throws Exception
{    final int QTY = 10;    final int ITERATIONS = 1000;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY, 0);    ProviderStrategy<Void> strategy = new RandomStrategy<Void>();    long[] counts = new long[QTY];    for (int i = 0; i < ITERATIONS; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        int id = Integer.parseInt(instance.getId());        counts[id]++;    }    SummaryStatistics statistic = new SummaryStatistics();    for (int i = 0; i < QTY; ++i) {        statistic.addValue(counts[i]);    }        Assert.assertTrue(statistic.getStandardDeviation() <= (QTY * 2), "" + statistic.getStandardDeviation());}
0
public void testRoundRobin() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    ProviderStrategy<Void> strategy = new RoundRobinStrategy<Void>();    for (int i = 0; i < QTY; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i));    }    for (int i = 0; i < (1234 * QTY); ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i % QTY));    }}
0
public void testSticky() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    StickyStrategy<Void> strategy = new StickyStrategy<Void>(new RandomStrategy<Void>());    ServiceInstance<Void> theInstance = strategy.getInstance(instanceProvider);    int instanceNumber = strategy.getInstanceNumber();    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }        instanceProvider = new TestInstanceProvider(QTY, QTY);    Assert.assertFalse(strategy.getInstance(instanceProvider).equals(theInstance));    Assert.assertFalse(instanceNumber == strategy.getInstanceNumber());    theInstance = strategy.getInstance(instanceProvider);    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }}
0
public void testScheme()
{    UriSpec spec = new UriSpec("{scheme}://foo.com");    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.id("x");    builder.name("foo");    builder.port(5);    ServiceInstance<Void> instance = builder.build();    Assert.assertEquals(spec.build(instance), "http://foo.com");    builder.sslPort(5);    instance = builder.build();    Assert.assertEquals(spec.build(instance), "https://foo.com");}
0
public void testFromInstance()
{    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.address("1.2.3.4");    builder.name("foo");    builder.id("bar");    builder.port(5);    builder.sslPort(6);    builder.registrationTimeUTC(789);    builder.serviceType(ServiceType.PERMANENT);    ServiceInstance<Void> instance = builder.build();    UriSpec spec = new UriSpec("{scheme}://{address}:{port}:{ssl-port}/{name}/{id}/{registration-time-utc}/{service-type}");    Map<String, Object> m = Maps.newHashMap();    m.put("scheme", "test");    Assert.assertEquals(spec.build(instance, m), "test://1.2.3.4:5:6/foo/bar/789/permanent");}
0
public void testEscapes()
{    UriSpec spec = new UriSpec("{one}two-three-{[}four{]}-five{six}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two-three-", false);    checkPart(iterator.next(), "[", true);    checkPart(iterator.next(), "four", false);    checkPart(iterator.next(), "]", true);    checkPart(iterator.next(), "-five", false);    checkPart(iterator.next(), "six", true);    Map<String, Object> m = Maps.newHashMap();    m.put("one", 1);    m.put("six", 6);    Assert.assertEquals(spec.build(m), "1two-three-{four}-five6");}
0
public void testBasic()
{    UriSpec spec = new UriSpec("{one}{two}three-four-five{six}seven{eight}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two", true);    checkPart(iterator.next(), "three-four-five", false);    checkPart(iterator.next(), "six", true);    checkPart(iterator.next(), "seven", false);    checkPart(iterator.next(), "eight", true);}
0
private void checkPart(UriSpec.Part p, String value, boolean isVariable)
{    Assert.assertEquals(p.getValue(), value);    Assert.assertEquals(p.isVariable(), isVariable);}
0
public ProviderStrategy<T> getProviderStrategy()
{    return providerStrategy;}
0
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
0
public ServiceDiscovery<T> getServiceDiscovery()
{    return serviceDiscovery;}
0
public void marshallJson(ObjectNode node, String fieldName, T payload) throws Exception
{    if (payload == null) {                payload = (T) payloadType.getRawType().newInstance();    }    node.putPOJO(fieldName, payload);}
0
public T unMarshallJson(JsonNode node) throws Exception
{    T payload;    ObjectMapper mapper = new ObjectMapper();        payload = (T) mapper.readValue(node.toString(), payloadType.getRawType());    return payload;}
0
public DiscoveryContext<T> getContext(Class<?> type)
{    return this;}
0
public ProviderStrategy<Integer> getProviderStrategy()
{    return providerStrategy;}
0
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
0
public ServiceDiscovery<Integer> getServiceDiscovery()
{    return serviceDiscovery;}
0
public void marshallJson(ObjectNode node, String fieldName, Integer payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload.toString());    }}
0
public Integer unMarshallJson(JsonNode node) throws Exception
{    if (node != null) {        return Integer.parseInt(node.asText());    }    return null;}
0
public DiscoveryContext<Integer> getContext(Class<?> type)
{    return this;}
0
public ProviderStrategy<String> getProviderStrategy()
{    return providerStrategy;}
0
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
0
public ServiceDiscovery<String> getServiceDiscovery()
{    return serviceDiscovery;}
0
public void marshallJson(ObjectNode node, String fieldName, String payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload);    }}
0
public String unMarshallJson(JsonNode node) throws Exception
{    return (node != null) ? node.asText() : null;}
0
public DiscoveryContext<String> getContext(Class<?> type)
{    return this;}
0
 static ServiceInstance<T> readInstance(JsonNode node, DiscoveryContext<T> context) throws Exception
{    ServiceInstanceBuilder<T> builder = ServiceInstance.builder();    builder.name(node.get("name").asText());    builder.id(node.get("id").asText());    builder.address(node.get("address").asText());    builder.registrationTimeUTC(node.get("registrationTimeUTC").asLong());    builder.serviceType(ServiceType.valueOf(node.get("serviceType").asText()));    builder.payload(context.unMarshallJson(node.get("payload")));    Integer port = getInteger(node, "port");    Integer sslPort = getInteger(node, "sslPort");    if (port != null) {        builder.port(port);    }    if (sslPort != null) {        builder.sslPort(sslPort);    }    return builder.build();}
0
 static ObjectNode writeInstance(ObjectMapper mapper, ServiceInstance<T> instance, DiscoveryContext<T> context)
{    ObjectNode node = mapper.createObjectNode();    node.put("name", instance.getName());    node.put("id", instance.getId());    node.put("address", instance.getAddress());    putInteger(node, "port", instance.getPort());    putInteger(node, "sslPort", instance.getSslPort());    node.put("registrationTimeUTC", instance.getRegistrationTimeUTC());    node.put("serviceType", instance.getServiceType().name());    try {        context.marshallJson(node, "payload", instance.getPayload());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }    return node;}
0
private static Integer getInteger(JsonNode node, String fieldName)
{    JsonNode intNode = node.get(fieldName);    return (intNode != null) ? intNode.asInt() : null;}
0
private static void putInteger(ObjectNode node, String fieldName, Integer value)
{    if (value != null) {        node.put(fieldName, value);    }}
0
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
0
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstance.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
0
public long getSize(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
0
public ServiceInstance<T> readFrom(Class<ServiceInstance<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        ObjectMapper mapper = new ObjectMapper();        JsonNode node = mapper.reader().readTree(entityStream);        return readInstance(node, context);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
0
public void writeTo(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ObjectNode node = writeInstance(mapper, serviceInstance, context);    mapper.writer().writeValue(entityStream, node);}
0
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
0
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstances.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
0
public long getSize(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
0
public ServiceInstances<T> readFrom(Class<ServiceInstances<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        List<ServiceInstance<T>> instances = Lists.newArrayList();        ObjectMapper mapper = new ObjectMapper();        JsonNode tree = mapper.reader().readTree(entityStream);        for (int i = 0; i < tree.size(); ++i) {            JsonNode node = tree.get(i);            ServiceInstance<T> instance = JsonServiceInstanceMarshaller.readInstance(node, context);            instances.add(instance);        }        return new ServiceInstances<T>(instances);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
0
public void writeTo(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    List<? extends ServiceInstance<T>> instanceList = serviceInstances.getServices();    for (ServiceInstance<T> instance : instanceList) {        ObjectNode node = JsonServiceInstanceMarshaller.writeInstance(mapper, instance, context);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
0
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
0
public ServiceNames readFrom(Class<ServiceNames> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    List<String> names = Lists.newArrayList();    ObjectMapper mapper = new ObjectMapper();    JsonNode tree = mapper.reader().readTree(entityStream);    for (int i = 0; i < tree.size(); ++i) {        JsonNode node = tree.get(i);        names.add(node.get("name").asText());    }    return new ServiceNames(names);}
0
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
0
public long getSize(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
0
public void writeTo(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    for (String name : serviceNames.getNames()) {        ObjectNode node = mapper.createObjectNode();        node.put("name", name);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
0
private static boolean allow(Class<?> type, MediaType mediaType)
{    return ServiceNames.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
0
public List<ServiceInstance<T>> getServices()
{    return ImmutableList.copyOf(services);}
0
public List<String> getNames()
{    return ImmutableList.copyOf(names);}
0
public Response putService(ServiceInstance<T> instance, @PathParam("name") String name, @PathParam("id") String id)
{    if (!instance.getId().equals(id) || !instance.getName().equals(name)) {                return Response.status(Response.Status.BAD_REQUEST).build();    }    if (instance.getServiceType().isDynamic()) {                return Response.status(Response.Status.BAD_REQUEST).build();    }    try {        context.getServiceDiscovery().registerService(instance);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }    return Response.status(Response.Status.CREATED).build();}
1
public Response removeService(@PathParam("name") String name, @PathParam("id") String id)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance != null) {                        context.getServiceDiscovery().unregisterService(instance);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }    return Response.ok().build();}
1
public Response getDeprecated(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, true);}
0
public Response get(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, false);}
0
public Response getAllNames()
{    try {        List<String> instances = Lists.newArrayList(context.getServiceDiscovery().queryForNames());        Collections.sort(instances);        return Response.ok(new ServiceNames(instances)).build();    } catch (Exception e) {                return Response.serverError().build();    }}
1
public Response getAll(@PathParam("name") String name)
{    try {        Collection<ServiceInstance<T>> instances = context.getServiceDiscovery().queryForInstances(name);        return Response.ok(new ServiceInstances<T>(instances)).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
1
public Response getAny(@PathParam("name") String name)
{    try {        final List<ServiceInstance<T>> instances = Lists.newArrayList(context.getServiceDiscovery().queryForInstances(name));        ServiceInstance<?> randomInstance = context.getProviderStrategy().getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (randomInstance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        return Response.ok(randomInstance).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
1
public List<ServiceInstance<T>> getInstances() throws Exception
{    return instances;}
0
private Response internalGet(String name, String id, boolean addDeprecationHeader)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        Response.ResponseBuilder builder = Response.ok(instance);        if (addDeprecationHeader) {            builder = builder.header("Warning", "This API has been deprecated. Please see the updated spec for the replacement API.");        }        return builder.build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
1
public void start()
{    Preconditions.checkArgument(!service.isShutdown(), "already started");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, instanceRefreshMs, instanceRefreshMs, TimeUnit.MILLISECONDS);}
0
public void run()
{    doWork();}
0
public void close() throws IOException
{    Preconditions.checkArgument(!service.isShutdown(), "not started");    service.shutdownNow();}
0
private void doWork()
{    try {        for (String name : discovery.queryForNames()) {            checkService(name);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
1
private void checkService(String name)
{    try {        Collection<ServiceInstance<Object>> instances = discovery.queryForInstances(name);        for (ServiceInstance<Object> instance : instances) {            if (instance.getServiceType() == ServiceType.STATIC) {                if ((System.currentTimeMillis() - instance.getRegistrationTimeUTC()) > instanceRefreshMs) {                    discovery.unregisterService(instance);                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
1
public String getDescription()
{    return description;}
0
public void setDescription(String description)
{    this.description = description;}
0
public void setData(Map<String, String> data)
{    this.data = data;}
0
public Map<String, String> getData()
{    return data;}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((data == null) ? 0 : data.hashCode());    result = prime * result + ((description == null) ? 0 : description.hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ServiceDetails other = (ServiceDetails) obj;    if (data == null) {        if (other.data != null)            return false;    } else if (!data.equals(other.data))        return false;    if (description == null) {        if (other.description != null)            return false;    } else if (!description.equals(other.description))        return false;    return true;}
0
public void setup() throws Exception
{    context = new MapDiscoveryContext(new MockServiceDiscovery<Map<String, String>>(), new RandomStrategy<Map<String, String>>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<Map<String, String>>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<Map<String, String>>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(MapDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
0
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(MapDiscoveryResource.class);    return classes;}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void teardown() throws Exception
{    server.stop();    server.join();}
0
public void testRegisterService() throws Exception
{    Map<String, String> payload = Maps.newHashMap();    payload.put("one", "1");    payload.put("two", "2");    payload.put("three", "3");    ServiceInstance<Map<String, String>> service = ServiceInstance.<Map<String, String>>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<Map<String, String>>> type = new GenericType<ServiceInstances<Map<String, String>>>() {    };    ServiceInstances<Map<String, String>> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<Map<String, String>>> singleInstanceType = new GenericType<ServiceInstance<Map<String, String>>>() {    };    ServiceInstance<Map<String, String>> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void setup() throws Exception
{    context = new ServiceDetailsDiscoveryContext(new MockServiceDiscovery<ServiceDetails>(), new RandomStrategy<ServiceDetails>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<ServiceDetails>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<ServiceDetails>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(ServiceDetailsDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
0
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(ServiceDetailsDiscoveryResource.class);    return classes;}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void teardown() throws Exception
{    server.stop();    server.join();}
0
public void testRegisterService() throws Exception
{    ServiceDetails payload = new ServiceDetails();    payload.setDescription("Example description for test");    payload.getData().put("one", "1");    payload.getData().put("two", "2");    payload.getData().put("three", "3");    ServiceInstance<ServiceDetails> service = ServiceInstance.<ServiceDetails>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<ServiceDetails>> type = new GenericType<ServiceInstances<ServiceDetails>>() {    };    ServiceInstances<ServiceDetails> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<ServiceDetails>> singleInstanceType = new GenericType<ServiceInstance<ServiceDetails>>() {    };    ServiceInstance<ServiceDetails> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void setup() throws Exception
{    context = new StringDiscoveryContext(new MockServiceDiscovery<String>(), new RandomStrategy<String>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<String>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<String>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(StringDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
0
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void teardown() throws Exception
{    server.stop();    server.join();}
0
public void testRegisterService() throws Exception
{    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<String>> type = new GenericType<ServiceInstances<String>>() {    };    ServiceInstances<String> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        GenericType<ServiceInstance<String>> singleInstanceType = new GenericType<ServiceInstance<String>>() {    };    ServiceInstance<String> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public void testEmptyServiceNames()
{    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
0
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
0
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(singletonsRef.get().contextSingleton);    singletons.add(singletonsRef.get().serviceNamesMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstanceMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstancesMarshallerSingleton);    return singletons;}
0
private static DiscoveryContext<String> getContextFromProvider(Providers providers)
{    ContextResolver<DiscoveryContext> contextResolver = providers.getContextResolver(DiscoveryContext.class, MediaType.WILDCARD_TYPE);        return contextResolver.getContext(DiscoveryContext.class);}
0
public void setup() throws Exception
{    RestEasyApplication.singletonsRef.set(new RestEasySingletons());    ResteasyProviderFactory.setInstance(new ResteasyProviderFactory());    HttpServletDispatcher dispatcher = new HttpServletDispatcher();    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.getInitParams().put("javax.ws.rs.Application", RestEasyApplication.class.getName());    root.addServlet(new ServletHolder(dispatcher), "/*");    root.addEventListener(new ResteasyBootstrap());    server.start();}
0
public void teardown() throws Exception
{    server.stop();    server.join();}
0
public void testRegisterService() throws Exception
{    RestEasySingletons restEasySingletons = RestEasyApplication.singletonsRef.get();    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ByteArrayOutputStream out = new ByteArrayOutputStream();    restEasySingletons.serviceInstanceMarshallerSingleton.writeTo(service, null, null, null, null, null, out);    getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), new String(out.toByteArray()));    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = restEasySingletons.serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    json = getJson("http://localhost:" + port + "/v1/service/test", null);    ServiceInstances<String> instances = restEasySingletons.serviceInstancesMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        json = getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), null);    ServiceInstance<String> instance = restEasySingletons.serviceInstanceMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instance, service);}
0
public void testEmptyServiceNames() throws Exception
{    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = RestEasyApplication.singletonsRef.get().serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
0
private String getJson(String urlStr, String body) throws IOException
{    URL url = new URL(urlStr);    URLConnection urlConnection = url.openConnection();    urlConnection.addRequestProperty("Accept", "application/json");    if (body != null) {        ((HttpURLConnection) urlConnection).setRequestMethod("PUT");        urlConnection.addRequestProperty("Content-Type", "application/json");        urlConnection.addRequestProperty("Content-Length", Integer.toString(body.length()));        urlConnection.setDoOutput(true);        OutputStream out = urlConnection.getOutputStream();        ByteSource.wrap(body.getBytes()).copyTo(out);    }    BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));    try {        return CharStreams.toString(in);    } finally {        in.close();    }}
0
public Collection<ServiceInstance<T>> get()
{    return Lists.newArrayList();}
0
public void start() throws Exception
{}
0
public void registerService(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
0
public void unregisterService(ServiceInstance<T> service) throws Exception
{    services.remove(service.getName(), service);}
0
public void updateService(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
0
public ServiceCacheBuilder<T> serviceCacheBuilder()
{    throw new UnsupportedOperationException();}
0
public Collection<String> queryForNames() throws Exception
{    return services.keys();}
0
public Collection<ServiceInstance<T>> queryForInstances(String name) throws Exception
{    return services.get(name);}
0
public ServiceInstance<T> queryForInstance(String name, String id) throws Exception
{    Collection<ServiceInstance<T>> instances = services.get(name);    for (ServiceInstance<T> instance : instances) {        if (instance.getId().equals(id)) {            return instance;        }    }    return null;}
0
public ServiceProviderBuilder<T> serviceProviderBuilder()
{    throw new UnsupportedOperationException();}
0
public void close() throws IOException
{}
0
