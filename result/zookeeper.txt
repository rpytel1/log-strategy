f3f6682ec0c024bc876a0336decef1e4660be4277669497e90013df6b8ecfe95
main
public static void main(String[] args) throws IOException, ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException
{    InputStream is = FatJarMain.class.getResourceAsStream("/mainClasses");    if (is == null) {        System.err.println("Couldn't find /mainClasses in classpath.");        System.exit(3);    }    BufferedReader br = new BufferedReader(new InputStreamReader(is));    String line;    while ((line = br.readLine()) != null) {        String[] parts = line.split(":", 3);        if (parts.length != 3 || (parts[0].length() > 0 && parts[0].charAt(0) == '#')) {            continue;        }        if (parts[0].length() > 0) {            cmds.put(parts[0], new Cmd(parts[0], parts[1], parts[2]));                                    order.add(parts[0]);        } else {                        order.add(parts[2]);        }    }    if (args.length == 0) {        doHelp();        return;    }    Cmd cmd = cmds.get(args[0]);    if (cmd == null) {        doHelp();        return;    }    Class<?> clazz = Class.forName(cmd.clazz);    Method main = clazz.getMethod("main", String[].class);    String[] newArgs = new String[args.length - 1];    System.arraycopy(args, 1, newArgs, 0, newArgs.length);    try {        main.invoke(null, (Object) newArgs);    } catch (InvocationTargetException e) {        if (e.getCause() != null) {            e.getCause().printStackTrace();        } else {            e.printStackTrace();        }    }}
81c6b0aeeef789b138b9c828b10756dc0e1d10c34ff159f101ff6f16600570f2
doHelp
private static void doHelp()
{    System.err.println("USAGE: FatJarMain cmd args");    System.err.println("Available cmds:");    for (String c : order) {        Cmd cmd = cmds.get(c);        if (cmd != null) {            System.err.println("  " + c + " " + cmd.desc);        } else {            System.err.println(c);        }    }    System.exit(2);}
f412298470eab56428c17f4fdd8e119c61abd6c626fb3f7f27e99f86752b8f7f
newOp
public static FilterOp newOp(String op) throws FilterException
{    if (op.equals("or"))        return new OrOp();    if (op.equals("and"))        return new AndOp();    if (op.equals("not"))        return new NotOp();    if (op.equals("xor"))        return new XorOp();    if (op.equals("="))        return new EqualsOp();    if (op.equals("<"))        return new LessThanOp();    if (op.equals(">"))        return new GreaterThanOp();    throw new FilterException("Invalid operation '" + op + "'");}
a2a3b2a1dfd9f9f4df348f9a418092f832e823aeb1b7166eb927f97e8b06aeb0
addSubOp
public void addSubOp(FilterOp op)
{    subOps.add(op);}
264bca02631d3afdde156aed4158d010222a75ca9fcfa5d6869c4a864f0ed686
addArg
public void addArg(Arg arg)
{    args.add(arg);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String op = "(" + getClass().getName();    for (FilterOp f : subOps) {        op += " " + f;    }    for (Arg a : args) {        op += " " + a;    }    return op + ")";}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (!f.matches(entry)) {            return false;        }    }    return true;}
f2675839f6a3be987f9e699930d6adff42e4c49fd3b1aebe0c2f5e594fdd199e
getType
public ArgType getType()
{    return type;}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "[" + type + ":" + value + "]";}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    Object last = null;    for (Arg a : args) {        Object v = a.getValue();        if (a.getType() == FilterOp.ArgType.SYMBOL) {            String key = (String) a.getValue();            v = entry.getAttribute(key);        }        if (last != null && !last.equals(v)) {            return false;        }        last = v;    }    return true;}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) <= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                                        if (((Number) last).longValue() <= ((Number) v).longValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) >= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                    if (((Number) last).doubleValue() >= ((Number) v).doubleValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    if (subOps.size() != 1) {        throw new FilterException("Not operation can only take one argument");    }    return !subOps.get(0).matches(entry);}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (f.matches(entry)) {            return true;        }    }    return false;}
3021cfc708166f82471e2847428f56e9137f485b6a60d710bb076307b18c932a
matches
public boolean matches(LogEntry entry) throws FilterException
{    int count = 0;    for (FilterOp f : subOps) {        if (f.matches(entry)) {            count++;            if (count > 1) {                return false;            }        }    }    if (count == 1) {        return true;    }    return false;}
823bbd5b396e15470cececdadc416614887393c1906554519380ab110b400819
readUntilSpace
private String readUntilSpace() throws IOException
{    StringBuffer buffer = new StringBuffer();    int c = reader.read();    while (!Character.isWhitespace(c) && c != ')' && c != '(') {        buffer.append((char) c);        c = reader.read();        if (c == -1) {            break;        }    }    reader.unread(c);    return buffer.toString().trim();}
9a2591016eb5a7d2b31274461478297367ab1a94dbc739c32b228954a5948d01
readStringArg
private StringArg readStringArg() throws IOException, FilterException
{    int c = reader.read();    int last = 0;    if (c != '"') {        throw new FilterException("Check the parser, trying to read a string that doesn't begin with quotes");    }    StringBuffer buffer = new StringBuffer();    while (reader.ready()) {        last = c;        c = reader.read();        if (c == -1) {            break;        }        if (c == '"' && last != '\\') {            return new StringArg(buffer.toString());        } else {            buffer.append((char) c);        }    }    throw new FilterException("Unterminated string");}
bfe68b53c87e497e66567e7843996eaebef90d791b1cac1e15886055ca89394e
readNumberArg
private NumberArg readNumberArg() throws IOException, FilterException
{    String strval = readUntilSpace();    try {        if (strval.startsWith("0x")) {            return new NumberArg(Long.valueOf(strval.substring(2), 16));        } else {            return new NumberArg(Long.valueOf(strval));        }    } catch (NumberFormatException e) {        throw new FilterException("Not a number [" + strval + "]\n" + e);    }}
96c3b7b7a072e51827b3bb5ecf11ac0c6bd54e377e2f26f703ad35c2ddf16667
readSymbolArg
private SymbolArg readSymbolArg() throws IOException, FilterException
{    return new SymbolArg(readUntilSpace());}
06a4a9916b9bae1e38622d5e948b07308bf9f20b4733a0325513f7f19a94aeb7
parse
public FilterOp parse() throws IOException, FilterException
{    int c = reader.read();    if (c != '(') {        throw new FilterException("Invalid format");    }    String opstr = readUntilSpace();    FilterOp op = FilterOp.newOp(opstr);    while (reader.ready()) {        c = reader.read();        if (c == -1) {            break;        }        if (c == '(') {            reader.unread(c);            op.addSubOp(parse());        } else if (c == ')') {            return op;        } else if (c == '"') {            reader.unread(c);            op.addArg(readStringArg());        } else if (Character.isDigit(c) || c == '-' || c == '+') {            reader.unread(c);            op.addArg(readNumberArg());        } else if (Character.isJavaIdentifierStart(c)) {            reader.unread(c);            op.addArg(readSymbolArg());        }    }    throw new FilterException("Incomplete filter");}
8e560df2397e28f7c9aa2e1abe22f8c88a6848fb0c5c77e6913052346b227569
main
public static void main(String[] args) throws IOException, FilterException
{    if (args.length == 1) {        System.out.println(new FilterParser(args[0]).parse());    } else {        System.out.println(new FilterParser("(or (and (= session foobar) (= session barfoo)) (= session sdfs))").parse());    }}
a3748c119d96fa294823e8583effc29f34cc738b363e3edf8d11aed755ac1d34
equals
public boolean equals(Message m)
{    return (m.from == this.from && m.to == this.to && m.zxid == this.zxid);}
ab820d7d178ef7735a08cc8b4a68c7652ff7f4ab285573e25b5a7d356b9b524c
txnEntry
public JSONObject txnEntry(TransactionEntry e)
{    JSONObject event = new JSONObject();    event.put("time", Long.toString(e.getTimestamp()));    event.put("client", Long.toHexString(e.getClientId()));    event.put("cxid", Long.toHexString(e.getCxid()));    event.put("zxid", Long.toHexString(e.getZxid()));    event.put("op", e.getOp());    event.put("extra", e.getExtra());    event.put("type", "transaction");    return event;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return JSONValue.toJSONString(root);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    MergedLogSource src = new MergedLogSource(args);    LogIterator iter = src.iterator();    System.out.println(new JsonGenerator(iter));}
47240d948c610c85f5a6df2f7364890c8d8c0bf0c03081f8407136b376bae662
getEntry
public String getEntry()
{    return (String) getAttribute("log-text");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "" + getTimestamp() + "::::" + getNode() + "::::" + getEntry();}
7894c60ba761d81ad215df859196915a5f04072cabc72abb913fba7eb21dae01
getNode
public int getNode()
{    return (Integer) getAttribute("node");}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return LogEntry.Type.LOG4J;}
a83e311d319a6a2a96bfc123a4462082076988494bd15e02510c3bfd15e20e06
overlapsRange
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return size;}
afc2d9d29525357dc0a8793ba8a0adf0e8de8c4687915bde8bfb32988722ba0c
getStartTime
public long getStartTime()
{    return starttime;}
245e25a7653bf870b0cb02144099f191f27e8ab0d18d659e65998d30ba1b1d79
getEndTime
public long getEndTime()
{    return endtime;}
b7dcb62bcf613089c02d6ddfa83c2db3a9dbd499af234c9cb25f45898a0ac231
getSkipList
public LogSkipList getSkipList()
{    return skiplist;}
36075ead2a2eba31c6b716399bc644a7ea8708e8c01bdbb33ebd9d62da973c87
size
public synchronized long size() throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("size() called");    }    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = in.getPosition();    if (LOG.isTraceEnabled()) {        LOG.trace("saved pos () = " + pos);    }    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    in.seek(lastseg.getBytes());        buf = "";        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (LOG.isTraceEnabled()) {                }        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    in.seek(pos);    buf = "";    if (LOG.isTraceEnabled()) {        LOG.trace("size() = " + count);    }    return count;}
5a6a602c012fb146e3dde06ab39a522f5b6281bb8b53496714a4dc626603ffc8
readNextEntry
private synchronized LogEntry readNextEntry()
{    try {        try {            while (true) {                String line = in.readLine();                if (line == null) {                    break;                }                Matcher m = src.timep.matcher(line);                if (m.lookingAt()) {                    if (buf.length() > 0) {                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);                        buf = line;                        return e;                    }                    buf = line;                } else if (buf.length() > 0) {                    buf += line + "\n";                }            }        } catch (EOFException eof) {                }        if (buf.length() > 0) {            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);            buf = "";            return e;        }    } catch (Exception e) {        LOG.error("Error reading next entry in file (" + src.file + "): " + e);        return null;    }    return null;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return next != null;}
587a94e78dc8d43a1cdb9b36a67a4d77777fb524fea671bd5e859ae375686323
next
public LogEntry next() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(e.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
f893c4aca844d22c972e9ae8a2cde9eb4a5b553bae808938e884fe0ce517bb9e
remove
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for L4J logs");}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String size;    try {        size = new Long(size()).toString();    } catch (IOException ioe) {        size = "Unable to read";    }    return "Log4JSourceIterator(start=" + starttime + ", end=" + endtime + ", size=" + size + ")";}
56550d86759d5497e46aeadc25e366a4e86eebccad7504a0a7b8700355df08ca
iterator
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
4b0e489d7a367bb7362af10936a4ab89313eebd953f8f5c7aeb7bb3e620eaa9c
iterator
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new Log4JSourceIterator(this, starttime, endtime, filter);}
d444843f3d30cbda87336b977a07f1c888933512e50e8dec86e286d40e31438d
iterator
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
aa227d43ec25d0b7776428f773f5e61fe1420bbb4644224eb34367f2cce61a14
timestampFromText
private static long timestampFromText(SimpleDateFormat format, String s)
{    Date d = null;    try {        d = format.parse(s);    } catch (ParseException e) {        return 0;    }    Calendar c = new GregorianCalendar();    c.setTime(d);    return c.getTimeInMillis();}
7b52debc63135d2337f4dadf2915b3e1dfdd7fca2b0022da881119e517cbf00c
init
private void init() throws IOException
{    File f = new File(file);    RandomAccessFileReader in = new RandomAccessFileReader(f);    SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);    Pattern idp = Pattern.compile("\\[myid:(\\d+)\\]");    long lastFp = in.getPosition();    String line = in.readLine();    Matcher m = null;        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {        starttime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. First line doesn't start with time");    }    /*	  Count number of log entries. Any line starting with a timestamp counts as an entry	*/    String lastentry = line;    try {        while (line != null) {            m = timep.matcher(line);            if (m.lookingAt()) {                if (size % skipN == 0) {                    long time = timestampFromText(dateformat, m.group(1));                    skiplist.addMark(time, lastFp, size);                }                size++;                lastentry = line;            }            if (serverid == 0 && (m = idp.matcher(line)).find()) {                serverid = Integer.valueOf(m.group(1));            }            lastFp = in.getPosition();            line = in.readLine();        }    } catch (EOFException eof) {        } finally {        in.close();    }    m = timep.matcher(lastentry);    if (m.lookingAt()) {        endtime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. Last line doesn't start with time");    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Log4JSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ", id=" + serverid + ")";}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    final Log4JSource s = new Log4JSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        final long starttime = Long.valueOf(args[1]);        final long endtime = Long.valueOf(args[2]);        iter = s.iterator(starttime, endtime);        Thread t1 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t2 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t3 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);            }        };        t1.start();        t2.start();        } else {        iter = s.iterator();    }    /*while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);}
f2db77df2a60720035a8211d757d0443bdc24bdc61d9a64a8dc597a0396302b7
getServerId
public int getServerId()
{    return serverid;}
efd4f04d2f7438e26699863148fedf2a1756ec4f9ea70d9d64b80b1bdb63169b
getTimestamp
public long getTimestamp()
{    return (Long) getAttribute("timestamp");}
3671bdbe9316a22d486ae38daee5d15605833e4177cf55bb5b087cdd2a275083
setAttribute
public void setAttribute(String key, Object v)
{    attributes.put(key, v);}
766b8ae0aab527339fe471dcf292d2e78f74666fe6fa54feae54d7c20ebcfddd
getAttribute
public Object getAttribute(String key)
{    return attributes.get(key);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    try {        MergedLogSource src = new MergedLogSource(args);        System.out.println(src);        Server server = new Server(8182);        server.setHandler(new LogServer(src));        server.start();        server.join();    } catch (Exception e) {                e.printStackTrace();    }}
e908edc1322f03e7ca2dd841fb14f8c24df7b4eaa009531591d695d31b6fe131
getTime
public long getTime()
{    return this.time;}
d76f2a28457ae5f0f402725b61a4d97e33efca7db9cd57dc63c19e0e302ac7d7
getBytes
public long getBytes()
{    return this.bytes;}
c7385f993cb8dd2a3a2fa9b46d09cd5f6ff6401794feeef8077e8ec1a3a08d77
getEntriesSkipped
public long getEntriesSkipped()
{    return this.skipped;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Mark(time=" + time + ", bytes=" + bytes + ", skipped=" + skipped + ")";}
cec0ce4fdd1642c13bae2501001e1c3dda9a46f12496140dbd8eedd09daec3a0
addMark
public void addMark(long time, long bytes, long skipped)
{    if (LOG.isTraceEnabled()) {        LOG.trace("addMark (time:" + time + ", bytes: " + bytes + ", skipped: " + skipped + ")");    }    marks.add(new Mark(time, bytes, skipped));}
a3fc576e91fa9b93ade4672f247ed4b598c1b45654d3c95e37611bf87d9ef65a
findMarkBefore
public Mark findMarkBefore(long time) throws NoSuchElementException
{    if (LOG.isTraceEnabled()) {        LOG.trace("findMarkBefore(" + time + ")");    }    Mark last = marks.getFirst();    for (Mark m : marks) {        if (m.getTime() > time) {            break;        }        last = m;    }    if (LOG.isTraceEnabled()) {        LOG.trace("return " + last);    }    return last;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    MergedLogSource source = new MergedLogSource(args);    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-ms.out")));    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-sec.out")));    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-min.out")));    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-hour.out")));    LogIterator iter;    System.out.println(source);    iter = source.iterator();    long currentms = 0;    long currentsec = 0;    long currentmin = 0;    long currenthour = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxid_sec = 0;    long zxid_min = 0;    long zxid_hour = 0;    while (iter.hasNext()) {        LogEntry e = iter.next();        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long sec = ms / MS_PER_SEC;        long min = ms / MS_PER_MIN;        long hour = ms / MS_PER_HOUR;        if (currentms != ms && currentms != 0) {            ps_ms.println("" + currentms + " " + zxids_ms.size());            zxid_sec += zxids_ms.size();            zxid_min += zxids_ms.size();            zxid_hour += zxids_ms.size();            zxids_ms.clear();        }        if (currentsec != sec && currentsec != 0) {            ps_sec.println("" + currentsec * MS_PER_SEC + " " + zxid_sec);            zxid_sec = 0;        }        if (currentmin != min && currentmin != 0) {            ps_min.println("" + currentmin * MS_PER_MIN + " " + zxid_min);            zxid_min = 0;        }        if (currenthour != hour && currenthour != 0) {            ps_hour.println("" + currenthour * MS_PER_HOUR + " " + zxid_hour);            zxid_hour = 0;        }        currentms = ms;        currentsec = sec;        currentmin = min;        currenthour = hour;        zxids_ms.add(cxn.getZxid());    }    iter.close();    ps_ms.close();    ps_sec.close();    ps_min.close();    ps_hour.close();}
a83e311d319a6a2a96bfc123a4462082076988494bd15e02510c3bfd15e20e06
overlapsRange
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return size;}
afc2d9d29525357dc0a8793ba8a0adf0e8de8c4687915bde8bfb32988722ba0c
getStartTime
public long getStartTime()
{    return starttime;}
245e25a7653bf870b0cb02144099f191f27e8ab0d18d659e65998d30ba1b1d79
getEndTime
public long getEndTime()
{    return endtime;}
89e0335520973d3c0da416736789cc447e615057aa21eac4334d8cf7cd1f2ff2
size
public long size() throws IOException
{    long size = 0;    for (LogIterator i : sources) {        size += i.size();    }    return size;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    for (LogEntry n : nexts) {        if (n != null)            return true;    }    return false;}
ee5d9b2908828c18d91e5b2e28323a1dfac34de8b92a1adfa87e4933cb9c9796
next
public LogEntry next()
{    int min = -1;    for (int i = 0; i < nexts.length; i++) {        if (nexts[i] != null) {            if (min == -1) {                min = i;            } else if (nexts[i].getTimestamp() < nexts[min].getTimestamp()) {                min = i;            }        }    }    if (min == -1) {        return null;    } else {        LogEntry e = nexts[min];        nexts[min] = sources[min].next();        return e;    }}
f893c4aca844d22c972e9ae8a2cde9eb4a5b553bae808938e884fe0ce517bb9e
remove
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Merged logs");}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    for (LogIterator i : sources) {        i.close();    }}
56550d86759d5497e46aeadc25e366a4e86eebccad7504a0a7b8700355df08ca
iterator
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
4b0e489d7a367bb7362af10936a4ab89313eebd953f8f5c7aeb7bb3e620eaa9c
iterator
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new MergedLogSourceIterator(this, starttime, endtime, filter);}
d444843f3d30cbda87336b977a07f1c888933512e50e8dec86e286d40e31438d
iterator
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
dde12346d04dde53ced76cc700cbf6eb92e795d12971ab931cf08720da1b8f35
addSource
public void addSource(String f) throws IOException
{    LogSource s = null;    if (TxnLogSource.isTransactionFile(f)) {        s = new TxnLogSource(f);    } else {        s = new Log4JSource(f);    }    size += s.size();    endtime = s.getEndTime() > endtime ? s.getEndTime() : endtime;    starttime = s.getStartTime() < starttime || starttime == 0 ? s.getStartTime() : starttime;    sources.add(s);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String s = "MergedLogSource(size=" + size + ", start=" + starttime + ", end=" + endtime + ")";    for (LogSource src : sources) {        s += "\n\t- " + src;    }    return s;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    System.out.println("Time: " + System.currentTimeMillis());    MergedLogSource s = new MergedLogSource(args);    System.out.println(s);    LogIterator iter;    iter = s.iterator();    System.out.println("Time: " + System.currentTimeMillis());    System.out.println("Iterator Size: " + iter.size());    System.out.println("Time: " + System.currentTimeMillis());    /*	while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();    System.out.println("Time: " + System.currentTimeMillis());}
d20693e778172b0c180ba59ee2799036fbd7f5aa3d1ed6ae47b98eed2e2c9bc4
fill
private int fill() throws IOException
{    fileoffset = fp;    int read = file.read(buffer, 0, buffer.length);    if (LOG.isDebugEnabled()) {        String buf = new String(buffer, 0, 40, "UTF-8");        LOG.debug("fill(buffer=" + buf + ")");    }    if (read == -1) {                buffersize = 0;    } else {        buffersize = read;    }    fp += buffersize;    bufferoffset = 0;    return buffersize;}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return false;}
f4eafade6688cc74b1bfb7bdb84031604ecee7ee13617b9b3951aae782e21b9d
read
public synchronized int read(char[] cbuf, int off, int len) throws IOException
{        byte[] b = new byte[2];    int bytesread = 0;    while (len > 0) {        int read = read(b, 0, 2);        bytesread += read;        if (read < 2) {            return bytesread;        }        cbuf[off] = (char) ((b[0] << 8) | (b[1] & 0xff));        off += read;        len -= read;    }    return bytesread;}
a0ee51b9b364a6f06704b513d87c4f19a93a1811bcca6fc81ed328c6b269ff6a
read
public synchronized int read(byte[] buf, int off, int len) throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("read(buf, off=" + off + ", len=" + len);    }    int read = 0;    while (len > 0) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        int tocopy = Math.min(len, buffersize);        if (LOG.isTraceEnabled()) {            LOG.trace("tocopy=" + tocopy);        }        System.arraycopy(buffer, bufferoffset, buf, off, tocopy);        buffersize -= tocopy;        bufferoffset += tocopy;        len -= tocopy;        read += tocopy;        off += tocopy;    }    if (LOG.isTraceEnabled()) {        LOG.trace("read=" + read);    }    return read;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    file.close();}
440295a41d4e3cef67a12523813a1969b46946ef4ce8d8b8b75a27bceedd007b
getPosition
public long getPosition()
{    return bufferoffset + fileoffset;}
c346e5e4ea6aea8d801439a244675c860507e4c259208ee6c50b91aaab3363e7
seek
public synchronized void seek(long pos) throws IOException
{    if (LOG.isDebugEnabled()) {        LOG.debug("seek(" + pos + ")");    }    file.seek(pos);    fp = pos;        buffersize = 0;}
550e69c1abc47d51f4a038807f9c914a844f33c06bbca5ff0795c672047cebbe
readLine
public synchronized String readLine() throws IOException
{    StringBuffer s = null;        buffering: for (; ; ) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        for (int i = 0; i < buffersize; i++) {            if (buffer[bufferoffset + i] == '\n') {                if (i > 0) {                                        if (s == null) {                        s = new StringBuffer();                    }                    s.append(new String(buffer, bufferoffset, i, "UTF-8"));                }                bufferoffset += i + 1;                buffersize -= i + 1;                break buffering;            }        }                if (s == null) {            s = new StringBuffer();        }        s.append(new String(buffer, bufferoffset, buffersize, "UTF-8"));        buffersize = 0;    }    if (s == null) {        return null;    } else {        return s.toString();    }}
461ee979b83ab48c31ff692513597472d6b2b18e8c0ad485b95eabca1fa258fc
readFully
public void readFully(byte[] b) throws IOException
{    readFully(b, 0, b.length);}
c8e484efd11a9cddbcb421571583b50c283bd43e0f219fb874164f9de019df72
readFully
public void readFully(byte[] b, int off, int len) throws IOException
{    while (len > 0) {        int read = read(b, off, len);        len -= read;        off += read;        if (read == 0) {            throw new EOFException("End of file reached");        }    }}
8126f4840ff375c8d01a0d3ca9d01334372282588f45f32ff0cc58041ca9bdf1
skipBytes
public int skipBytes(int n) throws IOException
{    seek(getPosition() + n);    return n;}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{    return (readByte() != 0);}
74e30266fb5248026c385de9cf27411ad252eb1f24bb206a7e43f479960d907b
readByte
public byte readByte() throws IOException
{    byte[] b = new byte[1];    readFully(b, 0, 1);    return b[0];}
11fd0a8c2e174d5552a7020de870c7fc56d7a1cdcf041eac88a42c0fa25a1b99
readUnsignedByte
public int readUnsignedByte() throws IOException
{    return (int) readByte();}
371e65cc0cfa669ccfb7cafba41bf724a24cd6b83a559e6d534a5bb092f0e4fb
readShort
public short readShort() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (short) ((b[0] << 8) | (b[1] & 0xff));}
737523a96551e5eaca3103104866b32baac693c5c06ac109739db14abff4997b
readUnsignedShort
public int readUnsignedShort() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (((b[0] & 0xff) << 8) | (b[1] & 0xff));}
327b98f7be5087ab08b9d6f10246f4c488356ab008fbe853a67b343be55b9863
readChar
public char readChar() throws IOException
{    return (char) readShort();}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    byte[] b = new byte[4];    readFully(b, 0, 4);    return (((b[0] & 0xff) << 24) | ((b[1] & 0xff) << 16) | ((b[2] & 0xff) << 8) | (b[3] & 0xff));}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    byte[] b = new byte[8];    readFully(b, 0, 8);    return (((long) (b[0] & 0xff) << 56) | ((long) (b[1] & 0xff) << 48) | ((long) (b[2] & 0xff) << 40) | ((long) (b[3] & 0xff) << 32) | ((long) (b[4] & 0xff) << 24) | ((long) (b[5] & 0xff) << 16) | ((long) (b[6] & 0xff) << 8) | ((long) (b[7] & 0xff)));}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    return Float.intBitsToFloat(readInt());}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    return Double.longBitsToDouble(readLong());}
9ed8510b85fc57c09691897769e4f664a20cf7ca2f957229b6d31f10210f7001
readUTF
public String readUTF() throws IOException
{    int len = readUnsignedShort();    byte[] bytes = new byte[len + 2];    bytes[0] = (byte) ((len >> 8) & 0xFF);    bytes[1] = (byte) (len & 0xFF);    readFully(bytes, 2, len);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));    return dis.readUTF();}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));    long pos0 = f.getPosition();    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    long pos1 = f.getPosition();    System.out.println("pos: " + pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos0);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    long pos2 = f.getPosition();    System.out.println("=============");    System.out.println(f.readLine());    f.seek(pos2);    System.out.println(f.readLine());    f.close();}
e82c4c59952f6193f5babb3a58f1d23d165dc2538527527f27e6e69c9662ab47
handleRequest
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    String file = request.getString("path", "/");    JSONObject o = new JSONObject();    try {        this.source.addSource(file);        o.put("status", "OK");    } catch (Exception e) {        o.put("status", "ERR");        o.put("error", e.toString());    }    return JSONValue.toJSONString(o);}
e82c4c59952f6193f5babb3a58f1d23d165dc2538527527f27e6e69c9662ab47
handleRequest
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    JSONArray filelist = new JSONArray();    File base = new File(request.getString("path", "/"));    if (!base.exists() || !base.isDirectory()) {        throw new FileNotFoundException("Couldn't find [" + request + "]");    }    File[] files = base.listFiles();    Arrays.sort(files, new Comparator<File>() {        public int compare(File o1, File o2) {            if (o1.isDirectory() != o2.isDirectory()) {                if (o1.isDirectory()) {                    return -1;                } else {                    return 1;                }            }            return o1.getName().compareToIgnoreCase(o2.getName());        }    });    for (File f : files) {        JSONObject o = new JSONObject();        o.put("file", f.getName());        o.put("type", f.isDirectory() ? "D" : "F");        o.put("path", f.getCanonicalPath());        filelist.add(o);    }    return JSONValue.toJSONString(filelist);}
6839c12feb29f4c058a4da429666bc9c963be53674393df89ab6de5e2d15ad6b
compare
public int compare(File o1, File o2)
{    if (o1.isDirectory() != o2.isDirectory()) {        if (o1.isDirectory()) {            return -1;        } else {            return 1;        }    }    return o1.getName().compareToIgnoreCase(o2.getName());}
e82c4c59952f6193f5babb3a58f1d23d165dc2538527527f27e6e69c9662ab47
handleRequest
 String handleRequest(JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    FilterOp fo = null;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    String filterstr = request.getString("filter", "");    if (filterstr.length() > 0) {        fo = new FilterParser(filterstr).parse();    }    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = starttime + DEFAULT_PERIOD;        }    }    if (LOG.isDebugEnabled()) {        LOG.debug("handle(start= " + starttime + ", end=" + endtime + ", period=" + period + ")");    }    LogIterator iterator = (fo != null) ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);    return new JsonGenerator(iterator).toString();}
10ab05a75687b3a0b1de518d96d113f9c3eb2c5a2126175f7d0dffff4ec6c9c4
getNumber
public long getNumber(String name, long defaultnum)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultnum;    }    try {        return Long.valueOf(vals[0]);    } catch (NumberFormatException e) {        return defaultnum;    }}
d88054921d906401a2aa9fdbe7d0d67c472b3d04df7355aedacea25c2d040dac
getString
public String getString(String name, String defaultstr)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultstr;    } else {        return vals[0];    }}
5a0fc5243f26938427ca93c0ceddb95da8d9092a44dc54454178170f1d780dbe
doGet
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    response.setContentType("text/plain;charset=utf-8");    response.setStatus(HttpServletResponse.SC_OK);    try {        String req = request.getRequestURI().substring(request.getServletPath().length());        response.getWriter().println(handleRequest(new JsonRequest(request)));    } catch (Exception e) {        JSONObject o = new JSONObject();        o.put("error", e.toString());        response.getWriter().println(JSONValue.toJSONString(o));    } catch (java.lang.OutOfMemoryError oom) {        JSONObject o = new JSONObject();        o.put("error", "Out of memory. Perhaps you've requested too many logs. Try narrowing you're filter criteria.");        response.getWriter().println(JSONValue.toJSONString(o));    }}
e82c4c59952f6193f5babb3a58f1d23d165dc2538527527f27e6e69c9662ab47
handleRequest
 String handleRequest(JsonRequest request) throws Exception
{    String output = "";    long starttime = 0;    long endtime = 0;    long period = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    LogIterator iter = source.iterator(starttime, endtime);    JSONObject data = new JSONObject();    data.put("startTime", starttime);    data.put("endTime", endtime);    long size = 0;    size = iter.size();    data.put("numEntries", size);    if (LOG.isDebugEnabled()) {        LOG.debug("handle(start= " + starttime + ", end=" + endtime + ", numEntries=" + size + ")");    }    iter.close();    return JSONValue.toJSONString(data);}
5a0fc5243f26938427ca93c0ceddb95da8d9092a44dc54454178170f1d780dbe
doGet
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    String path = request.getRequestURI().substring(request.getServletPath().length());    InputStream resource = ClassLoader.getSystemResourceAsStream("org/apache/zookeeper/graph/resources" + path);    if (resource == null) {        response.getWriter().println(path + " not found!");        response.setStatus(HttpServletResponse.SC_NOT_FOUND);        return;    }    try {        while (resource.available() > 0) {            response.getWriter().write(resource.read());        }    } finally {        resource.close();    }        response.setStatus(HttpServletResponse.SC_OK);}
c18e05188a3b7dd2fafae6431ef2c07cd8cb9df0d7d8361085d5f09eb51a3d90
handleRequest
public String handleRequest(JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    long scale = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    String scalestr = request.getString("scale", "minutes");    if (scalestr.equals("seconds")) {        scale = MS_PER_SEC;    } else if (scalestr.equals("hours")) {        scale = MS_PER_HOUR;    } else {        scale = MS_PER_MIN;    }    LogIterator iter = source.iterator(starttime, endtime);    long current = 0;    long currentms = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxidcount = 0;    JSONArray events = new JSONArray();    while (iter.hasNext()) {        LogEntry e = iter.next();        if (e.getType() != LogEntry.Type.TXN) {            continue;        }        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long inscale = ms / scale;        if (currentms != ms && currentms != 0) {            zxidcount += zxids_ms.size();            zxids_ms.clear();        }        if (inscale != current && current != 0) {            JSONObject o = new JSONObject();            o.put("time", current * scale);            o.put("count", zxidcount);            events.add(o);            zxidcount = 0;        }        current = inscale;        currentms = ms;        zxids_ms.add(cxn.getZxid());    }    JSONObject o = new JSONObject();    o.put("time", current * scale);    o.put("count", zxidcount);    events.add(o);    iter.close();    return JSONValue.toJSONString(events);}
7727503a357d854a531790212a0c08e860d4e48f4810b7dfba16555b3bf09b4b
getClientId
public long getClientId()
{    return (Long) getAttribute("client-id");}
e5391bb0d4d61de83284aee5440016d69c1257f89ff90717c763e6fd132bf02d
getCxid
public long getCxid()
{    return (Long) getAttribute("cxid");}
801e4e9de7001eb2aab4d5e974b3815294de7fb0baf148bdf44fffbf5d770188
getZxid
public long getZxid()
{    return (Long) getAttribute("zxid");}
2bee2e1e45615685a9d9aef903b89c5ce2cdbd34d846bd8979617266a2311ac4
getOp
public String getOp()
{    return (String) getAttribute("operation");}
07c559cb5bde54cfe4e9ea0c6dac46907efcaffd48ff2e2871c98727f1aa6b78
getExtra
public String getExtra()
{    return (String) getAttribute("extra");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getTimestamp() + ":::session(0x" + Long.toHexString(getClientId()) + ") cxid(0x" + Long.toHexString(getCxid()) + ") zxid(0x" + Long.toHexString(getZxid()) + ") op(" + getOp() + ") extra(" + getExtra() + ")";}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return LogEntry.Type.TXN;}
a83e311d319a6a2a96bfc123a4462082076988494bd15e02510c3bfd15e20e06
overlapsRange
public boolean overlapsRange(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return size;}
afc2d9d29525357dc0a8793ba8a0adf0e8de8c4687915bde8bfb32988722ba0c
getStartTime
public long getStartTime()
{    return starttime;}
245e25a7653bf870b0cb02144099f191f27e8ab0d18d659e65998d30ba1b1d79
getEndTime
public long getEndTime()
{    return endtime;}
b7dcb62bcf613089c02d6ddfa83c2db3a9dbd499af234c9cb25f45898a0ac231
getSkipList
public LogSkipList getSkipList()
{    return skiplist;}
6ed6d9bf1461cf64ba199305ca0784478620fe0c59dbe5b87336fe602b6370ae
isTransactionFile
public static boolean isTransactionFile(String file) throws IOException
{    RandomAccessFileReader reader = new RandomAccessFileReader(new File(file));    BinaryInputArchive logStream = new BinaryInputArchive(reader);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    reader.close();    return fhdr.getMagic() == FileTxnLog.TXNLOG_MAGIC;}
89e0335520973d3c0da416736789cc447e615057aa21eac4334d8cf7cd1f2ff2
size
public long size() throws IOException
{    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = reader.getPosition();    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    reader.seek(lastseg.getBytes());        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    reader.seek(pos);    ;    return count;}
cf74f1b8a20cb4b1ee90d81a5ca2517cca68e10ffbbdd9d5fc5230b23a9279e2
readNextEntry
private LogEntry readNextEntry()
{    LogEntry e = null;    try {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException ex) {            return null;        }        if (bytes.length == 0) {            return null;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record r = SerializeUtils.deserializeTxn(bytes, hdr);        switch(hdr.getType()) {            case OpCode.createSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "createSession");                }                break;            case OpCode.closeSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "closeSession");                }                break;            case OpCode.create:                if (r != null) {                    CreateTxn create = (CreateTxn) r;                    String path = create.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "create", path);                }                break;            case OpCode.setData:                if (r != null) {                    SetDataTxn set = (SetDataTxn) r;                    String path = set.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setData", path);                }                break;            case OpCode.setACL:                if (r != null) {                    SetACLTxn setacl = (SetACLTxn) r;                    String path = setacl.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setACL", path);                }                break;            case OpCode.error:                if (r != null) {                    ErrorTxn error = (ErrorTxn) r;                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "error", "Error: " + error.getErr());                }                break;            default:                LOG.info("Unknown op: " + hdr.getType());                break;        }        if (logStream.readByte("EOR") != 'B') {            throw new EOFException("Last transaction was partial.");        }    } catch (Exception ex) {        LOG.error("Error reading transaction from (" + src.file + ") :" + e);        return null;    }    return e;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return next != null;}
587a94e78dc8d43a1cdb9b36a67a4d77777fb524fea671bd5e859ae375686323
next
public LogEntry next() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(fe.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
f893c4aca844d22c972e9ae8a2cde9eb4a5b553bae808938e884fe0ce517bb9e
remove
public void remove() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Txn logs");}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
56550d86759d5497e46aeadc25e366a4e86eebccad7504a0a7b8700355df08ca
iterator
public LogIterator iterator(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
4b0e489d7a367bb7362af10936a4ab89313eebd953f8f5c7aeb7bb3e620eaa9c
iterator
public LogIterator iterator(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new TxnLogSourceIterator(this, starttime, endtime, filter);}
d444843f3d30cbda87336b977a07f1c888933512e50e8dec86e286d40e31438d
iterator
public LogIterator iterator() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TxnLogSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ")";}
8e560df2397e28f7c9aa2e1abe22f8c88a6848fb0c5c77e6913052346b227569
main
public static void main(String[] args) throws IOException, FilterException
{    TxnLogSource s = new TxnLogSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        long starttime = Long.valueOf(args[1]);        long endtime = Long.valueOf(args[2]);        FilterOp fo = new FilterParser("(or (and (> zxid 0x2f0bd6f5e0) (< zxid 0x2f0bd6f5e9)) (= operation \"error\"))").parse();        System.out.println("fo: " + fo);        iter = s.iterator(starttime, endtime, fo);    } else {        iter = s.iterator();    }    System.out.println(iter);    while (iter.hasNext()) {        System.out.println(iter.next());    }    iter.close();}
ec826e7b4756de1f181a966f9ab895d7c6f517eecbcaf0b72f8afb9a2e9d85bd
join
public static Credentials join(Credentials a, Credentials b)
{    Credentials result = new Credentials();    result.putAll(a);    result.putAll(b);    return result;}
5c898aad5be30ae6a6dfb3a3080c9d4f75215b6df5fcdb6744a60046be788752
getContext
public String getContext()
{    return context;}
1a1a2b8d1542b6b4808be0620f524ce35f718bfec2737d977615ba0a5c28e149
getHostPort
public String getHostPort()
{    return hostPort.toString();}
498466ad57b236eeb61defe8f36d6fa31e6bacc1a81d0128bfbc0256aa4c2a33
getCredentials
public Credentials getCredentials()
{    return credentials;}
34389d6004ad00322fd74430d94af371d62e6081e05ca03df064f6737bef0f10
setCredentials
public void setCredentials(String c)
{    this.credentials = new Credentials(c);}
85913deef4cb40833b977504054b3f71e5419ca55bffb20a79ce0f7be76da884
setZooKeeperAuthInfo
public void setZooKeeperAuthInfo(String digest)
{    zookeeperAuth = new Credentials(digest);}
e29b5779e62e8c15006a67b906ea33d922d90f2ac13f5693817fe64f0dd50aab
getZooKeeperAuthInfo
public final Credentials getZooKeeperAuthInfo()
{    return zookeeperAuth;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    Endpoint e = (Endpoint) o;    return context.equals(e.context);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return context.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("<Endpoint %s %s>", context, hostPort.toString());}
165b1c9352ad3d309866d5286d1a7fd8eae4d022cb5ad661b1269ac75c218ebb
getHost
public String getHost()
{    return host;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return port;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    HostPort p = (HostPort) o;    return host.equals(p.host) && port == p.port;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return String.format("%s:%d", host, port).hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return original;}
33c10f7fa29f65f76a3a791c832a264c67f27c0808194ad7951a8a51bcac078d
extractCredentials
private void extractCredentials()
{    if (cfg.containsKey("rest.http.auth")) {        credentials = new Credentials(cfg.getProperty("rest.http.auth", ""));    }}
44cb815681aae8aee73f9aa7b65312b305184b29240a0f8ac0f040273c3ab3ee
extractEndpoints
private void extractEndpoints()
{    int count = 1;    while (true) {        String e = cfg.getProperty(String.format("rest.endpoint.%d", count), null);        if (e == null) {            break;        }        String[] parts = e.split(";");        if (parts.length != 2) {            count++;            continue;        }        Endpoint point = new Endpoint(parts[0], parts[1]);        String c = cfg.getProperty(String.format("rest.endpoint.%d.http.auth", count), "");        point.setCredentials(c);        String digest = cfg.getProperty(String.format("rest.endpoint.%d.zk.digest", count), "");        point.setZooKeeperAuthInfo(digest);        endpoints.add(point);        count++;    }}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return Integer.parseInt(cfg.getProperty("rest.port", "9998"));}
a54899c040039e71a99523b161dd5ce3fc8292f047aa3058373c9610a3960178
useSSL
public boolean useSSL()
{    return Boolean.valueOf(cfg.getProperty("rest.ssl", "false"));}
16c7f785aced8788003a24e11d42d5c3ab62d71313988c54e85fe21675ed2b97
getEndpoints
public final Set<Endpoint> getEndpoints()
{    return endpoints;}
815e5eadbbd19b08b6b7a6213e7389e49e9a57f77dce63d89e003fddaee5cb17
getCredentials
public final Credentials getCredentials()
{    return credentials;}
b04a226efaf5c8a669645ce292d349ec79a53afc65035969f7ec5dbac63f4a0d
getJKS
public String getJKS()
{    return cfg.getProperty("rest.ssl.jks");}
0ab56ecde7db1f05734d27efdf8650be7b7ccf79d74c835f66d08aecb6533122
getJKS
public String getJKS(String def)
{    return cfg.getProperty("rest.ssl.jks", def);}
756ce97547b813194e636a1e78cd5de6a93333e6ea404d063fe799017ffa98fc
getJKSPassword
public String getJKSPassword()
{    return cfg.getProperty("rest.ssl.jks.pass");}
07f99bb9d07fcaa69dd2f2843bda9c4050284e6649922482f4d7f27712999874
doFilter
public void doFilter(ServletRequest req0, ServletResponse resp0, FilterChain chain) throws IOException, ServletException
{    HttpServletRequest request = (HttpServletRequest) req0;    HttpServletResponse response = (HttpServletResponse) resp0;    String authorization = request.getHeader("Authorization");    if (authorization != null) {        String[] c = parseAuthorization(authorization);        if (c != null && credentials.containsKey(c[0]) && credentials.get(c[0]).equals(c[1])) {            chain.doFilter(request, response);            return;        }    }    response.setHeader("WWW-Authenticate", "Basic realm=\"Restricted\"");    response.sendError(401);}
c0c518ae0e0c54ab5bb87b6c97c3018db4a109ec2598b1e72fcbfc1e628d3bc0
parseAuthorization
private String[] parseAuthorization(String authorization)
{    String[] parts = authorization.split(" ");    if (parts.length == 2 && parts[0].equalsIgnoreCase("Basic")) {        String userPass = Base64.base64Decode(parts[1]);        int p = userPass.indexOf(":");        if (p != -1) {            return new String[] { userPass.substring(0, p), userPass.substring(p + 1) };        }    }    return null;}
f989759145ce03a120821e2193e15112013025f38cba0aa162b1133f0013e369
init
public void init(FilterConfig arg0) throws ServletException
{}
9cabd71a85d4928de1c9a46601c11d584f3e7522ee61146e1117d0d360a20b2e
destroy
public void destroy()
{}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return path.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ZChildren)) {        return false;    }    ZChildren o = (ZChildren) obj;    return path.equals(o.path) && children.equals(o.children);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ZChildren(" + path + "," + children + ")";}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return path.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ZChildrenJSON)) {        return false;    }    ZChildrenJSON o = (ZChildrenJSON) obj;    return path.equals(o.path) && children.equals(o.children);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ZChildrenJSON(" + path + "," + children + ")";}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return path.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ZPath)) {        return false;    }    ZPath o = (ZPath) obj;    return path.equals(o.path);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ZPath(" + path + ")";}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return id.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ZSession)) {        return false;    }    ZSession s = (ZSession) obj;    return id.equals(s.id);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ZSession(" + id + ")";}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return path.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ZStat)) {        return false;    }    ZStat o = (ZStat) obj;    return toString().equals(o.toString());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ZStat(" + path + "," + "b64[" + (data64 == null ? null : new String(data64)) + "]," + dataUtf8 + ")";}
19e1a96c630a57938350520981127e58be328a5061b4766c0db69a25a678c5e2
getContext
public JAXBContext getContext(Class<?> objectType)
{    return (typesSet.contains(objectType)) ? context : null;}
ad9733c242ad4df08029df146cf311fc45b816caa6ec67a095097529b8a9fbbf
toResponse
public Response toResponse(KeeperException e)
{    Response.Status status;    String message;    String path = e.getPath();    switch(e.code()) {        case AUTHFAILED:            status = Response.Status.UNAUTHORIZED;            message = path + " not authorized";            break;        case BADARGUMENTS:            status = Response.Status.BAD_REQUEST;            message = path + " bad arguments";            break;        case BADVERSION:            status = Response.Status.PRECONDITION_FAILED;            message = path + " bad version";            break;        case INVALIDACL:            status = Response.Status.BAD_REQUEST;            message = path + " invalid acl";            break;        case NODEEXISTS:            status = Response.Status.CONFLICT;            message = path + " already exists";            break;        case NONODE:            status = Response.Status.NOT_FOUND;            message = path + " not found";            break;        case NOTEMPTY:            status = Response.Status.CONFLICT;            message = path + " not empty";            break;        default:                        status = Response.Status.fromStatusCode(502);            message = "Error processing request for " + path + " : " + e.getMessage();    }    return Response.status(status).entity(new ZError(ui.getRequestUri().toString(), message)).build();}
2aa3caf7100bf66b7a8e12c353344fc839679584131dde6cfdf7e3abddfd025e
toResponse
public Response toResponse(RuntimeException e)
{        if (e instanceof WebApplicationException) {        WebApplicationException ie = (WebApplicationException) e;        return ie.getResponse();    }    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(new ZError(ui.getRequestUri().toString(), "Error processing request due to " + e)).build();}
deab47abbd5558beb06404d65f098faef66e83059412622b02ff8db8b0cd4c8b
keepAliveSession
public Response keepAliveSession(@PathParam("session") String session, @Context UriInfo ui, byte[] data)
{    if (!ZooKeeperService.isConnected(contextPath, session)) {        throwNotFound(session, ui);    }    ZooKeeperService.resetTimer(contextPath, session);    return Response.status(Response.Status.OK).build();}
fcdb4aa7be3b0071138b94d839e933f7ba57087cfcdbcbc843a3918182a07b27
createSession
public Response createSession(@QueryParam("op") String op, @DefaultValue("5") @QueryParam("expire") String expire, @Context UriInfo ui)
{    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), "")).build());    }    int expireInSeconds;    try {        expireInSeconds = Integer.parseInt(expire);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());    }    String uuid = UUID.randomUUID().toString();    while (ZooKeeperService.isConnected(contextPath, uuid)) {        uuid = UUID.randomUUID().toString();    }        try {        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);    } catch (IOException e) {        LOG.error("Failed while trying to create a new session", e);        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());    }    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();    return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();}
4aeddfbcd164b4fcd38d9a507520f06b70b1b8ed0a218b29a34aed35d4ff2d9d
deleteSession
public void deleteSession(@PathParam("session") String session, @Context UriInfo ui)
{    ZooKeeperService.close(contextPath, session);}
a339bcd56bc29bd3c2f93bff331d82f195c7c7b2b66d0e6b98daec23baaafbe0
throwNotFound
private static void throwNotFound(String session, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), session + " not found")).build());}
0bd39f40e0ca250e3339bffad97ee0123a57b38dd9bb8082870447775db5d380
getSize
public long getSize(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
639b805b4c683337113c5542c718a000c034946fb88af3718509be6da06ad085
isWriteable
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ZError.class.isAssignableFrom(type);}
9c7e9749f8ff47ad4e13db5d92fc579d55ca1ae24a4af4fe3d76dae16da7a4ba
writeTo
public void writeTo(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream os) throws IOException, WebApplicationException
{    PrintStream p = new PrintStream(os);    p.print("Request " + t.request + " failed due to " + t.message);    p.flush();}
f7d01c382b9fdb9d3a672e1873c6460993bc70e9dbe4557632da35c51f7d4bc0
ensurePathNotNull
private void ensurePathNotNull(String path)
{    if (path == null) {        throw new IllegalArgumentException("Invalid path \"" + path + "\"");    }}
fa6ab74994f82c865f0018bc12d8a94bcd75e0cc6a951621ace26371bf08484b
existsZNode
public Response existsZNode(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.OK).build();}
b068cdc779e3fa3a14592f7dab00b361a02e9a99c5fe2592c433c75d820a050a
existsZNodeAsOctet
public Response existsZNodeAsOctet(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.NO_CONTENT).build();}
2d88ac56ccd0f04dd5c68dfac1e16b762c4bc900b6a500600f796fbe8ed5b24f
getZNodeListJSON
public Response getZNodeListJSON(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("data") @QueryParam("view") String view, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(true, path, callback, view, dataformat, ui);}
0b033733b485ee2df1cbecf7716e532d1720e5e64153845a533f7e85f3eae0b0
getZNodeList
public Response getZNodeList(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("data") @QueryParam("view") String view, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(false, path, callback, view, dataformat, ui);}
b9ccf9f365fe34a1c16927222dabb5992bf8462bf866bceb2c404a5607e68317
getZNodeList
private Response getZNodeList(boolean json, String path, String callback, String view, String dataformat, UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (view.equals("children")) {        List<String> children = new ArrayList<String>();        for (String child : zk.getChildren(path, false)) {            children.add(child);        }        Object child;        String childTemplate = ui.getAbsolutePath().toString();        if (!childTemplate.endsWith("/")) {            childTemplate += "/";        }        childTemplate += "{child}";        if (json) {            child = new ZChildrenJSON(path, ui.getAbsolutePath().toString(), childTemplate, children);        } else {            child = new ZChildren(path, ui.getAbsolutePath().toString(), childTemplate, children);        }        return Response.status(Response.Status.OK).entity(new JSONWithPadding(child, callback)).build();    } else {        Stat stat = new Stat();        byte[] data = zk.getData(path, false, stat);        byte[] data64;        String dataUtf8;        if (data == null) {            data64 = null;            dataUtf8 = null;        } else if (!dataformat.equals("utf8")) {            data64 = data;            dataUtf8 = null;        } else {            data64 = null;            dataUtf8 = new String(data);        }        ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), data64, dataUtf8, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());        return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();    }}
c5d0876f18ad6289a5bbca5a0598e2ee591acc86057560e30775e5c463af959f
getZNodeListAsOctet
public Response getZNodeListAsOctet(@PathParam("path") String path) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    Stat stat = new Stat();    byte[] data = zk.getData(path, false, stat);    if (data == null) {        return Response.status(Response.Status.NO_CONTENT).build();    } else {        return Response.status(Response.Status.OK).entity(data).build();    }}
88694423d9008d61d1e31c3b2541789fb4ad33efac79693a20142062b63d7ec5
setZNode
public Response setZNode(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("-1") @QueryParam("version") String versionParam, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @DefaultValue("false") @QueryParam("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    Stat stat = zk.setData(path, data, version);    ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), null, null, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());    return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();}
4a62aacd1eadce90bed0cb0d7e86ed95712f86951d98989b06c597520546ae5b
setZNodeAsOctet
public void setZNodeAsOctet(@PathParam("path") String path, @DefaultValue("-1") @QueryParam("version") String versionParam, @DefaultValue("false") @QueryParam("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    zk.setData(path, data, version);}
d86d63c76912f758809fbbf26f0881280b459b177d0a6f5566fac68e82eb7181
createZNode
public Response createZNode(@PathParam("path") String path, @QueryParam("callback") String callback, @DefaultValue("create") @QueryParam("op") String op, @QueryParam("name") String name, @DefaultValue("base64") @QueryParam("dataformat") String dataformat, @DefaultValue("false") @QueryParam("null") String setNull, @DefaultValue("false") @QueryParam("sequence") String sequence, @DefaultValue("false") @QueryParam("ephemeral") String ephemeral, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        if (ephemeral.equals("false")) {            createMode = CreateMode.PERSISTENT_SEQUENTIAL;        } else {            createMode = CreateMode.EPHEMERAL_SEQUENTIAL;        }    } else if (ephemeral.equals("false")) {        createMode = CreateMode.PERSISTENT;    } else {        createMode = CreateMode.EPHEMERAL;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new JSONWithPadding(new ZPath(newPath, ui.getAbsolutePath().toString()))).build();}
47ca51c397e28f9134857c28e0d8b01825ddedd7a572ae6c2f081abcf08555a0
createZNodeAsOctet
public Response createZNodeAsOctet(@PathParam("path") String path, @DefaultValue("create") @QueryParam("op") String op, @QueryParam("name") String name, @DefaultValue("false") @QueryParam("null") String setNull, @DefaultValue("false") @QueryParam("sequence") String sequence, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        createMode = CreateMode.PERSISTENT_SEQUENTIAL;    } else {        createMode = CreateMode.PERSISTENT;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new ZPath(newPath, ui.getAbsolutePath().toString())).build();}
3443ff0c8af89287d2d9a16a8a9e4e46f3dfe7aa1b86f59a36aabb418c899630
deleteZNode
public void deleteZNode(@PathParam("path") String path, @DefaultValue("-1") @QueryParam("version") String versionParam, @Context UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    zk.delete(path, version);}
31d1b3d1f246a2ae76aaa3518dfc568277870242f1df22c9c3bf5fcd75eb600a
throwNotFound
private static void throwNotFound(String path, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), path + " not found")).build());}
e5a14fc0f40f83e0c8774c3bcbdfa6c6fbf236404951b40500e2bd5e42f00077
start
public void start() throws IOException
{    System.out.println("Starting grizzly ...");    boolean useSSL = cfg.useSSL();    gws = new GrizzlyWebServer(cfg.getPort(), "/tmp/23cxv45345/2131xc2/", useSSL);    for (Endpoint e : cfg.getEndpoints()) {        ZooKeeperService.mapContext(e.getContext(), e);        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });    }    if (useSSL) {        System.out.println("Starting SSL ...");        String jks = cfg.getJKS("keys/rest.jks");        String jksPassword = cfg.getJKSPassword();        SSLConfig sslConfig = new SSLConfig();        URL resource = getClass().getClassLoader().getResource(jks);        if (resource == null) {            LOG.error("Unable to find the keystore file: " + jks);            System.exit(2);        }        try {            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());        } catch (URISyntaxException e1) {            LOG.error("Unable to load keystore: " + jks, e1);            System.exit(2);        }        sslConfig.setKeyStorePass(jksPassword);        gws.setSSLConfig(sslConfig);    }    gws.start();}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    gws.stop();    ZooKeeperService.closeAll();}
513bd0ea38ca5e441b1f778775b7bd07c280ac3c62da3a23281b9d3c6dbacbf8
createJerseyAdapter
private ServletAdapter createJerseyAdapter(Endpoint e)
{    ServletAdapter jersey = new ServletAdapter();    jersey.setServletInstance(new ServletContainer());    jersey.addInitParameter("com.sun.jersey.config.property.packages", "org.apache.zookeeper.server.jersey.resources");    jersey.setContextPath(e.getContext());    Credentials c = Credentials.join(e.getCredentials(), cfg.getCredentials());    if (!c.isEmpty()) {        jersey.addFilter(new HTTPBasicAuth(c), e.getContext() + "-basic-auth", null);    }    return jersey;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    RestCfg cfg = new RestCfg("rest.properties");    final RestMain main = new RestMain(cfg);    main.start();    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            main.stop();            System.out.println("Got exit request. Bye.");        }    });    printEndpoints(cfg);    System.out.println("Server started.");}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    main.stop();    System.out.println("Got exit request. Bye.");}
982f41708f21539e360a2cc637f34321b0d0393aee476e8b529e69b00c322ec3
printEndpoints
private static void printEndpoints(RestCfg cfg)
{    int port = cfg.getPort();    for (Endpoint e : cfg.getEndpoints()) {        String context = e.getContext();        if (context.charAt(context.length() - 1) != '/') {            context += "/";        }        System.out.println(String.format("Started %s - WADL: http://localhost:%d%sapplication.wadl", context, port, context));    }}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        close(contextPath);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    if (LOG.isInfoEnabled()) {        LOG.info(String.format("Session '%s' expired after " + "'%d' milliseconds.", session, delay));    }    ZooKeeperService.close(contextPath, session);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    timer.schedule(this, delay);}
337d48eb8bef7f0c0a8cbde46d2a096e61c59c96caea168f7490e5417585f901
mapContext
public static synchronized void mapContext(String contextPath, Endpoint e)
{    contextMap.put(contextPath, e);}
078f6b0819ef7f4951d51dac8a05c09eee4ce50c6f2e79ce061d0e8a472bcdba
resetTimer
public static synchronized void resetTimer(String contextPath, String session)
{    if (session != null) {        String uri = concat(contextPath, session);        SessionTimerTask t = zkSessionTimers.remove(uri);        t.cancel();        zkSessionTimers.put(uri, new SessionTimerTask(t));    }}
0f3de60cf1ebe00e8605a44045738cc20809b621502e27e2ba934cc8fb62c504
close
public static void close(String contextPath)
{    close(contextPath, null);}
2c348e2591aa4cc0cd73de2646154baedd32576d3c023a7b4cf646bcc8b41b35
close
public static synchronized void close(String contextPath, String session)
{    String uri = concat(contextPath, session);    TimerTask t = zkSessionTimers.remove(uri);    if (t != null) {        t.cancel();    }    ZooKeeper zk = zkMap.remove(uri);    if (zk == null) {        return;    }    try {        zk.close();    } catch (InterruptedException e) {        LOG.error("Interrupted while closing ZooKeeper connection.", e);    }}
87f9986c83e527743e98f704d3decfb8841c1a17aa754a3d4ceb24dee244918f
closeAll
public static synchronized void closeAll()
{    Set<String> sessions = new TreeSet<String>(zkMap.keySet());    for (String key : sessions) {        close(key);    }}
179eb7c7a6d2dc6d06cbc0e6e15150d7332edcacde36a56e9c213a6509fe582c
isConnected
public static synchronized boolean isConnected(String contextPath, String session)
{    return zkMap.containsKey(concat(contextPath, session));}
0415b58a81051c5ad788a7209e70b337b4dc5fb038c47cb38a9820ab89a8fc12
getClient
public static ZooKeeper getClient(String contextPath) throws IOException
{    return getClient(contextPath, null);}
f56942dcdb0a90cc758cfafa83aa6453b933407c581babaac3b4d96f2e2b1859
getClient
public static ZooKeeper getClient(String contextPath, String session) throws IOException
{    return getClient(contextPath, session, 5);}
0606d48b905c0b57f924301ea7fbde4b9a88a2c83e69517f1448b4d4a071f10d
getClient
public static synchronized ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException
{    final String connectionId = concat(contextPath, session);    ZooKeeper zk = zkMap.get(connectionId);    if (zk == null) {        if (LOG.isInfoEnabled()) {            LOG.info(String.format("creating new " + "connection for : '%s'", connectionId));        }        Endpoint e = contextMap.get(contextPath);        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {            zk.addAuthInfo("digest", String.format("%s:%s", p.getKey(), p.getValue()).getBytes());        }        zkMap.put(connectionId, zk);                if (session != null) {            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));        }    }    return zk;}
0b2603b1987123da210417862c764c103af4c26f6c50a0a543937e4cd224eb06
concat
private static String concat(String contextPath, String session)
{    if (session != null) {        return String.format("%s@%s", contextPath, session);    }    return contextPath;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    RestCfg cfg = new RestCfg(new ByteArrayInputStream(String.format("rest.port=%s\n" + "rest.endpoint.1=%s;%s\n", GRIZZLY_PORT, CONTEXT_PATH, ZKHOSTPORT).getBytes()));    rest = new RestMain(cfg);    rest.start();    zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    client = Client.create();    znodesr = client.resource(BASEURI).path("znodes/v1");    sessionsr = client.resource(BASEURI).path("sessions/v1/");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    client.destroy();    zk.close();    rest.stop();}
e639668561e10a0890931e178e506d9d54150c7b57d78e80169fb02299abcfcb
createBaseZNode
protected static String createBaseZNode() throws Exception
{    ZooKeeper zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    String baseZnode = zk.create("/test-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.close();    return baseZnode;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "foo bar", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/foo bar"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t1"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t2"), "".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t3"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t4", "base64", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t4"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true } });}
a66dfa0a0dc44c8498730b66bb882e7c65e66f27e31ffe53ff36181d8fbb6615
testCreate
public void testCreate() throws Exception
{    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding).queryParam("name", name);    if (data == null) {        wr = wr.queryParam("null", "true");    }    if (sequence) {        wr = wr.queryParam("sequence", "true");    }    Builder builder = wr.accept(accept);    ClientResponse cr;    if (data == null) {        cr = builder.post(ClientResponse.class);    } else {        cr = builder.post(ClientResponse.class, data);    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedPath == null) {        return;    }    ZPath zpath = cr.getEntity(ZPath.class);    if (sequence) {        Assert.assertTrue(zpath.path.startsWith(expectedPath.path));        Assert.assertTrue(zpath.uri.startsWith(znodesr.path(path).toString()));    } else {        Assert.assertEquals(expectedPath, zpath);        Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);    }        byte[] data = zk.getData(zpath.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.assertEquals(data, this.data);    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT }, { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT } });}
f5016b5c60047af11250d71203a30dc14e522a4a5e2333d8b8998ae3239be5a0
verify
public void verify(String type) throws Exception
{    if (expectedStatus != ClientResponse.Status.NOT_FOUND) {        zpath = zk.create(zpath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    }    ClientResponse cr = znodesr.path(zpath).accept(type).type(type).delete(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());        Stat stat = zk.exists(zpath, false);    Assert.assertNull(stat);}
d588d24d86f0ebbff2cd80210ca2cce069b8c9b5ef0b61e20fb792c431381f7f
testDelete
public void testDelete() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, ClientResponse.Status.OK }, { baseZnode + "dkdk38383", ClientResponse.Status.NOT_FOUND } });}
03c85ed96011595c56a23d81140dfe6e59c94f537604bce20c8b20e6c3debd15
verify
private void verify(String type)
{    ClientResponse cr = znodesr.path(path).accept(type).type(type).head();    if (type.equals(MediaType.APPLICATION_OCTET_STREAM) && expectedStatus == ClientResponse.Status.OK) {        Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    } else {        Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    }}
a66c7b514e0cc7acf178878248fde23c7820d4057ff4d4b6ffbfe0da9250b526
testExists
public void testExists() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    String baseZnode2 = Base.createBaseZNode();    String baseZnode3 = Base.createBaseZNode();    String baseZnode4 = Base.createBaseZNode();    String baseZnode5 = Base.createBaseZNode();    String baseZnode6 = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_XML, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_XML, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_XML, baseZnode4, ClientResponse.Status.OK, baseZnode4, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_JSON, baseZnode2, ClientResponse.Status.OK, baseZnode2, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_XML, baseZnode5, ClientResponse.Status.OK, baseZnode5, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_JSON, baseZnode3, ClientResponse.Status.OK, baseZnode3, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) }, { MediaType.APPLICATION_XML, baseZnode6, ClientResponse.Status.OK, baseZnode6, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) } });}
13e8680c1e35707d68c911292648eb3dd3fe3efeac48ce55b75db8e94d5bf275
testGetChildren
public void testGetChildren() throws Exception
{    if (expectedChildren != null) {        for (String child : expectedChildren) {            zk.create(expectedPath + "/" + child, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    ClientResponse cr = znodesr.path(path).queryParam("view", "children").accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedChildren == null) {        return;    }    if (accept.equals(MediaType.APPLICATION_JSON)) {        ZChildrenJSON zchildren = cr.getEntity(ZChildrenJSON.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else if (accept.equals(MediaType.APPLICATION_XML)) {        ZChildren zchildren = cr.getEntity(ZChildren.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else {        Assert.fail("unknown accept type");    }}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "") }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_XML, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null } });}
2036295288ae2957843d767363bfed098cb02b2bd68371306e2b5d80e5352f05
testGet
public void testGet() throws Exception
{    if (expectedStat != null) {        if (expectedStat.data64 != null || expectedStat.dataUtf8 == null) {            zk.setData(expectedStat.path, expectedStat.data64, -1);        } else {            zk.setData(expectedStat.path, expectedStat.dataUtf8.getBytes(), -1);        }    }    ClientResponse cr = znodesr.path(path).queryParam("dataformat", encoding).accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);    Assert.assertEquals(znodesr.path(path).toString(), zstat.uri);}
ca86f0db8b699367a1e071192b0ab724903096b25a11d522de42a85bae0700a9
setUp
public static void setUp()
{}
7bc01499962f9db4f29ce028fa1e575b4b5f7e9b37f763467d82ccb96ea15886
tearDown
public static void tearDown()
{}
a66dfa0a0dc44c8498730b66bb882e7c65e66f27e31ffe53ff36181d8fbb6615
testCreate
public void testCreate() throws Exception
{    String path = "/";    String name = "roottest-create";    byte[] data = "foo".getBytes();    WebResource wr = znodesr.path(path).queryParam("dataformat", "utf8").queryParam("name", name);    Builder builder = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr;    cr = builder.post(ClientResponse.class, data);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    ZPath zpath = cr.getEntity(ZPath.class);    Assert.assertEquals(new ZPath(path + name), zpath);    Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);        byte[] rdata = zk.getData(zpath.path, false, new Stat());    Assert.assertTrue(new String(rdata) + " == " + new String(data), Arrays.equals(rdata, data));}
f9cd6cc162add6ce706743a33ea90b7e7fc0835dbbbfda59151b45f4772e7f1c
createSession
private ZSession createSession()
{    return createSession("30");}
7f5a0ca2f1738b97d685dc0c2ae3e2f2a79cd83e7292c8ca0658a73ff28ed138
createSession
private ZSession createSession(String expire)
{    WebResource wr = sessionsr.queryParam("op", "create").queryParam("expire", expire);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    return cr.getEntity(ZSession.class);}
4add3bdf48a5ab9326cbfb68195425906082490b8198ece01affd65462f2cf88
testCreateNewSession
public void testCreateNewSession() throws JSONException
{    ZSession session = createSession();    Assert.assertEquals(session.id.length(), 36);        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
a265612d721239cdb0e46257924b63f27ae465548914972b4b3f67a8d850ab0d
testSessionExpires
public void testSessionExpires() throws InterruptedException
{    ZSession session = createSession("1");        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));        Thread.sleep(1500);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
4aa70a211b33b4c30d038702006283368367c00c51bece8a8581246223d4c44d
testDeleteSession
public void testDeleteSession()
{    ZSession session = createSession("30");    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    ClientResponse cr = b.delete(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
1a85981a5e7a0214c8b8615de2aeea7c9513e14985183deaf1c9b67104dae947
testSendHeartbeat
public void testSendHeartbeat() throws InterruptedException
{    ZSession session = createSession("2");    Thread.sleep(1000);    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.put(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.OK, cr.getClientResponseStatus());    Thread.sleep(1500);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    Thread.sleep(1000);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
8a50b6d71dbddc90a7b34a177de0b7747f788a2711331135d69039a7ea4ef0c9
testCreateEphemeralZNode
public void testCreateEphemeralZNode() throws KeeperException, InterruptedException, IOException
{    ZSession session = createSession("30");    WebResource wr = znodesr.path("/").queryParam("op", "create").queryParam("name", "ephemeral-test").queryParam("ephemeral", "true").queryParam("session", session.id).queryParam("null", "true");    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    Stat stat = new Stat();    zk.getData("/ephemeral-test", false, stat);    ZooKeeper sessionZK = ZooKeeperService.getClient(CONTEXT_PATH, session.id);    Assert.assertEquals(stat.getEphemeralOwner(), sessionZK.getSessionId());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
99368237115bcd481a1248dee30803c780b17e2ee128f406ebf46bc0a5c175b3
data
public static Collection<Object[]> data() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "/s-t1", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t1", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t2", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t2", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t3", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t3", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t4", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t4", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t5", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t5", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t6", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t6", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "utf8", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "base64", ClientResponse.Status.NOT_FOUND, null, null } });}
cec564f9b0b24c51589eb9c6500ced17a78254a77e3e7bbc24c54470d354a153
testSet
public void testSet() throws Exception
{    if (expectedStat != null) {        zk.create(expectedStat.path, "initial".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding);    if (data == null) {        wr = wr.queryParam("null", "true");    }    Builder builder = wr.accept(accept).type(MediaType.APPLICATION_OCTET_STREAM);    ClientResponse cr;    if (data == null) {        cr = builder.put(ClientResponse.class);    } else {                                        cr = builder.put(ClientResponse.class, new String(data));    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);        byte[] data = zk.getData(zstat.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.fail((data == null ? null : new String(data)) + " == " + (this.data == null ? null : new String(this.data)));    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
f09b602135f9a505b5e4d7055e60e21e8eecf2d6419a806ac7622608c24884cc
testApplicationWadl
public void testApplicationWadl()
{    WebResource r = client.resource(BASEURI);    String serviceWadl = r.path("application.wadl").accept(MediaTypes.WADL).get(String.class);    Assert.assertTrue("Something wrong. Returned wadl length not > 0.", serviceWadl.length() > 0);}
1f0d8c5a7f6eb416ca24167ea312f2d6e8d9a53f5ef2af9b3d182c68ca5674f0
initComponents
private void initComponents()
{    setSize(toasterWidth, toasterHeight);    message.setFont(getToasterMessageFont());    JPanel externalPanel = new JPanel(new BorderLayout(1, 1));    externalPanel.setBackground(getBorderColor());    JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));    innerPanel.setBackground(getToasterColor());    message.setBackground(getToasterColor());    message.setMargin(new Insets(2, 2, 2, 2));    message.setLineWrap(true);    message.setWrapStyleWord(true);    EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();    externalPanel.setBorder(etchedBorder);    externalPanel.add(innerPanel);    message.setForeground(getMessageColor());    innerPanel.add(iconLabel, BorderLayout.WEST);    innerPanel.add(message, BorderLayout.CENTER);    getContentPane().add(externalPanel);}
1a3f6dbfaf3ef03d995796e67fdc9776b192a857c73121679070e50ca65b042c
animate
public void animate()
{    (new Animation(this)).start();}
13b301013d96dd0bae13df2d29504bc05f933cba0d487e920b402cde14825cd8
animateVertically
protected void animateVertically(int posx, int fromY, int toY) throws InterruptedException
{    toaster.setLocation(posx, fromY);    if (toY < fromY) {        for (int i = fromY; i > toY; i -= step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    } else {        for (int i = fromY; i < toY; i += step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    }    toaster.setLocation(posx, toY);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        boolean animateFromBottom = true;        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();        Rectangle screenRect = ge.getMaximumWindowBounds();        int screenHeight = (int) screenRect.height;        int startYPosition;        int stopYPosition;        if (screenRect.y > 0) {                        animateFromBottom = false;        }        maxToasterInSceen = screenHeight / toasterHeight;        int posx = (int) screenRect.width - toasterWidth - 1;        toaster.setLocation(posx, screenHeight);        toaster.setVisible(true);        if (useAlwaysOnTop) {            toaster.setAlwaysOnTop(true);        }        if (animateFromBottom) {            startYPosition = screenHeight;            stopYPosition = startYPosition - toasterHeight - 1;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition - (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        } else {            startYPosition = screenRect.y - toasterHeight;            stopYPosition = screenRect.y;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition + (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        }        currentNumberOfToaster++;        maxToaster++;        animateVertically(posx, startYPosition, stopYPosition);        Thread.sleep(displayTime);        animateVertically(posx, stopYPosition, startYPosition);        currentNumberOfToaster--;        toaster.setVisible(false);        toaster.dispose();    } catch (Exception e) {        e.printStackTrace();    }}
08f88bab538dd341a79797b9d1cd2106abe769299199072fe56afea2bf5eb929
showToaster
public void showToaster(Icon icon, String msg)
{    SingleToaster singleToaster = new SingleToaster();    if (icon != null) {        singleToaster.iconLabel.setIcon(icon);    }    singleToaster.message.setText(msg);    singleToaster.animate();}
51ca646a6e6053c7a90c9992e26c4b5ac9364e134702bdca282381569fbd90fe
showToaster
public void showToaster(String msg)
{    showToaster(null, msg);}
f077032bae4627b430d358ec5bfd865b608507388accc7d7b4294b0f186e7c94
getToasterMessageFont
public Font getToasterMessageFont()
{        return font;}
6924a4f5f061bafa47b3df500d58210f4d3be6c3b0be594a11dace1c8bc62ce3
setToasterMessageFont
public void setToasterMessageFont(Font f)
{    font = f;}
c9bf380e1b28f15f33da2847556adcaa0a00f5950eea97e38dcb49d33a8ff109
getBorderColor
public Color getBorderColor()
{    return borderColor;}
1cd0ab277888619ee9a22431c4665dfd7ee08c4df8666f593c8e3cc4e40d5a2a
setBorderColor
public void setBorderColor(Color borderColor)
{    this.borderColor = borderColor;}
539d2b4088b0762a57fbf7ff4b12833fc12ad5486f0735729c8d543b0587e7c1
getDisplayTime
public int getDisplayTime()
{    return displayTime;}
a85f8490ae69a082884a0664d312df19a01a55e5c82031cf50471298b2682966
setDisplayTime
public void setDisplayTime(int displayTime)
{    this.displayTime = displayTime;}
6c3ef4ae6e34b273a5c3621fcc0d8c53a0e50e00d7f63288db278773b1f8046f
getMargin
public int getMargin()
{    return margin;}
dac4d6e06c257a7c31d1c023b33453b3758282b42afcadd5a412dde0d84236d9
setMargin
public void setMargin(int margin)
{    this.margin = margin;}
6adfedc6d91f0db0fa8adefafa56e9fe124ead7ce3cc662ee21c8a1ecf74619e
getMessageColor
public Color getMessageColor()
{    return messageColor;}
367c102397ec06635aeb5031baebafd06b8acb30f0f126b45cf4b2382846a8fc
setMessageColor
public void setMessageColor(Color messageColor)
{    this.messageColor = messageColor;}
1155f7a7c8c942e53f5a5b594b7cb754c488a16c5eea10c49f4462cdbc1bcecf
getStep
public int getStep()
{    return step;}
a1072815ecc512d491cb33dd819b5d78a1b5c096c2cf568d5de7955ad043834d
setStep
public void setStep(int step)
{    this.step = step;}
12b9241143126a19fd3759fcbb642efa856bda64cb3d12af4e45d4a08d4206d1
getStepTime
public int getStepTime()
{    return stepTime;}
43266336464fde886ac52a4c06c185f27d15132e3768a778b22e0c598307c2d9
setStepTime
public void setStepTime(int stepTime)
{    this.stepTime = stepTime;}
3c462997cd9533ef35c7a86355d79b62d2713c75c2e699ee7faa17f25e167145
getToasterColor
public Color getToasterColor()
{    return toasterColor;}
31786e7ae6c4cd0d9b7096697bdaa35d6b6468c19a886678522d327101538f3f
setToasterColor
public void setToasterColor(Color toasterColor)
{    this.toasterColor = toasterColor;}
b3fba50901ad6319c704fad80948d3f1e6b36b1ec37fef6fb0c1a89804b758d9
getToasterHeight
public int getToasterHeight()
{    return toasterHeight;}
aeae4de6928a6dc0001e6c3758ce50d9e77aa97a405d6a187257d789f0989fe9
setToasterHeight
public void setToasterHeight(int toasterHeight)
{    this.toasterHeight = toasterHeight;}
a0ca5db38436c5ec6ff60de2af4b1b3ddc5a6bd16906512ece7d6e1f678d9780
getToasterWidth
public int getToasterWidth()
{    return toasterWidth;}
8ff0126e89a5614c864cb3a450a11131e1aba0de9dc2eea7d545306df16ece9e
setToasterWidth
public void setToasterWidth(int toasterWidth)
{    this.toasterWidth = toasterWidth;}
155057fc85374139962996d4a3dd3b486cd4841a0682efad5aea4cc2cba6f149
decryptData
public String decryptData(byte[] encrypted) throws Exception
{    return new String(encrypted);}
bffef4cbb982577d2c433ff3fe829cd9964d06807d8c74b1569abbeaabbc928d
encryptData
public byte[] encryptData(String data) throws Exception
{    if (data == null) {        return new byte[0];    }    return data.getBytes();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 1) {        final String nodeName = JOptionPane.showInputDialog(panel, "Please Enter a name for the new node", "Create Node", JOptionPane.INFORMATION_MESSAGE);        if (nodeName != null && nodeName.length() > 0) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    } else {        JOptionPane.showMessageDialog(panel, "Please select 1 parent node for the new node.");    }}
7a78e0764277b726e816229b2a7459055bb1cdfa06d5b358d09b04e15fc57955
doInBackground
protected Boolean doInBackground() throws Exception
{    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    treeViewer.refreshView();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 0) {        JOptionPane.showMessageDialog(parentPanel, "Please select at least 1 node to be deleted");    } else {        int answer = JOptionPane.showConfirmDialog(parentPanel, "Are you sure you want to delete the selected nodes?" + "(This action cannot be reverted)", "Confirm Delete", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        if (answer == JOptionPane.YES_OPTION) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    for (String nodePath : selectedNodes) {                        zooInspectorManager.deleteNode(nodePath);                    }                    return true;                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    }}
7a78e0764277b726e816229b2a7459055bb1cdfa06d5b358d09b04e15fc57955
doInBackground
protected Boolean doInBackground() throws Exception
{    for (String nodePath : selectedNodes) {        zooInspectorManager.deleteNode(nodePath);    }    return true;}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    treeViewer.refreshView();}
c126aa57d68c575f21fdab659a6baf45650231bae462ae990fdea43114322217
find
public URL find(String name)
{    String iconPath = buildIconPath(name);    URL iconUrl = findInPaths(iconPath);    if (null != iconUrl)        return iconUrl;    iconUrl = getClass().getResource(iconPath);    if (null != iconUrl)        return iconUrl;    if (!name.equals(FALLBACK_ICON))        return find(FALLBACK_ICON);    return null;}
ab824a239eecac4ad9c57516714eb432866356a26c36befa22bc3615b44791b0
get
public ImageIcon get(String name, String description)
{    URL iconUrl = find(name);    if (null == iconUrl) {        ImageIcon icon = new ImageIcon();        icon.setDescription(description);        return icon;    } else {        return new ImageIcon(iconUrl, description);    }}
05087b9ca9a0511ec512f41edc047f8e0bd58cedb8d4dcda9d2eaedd003aa111
findInPaths
private URL findInPaths(String iconPath)
{    for (String dataDir : DEFAULT_XDG_DATA_DIRS) {        File file = new File(dataDir + iconPath);        if (file.exists()) {            try {                return file.toURI().toURL();            } catch (MalformedURLException e) {                LoggerFactory.getLogger().warn(e.toString());            }        }    }    return null;}
5d05628974f239a3361df22e02e3de71492878e08ccbc34c6bc8d17a3581fcbd
buildIconPath
private String buildIconPath(String name)
{    return "/icons/" + theme + "/" + size + "/" + name + ".png";}
e5ef01fa2cf65dfc9fab56435459437471698c703940d8b9a6902680e8c38e95
getTitle
public String getTitle()
{    return "Node ACLs";}
fde86ad6de584b045d2cc264b23017fe023752c3ff9064ac7c9b60bbfd13b550
nodeSelectionChanged
public void nodeSelectionChanged(List<String> selectedNodes)
{    this.aclDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<List<Map<String, String>>, Void> worker = new SwingWorker<List<Map<String, String>>, Void>() {            @Override            protected List<Map<String, String>> doInBackground() throws Exception {                return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);            }            @Override            protected void done() {                List<Map<String, String>> acls = null;                try {                    acls = get();                } catch (InterruptedException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                } catch (ExecutionException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                }                aclDataPanel.setLayout(new GridBagLayout());                int j = 0;                for (Map<String, String> data : acls) {                    int rowPos = 2 * j + 1;                    JPanel aclPanel = new JPanel();                    aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));                    aclPanel.setBackground(Color.WHITE);                    aclPanel.setLayout(new GridBagLayout());                    int i = 0;                    for (Map.Entry<String, String> entry : data.entrySet()) {                        int rowPosACL = 2 * i + 1;                        JLabel label = new JLabel(entry.getKey());                        JTextField text = new JTextField(entry.getValue());                        text.setEditable(false);                        GridBagConstraints c1 = new GridBagConstraints();                        c1.gridx = 1;                        c1.gridy = rowPosACL;                        c1.gridwidth = 1;                        c1.gridheight = 1;                        c1.weightx = 0;                        c1.weighty = 0;                        c1.anchor = GridBagConstraints.NORTHWEST;                        c1.fill = GridBagConstraints.BOTH;                        c1.insets = new Insets(5, 5, 5, 5);                        c1.ipadx = 0;                        c1.ipady = 0;                        aclPanel.add(label, c1);                        GridBagConstraints c2 = new GridBagConstraints();                        c2.gridx = 3;                        c2.gridy = rowPosACL;                        c2.gridwidth = 1;                        c2.gridheight = 1;                        c2.weightx = 0;                        c2.weighty = 0;                        c2.anchor = GridBagConstraints.NORTHWEST;                        c2.fill = GridBagConstraints.BOTH;                        c2.insets = new Insets(5, 5, 5, 5);                        c2.ipadx = 0;                        c2.ipady = 0;                        aclPanel.add(text, c2);                        i++;                    }                    GridBagConstraints c = new GridBagConstraints();                    c.gridx = 1;                    c.gridy = rowPos;                    c.gridwidth = 1;                    c.gridheight = 1;                    c.weightx = 1;                    c.weighty = 1;                    c.anchor = GridBagConstraints.NORTHWEST;                    c.fill = GridBagConstraints.NONE;                    c.insets = new Insets(5, 5, 5, 5);                    c.ipadx = 0;                    c.ipady = 0;                    aclDataPanel.add(aclPanel, c);                }                NodeViewerACL.this.aclDataPanel.revalidate();                NodeViewerACL.this.aclDataPanel.repaint();            }        };        worker.execute();    }}
39e3b92215ffabd6ac801809175a2fd0438387268919053bedb3e8276f5a15f2
doInBackground
protected List<Map<String, String>> doInBackground() throws Exception
{    return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    List<Map<String, String>> acls = null;    try {        acls = get();    } catch (InterruptedException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    } catch (ExecutionException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    }    aclDataPanel.setLayout(new GridBagLayout());    int j = 0;    for (Map<String, String> data : acls) {        int rowPos = 2 * j + 1;        JPanel aclPanel = new JPanel();        aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));        aclPanel.setBackground(Color.WHITE);        aclPanel.setLayout(new GridBagLayout());        int i = 0;        for (Map.Entry<String, String> entry : data.entrySet()) {            int rowPosACL = 2 * i + 1;            JLabel label = new JLabel(entry.getKey());            JTextField text = new JTextField(entry.getValue());            text.setEditable(false);            GridBagConstraints c1 = new GridBagConstraints();            c1.gridx = 1;            c1.gridy = rowPosACL;            c1.gridwidth = 1;            c1.gridheight = 1;            c1.weightx = 0;            c1.weighty = 0;            c1.anchor = GridBagConstraints.NORTHWEST;            c1.fill = GridBagConstraints.BOTH;            c1.insets = new Insets(5, 5, 5, 5);            c1.ipadx = 0;            c1.ipady = 0;            aclPanel.add(label, c1);            GridBagConstraints c2 = new GridBagConstraints();            c2.gridx = 3;            c2.gridy = rowPosACL;            c2.gridwidth = 1;            c2.gridheight = 1;            c2.weightx = 0;            c2.weighty = 0;            c2.anchor = GridBagConstraints.NORTHWEST;            c2.fill = GridBagConstraints.BOTH;            c2.insets = new Insets(5, 5, 5, 5);            c2.ipadx = 0;            c2.ipady = 0;            aclPanel.add(text, c2);            i++;        }        GridBagConstraints c = new GridBagConstraints();        c.gridx = 1;        c.gridy = rowPos;        c.gridwidth = 1;        c.gridheight = 1;        c.weightx = 1;        c.weighty = 1;        c.anchor = GridBagConstraints.NORTHWEST;        c.fill = GridBagConstraints.NONE;        c.insets = new Insets(5, 5, 5, 5);        c.ipadx = 0;        c.ipady = 0;        aclDataPanel.add(aclPanel, c);    }    NodeViewerACL.this.aclDataPanel.revalidate();    NodeViewerACL.this.aclDataPanel.repaint();}
c95f485026df28f93859f3385ac609f39e9b7627e6245bd975740c045fc5a6b0
setZooInspectorManager
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    if (selectedNode != null) {        if (JOptionPane.showConfirmDialog(NodeViewerData.this, "Are you sure you want to save this node?" + " (this action cannot be reverted)", "Confirm Save", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {            zooInspectorManager.setData(selectedNode, dataArea.getText());        }    }}
e5ef01fa2cf65dfc9fab56435459437471698c703940d8b9a6902680e8c38e95
getTitle
public String getTitle()
{    return "Node Data";}
fde86ad6de584b045d2cc264b23017fe023752c3ff9064ac7c9b60bbfd13b550
nodeSelectionChanged
public void nodeSelectionChanged(List<String> selectedNodes)
{    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<String, Void> worker = new SwingWorker<String, Void>() {            @Override            protected String doInBackground() throws Exception {                return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);            }            @Override            protected void done() {                String data = "";                try {                    data = get();                } catch (InterruptedException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                } catch (ExecutionException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                }                NodeViewerData.this.dataArea.setText(data);            }        };        worker.execute();    }}
4b723aaeb1f097bca7778fee15f988d671b57f2ba74b556f12c0707a438f397b
doInBackground
protected String doInBackground() throws Exception
{    return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    String data = "";    try {        data = get();    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    }    NodeViewerData.this.dataArea.setText(data);}
c95f485026df28f93859f3385ac609f39e9b7627e6245bd975740c045fc5a6b0
setZooInspectorManager
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
e5ef01fa2cf65dfc9fab56435459437471698c703940d8b9a6902680e8c38e95
getTitle
public String getTitle()
{    return "Node Metadata";}
fde86ad6de584b045d2cc264b23017fe023752c3ff9064ac7c9b60bbfd13b550
nodeSelectionChanged
public void nodeSelectionChanged(List<String> selectedNodes)
{    this.metaDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<Map<String, String>, Void> worker = new SwingWorker<Map<String, String>, Void>() {            @Override            protected Map<String, String> doInBackground() throws Exception {                return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);            }            @Override            protected void done() {                Map<String, String> data = null;                try {                    data = get();                } catch (InterruptedException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                } catch (ExecutionException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                }                NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());                JPanel infoPanel = new JPanel();                infoPanel.setBackground(Color.WHITE);                infoPanel.setLayout(new GridBagLayout());                int i = 0;                int rowPos = 0;                for (Map.Entry<String, String> entry : data.entrySet()) {                    rowPos = 2 * i + 1;                    JLabel label = new JLabel(entry.getKey());                    JTextField text = new JTextField(entry.getValue());                    text.setEditable(false);                    GridBagConstraints c1 = new GridBagConstraints();                    c1.gridx = 0;                    c1.gridy = rowPos;                    c1.gridwidth = 1;                    c1.gridheight = 1;                    c1.weightx = 0;                    c1.weighty = 0;                    c1.anchor = GridBagConstraints.WEST;                    c1.fill = GridBagConstraints.HORIZONTAL;                    c1.insets = new Insets(5, 5, 5, 5);                    c1.ipadx = 0;                    c1.ipady = 0;                    infoPanel.add(label, c1);                    GridBagConstraints c2 = new GridBagConstraints();                    c2.gridx = 2;                    c2.gridy = rowPos;                    c2.gridwidth = 1;                    c2.gridheight = 1;                    c2.weightx = 0;                    c2.weighty = 0;                    c2.anchor = GridBagConstraints.WEST;                    c2.fill = GridBagConstraints.HORIZONTAL;                    c2.insets = new Insets(5, 5, 5, 5);                    c2.ipadx = 0;                    c2.ipady = 0;                    infoPanel.add(text, c2);                    i++;                }                GridBagConstraints c = new GridBagConstraints();                c.gridx = 1;                c.gridy = rowPos;                c.gridwidth = 1;                c.gridheight = 1;                c.weightx = 1;                c.weighty = 1;                c.anchor = GridBagConstraints.NORTHWEST;                c.fill = GridBagConstraints.NONE;                c.insets = new Insets(5, 5, 5, 5);                c.ipadx = 0;                c.ipady = 0;                NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);                NodeViewerMetaData.this.metaDataPanel.revalidate();                NodeViewerMetaData.this.metaDataPanel.repaint();            }        };        worker.execute();    }}
a0fa54b08845509c9db5d315ad42af6cfc4bde758ee032309829391a99693732
doInBackground
protected Map<String, String> doInBackground() throws Exception
{    return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    Map<String, String> data = null;    try {        data = get();    } catch (InterruptedException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    } catch (ExecutionException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    }    NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());    JPanel infoPanel = new JPanel();    infoPanel.setBackground(Color.WHITE);    infoPanel.setLayout(new GridBagLayout());    int i = 0;    int rowPos = 0;    for (Map.Entry<String, String> entry : data.entrySet()) {        rowPos = 2 * i + 1;        JLabel label = new JLabel(entry.getKey());        JTextField text = new JTextField(entry.getValue());        text.setEditable(false);        GridBagConstraints c1 = new GridBagConstraints();        c1.gridx = 0;        c1.gridy = rowPos;        c1.gridwidth = 1;        c1.gridheight = 1;        c1.weightx = 0;        c1.weighty = 0;        c1.anchor = GridBagConstraints.WEST;        c1.fill = GridBagConstraints.HORIZONTAL;        c1.insets = new Insets(5, 5, 5, 5);        c1.ipadx = 0;        c1.ipady = 0;        infoPanel.add(label, c1);        GridBagConstraints c2 = new GridBagConstraints();        c2.gridx = 2;        c2.gridy = rowPos;        c2.gridwidth = 1;        c2.gridheight = 1;        c2.weightx = 0;        c2.weighty = 0;        c2.anchor = GridBagConstraints.WEST;        c2.fill = GridBagConstraints.HORIZONTAL;        c2.insets = new Insets(5, 5, 5, 5);        c2.ipadx = 0;        c2.ipady = 0;        infoPanel.add(text, c2);        i++;    }    GridBagConstraints c = new GridBagConstraints();    c.gridx = 1;    c.gridy = rowPos;    c.gridwidth = 1;    c.gridheight = 1;    c.weightx = 1;    c.weighty = 1;    c.anchor = GridBagConstraints.NORTHWEST;    c.fill = GridBagConstraints.NONE;    c.insets = new Insets(5, 5, 5, 5);    c.ipadx = 0;    c.ipady = 0;    NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);    NodeViewerMetaData.this.metaDataPanel.revalidate();    NodeViewerMetaData.this.metaDataPanel.repaint();}
c95f485026df28f93859f3385ac609f39e9b7627e6245bd975740c045fc5a6b0
setZooInspectorManager
public void setZooInspectorManager(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
495b6b5989124efc949a3f34529b7fbda56531013700c2f02e6641f3d5bdd8b8
getTransferData
public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException
{    if (flavor.equals(nodeViewerDataFlavor)) {        return this.getClass().getCanonicalName();    } else {        return null;    }}
c3e0259d578adfc57e42d36646c20b64881a621f3359dbb8b6f78c99e46c0e6a
getTransferDataFlavors
public DataFlavor[] getTransferDataFlavors()
{    return new DataFlavor[] { nodeViewerDataFlavor };}
25f7921e42c8203c0369dcf6fb96e0ee0ec7376e86335d984893f5398a8482ae
isDataFlavorSupported
public boolean isDataFlavorSupported(DataFlavor flavor)
{    return flavor.equals(nodeViewerDataFlavor);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorNodeViewer other = (ZooInspectorNodeViewer) obj;    if (getClass().getCanonicalName() != other.getClass().getCanonicalName()) {        return false;    }    if (getTitle() == null) {        if (other.getTitle() != null)            return false;    } else if (!getTitle().equals(other.getTitle()))        return false;    return true;}
5a814c0210d30c9274417ad81324215375265d5892bb57c0581091b236d2573f
addActionListener
public void addActionListener(Button button, ActionListener actionListener)
{    buttons.get(button).addActionListener(actionListener);}
4e24a2b6838130da0247d70eb262ad0252ffb69d9f108eb827ad2619f20d5a75
getJToolBar
public JToolBar getJToolBar()
{    return toolbar;}
0e503412fadb6a8ee026aa3650a8c13ffb1d4f90d5a1d6d030a452534544a0a4
toggleButtons
public void toggleButtons(boolean connected)
{    for (Button button : buttonsToToggle) {        buttons.get(button).setEnabled(connected != button.enabled);    }}
d4ed25ac8ad321cf30617caf76c4576654e12017af8058c0917f5c720521f0ec
init
private void init()
{    toolbar.setFloatable(false);    for (Button button : Button.values()) {        JButton jbutton = button.createJButton(iconResource);        buttons.put(button, jbutton);        toolbar.add(jbutton);    }}
92b9f83386ea44324ab6306ecccb1821293f87e7b908a7dce83eb8bdccedf3c4
createJButton
public JButton createJButton(IconResource iconResource)
{    JButton jbutton = new JButton(iconResource.get(icon, toolTip));    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorAboutDialog.this.dispose();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorConnectionPropertiesDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File propsFilePath = fileChooser.getSelectedFile();        Properties props = new Properties();        try {            FileReader reader = new FileReader(propsFilePath);            try {                props.load(reader);                loadConnectionProps(props);            } finally {                reader.close();            }        } catch (IOException ex) {            LoggerFactory.getLogger().error("An Error occurred loading connection properties from file", ex);            JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred loading connection properties from file", "Error", JOptionPane.ERROR_MESSAGE);        }        options.revalidate();        options.repaint();    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    Properties connectionProps = getConnectionProps();    try {        zooInspectorPanel.setdefaultConnectionProps(connectionProps);    } catch (IOException ex) {        LoggerFactory.getLogger().error("An Error occurred saving the default connection properties file", ex);        JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred saving the default connection properties file", "Error", JOptionPane.ERROR_MESSAGE);    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();    Properties connectionProps = getConnectionProps();    zooInspectorPanel.connect(connectionProps);}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();}
b1c0a60b774d93f828d30a1a7678436944c783dadc0f0b994c5be12f361811c4
loadConnectionProps
private void loadConnectionProps(Properties props)
{    if (props != null) {        for (Object key : props.keySet()) {            String propsKey = (String) key;            if (components.containsKey(propsKey)) {                JComponent component = components.get(propsKey);                String value = props.getProperty(propsKey);                if (component instanceof JTextField) {                    ((JTextField) component).setText(value);                } else if (component instanceof JComboBox) {                    ((JComboBox) component).setSelectedItem(value);                }            }        }    }}
40e434c3a0d2e3a1c865c785d92fa6b94a4c105d185770bcc17c319b55913950
getConnectionProps
private Properties getConnectionProps()
{    Properties connectionProps = new Properties();    for (Entry<String, JComponent> entry : components.entrySet()) {        String value = null;        JComponent component = entry.getValue();        if (component instanceof JTextField) {            value = ((JTextField) component).getText();        } else if (component instanceof JComboBox) {            value = ((JComboBox) component).getSelectedItem().toString();        }        connectionProps.put(entry.getKey(), value);    }    return connectionProps;}
5adc7e4763920f69b026d1f614ada7539b7f8754d3e2daa34ce37a61776cd6b8
getListCellRendererComponent
public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus)
{    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) value;    JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);    label.setText(viewer.getTitle());    return label;}
782f499a85244a1aa5b9a9a0daaf4db7f29dde7ef65baed4fb16bcd2bed36e2a
canImport
public boolean canImport(TransferHandler.TransferSupport info)
{        if (!info.isDataFlavorSupported(ZooInspectorNodeViewer.nodeViewerDataFlavor)) {        return false;    }    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    if (dl.getIndex() == -1) {        return false;    }    return true;}
65efd9d72459cc1558e385ea21772efdedcde189fd9a596cbd34ed4fa3d943e5
importData
public boolean importData(TransferHandler.TransferSupport info)
{    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    int index = dl.getIndex();    boolean insert = dl.isInsert();        Transferable t = info.getTransferable();    String data;    try {        data = (String) t.getTransferData(ZooInspectorNodeViewer.nodeViewerDataFlavor);    } catch (Exception e) {        return false;    }    try {        ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(data).newInstance();        if (listModel.contains(viewer)) {            listModel.removeElement(viewer);        }        if (insert) {            listModel.add(index, viewer);        } else {            listModel.set(index, viewer);        }        return true;    } catch (Exception e) {        LoggerFactory.getLogger().error("Error instantiating class: " + data, e);        return false;    }}
cdbcf9db518b965ea2f5a918623f794675d37498856ecb0226014ca076361daf
getSourceActions
public int getSourceActions(JComponent c)
{    return MOVE;}
e48704fa2a7547b5ee1db0e2b78a5e723e13c1cae7f5489ff71e21193551a4f5
createTransferable
protected Transferable createTransferable(JComponent c)
{    JList list = (JList) c;    ZooInspectorNodeViewer value = (ZooInspectorNodeViewer) list.getSelectedValue();    return value;}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index - 1);        viewersList.setSelectedValue(viewer, true);    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index + 1);        viewersList.setSelectedValue(viewer, true);    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElement(viewer);        viewersList.setSelectedIndex(index == listModel.size() ? index - 1 : index);    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    String className = newViewerTextField.getText();    if (className == null || className.length() == 0) {        JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Please enter the full class name for a Node Viewer and click the add button", "Input Error", JOptionPane.ERROR_MESSAGE);    } else {        try {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(className).newInstance();            if (listModel.contains(viewer)) {                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Node viewer already exists.  Each node viewer can only be added once.", "Input Error", JOptionPane.ERROR_MESSAGE);            } else {                listModel.addElement(viewer);            }        } catch (Exception ex) {            LoggerFactory.getLogger().error("An error occurred while instaniating the node viewer. ", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "An error occurred while instaniating the node viewer: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showSaveDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File selectedFile = fileChooser.getSelectedFile();        int answer = JOptionPane.YES_OPTION;        if (selectedFile.exists()) {            answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "The specified file already exists.  do you want to overwrite it?", "Confirm Overwrite", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        }        if (answer == JOptionPane.YES_OPTION) {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            List<String> nodeViewersClassNames = new ArrayList<String>();            Object[] modelContents = listModel.toArray();            for (Object o : modelContents) {                nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());            }            try {                manager.saveNodeViewersFile(selectedFile, nodeViewersClassNames);            } catch (IOException ex) {                LoggerFactory.getLogger().error("Error saving node viewer configuration from file.", ex);                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error saving node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);            }        }    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        try {            List<String> nodeViewersClassNames = manager.loadNodeViewersFile(fileChooser.getSelectedFile());            List<ZooInspectorNodeViewer> nodeViewers = new ArrayList<ZooInspectorNodeViewer>();            for (String nodeViewersClassName : nodeViewersClassNames) {                ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(nodeViewersClassName).newInstance();                nodeViewers.add(viewer);            }            DefaultListModel model = new DefaultListModel();            for (ZooInspectorNodeViewer viewer : nodeViewers) {                model.addElement(viewer);            }            viewersList.setModel(model);            panel.revalidate();            panel.repaint();        } catch (Exception ex) {            LoggerFactory.getLogger().error("Error loading node viewer configuration from file.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error loading node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    int answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "Are you sure you want to save this configuration as the default?", "Confirm Set Defaults", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);    if (answer == JOptionPane.YES_OPTION) {        DefaultListModel listModel = (DefaultListModel) viewersList.getModel();        List<String> nodeViewersClassNames = new ArrayList<String>();        Object[] modelContents = listModel.toArray();        for (Object o : modelContents) {            nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());        }        try {            manager.setDefaultNodeViewerConfiguration(nodeViewersClassNames);        } catch (IOException ex) {            LoggerFactory.getLogger().error("Error setting default node viewer configuration.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error setting default node viewer configuration: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    newViewers.clear();    Object[] modelContents = listModel.toArray();    for (Object o : modelContents) {        newViewers.add((ZooInspectorNodeViewer) o);    }    currentViewers.clear();    currentViewers.addAll(newViewers);    for (NodeViewersChangeListener listener : listeners) {        listener.nodeViewersChanged(currentViewers);    }}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();}
bfb0609ef8c8d279ede694bddbfa1dd3b0ed94a8847beba60ae5047cf6f36198
valueChanged
public void valueChanged(ListSelectionEvent e)
{    JButton removeButton = buttons.get(Button.remove);    JButton upButton = buttons.get(Button.up);    JButton downButton = buttons.get(Button.down);    int index = viewersList.getSelectedIndex();    if (index == -1) {        removeButton.setEnabled(false);        upButton.setEnabled(false);        downButton.setEnabled(false);    } else {        removeButton.setEnabled(true);        if (index == 0) {            upButton.setEnabled(false);        } else {            upButton.setEnabled(true);        }        if (index == ((DefaultListModel) viewersList.getModel()).getSize()) {            downButton.setEnabled(false);        } else {            downButton.setEnabled(true);        }    }}
92b9f83386ea44324ab6306ecccb1821293f87e7b908a7dce83eb8bdccedf3c4
createJButton
public JButton createJButton(IconResource iconResource)
{    ImageIcon imageIcon = iconResource.get(icon, toolTip);    JButton jbutton;    if (imageIcon == null) {        jbutton = new JButton(icon);    } else {        jbutton = new JButton(imageIcon);    }    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
7e2b121accee475c89a02cbf00530f9f84c2b6faded473e95250b0101a72dd68
setNodeViewers
public void setNodeViewers(List<ZooInspectorNodeViewer> nodeViewers)
{    this.nodeVeiwers.clear();    this.nodeVeiwers.addAll(nodeViewers);    needsReload.clear();    tabbedPane.removeAll();    for (ZooInspectorNodeViewer nodeViewer : nodeVeiwers) {        nodeViewer.setZooInspectorManager(zooInspectorManager);        needsReload.add(true);        tabbedPane.add(nodeViewer.getTitle(), nodeViewer);    }    this.revalidate();    this.repaint();}
fb7774da5dc4d8ba73b1be8d2d6038844cfd8604bb4c53a255feb7897a7f4370
reloadSelectedViewer
private void reloadSelectedViewer()
{    int index = this.tabbedPane.getSelectedIndex();    if (index != -1 && this.needsReload.get(index)) {        ZooInspectorNodeViewer viewer = this.nodeVeiwers.get(index);        viewer.nodeSelectionChanged(selectedNodes);        this.needsReload.set(index, false);    }}
fc8bbeaca413dfcec2c142591d6c99e6d898ffb6cde1ee6a3020692f732cb832
valueChanged
public void valueChanged(TreeSelectionEvent e)
{    TreePath[] paths = e.getPaths();    selectedNodes.clear();    for (TreePath path : paths) {        boolean appended = false;        StringBuilder sb = new StringBuilder();        Object[] pathArray = path.getPath();        for (Object o : pathArray) {            if (o != null) {                String nodeName = o.toString();                if (nodeName != null) {                    if (nodeName.length() > 0) {                        appended = true;                                                sb.append("/");                        sb.append(o.toString());                    }                }            }        }        if (appended) {            selectedNodes.add(sb.toString());        }    }    for (int i = 0; i < needsReload.size(); i++) {        this.needsReload.set(i, true);    }    reloadSelectedViewer();}
c28cfd2173521c0e207fc871ec0e01e1404fbae3b87a0ec8015218bce4884b5b
stateChanged
public void stateChanged(ChangeEvent e)
{    reloadSelectedViewer();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog zicpd = new ZooInspectorConnectionPropertiesDialog(zooInspectorManager.getLastConnectionProps(), zooInspectorManager.getConnectionPropertiesTemplate(), ZooInspectorPanel.this);    zicpd.setVisible(true);}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    disconnect();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    treeViewer.refreshView();}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorNodeViewersDialog nvd = new ZooInspectorNodeViewersDialog(JOptionPane.getRootFrame(), nodeViewers, listeners, zooInspectorManager, iconResource);    nvd.setVisible(true);}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    ZooInspectorAboutDialog zicpd = new ZooInspectorAboutDialog(JOptionPane.getRootFrame(), iconResource);    zicpd.setVisible(true);}
9c3b5ef0722ce583f6fbc164df67f5b57c62e67721bf2fbbc2c0b9ff2456f2fd
connect
public void connect(final Properties connectionProps)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            zooInspectorManager.setLastConnectionProps(connectionProps);            return zooInspectorManager.connect(connectionProps);        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.refreshView();                    toolbar.toggleButtons(true);                } else {                    JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            }        }    };    worker.execute();}
7a78e0764277b726e816229b2a7459055bb1cdfa06d5b358d09b04e15fc57955
doInBackground
protected Boolean doInBackground() throws Exception
{    zooInspectorManager.setLastConnectionProps(connectionProps);    return zooInspectorManager.connect(connectionProps);}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    try {        if (get()) {            treeViewer.refreshView();            toolbar.toggleButtons(true);        } else {            JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    }}
0dba3948e03692823445b16cdfa3dd8b6577a858c451983c8276e1dab61136cc
disconnect
public void disconnect()
{    disconnect(false);}
154ef05c5797f20ee01a3e8dc75409912476ec02dd0d05431ca9ece65f656946
disconnect
public void disconnect(boolean wait)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            return ZooInspectorPanel.this.zooInspectorManager.disconnect();        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.clearView();                    toolbar.toggleButtons(false);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    };    worker.execute();    if (wait) {        while (!worker.isDone()) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    }}
7a78e0764277b726e816229b2a7459055bb1cdfa06d5b358d09b04e15fc57955
doInBackground
protected Boolean doInBackground() throws Exception
{    return ZooInspectorPanel.this.zooInspectorManager.disconnect();}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    try {        if (get()) {            treeViewer.clearView();            toolbar.toggleButtons(false);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }}
985cd9b45a2e43c2d1ece2c81b7dd69dd888533fff128267844c9bcd07f48844
nodeViewersChanged
public void nodeViewersChanged(List<ZooInspectorNodeViewer> newViewers)
{    this.nodeViewersPanel.setNodeViewers(newViewers);}
f488a17f769ca1ef93b611ec3bd32f049f5c697d3e52eab644895e46d6de7e58
setdefaultConnectionProps
public void setdefaultConnectionProps(Properties connectionProps) throws IOException
{    this.zooInspectorManager.saveDefaultConnectionFile(connectionProps);}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.addWatchers(selectedNodes, ZooInspectorTreeViewer.this);}
b383c4a073cb193838350745a02cbc37fea526ebea3aad6d1cc1545c45f38574
actionPerformed
public void actionPerformed(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.removeWatchers(selectedNodes);}
dd523f8856c41188c23550333b7a94aceca2198495314fa6c3820ca28530cb9c
mouseClicked
public void mouseClicked(MouseEvent e)
{    if (e.isPopupTrigger() || e.getButton() == MouseEvent.BUTTON3) {                                popupMenu.removeAll();        popupMenu.add(addNode);        popupMenu.add(deleteNode);        popupMenu.add(addNotify);        popupMenu.add(removeNotify);        popupMenu.show(ZooInspectorTreeViewer.this, e.getX(), e.getY());    }}
33e31d5783452e86c43de3a6c3cd6766fa9132eacb12919f925c54b64aaecac6
refreshView
public void refreshView()
{    final Set<TreePath> expandedNodes = new LinkedHashSet<TreePath>();    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {        TreePath path = tree.getPathForRow(i);        if (tree.isExpanded(path)) {            expandedNodes.add(path);        }    }    final TreePath[] selectedNodes = tree.getSelectionPaths();    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));            return true;        }        @Override        protected void done() {            for (TreePath path : expandedNodes) {                tree.expandPath(path);            }            tree.getSelectionModel().setSelectionPaths(selectedNodes);        }    };    worker.execute();}
7a78e0764277b726e816229b2a7459055bb1cdfa06d5b358d09b04e15fc57955
doInBackground
protected Boolean doInBackground() throws Exception
{    tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));    return true;}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    for (TreePath path : expandedNodes) {        tree.expandPath(path);    }    tree.getSelectionModel().setSelectionPaths(selectedNodes);}
b0061e1d419ddfe7ff80fa5b70357888ff50de60f46ee1c63783d0b9b64a24c4
clearView
public void clearView()
{    tree.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));}
b042946be1a48b6423f77f6ae61baeb2b8caa4ed1f2c556e8132419575f0a49c
children
public Enumeration<TreeNode> children()
{    List<String> children = zooInspectorManager.getChildren(this.nodePath);    Collections.sort(children);    List<TreeNode> returnChildren = new ArrayList<TreeNode>();    for (String child : children) {        returnChildren.add(new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this));    }    return Collections.enumeration(returnChildren);}
1ba81a1b810618775f80b02f822eafbae32a44a6c3bbeebf18258d6aa020e775
getAllowsChildren
public boolean getAllowsChildren()
{    return zooInspectorManager.isAllowsChildren(this.nodePath);}
598969685b7ebc746a174c1e7e28eea432537231e628779569704222e1df4f48
getChildAt
public TreeNode getChildAt(int childIndex)
{    String child = zooInspectorManager.getNodeChild(this.nodePath, childIndex);    if (child != null) {        return new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this);    }    return null;}
135f41e3cc60df9c914c56b4b8432fe2dd8f4354ffd145008b488c9a0a4c69f8
getChildCount
public int getChildCount()
{    return zooInspectorManager.getNumChildren(this.nodePath);}
028274a93b9298f10b90ca7558bccb6bfa80ac59dfc24800f56470302e9b8650
getIndex
public int getIndex(TreeNode node)
{    return zooInspectorManager.getNodeIndex(this.nodePath);}
a50763087273e03281bfba7f9e9fb48bb3d4ee911f26921308a285dce3bc26d9
getParent
public TreeNode getParent()
{    return this.parent;}
28bf92fbf201e74de25feaf287fe7bc9b97f32448c500fb022db2a994f08a86a
isLeaf
public boolean isLeaf()
{    return !zooInspectorManager.hasChildren(this.nodePath);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.nodeName;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + getOuterType().hashCode();    result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());    result = prime * result + ((parent == null) ? 0 : parent.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorTreeNode other = (ZooInspectorTreeNode) obj;    if (!getOuterType().equals(other.getOuterType()))        return false;    if (nodePath == null) {        if (other.nodePath != null)            return false;    } else if (!nodePath.equals(other.nodePath))        return false;    if (parent == null) {        if (other.parent != null)            return false;    } else if (!parent.equals(other.parent))        return false;    return true;}
d1275f865cf00bc50a241331ba510f4d40e020185e4e13291a51874189a62644
getOuterType
private ZooInspectorTreeViewer getOuterType()
{    return ZooInspectorTreeViewer.this;}
9b09867abcba9b7e4034164d0739d27e7cfdd8b9a3bbdef631c9cf68dd5e077a
getSelectedNodes
public List<String> getSelectedNodes()
{    TreePath[] paths = tree.getSelectionPaths();    List<String> selectedNodes = new ArrayList<String>();    if (paths != null) {        for (TreePath path : paths) {            StringBuilder sb = new StringBuilder();            Object[] pathArray = path.getPath();            for (Object o : pathArray) {                String nodeName = o.toString();                if (nodeName.length() > 0) {                    sb.append("/");                    sb.append(o.toString());                }            }            selectedNodes.add(sb.toString());        }    }    return selectedNodes;}
63c3336c2dd0765f8a633c02af3512710e33c8691cc477899b35b769ee8aae91
processEvent
public void processEvent(String nodePath, String eventType, Map<String, String> eventInfo)
{    StringBuilder sb = new StringBuilder();    sb.append("Node: ");    sb.append(nodePath);    sb.append("\nEvent: ");    sb.append(eventType);    if (eventInfo != null) {        for (Map.Entry<String, String> entry : eventInfo.entrySet()) {            sb.append("\n");            sb.append(entry.getKey());            sb.append(": ");            sb.append(entry.getValue());        }    }    this.toasterManager.showToaster(toasterIcon, sb.toString());}
11aa1ac9650fc1160c0e71980870a458e59cd9951eb04c11f5fc6c8a0fd4080c
getLogger
public static org.slf4j.Logger getLogger()
{    return logger;}
3e144af2df8b0d1aa993f884458f92a1c9e541ae7979991dce546acb4981f117
load
public List<String> load(String nodePath) throws Exception
{    return getChildren(nodePath);}
76506c87ecb90dddbdd0100ae0b61d7874b74ad84b1139cf26ce29166508614d
getChildren
public List<String> getChildren(String nodePath)
{    try {        Stat s = zooKeeper.exists(nodePath, false);        if (s != null) {            List<String> children = this.zooKeeper.getChildren(nodePath, false);            Collections.sort(children);            return children;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving child of node: " + nodePath, e);    }    return null;}
ec5b947f44dd9dd852cbc05d3c2241f0582fa990e65a187f8972a7f508bbdefa
getNodeChild
public String getNodeChild(String nodePath, int index)
{    List<String> childNodes = null;    try {        childNodes = nodes.get(nodePath);        return childNodes.get(index);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred retrieving child " + index + "of node: " + nodePath, e);    }    return null;}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return key;}
1ccb95d9d0b86425ab1f1d0da9ec56e6ea0e4f118d4059bab00823cc75ac1a31
setKey
public void setKey(K key)
{    this.key = key;}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return value;}
f3b7bc10b50507b4ebcfd7933f905497eb338e8546a2cef76c532b2e800cc12b
setValue
public void setValue(V value)
{    this.value = value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Pair [" + key + ", " + value + "]";}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((key == null) ? 0 : key.hashCode());    result = prime * result + ((value == null) ? 0 : value.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    Pair<?, ?> other = (Pair<?, ?>) obj;    if (key == null) {        if (other.key != null)            return false;    } else if (!key.equals(other.key))        return false;    if (value == null) {        if (other.value != null)            return false;    } else if (!value.equals(other.value))        return false;    return true;}
6772b5a567625b61b08e480d8f0c751227ef77e74c430756f64cd0c18b37dc45
connect
public boolean connect(Properties connectionProps)
{    try {        if (this.zooKeeper == null) {            String connectString = connectionProps.getProperty(CONNECT_STRING);            String sessionTimeout = connectionProps.getProperty(SESSION_TIMEOUT);            String encryptionManager = connectionProps.getProperty(DATA_ENCRYPTION_MANAGER);            String authScheme = connectionProps.getProperty(AUTH_SCHEME_KEY);            String authData = connectionProps.getProperty(AUTH_DATA_KEY);            if (connectString == null || sessionTimeout == null) {                throw new IllegalArgumentException("Both connect string and session timeout are required.");            }            if (encryptionManager == null) {                this.encryptionManager = new BasicDataEncryptionManager();            } else {                Class<?> clazz = Class.forName(encryptionManager);                if (Arrays.asList(clazz.getInterfaces()).contains(DataEncryptionManager.class)) {                    this.encryptionManager = (DataEncryptionManager) Class.forName(encryptionManager).newInstance();                } else {                    throw new IllegalArgumentException("Data encryption manager must implement DataEncryptionManager interface");                }            }            this.connectString = connectString;            this.sessionTimeout = Integer.valueOf(sessionTimeout);            this.zooKeeper = new ZooKeeperRetry(connectString, Integer.valueOf(sessionTimeout), new Watcher() {                public void process(WatchedEvent event) {                    if (event.getState() == KeeperState.Expired) {                        connected = false;                    }                }            });            if (authData != null && authData.length() > 0) {                this.zooKeeper.addAuthInfo(authScheme, authData.getBytes());            }            ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);            connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();        }    } catch (Exception e) {        connected = false;        e.printStackTrace();    }    if (!connected) {        disconnect();    } else {        this.nodesCache = new NodesCache(zooKeeper);    }    return connected;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        connected = false;    }}
27d1543870ca53aae0cfec9099d4a732d7ebd2ab0e1e6bbd80f0a65198574afb
disconnect
public boolean disconnect()
{    try {        if (this.zooKeeper != null) {            this.zooKeeper.close();            this.zooKeeper = null;            connected = false;            removeWatchers(this.watchers.keySet());            return true;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }    return false;}
76506c87ecb90dddbdd0100ae0b61d7874b74ad84b1139cf26ce29166508614d
getChildren
public List<String> getChildren(String nodePath)
{    if (connected) {        return nodesCache.getChildren(nodePath);    }    return null;}
49236fa613e8d0b3d339ad62dc80c4834cddf98a8bc19f79ae9b9a34e9d0368f
getData
public String getData(String nodePath)
{    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return this.encryptionManager.decryptData(zooKeeper.getData(nodePath, false, s));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting data for node: " + nodePath, e);        }    }    return null;}
10d9cf3ab7c92299f7d9c6626ac3c2890869fbb5da660c33646c7381b4944831
getNodeChild
public String getNodeChild(String nodePath, int childIndex)
{    if (connected) {        return this.nodesCache.getNodeChild(nodePath, childIndex);    }    return null;}
41143fc7dfbade1118fd338652f99190d99a27c0892ab609a5bea40d0fe6a37c
getNodeIndex
public int getNodeIndex(String nodePath)
{    if (connected) {        int index = nodePath.lastIndexOf("/");        if (index == -1 || (!nodePath.equals("/") && nodePath.charAt(nodePath.length() - 1) == '/')) {            throw new IllegalArgumentException("Invalid node path: " + nodePath);        }        String parentPath = nodePath.substring(0, index);        String child = nodePath.substring(index + 1);        if (parentPath != null && parentPath.length() > 0) {            List<String> children = this.nodesCache.getChildren(parentPath);            if (children != null) {                return children.indexOf(child);            }        }    }    return -1;}
830844c7e7bdf3490efd0bff3ccf779643e9d4feb7e6cb8f8f12f3546ad18f2e
getACLs
public List<Map<String, String>> getACLs(String nodePath)
{    List<Map<String, String>> returnACLs = new ArrayList<Map<String, String>>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<ACL> acls = zooKeeper.getACL(nodePath, s);                for (ACL acl : acls) {                    Map<String, String> aclMap = new LinkedHashMap<String, String>();                    aclMap.put(ACL_SCHEME, acl.getId().getScheme());                    aclMap.put(ACL_ID, acl.getId().getId());                    StringBuilder sb = new StringBuilder();                    int perms = acl.getPerms();                    boolean addedPerm = false;                    if ((perms & Perms.READ) == Perms.READ) {                        sb.append("Read");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.WRITE) == Perms.WRITE) {                        sb.append("Write");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.CREATE) == Perms.CREATE) {                        sb.append("Create");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.DELETE) == Perms.DELETE) {                        sb.append("Delete");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.ADMIN) == Perms.ADMIN) {                        sb.append("Admin");                        addedPerm = true;                    }                    aclMap.put(ACL_PERMS, sb.toString());                    returnACLs.add(aclMap);                }            }        } catch (InterruptedException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        } catch (KeeperException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        }    }    return returnACLs;}
8a03c5c33e9c2260d10f1684414db4c51f14001b5a41c1c689ac0b5bb52b628e
getNodeMeta
public Map<String, String> getNodeMeta(String nodePath)
{    Map<String, String> nodeMeta = new LinkedHashMap<String, String>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                nodeMeta.put(A_VERSION, String.valueOf(s.getAversion()));                nodeMeta.put(C_TIME, String.valueOf(s.getCtime()));                nodeMeta.put(C_VERSION, String.valueOf(s.getCversion()));                nodeMeta.put(CZXID, String.valueOf(s.getCzxid()));                nodeMeta.put(DATA_LENGTH, String.valueOf(s.getDataLength()));                nodeMeta.put(EPHEMERAL_OWNER, String.valueOf(s.getEphemeralOwner()));                nodeMeta.put(M_TIME, String.valueOf(s.getMtime()));                nodeMeta.put(MZXID, String.valueOf(s.getMzxid()));                nodeMeta.put(NUM_CHILDREN, String.valueOf(s.getNumChildren()));                nodeMeta.put(PZXID, String.valueOf(s.getPzxid()));                nodeMeta.put(VERSION, String.valueOf(s.getVersion()));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred retrieving meta data for node: " + nodePath, e);        }    }    return nodeMeta;}
1e9af86f411ebc618eca84f6173f87eca1763b1d440a7ac8a21e76067ecd96fe
getNumChildren
public int getNumChildren(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getNumChildren();            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting the number of children of node: " + nodePath, e);        }    }    return -1;}
8cb3efbbe1165eea79eb9cef361081e7e12bf5a93a85e99b300f00e4d10b77f8
hasChildren
public boolean hasChildren(String nodePath)
{    return getNumChildren(nodePath) > 0;}
73bfa417697c50d656b3c7f5529a982c22cc1393ba5ce36092bb6d2bdf20239b
isAllowsChildren
public boolean isAllowsChildren(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getEphemeralOwner() == 0;            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred determining whether node is allowed children: " + nodePath, e);        }    }    return false;}
a72c8be5094001a408e7f6da69cc1d04df7121441e291809ed8fe21983999c84
getSessionMeta
public Map<String, String> getSessionMeta()
{    Map<String, String> sessionMeta = new LinkedHashMap<String, String>();    try {        if (zooKeeper != null) {            sessionMeta.put(SESSION_ID, String.valueOf(zooKeeper.getSessionId()));            sessionMeta.put(SESSION_STATE, String.valueOf(zooKeeper.getState().toString()));            sessionMeta.put(CONNECT_STRING, this.connectString);            sessionMeta.put(SESSION_TIMEOUT, String.valueOf(this.sessionTimeout));        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving session meta data.", e);    }    return sessionMeta;}
c5c3e55731f1b1afa3129e1d3c2278ff6791cb162464f2c082d621e1baba919c
createNode
public boolean createNode(String parent, String nodeName)
{    if (connected) {        try {            String[] nodeElements = nodeName.split("/");            for (String nodeElement : nodeElements) {                String node = parent + "/" + nodeElement;                Stat s = zooKeeper.exists(node, false);                if (s == null) {                    zooKeeper.create(node, this.encryptionManager.encryptData(null), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    parent = node;                }            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred creating node: " + parent + "/" + nodeName, e);        }    }    return false;}
e36f09cfcc911ebb8b01534722af840a9f3a29dbd9339d2a09b151dc14d0dbfd
deleteNode
public boolean deleteNode(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<String> children = zooKeeper.getChildren(nodePath, false);                for (String child : children) {                    String node = nodePath + "/" + child;                    deleteNode(node);                }                zooKeeper.delete(nodePath, -1);            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred deleting node: " + nodePath, e);        }    }    return false;}
de5d14e52daec5a84a9754e02f39d61439c15a130a44419b96a49f0c3d55df0a
setData
public boolean setData(String nodePath, String data)
{    if (connected) {        try {            zooKeeper.setData(nodePath, this.encryptionManager.encryptData(data), -1);            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred setting data for node: " + nodePath, e);        }    }    return false;}
c49216c35e0709c7f1c9aaf6a4945ee17750adb99590f9577ab8bb1bf05a81cc
getConnectionPropertiesTemplate
public Pair<Map<String, List<String>>, Map<String, String>> getConnectionPropertiesTemplate()
{    Map<String, List<String>> template = new LinkedHashMap<String, List<String>>();    template.put(CONNECT_STRING, Arrays.asList(new String[] { defaultHosts }));    template.put(SESSION_TIMEOUT, Arrays.asList(new String[] { defaultTimeout }));    template.put(DATA_ENCRYPTION_MANAGER, Arrays.asList(new String[] { defaultEncryptionManager }));    template.put(AUTH_SCHEME_KEY, Arrays.asList(new String[] { defaultAuthScheme }));    template.put(AUTH_DATA_KEY, Arrays.asList(new String[] { defaultAuthValue }));    Map<String, String> labels = new LinkedHashMap<String, String>();    labels.put(CONNECT_STRING, "Connect String");    labels.put(SESSION_TIMEOUT, "Session Timeout");    labels.put(DATA_ENCRYPTION_MANAGER, "Data Encryption Manager");    labels.put(AUTH_SCHEME_KEY, "Authentication Scheme");    labels.put(AUTH_DATA_KEY, "Authentication Data");    return new Pair<Map<String, List<String>>, Map<String, String>>(template, labels);}
382d2e878155c064e60a51f4c52004a48dce1977720de0222c06862c3d3d91ac
addWatchers
public void addWatchers(Collection<String> selectedNodes, NodeListener nodeListener)
{        if (connected) {        for (String node : selectedNodes) {            if (!watchers.containsKey(node)) {                try {                    watchers.put(node, new NodeWatcher(node, nodeListener, zooKeeper));                } catch (Exception e) {                    LoggerFactory.getLogger().error("Error occurred adding node watcher for node: " + node, e);                }            }        }    }}
83bcb41f03a8044dd96742ddd9d4a58b132c34b4596fe2886d338acc2f99623e
removeWatchers
public void removeWatchers(Collection<String> selectedNodes)
{        if (connected) {        for (String node : selectedNodes) {            if (watchers.containsKey(node)) {                NodeWatcher watcher = watchers.remove(node);                if (watcher != null) {                    watcher.stop();                }            }        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (!closed) {        try {            if (event.getType() != EventType.NodeDeleted) {                Stat s = zooKeeper.exists(nodePath, this);                if (s != null) {                    zookeeper.getChildren(nodePath, this);                }            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred re-adding node watcherfor node " + nodePath, e);        }        nodeListener.processEvent(event.getPath(), event.getType().name(), null);    }}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    this.closed = true;}
3f815cc556c62889b32179568dcbab83740c1d5b598800f53a36881e24437984
loadNodeViewersFile
public List<String> loadNodeViewersFile(File selectedFile) throws IOException
{    List<String> result = new ArrayList<String>();    if (defaultNodeViewersFile.exists()) {        FileReader reader = new FileReader(selectedFile);        try {            BufferedReader buff = new BufferedReader(reader);            try {                while (buff.ready()) {                    String line = buff.readLine();                    if (line != null && line.length() > 0 && !line.startsWith("#")) {                        result.add(line);                    }                }            } finally {                buff.close();            }        } finally {            reader.close();        }    }    return result;}
b44228f6fe09906dc5925faba2eb113dbeedf0eaff3ed9e71b54f67026351519
loadDefaultConnectionFile
private void loadDefaultConnectionFile() throws IOException
{    if (defaultConnectionFile.exists()) {        Properties props = new Properties();        FileReader reader = new FileReader(defaultConnectionFile);        try {            props.load(reader);        } finally {            reader.close();        }        defaultEncryptionManager = props.getProperty(DATA_ENCRYPTION_MANAGER) == null ? "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager" : props.getProperty(DATA_ENCRYPTION_MANAGER);        defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ? "5000" : props.getProperty(SESSION_TIMEOUT);        defaultHosts = props.getProperty(CONNECT_STRING) == null ? "localhost:2181" : props.getProperty(CONNECT_STRING);        defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ? "" : props.getProperty(AUTH_SCHEME_KEY);        defaultAuthValue = props.getProperty(AUTH_DATA_KEY) == null ? "" : props.getProperty(AUTH_DATA_KEY);    } else {        defaultEncryptionManager = "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager";        defaultTimeout = "5000";        defaultHosts = "localhost:2181";        defaultAuthScheme = "";        defaultAuthValue = "";    }}
818bfb877ff6cb2d96f48eed8b1a3e4c189351c2329bde74c138861b952bda77
saveDefaultConnectionFile
public void saveDefaultConnectionFile(Properties props) throws IOException
{    File defaultDir = defaultConnectionFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    if (!defaultConnectionFile.exists()) {        if (!defaultConnectionFile.createNewFile()) {            throw new IOException("Failed to create default connection file: " + defaultConnectionFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(defaultConnectionFile);    try {        props.store(writer, "Default connection for ZooInspector");    } finally {        writer.close();    }}
4a5e523e2db6b7d91c6d41b32defe034e98ec1f13876b0ef049780488a75f8b9
saveNodeViewersFile
public void saveNodeViewersFile(File selectedFile, List<String> nodeViewersClassNames) throws IOException
{    if (!selectedFile.exists()) {        if (!selectedFile.createNewFile()) {            throw new IOException("Failed to create node viewers configuration file: " + selectedFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(selectedFile);    try {        BufferedWriter buff = new BufferedWriter(writer);        try {            for (String nodeViewersClassName : nodeViewersClassNames) {                buff.append(nodeViewersClassName);                buff.append("\n");            }        } finally {            buff.flush();            buff.close();        }    } finally {        writer.close();    }}
b3f5c9cf8c1d432e040f595f4df47bb197972af4253db59c7ef6d4c9692a17c8
setDefaultNodeViewerConfiguration
public void setDefaultNodeViewerConfiguration(List<String> nodeViewersClassNames) throws IOException
{    File defaultDir = defaultNodeViewersFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    saveNodeViewersFile(defaultNodeViewersFile, nodeViewersClassNames);}
583bceb04779c27e6c824735ef8f45a72d5379003af982a43758c40d930509c0
getDefaultNodeViewerConfiguration
public List<String> getDefaultNodeViewerConfiguration() throws IOException
{    List<String> defaultNodeViewers = loadNodeViewersFile(defaultNodeViewersFile);    if (defaultNodeViewers.isEmpty()) {        LoggerFactory.getLogger().warn("List of default node viewers is empty");    }    return defaultNodeViewers;}
3f6e271be5432f8937685b1cf69bb1474a1add79f7f472356657dfc8de1d2a04
getLastConnectionProps
public Properties getLastConnectionProps()
{    return this.lastConnectionProps;}
f1a8cbeffad9938268efa87989032a5f891e85d1cf6d7cd5f20d37679ad3c159
setLastConnectionProps
public void setLastConnectionProps(Properties connectionProps)
{    this.lastConnectionProps = connectionProps;}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    try {        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());        JFrame frame = new JFrame("ZooInspector");        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        iconResource = new IconResource();        final ZooInspectorPanel zooInspectorPanel = new ZooInspectorPanel(new ZooInspectorManagerImpl(), iconResource);        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosed(WindowEvent e) {                super.windowClosed(e);                zooInspectorPanel.disconnect(true);            }        });        frame.setContentPane(zooInspectorPanel);        frame.setSize(1024, 768);        frame.setVisible(true);    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred loading ZooInspector", e);        JOptionPane.showMessageDialog(null, "ZooInspector failed to start: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);    }}
e851993a02da172eb794983f6c8f2b80a3a5d2b864f349847a7262a45fc0fef4
windowClosed
public void windowClosed(WindowEvent e)
{    super.windowClosed(e);    zooInspectorPanel.disconnect(true);}
3cc59dbf86e75b9868827b28362533d64c83a39c2f84caf36843b9026a5d4bcf
close
public synchronized void close() throws InterruptedException
{    this.closed = true;    super.close();}
5ebae890b81a326bfcbf55727d83b51602e7fb43affe83162d641715d7030c97
create
public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.create(path, data, acl, createMode);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) != null) {                return path;            }        } catch (KeeperException.NodeExistsException e) {            return path;        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
5b715c295e775c1665b085eadb3c6e145595dcec7f3be364576fd8f4aa0773df
delete
public void delete(String path, int version) throws InterruptedException, KeeperException
{    int count = 0;    do {        try {            super.delete(path, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) == null) {                return;            }        } catch (KeeperException.NoNodeException e) {            break;        }    } while (!closed && (limit == -1 || count++ < limit));}
868dfd77a484670f74667abdbd12580f640119fb3dacec3d2de458e97d1ffb22
exists
public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
3038c206e96fc23fe694158d1dac7ba82803701e523d2e75cdbe07906de7d873
exists
public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
b32eac630bc5278bad6425d93efe9fd5c92757e0b4d5aacbe1c5d2077c5ce124
getACL
public List<ACL> getACL(String path, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getACL(path, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
f7b02a66840853537bb3bc54bd93b5234760ce66ca22c1a3c53335e12359a660
getChildren
public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
380451ad47e5d8d64b3e9dadfa284309dd43884e8d627be03422f828eff90f87
getChildren
public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
a95f6f0f6b4145780a00b91222b7c85c01b88f45de2e4edd3a1ddefbd85a2ed8
getData
public byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watch ? watcher : null, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
b4b00666ea4f9ea522302a55ef186a48100b8e08880493f8faf00ac694a0da14
getData
public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watcher, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
50b1f9ef0abf94a8c7329f06e5abdb7c1b5e0cd48e142bb350928a3f061e4571
setACL
public Stat setACL(String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setACL(path, acl, aclVersion);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getACL(path, s).equals(acl)) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
903fa9ea0d8bc39492c0ed3ff338d6b9fb0a3e86ecb84edde075a965dd25aa25
setData
public Stat setData(String path, byte[] data, int version) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setData(path, data, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getData(path, false, s) == data) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
28e1e9dc89225767b58a8e304235585883d071e4f6e1df9d23830d268ede9812
setRetryLimit
public void setRetryLimit(int limit)
{    this.limit = limit;}
3f46bb34558791375fb0cf07dbbb5bb6cf4de943d13bf0431f9d57248ff07a27
testConnection
public boolean testConnection()
{    int count = 0;    do {        try {            return super.exists("/", null) != null;        } catch (Exception e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (count++ < 5);    return false;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    org.openjdk.jmh.Main.main(args);}
6a917c8cd92638416f92caa0abf5969788f9281422c8fdc6a0ed5580a4f8bc4f
createWatchManager
 static IWatchManager createWatchManager(String className) throws Exception
{    Class clazz = Class.forName("org.apache.zookeeper.server.watch." + className);    return (IWatchManager) clazz.newInstance();}
aa6d014ffb3fff974f7bfbfa0c022e3831a1e775f311daa869ca562324ac4889
forceGC
 static void forceGC()
{    int gcTimes = 3;    for (int i = 0; i < gcTimes; i++) {        try {            System.gc();            Thread.currentThread().sleep(1000);            System.runFinalization();            Thread.currentThread().sleep(1000);        } catch (InterruptedException ex) {        /* ignore */        }    }}
0c74332bee3b8d2b836137b426078ae5098bac16cd01740b584f48f2b84b540a
getMemoryUse
 static long getMemoryUse()
{    forceGC();    long totalMem = Runtime.getRuntime().totalMemory();    forceGC();    long freeMem = Runtime.getRuntime().freeMemory();    return totalMem - freeMem;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    paths = new String[pathCount];    for (int i = 0; i < paths.length; i++) {        paths[i] = pathPrefix + i;    }    watchesAdded = 0;    watchManager = createWatchManager(watchManagerClass);    memWhenSetup = getMemoryUse();}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");}
ae16f40f4179772a38458bbf450cffbe04311d45266e646467e5d1faf1bb1a97
testAddConcentrateWatch
public void testAddConcentrateWatch(IterationState state) throws Exception
{    Watcher watcher = new DumbWatcher();        for (String path : state.paths) {        if (state.watchManager.addWatch(path, watcher)) {            state.watchesAdded++;        }    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    initialize();    prepare();}
27582e64608758599b15c311599903b568923deed184fffc39a9c91cb70b3d65
initialize
 void initialize() throws Exception
{    if (paths == null || paths.length != pathCount) {        paths = new String[pathCount];        for (int i = 0; i < pathCount; i++) {            paths[i] = pathPrefix + i;        }    }    if (watchers == null || watchers.length != watcherCount) {        watchers = new Watcher[watcherCount];        for (int i = 0; i < watcherCount; i++) {            watchers[i] = new DumbWatcher();        }    }    if (watchManager == null || !watchManager.getClass().getSimpleName().contains(watchManagerClass)) {        watchManager = createWatchManager(watchManagerClass);    }}
41bc58f12683fd8e4b3bb44d8916c2fd18fe681fe96741347c2e021d43f482dd
prepare
 void prepare()
{    for (String path : paths) {        for (Watcher watcher : watchers) {            watchManager.addWatch(path, watcher);        }    }}
eadf060138d53ac910826f45e1224c924f2c01623209dcd8553edeb9dc5016fd
testTriggerConcentrateWatch
public void testTriggerConcentrateWatch(InvocationState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
f542f82c964a89fc9bbd653cf6eb1d7b239b8f16b2a3715c4fbfb5ff4a41e9da
prepare
public void prepare()
{    watchesAdded = 0;    memWhenSetup = getMemoryUse();}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million sparse watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");        for (String path : paths) {        watchManager.triggerWatch(path, event);    }}
4ab15335b49a736780ba922733833e03d34addac3c6f6c39b64f024e74281e3d
testAddSparseWatch
public void testAddSparseWatch(AddSparseWatchState state) throws Exception
{        for (Watcher watcher : state.watchers) {        if (state.watchManager.addWatch(state.paths[0], watcher)) {            state.watchesAdded++;        }    }        for (String path : state.paths) {        if (state.watchManager.addWatch(path, state.watchers[0])) {            state.watchesAdded++;        }    }}
f542f82c964a89fc9bbd653cf6eb1d7b239b8f16b2a3715c4fbfb5ff4a41e9da
prepare
public void prepare()
{        for (Watcher watcher : watchers) {        watchManager.addWatch(paths[0], watcher);    }        for (String path : paths) {        watchManager.addWatch(path, watchers[0]);    }}
c4f6b5a3291503fd0d8b3fef5003d2e2333f35299d3a172437c7bbf479c8522d
testTriggerSparseWatch
public void testTriggerSparseWatch(TriggerSparseWatchState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    if (!fakeMachines) {        zk = new ZooKeeper(zkHostPort, 15000, new Watcher() {            public void process(WatchedEvent e) {            }        });        im = new InstanceManager(zk, prefix);    }}
33ef80059d7e7a7518d8573f1a5b03b2c696de96c32f61b1b2b1e2ffdcd0b9cd
process
public void process(WatchedEvent e)
{}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (null != im) {        im.close();    }}
1a1a2b8d1542b6b4808be0620f524ce35f718bfec2737d977615ba0a5c28e149
getHostPort
public String getHostPort()
{    return serverHostPort;}
3c3e8e773542a2abb0854ce2fd53bd6c838d8b7189061dcc5c39b21bbce4fd09
getServerCount
public int getServerCount()
{    return serverCount;}
8688c9fbc7059b0cca24d1b7866d1480bec4855ac67d44d1e446254d6aab9daf
getClientCount
public int getClientCount()
{    return clientCount;}
193dcbd9ba4dc9f67a8629c59018376e6ac8c495a889fa19d458ebeb80fe713f
startServers
public void startServers() throws IOException
{    for (int i = 0; i < serverCount; i++) {        startServer(i);    }}
e9975b491a7b7d0cbcb1325d0279a0f632e7643a6382b5240ac60b67534e67ee
stopServers
public void stopServers() throws IOException
{    for (int i = 0; i < serverCount; i++) {        stopServer(i);    }}
ce553d73b1a1beb6a667f85c3ffd45e221177cd79e69a0fcc93a4c716cb7c87d
startClients
public void startClients() throws IOException
{    for (int i = 0; i < clientCount; i++) {        startClient(i);    }}
ee0e834940b5b3f480ef605747b7cfea7143e91e583611734a46ec466101dac8
stopClients
public void stopClients() throws IOException
{    for (int i = 0; i < clientCount; i++) {        stopClient(i);    }}
9784da7a4bb509b6a1f13ff198032eb9ac08db215371494166ddfe3d2ec7a9ea
configureServers
public void configureServers(int count) throws Exception
{    serverCount = count;    if (fakeMachines) {        fakeConfigureServers(count);    } else {        distributedConfigureServers(count);    }}
e8be4154d061e60db0e9ffe13d571a6ef138d65315f44f670a2896662a75e208
distributedConfigureServers
private void distributedConfigureServers(int count) throws IOException
{    StringBuilder sbClient = new StringBuilder();    StringBuilder sbServer = new StringBuilder();    try {        for (int i = 0; i < count; i++) {            String[] r = QuorumPeerInstance.createServer(im, i);            if (i > 0) {                sbClient.append(',');                sbServer.append(',');            }                        sbClient.append(r[0]);                        sbServer.append(r[1]);                        sbServer.append(";" + (r[0].split(":"))[1]);        }        serverHostPort = sbClient.toString();        quorumHostPort = sbServer.toString();    } catch (Exception e) {        IOException ioe = new IOException(e.getMessage());        ioe.setStackTrace(e.getStackTrace());        throw ioe;    }}
aebbcff64c87ad0480f1789277724ffb056a4bf7c3258e8506b51ed7bd6cf5d7
fakeConfigureServers
private void fakeConfigureServers(int count) throws IOException
{    peers = new HashMap<Long, QuorumServer>();    qps = new QuorumPeer[count];    qpsDirs = new File[count];    for (int i = 1; i <= count; i++) {        InetSocketAddress peerAddress = new InetSocketAddress("127.0.0.1", fakeBasePort + i);        InetSocketAddress electionAddr = new InetSocketAddress("127.0.0.1", serverCount + fakeBasePort + i);        peers.put(Long.valueOf(i), new QuorumServer(i, peerAddress, electionAddr));    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i < count; i++) {                testData.mkdirs();        qpsDirs[i] = File.createTempFile("sysTest", ".tmp", testData);        qpsDirs[i].delete();        qpsDirs[i].mkdir();        int port = fakeBasePort + 10 + i;        if (sb.length() > 0) {            sb.append(',');        }        sb.append("localhost:");        sb.append(port);    }    serverHostPort = sb.toString();}
ce7b2b78ba2739261a62f1fd582873484d0681d5e9b96859cc9c0b4e7a923764
startServer
public void startServer(int index) throws IOException
{    int port = fakeBasePort + 10 + index;    if (fakeMachines) {        qps[index] = new QuorumPeer(peers, qpsDirs[index], qpsDirs[index], port, 3, index + 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);        qps[index].start();    } else {        try {            QuorumPeerInstance.startInstance(im, quorumHostPort, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getClass().getName() + ": " + e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
50e3e2f42b3264ff0df827e35fc22b49056239c30b4e98f09adaf5b8350f9740
stopServer
public void stopServer(int index) throws IOException
{    if (fakeMachines) {        qps[index].shutdown();    } else {        try {            QuorumPeerInstance.stopInstance(im, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
ff09bf78b57da39306cd2c1c2808077f2f82cda8fbad1c6f5a7c4e6293384f04
configureClients
public void configureClients(int count, Class<? extends Instance> clazz, String params) throws Exception
{    clientCount = count;    if (fakeMachines) {        fakeConfigureClients(count, clazz, params);    } else {        distributedConfigureClients(count, clazz, params);    }}
9781c8160af4d47f13b71b49d98be1d41814250b4eef18cb110b13475f977a55
distributedConfigureClients
private void distributedConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException
{    this.clazz = clazz;    this.params = params;}
f3fee7377c387f48abd102674584c8f46f5195d3b2b2cc1ce6ff8cfc657cf4dc
fakeConfigureClients
private void fakeConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException, ClassNotFoundException
{    fakeBaseClients = new Instance[count];    for (int i = 0; i < count; i++) {        try {            fakeBaseClients[i] = clazz.newInstance();        } catch (InstantiationException e) {            e.printStackTrace();            return;        } catch (IllegalAccessException e) {            e.printStackTrace();            return;        }        fakeBaseClients[i].configure(i + " " + params);    }}
88d74cfd9713113adb0621b704744664435077f4863dfce5b663d1a5f5b5ce5f
startClient
public void startClient(int index) throws IOException
{    if (fakeMachines) {        fakeStartClient(index);    } else {        distributedStartClient(index);    }}
1ef9bae514d9f38e927935afc101f0a34f46a965599a71d1c6b0416ac028a699
distributedStartClient
private void distributedStartClient(int index) throws IOException
{    try {        im.assignInstance("client" + index, clazz, index + " " + params, 1);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
465e03bd6572b84f6407dd8fba8d042b6de3764f8eedde82625a979eb9a45cbc
fakeStartClient
private void fakeStartClient(int index)
{    fakeBaseClients[index].start();}
f9e8eb02a96582322afaa8ed2a7df782264069d70bda1e3d52d2b1fd41fde323
stopClient
public void stopClient(int index) throws IOException
{    if (fakeMachines) {        fakeStopClient(index);    } else {        distributedStopClient(index);    }}
3c989ebadbfb698c510fb3b4a5a1c6b09b327a97f58007839e48d6f86810c221
distributedStopClient
private void distributedStopClient(int index) throws IOException
{    try {        im.removeInstance("client" + index);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
d5cc0a8d97c9b892e37b06bc39986ebfaafc82b006d3a98c7ea25bb613205342
fakeStopClient
private void fakeStopClient(int index)
{    fakeBaseClients[index].stop();}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    JUnitCore.main(args);}
f79a3e38dc069e599862722713ba33b80e8ce1282cba47919d9f41aff6a9ee12
add
 static synchronized void add(long time, int count, Socket s)
{    long interval = time / INTERVAL;    if (currentInterval == 0 || currentInterval > interval) {        System.out.println("Dropping " + count + " for " + new Date(time) + " " + currentInterval + ">" + interval);        return;    }        Long total = totalByTime.get(interval);    if (total == null) {        totalByTime.put(interval, (long) count);    } else {        totalByTime.put(interval, total.longValue() + count);    }    tf.println(interval + " " + count + " " + s);}
a5b19d55eea3383f1a618d13daa0140fe612f20cc76d6c034e522cb7cf203cc3
remove
 static synchronized long remove(long interval)
{    Long total = totalByTime.remove(interval);    return total == null ? -1 : total;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        System.out.println("Connected to " + s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String result;        while ((result = is.readLine()) != null) {            String[] timePercentCount = result.split(" ");            if (timePercentCount.length != 5) {                System.err.println("Got " + result + " from " + s + " exitng.");                throw new IOException(result);            }            long time = Long.parseLong(timePercentCount[0]);                        int count = Integer.parseInt(timePercentCount[2]);            int errs = Integer.parseInt(timePercentCount[3]);            if (errs > 0) {                System.out.println(s + " Got an error! " + errs);            }            add(time, count, s);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        close();    }}
9204efe8348d6d2a0791faa320a0ee4c0c910a60ca51eadcb5bb0f12799846a6
send
 void send(int percentage)
{    try {        s.getOutputStream().write((percentage + "\n").getBytes());    } catch (IOException e) {        e.printStackTrace();    }}
c2864e5a4894768906844a2ddb5f229fc8d93aa73ebb06368e7b1ddbe43efd96
close
 void close()
{    try {        System.err.println("Closing " + s);        slaves.remove(this);        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (true) {            Socket s = ss.accept();            System.err.println("Accepted connection from " + s);            slaves.add(new SlaveThread(s));        }    } catch (IOException e) {        e.printStackTrace();    } finally {        for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext(); ) {            SlaveThread st = it.next();            it.remove();            st.close();        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        currentInterval = Time.currentElapsedTime() / INTERVAL;                Thread.sleep(INTERVAL * 2);        long min = 99999;        long max = 0;        long total = 0;        int number = 0;        while (true) {            long now = Time.currentElapsedTime();            long lastInterval = currentInterval;            currentInterval += 1;            long count = remove(lastInterval);                        count = count * 1000 / INTERVAL;                        if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {                if (count < min) {                    min = count;                }                if (count > max) {                    max = count;                }                total += count;                number++;                Calendar calendar = Calendar.getInstance();                calendar.setTimeInMillis(lastInterval * INTERVAL);                String report = lastInterval + " " + calendar.get(Calendar.HOUR_OF_DAY) + ":" + calendar.get(Calendar.MINUTE) + ":" + calendar.get(Calendar.SECOND) + " " + percentage + "% " + count + " " + min + " " + ((double) total / (double) number) + " " + max;                System.err.println(report);                if (sf != null) {                    sf.println(report);                }            } else {                max = total = 0;                min = 999999999;                number = 0;            }            Thread.sleep(INTERVAL);        }    } catch (Exception e) {        e.printStackTrace();    }}
c5a0372d55bfc83694aba1d02451a5db765cce516e20284489f14007413878ed
sendChange
 static synchronized void sendChange(int percentage)
{    long now = Time.currentElapsedTime();    long start = now;    ReporterThread.percentage = percentage;    for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {        st.send(percentage);    }    now = Time.currentElapsedTime();    long delay = now - start;    if (delay > 1000) {        System.out.println("Delay of " + delay + " to send new percentage");    }    lastChange = now;}
0b633904541956cb7d4286ab59fd9b6cc4ce7f77cfbaab935085bc10d1b21daa
incOutstanding
 synchronized void incOutstanding() throws InterruptedException
{    outstanding++;    while (outstanding > outstandingLimit) {        wait();    }}
b182fa2e828adb57dbe5c5a626218c0d91aa7025d2ff698d44fdf6a4ab5a7194
decOutstanding
 synchronized void decOutstanding()
{    outstanding--;    notifyAll();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        zk = new ZooKeeper(host, 60000, this);        synchronized (this) {            if (!connected) {                wait(20000);            }        }        for (int i = 0; i < 300; i++) {            try {                Thread.sleep(100);                path = zk.create("/client", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);                break;            } catch (KeeperException e) {                LOG.error("keeper exception thrown", e);            }        }        if (path == null) {            System.err.println("Couldn't create a node in /!");            return;        }        while (alive) {            if (r.nextInt(100) < percentage) {                zk.setData(path, bytes, -1, this, System.currentTimeMillis());            } else {                zk.getData(path, false, this, System.currentTimeMillis());            }            incOutstanding();        }    } catch (Exception e) {        e.printStackTrace();    } finally {        alive = false;        try {            zk.close();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    System.err.println(event);    synchronized (this) {        if (event.getType() == EventType.None) {            connected = (event.getState() == KeeperState.SyncConnected);            notifyAll();        }    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (!alive) {            return;        }        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            rlatency += Time.currentElapsedTime() - (Long) ctx;            reads++;        }    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            wlatency += Time.currentElapsedTime() - (Long) ctx;            writes++;        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        OutputStream os = s.getOutputStream();        finished = 0;        errors = 0;        while (alive) {            Thread.sleep(300);            if (percentage == -1 || (finished == 0 && errors == 0)) {                continue;            }            String report = Time.currentElapsedTime() + " " + percentage + " " + finished + " " + errors + " " + outstanding + "\n";            /* String subreport = reads + " "                                + (((double) rlatency) / reads) + " " + writes                                + " " + (((double) wlatency / writes)); */            synchronized (statSync) {                finished = 0;                errors = 0;                reads = 0;                writes = 0;                rlatency = 0;                wlatency = 0;            }            os.write(report.getBytes());                }    } catch (Exception e) {        e.printStackTrace();    }}
e4c1be34bc6f5b082b6ff3fab6367358572b673440308f42efeaac14e98c7245
configure
public void configure(final String params)
{    System.err.println("Got " + params);    new Thread() {        public void run() {            try {                String[] parts = params.split(" ");                String[] hostPort = parts[1].split(":");                int bytesSize = 1024;                if (parts.length == 3) {                    try {                        bytesSize = Integer.parseInt(parts[2]);                    } catch (Exception e) {                        System.err.println("Not an integer: " + parts[2]);                    }                }                bytes = new byte[bytesSize];                s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));                zkThread = new ZooKeeperThread(parts[0]);                sendThread = new SenderThread(s);                BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));                String line;                while ((line = is.readLine()) != null) {                    percentage = Integer.parseInt(line);                }            } catch (Exception e) {                e.printStackTrace();            }        }    }.start();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        String[] parts = params.split(" ");        String[] hostPort = parts[1].split(":");        int bytesSize = 1024;        if (parts.length == 3) {            try {                bytesSize = Integer.parseInt(parts[2]);            } catch (Exception e) {                System.err.println("Not an integer: " + parts[2]);            }        }        bytes = new byte[bytesSize];        s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));        zkThread = new ZooKeeperThread(parts[0]);        sendThread = new SenderThread(s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String line;        while ((line = is.readLine()) != null) {            percentage = Integer.parseInt(line);        }    } catch (Exception e) {        e.printStackTrace();    }}
f83b6240f75d0ebfff592560afd6b92ef808c6e13e142438310f178a3573a1e4
setReporter
public void setReporter(Reporter r)
{    this.r = r;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    try {        r.report("started");    } catch (Exception e) {        e.printStackTrace();    }}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    alive = false;    zkThread.interrupt();    sendThread.interrupt();    try {        zkThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        sendThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        r.report("stopped");    } catch (Exception e) {        e.printStackTrace();    }    try {        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Watcher.Event.EventType.None) {        synchronized (this) {            connected = event.getState() == Watcher.Event.KeeperState.SyncConnected;            notifyAll();        }    }}
0fc5b1fa80d5858dc92cb436cfae4cc66959c027c89ca26a602ddfd8a3779434
waitConnected
public synchronized boolean waitConnected(long timeout) throws InterruptedException
{    long endTime = Time.currentElapsedTime() + timeout;    while (!connected && Time.currentElapsedTime() < endTime) {        wait(endTime - Time.currentElapsedTime());    }    return connected;}
1d67e2302ff821c29f10ab0d2b0335eb720e96424aa1ae0ac2144b18e8b985cb
processOptions
private static String[] processOptions(String[] args)
{    ArrayList<String> newArgs = new ArrayList<String>();    for (String a : args) {        if (a.equals("--leaderOnly")) {            leaderOnly = true;            leaderServes = true;        } else if (a.equals("--leaderServes")) {            leaderServes = true;        } else {            newArgs.add(a);        }    }    return newArgs.toArray(new String[0]);}
de234c220020e05ed84d6b7f9c7a26079f641bb0d6e34762b466ab549bbc81e2
main
public static void main(String[] args) throws InterruptedException, KeeperException, NoAvailableContainers, DuplicateNameException, NoAssignmentException
{    args = processOptions(args);    if (args.length == 5) {        try {            StatusWatcher statusWatcher = new StatusWatcher();            ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);            if (!statusWatcher.waitConnected(5000)) {                System.err.println("Could not connect to " + args[0]);                return;            }            InstanceManager im = new InstanceManager(zk, args[1]);            ss = new ServerSocket(0);            int port = ss.getLocalPort();            int serverCount = Integer.parseInt(args[2]);            int clientCount = Integer.parseInt(args[3]);            StringBuilder quorumHostPort = new StringBuilder();            StringBuilder zkHostPort = new StringBuilder();            for (int i = 0; i < serverCount; i++) {                String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);                if (i > 0) {                    quorumHostPort.append(',');                    zkHostPort.append(',');                }                                zkHostPort.append(r[0]);                                quorumHostPort.append(r[1]);                                quorumHostPort.append(";" + (r[0].split(":"))[1]);            }            for (int i = 0; i < serverCount; i++) {                QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);            }            if (leaderOnly) {                int tries = 0;                outer: while (true) {                    Thread.sleep(1000);                    IOException lastException = null;                    String[] parts = zkHostPort.toString().split(",");                    for (int i = 0; i < parts.length; i++) {                        try {                            String mode = getMode(parts[i]);                            if (mode.equals("leader")) {                                zkHostPort = new StringBuilder(parts[i]);                                System.out.println("Connecting exclusively to " + zkHostPort.toString());                                break outer;                            }                        } catch (IOException e) {                            lastException = e;                        }                    }                    if (tries++ > 3) {                        throw lastException;                    }                }            }            for (int i = 0; i < clientCount; i++) {                im.assignInstance("client" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);            }            new AcceptorThread();            new ReporterThread();            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = is.readLine()) != null) {                try {                    String[] cmdNumber = line.split(" ");                    if (cmdNumber[0].equals("percentage") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        if (number < 0 || number > 100) {                            throw new NumberFormatException("must be between 0 and 100");                        }                        sendChange(number);                    } else if (cmdNumber[0].equals("sleep") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        Thread.sleep(number * 1000);                    } else if (cmdNumber[0].equals("save") && cmdNumber.length > 1) {                        sf = new PrintStream(cmdNumber[1]);                    } else {                        System.err.println("Commands must be:");                        System.err.println("\tpercentage new_write_percentage");                        System.err.println("\tsleep seconds_to_sleep");                        System.err.println("\tsave file_to_save_output");                    }                } catch (NumberFormatException e) {                    System.out.println("Not a valid number: " + e.getMessage());                }            }        } catch (NumberFormatException e) {            doUsage();        } catch (IOException e) {            e.printStackTrace();            System.exit(ExitCode.INVALID_INVOCATION.getValue());        }    } else {        doUsage();    }}
9683060ad3cbf171542beb2fdf08597ac565ecc37fe1cd47126b7410d7934ca5
getMode
private static String getMode(String hostPort) throws NumberFormatException, UnknownHostException, IOException
{    String[] parts = hostPort.split(":");    Socket s = new Socket(parts[0], Integer.parseInt(parts[1]));    s.getOutputStream().write("stat".getBytes());    BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));    String line;    try {        while ((line = br.readLine()) != null) {            if (line.startsWith("Mode: ")) {                return line.substring(6);            }        }        return "unknown";    } finally {        s.close();    }}
0d80c8a71382cbd742270140cd16890b43a31d4e3baa05c19071d132c733628e
doUsage
private static void doUsage()
{    System.err.println("USAGE: " + GenerateLoad.class.getName() + " [--leaderOnly] [--leaderServes] zookeeper_host:port containerPrefix #ofServers #ofClients requestSize");    System.exit(ExitCode.INVALID_INVOCATION.getValue());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals(myNode)) {        zk.getData(myNode, this, dc, this);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                return;    }    if (rc != KeeperException.Code.OK.intValue()) {        zk.getData(myNode, (Watcher) ctx, this, ctx);    }    int currVer = stat.getVersion();    if (currVer != lastVer) {        String[] parts = new String(data).split(" ", 2);        myInstance.configure(parts[1]);        lastVer = currVer;    }}
fce239687a719c675beba07cdb155c27c36887f8e89b5652eb74b14a3eccf7ef
report
public void report(String report) throws KeeperException, InterruptedException
{    for (int j = 0; j < maxTries; j++) {        try {            try {                zk.setData(myReportNode, report.getBytes(), -1);            } catch (NoNodeException e) {                zk.create(myReportNode, report.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            }            break;        } catch (ConnectionLossException e) {        }    }}
110b3f7056a0027e3f27649393bbc5ffb05a843dbdf5957a80bdccbaf2e5361d
rmnod
private void rmnod(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            lastException = null;            break;        } catch (KeeperException.NoNodeException e) {                        break;        } catch (KeeperException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
3f8ea7274965376dab62e6111cf33566ffe6a07e4f4f626e965a191535dcea18
mknod_inner
private void mknod_inner(String path, CreateMode mode) throws KeeperException, InterruptedException
{    for (int i = 0; i < maxTries; i++) {        try {            zk.create(path, null, Ids.OPEN_ACL_UNSAFE, mode);            break;        } catch (NodeExistsException e) {            if (mode != CreateMode.EPHEMERAL) {                return;            }            Stat stat = zk.exists(path, false);            if (stat == null) {                continue;            }            if (stat.getEphemeralOwner() != zk.getSessionId()) {                throw e;            }            break;        } catch (ConnectionLossException e) {            e.printStackTrace();        }    }}
fc10171e71c8a847c5175f7289214db5cb78219e08eaf5698278f6bc37c9963c
mknod
private void mknod(String path, CreateMode mode) throws KeeperException, InterruptedException
{    String[] subpath = path.split("/");    StringBuilder sb = new StringBuilder();        for (int i = 1; i < subpath.length; i++) {        sb.append("/");        sb.append(subpath[i]);        CreateMode m = CreateMode.PERSISTENT;        if (i == subpath.length - 1) {            m = mode;        }        mknod_inner(sb.toString(), m);    }}
4a2d51607ed5bae281184cf58a9022b7494c05f0948566b6751bbdb974263bba
run
public void run() throws IOException, InterruptedException, KeeperException
{    zk = new ZooKeeper(zkHostPort, sessTimeout, this);    mknod(assignmentsNode, CreateMode.PERSISTENT);    mknod(statusNode, CreateMode.EPHEMERAL);    mknod(reportsNode, CreateMode.PERSISTENT);        zk.getChildren(assignmentsNode, true, this, null);}
ca8cec63222d91c1ecb01f7a4be17d7e63aa5bbe765079bc2a0a473e93fbd6cd
main
public static void main(String[] args) throws UnknownHostException, IOException, InterruptedException, KeeperException
{    if (args.length != 3) {        System.err.println("USAGE: " + InstanceContainer.class.getName() + " name zkHostPort znodePrefix");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new InstanceContainer(args[0], args[1], args[2]).run();    while (true) {        Thread.sleep(1000);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (KeeperState.Expired == event.getState()) {                LOG.error("Lost session");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    }    if (event.getPath() != null && event.getPath().equals(assignmentsNode)) {                zk.getChildren(assignmentsNode, true, this, null);    }}
cac92b0fb5d66d21de711286665096128f53536b61b7812df3b744288e72f8f6
processResult
public void processResult(int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {                zk.getChildren(assignmentsNode, true, this, null);        return;    }    Map<String, Instance> newList = new HashMap<String, Instance>();        Stat stat = new Stat();    for (String child : children) {        Instance i = instances.remove(child);        if (i == null) {                        byte[] data = null;            String myNode = assignmentsNode + '/' + child;            while (true) {                try {                    data = zk.getData(myNode, true, stat);                    break;                } catch (NoNodeException e) {                                        break;                } catch (KeeperException e) {                    e.printStackTrace();                } catch (InterruptedException e) {                    return;                }            }            if (data != null) {                String instanceSpec = new String(data);                int spaceIndex = instanceSpec.indexOf(' ');                String clazz;                String conf;                if (spaceIndex == -1) {                    clazz = instanceSpec;                    conf = null;                } else {                    clazz = instanceSpec.substring(0, spaceIndex);                    conf = instanceSpec.substring(spaceIndex + 1);                }                try {                    Class<?> c = Class.forName(clazz);                    i = (Instance) c.newInstance();                    Reporter reporter = new MyReporter(child);                    i.setReporter(reporter);                    i.configure(conf);                    i.start();                    newList.put(child, i);                    int ver = stat.getVersion();                    Instance myInstance = i;                    DataCallback dc = new MyDataCallback(myNode, myInstance, ver);                    Watcher watcher = new MyWatcher(myNode, dc);                    zk.getData(myNode, watcher, dc, watcher);                } catch (Exception e) {                    LOG.warn("Skipping " + child, e);                    if (e.getCause() != null) {                        LOG.warn("Caused by", e.getCause());                    }                }            }        } else {                        newList.put(child, i);        }    }        for (Map.Entry<String, Instance> i : instances.entrySet()) {        i.getValue().stop();        try {            rmnod(reportsNode + '/' + i.getKey());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        } catch (KeeperException e) {            e.printStackTrace();        }    }    instances = newList;}
301218684f002fced40c264a0d0610ee5210c576d488f36013efac005e84ab3a
setupNodes
private void setupNodes(ZooKeeper zk) throws KeeperException, InterruptedException
{    try {        zk.create(prefixNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(assignmentsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(statusNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(reportsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(readyNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }}
5be624df5d4b70bcbd92ae11931b2b87aa40aaa76e7d1dd501448449553e4101
processResult
public synchronized void processResult(int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {        zk.getChildren(statusNode, this, this, null);        return;    }    if (LOG.isDebugEnabled()) {        LOG.debug("Got " + children + " children from " + path);    }    Map<String, HashSet<Assigned>> newAssignments = new HashMap<String, HashSet<Assigned>>();    for (String c : children) {        HashSet<Assigned> a = assignments.remove(c);        if (a != null) {            newAssignments.put(c, a);        } else {            newAssignments.put(c, new HashSet<Assigned>());        }    }        for (String dead : assignments.keySet()) {        try {            removeInstance(dead);        } catch (KeeperException e) {            e.printStackTrace();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    assignments = newAssignments;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getPath().equals(statusNode)) {        zk.getChildren(statusNode, this, this, null);    }}
29ff0a1bc77aee814ffc70c54418e291c6a9060dd56504abce5823ed0d038453
assignInstance
public synchronized String assignInstance(String name, Class<? extends Instance> clazz, String params, int weight) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    if (weight < 1) {                weight = 1;    }    String instanceSpec = clazz.getName() + ' ' + params;    if (instanceToAssignment.get(name) != null) {        throw new DuplicateNameException(name + " already exists");    }        String mostIdle = null;    int mostIdleWeight = Integer.MAX_VALUE;    for (String preferred : preferredList) {        HashSet<Assigned> assignmentList = assignments.get(preferred);        int w = 0;        if (assignmentList != null) {            for (Assigned a : assignmentList) {                w += a.weight;            }            if (w < mostIdleWeight) {                mostIdleWeight = w;                mostIdle = preferred;            }        }    }    for (Entry<String, HashSet<Assigned>> e : assignments.entrySet()) {        int w = 0;        for (Assigned a : e.getValue()) {            w += a.weight;        }        if (w < mostIdleWeight) {            mostIdleWeight = w;            mostIdle = e.getKey();        }    }    if (mostIdle == null) {        throw new NoAvailableContainers("No available containers");    }    Assigned a = new Assigned(mostIdle, weight);    instanceToAssignment.put(name, a);    HashSet<Assigned> as = assignments.get(mostIdle);    if (as == null) {        as = new HashSet<Assigned>();        assignments.put(mostIdle, as);    }    as.add(a);    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.create(assignmentsNode + '/' + mostIdle + '/' + name, instanceSpec.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            return mostIdle;        } catch (NodeExistsException e) {            return mostIdle;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
c8f6fda6a461d58c67fa620186eb4c4f07ea525091b8df55e08e6eac6c559442
reconfigureInstance
public void reconfigureInstance(String name, String params) throws NoAssignmentException, InterruptedException, KeeperException
{    if (LOG.isDebugEnabled()) {        LOG.debug("Reconfiguring " + name + " with " + params);    }    Assigned assigned = instanceToAssignment.get(name);    if (assigned == null) {        throw new NoAssignmentException();    }    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, ("update " + params).getBytes(), -1);            break;        } catch (ConnectionLossException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
28d355235940c4e164795c6ac437af6d85a3dea3786faeeef590d1040450983a
doDelete
private void doDelete(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            return;        } catch (NoNodeException e) {            return;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
b04d9c16f92da8fc58f616744b9dc4183eb19c9bc7f749ca3f59ad139c9c0b96
removeInstance
public synchronized void removeInstance(String name) throws InterruptedException, KeeperException
{    Assigned assigned = instanceToAssignment.remove(name);    if (assigned == null) {        return;    }    assignments.get(assigned.container).remove(name);    doDelete(assignmentsNode + '/' + assigned.container + '/' + name);    doDelete(reportsNode + '/' + name);}
efe11e184411561b9138ef1d373abae39556d2059a1f4a29632db6a7e3f548bf
isAlive
 synchronized boolean isAlive(String name)
{    return instanceToAssignment.get(name) != null;}
2f703b28ceb5d7bcf65da306e2a11dbd2aa86b8b3dc4e6c6c380f5ce4a680d35
resetStatus
public void resetStatus(String name) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(reportsNode + '/' + name, -1);            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {                }    }    if (lastException != null) {        throw lastException;    }}
1c2f0cea90d3075f2ee31feef61a349339860a42613d5e06b541acf65b3a18fb
getStatus
public String getStatus(String name, long timeout) throws KeeperException, InterruptedException
{    Stat stat = new Stat();    byte[] data = null;    long endTime = Time.currentElapsedTime() + timeout;    KeeperException lastException = null;    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {        try {            data = zk.getData(reportsNode + '/' + name, false, stat);            if (LOG.isDebugEnabled()) {                LOG.debug("Got Data: " + ((data == null) ? "null" : new String(data)));            }            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {            final Object eventObj = new Object();            synchronized (eventObj) {                                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {                    public void process(WatchedEvent event) {                        synchronized (eventObj) {                            eventObj.notifyAll();                        }                    }                });                if (eStat == null) {                    eventObj.wait(endTime - Time.currentElapsedTime());                }            }            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }    return new String(data);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    synchronized (eventObj) {        eventObj.notifyAll();    }}
3cc59dbf86e75b9868827b28362533d64c83a39c2f84caf36843b9026a5d4bcf
close
public synchronized void close() throws InterruptedException
{    for (String name : instanceToAssignment.keySet().toArray(new String[0])) {        try {            removeInstance(name);        } catch (KeeperException e) {            e.printStackTrace();        }    }    try {        doDelete(readyNode);    } catch (KeeperException e) {        e.printStackTrace();    }}
f83b6240f75d0ebfff592560afd6b92ef808c6e13e142438310f178a3573a1e4
setReporter
public void setReporter(Reporter r)
{    this.r = r;}
ffeeb37b67e5455b195150a33c26be64d6dfcc000761c127bc8cca512efaa9d5
configure
public void configure(String params)
{    if (clientAddr == null) {        String[] parts = params.split(" ");                        serverId = Integer.parseInt(parts[0]);        if (LOG.isDebugEnabled()) {            LOG.debug("Setting up server " + serverId);        }        if (parts.length > 1 && parts[1].equals("false")) {            System.setProperty("zookeeper.leaderServes", "no");        } else {            System.setProperty("zookeeper.leaderServes", "yes");        }                try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();        try {            if (LOG.isDebugEnabled()) {                LOG.debug("Reporting " + report);            }            r.report(report);        } catch (Exception e) {            e.printStackTrace();        }        return;    } else {        int spaceIndex = params.indexOf(' ');        if (spaceIndex == -1) {            LOG.warn("looking for host:port,... start|stop, but found " + params);            return;        }        String quorumSpecs = params.substring(0, spaceIndex);        String cmd = params.substring(spaceIndex + 1);        if (LOG.isDebugEnabled()) {            LOG.debug("Running command: " + cmd);        }        if (!cmd.equals("start")) {            if (peer != null) {                peer.shutdown();            }            peer = null;            try {                for (int i = 0; i < 5; i++) {                    Thread.sleep(500);                    try {                                                new Socket("127.0.0.1", clientAddr.getPort()).close();                    } catch (IOException e) {                        break;                    }                }                r.report("stopped");            } catch (Exception e) {                LOG.error("Unhandled error", e);            }            return;        }        String[] parts = quorumSpecs.split(",");        peers = new HashMap<Long, QuorumServer>();        for (int i = 0; i < parts.length; i++) {                        String[] subparts = ((parts[i].split(";"))[0]).split(":");            String clientPort = (parts[i].split(";"))[1];            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));        }        try {            if (LOG.isDebugEnabled()) {                LOG.debug("Starting quorumPeer " + serverId + " on port " + clientAddr.getPort());            }            if (peer != null) {                LOG.warn("Peer " + serverId + " already started");                return;            }            System.err.println("SnapDir = " + snapDir + " LogDir = " + logDir);            peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            peer.start();            for (int i = 0; i < 5; i++) {                Thread.sleep(500);                try {                                        new Socket("127.0.0.1", clientAddr.getPort()).close();                    break;                } catch (IOException e) {                }            }            r.report("started");        } catch (Exception e) {            LOG.error("Unhandled exception", e);        }    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    if (LOG.isDebugEnabled()) {        LOG.debug("Stopping peer " + serverId);    }    if (peer != null) {        peer.shutdown();    }    if (logDir != null) {        TestUtils.deleteFileRecursively(logDir);    }    if (snapDir != null) {        TestUtils.deleteFileRecursively(snapDir);    }}
c18efd272ac0597abd4be6f2590775d20999f1a2c8c905ce84ef3d5aaf21b04b
createServer
public static String[] createServer(InstanceManager im, int i) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    return createServer(im, i, true);}
0a156cdac65f6b13d4d629062d483b8e93f70770ebb80a48ae2912431b4266af
createServer
public static String[] createServer(InstanceManager im, int i, boolean leaderServes) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    im.assignInstance("server" + i, QuorumPeerInstance.class, Integer.toString(i) + " " + leaderServes, 50);    return im.getStatus("server" + i, 3000).split(",");}
ad8bd18bfca803f46e6f437d95daf7d0ce0ff6f2e09a64277e9c44929a8a87ea
startInstance
public static void startInstance(InstanceManager im, String quorumHostPort, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, quorumHostPort + " start");    im.getStatus("server" + index, 5000);}
4c2d558b7bbab78bfcebb8da4171ad59b64fd1c077061dd6b09a39fcd7a14ae0
stopInstance
public static void stopInstance(InstanceManager im, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, Integer.toString(index) + " stop");    im.getStatus("server" + index, 3000);}
ffeeb37b67e5455b195150a33c26be64d6dfcc000761c127bc8cca512efaa9d5
configure
public void configure(String params)
{    String[] parts = params.split(" ");    hostPort = parts[1];    this.index = Integer.parseInt(parts[0]);    myPath = "/simpleCase/" + index;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    try {        zk = new ZooKeeper(hostPort, 15000, this);        zk.getData("/simpleCase", true, this, null);        if (null != r) {            r.report("Client " + index + " connecting to " + hostPort);        }    } catch (Exception e) {        e.printStackTrace();    }}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    try {        if (zk != null) {            zk.close();        }    } catch (InterruptedException e) {        e.printStackTrace();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals("/simpleCase")) {        zk.getData("/simpleCase", true, this, null);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc != 0) {        zk.getData("/simpleCase", true, this, null);    } else {        this.data = data;        String content = new String(data);        if (content.equals("die")) {            this.stop();            return;        }        if (!createdEphemeral) {            zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);            createdEphemeral = true;        } else {            zk.setData(myPath, data, -1, this, null);        }    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    if (rc != 0) {        zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc != 0) {        zk.setData(myPath, data, -1, this, null);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return SimpleClient.class.getName() + "[" + index + "] using " + hostPort;}
f83b6240f75d0ebfff592560afd6b92ef808c6e13e142438310f178a3573a1e4
setReporter
public void setReporter(Reporter r)
{    this.r = r;}
4e0156279377e5e9a0c23deaaa9d316278236aaee2f84a0cac99acdb5167910f
waitForConnect
private synchronized boolean waitForConnect(ZooKeeper zk, long timeout) throws InterruptedException
{    connected = (zk.getState() == States.CONNECTED);    long end = Time.currentElapsedTime() + timeout;    while (!connected && end > Time.currentElapsedTime()) {        wait(timeout);        connected = (zk.getState() == States.CONNECTED);    }    return connected;}
ffe8f0c1d3c4f9bd2508890dd50a64f184c27604f2f79faf074817b4d3758e2d
testSimpleCase
public void testSimpleCase() throws Exception
{    configureServers(serverCount);    configureClients(clientCount, SimpleClient.class, getHostPort());    Stat stat = new Stat();    startServers();    LOG.debug("Connecting to " + getHostPort());    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);    waitForConnect(zk, 10000);    zk.create("/simpleCase", "orig".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    startClients();        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            try {                byte[] b = zk.getData("/simpleCase/" + i, false, stat);                Assert.assertEquals("orig", new String(b));            } catch (NoNodeException e) {                if (j + 1 == maxTries) {                    Assert.fail("Max tries exceeded on client " + i);                }                Thread.sleep(1000);            }        }    }        for (int i = 0; i < getServerCount(); i++) {        stopServer(i);        if (i + 1 > getServerCount() / 2) {            startServer(i);        } else if (i + 1 == getServerCount() / 2) {            Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));            try {                zk.setData("/simpleCase", "new".getBytes(), -1);            } catch (ConnectionLossException e) {                Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));                zk.setData("/simpleCase", "new".getBytes(), -1);            }            for (int j = 0; j < i; j++) {                LOG.info("Starting server " + j);                startServer(i);            }        }    }        Thread.sleep(100);    Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    try {        zk.getData("/simpleCase", false, stat);    } catch (ConnectionLossException e) {        Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    }        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            byte[] data = zk.getData("/simpleCase/" + i, false, stat);            if (new String(data).equals("new")) {                break;            }            if (j + 1 == maxTries) {                Assert.fail("max tries exceeded for " + i);            }            Thread.sleep(1000);        }    }        zk.setData("/simpleCase", "die".getBytes(), -1);        for (int i = 0; i < getClientCount(); i++) {        try {            for (int j = 0; j < maxTries; j++) {                zk.getData("/simpleCase/" + i, false, stat);                if (j + 1 == maxTries) {                    Assert.fail("max tries exceeded waiting for child " + i + " to die");                }                Thread.sleep(200);            }        } catch (NoNodeException e) {                }    }    stopClients();    stopServers();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        synchronized (this) {            connected = true;            notifyAll();        }    } else if (event.getState() == KeeperState.Disconnected) {        synchronized (this) {            connected = false;            notifyAll();        }    }}
4b0b1eb60f01c863bd6befefa927b30aa778f8d4aa501e052db1c49c9d111ea4
getArchive
public static BinaryInputArchive getArchive(InputStream strm)
{    return new BinaryInputArchive(new DataInputStream(strm));}
c2eb482582a583da75a2c1ff92e891309ca985caf77d21831185316aaa69e5ff
done
public boolean done()
{    return (nelems <= 0);}
88af5eafc088a7375f27068de8ded824c953c540eff2313f9222e0f7e10f94ac
incr
public void incr()
{    nelems--;}
6d8b3d204d338b21f552ada6541e8a4935faa3f1dedcacb5243c6fbc454381ec
readByte
public byte readByte(String tag) throws IOException
{    return in.readByte();}
23d41e34956a02baa1d16de4d01e52dbd4678bdbd65c9ed9e999f776dc0fb8cc
readBool
public boolean readBool(String tag) throws IOException
{    return in.readBoolean();}
ec8309ab85aaf6ad805bc457996ade4e504989e206a9f537212d751235e3ed32
readInt
public int readInt(String tag) throws IOException
{    return in.readInt();}
20b95f20cd6b73f4ce8218e0e56a4162e013a9923bc584a0c33ac7d2db4e958b
readLong
public long readLong(String tag) throws IOException
{    return in.readLong();}
80f1062b1009968507f4f756428e4f688c811697fc6f3a0f26f0fbe8e5ea36d7
readFloat
public float readFloat(String tag) throws IOException
{    return in.readFloat();}
b0c647bc74f4be633510bddde086980e5ad4702625561acde66d3310cd6a788d
readDouble
public double readDouble(String tag) throws IOException
{    return in.readDouble();}
2986261a8cb2194f3ba7f302e4f0880971b434b7d3812520d16019a5de29cfdf
readString
public String readString(String tag) throws IOException
{    int len = in.readInt();    if (len == -1) {        return null;    }    checkLength(len);    byte[] b = new byte[len];    in.readFully(b);    return new String(b, StandardCharsets.UTF_8);}
d008943ce43a325d38a00db07809da25bf70ed08353a04cae2d9aed95deba4a2
readBuffer
public byte[] readBuffer(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    checkLength(len);    byte[] arr = new byte[len];    in.readFully(arr);    return arr;}
2337d7132a5a3116caec471ecf30b2046dc9231bda180709a6160a647ca3c57c
readRecord
public void readRecord(Record r, String tag) throws IOException
{    r.deserialize(this, tag);}
d1138830f4f2c84f2711bdd78d42d4f01993d77147bee0c0de81ddec51d75ea7
startRecord
public void startRecord(String tag) throws IOException
{}
2163c35861ee6c8b665f8a02f1400680719d0cae858a42ec30e16e0cc89ca653
endRecord
public void endRecord(String tag) throws IOException
{}
8b938461739c27f50715667b24575377bd0beb6755dd7eeb8978d35e26a2b5b5
startVector
public Index startVector(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    return new BinaryIndex(len);}
2e8f6f07bf1a00c5540985f216c2ff88be476bd217ee77bfccc69fc761de79a7
endVector
public void endVector(String tag) throws IOException
{}
d994d7059a9ad3ccef21ae8e0035f0057f6e5ebf4709f69489d9f74f1ae637b8
startMap
public Index startMap(String tag) throws IOException
{    return new BinaryIndex(readInt(tag));}
a62515c93413fb929c0657339d26a42154869da542b9e1f943e04d6aaa3c7407
endMap
public void endMap(String tag) throws IOException
{}
2e9ab9ef31c74f31eede3a99bdcf1088fdba346d5b1c8abe297ff6d43ee00c80
checkLength
private void checkLength(int len) throws IOException
{    if (len < 0 || len > maxBufferSize + extraMaxBufferSize) {        throw new IOException(UNREASONBLE_LENGTH + len);    }}
ab388c0112aa0f5790717ff3e691d64c9a1d78d8cbf97e9833fa34212cb37c14
getArchive
public static BinaryOutputArchive getArchive(OutputStream strm)
{    return new BinaryOutputArchive(new DataOutputStream(strm));}
36dd3e0bfec762a5b7b7eed75f2b0aa37cb97581be000d18e85806d956920c9d
writeByte
public void writeByte(byte b, String tag) throws IOException
{    out.writeByte(b);}
2077352d6f236d7ed32d965e0c6e98a165488380ceb5e88d57670c2313d31ee2
writeBool
public void writeBool(boolean b, String tag) throws IOException
{    out.writeBoolean(b);}
7f2b5ecb348aacbeabed81e0f0cf43f839fa78cbad461faa09ebd9bd31db2c37
writeInt
public void writeInt(int i, String tag) throws IOException
{    out.writeInt(i);}
e358a697af25dc9ee2726911756380c33aa8b813c237a01b73dff75ed54b5670
writeLong
public void writeLong(long l, String tag) throws IOException
{    out.writeLong(l);}
a47380e58dbee03ff1059b5af36250fd5dfc14fe8c04192364552b564f5db51b
writeFloat
public void writeFloat(float f, String tag) throws IOException
{    out.writeFloat(f);}
9598fc48c3269269d0fc4a37bbae0677a26ba321260e5b58d0f917fdf8cee7f4
writeDouble
public void writeDouble(double d, String tag) throws IOException
{    out.writeDouble(d);}
30931d9efef606e34f11298cb2a75063cb67d61e2b07a234590d2555e3db9f12
stringToByteBuffer
private ByteBuffer stringToByteBuffer(CharSequence s)
{    bb.clear();    final int len = s.length();    for (int i = 0; i < len; i++) {        if (bb.remaining() < 3) {            ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);            bb.flip();            n.put(bb);            bb = n;        }        char c = s.charAt(i);        if (c < 0x80) {            bb.put((byte) c);        } else if (c < 0x800) {            bb.put((byte) (0xc0 | (c >> 6)));            bb.put((byte) (0x80 | (c & 0x3f)));        } else {            bb.put((byte) (0xe0 | (c >> 12)));            bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));            bb.put((byte) (0x80 | (c & 0x3f)));        }    }    bb.flip();    return bb;}
5ea3c19be876ab804ccf231692fefd3ca44b4a00142f95b5b7aaf4193fc310d0
writeString
public void writeString(String s, String tag) throws IOException
{    if (s == null) {        writeInt(-1, "len");        return;    }    ByteBuffer bb = stringToByteBuffer(s);    writeInt(bb.remaining(), "len");    out.write(bb.array(), bb.position(), bb.limit());}
7a29dec8f87931a6b7a0ed386580b369ecd09f429fb3e6588b0bc9f3317a3a8c
writeBuffer
public void writeBuffer(byte[] barr, String tag) throws IOException
{    if (barr == null) {        out.writeInt(-1);        return;    }    out.writeInt(barr.length);    out.write(barr);}
64bb611dbb27873489157fc69e6392c0bf17411ba942997ac2a5c7ab8ab33ad5
writeRecord
public void writeRecord(Record r, String tag) throws IOException
{    r.serialize(this, tag);}
03e188dd2aafef8115221c892f6433bf0b72fbe92bb9da6a1b449369414cad64
startRecord
public void startRecord(Record r, String tag) throws IOException
{}
b9201dc8811f92ccd42bb59adbc790f8b2bb5576860e5a6c8a235854ba422a45
endRecord
public void endRecord(Record r, String tag) throws IOException
{}
0f72e6acfaba9aeeac39baeb68348308ffaefb55e8ff1be8eaa932808e20f539
startVector
public void startVector(List<?> v, String tag) throws IOException
{    if (v == null) {        writeInt(-1, tag);        return;    }    writeInt(v.size(), tag);}
ae2d5241f1796263e5c1c0a0191c4134f759329d2c9f219411771f1b77ac68c1
endVector
public void endVector(List<?> v, String tag) throws IOException
{}
e8c9fba71e8a6cd73f55d2d370e05570c096eb03140af9f67090f58fca111757
startMap
public void startMap(TreeMap<?, ?> v, String tag) throws IOException
{    writeInt(v.size(), tag);}
e667ffe879568bfa768c7a45463162004bb210019b13b8f3df2a43c25b3636ba
endMap
public void endMap(TreeMap<?, ?> v, String tag) throws IOException
{}
424f7f56b5f635221929c6d3e2282c16f0a98e13cf5c76945849561af401518e
genCode
 void genCode() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter c = new FileWriter(new File(outputDirectory, mName + ".c"));        FileWriter h = new FileWriter(new File(outputDirectory, mName + ".h"))) {        h.write("/**\n");        h.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        h.write("* or more contributor license agreements.  See the NOTICE file\n");        h.write("* distributed with this work for additional information\n");        h.write("* regarding copyright ownership.  The ASF licenses this file\n");        h.write("* to you under the Apache License, Version 2.0 (the\n");        h.write("* \"License\"); you may not use this file except in compliance\n");        h.write("* with the License.  You may obtain a copy of the License at\n");        h.write("*\n");        h.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        h.write("*\n");        h.write("* Unless required by applicable law or agreed to in writing, software\n");        h.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        h.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        h.write("* See the License for the specific language governing permissions and\n");        h.write("* limitations under the License.\n");        h.write("*/\n");        h.write("\n");        c.write("/**\n");        c.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        c.write("* or more contributor license agreements.  See the NOTICE file\n");        c.write("* distributed with this work for additional information\n");        c.write("* regarding copyright ownership.  The ASF licenses this file\n");        c.write("* to you under the Apache License, Version 2.0 (the\n");        c.write("* \"License\"); you may not use this file except in compliance\n");        c.write("* with the License.  You may obtain a copy of the License at\n");        c.write("*\n");        c.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        c.write("*\n");        c.write("* Unless required by applicable law or agreed to in writing, software\n");        c.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        c.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        c.write("* See the License for the specific language governing permissions and\n");        c.write("* limitations under the License.\n");        c.write("*/\n");        c.write("\n");        h.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#include \"recordio.h\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            h.write("#include \"" + f.getName() + ".h\"\n");        }                h.write("\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");                c.write("#include <stdlib.h>\n");        c.write("#include \"" + mName + ".h\"\n\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCCode(h, c);        }        h.write("\n#ifdef __cplusplus\n}\n#endif\n\n");        h.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
424f7f56b5f635221929c6d3e2282c16f0a98e13cf5c76945849561af401518e
genCode
 void genCode() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter cc = new FileWriter(new File(outputDirectory, mName + ".cc"));        FileWriter hh = new FileWriter(new File(outputDirectory, mName + ".hh"))) {        hh.write("/**\n");        hh.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        hh.write("* or more contributor license agreements.  See the NOTICE file\n");        hh.write("* distributed with this work for additional information\n");        hh.write("* regarding copyright ownership.  The ASF licenses this file\n");        hh.write("* to you under the Apache License, Version 2.0 (the\n");        hh.write("* \"License\"); you may not use this file except in compliance\n");        hh.write("* with the License.  You may obtain a copy of the License at\n");        hh.write("*\n");        hh.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        hh.write("*\n");        hh.write("* Unless required by applicable law or agreed to in writing, software\n");        hh.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        hh.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        hh.write("* See the License for the specific language governing permissions and\n");        hh.write("* limitations under the License.\n");        hh.write("*/\n");        hh.write("\n");        cc.write("/**\n");        cc.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        cc.write("* or more contributor license agreements.  See the NOTICE file\n");        cc.write("* distributed with this work for additional information\n");        cc.write("* regarding copyright ownership.  The ASF licenses this file\n");        cc.write("* to you under the Apache License, Version 2.0 (the\n");        cc.write("* \"License\"); you may not use this file except in compliance\n");        cc.write("* with the License.  You may obtain a copy of the License at\n");        cc.write("*\n");        cc.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        cc.write("*\n");        cc.write("* Unless required by applicable law or agreed to in writing, software\n");        cc.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        cc.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        cc.write("* See the License for the specific language governing permissions and\n");        cc.write("* limitations under the License.\n");        cc.write("*/\n");        cc.write("\n");        hh.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#include \"recordio.hh\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            hh.write("#include \"" + f.getName() + ".hh\"\n");        }        cc.write("#include \"" + mName + ".hh\"\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCppCode(hh, cc);        }        hh.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
424f7f56b5f635221929c6d3e2282c16f0a98e13cf5c76945849561af401518e
genCode
 void genCode() throws IOException
{    for (JRecord rec : mRecList) {        rec.genCsharpCode(outputDirectory);    }}
424f7f56b5f635221929c6d3e2282c16f0a98e13cf5c76945849561af401518e
genCode
 void genCode() throws IOException
{    for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {        JRecord rec = i.next();        rec.genJavaCode(outputDirectory);    }}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "z";}
e40304626cb3d10631210643c4ae665cc68abe780f1d635d824167a46235ed79
genJavaCompareTo
public String genJavaCompareTo(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 : (" + fname + "?1:-1);\n";}
909155c9bae51b1031b5af86a87a9330c7ecd1a11f18ee5efd83d1673884e01b
genJavaHashCode
public String genJavaHashCode(String fname)
{    return "     ret = (" + fname + ")?0:1;\n";}
514c479bb6bc8cbe9dc713a4054a03fa770e59bdb826650ff7e19ecad3ef2202
genCsharpHashCode
 String genCsharpHashCode(String fname)
{    return "     ret = (" + capitalize(fname) + ")?0:1;\n";}
36cefdb6fec45afeca409eb7a93502c3c7d1dec24eecc93bcb374eb87618a726
genCsharpCompareTo
 String genCsharpCompareTo(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 : (" + capitalize(name) + "?1:-1);\n";}
dfd6b6ff680619227ea41f6617676337850bdfdce705d287cbe53f6d78370c3b
genCppGetSet
public String genCppGetSet(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "B";}
696a3ed6ebc17b5255a708100ae63a78e0aa727d0d789d7a136f91a477b3c0dd
genJavaReadWrapper
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    byte[] " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readBuffer(\"" + tag + "\");\n";}
c219f4bcae942617a43312ae06d86cb01fe05e38062c7ec6cbadd33d8e21a533
genJavaWriteWrapper
public String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.writeBuffer(" + fname + ",\"" + tag + "\");\n";}
14ef04f10ae54bb87929963e7d30a9655e9dacf47daa03fb88c2f60e7bc39e80
genJavaCompareTo
public String genJavaCompareTo(String fname, String other)
{    StringBuilder sb = new StringBuilder();    sb.append("    {\n");    sb.append("      byte[] my = " + fname + ";\n");    sb.append("      byte[] ur = " + other + ";\n");    sb.append("      ret = org.apache.jute.Utils.compareBytes(my,0,my.length,ur,0,ur.length);\n");    sb.append("    }\n");    return sb.toString();}
e40304626cb3d10631210643c4ae665cc68abe780f1d635d824167a46235ed79
genJavaCompareTo
public String genJavaCompareTo(String fname)
{    return genJavaCompareTo(fname, "peer." + fname);}
dbf46e318df8db99978640477f4c4f4583f352023ce29e778b82ae6eed13675f
genJavaCompareToWrapper
public String genJavaCompareToWrapper(String fname, String other)
{    return "    " + genJavaCompareTo(fname, other);}
e04740948c97da9a02e876723b350e27688d1fc6e276f402d4c26fcf8a0756be
genJavaEquals
public String genJavaEquals(String fname, String peer)
{    return "    ret = org.apache.jute.Utils.bufEquals(" + fname + "," + peer + ");\n";}
909155c9bae51b1031b5af86a87a9330c7ecd1a11f18ee5efd83d1673884e01b
genJavaHashCode
public String genJavaHashCode(String fname)
{    return "    ret = java.util.Arrays.toString(" + fname + ").hashCode();\n";}
70cb7f51984a87e119f03a65a717ee3b1995ec89ce9f5f2d6ccf9ae029115114
genJavaSlurpBytes
public String genJavaSlurpBytes(String b, String s, String l)
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i = org.apache.jute.Utils.readVInt(" + b + ", " + s + ");\n");    sb.append("           int z = WritableUtils.getVIntSize(i);\n");    sb.append("           " + s + " += z+i; " + l + " -= (z+i);\n");    sb.append("        }\n");    return sb.toString();}
ec8d8dd74717e45807c6e58d85e90faad6d12af1164b98d221c9269aa6756a34
genJavaCompareBytes
public String genJavaCompareBytes()
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i1 = org.apache.jute.Utils.readVInt(b1, s1);\n");    sb.append("           int i2 = org.apache.jute.Utils.readVInt(b2, s2);\n");    sb.append("           int z1 = WritableUtils.getVIntSize(i1);\n");    sb.append("           int z2 = WritableUtils.getVIntSize(i2);\n");    sb.append("           s1+=z1; s2+=z2; l1-=z1; l2-=z2;\n");    sb.append("           int r1 = org.apache.jute.Utils.compareBytes(b1,s1,l1,b2,s2,l2);\n");    sb.append("           if (r1 != 0) { return (r1<0)?-1:0; }\n");    sb.append("           s1+=i1; s2+=i2; l1-=i1; l1-=i2;\n");    sb.append("        }\n");    return sb.toString();}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "b";}
4ee28271596a82c49ed7ceca95cfbc51c40a3b2a076760f26a4c253d566dfd80
genCppGetSet
 String genCppGetSet(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
aaf7635bb62a084eb4b976347ed31ab2290f0be65344e7a53f6950788d1151e4
genJavaCompareTo
 String genJavaCompareTo(String fname)
{    return "    ret = " + fname + ".compareTo(peer." + fname + ");\n";}
ef3f80400927fe166c930ae8984799074e8f5dc5b8a7e9f81e187db092cb3746
genJavaEquals
 String genJavaEquals(String fname, String peer)
{    return "    ret = " + fname + ".equals(" + peer + ");\n";}
0b3fdbb31b1827888e2f68eff8ef46cf5873581e15f80b5fa992790306b9dc5a
genJavaHashCode
 String genJavaHashCode(String fname)
{    return "    ret = " + fname + ".hashCode();\n";}
514c479bb6bc8cbe9dc713a4054a03fa770e59bdb826650ff7e19ecad3ef2202
genCsharpHashCode
 String genCsharpHashCode(String fname)
{    return "    ret = " + capitalize(fname) + ".GetHashCode();\n";}
cf11db7425677f472d7994800cd56279ded218ae36b027e11772d86055c453a5
genCsharpEquals
 String genCsharpEquals(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = " + capitalize(name) + ".Equals(" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
36cefdb6fec45afeca409eb7a93502c3c7d1dec24eecc93bcb374eb87618a726
genCsharpCompareTo
 String genCsharpCompareTo(String name)
{    return "    ret = " + capitalize(name) + ".CompareTo(peer." + capitalize(name) + ");\n";}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "d";}
909155c9bae51b1031b5af86a87a9330c7ecd1a11f18ee5efd83d1673884e01b
genJavaHashCode
public String genJavaHashCode(String fname)
{    String tmp = "Double.doubleToLongBits(" + fname + ")";    return "    ret = (int)(" + tmp + "^(" + tmp + ">>>32));\n";}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return mType.getSignature();}
66ad31fd625052e3f50ef0d70bbd75359d2208aa7881649160002fe847c21b02
genCppDecl
public String genCppDecl()
{    return mType.genCppDecl(mName);}
3306aea17bde04ace799b9de15a212784a57b480a857291ad5bc5b9074bb7599
genCDecl
public String genCDecl()
{    return mType.genCDecl(mName);}
c1c5f38658e75d3f34f71baf8696037b7ee5c4cc0236e4ab7d665f05111340b5
genCsharpDecl
public String genCsharpDecl()
{    return mType.genCsharpDecl(mName);}
eb4b800365feb783c08c00c90bf15f68eb9cf0ba924baa77b2643434996c1b4e
genCsharpConstructorParam
public String genCsharpConstructorParam(String fname)
{    return mType.genCsharpConstructorParam(fname);}
d733d712ca36858d78a1533db1c6a68fbff61212e849d3e1851bfa8acccdb71a
genJavaDecl
public String genJavaDecl()
{    return mType.genJavaDecl(mName);}
76b99386eed0e66844c6cee7e3d4c33f29b39f349dfc0dcc58323cc38afc3aa8
genJavaConstructorParam
public String genJavaConstructorParam(String fname)
{    return mType.genJavaConstructorParam(fname);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return mName;}
01de6781aacb5d457e9c7da77e7bcaa69f5e5859542847a5caab18be52e5c010
getCsharpName
public String getCsharpName()
{    return "Id".equals(mName) ? "ZKId" : mName;}
c9718c288e4d03d9e87ac037af0db5dca8e98ecd0e506e22807297615712ce2d
getTag
public String getTag()
{    return mName;}
4d0e301fcd749e9c50db4f4b82f834a94fb74ea714f94d2d5da9dd79c547a57f
getType
public JType getType()
{    return mType;}
25d87a6e7975f267281a1297973fde42e5568728e2defb855db5b59c93a19893
genCppGetSet
public String genCppGetSet(int fIdx)
{    return mType.genCppGetSet(mName, fIdx);}
008e68e4464f4eb2fde38d48165613815e9876209c0a04f0aadacfc00a0ab084
genCsharpConstructorSet
public String genCsharpConstructorSet(String fname)
{    return mType.genCsharpConstructorSet(mName, fname);}
85d6ba5c1954fe07b84e037e1f14052e063c7e1787919d93fcaddc99b5a8e80b
genCsharpGetSet
public String genCsharpGetSet(int fIdx)
{    return mType.genCsharpGetSet(getCsharpName(), fIdx);}
f7f3f558ec61b1d70576a0605e42f8e4cb54834ab65fb85d337854a12a4a4d8f
genCsharpWriteMethodName
public String genCsharpWriteMethodName()
{    return mType.genCsharpWriteMethod(getCsharpName(), getTag());}
dc7a3c3fad1de8c7a7441fa245dc19d29472c011f49b7ad981500c298700d4f9
genCsharpReadMethodName
public String genCsharpReadMethodName()
{    return mType.genCsharpReadMethod(getCsharpName(), getTag());}
07d7a26fd48913016589410cfd87e1738598b311309629379cf178a16801b0a1
genCsharpCompareTo
public String genCsharpCompareTo()
{    return mType.genCsharpCompareTo(getCsharpName());}
8522cc3e0ffc1da12467d751ec92ed2ed372f49a4c8404cb5d4c4239ae37df22
genCsharpEquals
public String genCsharpEquals()
{    return mType.genCsharpEquals(getCsharpName(), "peer." + getCsharpName());}
ec1cda9db0fd7ee1fe74e62cbebbd94dddce763091f8cc3fb7a124acb754ad41
genCsharpHashCode
public String genCsharpHashCode()
{    return mType.genCsharpHashCode(getCsharpName());}
ba060a3c15173e65217df68fb56600fb67188d9fba1f3afd2817ecf8691f18ba
genJavaGetSet
public String genJavaGetSet(int fIdx)
{    return mType.genJavaGetSet(mName, fIdx);}
69a46ccbce6b6559d03fbd531f6e5834beb223c567a246314d204984d1a440ca
genJavaWriteMethodName
public String genJavaWriteMethodName()
{    return mType.genJavaWriteMethod(getName(), getTag());}
d4ea911b91a6011eb3862b01e5b31e671b98287cfafb1ae5d1e06b6ffa26d841
genJavaReadMethodName
public String genJavaReadMethodName()
{    return mType.genJavaReadMethod(getName(), getTag());}
2f055b85e4b6a1c677b11e40e7b3350f6e10bd0dc524163ad4b9e4d6b877436a
genJavaCompareTo
public String genJavaCompareTo()
{    return mType.genJavaCompareTo(getName());}
e9ea35da082c7783ac9293e1250ed11af772cb084dc65385b18b3d6d090cd62b
genJavaEquals
public String genJavaEquals()
{    return mType.genJavaEquals(getName(), "peer." + getName());}
fcf3ae50c180182e5ea9d0dc1665de7f7f61dd6220693aa940cf31a398130edb
genJavaHashCode
public String genJavaHashCode()
{    return mType.genJavaHashCode(getName());}
fedf0b190f81cf4533cd3054d5dde9a2560b8ad95b4f1ce7601f5c62dd6ee992
genJavaConstructorSet
public String genJavaConstructorSet(String fname)
{    return mType.genJavaConstructorSet(mName, fname);}
0c786cac7bb579622c9ab7c4d2d58ca1e63a59687a9e7538f6ae86092d8891ec
getName
 String getName()
{    int idx = mName.lastIndexOf('/');    return (idx > 0) ? mName.substring(idx) : mName;}
475f792e200058762e950fb977f36ae3536ab53f5470a84c206de5276e627c8b
genCode
public void genCode(String language, File outputDirectory) throws IOException
{    if ("c++".equals(language)) {        CppGenerator gen = new CppGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("java".equals(language)) {        JavaGenerator gen = new JavaGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("c".equals(language)) {        CGenerator gen = new CGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("csharp".equals(language)) {        CSharpGenerator gen = new CSharpGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else {        throw new IOException("Cannnot recognize language:" + language);    }}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "f";}
909155c9bae51b1031b5af86a87a9330c7ecd1a11f18ee5efd83d1673884e01b
genJavaHashCode
public String genJavaHashCode(String fname)
{    return "    ret = Float.floatToIntBits(" + fname + ");\n";}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "i";}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "l";}
909155c9bae51b1031b5af86a87a9330c7ecd1a11f18ee5efd83d1673884e01b
genJavaHashCode
public String genJavaHashCode(String fname)
{    return "    ret = (int) (" + fname + "^(" + fname + ">>>32));\n";}
1a1ac1efc95949614b687fa490f64f6286775c14c173ac99c48cbf92785c18d1
getLevel
private static String getLevel()
{    return Integer.toString(level);}
b5439922df8a0f7c78217f3b972452127c56daccc6ad19987b2bedac17f042c7
incrLevel
private static void incrLevel()
{    level++;}
61b7a42d82e3b92b3bf23e1688facc9a1ebab33ef80c0d0d24f09831b65677b2
decrLevel
private static void decrLevel()
{    level--;}
055a6800e13eb9034254344b2741b9f57802a9f86dcbb24ae04cb1db2752968d
getId
private static String getId(String id)
{    return id + getLevel();}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "{" + mKey.getSignature() + mValue.getSignature() + "}";}
e40304626cb3d10631210643c4ae665cc68abe780f1d635d824167a46235ed79
genJavaCompareTo
public String genJavaCompareTo(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
696a3ed6ebc17b5255a708100ae63a78e0aa727d0d789d7a136f91a477b3c0dd
genJavaReadWrapper
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    java.util.TreeMap " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      org.apache.jute.Index " + getId("midx") + " = a_.startMap(\"" + tag + "\");\n");    ret.append("      " + fname + "=new java.util.TreeMap();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genJavaReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genJavaReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".put(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.endMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
6c7637d3b2f5048c1372fbb49547782df2b244be1441656da2f3e5fa08e2c844
genJavaReadMethod
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
c219f4bcae942617a43312ae06d86cb01fe05e38062c7ec6cbadd33d8e21a533
genJavaWriteWrapper
public String genJavaWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getJavaWrapperType() + " " + getId("k") + " = (" + mKey.getJavaWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getJavaWrapperType() + " " + getId("v") + " = (" + mValue.getJavaWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genJavaWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genJavaWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.endMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
2025dc25445f89a856ae89157e6222f6754711dedc1b6337dc39ce92b4efe09a
genJavaWriteMethod
public String genJavaWriteMethod(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
5b900c1ea8c556478953b9cd0facf8e513d233677271e869c801c4cc49fcf290
genCsharpWriteWrapper
public String genCsharpWriteWrapper(String fname, int tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getCsharpWrapperType() + " " + getId("k") + " = (" + mKey.getCsharpWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getCsharpWrapperType() + " " + getId("v") + " = (" + mValue.getCsharpWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genCsharpWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genCsharpWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.EndMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
ace5118702bf1ba927756ef5375e1e5922d0fc663bf954a73848966c5459d61f
genCsharpWriteMethod
 String genCsharpWriteMethod(String fname, int tag)
{    return genCsharpWriteWrapper(fname, tag);}
b4275b2038bb8f5202e83c0965a0b4ec12f72344f79ad844e6795b83de6a2d33
genCsharpReadWrapper
public String genCsharpReadWrapper(String fname, int tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    System.Collections.SortedDictionary<string,string> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Org.Apache.Jute.IIndex " + getId("midx") + " = a_.StartMap(\"" + tag + "\");\n");    ret.append("      " + fname + "= new System.Collections.SortedDictionary<string,string>();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genCsharpReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genCsharpReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".Add(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.EndMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
da5fbac4fa8b87981bca045f8a603f1ba54c7db69bdf2506ad89e89591e25aba
genCsharpReadMethod
 String genCsharpReadMethod(String fname, int tag)
{    return genCsharpReadWrapper(fname, tag, false);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return mName;}
01de6781aacb5d457e9c7da77e7bcaa69f5e5859542847a5caab18be52e5c010
getCsharpName
public String getCsharpName()
{    return "Id".equals(mName) ? "ZKId" : mName;}
97b80c1f5deaf3aa3bc287e22d9aca7741be648a37c46de9497749bf4fb123e8
getJavaFQName
public String getJavaFQName()
{    return mFQName;}
17a2a6d63359b6748a0af9cb4e15290bead38a2b3e13b3504c9c43859438d211
getCppFQName
public String getCppFQName()
{    return mFQName.replaceAll("\\.", "::");}
9ab60b4abb1f72efa82babe135abc0938ef06afe122966362d909d82f258bb25
getJavaPackage
public String getJavaPackage()
{    return mModule;}
54c51107e2c4e98000d5c7bd60552737ef0aea3674c6121e138f33909649f769
getCppNameSpace
public String getCppNameSpace()
{    return mModule.replaceAll("\\.", "::");}
e5dd1855eee8c9a648e7848fe1d920f7b6aa1341e742757fa27c6cfadc8989ae
getCsharpNameSpace
public String getCsharpNameSpace()
{    String[] parts = mModule.split("\\.");    StringBuffer namespace = new StringBuffer();    for (int i = 0; i < parts.length; i++) {        String capitalized = parts[i].substring(0, 1).toUpperCase() + parts[i].substring(1).toLowerCase();        namespace.append(capitalized);        if (i != parts.length - 1) {            namespace.append(".");        }    }    return namespace.toString();}
bb76fc174aed5f463bd72b664420daced06b7421e6380016408d35fef2f031ba
getFields
public List<JField> getFields()
{    return mFields;}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    StringBuilder sb = new StringBuilder();    sb.append("L").append(mName).append("(");    for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {        String s = i.next().getSignature();        sb.append(s);    }    sb.append(")");    return sb.toString();}
7a96387f26bf91804546e62bdf0e258dbc8e33cb19951ce6eec2b58755bb532b
genCppDecl
public String genCppDecl(String fname)
{    return "  " + getCppNameSpace() + "::" + mName + " m" + fname + ";\n";}
6c7637d3b2f5048c1372fbb49547782df2b244be1441656da2f3e5fa08e2c844
genJavaReadMethod
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
696a3ed6ebc17b5255a708100ae63a78e0aa727d0d789d7a136f91a477b3c0dd
genJavaReadWrapper
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getJavaFQName() + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getJavaFQName() + "();\n");    ret.append("    a_.readRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
c219f4bcae942617a43312ae06d86cb01fe05e38062c7ec6cbadd33d8e21a533
genJavaWriteWrapper
public String genJavaWriteWrapper(String fname, String tag)
{    return "    a_.writeRecord(" + fname + ",\"" + tag + "\");\n";}
0764cdd93ab0b6000755f72504183f4ff55c7ce239192519c8593902c4d4ab7e
genCsharpReadMethod
 String genCsharpReadMethod(String fname, String tag)
{        return genCsharpReadWrapper(capitalize(fname), tag, false);}
71b6663fc41de4295677ab471665a86982f0751394e135f8cb9a66510d593c9d
genCsharpReadWrapper
public String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getCsharpFQName(mFQName) + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getCsharpFQName(mFQName) + "();\n");    ret.append("    a_.ReadRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
e6b6c337581598cf996d92f7f2d6d8442a2e2fbbd769b6691547432ee8e57457
genCsharpWriteWrapper
public String genCsharpWriteWrapper(String fname, String tag)
{    return "    a_.WriteRecord(" + fname + ",\"" + tag + "\");\n";}
eaa7f8f84ec4bba1553187b655f62fb74dab5bf8f89411fc954b58f6fa8c506b
genCCode
public void genCCode(FileWriter h, FileWriter c) throws IOException
{    for (JField f : mFields) {        if (f.getType() instanceof JVector) {            JVector jv = (JVector) f.getType();            JType jvType = jv.getElementType();            String structName = JVector.extractVectorName(jvType);            if (vectorStructs.get(structName) == null) {                vectorStructs.put(structName, structName);                h.write("struct " + structName + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + "\n};\n");                h.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v);\n");                h.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v);\n");                h.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len);\n");                h.write("int deallocate_" + structName + "(struct " + structName + " *v);\n");                c.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len) {\n");                c.write("    if (!len) {\n");                c.write("        v->count = 0;\n");                c.write("        v->data = 0;\n");                c.write("    } else {\n");                c.write("        v->count = len;\n");                c.write("        v->data = calloc(sizeof(*v->data), len);\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int deallocate_" + structName + "(struct " + structName + " *v) {\n");                c.write("    if (v->data) {\n");                c.write("        int32_t i;\n");                c.write("        for(i=0;i<v->count; i++) {\n");                c.write("            deallocate_" + JRecord.extractMethodSuffix(jvType) + "(&v->data[i]);\n");                c.write("        }\n");                c.write("        free(v->data);\n");                c.write("        v->data = 0;\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int32_t count = v->count;\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = out->start_vector(out, tag, &count);\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genSerialize(c, jvType, "data", "data[i]");                c.write("    }\n");                c.write("    rc = rc ? rc : out->end_vector(out, tag);\n");                c.write("    return rc;\n");                c.write("}\n");                c.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = in->start_vector(in, tag, &v->count);\n");                c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genDeserialize(c, jvType, "value", "data[i]");                c.write("    }\n");                c.write("    rc = in->end_vector(in, tag);\n");                c.write("    return rc;\n");                c.write("}\n");            }        }    }    String recName = getName();    h.write("struct " + recName + " {\n");    for (JField f : mFields) {        h.write(f.genCDecl());    }    h.write("};\n");    h.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v);\n");    h.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v);\n");    h.write("void deallocate_" + recName + "(struct " + recName + "*);\n");    c.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = out->start_record(out, tag);\n");    for (JField f : mFields) {        genSerialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : out->end_record(out, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = in->start_record(in, tag);\n");    for (JField f : mFields) {        genDeserialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : in->end_record(in, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("void deallocate_" + recName + "(struct " + recName + "*v)");    c.write("{\n");    for (JField f : mFields) {        if (f.getType() instanceof JRecord) {            c.write("    deallocate_" + extractStructName(f.getType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JVector) {            JVector vt = (JVector) f.getType();            c.write("    deallocate_" + JVector.extractVectorName(vt.getElementType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JCompType) {            c.write("    deallocate_" + extractMethodSuffix(f.getType()) + "(&v->" + f.getName() + ");\n");        }    }    c.write("}\n");}
eb312ba611f5fbb300d166cab8b7621a3e9d915e799f19811884753549766295
genSerialize
private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : serialize_" + extractStructName(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : serialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : out->serialize_" + extractMethodSuffix(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    }}
4f15b473b1fbb7ba427abbcb74ec66ab51d6131d878dfb5a2c324e9333322fe7
genDeserialize
private void genDeserialize(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : deserialize_" + extractStructName(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : deserialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : in->deserialize_" + extractMethodSuffix(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    }}
d582cc57a5316007f28a55c8ef8b79c444a761fde5102a7e8be861ba7b5a3d72
extractMethodSuffix
 static String extractMethodSuffix(JType t)
{    if (t instanceof JRecord) {        return extractStructName(t);    }    return t.getMethodSuffix();}
bea5150cfb23fae9829ee8ac4bccfa3518d3123e396a109d6fcb68c277a839ba
extractStructName
private static String extractStructName(JType t)
{    String type = t.getCType();    if (!type.startsWith("struct ")) {        return type;    }    return type.substring("struct ".length());}
c231f2e6598ba3f42511b5a95efb8b1b2d3718bbd4ba17c910000966ad76b462
getCsharpFQName
public static String getCsharpFQName(String name)
{    String[] packages = name.split("\\.");    StringBuffer fQName = new StringBuffer();    for (int i = 0; i < packages.length; i++) {        String pack = packages[i];        pack = capitalize(pack);        pack = "Id".equals(pack) ? "ZKId" : pack;        fQName.append(capitalize(pack));        if (i != packages.length - 1) {            fQName.append(".");        }    }    return fQName.toString();}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "s";}
696a3ed6ebc17b5255a708100ae63a78e0aa727d0d789d7a136f91a477b3c0dd
genJavaReadWrapper
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    String " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readString(\"" + tag + "\");\n";}
c219f4bcae942617a43312ae06d86cb01fe05e38062c7ec6cbadd33d8e21a533
genJavaWriteWrapper
public String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.writeString(" + fname + ",\"" + tag + "\");\n";}
cfef63a4e2b17c336eca7082c0b087335fbcaaa943d3ae83f3bbb79b0f9c945d
genCppDecl
 String genCppDecl(String fname)
{    return "  " + mCppName + " m" + fname + ";\n";}
6880db8c49d895451576edaab99e9d4e2f4e21a965bad81cc0ccfaa1317be8c9
genCDecl
 String genCDecl(String name)
{    return "    " + mCName + " " + name + ";\n";}
eaa11d62f410d51c0d4397296de73cbd8664ace2d4cd9a693cd110338d15f576
genCsharpDecl
public String genCsharpDecl(String name)
{    return "  private " + mCsharpName + " " + name + ";\n";}
2e0a2d81e812983527ec41969c3ab6f14320e34f39a3cb2b657f025c5021e75f
genJavaDecl
 String genJavaDecl(String fname)
{    return "  private " + mJavaName + " " + fname + ";\n";}
5ecc3f7c7c28b1017cadcbb2a891d995ed4d8328cfc9cadaf0e30a5c9e5d9971
genJavaConstructorParam
 String genJavaConstructorParam(String fname)
{    return "        " + mJavaName + " " + fname;}
4ee28271596a82c49ed7ceca95cfbc51c40a3b2a076760f26a4c253d566dfd80
genCppGetSet
 String genCppGetSet(String fname, int fIdx)
{    String getFunc = "  virtual " + mCppName + " get" + fname + "() const {\n";    getFunc += "    return m" + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  virtual void set" + fname + "(" + mCppName + " m_) {\n";    setFunc += "    m" + fname + "=m_; bs_.set(" + fIdx + ");\n";    setFunc += "  }\n";    return getFunc + setFunc;}
5fc3447ef3483ce19a1154df7df3ac47ffd7373556e97e0781d6863f6b883d00
genCsharpGetSet
 String genCsharpGetSet(String fname, int fIdx)
{    String getFunc = "  public " + getCsharpType() + " " + capitalize(fname) + " { get; set; } ";    return getFunc;}
a9afe2e07982e718632edafee7d34c7bccfb9149769966758a809291b9a07224
capitalize
 static String capitalize(String s)
{    return s.substring(0, 1).toUpperCase() + s.substring(1);}
5ebdd4ca293f61bb2aa77aa78abbcfaff5717267cbc9c65c171002cad5e7aa3c
genJavaGetSet
 String genJavaGetSet(String fname, int fIdx)
{    String getFunc = "  public " + mJavaName + " get" + capitalize(fname) + "() {\n";    getFunc += "    return " + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  public void set" + capitalize(fname) + "(" + mJavaName + " m_) {\n";    setFunc += "    " + fname + "=m_;\n";    setFunc += "  }\n";    return getFunc + setFunc;}
fe9498f648f44b25e573f89d0ea7ccc4b7ed33e272278eaf1ff1c4e941145596
getCType
 String getCType()
{    return mCName;}
551e887a2a42498a8249d1b9d4e6ad1f4e75153f8292a2d2a61beb34fb04019c
getCppType
 String getCppType()
{    return mCppName;}
2280e704657defd2594fdf86d0a630cca24c58e80964b613be86ff076adee500
getCsharpType
 String getCsharpType()
{    return mCsharpName;}
093b8f7ab28c31e4fc2a47545f37faf74e0ba8d7adfe3cfb8e540e0557d3d33a
getJavaType
 String getJavaType()
{    return mJavaName;}
74a701daded59e50ded80088895b3ff65718e2ba33d914cfab762f4a996d7d0c
getJavaWrapperType
 String getJavaWrapperType()
{    return mWrapper;}
25984135ad31c3f0ce2888769b1f76de54f866f0a9878cb8e71ae69d16759ac2
getCsharpWrapperType
 String getCsharpWrapperType()
{    return mSharpWrapper;}
b735f447fa94562e3e3bccadb8d599d8a865f0f2252a029401535e256ce9a399
getMethodSuffix
 String getMethodSuffix()
{    return mMethodSuffix;}
d173ac09836a3fa5534c25f6575533ec0fd172d2a333a5f03e8ca6b5523dd0a7
genJavaWriteMethod
 String genJavaWriteMethod(String fname, String tag)
{    return "    a_.write" + mMethodSuffix + "(" + fname + ",\"" + tag + "\");\n";}
f700ec4d4e70222323c01042555b411ec18a9fcecb120fe6bc1d9e9af1104a43
genJavaReadMethod
 String genJavaReadMethod(String fname, String tag)
{    return "    " + fname + "=a_.read" + mMethodSuffix + "(\"" + tag + "\");\n";}
8b364e014dbb6460ae31f3283ba07cd6f1084df370c77fe8c6ca7cab4fa34340
genJavaReadWrapper
 String genJavaReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=new " + mWrapper + "(a_.read" + mMethodSuffix + "(\"" + tag + "\"));\n";}
45a5360b902fd003efa9f6fbe72debfe699824ac548a53fafec8853b0f15b1a7
genJavaWriteWrapper
 String genJavaWriteWrapper(String fname, String tag)
{    return "        a_.write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
aaf7635bb62a084eb4b976347ed31ab2290f0be65344e7a53f6950788d1151e4
genJavaCompareTo
 String genJavaCompareTo(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 :((" + fname + "<peer." + fname + ")?-1:1);\n";}
ef3f80400927fe166c930ae8984799074e8f5dc5b8a7e9f81e187db092cb3746
genJavaEquals
 String genJavaEquals(String fname, String peer)
{    return "    ret = (" + fname + "==" + peer + ");\n";}
0b3fdbb31b1827888e2f68eff8ef46cf5873581e15f80b5fa992790306b9dc5a
genJavaHashCode
 String genJavaHashCode(String fname)
{    return "    ret = (int)" + fname + ";\n";}
e8106cb68bffca4528aea68922c440490c6490e1fc2d9d2a54c2bb15b50ede1c
genJavaConstructorSet
 String genJavaConstructorSet(String fname, String name)
{    return "    this." + fname + "=" + name + ";\n";}
9779d9cc56864071aa94aee625e9644349988bf7368963877b36e5ab3b738807
genCsharpWriteMethod
 String genCsharpWriteMethod(String fname, String tag)
{    return "    a_.Write" + mMethodSuffix + "(" + capitalize(fname) + ",\"" + tag + "\");\n";}
0764cdd93ab0b6000755f72504183f4ff55c7ce239192519c8593902c4d4ab7e
genCsharpReadMethod
 String genCsharpReadMethod(String fname, String tag)
{    return "    " + capitalize(fname) + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
7cea56183125f403e49cc021e660a28be19a3a1b063b08abe0728b27de2dd391
genCsharpReadWrapper
 String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
9124ef16a4a1435fe6e210cda88e36d0eb233ad08e2867184e987968e9506eb5
genCsharpWriteWrapper
 String genCsharpWriteWrapper(String fname, String tag)
{    return (mUnwrapMethod == null) ? "        a_.Write" + mMethodSuffix + "(" + fname + "," + tag + ");\n" : "        a_.Write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
36cefdb6fec45afeca409eb7a93502c3c7d1dec24eecc93bcb374eb87618a726
genCsharpCompareTo
 String genCsharpCompareTo(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 :((" + capitalize(name) + "<peer." + capitalize(name) + ")?-1:1);\n";}
cf11db7425677f472d7994800cd56279ded218ae36b027e11772d86055c453a5
genCsharpEquals
 String genCsharpEquals(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = (" + capitalize(name) + "==" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
514c479bb6bc8cbe9dc713a4054a03fa770e59bdb826650ff7e19ecad3ef2202
genCsharpHashCode
 String genCsharpHashCode(String fname)
{    return "    ret = (int)" + capitalize(fname) + ";\n";}
87ac7674b4c3b81d94b6659ef86819f9c395385139ac7ca3b5d45b14b56daef8
genCsharpConstructorSet
 String genCsharpConstructorSet(String mName, String fname)
{    return capitalize(fname) + "=" + mName + ";\n";}
eb4b800365feb783c08c00c90bf15f68eb9cf0ba924baa77b2643434996c1b4e
genCsharpConstructorParam
public String genCsharpConstructorParam(String fname)
{    return "  " + mCsharpName + " " + fname + "\n";}
055a6800e13eb9034254344b2741b9f57802a9f86dcbb24ae04cb1db2752968d
getId
private static String getId(String id)
{    return id + getLevel();}
1a1ac1efc95949614b687fa490f64f6286775c14c173ac99c48cbf92785c18d1
getLevel
private static String getLevel()
{    return Integer.toString(level);}
b5439922df8a0f7c78217f3b972452127c56daccc6ad19987b2bedac17f042c7
incrLevel
private static void incrLevel()
{    level++;}
61b7a42d82e3b92b3bf23e1688facc9a1ebab33ef80c0d0d24f09831b65677b2
decrLevel
private static void decrLevel()
{    level--;}
ea69dbc225e68bd42c550d38a170c1e72ac2f8b5db91ca6733c567b916a7008a
getSignature
public String getSignature()
{    return "[" + mElement.getSignature() + "]";}
e40304626cb3d10631210643c4ae665cc68abe780f1d635d824167a46235ed79
genJavaCompareTo
public String genJavaCompareTo(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
696a3ed6ebc17b5255a708100ae63a78e0aa727d0d789d7a136f91a477b3c0dd
genJavaReadWrapper
public String genJavaReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("      java.util.List " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Index " + getId("vidx") + " = a_.startVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + fname + "=new java.util.ArrayList<" + mElement.getJavaType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".done(); " + getId("vidx") + ".incr()) {\n");    ret.append(mElement.genJavaReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + fname + ".add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.endVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
6c7637d3b2f5048c1372fbb49547782df2b244be1441656da2f3e5fa08e2c844
genJavaReadMethod
public String genJavaReadMethod(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
c219f4bcae942617a43312ae06d86cb01fe05e38062c7ec6cbadd33d8e21a533
genJavaWriteWrapper
public String genJavaWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startVector(" + fname + ",\"" + tag + "\");\n");    ret.append("      if (" + fname + "!= null) {");    ret.append("          int " + getId("len") + " = " + fname + ".size();\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getJavaWrapperType() + " " + getId("e") + " = (" + mElement.getJavaWrapperType() + ") " + fname + ".get(" + getId("vidx") + ");\n");    ret.append(mElement.genJavaWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.endVector(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
2025dc25445f89a856ae89157e6222f6754711dedc1b6337dc39ce92b4efe09a
genJavaWriteMethod
public String genJavaWriteMethod(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
d7a4fff70c926eaed6baf1ae4d5c5b4eb4b3003dc51a48c96dfc5aa38f93ff02
getElementType
public JType getElementType()
{    return mElement;}
e6b6c337581598cf996d92f7f2d6d8442a2e2fbbd769b6691547432ee8e57457
genCsharpWriteWrapper
public String genCsharpWriteWrapper(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("      if (" + capitalize(fname) + "!= null) {");    ret.append("          int " + getId("len") + " = " + capitalize(fname) + ".Count;\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getCsharpWrapperType() + " " + getId("e") + " = (" + mElement.getCsharpWrapperType() + ") " + capitalize(fname) + "[" + getId("vidx") + "];\n");    ret.append(mElement.genCsharpWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.EndVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
9779d9cc56864071aa94aee625e9644349988bf7368963877b36e5ab3b738807
genCsharpWriteMethod
 String genCsharpWriteMethod(String fname, String tag)
{    return genCsharpWriteWrapper(fname, tag);}
71b6663fc41de4295677ab471665a86982f0751394e135f8cb9a66510d593c9d
genCsharpReadWrapper
public String genCsharpReadWrapper(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder();    if (decl) {        ret.append("      System.Collections.Generic.List<" + mElement.getCsharpType() + "> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      IIndex " + getId("vidx") + " = a_.StartVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + capitalize(fname) + "=new System.Collections.Generic.List<" + mElement.getCsharpType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".Done(); " + getId("vidx") + ".Incr()) {\n");    ret.append(mElement.genCsharpReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + capitalize(fname) + ".Add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.EndVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
0764cdd93ab0b6000755f72504183f4ff55c7ce239192519c8593902c4d4ab7e
genCsharpReadMethod
 String genCsharpReadMethod(String fname, String tag)
{    return genCsharpReadWrapper(fname, tag, false);}
ffd93d17d6389d875e53ec1a5842736ca280514817151257ac18baa32045bc21
extractVectorName
 static String extractVectorName(JType jvType)
{    return JRecord.extractMethodSuffix(jvType) + "_vector";}
6345a4a2c81c11475aa32fb968c9a8470949bd3a2483237319e3963cbf5007fc
createArchive
private static InputArchive createArchive(InputStream in, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { in };        try {            return (InputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
813af1d916bd58d5fdd515092c26b8ab59fd504005e8755fd71f8d05f417e85b
read
public void read(Record r) throws IOException
{    r.deserialize(archive, "");}
12c01303b8083d76258ed886e7b0d033956714f198880aadca23fabc22e3b46c
constructFactory
 static HashMap<String, Method> constructFactory()
{    HashMap<String, Method> factory = new HashMap<String, Method>();    try {        factory.put("binary", BinaryOutputArchive.class.getDeclaredMethod("getArchive", OutputStream.class));    } catch (SecurityException | NoSuchMethodException ex) {        ex.printStackTrace();    }    return factory;}
c31e42f33f7e946f45b0038e5e807d3cc7795c80fae8ffa764a55088c5d5eff7
createArchive
private static OutputArchive createArchive(OutputStream out, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { out };        try {            return (OutputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
9715f36fe1ee0c10885dff6465bf2d94e55af2b6b0451114558e6a6a528f1bb3
write
public void write(Record r) throws IOException
{    r.serialize(archive, "");}
5ec893a18e058e486cde7868a29d9308c2b4a9a45f2172daacd5055fa212b83c
throwExceptionOnError
private void throwExceptionOnError(String tag) throws IOException
{    if (stream.checkError()) {        throw new IOException("Error serializing " + tag);    }}
45fbd3a0a96f9964ca2eed306c0f7ae15b23417fa57d2116bd961a33d506de7e
printCommaUnlessFirst
private void printCommaUnlessFirst()
{    if (!isFirst) {        stream.print(",");    }    isFirst = false;}
36dd3e0bfec762a5b7b7eed75f2b0aa37cb97581be000d18e85806d956920c9d
writeByte
public void writeByte(byte b, String tag) throws IOException
{    writeLong((long) b, tag);}
2077352d6f236d7ed32d965e0c6e98a165488380ceb5e88d57670c2313d31ee2
writeBool
public void writeBool(boolean b, String tag) throws IOException
{    printCommaUnlessFirst();    String val = b ? "T" : "F";    stream.print(val);    throwExceptionOnError(tag);}
7f2b5ecb348aacbeabed81e0f0cf43f839fa78cbad461faa09ebd9bd31db2c37
writeInt
public void writeInt(int i, String tag) throws IOException
{    writeLong((long) i, tag);}
e358a697af25dc9ee2726911756380c33aa8b813c237a01b73dff75ed54b5670
writeLong
public void writeLong(long l, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(l);    throwExceptionOnError(tag);}
a47380e58dbee03ff1059b5af36250fd5dfc14fe8c04192364552b564f5db51b
writeFloat
public void writeFloat(float f, String tag) throws IOException
{    writeDouble((double) f, tag);}
9598fc48c3269269d0fc4a37bbae0677a26ba321260e5b58d0f917fdf8cee7f4
writeDouble
public void writeDouble(double d, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(d);    throwExceptionOnError(tag);}
5ea3c19be876ab804ccf231692fefd3ca44b4a00142f95b5b7aaf4193fc310d0
writeString
public void writeString(String s, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeString(s));    throwExceptionOnError(tag);}
ab08260b00f81d91bb71b088323cf70d14e2cfc87dcd8b67f21ce544d058f981
writeBuffer
public void writeBuffer(byte[] buf, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeBuffer(buf));    throwExceptionOnError(tag);}
64bb611dbb27873489157fc69e6392c0bf17411ba942997ac2a5c7ab8ab33ad5
writeRecord
public void writeRecord(Record r, String tag) throws IOException
{    if (r == null) {        return;    }    r.serialize(this, tag);}
03e188dd2aafef8115221c892f6433bf0b72fbe92bb9da6a1b449369414cad64
startRecord
public void startRecord(Record r, String tag) throws IOException
{    if (tag != null && !"".equals(tag)) {        printCommaUnlessFirst();        stream.print("s{");        isFirst = true;    }}
b9201dc8811f92ccd42bb59adbc790f8b2bb5576860e5a6c8a235854ba422a45
endRecord
public void endRecord(Record r, String tag) throws IOException
{    if (tag == null || "".equals(tag)) {        stream.print("\n");        isFirst = true;    } else {        stream.print("}");        isFirst = false;    }}
0f72e6acfaba9aeeac39baeb68348308ffaefb55e8ff1be8eaa932808e20f539
startVector
public void startVector(List<?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("v{");    isFirst = true;}
ae2d5241f1796263e5c1c0a0191c4134f759329d2c9f219411771f1b77ac68c1
endVector
public void endVector(List<?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
e8c9fba71e8a6cd73f55d2d370e05570c096eb03140af9f67090f58fca111757
startMap
public void startMap(TreeMap<?, ?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("m{");    isFirst = true;}
e667ffe879568bfa768c7a45463162004bb210019b13b8f3df2a43c25b3636ba
endMap
public void endMap(TreeMap<?, ?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
370c533c6d87685b766de00415b45d5f2b1e5fece3f7fe99cc4fb7752329cf22
escapeString
private static String escapeString(String s)
{    if (s == null) {        return "";    }    StringBuilder sb = new StringBuilder(s.length() + 1);    sb.append('\'');    int len = s.length();    for (int i = 0; i < len; i++) {        char c = s.charAt(i);        switch(c) {            case '\0':                sb.append("%00");                break;            case '\n':                sb.append("%0A");                break;            case '\r':                sb.append("%0D");                break;            case ',':                sb.append("%2C");                break;            case '}':                sb.append("%7D");                break;            case '%':                sb.append("%25");                break;            default:                sb.append(c);        }    }    return sb.toString();}
523bcce7b44a188f0433430e77e35b507a20161f688ef6ee61cdcdf954fc0e0d
escapeBuffer
private static String escapeBuffer(byte[] barr)
{    if (barr == null || barr.length == 0) {        return "";    }    StringBuilder sb = new StringBuilder(barr.length + 1);    sb.append('#');    for (byte b : barr) {        sb.append(Integer.toHexString(b));    }    return sb.toString();}
3fe0872c8c9d6b092c1510f84e29221d400fa8262611a20d9a736ab50d5306e9
bufEquals
public static boolean bufEquals(byte[] onearray, byte[] twoarray)
{    if (onearray == twoarray) {        return true;    }    boolean ret = (onearray.length == twoarray.length);    if (!ret) {        return ret;    }    for (int idx = 0; idx < onearray.length; idx++) {        if (onearray[idx] != twoarray[idx]) {            return false;        }    }    return true;}
49a42a336f3cbc14f79fc34a361e1d62cbce17b40c32bac7d62566b5cbe60cf9
compareBytes
public static int compareBytes(byte[] b1, int off1, int len1, byte[] b2, int off2, int len2)
{    int i;    for (i = 0; i < len1 && i < len2; i++) {        if (b1[off1 + i] != b2[off2 + i]) {            return b1[off1 + i] < b2[off2 + i] ? -1 : 1;        }    }    if (len1 != len2) {        return len1 < len2 ? -1 : 1;    }    return 0;}
3acccc4e38e8460bdd40034b80a0ad0a701d63c353abd7531f100b5ae9e38e19
testReadStringCheckLength
public void testReadStringCheckLength()
{    byte[] buf = new byte[] { Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE };    ByteArrayInputStream is = new ByteArrayInputStream(buf);    BinaryInputArchive ia = BinaryInputArchive.getArchive(is);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
9500cd0ec61345eb2dbbac23aa6084c929ef2e554accea972200f7261b42878a
checkWriterAndReader
private void checkWriterAndReader(TestWriter writer, TestReader reader)
{    TestCheckWriterReader.checkWriterAndReader(BinaryOutputArchive::getArchive, BinaryInputArchive::getArchive, writer, reader);}
2f10d36bafbb2b3dfe9117c739286851614ea4b4edaacb4a39d77c0ba7e40abd
testInt
public void testInt()
{    final int expected = 4;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeInt(expected, tag), (ia) -> {        int actual = ia.readInt(tag);        assertEquals(expected, actual);    });}
95dd869ea78fb3cf2ba7a6efdeead57bfb963fd6ab132eff0e952308ec57b814
testBool
public void testBool()
{    final boolean expected = false;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBool(expected, tag), (ia) -> {        boolean actual = ia.readBool(tag);        assertEquals(expected, actual);    });}
eeeafcd44575acfda0a5acf65dc9f11e90ef70e62392a3884ffe471fde22edb3
testString
public void testString()
{    final String expected = "hello";    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeString(expected, tag), (ia) -> {        String actual = ia.readString(tag);        assertEquals(expected, actual);    });}
305242112461377069be291ad69495bf1e1db9d018e7721514c34899670969e1
testFloat
public void testFloat()
{    final float expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-10f;    checkWriterAndReader((oa) -> oa.writeFloat(expected, tag), (ia) -> {        float actual = ia.readFloat(tag);        assertEquals(expected, actual, delta);    });}
c5220b2b43a81a5c3331a84039191e97649ce2b6be86398d7d8981dd5be2fff4
testDouble
public void testDouble()
{    final double expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-20f;    checkWriterAndReader((oa) -> oa.writeDouble(expected, tag), (ia) -> {        double actual = ia.readDouble(tag);        assertEquals(expected, actual, delta);    });}
7bf2643525da4b301981b7464f7bfe2833bf258d1556bd6fe16214a28a21b0c5
testBuffer
public void testBuffer()
{    final byte[] expected = "hello-world".getBytes(StandardCharsets.UTF_8);    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBuffer(expected, tag), (ia) -> {        byte[] actual = ia.readBuffer(tag);        assertArrayEquals(expected, actual);    });}
4856693b54f38e5be6e12c1954c52b686ae71c4795ba24d3aabc3aefde62c4ee
testReadStringForRecordsHavingLengthMoreThanMaxAllowedSize
public void testReadStringForRecordsHavingLengthMoreThanMaxAllowedSize()
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;        int recordSize = maxBufferSize + extraMaxBufferSize + 100;    BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
aa70a27526a182e66dcfd53236e4fa060c41a055fdadbbf633ffef9eac8304da
testReadStringForRecordsHavingLengthLessThanMaxAllowedSize
public void testReadStringForRecordsHavingLengthLessThanMaxAllowedSize() throws IOException
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;    int recordSize = maxBufferSize + extraMaxBufferSize - 100;        BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    String s = ia.readString("");    assertNotNull(s);    assertEquals(recordSize, s.getBytes().length);}
c5cc8498d922996feaf285bf791e2f92b5955ab2229c7a23fcd931e1f8914227
getBinaryInputArchive
private BinaryInputArchive getBinaryInputArchive(int recordSize, int maxBufferSize, int extraMaxBufferSize)
{    byte[] data = getData(recordSize);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));    return new BinaryInputArchive(dis, maxBufferSize, extraMaxBufferSize);}
3764a3fe2c6f7e9fe8e0d76fe18667caaa889f2ffc2d5b6a42ad55d1e8e80100
getData
private byte[] getData(int recordSize)
{    ByteBuffer buf = ByteBuffer.allocate(recordSize + 4);    buf.putInt(recordSize);    byte[] bytes = new byte[recordSize];    for (int i = 0; i < recordSize; i++) {        bytes[i] = (byte) 'a';    }    buf.put(bytes);    return buf.array();}
e0b15407ed5906a4f91b1c4b2e39daf33f648d37b2dede1c13ca0588dec0392b
checkWriterAndReader
 static void checkWriterAndReader(TestOutputArchive output, TestInputArchive input, TestWriter writer, TestReader reader)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        OutputArchive oa = output.getArchive(baos);        writer.write(oa);    } catch (IOException e) {        fail("Should not throw IOException while writing");    }    InputStream is = new ByteArrayInputStream(baos.toByteArray());    try {        InputArchive ia = input.getArchive(is);        reader.read(ia);    } catch (IOException e) {        fail("Should not throw IOException while reading back");    }}
e390648924e726b491f298368a785005e79ae81a83407c47b8fbb9626eaf06b3
configure
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{    LOG.info("Initializing metrics, configuration: {}", configuration);    this.port = Integer.parseInt(configuration.getProperty("httpPort", "7000"));    this.exportJvmInfo = Boolean.parseBoolean(configuration.getProperty("exportJvmInfo", "true"));}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{    try {        LOG.info("Starting /metrics HTTP endpoint at port {} exportJvmInfo: {}", port, exportJvmInfo);        if (exportJvmInfo) {            DefaultExports.initialize();        }        server = new Server(port);        ServletContextHandler context = new ServletContextHandler();        context.setContextPath("/");        server.setHandler(context);        context.addServlet(new ServletHolder(servlet), "/metrics");        server.start();    } catch (Exception err) {        LOG.error("Cannot start /metrics server", err);        if (server != null) {            try {                server.stop();            } catch (Exception suppressed) {                err.addSuppressed(suppressed);            } finally {                server = null;            }        }        throw new MetricsProviderLifeCycleException(err);    }}
1c47b7f4ce9133adff129c80dbc8b2adc8c9cbf35a0b4bd23761e6f5fb8e6403
getServlet
 MetricsServletImpl getServlet()
{    return servlet;}
aa23481d8bd90f78e49a5e500dec98490654ae5479cc9426a36d2ccccada8dcd
getRootContext
public MetricsContext getRootContext()
{    return rootContext;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    if (server != null) {        try {            server.stop();        } catch (Exception err) {            LOG.error("Cannot safely stop Jetty server", err);        } finally {            server = null;        }    }}
340d939336a8d9d074f5b17fbef7be8130c1d436e0bd0ce104c85ee060ef513a
dump
public void dump(BiConsumer<String, Object> sink)
{    sampleGauges();    Enumeration<Collector.MetricFamilySamples> samplesFamilies = collectorRegistry.metricFamilySamples();    while (samplesFamilies.hasMoreElements()) {        Collector.MetricFamilySamples samples = samplesFamilies.nextElement();        samples.samples.forEach(sample -> {            String key = buildKeyForDump(sample);            sink.accept(key, sample.value);        });    }}
fb25ed66a681bb31ec4dd29dcebfa98ab49a679dba1f1db89f272718fdb4b741
buildKeyForDump
private static String buildKeyForDump(Collector.MetricFamilySamples.Sample sample)
{    StringBuilder keyBuilder = new StringBuilder();    keyBuilder.append(sample.name);    if (sample.labelNames.size() > 0) {        keyBuilder.append('{');        for (int i = 0; i < sample.labelNames.size(); ++i) {            if (i > 0) {                keyBuilder.append(',');            }            keyBuilder.append(sample.labelNames.get(i));            keyBuilder.append("=\"");            keyBuilder.append(sample.labelValues.get(i));            keyBuilder.append('"');        }        keyBuilder.append('}');    }    return keyBuilder.toString();}
e110bcd60631ab030c8b4ba79a6a0511a8caf56b724523732efcda99e3503e53
sampleGauges
private void sampleGauges()
{    rootContext.gauges.values().forEach(PrometheusGaugeWrapper::sample);}
45422fa668d7c89937d4e2e3d11a6b1d2aa4f0b27b1259483c201037b224b7bd
resetAllValues
public void resetAllValues()
{}
702687f7d9c8156c6ae67a5c34889ae40738fdd8c92a96cf44cde6ca80353195
getContext
public MetricsContext getContext(String name)
{        return this;}
5633b30ec05c77f25df04f3a4f0bde17cec6bd0a93316213f7573b14662517ce
getCounter
public Counter getCounter(String name)
{    return counters.computeIfAbsent(name, PrometheusCounter::new);}
254579dd86e8fbfd5534b3e25545de1b8cc119d70e496fd140f89c15e6281723
registerGauge
public void registerGauge(String name, Gauge gauge)
{    Objects.requireNonNull(name);    gauges.compute(name, (id, prev) -> new PrometheusGaugeWrapper(id, gauge, prev != null ? prev.inner : null));}
ca09db82e3501ebbcaedc48a0c02c7335db0c2414ec384400cad129347d1cafa
unregisterGauge
public void unregisterGauge(String name)
{    PrometheusGaugeWrapper existing = gauges.remove(name);    if (existing != null) {        existing.unregister();    }}
f39b1e617a9e696e043e7fe728e9cd9d9b58881269c9c003588e8e380dccf4e6
getSummary
public Summary getSummary(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    }}
3204b50d1074cce7c6a8cb89bb32e896ca6b94185b2b77cd79747f61f7476f6c
getSummarySet
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    }}
a24034b47c6f1e5f1d730be81cd9c52cdc49c4b9d237e333c05693c18d193c31
add
public void add(long delta)
{    try {        inner.inc(delta);    } catch (IllegalArgumentException err) {        LOG.error("invalid delta " + delta + " for metric " + name, err);    }}
9c296a9ae6604f1ab76b67812ec53c653913df94f0267698b3e9a72e90441ce2
get
public long get()
{        return (long) inner.get();}
c14e36600db658d0cf17336c53109c76b684a0dd2fb24a7656cf2064cd9e7785
sample
private void sample()
{    Number value = gauge.get();    this.inner.set(value != null ? value.doubleValue() : 0);}
7ee9cb36259d447a70b9e9876b565d1b1ca973ce2958cebab270a5ddd3bf73e1
unregister
private void unregister()
{    collectorRegistry.unregister(inner);}
a24034b47c6f1e5f1d730be81cd9c52cdc49c4b9d237e333c05693c18d193c31
add
public void add(long delta)
{    try {        inner.observe(delta);    } catch (IllegalArgumentException err) {        LOG.error("invalid delta " + delta + " for metric " + name, err);    }}
8afe3bc5a20d23fed03deefb3f9c911c73f164c0931dbfda26a2ac5b69076546
add
public void add(String key, long value)
{    try {        inner.labels(key).observe(value);    } catch (IllegalArgumentException err) {        LOG.error("invalid value " + value + " for metric " + name + " with key " + key, err);    }}
3ff3be40d7de1879a58f8349e25ae9978778e99ed2ab7aefd27e6c1059e7bdee
doGet
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
{            sampleGauges();        super.doGet(req, resp);}
aac33bdce0c61e40b7c5651258c4331df28d6f47ff402061d61314101461f38e
exportInfo
public void exportInfo() throws Exception
{    runTest(true);}
a75df2fa9a8f41b6018faf2f6aa8048e46818a8d34dc4caecb7920ac65cc055e
doNotExportInfo
public void doNotExportInfo() throws Exception
{    runTest(false);}
22439b24cc1054c492a9fb1a60162a85cf0ce5b5391151311ba8c8b34fd55651
runTest
private void runTest(boolean exportJvmInfo) throws Exception
{    CollectorRegistry.defaultRegistry.clear();    PrometheusMetricsProvider provider = new PrometheusMetricsProvider();    try {        Properties configuration = new Properties();                configuration.setProperty("httpPort", "0");        configuration.setProperty("exportJvmInfo", exportJvmInfo + "");        provider.configure(configuration);        provider.start();        boolean[] found = { false };        provider.dump((k, v) -> {            found[0] = found[0] || k.contains("heap");        });        assertEquals(exportJvmInfo, found[0]);    } finally {        provider.stop();    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    CollectorRegistry.defaultRegistry.clear();    provider = new PrometheusMetricsProvider();    Properties configuration = new Properties();        configuration.setProperty("httpPort", "0");    configuration.setProperty("exportJvmInfo", "false");    provider.configure(configuration);    provider.start();}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    if (provider != null) {        provider.stop();    }    CollectorRegistry.defaultRegistry.clear();}
0a0e6572aea1654926cea8a75c6c556cedb948c08b379aad74ee9f3a4eec6d4e
testCounters
public void testCounters() throws Exception
{    Counter counter = provider.getRootContext().getCounter("cc");    counter.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);    count[0] = 0;        counter.add(-1);    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);        assertSame(counter, provider.getRootContext().getCounter("cc"));    String res = callServlet();    assertThat(res, CoreMatchers.containsString("# TYPE cc counter"));    assertThat(res, CoreMatchers.containsString("cc 10.0"));}
99aa814f9b51bd9a5463c398fd89b7287eda160d145798f9443965fe8e7c4ad7
testGauge
public void testGauge() throws Exception
{    int[] values = { 78, -89 };    int[] callCounts = { 0, 0 };    Gauge gauge0 = () -> {        callCounts[0]++;        return values[0];    };    Gauge gauge1 = () -> {        callCounts[1]++;        return values[1];    };    provider.getRootContext().registerGauge("gg", gauge0);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[0], ((Number) v).intValue());        count[0]++;    });    assertEquals(1, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res2 = callServlet();    assertThat(res2, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res2, CoreMatchers.containsString("gg 78.0"));    provider.getRootContext().unregisterGauge("gg");    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(0, count[0]);    String res3 = callServlet();    assertTrue(res3.isEmpty());    provider.getRootContext().registerGauge("gg", gauge1);    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[1], ((Number) v).intValue());        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(1, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res4 = callServlet();    assertThat(res4, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res4, CoreMatchers.containsString("gg -89.0"));    assertEquals(2, callCounts[0]);        assertEquals(2, callCounts[1]);        provider.getRootContext().registerGauge("gg", gauge0);    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(1, count[0]);    assertEquals(3, callCounts[0]);    assertEquals(2, callCounts[1]);}
95dbfa1fb1b83a5926bdb207be1e91b7e7b6acd54e7a65b7c4b3acae505eb5ae
testBasicSummary
public void testBasicSummary() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(3, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));}
7ffcdcd5cf01c62abccd4ece4b640bc4490895b36281d795dd5cd43d4f86e670
testAdvancedSummary
public void testAdvancedSummary() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.9\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.99\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(5, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.9\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.99\",} 10.0"));}
30d6765feb3f3ad0952712bbd1a8162a9d173f86f49b85a98dfa2d2b3f791fdf
callServlet
private String callServlet() throws ServletException, IOException
{            StringWriter writer = new StringWriter();    HttpServletResponse response = mock(HttpServletResponse.class);    when(response.getWriter()).thenReturn(new PrintWriter(writer));    HttpServletRequest req = mock(HttpServletRequest.class);    provider.getServlet().doGet(req, response);    String res = writer.toString();    return res;}
5b05914888e421f26bff6f39231facdd35759f746a9af780ebac2cf5b2c81932
start
public synchronized void start()
{    state = State.START;    dispatchEvent(EventType.START);    LOG.info("Starting leader election support");    if (zooKeeper == null) {        throw new IllegalStateException("No instance of zookeeper provided. Hint: use setZooKeeper()");    }    if (hostName == null) {        throw new IllegalStateException("No hostname provided. Hint: use setHostName()");    }    try {        makeOffer();        determineElectionStatus();    } catch (KeeperException | InterruptedException e) {        becomeFailed(e);    }}
06e1ddba8663c90da407ac517f29ed70555cfe57b0332c9a96e7c696e0255364
stop
public synchronized void stop()
{    state = State.STOP;    dispatchEvent(EventType.STOP_START);    LOG.info("Stopping leader election support");    if (leaderOffer != null) {        try {            zooKeeper.delete(leaderOffer.getNodePath(), -1);            LOG.info("Removed leader offer {}", leaderOffer.getNodePath());        } catch (InterruptedException | KeeperException e) {            becomeFailed(e);        }    }    dispatchEvent(EventType.STOP_COMPLETE);}
be48c7d6874d8f9a2ef52a7ad443f30ee1f3d2a60f83e0674bfdb106dadb567b
makeOffer
private void makeOffer() throws KeeperException, InterruptedException
{    state = State.OFFER;    dispatchEvent(EventType.OFFER_START);    LeaderOffer newLeaderOffer = new LeaderOffer();    byte[] hostnameBytes;    synchronized (this) {        newLeaderOffer.setHostName(hostName);        hostnameBytes = hostName.getBytes();        newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + "/" + "n_", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));        leaderOffer = newLeaderOffer;    }    LOG.debug("Created leader offer {}", leaderOffer);    dispatchEvent(EventType.OFFER_COMPLETE);}
b5fe12d963406a016c86b91ebf7b1529e9b4b7cbf53ff88b1116edb468f09148
getLeaderOffer
private synchronized LeaderOffer getLeaderOffer()
{    return leaderOffer;}
71685506697f9a254b278e2f595a91851e4a803ca3cdfef26ee05005694b23d0
determineElectionStatus
private void determineElectionStatus() throws KeeperException, InterruptedException
{    state = State.DETERMINE;    dispatchEvent(EventType.DETERMINE_START);    LeaderOffer currentLeaderOffer = getLeaderOffer();    String[] components = currentLeaderOffer.getNodePath().split("/");    currentLeaderOffer.setId(Integer.valueOf(components[components.length - 1].substring("n_".length())));    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    /*         * For each leader offer, find out where we fit in. If we're first, we         * become the leader. If we're not elected the leader, attempt to stat the         * offer just less than us. If they exist, watch for their failure, but if         * they don't, become the leader.         */    for (int i = 0; i < leaderOffers.size(); i++) {        LeaderOffer leaderOffer = leaderOffers.get(i);        if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {            LOG.debug("There are {} leader offers. I am {} in line.", leaderOffers.size(), i);            dispatchEvent(EventType.DETERMINE_COMPLETE);            if (i == 0) {                becomeLeader();            } else {                becomeReady(leaderOffers.get(i - 1));            }            /* Once we've figured out where we are, we're done. */            break;        }    }}
5663acba20a48a731e82adad6f358b0e594d773d4eecf925378291d9ec2d2e04
becomeReady
private void becomeReady(LeaderOffer neighborLeaderOffer) throws KeeperException, InterruptedException
{    LOG.info("{} not elected leader. Watching node:{}", getLeaderOffer().getNodePath(), neighborLeaderOffer.getNodePath());    /*         * Make sure to pass an explicit Watcher because we could be sharing this         * zooKeeper instance with someone else.         */    Stat stat = zooKeeper.exists(neighborLeaderOffer.getNodePath(), this);    if (stat != null) {        dispatchEvent(EventType.READY_START);        LOG.debug("We're behind {} in line and they're alive. Keeping an eye on them.", neighborLeaderOffer.getNodePath());        state = State.READY;        dispatchEvent(EventType.READY_COMPLETE);    } else {        /*             * If the stat fails, the node has gone missing between the call to             * getChildren() and exists(). We need to try and become the leader.             */        LOG.info("We were behind {} but it looks like they died. Back to determination.", neighborLeaderOffer.getNodePath());        determineElectionStatus();    }}
3783b96622ac321e8f5c1329d233e9ac2435859a1156ddb8659865a057bf68a6
becomeLeader
private void becomeLeader()
{    state = State.ELECTED;    dispatchEvent(EventType.ELECTED_START);    LOG.info("Becoming leader with node:{}", getLeaderOffer().getNodePath());    dispatchEvent(EventType.ELECTED_COMPLETE);}
41c2fc473eddefe3016447474b8efc8ebce5d72fd05a38bde2e81d315d7f30e5
becomeFailed
private void becomeFailed(Exception e)
{    LOG.error("Failed in state {} - Exception:{}", state, e);    state = State.FAILED;    dispatchEvent(EventType.FAILED);}
35d448ed921d95969edd01f42c0c212cabebc7e4c8e6a435935cceee1a4750db
getLeaderHostName
public String getLeaderHostName() throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    if (leaderOffers.size() > 0) {        return leaderOffers.get(0).getHostName();    }    return null;}
d2ae8f8261cb7244b5dcd0971f80e635d63d22d9d27656797e4605917c9e0cda
toLeaderOffers
private List<LeaderOffer> toLeaderOffers(List<String> strings) throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = new ArrayList<>(strings.size());    /*         * Turn each child of rootNodeName into a leader offer. This is a tuple of         * the sequence number and the node name.         */    for (String offer : strings) {        String hostName = new String(zooKeeper.getData(rootNodeName + "/" + offer, false, null));        leaderOffers.add(new LeaderOffer(Integer.valueOf(offer.substring("n_".length())), rootNodeName + "/" + offer, hostName));    }    /*         * We sort leader offers by sequence number (which may not be zero-based or         * contiguous) and keep their paths handy for setting watches.         */    Collections.sort(leaderOffers, new LeaderOffer.IdComparator());    return leaderOffers;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) {        if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {            LOG.debug("Node {} deleted. Need to run through the election process.", event.getPath());            try {                determineElectionStatus();            } catch (KeeperException | InterruptedException e) {                becomeFailed(e);            }        }    }}
070a9b176329800144c6815b240a534aea45f03107c5b2f8118bb65bafbcadf2
dispatchEvent
private void dispatchEvent(EventType eventType)
{    LOG.debug("Dispatching event:{}", eventType);    synchronized (listeners) {        if (listeners.size() > 0) {            for (LeaderElectionAware observer : listeners) {                observer.onElectionEvent(eventType);            }        }    }}
67c2e023b594bacdf5f055c78df2c7d0abf272d3278f8e1bcc697f83d62df827
addListener
public void addListener(LeaderElectionAware listener)
{    listeners.add(listener);}
353314af14ed48649f75d239798b28a78f7354d37076c997535d8d679036b7c7
removeListener
public void removeListener(LeaderElectionAware listener)
{    listeners.remove(listener);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "{" + " state:" + state + " leaderOffer:" + getLeaderOffer() + " zooKeeper:" + zooKeeper + " hostName:" + getHostName() + " listeners:" + listeners + " }";}
54e2f245919fb7831232561ae304184b47c9751837c5edd1235d59e8d6639460
getRootNodeName
public String getRootNodeName()
{    return rootNodeName;}
26ec4c7359f40f23b185778da47a49366a1c201fb7b62efa444cf59363fb40d8
setRootNodeName
public void setRootNodeName(String rootNodeName)
{    this.rootNodeName = rootNodeName;}
eb53bf6c8f294379f90b7c822476e9e6bb9e57a2e80915cd1b11daeefacdc2d0
getZooKeeper
public ZooKeeper getZooKeeper()
{    return zooKeeper;}
1494353227d8d78d4f60ef956d7ddc00f7f831e56f26bad8ef662987917e7a67
setZooKeeper
public void setZooKeeper(ZooKeeper zooKeeper)
{    this.zooKeeper = zooKeeper;}
08b7851f0f9e977be5670f7c68d7956f03f6e5e8dd5bf9fa515b76bb9dc935c3
getHostName
public synchronized String getHostName()
{    return hostName;}
6588df9b0a5894d560c19dbb246d9d0f2bc002df0753dcde54b8cebf6fd33f18
setHostName
public synchronized void setHostName(String hostName)
{    this.hostName = hostName;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "{" + " id:" + id + " nodePath:" + nodePath + " hostName:" + hostName + " }";}
140d6b8c9b41cf799705c04bd96ae47dbc5c17d04361d67f59f707b39618275c
getId
public Integer getId()
{    return id;}
7a533d90c3e1499f932fe127a95712c37fcad5129bfc554d179eb343e770b9cd
setId
public void setId(Integer id)
{    this.id = id;}
6b2b69a38b00e587a9d2f34db9eedfe85f78b174d07d7f85865843c1f21fc943
getNodePath
public String getNodePath()
{    return nodePath;}
9c790ae6d76f7567749c38fb909a09b03f4286adc8302acc07e34743b718bb72
setNodePath
public void setNodePath(String nodePath)
{    this.nodePath = nodePath;}
39d9cd6f38baa59fab797f91a6856e0162449a9f7cddd492a3b663cf6cbec3fe
getHostName
public String getHostName()
{    return hostName;}
eeedf69507565db83a1f8a9bd37dc3e5bb12d5c095ca22640181384a14cc5987
setHostName
public void setHostName(String hostName)
{    this.hostName = hostName;}
ae3204149110f6f2cb6a8a05378b013ca118ed4b41adf426111247b27f168a22
compare
public int compare(LeaderOffer o1, LeaderOffer o2)
{    return o1.getId().compareTo(o2.getId());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zooKeeper = createClient();    zooKeeper.create(TEST_ROOT_NODE + Thread.currentThread().getId(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (zooKeeper != null) {        zooKeeper.delete(TEST_ROOT_NODE + Thread.currentThread().getId(), -1);    }    super.tearDown();}
ede46fd374472d22274afb0726b9e19bdded55d2e2c16fb39f50062a1eb93243
testNode
public void testNode() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();    Thread.sleep(3000);    electionSupport.stop();}
ebb24221fbf998c03aaddd15f7a8681865d1cb769942587716b559e0fbab5d3d
testNodes3
public void testNodes3() throws Exception
{    int testIterations = 3;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {        LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);    }}
c1840d5b9cd82f3e3bcbc3bfdaf7109053acbe47b4be3bd6657f4b112b2d2ff2
testNodes9
public void testNodes9() throws Exception
{    int testIterations = 9;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {        LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);    }}
7105a7236ffe9e0afa37d7ec3f802d00c37292646be437d8c42879c10e2e2712
testNodes20
public void testNodes20() throws Exception
{    int testIterations = 20;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {        LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);    }}
9a1f325441b2d950689df0a01346e4db6529f9851952a7f76cc46a39111da723
testNodes100
public void testNodes100() throws Exception
{    int testIterations = 100;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(20, TimeUnit.SECONDS)) {        LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);    }}
ac61c6b87736b155f4411f859fb9d1f83adf579f3de0f0d180496639b356426a
testOfferShuffle
public void testOfferShuffle() throws InterruptedException
{    int testIterations = 10;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    List<Thread> threads = new ArrayList<>(testIterations);    for (int i = 1; i <= testIterations; i++) {        threads.add(runElectionSupportThread(latch, failureCounter, Math.min(i * 1200, 10000)));    }    if (!latch.await(60, TimeUnit.SECONDS)) {        LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);    }}
5dc6ac4da64a8ac78cd74e7a615545312d806bf42c002f4d82ecaf5d2e0b90b7
testGetLeaderHostName
public void testGetLeaderHostName() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();        Thread.sleep(3000);    String leaderHostName = electionSupport.getLeaderHostName();    Assert.assertNotNull(leaderHostName);    Assert.assertEquals("foohost", leaderHostName);    electionSupport.stop();}
298340a40c72d82556a4b925be799133c025ef6d95eeef6f55e15f4b2998e3ab
testReadyOffer
public void testReadyOffer() throws Exception
{    final ArrayList<EventType> events = new ArrayList<>();    final CountDownLatch electedComplete = new CountDownLatch(1);    final LeaderElectionSupport electionSupport1 = createLeaderElectionSupport();    electionSupport1.start();    LeaderElectionSupport electionSupport2 = createLeaderElectionSupport();    LeaderElectionAware listener = new LeaderElectionAware() {        boolean stoppedElectedNode = false;        @Override        public void onElectionEvent(EventType eventType) {            events.add(eventType);            if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {                stoppedElectedNode = true;                try {                                        electionSupport1.stop();                } catch (Exception e) {                    LOGGER.error("Unexpected error", e);                }            }            if (eventType == EventType.ELECTED_COMPLETE) {                electedComplete.countDown();            }        }    };    electionSupport2.addListener(listener);    electionSupport2.start();        electedComplete.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS);    final ArrayList<EventType> expectedevents = new ArrayList<>();    expectedevents.add(EventType.START);    expectedevents.add(EventType.OFFER_START);    expectedevents.add(EventType.OFFER_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.ELECTED_START);    expectedevents.add(EventType.ELECTED_COMPLETE);    Assert.assertEquals("Events has failed to executed in the order", expectedevents, events);    electionSupport2.stop();}
aff4c1004990856b5efd4ae8f260c0f17b43c280b91ed0047c24fdd7f8e54915
onElectionEvent
public void onElectionEvent(EventType eventType)
{    events.add(eventType);    if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {        stoppedElectedNode = true;        try {                        electionSupport1.stop();        } catch (Exception e) {            LOGGER.error("Unexpected error", e);        }    }    if (eventType == EventType.ELECTED_COMPLETE) {        electedComplete.countDown();    }}
6ef9591252ff0324aeeb392c97c67997834968fdc41e069ccf5b78831ef20c43
createLeaderElectionSupport
private LeaderElectionSupport createLeaderElectionSupport()
{    LeaderElectionSupport electionSupport = new LeaderElectionSupport();    electionSupport.setZooKeeper(zooKeeper);    electionSupport.setRootNodeName(TEST_ROOT_NODE + Thread.currentThread().getId());    electionSupport.setHostName("foohost");    return electionSupport;}
5b5224548a12c8c6f6d3e84d552ec7c0409e5a4ded3eb96a0fc9bb1c6df3d31f
runElectionSupportThread
private Thread runElectionSupportThread(final CountDownLatch latch, final AtomicInteger failureCounter)
{    return runElectionSupportThread(latch, failureCounter, 3000);}
e01a8bd6c160f73208587f7e9470cff651c7e5a5deb6e3f74c4d9b338d9687da
runElectionSupportThread
private Thread runElectionSupportThread(final CountDownLatch latch, final AtomicInteger failureCounter, final long sleepDuration)
{    final LeaderElectionSupport electionSupport = createLeaderElectionSupport();    Thread t = new Thread(() -> {        try {            electionSupport.start();            Thread.sleep(sleepDuration);            electionSupport.stop();            latch.countDown();        } catch (Exception e) {            LOGGER.warn("Failed to run leader election due to: {}", e.getMessage());            failureCounter.incrementAndGet();        }    });    t.start();    return t;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (closed.compareAndSet(false, true)) {        doClose();    }}
931761d64a175ed695d641dfb9489402a3d3b127e82bf2873bafd61215876588
getZookeeper
public ZooKeeper getZookeeper()
{    return zookeeper;}
6c321425367cdffc5080771d9ac6bb4fc28413a81d213555938a244e37e97e29
getAcl
public List<ACL> getAcl()
{    return acl;}
da23a2b956079446c4f1ff0de2b3e3b3a28d0f3b64e6e13075955bb953eb112d
setAcl
public void setAcl(List<ACL> acl)
{    this.acl = acl;}
69b7f7dcdeeb71e434975f20ab3c7c42a2606119b4296ccfd3c4d03eb6e5d910
getRetryDelay
public long getRetryDelay()
{    return retryDelay;}
75389badc0584f5e17e44c0dfadcfefd4809b1bc11af8019c9bbbd040c0f259e
setRetryDelay
public void setRetryDelay(long retryDelay)
{    this.retryDelay = retryDelay;}
b59bbf45e4d212692a02e8bffbd55012fa8166d3da26e9dbfa4ceaa420037e32
doClose
protected void doClose()
{}
e4213597bb56dfff0562fa68e067ac9d156349f7bd5f7415171e83d4c4299fdf
retryOperation
protected Object retryOperation(ZooKeeperOperation operation) throws KeeperException, InterruptedException
{    KeeperException exception = null;    for (int i = 0; i < retryCount; i++) {        try {            return operation.execute();        } catch (KeeperException.SessionExpiredException e) {            LOG.warn("Session expired for: " + zookeeper + " so reconnecting due to: " + e, e);            throw e;        } catch (KeeperException.ConnectionLossException e) {            if (exception == null) {                exception = e;            }            LOG.debug("Attempt {} failed with connection loss so attempting to reconnect", i, e);            retryDelay(i);        }    }    throw exception;}
dbed7733e48ad36ca84c59504ef966d8c74ee930a2b24cdb5a5bc1923f0abab1
ensurePathExists
protected void ensurePathExists(String path)
{    ensureExists(path, null, acl, CreateMode.PERSISTENT);}
de3860e14b830e06a66b532d32e059bc24d2d7505a79ec6bfd41087ccf5bde8e
ensureExists
protected void ensureExists(final String path, final byte[] data, final List<ACL> acl, final CreateMode flags)
{    try {        retryOperation(() -> {            Stat stat = zookeeper.exists(path, false);            if (stat != null) {                return true;            }            zookeeper.create(path, data, acl, flags);            return true;        });    } catch (KeeperException | InterruptedException e) {        LOG.warn("Caught: " + e, e);    }}
0e23ea9e159911f48edd499d50a8a4b456565115ab1a2daf5bfef9fc9c2852cf
isClosed
protected boolean isClosed()
{    return closed.get();}
f86dc739e4dce9f709f96c8085cea9e21cbd27dc45fefd4f737a88ededea87bc
retryDelay
protected void retryDelay(int attemptCount)
{    if (attemptCount > 0) {        try {            Thread.sleep(attemptCount * retryDelay);        } catch (InterruptedException e) {            LOG.debug("Failed to sleep", e);        }    }}
4c9720e51ba0b88abf4ccf7ef8a177b7145f29d86ab3bc3bcc377cd78e973cb1
getLockListener
public synchronized LockListener getLockListener()
{    return this.callback;}
69bf3640f495f01aa4bf563aebc7258b8ce7149a7ed7578d4385ef09b0a8117f
setLockListener
public synchronized void setLockListener(LockListener callback)
{    this.callback = callback;}
c8d9b410713b0ad6ac0c7cf10406e0f9d0be833a614aa5a616ef133cbd15f24f
unlock
public synchronized void unlock() throws RuntimeException
{    if (!isClosed() && id != null) {                try {            ZooKeeperOperation zopdel = () -> {                zookeeper.delete(id, -1);                return Boolean.TRUE;            };            zopdel.execute();        } catch (InterruptedException e) {            LOG.warn("Caught: " + e, e);                        Thread.currentThread().interrupt();        } catch (KeeperException.NoNodeException e) {                } catch (KeeperException e) {            LOG.warn("Caught: " + e, e);            throw new RuntimeException(e.getMessage(), e);        } finally {            LockListener lockListener = getLockListener();            if (lockListener != null) {                lockListener.lockReleased();            }            id = null;        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{        LOG.debug("Watcher fired: {}", event);    try {        lock();    } catch (Exception e) {        LOG.warn("Failed to acquire lock: " + e, e);    }}
b613286df8eb9a768e5d3dd4c4c81d75679e907c4928d27de65564e3f1715601
findPrefixInChildren
private void findPrefixInChildren(String prefix, ZooKeeper zookeeper, String dir) throws KeeperException, InterruptedException
{    List<String> names = zookeeper.getChildren(dir, false);    for (String name : names) {        if (name.startsWith(prefix)) {            id = name;            LOG.debug("Found id created last time: {}", id);            break;        }    }    if (id == null) {        id = zookeeper.create(dir + "/" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);        LOG.debug("Created id: {}", id);    }}
91522213b12588ce30de3dca23971c3c2929bfc131ab35266df6beb0674d85d7
execute
public boolean execute() throws KeeperException, InterruptedException
{    do {        if (id == null) {            long sessionId = zookeeper.getSessionId();            String prefix = "x-" + sessionId + "-";                                    findPrefixInChildren(prefix, zookeeper, dir);            idName = new ZNodeName(id);        }        List<String> names = zookeeper.getChildren(dir, false);        if (names.isEmpty()) {            LOG.warn("No children in: " + dir + " when we've just created one! Lets recreate it...");                        id = null;        } else {                        SortedSet<ZNodeName> sortedNames = new TreeSet<>();            for (String name : names) {                sortedNames.add(new ZNodeName(dir + "/" + name));            }            ownerId = sortedNames.first().getName();            SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);            if (!lessThanMe.isEmpty()) {                ZNodeName lastChildName = lessThanMe.last();                lastChildId = lastChildName.getName();                LOG.debug("watching less than me node: {}", lastChildId);                Stat stat = zookeeper.exists(lastChildId, new LockWatcher());                if (stat != null) {                    return Boolean.FALSE;                } else {                    LOG.warn("Could not find the stats for less than me: " + lastChildName.getName());                }            } else {                if (isOwner()) {                    LockListener lockListener = getLockListener();                    if (lockListener != null) {                        lockListener.lockAcquired();                    }                    return Boolean.TRUE;                }            }        }    } while (id == null);    return Boolean.FALSE;}
ec53c9d68ac667aa445b25b54321752e2c9dae8d1059922d31a807d4ea98a320
lock
public synchronized boolean lock() throws KeeperException, InterruptedException
{    if (isClosed()) {        return false;    }    ensurePathExists(dir);    return (Boolean) retryOperation(zop);}
139e1674528b3c425da38548e9d36713f38e0033a1a9194df851d1ea246a4ee8
getDir
public String getDir()
{    return dir;}
028cb2444a47b467f41fafd169a80d199cce9d41cec5924999c4af51d22e437e
isOwner
public boolean isOwner()
{    return id != null && id.equals(ownerId);}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return this.id;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return name.toString();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZNodeName sequence = (ZNodeName) o;    return name.equals(sequence.name);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return name.hashCode() + 37;}
1c1483a25a66dc7092226d8074ba5b0301a9eb7fb63a1aa2e3c84ef3e1356dbd
compareTo
public int compareTo(ZNodeName that)
{    int answer = this.sequence - that.sequence;    if (answer == 0) {        return this.prefix.compareTo(that.prefix);    }    return answer;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
2102461fb5823b31ab942b0f89d438528108ced63e951ed17fbe954c47556cf3
getZNodeName
public int getZNodeName()
{    return sequence;}
a45881c16ab9e38f31484f692ce1411b032f19370daab3e4040c1c04d984146f
getPrefix
public String getPrefix()
{    return prefix;}
ae67a0d8c0d604d8bb308ed65bdc558b28037a3fac86878bd2b7f67210a99f60
testRun
public void testRun() throws Exception
{    runTest(3);}
d35724984c1eceb66391ceb0d36908aee5c0209aca90d7a6bbcb03473308b519
lockAcquired
public void lockAcquired()
{    latch.countDown();}
f2732422be482261370c0c5767218d8468babdef472b9aebc356eb88c68e569d
lockReleased
public void lockReleased()
{}
61a9a9c08dfe3a17e706a9596c507ff3448ddcf86c1abfcf56e142c6da0582a8
runTest
protected void runTest(int count) throws Exception
{    nodes = new WriteLock[count];    for (int i = 0; i < count; i++) {        ZooKeeper keeper = createClient();        WriteLock leader = new WriteLock(keeper, dir, null);        leader.setLockListener(new LockCallback());        nodes[i] = leader;        leader.lock();    }            latch.await(30, TimeUnit.SECONDS);    WriteLock first = nodes[0];    dumpNodes(count);        Assert.assertTrue("The first znode should be the leader " + first.getId(), first.isOwner());    for (int i = 1; i < count; i++) {        WriteLock node = nodes[i];        Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());    }    if (count > 1) {        if (killLeader) {            System.out.println("Now killing the leader");                        latch = new CountDownLatch(1);            first.unlock();            latch.await(30, TimeUnit.SECONDS);                        WriteLock second = nodes[1];            dumpNodes(count);                        Assert.assertTrue("The second znode should be the leader " + second.getId(), second.isOwner());            for (int i = 2; i < count; i++) {                WriteLock node = nodes[i];                Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());            }        }        if (restartServer) {                        System.out.println("Now stopping the server");            stopServer();            Thread.sleep(10000);                        dumpNodes(count);            System.out.println("Starting the server");            startServer();            Thread.sleep(10000);            for (int i = 0; i < count - 1; i++) {                System.out.println("Calling acquire for node: " + i);                nodes[i].lock();            }            dumpNodes(count);            System.out.println("Now closing down...");        }    }}
e80a6d8e0eb6fe54d84fb03435c0e07dd20786571547a6043d80ca1d2c64b5a3
dumpNodes
protected void dumpNodes(int count)
{    for (int i = 0; i < count; i++) {        WriteLock node = nodes[i];        System.out.println("node: " + i + " id: " + node.getId() + " is leader: " + node.isOwner());    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (nodes != null) {        for (int i = 0; i < nodes.length; i++) {            WriteLock node = nodes[i];            if (node != null) {                System.out.println("Closing node: " + i);                node.close();                if (workAroundClosingLastZNodeFails && i == nodes.length - 1) {                    System.out.println("Not closing zookeeper: " + i + " due to bug!");                } else {                    System.out.println("Closing zookeeper: " + i);                    node.getZookeeper().close();                    System.out.println("Closed zookeeper: " + i);                }            }        }    }    System.out.println("Now lets stop the server");    super.tearDown();}
b860fe0527ab295dd558e39b91e0d068486408aca7db26d5636f26dba0507e82
testOrderWithSamePrefix
public void testOrderWithSamePrefix() throws Exception
{    String[] names = { "x-3", "x-5", "x-11", "x-1" };    String[] expected = { "x-1", "x-3", "x-5", "x-11" };    assertOrderedNodeNames(names, expected);}
bd674fbf8910b00b29391017393184b5bcd16e72e75aaef9728a89d9dbffbe5e
testOrderWithDifferentPrefixes
public void testOrderWithDifferentPrefixes() throws Exception
{    String[] names = { "r-3", "r-2", "r-1", "w-2", "w-1" };    String[] expected = { "r-1", "w-1", "r-2", "w-2", "r-3" };    assertOrderedNodeNames(names, expected);}
5213dc7d0b27c5e40dca6f36ca16a1f6b944ed9727239ae188138f4939eb0b2a
testOrderWithDifferentPrefixIncludingSessionId
public void testOrderWithDifferentPrefixIncludingSessionId() throws Exception
{    String[] names = { "x-242681582799028564-0000000002", "x-170623981976748329-0000000003", "x-98566387950223723-0000000001" };    String[] expected = { "x-98566387950223723-0000000001", "x-242681582799028564-0000000002", "x-170623981976748329-0000000003" };    assertOrderedNodeNames(names, expected);}
04d66678bf1843a34aaa832e0a2e1ff4ab09856989d46adfea48abcd358d3858
testOrderWithExtraPrefixes
public void testOrderWithExtraPrefixes() throws Exception
{    String[] names = { "r-1-3-2", "r-2-2-1", "r-3-1-3" };    String[] expected = { "r-2-2-1", "r-1-3-2", "r-3-1-3" };    assertOrderedNodeNames(names, expected);}
441adee39db5cc7e7d1b1401236e95f5f0b2fdf4a9d42086fb7f650791c14ac8
assertOrderedNodeNames
protected void assertOrderedNodeNames(String[] names, String[] expected)
{    int size = names.length;    SortedSet<ZNodeName> nodeNames = new TreeSet<>();    for (String name : names) {        nodeNames.add(new ZNodeName(name));    }    Assert.assertEquals("The SortedSet does not have the expected size!", nodeNames.size(), expected.length);    int index = 0;    for (ZNodeName nodeName : nodeNames) {        String name = nodeName.getName();        Assert.assertEquals("Node " + index, expected[index++], name);    }}
6ecc32a67796392ea4c2760123fce95c56f373914d27314e60f8a5f1a1627302
orderedChildren
private Map<Long, String> orderedChildren(Watcher watcher) throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren = new TreeMap<>();    List<String> childNames;    childNames = zookeeper.getChildren(dir, watcher);    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                LOG.warn("Found child node with improper name: " + childName);                continue;            }            String suffix = childName.substring(prefix.length());            Long childId = Long.parseLong(suffix);            orderedChildren.put(childId, childName);        } catch (NumberFormatException e) {            LOG.warn("Found child node with improper format : " + childName + " " + e, e);        }    }    return orderedChildren;}
89885f6b1c4c219ecb297bc91e7d79ac41030649f09771c366802eaa230c64af
smallestChildName
private String smallestChildName() throws KeeperException, InterruptedException
{    long minId = Long.MAX_VALUE;    String minName = "";    List<String> childNames;    try {        childNames = zookeeper.getChildren(dir, false);    } catch (KeeperException.NoNodeException e) {        LOG.warn("Caught: " + e, e);        return null;    }    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                LOG.warn("Found child node with improper name: " + childName);                continue;            }            String suffix = childName.substring(prefix.length());            long childId = Long.parseLong(suffix);            if (childId < minId) {                minId = childId;                minName = childName;            }        } catch (NumberFormatException e) {            LOG.warn("Found child node with improper format : " + childName + " " + e, e);        }    }    if (minId < Long.MAX_VALUE) {        return minName;    } else {        return null;    }}
69ce2672f126a48c076e0b95d6394e480bc347e1c20318f820a1e97c2be5a0d0
element
public byte[] element() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            if (headNode != null) {                try {                    return zookeeper.getData(dir + "/" + headNode, false, null);                } catch (KeeperException.NoNodeException e) {                                }            }        }    }}
eea2a4a93f6d31a045795b3b5ef91cd40ac3b0f77cb70fd0916c48c25ffbaa59
remove
public byte[] remove() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.debug("Watcher fired: {}", event);    latch.countDown();}
b0b375d75fcbcf03ddaf3f6d24561fde6f05fcbeacce1d0b8bfabda8c8fd9899
await
public void await() throws InterruptedException
{    latch.await();}
b9b8e16e643a00128892f9c43a70d7e67f87dd9bbd0b94e129e582ebf93a66c1
take
public byte[] take() throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        LatchChildWatcher childWatcher = new LatchChildWatcher();        try {            orderedChildren = orderedChildren(childWatcher);        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);            continue;        }        if (orderedChildren.size() == 0) {            childWatcher.await();            continue;        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
a70943f3b329769fc5875189baa5acbbf42d9fe23e035ba893c4067c2695a0af
offer
public boolean offer(byte[] data) throws KeeperException, InterruptedException
{    for (; ; ) {        try {            zookeeper.create(dir + "/" + prefix, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);            return true;        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);        }    }}
cef7e5b0c203cbe73b2ccc3cddcacc9b659e3cc6645c38f515b49288e2ff4234
peek
public byte[] peek() throws KeeperException, InterruptedException
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
6bd3c0cc315f4934db6edd5876b555b38c5f72ec294d86515ac676ff05c83283
poll
public byte[] poll() throws KeeperException, InterruptedException
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    LOG.info("FINISHED " + getTestName());}
fb86be436b12b823a95c55b585cf574b8b4a55d9e1984b04c1c2e976a03a610a
testOffer1
public void testOffer1() throws Exception
{    String dir = "/testOffer1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
bac5623698b42fbef2040445f7bd0af3f6a1c6566bbe0ec076a42f1338b050c0
testOffer2
public void testOffer2() throws Exception
{    String dir = "/testOffer2";    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[1].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
75139bde671c668e118079835fe428ed266aa5def22fcb8eeae18b7ec1d4cc47
testTake1
public void testTake1() throws Exception
{    String dir = "/testTake1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].take();    Assert.assertEquals(new String(dequeuedBytes), testString);}
8eb7ed56ed31eb6d72e2ac0692d62dad06b14c1f6efbfba1dcde5af93b5cda09
testRemove1
public void testRemove1() throws Exception
{    String dir = "/testRemove1";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    try {        queueHandles[0].remove();    } catch (NoSuchElementException e) {        return;    }    Assert.fail();}
4a6b6dd0fd1889739a23cf4d6596d4667a55978e690ab64fd88c0e5fdded3c38
createNremoveMtest
public void createNremoveMtest(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    byte[] data = null;    for (int i = 0; i < m; i++) {        data = queueHandles[1].remove();    }    Assert.assertNotNull(data);    Assert.assertEquals(new String(data), testString + (m - 1));}
83eee548f0511390c9d51d6fafbb328ac06e2d082de471add7800e7443f702a8
testRemove2
public void testRemove2() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
97d3dfb67858cc6fc0494128346588bd90d114e9558173bad1fb61d537aac673
testRemove3
public void testRemove3() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
4c7ad0d0c360216216aba9c3b438650b8c9b4fcb249163080cac4b5c20272009
createNremoveMelementTest
public void createNremoveMelementTest(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    for (int i = 0; i < m; i++) {        queueHandles[1].remove();    }    Assert.assertEquals(new String(queueHandles[1].element()), testString + m);}
23f62eb695b2d32bfe1bd46e8d13976bf37d3c22cff01f0a48f893cccd83cb5f
testElement1
public void testElement1() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
98bcc95168f917296effb390a62e8f8c860ea1ff8c7c97add84f47b001b1eff9
testElement2
public void testElement2() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
4276f9a3cef633175204a1b8ef19eb901188b8a8944b6afd9aff2804f1cbed7d
testElement3
public void testElement3() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
eceb3bc1c88705cde8cf68d7691dd5853fb93c00061d71cf04d5ba912c0f6370
testElement4
public void testElement4() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
e57ce4880554172a7afef03b840ae898977c2c86ae4da50cea1d7198d7bf23ea
testTakeWait1
public void testTakeWait1() throws Exception
{    String dir = "/testTakeWait1";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    final byte[][] takeResult = new byte[1][];    Thread takeThread = new Thread(() -> {        try {            takeResult[0] = queueHandles[0].take();        } catch (KeeperException | InterruptedException ignore) {                }    });    takeThread.start();    Thread.sleep(1000);    Thread offerThread = new Thread(() -> {        try {            queueHandles[0].offer(testString.getBytes());        } catch (KeeperException | InterruptedException ignore) {                }    });    offerThread.start();    offerThread.join();    takeThread.join();    Assert.assertNotNull(takeResult[0]);    Assert.assertEquals(new String(takeResult[0]), testString);}
99691e7d085adf6350ba7d6cc5d1821aae3bfb5279063236544512639ea8dbf9
testTakeWait2
public void testTakeWait2() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    int numAttempts = 2;    for (int i = 0; i < numAttempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread(() -> {            try {                takeResult[0] = queueHandles[0].take();            } catch (KeeperException | InterruptedException ignore) {                        }        });        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread(() -> {            try {                queueHandles[0].offer(threadTestString.getBytes());            } catch (KeeperException | InterruptedException ignore) {                        }        });        offerThread.start();        offerThread.join();        takeThread.join();        Assert.assertNotNull(takeResult[0]);        Assert.assertEquals(new String(takeResult[0]), threadTestString);    }}
91deda8b200305818c2e9d80f6a17aa9130d40a6f08a429ea8437befe3e27df9
reconfigure
public byte[] reconfigure(String joiningServers, String leavingServers, String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), "");    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
d651eb53e44b27130b90a2a6cc4486bf8d5b678a079196ee06e8fbc697026c19
reconfigure
public byte[] reconfigure(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    return reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, stat);}
7a50c106b1f1928acb79939118d5b59e15ae8b1056be5db3009ee643297cecdf
reconfigure
public void reconfigure(String joiningServers, String leavingServers, String newMembers, long fromConfig, DataCallback cb, Object ctx)
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, ZooDefs.CONFIG_NODE, ZooDefs.CONFIG_NODE, ctx, null);}
ea722150b072959925cde95a600313043251779d8027eecfe87dd5b6eed70926
reconfigure
public void reconfigure(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, DataCallback cb, Object ctx)
{    reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, cb, ctx);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString();}
076e44e800e653852ed34a2d7b42f47f71a0b886b765766614d8c6e5dd5a059f
parse
public static List<ACL> parse(String aclString)
{    List<ACL> acl;    String[] acls = aclString.split(",");    acl = new ArrayList<ACL>();    for (String a : acls) {        int firstColon = a.indexOf(':');        int lastColon = a.lastIndexOf(':');        if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {            System.err.println(a + " does not have the form scheme:id:perm");            continue;        }        ACL newAcl = new ACL();        newAcl.setId(new Id(a.substring(0, firstColon), a.substring(firstColon + 1, lastColon)));        newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));        acl.add(newAcl);    }    return acl;}
93cfb7d01fd8942a3f8c50e3a8fef5a96c85b5c80738ae16e7a4b9371bc278cb
getPermFromString
private static int getPermFromString(String permString)
{    int perm = 0;    for (int i = 0; i < permString.length(); i++) {        switch(permString.charAt(i)) {            case 'r':                perm |= ZooDefs.Perms.READ;                break;            case 'w':                perm |= ZooDefs.Perms.WRITE;                break;            case 'c':                perm |= ZooDefs.Perms.CREATE;                break;            case 'd':                perm |= ZooDefs.Perms.DELETE;                break;            case 'a':                perm |= ZooDefs.Perms.ADMIN;                break;            default:                System.err.println("Unknown perm type: " + permString.charAt(i));        }    }    return perm;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    byte[] b = null;    if (args.length >= 3) {        b = args[2].getBytes();    }    zk.addAuthInfo(args[1], b);    return false;}
6906c10616ffd3e20ec7795014c57d2be8fc73ba618fad3716790c5c1210d754
setOut
public void setOut(PrintStream out)
{    this.out = out;}
5b7d8825402b3fa3d12e36ca6515cc5854b57744888c38af67fb0198112ec18f
setErr
public void setErr(PrintStream err)
{    this.err = err;}
ac56e924ec687d192f415e7335607bcbd8b0e1182542d613d527e1e203c33694
setZk
public void setZk(ZooKeeper zk)
{    this.zk = zk;}
482deb327ac28257078b10520e939440f32d8f0f680ed076745674f0642ecab4
getCmdStr
public String getCmdStr()
{    return cmdStr;}
56b436665cdb5b795c5ebf0c5b7e7450dee67e20aed164f57545734d1b6ebaac
getOptionStr
public String getOptionStr()
{    return optionStr;}
f32238a3fe048360bbac6c2f2813b5a4430ec38fc0853eea32bb79ecda6de81e
getUsageStr
public String getUsageStr()
{    return cmdStr + " " + optionStr;}
55d7e35a7a116d8e9c4b42012e1ce8c10f49b33556770e33b3980183dbfccc62
addToMap
public void addToMap(Map<String, CliCommand> cmdMap)
{    cmdMap.put(cmdStr, this);}
5e3ba7e60b4abd2e6f951792ccf4acc15a3126f7d3eff8cac85e8d00388c4378
getExitCode
public int getExitCode()
{    return exitCode;}
0ac2a8890a460650578a2db849f5c0084b134a699df1c9b65d4e166eb1bdfffb
getMessage
private static String getMessage(Throwable cause)
{    if (cause instanceof KeeperException) {        KeeperException keeperException = (KeeperException) cause;        if (keeperException instanceof KeeperException.NoNodeException) {            return "Node does not exist: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoChildrenForEphemeralsException) {            return "Ephemerals cannot have children: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NodeExistsException) {            return "Node already exists: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotEmptyException) {            return "Node not empty: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotReadOnlyException) {            return "Not a read-only call: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.InvalidACLException) {            return "Acl is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoAuthException) {            return "Authentication is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadArgumentsException) {            return "Arguments are not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadVersionException) {            return "version No is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.ReconfigInProgress) {            return "Another reconfiguration is in progress -- concurrent " + "reconfigs not supported (yet)";        } else if (keeperException instanceof KeeperException.NewConfigNoQuorum) {            return "No quorum of new config is connected and " + "up-to-date with the leader of last commmitted config - try invoking reconfiguration after " + "new servers are connected and synced";        }    }    return cause.getMessage();}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    try {        zk.close();    } catch (Exception ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    boolean hasE = cl.hasOption("e");    boolean hasS = cl.hasOption("s");    boolean hasC = cl.hasOption("c");    boolean hasT = cl.hasOption("t");    if (hasC && (hasE || hasS)) {        throw new MalformedCommandException("-c cannot be combined with -s or -e. Containers cannot be ephemeral or sequential.");    }    long ttl;    try {        ttl = hasT ? Long.parseLong(cl.getOptionValue("t")) : 0;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-t argument must be a long value");    }    if (hasT && hasE) {        throw new MalformedCommandException("TTLs cannot be used with Ephemeral znodes");    }    if (hasT && hasC) {        throw new MalformedCommandException("TTLs cannot be used with Container znodes");    }    CreateMode flags;    if (hasE && hasS) {        flags = CreateMode.EPHEMERAL_SEQUENTIAL;    } else if (hasE) {        flags = CreateMode.EPHEMERAL;    } else if (hasS) {        flags = hasT ? CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL : CreateMode.PERSISTENT_SEQUENTIAL;    } else if (hasC) {        flags = CreateMode.CONTAINER;    } else {        flags = hasT ? CreateMode.PERSISTENT_WITH_TTL : CreateMode.PERSISTENT;    }    if (hasT) {        try {            EphemeralType.TTL.toEphemeralOwner(ttl);        } catch (IllegalArgumentException e) {            throw new MalformedCommandException(e.getMessage());        }    }    String path = args[1];    byte[] data = null;    if (args.length > 2) {        data = args[2].getBytes();    }    List<ACL> acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;    if (args.length > 3) {        acl = AclParser.parse(args[3]);    }    try {        String newPath = hasT ? zk.create(path, data, acl, flags, new Stat(), ttl) : zk.create(path, data, acl, flags);        err.println("Created " + newPath);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.EphemeralOnLocalSessionException e) {        err.println("Unable to create ephemeral node on a local session");        throw new CliWrapperException(e);    } catch (KeeperException.InvalidACLException ex) {        err.println(ex.getMessage());        throw new CliWrapperException(ex);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    printDeprecatedWarning();    int batchSize;    try {        batchSize = cl.hasOption("b") ? Integer.parseInt(cl.getOptionValue("b")) : 1000;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-b argument must be an int value");    }    String path = args[1];    try {        boolean success = ZKUtil.deleteRecursive(zk, path, batchSize);        if (!success) {            err.println("Failed to delete some node(s) in the subtree!");        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
89ba1e29f32f2549eacf66c364d466129ece0bbde8b095de0b016f881d5a4237
printDeprecatedWarning
private void printDeprecatedWarning()
{    if ("rmr".equals(args[0])) {        err.println("The command 'rmr' has been deprecated. " + "Please use 'deleteall' instead.");    }}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
67f54c91c73c0d91d41878e83fb0acd306cc8df3d33a440790e7a8e5739d8a3a
retainCompatibility
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{    if (args.length > 2) {        err.println("'delete path [version]' has been deprecated. " + "Please use 'delete [-v version] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        zk.delete(path, version);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{            String path = args[1];    try {        if (cl.hasOption("b")) {            delQuota(zk, path, true, false);        } else if (cl.hasOption("n")) {            delQuota(zk, path, false, true);        } else if (args.length == 2) {                                    delQuota(zk, path, true, true);        }    } catch (KeeperException | InterruptedException | IOException ex) {        throw new CliWrapperException(ex);    }    return false;}
e8cdca3776f152227f0274be3ab8d4bc8abd6d9e4852e4d01090bc93f6cd7124
delQuota
public static boolean delQuota(ZooKeeper zk, String path, boolean bytes, boolean numNodes) throws KeeperException, IOException, InterruptedException, MalformedPathException
{    String parentPath = Quotas.quotaZookeeper + path;    String quotaPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    if (zk.exists(quotaPath, false) == null) {        System.out.println("Quota does not exist for " + path);        return true;    }    byte[] data = null;    try {        data = zk.getData(quotaPath, false, new Stat());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        System.err.println("quota does not exist for " + path);        return true;    }    StatsTrack strack = new StatsTrack(new String(data));    if (bytes && !numNodes) {        strack.setBytes(-1L);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (!bytes && numNodes) {        strack.setCount(-1);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (bytes && numNodes) {                        List<String> children = zk.getChildren(parentPath, false);                for (String child : children) {            zk.delete(parentPath + "/" + child, -1);        }                trimProcQuotas(zk, parentPath);    }    return true;}
69ebc7f89aa3faf4be7d19eb80a5fdb9cd2cbadaeada90ab3e920eeb2a8184b7
trimProcQuotas
private static boolean trimProcQuotas(ZooKeeper zk, String path) throws KeeperException, IOException, InterruptedException
{    if (Quotas.quotaZookeeper.equals(path)) {        return true;    }    List<String> children = zk.getChildren(path, false);    if (children.size() == 0) {        zk.delete(path, -1);        String parent = path.substring(0, path.lastIndexOf('/'));        return trimProcQuotas(zk, parent);    } else {        return true;    }}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    Stat stat = new Stat();    List<ACL> acl;    try {        acl = zk.getACL(path, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    for (ACL a : acl) {        out.println(a.getId() + ": " + getPermString(a.getPerms()));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return false;}
bc3974ef378d53bd049eba4ea52b420edc4622a8c020129cef583922227a938f
getPermString
private static String getPermString(int perms)
{    StringBuilder p = new StringBuilder();    if ((perms & ZooDefs.Perms.CREATE) != 0) {        p.append('c');    }    if ((perms & ZooDefs.Perms.DELETE) != 0) {        p.append('d');    }    if ((perms & ZooDefs.Perms.READ) != 0) {        p.append('r');    }    if ((perms & ZooDefs.Perms.WRITE) != 0) {        p.append('w');    }    if ((perms & ZooDefs.Perms.ADMIN) != 0) {        p.append('a');    }    return p.toString();}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    try {        String path = args[1];        int allChildrenNumber = zk.getAllChildrenNumber(path);        out.println(allChildrenNumber);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
67f54c91c73c0d91d41878e83fb0acd306cc8df3d33a440790e7a8e5739d8a3a
retainCompatibility
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'get path [watch]' has been deprecated. " + "Please use 'get [-s] [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    boolean watch = cl.hasOption("w");    String path = args[1];    Stat stat = new Stat();    byte[] data;    try {        data = zk.getData(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliException(ex);    }    data = (data == null) ? "null".getBytes() : data;    out.println(new String(data));    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 1) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    boolean watch = cl.hasOption("w");    Stat stat = new Stat();    byte[] data;    try {        data = zk.getConfig(watch, stat);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    data = (data == null) ? "null".getBytes() : data;    if (cl.hasOption("c")) {        out.println(ConfigUtils.getClientConfigStr(new String(data)));    } else {        out.println(new String(data));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path;    List<String> ephemerals;    try {        if (args.length < 2) {                        ephemerals = zk.getEphemerals();        } else {            path = args[1];            ephemerals = zk.getEphemerals(path);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(ephemerals);    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    try {        err.println("absolute path is " + absolutePath);        Stat stat = new Stat();        byte[] data = zk.getData(absolutePath, false, stat);        StatsTrack st = new StatsTrack(new String(data));        out.println("Output quota for " + path + " " + st.toString());        data = zk.getData(Quotas.quotaZookeeper + path + "/" + Quotas.statNode, false, stat);        out.println("Output stat for " + path + " " + new StatsTrack(new String(data)).toString());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        err.println("quota for " + path + " does not exist.");    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    err.println("'ls2' has been deprecated. " + "Please use 'ls [-s] path' instead.");    String path = args[1];    boolean watch = args.length > 2;    Stat stat = new Stat();    List<String> children;    try {        children = zk.getChildren(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(children);    new StatPrinter(out).print(stat);    return watch;}
ffd69fa87b19387214b43724e7138bae5c8fa97d86b57e6907825ba03c1d132b
printHelp
private void printHelp()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ls [options] path", options);}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (cl.hasOption("?")) {        printHelp();    }    retainCompatibility(cmdArgs);    return this;}
67f54c91c73c0d91d41878e83fb0acd306cc8df3d33a440790e7a8e5739d8a3a
retainCompatibility
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'ls path [watch]' has been deprecated. " + "Please use 'ls [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    String path = args[1];    boolean watch = cl.hasOption("w");    boolean withStat = cl.hasOption("s");    boolean recursive = cl.hasOption("R");    try {        if (recursive) {            ZKUtil.visitSubTreeDFS(zk, path, watch, new StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    out.println(path);                }            });        } else {            Stat stat = withStat ? new Stat() : null;            List<String> children = zk.getChildren(path, watch, stat);            printChildren(children, stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return watch;}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    out.println(path);}
dc0864e35c5f38a50acbd7d06c480ea2bdd251d66e1fa7e1cbf5898ab20b508e
printChildren
private void printChildren(List<String> children, Stat stat)
{    Collections.sort(children);    out.append("[");    boolean first = true;    for (String child : children) {        if (!first) {            out.append(", ");        } else {            first = false;        }        out.append(child);    }    out.append("]");    if (stat != null) {        new StatPrinter(out).print(stat);    }    out.append("\n");}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    joining = null;    leaving = null;    members = null;    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    if (!(cl.hasOption("file") || cl.hasOption("members")) && !cl.hasOption("add") && !cl.hasOption("remove")) {        throw new CliParseException(getUsageStr());    }    if (cl.hasOption("v")) {        try {            version = Long.parseLong(cl.getOptionValue("v"), 16);        } catch (NumberFormatException e) {            throw new CliParseException("-v must be followed by a long (configuration version)");        }    } else {        version = -1;    }        if ((cl.hasOption("file") || cl.hasOption("members")) && (cl.hasOption("add") || cl.hasOption("remove"))) {        throw new CliParseException("Can't use -file or -members together with -add or -remove (mixing incremental" + " and non-incremental modes is not allowed)");    }    if (cl.hasOption("file") && cl.hasOption("members")) {        throw new CliParseException("Can't use -file and -members together (conflicting non-incremental modes)");    }        if (cl.hasOption("add")) {        joining = cl.getOptionValue("add").toLowerCase();    }    if (cl.hasOption("remove")) {        leaving = cl.getOptionValue("remove").toLowerCase();    }    if (cl.hasOption("members")) {        members = cl.getOptionValue("members").toLowerCase();    }    if (cl.hasOption("file")) {        try {            Properties dynamicCfg = new Properties();            try (FileInputStream inConfig = new FileInputStream(cl.getOptionValue("file"))) {                dynamicCfg.load(inConfig);            }                                                members = QuorumPeerConfig.parseDynamicConfig(dynamicCfg, 0, true, false).toString();        } catch (Exception e) {            throw new CliParseException("Error processing " + cl.getOptionValue("file") + e.getMessage());        }    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    try {        Stat stat = new Stat();        if (!(zk instanceof ZooKeeperAdmin)) {                        return false;        }        byte[] curConfig = ((ZooKeeperAdmin) zk).reconfigure(joining, leaving, members, version, stat);        out.println("Committed new configuration:\n" + new String(curConfig));        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
3818ce8382138f1b40440e0e1b57defb6343b66c407f34bf4b5dd1df939b9709
exec
public boolean exec() throws CliWrapperException, MalformedPathException
{    String path = args[1];    WatcherType wtype = WatcherType.Any;        if (cl.hasOption("c")) {        wtype = WatcherType.Children;    } else if (cl.hasOption("d")) {        wtype = WatcherType.Data;    } else if (cl.hasOption("a")) {        wtype = WatcherType.Any;    }        boolean local = cl.hasOption("l");    try {        zk.removeAllWatches(path, wtype, local);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    String aclStr = args[2];    List<ACL> acl = AclParser.parse(aclStr);    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        if (cl.hasOption("R")) {            ZKUtil.visitSubTreeDFS(zk, path, false, new StringCallback() {                @Override                public void processResult(int rc, String p, Object ctx, String name) {                    try {                        zk.setACL(p, acl, version);                    } catch (KeeperException | InterruptedException e) {                        out.print(e.getMessage());                    }                }            });        } else {            Stat stat = zk.setACL(path, acl, version);            if (cl.hasOption("s")) {                new StatPrinter(out).print(stat);            }        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
f3c7d03cfa0ba91ba82315de833957b35a5d7fe1a6a5cbe582a24ca87f00872f
processResult
public void processResult(int rc, String p, Object ctx, String name)
{    try {        zk.setACL(p, acl, version);    } catch (KeeperException | InterruptedException e) {        out.print(e.getMessage());    }}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    byte[] data = args[2].getBytes();    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        Stat stat = zk.setData(path, data, version);        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{        String path = args[1];    if (path.startsWith(Quotas.quotaZookeeper)) {        err.println("cannot set a quota under the path: " + Quotas.quotaZookeeper);        return false;    }    if (cl.hasOption("b")) {                long bytes = Long.parseLong(cl.getOptionValue("b"));        try {            createQuota(zk, path, bytes, -1);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else if (cl.hasOption("n")) {                int numNodes = Integer.parseInt(cl.getOptionValue("n"));        try {            createQuota(zk, path, -1L, numNodes);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else {        throw new MalformedCommandException(getUsageStr());    }    return false;}
20a3d0ad1841fcf7c0c3f4843e78b89f142a0487b5e63339c06a4bf3d681f926
createQuota
public static boolean createQuota(ZooKeeper zk, String path, long bytes, int numNodes) throws KeeperException, InterruptedException, IllegalArgumentException, MalformedPathException
{                Stat initStat;    try {        initStat = zk.exists(path, false);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    }    if (initStat == null) {        throw new IllegalArgumentException(path + " does not exist.");    }            String quotaPath = Quotas.quotaZookeeper;                            checkIfChildQuota(zk, path);        checkIfParentQuota(zk, path);        if (zk.exists(quotaPath, false) == null) {        try {            zk.create(Quotas.procZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.create(Quotas.quotaZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }            String[] splits = path.split("/");    StringBuilder sb = new StringBuilder();    sb.append(quotaPath);    for (int i = 1; i < splits.length; i++) {        sb.append("/").append(splits[i]);        quotaPath = sb.toString();        try {            zk.create(quotaPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }    String statPath = quotaPath + "/" + Quotas.statNode;    quotaPath = quotaPath + "/" + Quotas.limitNode;    StatsTrack strack = new StatsTrack(null);    strack.setBytes(bytes);    strack.setCount(numNodes);    try {        zk.create(quotaPath, strack.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        StatsTrack stats = new StatsTrack(null);        stats.setBytes(0L);        stats.setCount(0);        zk.create(statPath, stats.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ne) {        byte[] data = zk.getData(quotaPath, false, new Stat());        StatsTrack strackC = new StatsTrack(new String(data));        if (bytes != -1L) {            strackC.setBytes(bytes);        }        if (numNodes != -1) {            strackC.setCount(numNodes);        }        zk.setData(quotaPath, strackC.toString().getBytes(), -1);    }    return true;}
081737a8c3b6782d27366c060f56f510f2a1e9bd5f97bd1b862e151cae784f58
checkIfChildQuota
private static void checkIfChildQuota(ZooKeeper zk, String path) throws KeeperException, InterruptedException
{    String realPath = Quotas.quotaZookeeper + path;    try {        ZKUtil.visitSubTreeDFS(zk, realPath, false, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String quotaPath, Object ctx, String name) {                List<String> children = new ArrayList<>();                try {                    children = zk.getChildren(quotaPath, false);                } catch (KeeperException.NoNodeException ne) {                    LOG.debug("child removed during quota check", ne);                    return;                } catch (InterruptedException | KeeperException e) {                    e.printStackTrace();                }                if (children.size() == 0) {                    return;                }                for (String child : children) {                    if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                        throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");                    }                }            }        });    } catch (KeeperException.NoNodeException ne) {        }}
d2b509685dd0e630c06f57f2a72d5aa7a35f07b73a75cd0a3dde797049d94006
processResult
public void processResult(int rc, String quotaPath, Object ctx, String name)
{    List<String> children = new ArrayList<>();    try {        children = zk.getChildren(quotaPath, false);    } catch (KeeperException.NoNodeException ne) {        LOG.debug("child removed during quota check", ne);        return;    } catch (InterruptedException | KeeperException e) {        e.printStackTrace();    }    if (children.size() == 0) {        return;    }    for (String child : children) {        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {            throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");        }    }}
800dbf36333a6aaa27edf37057b8eac7ff61b03ae94dda5e471adc0c394a5df9
checkIfParentQuota
private static void checkIfParentQuota(ZooKeeper zk, String path) throws InterruptedException, KeeperException
{    final String[] splits = path.split("/");    String quotaPath = Quotas.quotaZookeeper;    for (String str : splits) {        if (str.length() == 0) {                        continue;        }        quotaPath += "/" + str;        List<String> children = null;        try {            children = zk.getChildren(quotaPath, false);        } catch (KeeperException.NoNodeException ne) {            LOG.debug("child removed during quota check", ne);            return;        }        if (children.size() == 0) {            return;        }        for (String child : children) {            if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                throw new IllegalArgumentException(path + " has a parent " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");            }        }    }}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
67f54c91c73c0d91d41878e83fb0acd306cc8df3d33a440790e7a8e5739d8a3a
retainCompatibility
private void retainCompatibility(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'stat path [watch]' has been deprecated. " + "Please use 'stat [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    boolean watch = cl.hasOption("w");    Stat stat;    try {        stat = zk.exists(path, watch);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    if (stat == null) {        throw new CliWrapperException(new KeeperException.NoNodeException(path));    }    new StatPrinter(out).print(stat);    return watch;}
c0f24f804882185e30ed04d795f89f82fef64553bb3c7a858f27e815e454c670
print
public void print(Stat stat)
{    out.println("cZxid = 0x" + Long.toHexString(stat.getCzxid()));    out.println("ctime = " + new Date(stat.getCtime()).toString());    out.println("mZxid = 0x" + Long.toHexString(stat.getMzxid()));    out.println("mtime = " + new Date(stat.getMtime()).toString());    out.println("pZxid = 0x" + Long.toHexString(stat.getPzxid()));    out.println("cversion = " + stat.getCversion());    out.println("dataVersion = " + stat.getVersion());    out.println("aclVersion = " + stat.getAversion());    out.println("ephemeralOwner = 0x" + Long.toHexString(stat.getEphemeralOwner()));    out.println("dataLength = " + stat.getDataLength());    out.println("numChildren = " + stat.getNumChildren());}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    String path = args[1];    CompletableFuture<Integer> cf = new CompletableFuture<>();    try {        zk.sync(path, new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                cf.complete(rc);            }        }, null);        int resultCode = cf.get(SYNC_TIMEOUT, TimeUnit.MILLISECONDS);        if (resultCode == 0) {            out.println("Sync is OK");        } else {            out.println("Sync has failed. rc=" + resultCode);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (InterruptedException ie) {        Thread.currentThread().interrupt();        throw new CliWrapperException(ie);    } catch (TimeoutException | ExecutionException ex) {        throw new CliWrapperException(ex);    }    return false;}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    cf.complete(rc);}
693ebeebfeb2c90b18b3f3299ed7f0e96becf14cf45cc07467a850529e4942a8
parse
public CliCommand parse(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length > 1) {        throw new CliParseException(getUsageStr());    }    return this;}
01236622927e4df1dac20c4d7d50d961d51bb181e1378ab00a5e093d6baaa8a9
exec
public boolean exec() throws CliException
{    out.println("ZooKeeper CLI version: " + Version.getFullVersion());    return false;}
214713363a1047ab1a9e9882a8599c077088b2c6ff88e9d721d11c741baa31cb
getChrootPath
public String getChrootPath()
{    return chrootPath;}
3ed8a6a53d7104564bcad3001024675ddf06b7595f3ca87ce11a38a84a1d021e
getServerAddresses
public ArrayList<InetSocketAddress> getServerAddresses()
{    return serverAddresses;}
51b7150a3d85a3cd5f1f24606def5e0debfa02355d687c5cbe268e3820dd48f5
send4LetterWord
public static String send4LetterWord(String host, int port, String cmd) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, false, DEFAULT_SOCKET_TIMEOUT);}
29211555c0f46a5119c205bdc5914762277d684a9a48ea0f4752dcf1b98308ce
send4LetterWord
public static String send4LetterWord(String host, int port, String cmd, boolean secure) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, secure, DEFAULT_SOCKET_TIMEOUT);}
b607fce1cb33cfc830f26db08b91a2b05c5f58c71b5be476645142cc5957de24
send4LetterWord
public static String send4LetterWord(String host, int port, String cmd, boolean secure, int timeout) throws IOException, SSLContextException
{    LOG.info("connecting to {} {}", host, port);    Socket sock;    InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);    if (secure) {        LOG.info("using secure socket");        try (X509Util x509Util = new ClientX509Util()) {            SSLContext sslContext = x509Util.getDefaultSSLContext();            SSLSocketFactory socketFactory = sslContext.getSocketFactory();            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();            sslSock.connect(hostaddress, timeout);            sslSock.startHandshake();            sock = sslSock;        }    } else {        sock = new Socket();        sock.connect(hostaddress, timeout);    }    sock.setSoTimeout(timeout);    BufferedReader reader = null;    try {        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                if (!secure) {                        sock.shutdownOutput();        }        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) {            sb.append(line).append("\n");        }        return sb.toString();    } catch (SocketTimeoutException e) {        throw new IOException("Exception while executing four letter word: " + cmd, e);    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
172062cecaab557cce157f12e394f2c9656cc89bce9959f25fb68a10842db0d7
main
public static void main(String[] args) throws IOException, SSLContextException
{    if (args.length == 3) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2]));    } else if (args.length == 4) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2], Boolean.parseBoolean(args[3])));    } else {        System.out.println("Usage: FourLetterWordMain <host> <port> <cmd> <secure(optional)>");    }}
ba0766b6dc7aece9e196679db3bff11da208cbb672fb59e42898a9cabbad1904
getAllByName
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
ba0766b6dc7aece9e196679db3bff11da208cbb672fb59e42898a9cabbad1904
getAllByName
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
7ef5acbcd8b0a931b66bc01c9e7259dc6fa7373c64a1e70b9fb99d928d628501
init
private void init(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver)
{    this.sourceOfRandomness = new Random(randomnessSeed);    this.resolver = resolver;    if (serverAddresses.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }    this.serverAddresses = shuffle(serverAddresses);    currentIndex = -1;    lastIndex = -1;}
f7a029eb2effddc5f6f9b046df7266969f680df4027fb64677a069b26412800f
resolve
private InetSocketAddress resolve(InetSocketAddress address)
{    try {        String curHostString = address.getHostString();        List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));        if (resolvedAddresses.isEmpty()) {            return address;        }        Collections.shuffle(resolvedAddresses);        return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());    } catch (UnknownHostException e) {        LOG.error("Unable to resolve address: {}", address.toString(), e);        return address;    }}
62c20f0c0fe4d5e5a32687306090988c9c5af8c2c95612385f8d4d7db9d8928d
shuffle
private List<InetSocketAddress> shuffle(Collection<InetSocketAddress> serverAddresses)
{    List<InetSocketAddress> tmpList = new ArrayList<>(serverAddresses.size());    tmpList.addAll(serverAddresses);    Collections.shuffle(tmpList, sourceOfRandomness);    return tmpList;}
fd51c9c9a0aa1adc41254fa44f52cd534ba56665b908538a3e892041087509b4
updateServerList
public synchronized boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    List<InetSocketAddress> shuffledList = shuffle(serverAddresses);    if (shuffledList.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }        boolean myServerInNewConfig = false;    InetSocketAddress myServer = currentHost;        if (reconfigMode) {        myServer = next(0);    }        if (myServer == null) {                if (lastIndex >= 0) {                        myServer = this.serverAddresses.get(lastIndex);        } else {                        myServer = this.serverAddresses.get(0);        }    }    for (InetSocketAddress addr : shuffledList) {        if (addr.getPort() == myServer.getPort() && ((addr.getAddress() != null && myServer.getAddress() != null && addr.getAddress().equals(myServer.getAddress())) || addr.getHostString().equals(myServer.getHostString()))) {            myServerInNewConfig = true;            break;        }    }    reconfigMode = true;    newServers.clear();    oldServers.clear();        for (InetSocketAddress address : shuffledList) {        if (this.serverAddresses.contains(address)) {            oldServers.add(address);        } else {            newServers.add(address);        }    }    int numOld = oldServers.size();    int numNew = newServers.size();        if (numOld + numNew > this.serverAddresses.size()) {        if (myServerInNewConfig) {                        if (sourceOfRandomness.nextFloat() <= (1 - ((float) this.serverAddresses.size()) / (numOld + numNew))) {                pNew = 1;                pOld = 0;            } else {                                reconfigMode = false;            }        } else {                                                pNew = 1;            pOld = 0;        }    } else {                if (myServerInNewConfig) {                                    reconfigMode = false;        } else {            pOld = ((float) (numOld * (this.serverAddresses.size() - (numOld + numNew)))) / ((numOld + numNew) * (this.serverAddresses.size() - numOld));            pNew = 1 - pOld;        }    }    if (!reconfigMode) {        currentIndex = shuffledList.indexOf(getServerAtCurrentIndex());    } else {        currentIndex = -1;    }    this.serverAddresses = shuffledList;    currentIndexOld = -1;    currentIndexNew = -1;    lastIndex = currentIndex;    return reconfigMode;}
fdb0d44ee6985a1441034c3ea8b5304548ad9e7f7be072b095cb3d349e5c99d2
getServerAtIndex
public synchronized InetSocketAddress getServerAtIndex(int i)
{    if (i < 0 || i >= serverAddresses.size()) {        return null;    }    return serverAddresses.get(i);}
09a317b445742362e535dc03ee1a1be1ddaa1f6b0ad95a24c3c17ae0e8c0cbc5
getServerAtCurrentIndex
public synchronized InetSocketAddress getServerAtCurrentIndex()
{    return getServerAtIndex(currentIndex);}
eaafb4eb5b18fb3b34f16a6b742f9b616dd9970c142c488a7f39a82bc83df423
size
public synchronized int size()
{    return serverAddresses.size();}
dadc35e4c61e678ac106b36b48d7074ff308e76138ba0a0e105435abb8f317c5
nextHostInReconfigMode
private InetSocketAddress nextHostInReconfigMode()
{    boolean takeNew = (sourceOfRandomness.nextFloat() <= pNew);        if (((currentIndexNew + 1) < newServers.size()) && (takeNew || (currentIndexOld + 1) >= oldServers.size())) {        ++currentIndexNew;        return newServers.get(currentIndexNew);    }        if ((currentIndexOld + 1) < oldServers.size()) {        ++currentIndexOld;        return oldServers.get(currentIndexOld);    }    return null;}
c9541b1679326fe5747ee15703657217204a99e71b02ed734b5b8338e2dbf914
next
public InetSocketAddress next(long spinDelay)
{    boolean needToSleep = false;    InetSocketAddress addr;    synchronized (this) {        if (reconfigMode) {            addr = nextHostInReconfigMode();            if (addr != null) {                currentIndex = serverAddresses.indexOf(addr);                return resolve(addr);            }                        reconfigMode = false;            needToSleep = (spinDelay > 0);        }        ++currentIndex;        if (currentIndex == serverAddresses.size()) {            currentIndex = 0;        }        addr = serverAddresses.get(currentIndex);        needToSleep = needToSleep || (currentIndex == lastIndex && spinDelay > 0);        if (lastIndex == -1) {                        lastIndex = 0;        }    }    if (needToSleep) {        try {            Thread.sleep(spinDelay);        } catch (InterruptedException e) {            LOG.warn("Unexpected exception", e);        }    }    return resolve(addr);}
f876a4d2569f6dfa2b095111d11b3554d22b75ebe5e27d71b01d8b06060e9691
onConnected
public synchronized void onConnected()
{    lastIndex = currentIndex;    reconfigMode = false;}
dd21ba846150a8f564e742de9aded967c864c6adc3ca4551a4f423242dd14da5
initFromJavaSystemProperties
private void initFromJavaSystemProperties()
{    setProperty(ZOOKEEPER_REQUEST_TIMEOUT, System.getProperty(ZOOKEEPER_REQUEST_TIMEOUT));}
6df4e87bdc5cbc70e5b186d6b0e03c0436ffe2aecb3f4b2cc603fbd0924a7246
handleBackwardCompatibility
protected void handleBackwardCompatibility()
{    /**     * backward compatibility for properties which are common to both client     * and server     */    super.handleBackwardCompatibility();    /**     * backward compatibility for client specific properties     */    setProperty(ZK_SASL_CLIENT_USERNAME, System.getProperty(ZK_SASL_CLIENT_USERNAME));    setProperty(LOGIN_CONTEXT_NAME_KEY, System.getProperty(LOGIN_CONTEXT_NAME_KEY));    setProperty(ENABLE_CLIENT_SASL_KEY, System.getProperty(ENABLE_CLIENT_SASL_KEY));    setProperty(ZOOKEEPER_SERVER_REALM, System.getProperty(ZOOKEEPER_SERVER_REALM));    setProperty(DISABLE_AUTO_WATCH_RESET, System.getProperty(DISABLE_AUTO_WATCH_RESET));    setProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET, System.getProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET));    setProperty(SECURE_CLIENT, System.getProperty(SECURE_CLIENT));}
ff22d2534c96a5bf3f2b163e1d6da17c58a4f522d6156e1a18c19d0ac640a36c
isSaslClientEnabled
public boolean isSaslClientEnabled()
{    return Boolean.valueOf(getProperty(ENABLE_CLIENT_SASL_KEY, ENABLE_CLIENT_SASL_DEFAULT));}
8547542baed103f1c75de860ab3559c5db8efd597aeef5b6135230491492b275
getLong
public long getLong(String key, long defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Long.parseLong(value.trim());    }    return defaultValue;}
e1d0d181270e298954afdc7172f6f928c265cff4050354f01cb0c91580a0131e
isEnabled
public static boolean isEnabled()
{    return Boolean.parseBoolean(System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT));}
c17c03a2dfb111935eaa63c065e45ee0379022c4da9addb7e51dec21bfdf0069
getSaslState
public SaslState getSaslState()
{    return saslState;}
c609f053192bc1a52f10b03a7a1eea8edc96e165fe9b2972d179f90f57fb872f
getLoginContext
public String getLoginContext()
{    if (login != null) {        return login.getLoginContextName();    }    return null;}
b3d71dbfed8fa7bd2e92212659234c84e2d3bb25f3a29d9a4d8f878104127324
getConfigStatus
public String getConfigStatus()
{    return configStatus;}
6b8341e3bf79cd81024e28fa7df191b8c1cc2c3e26c486ea6fa2a5e58e89ef5d
isComplete
public boolean isComplete()
{    return (saslState == SaslState.COMPLETE);}
d96e2668dc227362a6de3cac8f1c7ffd0544111b3897b318561bbeb7c4da2682
isFailed
public boolean isFailed()
{    return (saslState == SaslState.FAILED);}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{                    ZooKeeperSaslClient client = ((ClientCnxn) ctx).zooKeeperSaslClient;    if (client == null) {        LOG.warn("sasl client was unexpectedly null: cannot respond to Zookeeper server.");        return;    }    byte[] usedata = data;    if (data != null) {        LOG.debug("ServerSaslResponseCallback(): saslToken server response: (length={})", usedata.length);    } else {        usedata = new byte[0];        LOG.debug("ServerSaslResponseCallback(): using empty data[] as server response (length={})", usedata.length);    }    client.respondToServer(usedata, (ClientCnxn) ctx);}
82df5595491b8cebddc6e1942fe85e9119392bf6514e94588fa53b04826a2c7d
createSaslClient
private SaslClient createSaslClient(final String servicePrincipal, final String loginContext) throws LoginException
{    try {        if (!initializedLogin) {            synchronized (this) {                if (login == null) {                    LOG.debug("JAAS loginContext is: {}", loginContext);                                                            login = new Login(loginContext, new SaslClientCallbackHandler(null, "Client"), clientConfig);                    login.startThreadIfNeeded();                    initializedLogin = true;                }            }        }        return SecurityUtils.createSaslClient(login.getSubject(), servicePrincipal, "zookeeper", "zk-sasl-md5", LOG, "Client");    } catch (LoginException e) {                throw e;    } catch (Exception e) {                LOG.error("Exception while trying to create SASL client: " + e);        return null;    }}
c1ec85f4ce92ce26c9ddb4b651b1513418264c81d9d5f254204ab07ff77d39b4
respondToServer
public void respondToServer(byte[] serverToken, ClientCnxn cnxn)
{    if (saslClient == null) {        LOG.error("saslClient is unexpectedly null. Cannot respond to server's SASL message; ignoring.");        return;    }    if (!(saslClient.isComplete())) {        try {            saslToken = createSaslToken(serverToken);            if (saslToken != null) {                sendSaslPacket(saslToken, cnxn);            }        } catch (SaslException e) {            LOG.error("SASL authentication failed using login context '" + this.getLoginContext() + "' with exception: {}", e);            saslState = SaslState.FAILED;            gotLastPacket = true;        }    }    if (saslClient.isComplete()) {                if ((serverToken == null) && (saslClient.getMechanismName().equals("GSSAPI"))) {            gotLastPacket = true;        }                if (!saslClient.getMechanismName().equals("GSSAPI")) {            gotLastPacket = true;        }                                cnxn.saslCompleted();    }}
6cfc29e5a066e4ba3d7d94fb6c39efe90d0b0901d5d169a91fdab8656657f036
createSaslToken
private byte[] createSaslToken() throws SaslException
{    saslState = SaslState.INTERMEDIATE;    return createSaslToken(saslToken);}
2e8d184de996ce445a49c2121d8e337cb28284f8f9f159ed530480ad5d9f80fb
createSaslToken
private byte[] createSaslToken(final byte[] saslToken) throws SaslException
{    if (saslToken == null) {                saslState = SaslState.FAILED;        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    Subject subject = login.getSubject();    if (subject != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                        LOG.debug("saslClient.evaluateChallenge(len={})", saslToken.length);                        return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's " + " received SASL token.";                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.";                }                error += " Zookeeper Client will go to AUTH_FAILED state.";                LOG.error(error);                saslState = SaslState.FAILED;                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
cabddfad6ece7010bf35d8db56919a4a2dbdc3c06f3a9f412066a5c204984361
run
public byte[] run() throws SaslException
{    LOG.debug("saslClient.evaluateChallenge(len={})", saslToken.length);    return saslClient.evaluateChallenge(saslToken);}
2e95ff7386a12163a6f7915047426459c777d5adf4f3f76501aa239438c424ee
sendSaslPacket
private void sendSaslPacket(byte[] saslToken, ClientCnxn cnxn) throws SaslException
{    LOG.debug("ClientCnxn:sendSaslPacket:length={}", saslToken.length);    GetSASLRequest request = new GetSASLRequest();    request.setToken(saslToken);    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server.", e);    }}
bb2ecf15f545d1cf37661bb35f960ff9e5083849442955e03f07d45ee9039f38
sendSaslPacket
private void sendSaslPacket(ClientCnxn cnxn) throws SaslException
{    LOG.debug("ClientCnxn:sendSaslPacket:length={}", saslToken.length);    GetSASLRequest request = new GetSASLRequest();    request.setToken(createSaslToken());    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server due " + "to IOException:", e);    }}
0c5a275788e6f1f83b3b01f9579ab53ad9281c7ed28b4ba568864432edf7a488
getKeeperState
public KeeperState getKeeperState()
{    if (saslClient != null) {        if (saslState == SaslState.FAILED) {            return KeeperState.AuthFailed;        }        if (saslClient.isComplete()) {            if (saslState == SaslState.INTERMEDIATE) {                saslState = SaslState.COMPLETE;                return KeeperState.SaslAuthenticated;            }        }    }        return null;}
eabd6894efdfc24779d470fc63529b00b0c21d3150158f619c840afb2c5e462b
initialize
public void initialize(ClientCnxn cnxn) throws SaslException
{    if (saslClient == null) {        saslState = SaslState.FAILED;        throw new SaslException("saslClient failed to initialize properly: it's null.");    }    if (saslState == SaslState.INITIAL) {        if (saslClient.hasInitialResponse()) {            sendSaslPacket(cnxn);        } else {            byte[] emptyToken = new byte[0];            sendSaslPacket(emptyToken, cnxn);        }        saslState = SaslState.INTERMEDIATE;    }}
812b540428c9399e8c56ace8f1ae7ebdaba140944cae8aaa4925e9d371ee5512
clientTunneledAuthenticationInProgress
public boolean clientTunneledAuthenticationInProgress()
{    if (!isSASLConfigured) {        return false;    }        try {        if ((clientConfig.getJaasConfKey() != null) || ((Configuration.getConfiguration() != null) && (Configuration.getConfiguration().getAppConfigurationEntry(clientConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)) != null))) {                        if (!isComplete() && !isFailed()) {                return true;            }                        if (!gotLastPacket) {                                return true;            }        }                return false;    } catch (SecurityException e) {                        LOG.debug("Could not retrieve login configuration", e);        return false;    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (null != login) {        login.shutdown();    }}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return sessionId;}
f35819e64c2a1cfd4033576f52f4fbb8d80247066288cdac11e1bda4ed1f744f
getSessionPasswd
public byte[] getSessionPasswd()
{    return sessionPasswd;}
2436723c695636833e0ebfc52d684cb9ae4da078ffa3153b560d8213802ad011
getSessionTimeout
public int getSessionTimeout()
{    return negotiatedSessionTimeout;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    SocketAddress local = sendThread.getClientCnxnSocket().getLocalSocketAddress();    SocketAddress remote = sendThread.getClientCnxnSocket().getRemoteSocketAddress();    sb.append("sessionid:0x").append(Long.toHexString(getSessionId())).append(" local:").append(local).append(" remoteserver:").append(remote).append(" lastZxid:").append(lastZxid).append(" xid:").append(xid).append(" sent:").append(sendThread.getClientCnxnSocket().getSentCount()).append(" recv:").append(sendThread.getClientCnxnSocket().getRecvCount()).append(" queuedpkts:").append(outgoingQueue.size()).append(" pendingresp:").append(pendingQueue.size()).append(" queuedevents:").append(eventThread.waitingEvents.size());    return sb.toString();}
56de9cec54c496835dcef259ed86321e24a7ee586a7a0b146fb93e7e635d5e9c
createBB
public void createBB()
{    try {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(-1, "len");        if (requestHeader != null) {            requestHeader.serialize(boa, "header");        }        if (request instanceof ConnectRequest) {            request.serialize(boa, "connect");                        boa.writeBool(readOnly, "readOnly");        } else if (request != null) {            request.serialize(boa, "request");        }        baos.close();        this.bb = ByteBuffer.wrap(baos.toByteArray());        this.bb.putInt(this.bb.capacity() - 4);        this.bb.rewind();    } catch (IOException e) {        LOG.warn("Ignoring unexpected exception", e);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("clientPath:" + clientPath);    sb.append(" serverPath:" + serverPath);    sb.append(" finished:" + finished);    sb.append(" header:: " + requestHeader);    sb.append(" replyHeader:: " + replyHeader);    sb.append(" request:: " + request);    sb.append(" response:: " + response);        return sb.toString().replaceAll("\r*\n+", " ");}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    sendThread.start();    eventThread.start();}
4c9afbf9f0a22215cb70b103ea09ff56f0119a57f234ab585d460188ca77204e
makeThreadName
private static String makeThreadName(String suffix)
{    String name = Thread.currentThread().getName().replaceAll("-EventThread", "");    return name + suffix;}
d1d01001b337460f34ac848edff9ab3b1e3bcf7c3c70ff8144a93cdf6549a48c
queueEvent
public void queueEvent(WatchedEvent event)
{    queueEvent(event, null);}
bfb979c17b81a8cfcb4541b7f152ccb90a21924b2e21b7893126e578de002d22
queueEvent
private void queueEvent(WatchedEvent event, Set<Watcher> materializedWatchers)
{    if (event.getType() == EventType.None && sessionState == event.getState()) {        return;    }    sessionState = event.getState();    final Set<Watcher> watchers;    if (materializedWatchers == null) {                watchers = watcher.materialize(event.getState(), event.getType(), event.getPath());    } else {        watchers = new HashSet<Watcher>();        watchers.addAll(materializedWatchers);    }    WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);        waitingEvents.add(pair);}
3bcdf03cde3eb79c23e60434433747a66cb8261a66f5dae989a4828565e63924
queueCallback
public void queueCallback(AsyncCallback cb, int rc, String path, Object ctx)
{    waitingEvents.add(new LocalCallback(cb, rc, path, ctx));}
c03df8d3699ab532d4214e87d71fbbe5926facd5f68a35cc87c18dc8df311af4
queuePacket
public void queuePacket(Packet packet)
{    if (wasKilled) {        synchronized (waitingEvents) {            if (isRunning) {                waitingEvents.add(packet);            } else {                processEvent(packet);            }        }    } else {        waitingEvents.add(packet);    }}
7841588081f48c63a96eb8539dc227d764ff0b39c3856f4b4abc1b0a212be9c8
queueEventOfDeath
public void queueEventOfDeath()
{    waitingEvents.add(eventOfDeath);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        isRunning = true;        while (true) {            Object event = waitingEvents.take();            if (event == eventOfDeath) {                wasKilled = true;            } else {                processEvent(event);            }            if (wasKilled) {                synchronized (waitingEvents) {                    if (waitingEvents.isEmpty()) {                        isRunning = false;                        break;                    }                }            }        }    } catch (InterruptedException e) {        LOG.error("Event thread exiting due to interruption", e);    }    LOG.info("EventThread shut down for session: 0x{}", Long.toHexString(getSessionId()));}
5ce08e612fc8803d67769ab7b009ed995fd089826a27742d2f5e938b59199927
processEvent
private void processEvent(Object event)
{    try {        if (event instanceof WatcherSetEventPair) {                        WatcherSetEventPair pair = (WatcherSetEventPair) event;            for (Watcher watcher : pair.watchers) {                try {                    watcher.process(pair.event);                } catch (Throwable t) {                    LOG.error("Error while calling watcher ", t);                }            }        } else if (event instanceof LocalCallback) {            LocalCallback lcb = (LocalCallback) event;            if (lcb.cb instanceof StatCallback) {                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof DataCallback) {                ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ACLCallback) {                ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ChildrenCallback) {                ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof Children2Callback) {                ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof StringCallback) {                ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {                ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {                ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);            } else {                ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);            }        } else {            Packet p = (Packet) event;            int rc = 0;            String clientPath = p.clientPath;            if (p.replyHeader.getErr() != 0) {                rc = p.replyHeader.getErr();            }            if (p.cb == null) {                LOG.warn("Somehow a null cb got to EventThread!");            } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {                StatCallback cb = (StatCallback) p.cb;                if (rc == 0) {                    if (p.response instanceof ExistsResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());                    } else if (p.response instanceof SetDataResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());                    } else if (p.response instanceof SetACLResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());                    }                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetDataResponse) {                DataCallback cb = (DataCallback) p.cb;                GetDataResponse rsp = (GetDataResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetACLResponse) {                ACLCallback cb = (ACLCallback) p.cb;                GetACLResponse rsp = (GetACLResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetChildrenResponse) {                ChildrenCallback cb = (ChildrenCallback) p.cb;                GetChildrenResponse rsp = (GetChildrenResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetAllChildrenNumberResponse) {                AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;                GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());                } else {                    cb.processResult(rc, clientPath, p.ctx, -1);                }            } else if (p.response instanceof GetChildren2Response) {                Children2Callback cb = (Children2Callback) p.cb;                GetChildren2Response rsp = (GetChildren2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof CreateResponse) {                StringCallback cb = (StringCallback) p.cb;                CreateResponse rsp = (CreateResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof Create2Response) {                Create2Callback cb = (Create2Callback) p.cb;                Create2Response rsp = (Create2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof MultiResponse) {                MultiCallback cb = (MultiCallback) p.cb;                MultiResponse rsp = (MultiResponse) p.response;                if (rc == 0) {                    List<OpResult> results = rsp.getResultList();                    int newRc = rc;                    for (OpResult result : results) {                        if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {                            break;                        }                    }                    cb.processResult(newRc, clientPath, p.ctx, results);                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetEphemeralsResponse) {                EphemeralsCallback cb = (EphemeralsCallback) p.cb;                GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, p.ctx, rsp.getEphemerals());                } else {                    cb.processResult(rc, p.ctx, null);                }            } else if (p.cb instanceof VoidCallback) {                VoidCallback cb = (VoidCallback) p.cb;                cb.processResult(rc, clientPath, p.ctx);            }        }    } catch (Throwable t) {        LOG.error("Caught unexpected throwable", t);    }}
be683dba73d27bc0f399430e099e046204b8c27e8dc00c8feac4747c6176fec4
finishPacket
protected void finishPacket(Packet p)
{    int err = p.replyHeader.getErr();    if (p.watchRegistration != null) {        p.watchRegistration.register(err);    }        if (p.watchDeregistration != null) {        Map<EventType, Set<Watcher>> materializedWatchers = null;        try {            materializedWatchers = p.watchDeregistration.unregister(err);            for (Entry<EventType, Set<Watcher>> entry : materializedWatchers.entrySet()) {                Set<Watcher> watchers = entry.getValue();                if (watchers.size() > 0) {                    queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());                                                            p.replyHeader.setErr(Code.OK.intValue());                }            }        } catch (KeeperException.NoWatcherException nwe) {            p.replyHeader.setErr(nwe.code().intValue());        } catch (KeeperException ke) {            p.replyHeader.setErr(ke.code().intValue());        }    }    if (p.cb == null) {        synchronized (p) {            p.finished = true;            p.notifyAll();        }    } else {        p.finished = true;        eventThread.queuePacket(p);    }}
9068d61cea7f83d3613963c14150ed89fc0a2f15064343183d21d1ec2bd7ab4a
queueEvent
 void queueEvent(String clientPath, int err, Set<Watcher> materializedWatchers, EventType eventType)
{    KeeperState sessionState = KeeperState.SyncConnected;    if (KeeperException.Code.SESSIONEXPIRED.intValue() == err || KeeperException.Code.CONNECTIONLOSS.intValue() == err) {        sessionState = Event.KeeperState.Disconnected;    }    WatchedEvent event = new WatchedEvent(eventType, sessionState, clientPath);    eventThread.queueEvent(event, materializedWatchers);}
d186923246a7a03a9a21508c8a04b8bf51e33f53effce08d5725c87eb332dd7b
queueCallback
 void queueCallback(AsyncCallback cb, int rc, String path, Object ctx)
{    eventThread.queueCallback(cb, rc, path, ctx);}
1a3559f2b8aeffb09952eb1b2187dbd1828731c91718c927ee0ff677f6fa66c4
conLossPacket
private void conLossPacket(Packet p)
{    if (p.replyHeader == null) {        return;    }    switch(state) {        case AUTH_FAILED:            p.replyHeader.setErr(KeeperException.Code.AUTHFAILED.intValue());            break;        case CLOSED:            p.replyHeader.setErr(KeeperException.Code.SESSIONEXPIRED.intValue());            break;        default:            p.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());    }    finishPacket(p);}
d2f73a962ac8f805f35d213cfeba4c256a65716d467e27f87e37a18c92065dfa
getLastZxid
public long getLastZxid()
{    return lastZxid;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EndOfStreamException: " + getMessage();}
5e515f809fcc627a1167f03cf826bc95625d4f6106aa9c4f4c5663493ce44327
readResponse
 void readResponse(ByteBuffer incomingBuffer) throws IOException
{    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);    ReplyHeader replyHdr = new ReplyHeader();    replyHdr.deserialize(bbia, "header");    if (replyHdr.getXid() == -2) {                if (LOG.isDebugEnabled()) {            LOG.debug("Got ping response for sessionid: 0x" + Long.toHexString(sessionId) + " after " + ((System.nanoTime() - lastPingSentNs) / 1000000) + "ms");        }        return;    }    if (replyHdr.getXid() == -4) {                if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {            state = States.AUTH_FAILED;            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            eventThread.queueEventOfDeath();        }        if (LOG.isDebugEnabled()) {            LOG.debug("Got auth sessionid:0x" + Long.toHexString(sessionId));        }        return;    }    if (replyHdr.getXid() == -1) {                if (LOG.isDebugEnabled()) {            LOG.debug("Got notification sessionid:0x" + Long.toHexString(sessionId));        }        WatcherEvent event = new WatcherEvent();        event.deserialize(bbia, "response");                if (chrootPath != null) {            String serverPath = event.getPath();            if (serverPath.compareTo(chrootPath) == 0) {                event.setPath("/");            } else if (serverPath.length() > chrootPath.length()) {                event.setPath(serverPath.substring(chrootPath.length()));            } else {                LOG.warn("Got server path " + event.getPath() + " which is too short for chroot path " + chrootPath);            }        }        WatchedEvent we = new WatchedEvent(event);        if (LOG.isDebugEnabled()) {            LOG.debug("Got " + we + " for sessionid 0x" + Long.toHexString(sessionId));        }        eventThread.queueEvent(we);        return;    }        if (tunnelAuthInProgress()) {        GetSASLRequest request = new GetSASLRequest();        request.deserialize(bbia, "token");        zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);        return;    }    Packet packet;    synchronized (pendingQueue) {        if (pendingQueue.size() == 0) {            throw new IOException("Nothing in the queue, but got " + replyHdr.getXid());        }        packet = pendingQueue.remove();    }    /*             * Since requests are processed in order, we better get a response             * to the first request!             */    try {        if (packet.requestHeader.getXid() != replyHdr.getXid()) {            packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());            throw new IOException("Xid out of order. Got Xid " + replyHdr.getXid() + " with err " + replyHdr.getErr() + " expected Xid " + packet.requestHeader.getXid() + " for a packet with details: " + packet);        }        packet.replyHeader.setXid(replyHdr.getXid());        packet.replyHeader.setErr(replyHdr.getErr());        packet.replyHeader.setZxid(replyHdr.getZxid());        if (replyHdr.getZxid() > 0) {            lastZxid = replyHdr.getZxid();        }        if (packet.response != null && replyHdr.getErr() == 0) {            packet.response.deserialize(bbia, "response");        }        if (LOG.isDebugEnabled()) {            LOG.debug("Reading reply sessionid:0x" + Long.toHexString(sessionId) + ", packet:: " + packet);        }    } finally {        finishPacket(packet);    }}
4acbbda06f144975fdf68c83c98ae199fd1a88ca35f68431e0601f5c364b175b
getZkState
 ZooKeeper.States getZkState()
{    return state;}
4a993d25e7bd7b311ee60e7b7dc31981ca6134af60f7b3f0fbac8476ca2c571a
getClientCnxnSocket
 ClientCnxnSocket getClientCnxnSocket()
{    return clientCnxnSocket;}
ab2953add36e9cb2dff54edb24ae56cc9091a46f1d6c36894322d395c6a6313c
primeConnection
 void primeConnection() throws IOException
{    LOG.info("Socket connection established, initiating session, client: {}, server: {}", clientCnxnSocket.getLocalSocketAddress(), clientCnxnSocket.getRemoteSocketAddress());    isFirstConnect = false;    long sessId = (seenRwServerBefore) ? sessionId : 0;    ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd);        if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {        List<String> dataWatches = zooKeeper.getDataWatches();        List<String> existWatches = zooKeeper.getExistWatches();        List<String> childWatches = zooKeeper.getChildWatches();        if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty()) {            Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();            Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();            Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();            long setWatchesLastZxid = lastZxid;            while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext()) {                List<String> dataWatchesBatch = new ArrayList<String>();                List<String> existWatchesBatch = new ArrayList<String>();                List<String> childWatchesBatch = new ArrayList<String>();                int batchLength = 0;                                while (batchLength < SET_WATCHES_MAX_LENGTH) {                    final String watch;                    if (dataWatchesIter.hasNext()) {                        watch = dataWatchesIter.next();                        dataWatchesBatch.add(watch);                    } else if (existWatchesIter.hasNext()) {                        watch = existWatchesIter.next();                        existWatchesBatch.add(watch);                    } else if (childWatchesIter.hasNext()) {                        watch = childWatchesIter.next();                        childWatchesBatch.add(watch);                    } else {                        break;                    }                    batchLength += watch.length();                }                SetWatches sw = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);                RequestHeader header = new RequestHeader(-8, OpCode.setWatches);                Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);                outgoingQueue.addFirst(packet);            }        }    }    for (AuthData id : authInfo) {        outgoingQueue.addFirst(new Packet(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, id.scheme, id.data), null, null));    }    outgoingQueue.addFirst(new Packet(null, null, conReq, null, null, readOnly));    clientCnxnSocket.connectionPrimed();    LOG.debug("Session establishment request sent on {}", clientCnxnSocket.getRemoteSocketAddress());}
6000da814d6e25f46974061178530e567e49780b6d919e2fd92eb42f4282a074
prependChroot
private List<String> prependChroot(List<String> paths)
{    if (chrootPath != null && !paths.isEmpty()) {        for (int i = 0; i < paths.size(); ++i) {            String clientPath = paths.get(i);            String serverPath;                        if (clientPath.length() == 1) {                serverPath = chrootPath;            } else {                serverPath = chrootPath + clientPath;            }            paths.set(i, serverPath);        }    }    return paths;}
b2755911a3b8c5ed519e4eb41709e74f2e85ec25ab144ca8ebb7cc3f9811f970
sendPing
private void sendPing()
{    lastPingSentNs = System.nanoTime();    RequestHeader h = new RequestHeader(-2, OpCode.ping);    queuePacket(h, null, null, null, null, null, null, null, null);}
7478a318fcc6b6a27721a30456645bf63ea8d48d46568b21c518cfab9c4d399b
startConnect
private void startConnect(InetSocketAddress addr) throws IOException
{        saslLoginFailed = false;    if (!isFirstConnect) {        try {            Thread.sleep(r.nextInt(1000));        } catch (InterruptedException e) {            LOG.warn("Unexpected exception", e);        }    }    state = States.CONNECTING;    String hostPort = addr.getHostString() + ":" + addr.getPort();    MDC.put("myid", hostPort);    setName(getName().replaceAll("\\(.*\\)", "(" + hostPort + ")"));    if (clientConfig.isSaslClientEnabled()) {        try {            if (zooKeeperSaslClient != null) {                zooKeeperSaslClient.shutdown();            }            zooKeeperSaslClient = new ZooKeeperSaslClient(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);        } catch (LoginException e) {                                                            LOG.warn("SASL configuration failed: " + e + " Will continue connection to Zookeeper server without " + "SASL authentication, if Zookeeper server allows it.");            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            saslLoginFailed = true;        }    }    logStartConnect(addr);    clientCnxnSocket.connect(addr);}
3435defbb960a2052fd70fed169a329cb18f7a9417c6bd2eb8a654b6c4ecfe09
logStartConnect
private void logStartConnect(InetSocketAddress addr)
{    String msg = "Opening socket connection to server " + addr;    if (zooKeeperSaslClient != null) {        msg += ". " + zooKeeperSaslClient.getConfigStatus();    }    LOG.info(msg);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();    int to;    long lastPingRwServer = Time.currentElapsedTime();        final int MAX_SEND_PING_INTERVAL = 10000;    InetSocketAddress serverAddress = null;    while (state.isAlive()) {        try {            if (!clientCnxnSocket.isConnected()) {                                if (closing) {                    break;                }                if (rwServerAddress != null) {                    serverAddress = rwServerAddress;                    rwServerAddress = null;                } else {                    serverAddress = hostProvider.next(1000);                }                startConnect(serverAddress);                clientCnxnSocket.updateLastSendAndHeard();            }            if (state.isConnected()) {                                if (zooKeeperSaslClient != null) {                    boolean sendAuthEvent = false;                    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {                        try {                            zooKeeperSaslClient.initialize(ClientCnxn.this);                        } catch (SaslException e) {                            LOG.error("SASL authentication with Zookeeper Quorum member failed: " + e);                            state = States.AUTH_FAILED;                            sendAuthEvent = true;                        }                    }                    KeeperState authState = zooKeeperSaslClient.getKeeperState();                    if (authState != null) {                        if (authState == KeeperState.AuthFailed) {                                                        state = States.AUTH_FAILED;                            sendAuthEvent = true;                        } else {                            if (authState == KeeperState.SaslAuthenticated) {                                sendAuthEvent = true;                            }                        }                    }                    if (sendAuthEvent) {                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));                        if (state == States.AUTH_FAILED) {                            eventThread.queueEventOfDeath();                        }                    }                }                to = readTimeout - clientCnxnSocket.getIdleRecv();            } else {                to = connectTimeout - clientCnxnSocket.getIdleRecv();            }            if (to <= 0) {                String warnInfo;                warnInfo = "Client session timed out, have not heard from server in " + clientCnxnSocket.getIdleRecv() + "ms" + " for sessionid 0x" + Long.toHexString(sessionId);                LOG.warn(warnInfo);                throw new SessionTimeoutException(warnInfo);            }            if (state.isConnected()) {                                                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);                                if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {                    sendPing();                    clientCnxnSocket.updateLastSend();                } else {                    if (timeToNextPing < to) {                        to = timeToNextPing;                    }                }            }                        if (state == States.CONNECTEDREADONLY) {                long now = Time.currentElapsedTime();                int idlePingRwServer = (int) (now - lastPingRwServer);                if (idlePingRwServer >= pingRwTimeout) {                    lastPingRwServer = now;                    idlePingRwServer = 0;                    pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);                    pingRwServer();                }                to = Math.min(to, pingRwTimeout - idlePingRwServer);            }            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);        } catch (Throwable e) {            if (closing) {                if (LOG.isDebugEnabled()) {                                        LOG.debug("An exception was thrown while closing send thread for session 0x" + Long.toHexString(getSessionId()) + " : " + e.getMessage());                }                break;            } else {                                if (e instanceof SessionExpiredException) {                    LOG.info(e.getMessage() + ", closing socket connection");                } else if (e instanceof SessionTimeoutException) {                    LOG.info(e.getMessage() + RETRY_CONN_MSG);                } else if (e instanceof EndOfStreamException) {                    LOG.info(e.getMessage() + RETRY_CONN_MSG);                } else if (e instanceof RWServerFoundException) {                    LOG.info(e.getMessage());                } else if (e instanceof SocketException) {                    LOG.info("Socket error occurred: {}: {}", serverAddress, e.getMessage());                } else {                    LOG.warn("Session 0x{} for server {}, unexpected error{}", Long.toHexString(getSessionId()), serverAddress, RETRY_CONN_MSG, e);                }                                                cleanAndNotifyState();            }        }    }    synchronized (state) {                        cleanup();    }    clientCnxnSocket.close();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "SendThread exited loop for session: 0x" + Long.toHexString(getSessionId()));}
11e6ab4531ca714becb9b9b3f801133711e05dd9ef96873eb7c09ea62d11f5ae
cleanAndNotifyState
private void cleanAndNotifyState()
{    cleanup();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();}
20d4d6e7d8a78cfcd06bcc2018afbe72e0d8b5fb3a329f3dbba56c6611c94ebc
pingRwServer
private void pingRwServer() throws RWServerFoundException
{    String result = null;    InetSocketAddress addr = hostProvider.next(0);    LOG.info("Checking server " + addr + " for being r/w." + " Timeout " + pingRwTimeout);    Socket sock = null;    BufferedReader br = null;    try {        sock = new Socket(addr.getHostString(), addr.getPort());        sock.setSoLinger(false, -1);        sock.setSoTimeout(1000);        sock.setTcpNoDelay(true);        sock.getOutputStream().write("isro".getBytes());        sock.getOutputStream().flush();        sock.shutdownOutput();        br = new BufferedReader(new InputStreamReader(sock.getInputStream()));        result = br.readLine();    } catch (ConnectException e) {        } catch (IOException e) {                LOG.warn("Exception while seeking for r/w server " + e.getMessage(), e);    } finally {        if (sock != null) {            try {                sock.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }        if (br != null) {            try {                br.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }    if ("rw".equals(result)) {        pingRwTimeout = minPingRwTimeout;                        rwServerAddress = addr;        throw new RWServerFoundException("Majority server found at " + addr.getHostString() + ":" + addr.getPort());    }}
adde398ff6c4ce4aad792f7d68d06704c1e30a6264b5e29ddf5f1f292c47ab33
cleanup
private void cleanup()
{    clientCnxnSocket.cleanup();    synchronized (pendingQueue) {        for (Packet p : pendingQueue) {            conLossPacket(p);        }        pendingQueue.clear();    }                Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        conLossPacket(p);        iter.remove();    }}
5ff672fabe7f195f1466f759d4e7faaa14969c8aaf7565be50dea1012bf3e6eb
onConnected
 void onConnected(int _negotiatedSessionTimeout, long _sessionId, byte[] _sessionPasswd, boolean isRO) throws IOException
{    negotiatedSessionTimeout = _negotiatedSessionTimeout;    if (negotiatedSessionTimeout <= 0) {        state = States.CLOSED;        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));        eventThread.queueEventOfDeath();        String warnInfo;        warnInfo = "Unable to reconnect to ZooKeeper service, session 0x" + Long.toHexString(sessionId) + " has expired";        LOG.warn(warnInfo);        throw new SessionExpiredException(warnInfo);    }    if (!readOnly && isRO) {        LOG.error("Read/write client got connected to read-only server");    }    readTimeout = negotiatedSessionTimeout * 2 / 3;    connectTimeout = negotiatedSessionTimeout / hostProvider.size();    hostProvider.onConnected();    sessionId = _sessionId;    sessionPasswd = _sessionPasswd;    state = (isRO) ? States.CONNECTEDREADONLY : States.CONNECTED;    seenRwServerBefore |= !isRO;    LOG.info("Session establishment complete on server " + clientCnxnSocket.getRemoteSocketAddress() + ", sessionid = 0x" + Long.toHexString(sessionId) + ", negotiated timeout = " + negotiatedSessionTimeout + (isRO ? " (READ-ONLY mode)" : ""));    KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));}
c2864e5a4894768906844a2ddb5f229fc8d93aa73ebb06368e7b1ddbe43efd96
close
 void close()
{    state = States.CLOSED;    clientCnxnSocket.onClosing();}
e222b1b4d8c833d75aeae7274ccfa4b15f5b9c539ca0d2bcea9268100ca1c32d
testableCloseSocket
 void testableCloseSocket() throws IOException
{    clientCnxnSocket.testableCloseSocket();}
df7be2b31c63fc25482ab1f7fb872a63f1a58dc59c73d875859a37ad9593047b
tunnelAuthInProgress
public boolean tunnelAuthInProgress()
{        if (!clientConfig.isSaslClientEnabled()) {        return false;    }        if (saslLoginFailed) {        return false;    }        if (zooKeeperSaslClient == null) {        return true;    }        return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();}
7ee10e5ec4126e2575e910d9b1b57efaddf21cd5fa5f866de4b8365156f284f4
sendPacket
public void sendPacket(Packet p) throws IOException
{    clientCnxnSocket.sendPacket(p);}
0dba3948e03692823445b16cdfa3dd8b6577a858c451983c8276e1dab61136cc
disconnect
public void disconnect()
{    if (LOG.isDebugEnabled()) {        LOG.debug("Disconnecting client for session: 0x" + Long.toHexString(getSessionId()));    }    sendThread.close();    try {        sendThread.join();    } catch (InterruptedException ex) {        LOG.warn("Got interrupted while waiting for the sender thread to close", ex);    }    eventThread.queueEventOfDeath();    if (zooKeeperSaslClient != null) {        zooKeeperSaslClient.shutdown();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (LOG.isDebugEnabled()) {        LOG.debug("Closing client for session: 0x" + Long.toHexString(getSessionId()));    }    try {        RequestHeader h = new RequestHeader();        h.setType(ZooDefs.OpCode.closeSession);        submitRequest(h, null, null, null);    } catch (InterruptedException e) {        } finally {        disconnect();    }}
f26dd81f26a012e08474dbd00625faf939a698deb3164ba738966398951a6520
getXid
public synchronized int getXid()
{        if (xid == Integer.MAX_VALUE) {        xid = 1;    }    return xid++;}
0819b834e6ffe53dee0b345d3f1b9bb49aba2ec36034a5b6cc7e084f7a7e8b3b
submitRequest
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return submitRequest(h, request, response, watchRegistration, null);}
c851da47303d6c94027ff9b007f12eafff3de7b5c69cfc9382a5062bd42b137b
submitRequest
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration) throws InterruptedException
{    ReplyHeader r = new ReplyHeader();    Packet packet = queuePacket(h, r, request, response, null, null, null, null, watchRegistration, watchDeregistration);    synchronized (packet) {        if (requestTimeout > 0) {                        waitForPacketFinish(r, packet);        } else {                        while (!packet.finished) {                packet.wait();            }        }    }    if (r.getErr() == Code.REQUESTTIMEOUT.intValue()) {        sendThread.cleanAndNotifyState();    }    return r;}
e1060cd4b9c3e4216e48660807ca457db7a9418fc86f67cf64300960f9618ebb
waitForPacketFinish
private void waitForPacketFinish(ReplyHeader r, Packet packet) throws InterruptedException
{    long waitStartTime = Time.currentElapsedTime();    while (!packet.finished) {        packet.wait(requestTimeout);        if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {            LOG.error("Timeout error occurred for the packet '{}'.", packet);            r.setErr(Code.REQUESTTIMEOUT.intValue());            break;        }    }}
66f1c5c1c96260c3ea309fae3f6b14ff9af2aa30648e8ced62bac96bd7df99dc
saslCompleted
public void saslCompleted()
{    sendThread.getClientCnxnSocket().saslCompleted();}
dbea8e2e2dc77cdcdc8c13abf2a4e197c395eef603216c93daee0a1d385f234c
sendPacket
public void sendPacket(Record request, Record response, AsyncCallback cb, int opCode) throws IOException
{            int xid = getXid();    RequestHeader h = new RequestHeader();    h.setXid(xid);    h.setType(opCode);    ReplyHeader r = new ReplyHeader();    r.setXid(xid);    Packet p = new Packet(h, r, request, response, null, false);    p.cb = cb;    sendThread.sendPacket(p);}
e52298abefebaa4920bab9e928308f1c4aafa1deb594b18dc8b287a980fb9d43
queuePacket
public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration)
{    return queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, watchRegistration, null);}
6efc304bfbce5fb730b6abb07f4bca3f639b29557f6855d35b1234b5ab3fe692
queuePacket
public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration)
{    Packet packet = null;                packet = new Packet(h, r, request, response, watchRegistration);    packet.cb = cb;    packet.ctx = ctx;    packet.clientPath = clientPath;    packet.serverPath = serverPath;    packet.watchDeregistration = watchDeregistration;        synchronized (state) {        if (!state.isAlive() || closing) {            conLossPacket(packet);        } else {                        if (h.getType() == OpCode.closeSession) {                closing = true;            }            outgoingQueue.add(packet);        }    }    sendThread.getClientCnxnSocket().packetAdded();    return packet;}
1d08df4181b86f11812fd75c46b00e31a77c03804d14cfd9fae13865e8302bad
addAuthInfo
public void addAuthInfo(String scheme, byte[] auth)
{    if (!state.isAlive()) {        return;    }    authInfo.add(new AuthData(scheme, auth));    queuePacket(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, scheme, auth), null, null, null, null, null, null);}
eff336eba8fc52669211eaddb2600a9f6d24bedfdb8a7edcc837396f6f7e41f1
getState
 States getState()
{    return state;}
7dbf883fc2e641ae69178c3c8d4dadfecd40daa97cf7b8936482de8275a0efb7
initRequestTimeout
private void initRequestTimeout()
{    try {        requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);        LOG.info("{} value is {}. feature enabled={}", ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, requestTimeout, requestTimeout > 0);    } catch (NumberFormatException e) {        LOG.error("Configured value {} for property {} can not be parsed to long.", clientConfig.getProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT), ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT);        throw e;    }}
acab7c13a6297ff840efaf7c193eb5115e10617baf468bf9dc2d3d7aa8de2b9d
introduce
 void introduce(ClientCnxn.SendThread sendThread, long sessionId, LinkedBlockingDeque<Packet> outgoingQueue)
{    this.sendThread = sendThread;    this.sessionId = sessionId;    this.outgoingQueue = outgoingQueue;}
da15f704ef9767c3c7b982eff0693b81df615b6148341d13f5dd8a34bb9b10a2
updateNow
 void updateNow()
{    now = Time.currentElapsedTime();}
8c1ebf569dc76f6b2a6858016bc55ccf74b8e23d5a728575c91604423eff656a
getIdleRecv
 int getIdleRecv()
{    return (int) (now - lastHeard);}
9d51678a2284adeb78692d7db445c99bd6ef0934287cbb4d5ee34db5adc70b4b
getIdleSend
 int getIdleSend()
{    return (int) (now - lastSend);}
22fac634cc388b5b49cc1753606c957d6ebfae2d61fc292e0c8a675d4f49be12
getSentCount
 long getSentCount()
{    return sentCount.get();}
dce02ab84e418d41526776c74e05c83597ba1e8f3db5c39250e9f8be05b337fb
getRecvCount
 long getRecvCount()
{    return recvCount.get();}
7c18bc2aa1306bb3a025fa46f5aa409e5eb83276a89d9177f796e472cc8e167d
updateLastHeard
 void updateLastHeard()
{    this.lastHeard = now;}
be04da5c26edeb7b2011bf6a28c9fd453eb1caed62ae06db33315c8c95b13591
updateLastSend
 void updateLastSend()
{    this.lastSend = now;}
da7bb9090d8ee3f96886d3de88bb81b4cc25a49be8efc4b16f3e48ff6e88804d
updateLastSendAndHeard
 void updateLastSendAndHeard()
{    this.lastSend = now;    this.lastHeard = now;}
ef4a22a2ec1fbc5b2dfc5db1920e490c990b767e48a5081075afcd49f7072b4d
readLength
 void readLength() throws IOException
{    int len = incomingBuffer.getInt();    if (len < 0 || len >= packetLen) {        throw new IOException("Packet len " + len + " is out of range!");    }    incomingBuffer = ByteBuffer.allocate(len);}
61ae899ca8a2738477a42c3f37058170d12d51158f6beccd5b0ef6dd31c1c9a9
readConnectResult
 void readConnectResult() throws IOException
{    if (LOG.isTraceEnabled()) {        StringBuilder buf = new StringBuilder("0x[");        for (byte b : incomingBuffer.array()) {            buf.append(Integer.toHexString(b) + ",");        }        buf.append("]");        LOG.trace("readConnectResult " + incomingBuffer.remaining() + " " + buf.toString());    }    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);    ConnectResponse conRsp = new ConnectResponse();    conRsp.deserialize(bbia, "connect");        boolean isRO = false;    try {        isRO = bbia.readBool("readOnly");    } catch (IOException e) {                        LOG.warn("Connected to an old server; r-o mode will be unavailable");    }    this.sessionId = conRsp.getSessionId();    sendThread.onConnected(conRsp.getTimeOut(), this.sessionId, conRsp.getPasswd(), isRO);}
7d5e7eed10a86ed3ef79a778792c301856211dffef96b0a7f3a32a471f29578d
initProperties
protected void initProperties() throws IOException
{    try {        packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);        LOG.info("{} value is {} Bytes", ZKConfig.JUTE_MAXBUFFER, packetLen);    } catch (NumberFormatException e) {        String msg = MessageFormat.format("Configured value {0} for property {1} can not be parsed to int", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);        LOG.error(msg);        throw new IOException(msg);    }}
948edbe148994f96d54dcdf5b1390c3efec5c913cf45924e28f12c1995a49bff
isConnected
 boolean isConnected()
{            connectLock.lock();    try {        return channel != null || connectFuture != null;    } finally {        connectLock.unlock();    }}
eebcc8895206bc11878bc626b00b86506c804eba1856187895b11610f67d158b
configureBootstrapAllocator
private Bootstrap configureBootstrapAllocator(Bootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
4ed24053357a1f3fd8485c609cfe975cf7f3a9ff37e4963a8fee97c977b815d2
connect
 void connect(InetSocketAddress addr) throws IOException
{    firstConnect = new CountDownLatch(1);    Bootstrap bootstrap = new Bootstrap().group(eventLoopGroup).channel(NettyUtils.nioOrEpollSocketChannel()).option(ChannelOption.SO_LINGER, -1).option(ChannelOption.TCP_NODELAY, true).handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));    bootstrap = configureBootstrapAllocator(bootstrap);    bootstrap.validate();    connectLock.lock();    try {        connectFuture = bootstrap.connect(addr);        connectFuture.addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception {                                boolean connected = false;                connectLock.lock();                try {                    if (!channelFuture.isSuccess()) {                        LOG.info("future isn't success, cause:", channelFuture.cause());                        return;                    } else if (connectFuture == null) {                        LOG.info("connect attempt cancelled");                                                                                                channelFuture.channel().close();                        return;                    }                                        channel = channelFuture.channel();                    disconnected.set(false);                    initialized = false;                    lenBuffer.clear();                    incomingBuffer = lenBuffer;                    sendThread.primeConnection();                    updateNow();                    updateLastSendAndHeard();                    if (sendThread.tunnelAuthInProgress()) {                        waitSasl.drainPermits();                        needSasl.set(true);                        sendPrimePacket();                    } else {                        needSasl.set(false);                    }                    connected = true;                } finally {                    connectFuture = null;                    connectLock.unlock();                    if (connected) {                        LOG.info("channel is connected: {}", channelFuture.channel());                    }                                                                                wakeupCnxn();                    firstConnect.countDown();                }            }        });    } finally {        connectLock.unlock();    }}
215623848f4d519ddf07a1fe02bd9f68c99259e4bb387c4a63b4279897d06c3a
operationComplete
public void operationComplete(ChannelFuture channelFuture) throws Exception
{        boolean connected = false;    connectLock.lock();    try {        if (!channelFuture.isSuccess()) {            LOG.info("future isn't success, cause:", channelFuture.cause());            return;        } else if (connectFuture == null) {            LOG.info("connect attempt cancelled");                                                channelFuture.channel().close();            return;        }                channel = channelFuture.channel();        disconnected.set(false);        initialized = false;        lenBuffer.clear();        incomingBuffer = lenBuffer;        sendThread.primeConnection();        updateNow();        updateLastSendAndHeard();        if (sendThread.tunnelAuthInProgress()) {            waitSasl.drainPermits();            needSasl.set(true);            sendPrimePacket();        } else {            needSasl.set(false);        }        connected = true;    } finally {        connectFuture = null;        connectLock.unlock();        if (connected) {            LOG.info("channel is connected: {}", channelFuture.channel());        }                                wakeupCnxn();        firstConnect.countDown();    }}
1f4886bd93247c7f75188a0d1bc6d5d45e9c3a06c609f0ca837af90fcafeea14
cleanup
 void cleanup()
{    connectLock.lock();    try {        if (connectFuture != null) {            connectFuture.cancel(false);            connectFuture = null;        }        if (channel != null) {            channel.close().syncUninterruptibly();            channel = null;        }    } finally {        connectLock.unlock();    }    Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p == WakeupPacket.getInstance()) {            iter.remove();        }    }}
c2864e5a4894768906844a2ddb5f229fc8d93aa73ebb06368e7b1ddbe43efd96
close
 void close()
{    eventLoopGroup.shutdownGracefully();}
ef27900297273107f3646527f4493c347841c0c5c18914c5cc3309e477e1344b
saslCompleted
 void saslCompleted()
{    needSasl.set(false);    waitSasl.release();}
b967fec05a1a49a7560ad87b3ef691d7de0e6e37dd323b4d85fbe7e9877fe213
connectionPrimed
 void connectionPrimed()
{}
75bf485e16c219e852106834984f7a7c7a97e4502394231c0758f2cd17657a46
packetAdded
 void packetAdded()
{}
77b3506abbc5c59e084abed1428bd21bd7bdaeaee078712f3d3a443981d756ea
onClosing
 void onClosing()
{    firstConnect.countDown();    wakeupCnxn();    LOG.info("channel is told closing");}
4df4c8f745b8bd45f7ef4ca14c275e486d64fcc879cd19b837ac243e6b355166
wakeupCnxn
private void wakeupCnxn()
{    if (needSasl.get()) {        waitSasl.release();    }    outgoingQueue.add(WakeupPacket.getInstance());}
cb56bb141c617c0edddbec7117532b2990cf127074efa40f9810369b5ceb916e
doTransport
 void doTransport(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    try {        if (!firstConnect.await(waitTimeOut, TimeUnit.MILLISECONDS)) {            return;        }        Packet head = null;        if (needSasl.get()) {            if (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) {                return;            }        } else {            head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS);        }                if (!sendThread.getZkState().isAlive()) {                        addBack(head);            return;        }                if (disconnected.get()) {            addBack(head);            throw new EndOfStreamException("channel for sessionid 0x" + Long.toHexString(sessionId) + " is lost");        }        if (head != null) {            doWrite(pendingQueue, head, cnxn);        }    } finally {        updateNow();    }}
ae4ffc3be4418c644792feda568946f4830a5b2d68e23b5157b9d9c6c18a934b
addBack
private void addBack(Packet head)
{    if (head != null && head != WakeupPacket.getInstance()) {        outgoingQueue.addFirst(head);    }}
ff81b4713f641285497c93fa00d34b870b55d8691946692385d034427f881d5a
sendPktAndFlush
private ChannelFuture sendPktAndFlush(Packet p)
{    return sendPkt(p, true);}
451f40ab11002e044619fe804be0d8db56d67b0d53dc8a455ff611f0f8fffcf0
sendPktOnly
private ChannelFuture sendPktOnly(Packet p)
{    return sendPkt(p, false);}
b7632a67ec88251e9e700b1e1887640a0dd26af0ec914b956dde9acfee8a5c22
sendPkt
private ChannelFuture sendPkt(Packet p, boolean doFlush)
{            p.createBB();    updateLastSend();    final ByteBuf writeBuffer = Unpooled.wrappedBuffer(p.bb);    final ChannelFuture result = doFlush ? channel.writeAndFlush(writeBuffer) : channel.write(writeBuffer);    result.addListener(onSendPktDoneListener);    return result;}
bab783d325937062c8aca11c7ce851c92723b67bdc275ddcec29a53002364934
sendPrimePacket
private void sendPrimePacket()
{        sendPktAndFlush(outgoingQueue.remove());}
a320aab2ad3fb7ba743107eaa111a5df9cb7d869226a4a9e5651c1d7be006ca4
doWrite
private void doWrite(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn)
{    updateNow();    boolean anyPacketsSent = false;    while (true) {        if (p != WakeupPacket.getInstance()) {            if ((p.requestHeader != null) && (p.requestHeader.getType() != ZooDefs.OpCode.ping) && (p.requestHeader.getType() != ZooDefs.OpCode.auth)) {                p.requestHeader.setXid(cnxn.getXid());                synchronized (pendingQueue) {                    pendingQueue.add(p);                }            }            sendPktOnly(p);            anyPacketsSent = true;        }        if (outgoingQueue.isEmpty()) {            break;        }        p = outgoingQueue.remove();    }        if (anyPacketsSent) {        channel.flush();    }}
5ba8843a30c3ecaef27c8fd45ca69bf563ebf47e8c358fe5effa8530390df698
sendPacket
 void sendPacket(ClientCnxn.Packet p) throws IOException
{    if (channel == null) {        throw new IOException("channel has been closed");    }    sendPktAndFlush(p);}
160394d23c8871cb2a23f8675e060b5697a6e79a629b1b310fdd8728c66b379c
getRemoteSocketAddress
 SocketAddress getRemoteSocketAddress()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.remoteAddress();}
a4f9ba55f55a3f76c0292fd530805a0331bfd08e0cfb202fa990989d8aeb5c3d
getLocalSocketAddress
 SocketAddress getLocalSocketAddress()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.localAddress();}
e222b1b4d8c833d75aeae7274ccfa4b15f5b9c539ca0d2bcea9268100ca1c32d
testableCloseSocket
 void testableCloseSocket() throws IOException
{    Channel copiedChanRef = channel;    if (copiedChanRef != null) {        copiedChanRef.disconnect().awaitUninterruptibly();    }}
6823c651298d777fb0de196d09436776f41298b1672fa224caa0ac6e1a11c0f2
getInstance
public static Packet getInstance()
{    return instance;}
bf534bb6a81e7653e772b45c660728e2ed8223b7f5c2fff9135bce2f0188c348
initChannel
protected void initChannel(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (clientConfig.getBoolean(ZKClientConfig.SECURE_CLIENT)) {        initSSL(pipeline);    }    pipeline.addLast("handler", new ZKClientHandler());}
e3c7dd645d1b5c197c770bd82aa03329506f86c2d83af813aa6854ae87a30bb4
initSSL
private synchronized void initSSL(ChannelPipeline pipeline) throws SSLContextException
{    if (sslContext == null || sslEngine == null) {        try (X509Util x509Util = new ClientX509Util()) {            sslContext = x509Util.createSSLContext(clientConfig);            sslEngine = sslContext.createSSLEngine(host, port);            sslEngine.setUseClientMode(true);        }    }    pipeline.addLast("ssl", new SslHandler(sslEngine));    LOG.info("SSL handler added for channel: {}", pipeline.channel());}
e3eadf870c8542dd216e415c3864eae1ce862e9b121c0701edbae3d151354ffe
channelInactive
public void channelInactive(ChannelHandlerContext ctx) throws Exception
{    LOG.info("channel is disconnected: {}", ctx.channel());    cleanup();}
adde398ff6c4ce4aad792f7d68d06704c1e30a6264b5e29ddf5f1f292c47ab33
cleanup
private void cleanup()
{    if (!channelClosed.compareAndSet(false, true)) {        return;    }    disconnected.set(true);    onClosing();}
279f8f97113e6f3a1e415cbee50f3ec89f154b8958402c7fb502ae3e9a664f2f
channelRead0
protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception
{    updateNow();    while (buf.isReadable()) {        if (incomingBuffer.remaining() > buf.readableBytes()) {            int newLimit = incomingBuffer.position() + buf.readableBytes();            incomingBuffer.limit(newLimit);        }        buf.readBytes(incomingBuffer);        incomingBuffer.limit(incomingBuffer.capacity());        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                lenBuffer.clear();                incomingBuffer = lenBuffer;                initialized = true;                updateLastHeard();            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    wakeupCnxn();}
d4714f48e5f66cb089afd789b7c0141f7feb706e2de57a936e8137f8074d34b6
exceptionCaught
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
{    LOG.warn("Exception caught", cause);    cleanup();}
0d9c0f399c900b7236b52940d5b335b825ff87ece1ae8202a1181a0b5e35f181
setTestAllocator
 static void setTestAllocator(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
5c396ec4a4c0e018e2e1defd5f584ce3159d17fea2b63dea6b82a57c597daa54
clearTestAllocator
 static void clearTestAllocator()
{    TEST_ALLOCATOR.set(null);}
948edbe148994f96d54dcdf5b1390c3efec5c913cf45924e28f12c1995a49bff
isConnected
 boolean isConnected()
{    return sockKey != null;}
dd64d9e48082d96ba103214e53983341518cd22bcf8a467a9f114fadf5c10c55
doIO
 void doIO(Queue<Packet> pendingQueue, ClientCnxn cnxn) throws InterruptedException, IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    if (sockKey.isReadable()) {        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new EndOfStreamException("Unable to read additional data from server sessionid 0x" + Long.toHexString(sessionId) + ", likely server has closed socket");        }        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                enableRead();                if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {                                                            enableWrite();                }                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();                initialized = true;            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    if (sockKey.isWritable()) {        Packet p = findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress());        if (p != null) {            updateLastSend();                        if (p.bb == null) {                if ((p.requestHeader != null) && (p.requestHeader.getType() != OpCode.ping) && (p.requestHeader.getType() != OpCode.auth)) {                    p.requestHeader.setXid(cnxn.getXid());                }                p.createBB();            }            sock.write(p.bb);            if (!p.bb.hasRemaining()) {                sentCount.getAndIncrement();                outgoingQueue.removeFirstOccurrence(p);                if (p.requestHeader != null && p.requestHeader.getType() != OpCode.ping && p.requestHeader.getType() != OpCode.auth) {                    synchronized (pendingQueue) {                        pendingQueue.add(p);                    }                }            }        }        if (outgoingQueue.isEmpty()) {                                                                        disableWrite();        } else if (!initialized && p != null && !p.bb.hasRemaining()) {                                                                                                                        disableWrite();        } else {                        enableWrite();        }    }}
27268353c5da7db8ccd9bcac459c19c0cd9e3f5b2f52d762d3203ffef61d56ff
findSendablePacket
private Packet findSendablePacket(LinkedBlockingDeque<Packet> outgoingQueue, boolean tunneledAuthInProgres)
{    if (outgoingQueue.isEmpty()) {        return null;    }        if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {        return outgoingQueue.getFirst();    }                        Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p.requestHeader == null) {                        iter.remove();            outgoingQueue.addFirst(p);            return p;        } else {                                    LOG.debug("deferring non-priming packet {} until SASL authentation completes.", p);        }    }    return null;}
1f4886bd93247c7f75188a0d1bc6d5d45e9c3a06c609f0ca837af90fcafeea14
cleanup
 void cleanup()
{    if (sockKey != null) {        SocketChannel sock = (SocketChannel) sockKey.channel();        sockKey.cancel();        try {            sock.socket().shutdownInput();        } catch (IOException e) {            LOG.debug("Ignoring exception during shutdown input", e);        }        try {            sock.socket().shutdownOutput();        } catch (IOException e) {            LOG.debug("Ignoring exception during shutdown output", e);        }        try {            sock.socket().close();        } catch (IOException e) {            LOG.debug("Ignoring exception during socket close", e);        }        try {            sock.close();        } catch (IOException e) {            LOG.debug("Ignoring exception during channel close", e);        }    }    try {        Thread.sleep(100);    } catch (InterruptedException e) {        LOG.debug("SendThread interrupted during sleep, ignoring");    }    sockKey = null;}
c2864e5a4894768906844a2ddb5f229fc8d93aa73ebb06368e7b1ddbe43efd96
close
 void close()
{    try {        LOG.trace("Doing client selector close");        selector.close();        LOG.trace("Closed client selector");    } catch (IOException e) {        LOG.warn("Ignoring exception during selector close", e);    }}
f3523ab9623c0d0addfc2c87aeee284af59fdc940364dc665c967ddee7e1adab
createSock
 SocketChannel createSock() throws IOException
{    SocketChannel sock;    sock = SocketChannel.open();    sock.configureBlocking(false);    sock.socket().setSoLinger(false, -1);    sock.socket().setTcpNoDelay(true);    return sock;}
c18347905b35d655641536eb82070d5136fcca62a1ee97dbb30a27d0db56d569
registerAndConnect
 void registerAndConnect(SocketChannel sock, InetSocketAddress addr) throws IOException
{    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);    boolean immediateConnect = sock.connect(addr);    if (immediateConnect) {        sendThread.primeConnection();    }}
4ed24053357a1f3fd8485c609cfe975cf7f3a9ff37e4963a8fee97c977b815d2
connect
 void connect(InetSocketAddress addr) throws IOException
{    SocketChannel sock = createSock();    try {        registerAndConnect(sock, addr);    } catch (IOException e) {        LOG.error("Unable to open socket to " + addr);        sock.close();        throw e;    }    initialized = false;    /*         * Reset incomingBuffer         */    lenBuffer.clear();    incomingBuffer = lenBuffer;}
160394d23c8871cb2a23f8675e060b5697a6e79a629b1b310fdd8728c66b379c
getRemoteSocketAddress
 SocketAddress getRemoteSocketAddress()
{    return remoteSocketAddress;}
a4f9ba55f55a3f76c0292fd530805a0331bfd08e0cfb202fa990989d8aeb5c3d
getLocalSocketAddress
 SocketAddress getLocalSocketAddress()
{    return localSocketAddress;}
3d9eebcba4205689cee7f24065133ff6e11734cdb927fb6277874f8b8a2552b0
updateSocketAddresses
private void updateSocketAddresses()
{    Socket socket = ((SocketChannel) sockKey.channel()).socket();    localSocketAddress = socket.getLocalSocketAddress();    remoteSocketAddress = socket.getRemoteSocketAddress();}
75bf485e16c219e852106834984f7a7c7a97e4502394231c0758f2cd17657a46
packetAdded
 void packetAdded()
{    wakeupCnxn();}
77b3506abbc5c59e084abed1428bd21bd7bdaeaee078712f3d3a443981d756ea
onClosing
 void onClosing()
{    wakeupCnxn();}
612cb636739b7ee2c4aee72df9b4ee9caa302f84cf3d3e9a87ea3a1b06d71477
wakeupCnxn
private synchronized void wakeupCnxn()
{    selector.wakeup();}
cb56bb141c617c0edddbec7117532b2990cf127074efa40f9810369b5ceb916e
doTransport
 void doTransport(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    selector.select(waitTimeOut);    Set<SelectionKey> selected;    synchronized (this) {        selected = selector.selectedKeys();    }                updateNow();    for (SelectionKey k : selected) {        SocketChannel sc = ((SocketChannel) k.channel());        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {            if (sc.finishConnect()) {                updateLastSendAndHeard();                updateSocketAddresses();                sendThread.primeConnection();            }        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {            doIO(pendingQueue, cnxn);        }    }    if (sendThread.getZkState().isConnected()) {        if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {            enableWrite();        }    }    selected.clear();}
e222b1b4d8c833d75aeae7274ccfa4b15f5b9c539ca0d2bcea9268100ca1c32d
testableCloseSocket
 void testableCloseSocket() throws IOException
{    LOG.info("testableCloseSocket() called");            SelectionKey tmp = sockKey;    if (tmp != null) {        ((SocketChannel) tmp.channel()).socket().close();    }}
ef27900297273107f3646527f4493c347841c0c5c18914c5cc3309e477e1344b
saslCompleted
 void saslCompleted()
{    enableWrite();}
74a41002f4e41365090c3d7b376b547952b06de7bab59dc4593f2bfc530fcb07
enableWrite
 synchronized void enableWrite()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) == 0) {        sockKey.interestOps(i | SelectionKey.OP_WRITE);    }}
0664a3ade956e9ad122682e8fa53aa99e9289f1ebdef52977687f8d0da8be1f8
disableWrite
private synchronized void disableWrite()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) != 0) {        sockKey.interestOps(i & (~SelectionKey.OP_WRITE));    }}
16ea7c9b30fd4c38203db3a1d24e59e746b32b55c529c3939a6a69a06b1a8bd9
enableRead
private synchronized void enableRead()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_READ) == 0) {        sockKey.interestOps(i | SelectionKey.OP_READ);    }}
b967fec05a1a49a7560ad87b3ef691d7de0e6e37dd323b4d85fbe7e9877fe213
connectionPrimed
 void connectionPrimed()
{    sockKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);}
baa4a9ff4a9c5fd6c27b0614284a5b727da628c2521c7e35d60c5d278f9d4ac0
getSelector
 Selector getSelector()
{    return selector;}
c049eb56c415d2f2bf71f04bcfdbfb9729c7c708bad2f2047ab1c5cda425522a
sendPacket
 void sendPacket(Packet p) throws IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    p.createBB();    ByteBuffer pbb = p.bb;    sock.write(pbb);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    out.write(b, off, len);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    boolean triedToClose = false, success = false;    try {        flush();        ((FileOutputStream) out).getFD().sync();        triedToClose = true;        super.close();        success = true;    } finally {        if (success) {            boolean renamed = tmpFile.renameTo(origFile);            if (!renamed) {                                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {                    throw new IOException("Could not rename temporary file " + tmpFile + " to " + origFile);                }            }        } else {            if (!triedToClose) {                                                IOUtils.closeStream(out);            }                        if (!tmpFile.delete()) {                LOG.warn("Unable to delete tmp file " + tmpFile);            }        }    }}
3e358ad1af3bc094e9ab9032d0b197aa5a53c6ad6f957f70b34e63afb16ed540
abort
public void abort()
{    try {        super.close();    } catch (IOException ioe) {        LOG.warn("Unable to abort file " + tmpFile, ioe);    }    if (!tmpFile.delete()) {        LOG.warn("Unable to delete tmp file during abort " + tmpFile);    }}
03ad1ee830541f5a5c9c609557a3a4b50f83e3d5dbb8382a287a4c1ff56dcc05
getConfigPrefix
protected String getConfigPrefix()
{    return "zookeeper.ssl.";}
d752bdd02f88e39a195097e3fb5590629ec944a5a879c36cfee84d2f47905f23
shouldVerifyClientHostname
protected boolean shouldVerifyClientHostname()
{    return false;}
69765cb2ee87cd500f82000ddffab985868572b3263ab47f64e77bf47c078cba
getSslAuthProviderProperty
public String getSslAuthProviderProperty()
{    return sslAuthProviderProperty;}
964f651b2d32afcd6e4b2c18ca5f0c709c757a772f0b1e365f804dace720b6da
getState
public synchronized State getState()
{    return state;}
0c2f727a26f77afb2c54ca9d85c5b893a3b4f17f66339794d05244c630ed0bd7
waitForState
 synchronized void waitForState(State desiredState) throws InterruptedException
{    while (this.state != desiredState) {        this.wait();    }}
f94c4af29625d887e2f4fdd40af9272f2fbc7defa4c1f5004e1aeeca7adecacf
setState
private synchronized void setState(State newState)
{    state = newState;    this.notifyAll();}
3fcdc4b17b29a5d88fc465be0d97f5f5f9050b2c313dee5391ef4dcfed45aedc
compareAndSetState
private synchronized boolean compareAndSetState(State expected, State update)
{    if (state == expected) {        setState(update);        return true;    } else {        return false;    }}
5730bc1294bc91e15a1700a40564ae85c9d38f94f6fd7075a4074a4da681f8a8
compareAndSetState
private synchronized boolean compareAndSetState(State[] expectedStates, State update)
{    for (State expected : expectedStates) {        if (state == expected) {            setState(update);            return true;        }    }    return false;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (!compareAndSetState(State.NEW, State.STARTING)) {                return;    }    this.watcherThread.start();}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    if (compareAndSetState(new State[] { State.RUNNING, State.STARTING }, State.STOPPING)) {        watcherThread.interrupt();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        LOG.info(getName() + " thread started");        if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {                                    FileChangeWatcher.State state = FileChangeWatcher.this.getState();            if (state != FileChangeWatcher.State.STOPPING) {                throw new IllegalStateException("Unexpected state: " + state);            }            return;        }        runLoop();    } catch (Exception e) {        LOG.warn("Error in runLoop()", e);        throw e;    } finally {        try {            watchService.close();        } catch (IOException e) {            LOG.warn("Error closing watch service", e);        }        LOG.info(getName() + " thread finished");        FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);    }}
4bad449a7cb9e0e24665d851cc68ed14f1474e6099c92ad1b4d0b02dcc803a83
runLoop
private void runLoop()
{    while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {        WatchKey key;        try {            key = watchService.take();        } catch (InterruptedException | ClosedWatchServiceException e) {            LOG.debug("{} was interrupted and is shutting down...", getName());            break;        }        for (WatchEvent<?> event : key.pollEvents()) {            LOG.debug("Got file changed event: {} with context: {}", event.kind(), event.context());            try {                callback.accept(event);            } catch (Throwable e) {                LOG.error("Error from callback", e);            }        }        boolean isKeyValid = key.reset();        if (!isKeyValid) {                                                            LOG.error("Watch key no longer valid, maybe the directory is inaccessible?");            break;        }    }}
fb6383b38051de989ff94762731027034f81dcde3bc7fc123ff3e4d0b934cce5
setKeyStorePath
 Builder<T> setKeyStorePath(String keyStorePath)
{    this.keyStorePath = Objects.requireNonNull(keyStorePath);    return this;}
42278116714867d764eb10b6ea266910cc8f33cfce400464b195cc769c780815
setTrustStorePath
 Builder<T> setTrustStorePath(String trustStorePath)
{    this.trustStorePath = Objects.requireNonNull(trustStorePath);    return this;}
c83fcc0ae23da061e2d255c20ff57f1f88133df1d4121f593de273145aaba06a
setKeyStorePassword
 Builder<T> setKeyStorePassword(String keyStorePassword)
{    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);    return this;}
21ce9b1f6055fce512acf838b2ec844dd3e08ddc2f3103072c6b3954bcb69a5c
setTrustStorePassword
 Builder<T> setTrustStorePassword(String trustStorePassword)
{    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);    return this;}
6d0c2c08e66656a6879fcc2188b7a52c0ed5f1097af6e31a5757c1e47ed16b61
getBuilderForKeyStoreFileType
 static FileKeyStoreLoader.Builder<? extends FileKeyStoreLoader> getBuilderForKeyStoreFileType(KeyStoreFileType type)
{    switch(Objects.requireNonNull(type)) {        case JKS:            return new JKSFileLoader.Builder();        case PEM:            return new PEMFileLoader.Builder();        case PKCS12:            return new PKCS12FileLoader.Builder();        default:            throw new AssertionError("Unexpected StoreFileType: " + type.name());    }}
78ac05241e292b8de032f03d320268b9cba479ccf8c4b0d5fe2e978f86c022c1
closeStream
public static void closeStream(Closeable stream)
{    cleanup(null, stream);}
1ea131baaeca50fcda51ea1736611e7cf451601029c50a78b57b0e257a94ee9a
cleanup
public static void cleanup(Logger log, Closeable... closeables)
{    for (Closeable c : closeables) {        if (c != null) {            try {                c.close();            } catch (IOException e) {                if (log != null) {                    log.warn("Exception in closing " + c, e);                }            }        }    }}
b65df3a3d18bb3a2acb07b166530873445aaaad5c4f13fdc9c22110ff09a16b1
copyBytes
public static void copyBytes(InputStream in, OutputStream out, int buffSize, boolean close) throws IOException
{    try {        copyBytes(in, out, buffSize);        if (close) {            out.close();            out = null;            in.close();            in = null;        }    } finally {        if (close) {            closeStream(out);            closeStream(in);        }    }}
adcc85913dfcd5fbf8d82e12f63ffb170daedc4419363405c71ee0bf400dfed9
copyBytes
public static void copyBytes(InputStream in, OutputStream out, int buffSize) throws IOException
{    PrintStream ps = out instanceof PrintStream ? (PrintStream) out : null;    byte[] buf = new byte[buffSize];    int bytesRead = in.read(buf);    while (bytesRead >= 0) {        out.write(buf, 0, bytesRead);        if ((ps != null) && ps.checkError()) {            throw new IOException("Unable to write to output stream.");        }        bytesRead = in.read(buf);    }}
915d17b6428a9402548e0e747ebc68c568fed1d4b02df2db2f4f72fbac829783
keyStoreInstance
protected KeyStore keyStoreInstance() throws KeyStoreException
{    return KeyStore.getInstance("JKS");}
3a396873cf314d274c073acda846f2d6944bb81729832b56876bf76c7a6250ca
build
 JKSFileLoader build()
{    return new JKSFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
1706afc620357173dd9a4240c4f68d0e90fd15d6b662207a0d2e14f0e1071184
getPropertyValue
public String getPropertyValue()
{    return this.name();}
694abb0ce1184f18100863bf7308c39884a236ece45c477897817e2def4faa74
getDefaultFileExtension
public String getDefaultFileExtension()
{    return defaultFileExtension;}
6ebb3afa2f18c348f45349d0b90b503cf2ae497cb3230930f4b4dd3b17a4ed0f
fromPropertyValue
public static KeyStoreFileType fromPropertyValue(String propertyValue)
{    if (propertyValue == null || propertyValue.length() == 0) {        return null;    }    return KeyStoreFileType.valueOf(propertyValue.toUpperCase());}
86cabe6e2c10a9af868a5148ff49458ef26910d8d99a3c3fb681ea676bcec8ff
fromFilename
public static KeyStoreFileType fromFilename(String filename)
{    int i = filename.lastIndexOf('.');    if (i >= 0) {        String extension = filename.substring(i);        for (KeyStoreFileType storeFileType : KeyStoreFileType.values()) {            if (storeFileType.getDefaultFileExtension().equals(extension)) {                return storeFileType;            }        }    }    throw new IllegalArgumentException("Unable to auto-detect store file type from file name: " + filename);}
cf013d0208f4904d33966dea67d20d0005d6dd991991233c0bc9c3edea70a9dd
fromPropertyValueOrFileName
public static KeyStoreFileType fromPropertyValueOrFileName(String propertyValue, String filename)
{    KeyStoreFileType result = KeyStoreFileType.fromPropertyValue(propertyValue);    if (result == null) {        result = KeyStoreFileType.fromFilename(filename);    }    return result;}
9812a43d52a3a3d772086b31db830ee0745664ffd73ce5d56bd7bea72de5e73f
newNioOrEpollEventLoopGroup
public static EventLoopGroup newNioOrEpollEventLoopGroup()
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup();    } else {        return new NioEventLoopGroup();    }}
8359c4e5cdd9bf02ec4cafe0e86b870f2489a0eeb3112aa754997e1abc998bf2
newNioOrEpollEventLoopGroup
public static EventLoopGroup newNioOrEpollEventLoopGroup(int nThreads)
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup(nThreads);    } else {        return new NioEventLoopGroup(nThreads);    }}
43a9e3bc3111b68df98fc13cbf9d5c2604a79ccb2f09b6d667557d8f19e0eec0
nioOrEpollSocketChannel
public static Class<? extends SocketChannel> nioOrEpollSocketChannel()
{    if (Epoll.isAvailable()) {        return EpollSocketChannel.class;    } else {        return NioSocketChannel.class;    }}
afd97d2b865431d62dbe53fb7673fa4edd58208ea5b6a879c3ad2c6aa3e1f2eb
nioOrEpollServerSocketChannel
public static Class<? extends ServerSocketChannel> nioOrEpollServerSocketChannel()
{    if (Epoll.isAvailable()) {        return EpollServerSocketChannel.class;    } else {        return NioServerSocketChannel.class;    }}
d96e0efdb50838ffe49a8d449ee1af02ee958c4963e62cd5280aba85303f5364
getClientReachableLocalInetAddressCount
public static int getClientReachableLocalInetAddressCount()
{    try {        Set<InetAddress> validInetAddresses = new HashSet<>();        Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();        for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {                if (inetAddress.isLinkLocalAddress()) {                    if (LOG.isDebugEnabled()) {                        LOG.debug("Ignoring link-local InetAddress {}", inetAddress);                    }                    continue;                }                if (inetAddress.isMulticastAddress()) {                    if (LOG.isDebugEnabled()) {                        LOG.debug("Ignoring multicast InetAddress {}", inetAddress);                    }                    continue;                }                if (inetAddress.isLoopbackAddress()) {                    if (LOG.isDebugEnabled()) {                        LOG.debug("Ignoring loopback InetAddress {}", inetAddress);                    }                    continue;                }                validInetAddresses.add(inetAddress);            }        }        LOG.debug("Detected {} local network addresses: {}", validInetAddresses.size(), validInetAddresses);        return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;    } catch (SocketException ex) {        LOG.warn("Failed to list all network interfaces, assuming 1", ex);        return DEFAULT_INET_ADDRESS_COUNT;    }}
5fc0e5519c89161e0196e6077b03bdba0fe66ae6879440bb06e279f18712b697
formatInetAddr
public static String formatInetAddr(InetSocketAddress addr)
{    InetAddress ia = addr.getAddress();    if (ia == null) {        return String.format("%s:%s", addr.getHostString(), addr.getPort());    }    if (ia instanceof Inet6Address) {        return String.format("[%s]:%s", ia.getHostAddress(), addr.getPort());    } else {        return String.format("%s:%s", ia.getHostAddress(), addr.getPort());    }}
3fd889548fb229371c1606b7bb45cd530008e10e91991e6098322f6f73c8600b
getParent
 TrieNode getParent()
{    return this.parent;}
428232d669b60ceb98e71e6f8ce3f97a8f82553c058e617e74240e97f06d042b
setParent
 void setParent(TrieNode parent)
{    this.parent = parent;}
03ab7face53b6e475e70f3fe65d7689cc2f9771160e69396c70e7c6de8a4f1f1
setProperty
 void setProperty(boolean prop)
{    this.property = prop;}
d7ed0cf13a582397e850e0aa273e7c1d8466474df6ce94237d0166aa0e20c03f
hasProperty
 boolean hasProperty()
{    return this.property;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return this.value;}
9e62632e51fbcc69ab593d3c1ea343f449bb2aa938328ee23e52a2df18b47067
addChild
 void addChild(String childName, TrieNode node)
{    this.children.putIfAbsent(childName, node);}
a966d0320f9e476bc023e79dfd6cde4a6a021bcb874a1816dfbc9d9977983bdf
deleteChild
 void deleteChild(String childName)
{    this.children.computeIfPresent(childName, (key, childNode) -> {                childNode.setProperty(false);                if (childNode.isLeafNode()) {            childNode.setParent(null);            return null;        }        return childNode;    });}
ccd3ec8d746d5a313f79b75bb1d0d280bf8a6aa69c751c869d8e28bad580e654
getChild
 TrieNode getChild(String childName)
{    return this.children.get(childName);}
783755b516ec271e0366abd4fc6badbcde138deef6b75214a9a5dea116494cab
getChildren
 Collection<String> getChildren()
{    return children.keySet();}
a5a5c32aab445ed6706d2a636836776dc279992aa18b29e94bf9bfcaf4f9f2ae
isLeafNode
 boolean isLeafNode()
{    return children.isEmpty();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TrieNode [name=" + value + ", property=" + property + ", children=" + children.keySet() + "]";}
2a493cfa56b0babe74913bb874e579e25cc6bd21d4d7d55599a23e959d741bfc
addPath
public void addPath(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            TrieNode child = parent.getChild(part);            if (child == null) {                child = new TrieNode(parent, part);                parent.addChild(part, child);            }            parent = child;        }        parent.setProperty(true);    } finally {        writeLock.unlock();    }}
1b45a5ad4eca00fc24916c0695bfeb5a85300f8dbcd4712e1262649402ec6952
deletePath
public void deletePath(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return;            }            parent = parent.getChild(part);            LOG.debug("{}", parent);        }        final TrieNode realParent = parent.getParent();        realParent.deleteChild(parent.getValue());    } finally {        writeLock.unlock();    }}
819382a33aa49f003d46a00e810090cb04d9f3051e671430b259bc8381d4c634
existsNode
public boolean existsNode(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    readLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return false;            }            parent = parent.getChild(part);            LOG.debug("{}", parent);        }    } finally {        readLock.unlock();    }    return true;}
127b87a3c5145ebed47e930567d7cb1acfaea35c3abad25b87af297ad65c1bd2
findMaxPrefix
public String findMaxPrefix(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    readLock.lock();    try {        TrieNode parent = rootNode;        TrieNode deepestPropertyNode = null;        for (final String element : pathComponents) {            parent = parent.getChild(element);            if (parent == null) {                LOG.debug("{}", element);                break;            }            if (parent.hasProperty()) {                deepestPropertyNode = parent;            }        }        if (deepestPropertyNode == null) {            return "/";        }        final Deque<String> treePath = new ArrayDeque<>();        TrieNode node = deepestPropertyNode;        while (node != this.rootNode) {            treePath.offerFirst(node.getValue());            node = node.parent;        }        return "/" + String.join("/", treePath);    } finally {        readLock.unlock();    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    writeLock.lock();    try {        rootNode.getChildren().clear();    } finally {        writeLock.unlock();    }}
854b017516af4c3c782dfd021cfb44aaf5b991afd93eadbf46bde92aae74f3a7
validatePath
public static void validatePath(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
6887ace551183d0adacf5553c9791b583fe169707d87b0ff9cce4798acd18f98
validatePath
public static void validatePath(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c <= '\u001f' || c >= '\u007f' && c <= '\u009F' || c >= '\ud800' && c <= '\uf8ff' || c >= '\ufff0' && c <= '\uffff') {            reason = "invalid character @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }}
37cdf7ef088f11916e7a687e911ce1e64f606738948200708eb1b069322f9db6
normalizeFileSystemPath
public static String normalizeFileSystemPath(String path)
{    if (path != null) {        String osname = java.lang.System.getProperty("os.name");        if (osname.toLowerCase().contains("windows")) {            return path.replace('\\', '/');        }    }    return path;}
b9f2e46ee0b3357d97190f4bc39fe03cbbd09bff588f97e27ce23a3274517a29
loadKeyStore
public KeyStore loadKeyStore() throws IOException, GeneralSecurityException
{    Optional<String> passwordOption;    if (keyStorePassword == null || keyStorePassword.length() == 0) {        passwordOption = Optional.empty();    } else {        passwordOption = Optional.of(keyStorePassword);    }    File file = new File(keyStorePath);    return PemReader.loadKeyStore(file, file, passwordOption);}
68198ab382e4106aaeb5cdcc541755fccb5613b09ade306ec246ccf21546baf1
loadTrustStore
public KeyStore loadTrustStore() throws IOException, GeneralSecurityException
{    return PemReader.loadTrustStore(new File(trustStorePath));}
136a173d12fda2a82d257c4a9e7ed6bf5696ce07496abda685b421a0eb8b9448
build
 PEMFileLoader build()
{    return new PEMFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
915d17b6428a9402548e0e747ebc68c568fed1d4b02df2db2f4f72fbac829783
keyStoreInstance
protected KeyStore keyStoreInstance() throws KeyStoreException
{    return KeyStore.getInstance("PKCS12");}
6fc05041e9a1dc33e5d88e6c1bf8b2ce9b433baf1d564bf116de054fa862488c
build
 PKCS12FileLoader build()
{    return new PKCS12FileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
03ad1ee830541f5a5c9c609557a3a4b50f83e3d5dbb8382a287a4c1ff56dcc05
getConfigPrefix
protected String getConfigPrefix()
{    return "zookeeper.ssl.quorum.";}
d752bdd02f88e39a195097e3fb5590629ec944a5a879c36cfee84d2f47905f23
shouldVerifyClientHostname
protected boolean shouldVerifyClientHostname()
{    return true;}
93de5d34c7e93ec42c787b61bb740e9c869aa5f840ab25f841eb8f6a9f583c23
getSSLContext
public SSLContext getSSLContext()
{    return sslContext;}
cc6fbfd5ec5c0c8bbd70a59c04cc744ae8096eddb2cb62c1c62d5a2096debe5d
createSSLSocket
public SSLSocket createSSLSocket() throws IOException
{    return configureSSLSocket((SSLSocket) sslContext.getSocketFactory().createSocket(), true);}
c4eae37d8eea0e6d5fc5bd91b73d4bd058d68a2d4c2a9642a206438e98ba3242
createSSLSocket
public SSLSocket createSSLSocket(Socket socket, byte[] pushbackBytes) throws IOException
{    SSLSocket sslSocket;    if (pushbackBytes != null && pushbackBytes.length > 0) {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, new ByteArrayInputStream(pushbackBytes), true);    } else {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, null, socket.getPort(), true);    }    return configureSSLSocket(sslSocket, false);}
a89c7930fba97b1c1c594fe74ff3a044420798e9927c94f21f2d594e6c290939
createSSLServerSocket
public SSLServerSocket createSSLServerSocket() throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket();    return configureSSLServerSocket(sslServerSocket);}
6008893b4d4d4e58c67a47318aedc5d83e7591b8977563b3001d871895225def
createSSLServerSocket
public SSLServerSocket createSSLServerSocket(int port) throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket(port);    return configureSSLServerSocket(sslServerSocket);}
aa135473c497d19dcacdae32274a43d56efe3b28c015144e1bd6b3d75ca25319
createNettyJdkSslContext
public SslContext createNettyJdkSslContext(SSLContext sslContext, boolean isClientSocket)
{    return new JdkSslContext(sslContext, isClientSocket, cipherSuitesAsList, IdentityCipherSuiteFilter.INSTANCE, null, isClientSocket ? X509Util.ClientAuth.NONE.toNettyClientAuth() : clientAuth.toNettyClientAuth(), enabledProtocols, false);}
23d3d1faa75943c53741a570d4e11dcfaab5493ace7bfdaf19d6d5eef3605ff9
getHandshakeDetectionTimeoutMillis
public int getHandshakeDetectionTimeoutMillis()
{    return handshakeDetectionTimeoutMillis;}
a135c452b21c6e2dfec59ac039f732b6865a68f1c7fed92a33c59357ba270243
configureSSLSocket
private SSLSocket configureSSLSocket(SSLSocket socket, boolean isClientSocket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, isClientSocket);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(isClientSocket);    return socket;}
2e7fbfde90c19adad12241adb3b1392c15cd9bcb3c32b1ebe55637db215e0481
configureSSLServerSocket
private SSLServerSocket configureSSLServerSocket(SSLServerSocket socket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, false);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(false);    return socket;}
957509a977d22ea2988e52313b1b3247710c567055381a8950669aa34e769cf4
configureSslParameters
private void configureSslParameters(SSLParameters sslParameters, boolean isClientSocket)
{    if (cipherSuites != null) {        if (LOG.isDebugEnabled()) {            LOG.debug("Setup cipher suites for {} socket: {}", isClientSocket ? "client" : "server", Arrays.toString(cipherSuites));        }        sslParameters.setCipherSuites(cipherSuites);    }    if (enabledProtocols != null) {        if (LOG.isDebugEnabled()) {            LOG.debug("Setup enabled protocols for {} socket: {}", isClientSocket ? "client" : "server", Arrays.toString(enabledProtocols));        }        sslParameters.setProtocols(enabledProtocols);    }    if (!isClientSocket) {        switch(clientAuth) {            case NEED:                sslParameters.setNeedClientAuth(true);                break;            case WANT:                sslParameters.setWantClientAuth(true);                break;            default:                                sslParameters.setNeedClientAuth(false);                break;        }    }}
f2a8e05c990c2f4630afb04977722c47e0dd93427ebb9b03291fab33e8b9dff7
getEnabledProtocols
private String[] getEnabledProtocols(final ZKConfig config, final SSLContext sslContext)
{    String enabledProtocolsInput = config.getProperty(x509Util.getSslEnabledProtocolsProperty());    if (enabledProtocolsInput == null) {        return new String[] { sslContext.getProtocol() };    }    return enabledProtocolsInput.split(",");}
868e290deea1d55d0480a9a3a8ee7b1272d4dfe7960c04ccf94418280f7f5d8e
getCipherSuites
private String[] getCipherSuites(final ZKConfig config)
{    String cipherSuitesInput = config.getProperty(x509Util.getSslCipherSuitesProperty());    if (cipherSuitesInput == null) {        return X509Util.getDefaultCipherSuites();    } else {        return cipherSuitesInput.split(",");    }}
cd127e231ed7778a9225a47f8b998ae339e78c92db673007cd6b0e4e35cb17a6
getClientAuth
private X509Util.ClientAuth getClientAuth(final ZKConfig config)
{    return X509Util.ClientAuth.fromPropertyValue(config.getProperty(x509Util.getSslClientAuthProperty()));}
f1548c038b6d752644a2e9192cdf97925d5fbabc7386c187cbf1e23e3b53a21f
getHandshakeDetectionTimeoutMillis
private int getHandshakeDetectionTimeoutMillis(final ZKConfig config)
{    String propertyString = config.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    int result;    if (propertyString == null) {        result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } else {        result = Integer.parseInt(propertyString);        if (result < 1) {                                    LOG.warn("Invalid value for {}: {}, using the default value of {}", x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), result, X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS);            result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;        }    }    return result;}
b9f2e46ee0b3357d97190f4bc39fe03cbbd09bff588f97e27ce23a3274517a29
loadKeyStore
public KeyStore loadKeyStore() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(keyStorePath))) {        KeyStore ks = keyStoreInstance();        ks.load(inputStream, passwordStringToCharArray(keyStorePassword));        return ks;    }}
68198ab382e4106aaeb5cdcc541755fccb5613b09ade306ec246ccf21546baf1
loadTrustStore
public KeyStore loadTrustStore() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(trustStorePath))) {        KeyStore ts = keyStoreInstance();        ts.load(inputStream, passwordStringToCharArray(trustStorePassword));        return ts;    }}
0fd578f5a81eea7b8a22a906971b438acd8b2fd2bf5cad5b4fa4e4dbd342a8c2
passwordStringToCharArray
private static char[] passwordStringToCharArray(String password)
{    return password == null ? EMPTY_CHAR_ARRAY : password.toCharArray();}
7291158b9de3b646ae0f4ce5aeff69779f31cb8eabba60905a29718da68a8abd
split
public static List<String> split(String value, String separator)
{    String[] splits = value.split(separator);    List<String> results = new ArrayList<String>();    for (int i = 0; i < splits.length; i++) {        splits[i] = splits[i].trim();        if (splits[i].length() > 0) {            results.add(splits[i]);        }    }    return Collections.unmodifiableList(results);}
1f85a864cbc2e2c7ea5cb8cc8447fcf0457811419515743679bcec0668715e49
joinStrings
public static String joinStrings(List<String> list, String delim)
{    if (list == null) {        return null;    }    StringBuilder builder = new StringBuilder(list.get(0));    for (String s : list.subList(1, list.size())) {        builder.append(delim).append(s);    }    return builder.toString();}
456ab32053ce2cef2f536e218a2452f24f02a58e6903c5b00289926bb28486f0
currentElapsedTime
public static long currentElapsedTime()
{    return System.nanoTime() / 1000000;}
ded58963eb2231cffefea16bb33dd545aa352649c0b205a3d4adc52dc5ee84b0
currentWallTime
public static long currentWallTime()
{    return System.currentTimeMillis();}
ef121c27d029cd79d01b474be12b2dd01ca3d32c416bd44e9a750b9d5273e785
elapsedTimeToDate
public static Date elapsedTimeToDate(long elapsedTime)
{    long wallTime = currentWallTime() + elapsedTime - currentElapsedTime();    return new Date(wallTime);}
444f1d93088ed91e885d52568016b882f82bfd785f51044bc65aeea66ad9119f
getGCMCiphers
private static String[] getGCMCiphers()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" };}
14a160807c3c6c6bb1a909d43a878cedb1012829ec93e1da2717861f203fc377
getCBCCiphers
private static String[] getCBCCiphers()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA" };}
cc042b4c7706d0887d39701e3543aa6c6080a06c6e093ff0935547b1e2111825
concatArrays
private static String[] concatArrays(String[] left, String[] right)
{    String[] result = new String[left.length + right.length];    System.arraycopy(left, 0, result, 0, left.length);    System.arraycopy(right, 0, result, left.length, right.length);    return result;}
a09a0b5b2d25afc3c080b32f39713674a3bc2e0b3b9a7f98c063a5b6250e6a29
fromPropertyValue
public static ClientAuth fromPropertyValue(String prop)
{    if (prop == null || prop.length() == 0) {        return NEED;    }    return ClientAuth.valueOf(prop.toUpperCase());}
8a13ad2de87bf754e32abdf859b27f2497d05eb1cd0af5c4a1dfaaa917bee706
toNettyClientAuth
public io.netty.handler.ssl.ClientAuth toNettyClientAuth()
{    return nettyAuth;}
2775b5c380fc89db0cdf1d92ca7f335bff2260362017ce7e0f05cb9aa059bc56
getSslProtocolProperty
public String getSslProtocolProperty()
{    return sslProtocolProperty;}
1e4dc8245cbae49027c67bb30931720fc377ec07700e9bdfc553a862ab48ebcc
getSslEnabledProtocolsProperty
public String getSslEnabledProtocolsProperty()
{    return sslEnabledProtocolsProperty;}
6747f73c115d4e859514263ae495acd02b7b434e304923f8ed47dcdf41fe72d0
getCipherSuitesProperty
public String getCipherSuitesProperty()
{    return cipherSuitesProperty;}
3466f08fb792743f6fa300b5d4c15e9886da94d34bdd9b1091b002c4b474dd53
getSslKeystoreLocationProperty
public String getSslKeystoreLocationProperty()
{    return sslKeystoreLocationProperty;}
3b7b7c53de4aa477ff86a08eed9e58216ce8dd99e7f612ed8a46602ae0671495
getSslCipherSuitesProperty
public String getSslCipherSuitesProperty()
{    return cipherSuitesProperty;}
e734457c7a3892ac882d0e1b9b068d471ef29c464996129ba1ce70e3fdc326d4
getSslKeystorePasswdProperty
public String getSslKeystorePasswdProperty()
{    return sslKeystorePasswdProperty;}
41fef40d6c77a69b3b2920b7dec3a3e8ed7efe84b3dee089b14f80574491f1a2
getSslKeystoreTypeProperty
public String getSslKeystoreTypeProperty()
{    return sslKeystoreTypeProperty;}
c1fd5448458e083bb0ef681022b5b7c14d418cd7bbbeeb4c3b535353bb0c4cdb
getSslTruststoreLocationProperty
public String getSslTruststoreLocationProperty()
{    return sslTruststoreLocationProperty;}
136c9491473917e1f908d0169fdc1bba7403c2974d34d685486529ede0c66b24
getSslTruststorePasswdProperty
public String getSslTruststorePasswdProperty()
{    return sslTruststorePasswdProperty;}
1436a82608d2448c7c1a5c071daa5819b9611539656fa45e3fcdb76325b56ca4
getSslTruststoreTypeProperty
public String getSslTruststoreTypeProperty()
{    return sslTruststoreTypeProperty;}
b9b4a8bdbdeba3dd099a633cf274732501e1da818561a37e9f50e66a02d01355
getSslContextSupplierClassProperty
public String getSslContextSupplierClassProperty()
{    return sslContextSupplierClassProperty;}
fce2b1c920ca0e55e2c418cc35157af7945f79279ee11a06029961009ee96025
getSslHostnameVerificationEnabledProperty
public String getSslHostnameVerificationEnabledProperty()
{    return sslHostnameVerificationEnabledProperty;}
ddcdd1e39bbcc8ce26ef1ce80be8f146e317a0fc08c124d993010d2ee53b30ac
getSslCrlEnabledProperty
public String getSslCrlEnabledProperty()
{    return sslCrlEnabledProperty;}
aebc3de7321cf6d6cb65ba3adcb6c22affb83e594eabe219c706c2c3e5e812ea
getSslOcspEnabledProperty
public String getSslOcspEnabledProperty()
{    return sslOcspEnabledProperty;}
4b44f475652222bf3321d371b7ead38be640f51074dbb9067e12cf9c0d48a7ec
getSslClientAuthProperty
public String getSslClientAuthProperty()
{    return sslClientAuthProperty;}
4886d194a64676747b6bdbd1fbc8b39ddc8e574dbe1252f51ee001884012289b
getSslHandshakeDetectionTimeoutMillisProperty
public String getSslHandshakeDetectionTimeoutMillisProperty()
{    return sslHandshakeDetectionTimeoutMillisProperty;}
0c325fa10fc31188bc1b08b48b39170fc9e333ec83c6cf55bcb0ca9bd30d355a
getDefaultSSLContext
public SSLContext getDefaultSSLContext() throws X509Exception.SSLContextException
{    return getDefaultSSLContextAndOptions().getSSLContext();}
1a05cd90257924cda194772c04ee184c6420700cba332762d14369194ce4569c
createSSLContext
public SSLContext createSSLContext(ZKConfig config) throws SSLContextException
{    return createSSLContextAndOptions(config).getSSLContext();}
19d30f7de9e0dbfdce21d26d787b3db8d5394410aa6c08a62af424f0f2c5f52d
getDefaultSSLContextAndOptions
public SSLContextAndOptions getDefaultSSLContextAndOptions() throws X509Exception.SSLContextException
{    SSLContextAndOptions result = defaultSSLContextAndOptions.get();    if (result == null) {        result = createSSLContextAndOptions();        if (!defaultSSLContextAndOptions.compareAndSet(null, result)) {                        result = defaultSSLContextAndOptions.get();        }    }    return result;}
047a1902d34f8949c405d8b52e74736f5bb1c4fb0cc498c90b473c78deabd197
resetDefaultSSLContextAndOptions
private void resetDefaultSSLContextAndOptions() throws X509Exception.SSLContextException
{    SSLContextAndOptions newContext = createSSLContextAndOptions();    defaultSSLContextAndOptions.set(newContext);}
b7184b5143e39cf8faa0a22331c2c838a4f437f405b13fb793e9cf3cb5ddb9ea
createSSLContextAndOptions
private SSLContextAndOptions createSSLContextAndOptions() throws SSLContextException
{    /*         * Since Configuration initializes the key store and trust store related         * configuration from system property. Reading property from         * configuration will be same reading from system property         */    return createSSLContextAndOptions(zkConfig == null ? new ZKConfig() : zkConfig);}
cdf07630470fc3927996b405d619c1e52c799ae2b9379b337298257a74627222
getSslHandshakeTimeoutMillis
public int getSslHandshakeTimeoutMillis()
{    try {        SSLContextAndOptions ctx = getDefaultSSLContextAndOptions();        return ctx.getHandshakeDetectionTimeoutMillis();    } catch (SSLContextException e) {        LOG.error("Error creating SSL context and options", e);        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } catch (Exception e) {        LOG.error("Error parsing config property " + getSslHandshakeDetectionTimeoutMillisProperty(), e);        return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    }}
6f671d2b65afc47601ba0ac2f9dd0801b05990f2ecca3263476924d4b12a5934
createSSLContextAndOptions
public SSLContextAndOptions createSSLContextAndOptions(ZKConfig config) throws SSLContextException
{    final String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);    if (supplierContextClassName != null) {        if (LOG.isDebugEnabled()) {            LOG.debug("Loading SSLContext supplier from property '{}'", sslContextSupplierClassProperty);        }        try {            Class<?> sslContextClass = Class.forName(supplierContextClassName);            Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();            return new SSLContextAndOptions(this, config, sslContextSupplier.get());        } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {            throw new SSLContextException("Could not retrieve the SSLContext from supplier source '" + supplierContextClassName + "' provided in the property '" + sslContextSupplierClassProperty + "'", e);        }    } else {        return createSSLContextAndOptionsFromConfig(config);    }}
494525ac49f0438630091a4b30b02c65e147db34937fe1b0e388ed2aa11e1ca0
createSSLContextAndOptionsFromConfig
public SSLContextAndOptions createSSLContextAndOptionsFromConfig(ZKConfig config) throws SSLContextException
{    KeyManager[] keyManagers = null;    TrustManager[] trustManagers = null;    String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty, "");    String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty, "");    String keyStoreTypeProp = config.getProperty(sslKeystoreTypeProperty);    if (keyStoreLocationProp.isEmpty()) {        LOG.warn(getSslKeystoreLocationProperty() + " not specified");    } else {        try {            keyManagers = new KeyManager[] { createKeyManager(keyStoreLocationProp, keyStorePasswordProp, keyStoreTypeProp) };        } catch (KeyManagerException keyManagerException) {            throw new SSLContextException("Failed to create KeyManager", keyManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslKeystoreTypeProperty + ": " + keyStoreTypeProp, e);        }    }    String trustStoreLocationProp = config.getProperty(sslTruststoreLocationProperty, "");    String trustStorePasswordProp = config.getProperty(sslTruststorePasswdProperty, "");    String trustStoreTypeProp = config.getProperty(sslTruststoreTypeProperty);    boolean sslCrlEnabled = config.getBoolean(this.sslCrlEnabledProperty);    boolean sslOcspEnabled = config.getBoolean(this.sslOcspEnabledProperty);    boolean sslServerHostnameVerificationEnabled = config.getBoolean(this.getSslHostnameVerificationEnabledProperty(), true);    boolean sslClientHostnameVerificationEnabled = sslServerHostnameVerificationEnabled && shouldVerifyClientHostname();    if (trustStoreLocationProp.isEmpty()) {        LOG.warn(getSslTruststoreLocationProperty() + " not specified");    } else {        try {            trustManagers = new TrustManager[] { createTrustManager(trustStoreLocationProp, trustStorePasswordProp, trustStoreTypeProp, sslCrlEnabled, sslOcspEnabled, sslServerHostnameVerificationEnabled, sslClientHostnameVerificationEnabled) };        } catch (TrustManagerException trustManagerException) {            throw new SSLContextException("Failed to create TrustManager", trustManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslTruststoreTypeProperty + ": " + trustStoreTypeProp, e);        }    }    String protocol = config.getProperty(sslProtocolProperty, DEFAULT_PROTOCOL);    try {        SSLContext sslContext = SSLContext.getInstance(protocol);        sslContext.init(keyManagers, trustManagers, null);        return new SSLContextAndOptions(this, config, sslContext);    } catch (NoSuchAlgorithmException | KeyManagementException sslContextInitException) {        throw new SSLContextException(sslContextInitException);    }}
ca6c4a5ad6a9a897120e34f4a36b6af4bc674fab840d73f8466ef0b856c50686
loadKeyStore
public static KeyStore loadKeyStore(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(keyStoreTypeProp, keyStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setKeyStorePath(keyStoreLocation).setKeyStorePassword(keyStorePassword).build().loadKeyStore();}
b1a1b85ee5849b11835f97adab5ba413208bf7eff64687af4a6337a6d366bb14
loadTrustStore
public static KeyStore loadTrustStore(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(trustStoreTypeProp, trustStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setTrustStorePath(trustStoreLocation).setTrustStorePassword(trustStorePassword).build().loadTrustStore();}
90aefe152c1d83099f83d688a74895f9a8560299c6359569db7be429f3ae9aac
createKeyManager
public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws KeyManagerException
{    if (keyStorePassword == null) {        keyStorePassword = "";    }    try {        KeyStore ks = loadKeyStore(keyStoreLocation, keyStorePassword, keyStoreTypeProp);        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");        kmf.init(ks, keyStorePassword.toCharArray());        for (KeyManager km : kmf.getKeyManagers()) {            if (km instanceof X509KeyManager) {                return (X509KeyManager) km;            }        }        throw new KeyManagerException("Couldn't find X509KeyManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new KeyManagerException(e);    }}
36b858b0e6204b412ef03d35058b3b2e0c383b1d1ce60be3c8986af18ec23d36
createTrustManager
public static X509TrustManager createTrustManager(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp, boolean crlEnabled, boolean ocspEnabled, final boolean serverHostnameVerificationEnabled, final boolean clientHostnameVerificationEnabled) throws TrustManagerException
{    if (trustStorePassword == null) {        trustStorePassword = "";    }    try {        KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);        PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());        if (crlEnabled || ocspEnabled) {            pbParams.setRevocationEnabled(true);            System.setProperty("com.sun.net.ssl.checkRevocation", "true");            System.setProperty("com.sun.security.enableCRLDP", "true");            if (ocspEnabled) {                Security.setProperty("ocsp.enable", "true");            }        } else {            pbParams.setRevocationEnabled(false);        }                TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");        tmf.init(new CertPathTrustManagerParameters(pbParams));        for (final TrustManager tm : tmf.getTrustManagers()) {            if (tm instanceof X509ExtendedTrustManager) {                return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);            }        }        throw new TrustManagerException("Couldn't find X509TrustManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new TrustManagerException(e);    }}
4da9a0fd8a2dfc03a814cfb9538a1febafb88f4a82bbfbcbd8e22a8d8580ebe5
createSSLSocket
public SSLSocket createSSLSocket() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket();}
ba8b4021bba8b7df3bcc1d7c7b97d742fd1f5064eee59ffe90f75a3af158b3f1
createSSLSocket
public SSLSocket createSSLSocket(Socket socket, byte[] pushbackBytes) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket(socket, pushbackBytes);}
213df19691a41e2796861981ff95d8d53d4844b33946534b4eb0c9fbe702c761
createSSLServerSocket
public SSLServerSocket createSSLServerSocket() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket();}
0a764d53b020e1f20da09c4b03169c8dd466adc52dc6d5aef66821f8ff5f8b0e
createSSLServerSocket
public SSLServerSocket createSSLServerSocket(int port) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket(port);}
37391ba62fa46de6a70349285df04324147d69a89d755e063a15da96a84cda56
getDefaultCipherSuites
 static String[] getDefaultCipherSuites()
{    return getDefaultCipherSuitesForJavaVersion(System.getProperty("java.specification.version"));}
56a1febfd5ccd897b5b08b29ceb5433c559984b80895b20e4caefea203ead7ed
getDefaultCipherSuitesForJavaVersion
 static String[] getDefaultCipherSuitesForJavaVersion(String javaVersion)
{    Objects.requireNonNull(javaVersion);    if (javaVersion.matches("\\d+")) {                LOG.debug("Using Java9+ optimized cipher suites for Java version {}", javaVersion);        return DEFAULT_CIPHERS_JAVA9;    } else if (javaVersion.startsWith("1.")) {                LOG.debug("Using Java8 optimized cipher suites for Java version {}", javaVersion);        return DEFAULT_CIPHERS_JAVA8;    } else {        LOG.debug("Could not parse java version {}, using Java8 optimized cipher suites", javaVersion);        return DEFAULT_CIPHERS_JAVA8;    }}
8783a6d736d998fd183bd9f3700c008aea820a3f034efcd4c2537e600f65ae8f
newFileChangeWatcher
private FileChangeWatcher newFileChangeWatcher(String fileLocation) throws IOException
{    if (fileLocation == null || fileLocation.isEmpty()) {        return null;    }    final Path filePath = Paths.get(fileLocation).toAbsolutePath();    Path parentPath = filePath.getParent();    if (parentPath == null) {        throw new IOException("Key/trust store path does not have a parent: " + filePath);    }    return new FileChangeWatcher(parentPath, watchEvent -> {        handleWatchEvent(filePath, watchEvent);    });}
3afd72ac626bd80ed68041f8744578ae53c82235ded7e886e4f8c862942fcb90
enableCertFileReloading
public void enableCertFileReloading() throws IOException
{    LOG.info("enabling cert file reloading");    ZKConfig config = zkConfig == null ? new ZKConfig() : zkConfig;    FileChangeWatcher newKeyStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslKeystoreLocationProperty));    if (newKeyStoreFileWatcher != null) {                if (keyStoreFileWatcher != null) {            keyStoreFileWatcher.stop();        }        keyStoreFileWatcher = newKeyStoreFileWatcher;        keyStoreFileWatcher.start();    }    FileChangeWatcher newTrustStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslTruststoreLocationProperty));    if (newTrustStoreFileWatcher != null) {                if (trustStoreFileWatcher != null) {            trustStoreFileWatcher.stop();        }        trustStoreFileWatcher = newTrustStoreFileWatcher;        trustStoreFileWatcher.start();    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (keyStoreFileWatcher != null) {        keyStoreFileWatcher.stop();        keyStoreFileWatcher = null;    }    if (trustStoreFileWatcher != null) {        trustStoreFileWatcher.stop();        trustStoreFileWatcher = null;    }}
565805d1d15f9c056d753ebc374f324f2a11366aff0895d6ed21564ea5ea71a1
handleWatchEvent
private void handleWatchEvent(Path filePath, WatchEvent<?> event)
{    boolean shouldResetContext = false;    Path dirPath = filePath.getParent();    if (event.kind().equals(StandardWatchEventKinds.OVERFLOW)) {                shouldResetContext = true;    } else if (event.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY) || event.kind().equals(StandardWatchEventKinds.ENTRY_CREATE)) {        Path eventFilePath = dirPath.resolve((Path) event.context());        if (filePath.equals(eventFilePath)) {            shouldResetContext = true;        }    }        if (shouldResetContext) {        if (LOG.isDebugEnabled()) {            LOG.debug("Attempting to reset default SSL context after receiving watch event: " + event.kind() + " with context: " + event.context());        }        try {            this.resetDefaultSSLContextAndOptions();        } catch (SSLContextException e) {            throw new RuntimeException(e);        }    } else {        if (LOG.isDebugEnabled()) {            LOG.debug("Ignoring watch event and keeping previous default SSL context. Event kind: " + event.kind() + " with context: " + event.context());        }    }}
d4ed25ac8ad321cf30617caf76c4576654e12017af8058c0917f5c720521f0ec
init
private void init()
{    /**     * backward compatibility for all currently available client properties     */    handleBackwardCompatibility();}
6df4e87bdc5cbc70e5b186d6b0e03c0436ffe2aecb3f4b2cc603fbd0924a7246
handleBackwardCompatibility
protected void handleBackwardCompatibility()
{    properties.put(JUTE_MAXBUFFER, System.getProperty(JUTE_MAXBUFFER));    properties.put(KINIT_COMMAND, System.getProperty(KINIT_COMMAND));    properties.put(JGSS_NATIVE, System.getProperty(JGSS_NATIVE));    try (ClientX509Util clientX509Util = new ClientX509Util()) {        putSSLProperties(clientX509Util);        properties.put(clientX509Util.getSslAuthProviderProperty(), System.getProperty(clientX509Util.getSslAuthProviderProperty()));    }    try (X509Util x509Util = new QuorumX509Util()) {        putSSLProperties(x509Util);    }}
e7bbcc717072efab32546c02eb4f9ead9209c510e0ce28f340858c4c77cc0e0b
putSSLProperties
private void putSSLProperties(X509Util x509Util)
{    properties.put(x509Util.getSslProtocolProperty(), System.getProperty(x509Util.getSslProtocolProperty()));    properties.put(x509Util.getSslEnabledProtocolsProperty(), System.getProperty(x509Util.getSslEnabledProtocolsProperty()));    properties.put(x509Util.getSslCipherSuitesProperty(), System.getProperty(x509Util.getSslCipherSuitesProperty()));    properties.put(x509Util.getSslKeystoreLocationProperty(), System.getProperty(x509Util.getSslKeystoreLocationProperty()));    properties.put(x509Util.getSslKeystorePasswdProperty(), System.getProperty(x509Util.getSslKeystorePasswdProperty()));    properties.put(x509Util.getSslKeystoreTypeProperty(), System.getProperty(x509Util.getSslKeystoreTypeProperty()));    properties.put(x509Util.getSslTruststoreLocationProperty(), System.getProperty(x509Util.getSslTruststoreLocationProperty()));    properties.put(x509Util.getSslTruststorePasswdProperty(), System.getProperty(x509Util.getSslTruststorePasswdProperty()));    properties.put(x509Util.getSslTruststoreTypeProperty(), System.getProperty(x509Util.getSslTruststoreTypeProperty()));    properties.put(x509Util.getSslContextSupplierClassProperty(), System.getProperty(x509Util.getSslContextSupplierClassProperty()));    properties.put(x509Util.getSslHostnameVerificationEnabledProperty(), System.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));    properties.put(x509Util.getSslCrlEnabledProperty(), System.getProperty(x509Util.getSslCrlEnabledProperty()));    properties.put(x509Util.getSslOcspEnabledProperty(), System.getProperty(x509Util.getSslOcspEnabledProperty()));    properties.put(x509Util.getSslClientAuthProperty(), System.getProperty(x509Util.getSslClientAuthProperty()));    properties.put(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), System.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty()));}
24b97b4a87e6aecb892eb1fbffabcbccc67ab8799b48339ba108a4e72cefdea9
getProperty
public String getProperty(String key)
{    return properties.get(key);}
52d4e9e6b53b263485aa0a2b4c64d81d841e9444c5dccd2381c46a38f66ebd41
getProperty
public String getProperty(String key, String defaultValue)
{    String value = properties.get(key);    return (value == null) ? defaultValue : value;}
2a9a79253d25bacfc0063145ddfca06bd7cec9cdee42a9b88879b64d68b0dab6
getJaasConfKey
public String getJaasConfKey()
{    return System.getProperty(Environment.JAAS_CONF_KEY);}
0ac4369b202b6395dfa26e597aaa0c9b8967a0b1e722fe1af71e32a0a7246e27
setProperty
public void setProperty(String key, String value)
{    if (null == key) {        throw new IllegalArgumentException("property key is null.");    }    String oldValue = properties.put(key, value);    if (LOG.isDebugEnabled()) {        if (null != oldValue && !oldValue.equals(value)) {            LOG.debug("key {}'s value {} is replaced with new value {}", key, oldValue, value);        }    }}
25e3350a8b0d300185a60b3794410620b5b53e316b8a0eab85d236dc0652dd92
addConfiguration
public void addConfiguration(File configFile) throws ConfigException
{    LOG.info("Reading configuration from: {}", configFile.getAbsolutePath());    try {        configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).validate(configFile);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parseProperties(cfg);    } catch (IOException | IllegalArgumentException e) {        LOG.error("Error while configuration from: {}", configFile.getAbsolutePath(), e);        throw new ConfigException("Error while processing " + configFile.getAbsolutePath(), e);    }}
2033e8abac6f6023093403c57e7f5ba9c357b4f25321edd00c4430a3beb2dee0
addConfiguration
public void addConfiguration(String configPath) throws ConfigException
{    addConfiguration(new File(configPath));}
22c86ead30a92c2adea77384e1709f187ddab90bd415c7f5690d65349aa01030
parseProperties
private void parseProperties(Properties cfg)
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        setProperty(key, value);    }}
9184bdf1fb3843577cb65000cbb4f296363425f67e3b112ff43c85fa62e89f9f
getBoolean
public boolean getBoolean(String key)
{    return getBoolean(key, false);}
e423b85b9dedefb260edaed9164697d0ecc780ed94745902078cfb1443890225
getBoolean
public boolean getBoolean(String key, boolean defaultValue)
{    String propertyValue = getProperty(key);    if (propertyValue == null) {        return defaultValue;    } else {        return Boolean.parseBoolean(propertyValue);    }}
d9327754c8cdcb5e83f79841d729a6bf5dd1a0b1f9d3fd594ef55be6ba1dd7e9
getInt
public int getInt(String key, int defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Integer.parseInt(value.trim());    }    return defaultValue;}
88a1ae75a84b3f0ebbf90796bce7877e1b0d61afe310b0456a7aec205d3037bb
IP
 static SubjectName IP(final String value)
{    return new SubjectName(value, IP);}
d6c23b16820b1a488bb73913a9f9e3743d9349f32b1ad3addcc21308ffcd4f07
DNS
 static SubjectName DNS(final String value)
{    return new SubjectName(value, DNS);}
e13ca6770d128854311e967cbfe111c5323a9155e542cbb6a563c89bfcce6811
getType
public int getType()
{    return type;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return value;}
76951a84493bccf1c127b1d5fa6a19c6619b31beee4bdddf8627edafe9514047
isIPv4Address
 static boolean isIPv4Address(final String input)
{    return IPV4_PATTERN.matcher(input).matches();}
a943cc72b5673e9df5c394761bfe1868218fda672b96db23cc607967ee68edc9
isIPv6StdAddress
 static boolean isIPv6StdAddress(final String input)
{    return IPV6_STD_PATTERN.matcher(input).matches();}
28ff764797dbb3dd99b75ffc3fbc5b10cb252c62dcb76940294422f6c8fee584
isIPv6HexCompressedAddress
 static boolean isIPv6HexCompressedAddress(final String input)
{    return IPV6_HEX_COMPRESSED_PATTERN.matcher(input).matches();}
4d49fd36ef77bc245088960b9d428b2ab37aa5cf6921d997c36f53f49ce40051
isIPv6Address
 static boolean isIPv6Address(final String input)
{    return isIPv6StdAddress(input) || isIPv6HexCompressedAddress(input);}
fd72df65276a3d333e1b9026f7cce1ebdec716fb189643757732b1d4de042b6c
verify
public boolean verify(final String host, final SSLSession session)
{    try {        final Certificate[] certs = session.getPeerCertificates();        final X509Certificate x509 = (X509Certificate) certs[0];        verify(host, x509);        return true;    } catch (final SSLException ex) {        if (log.isDebugEnabled()) {            log.debug(ex.getMessage(), ex);        }        return false;    }}
52a9864a3bbbebe2317c1948ae0e29225aa8705f57fe2ee9f8a6c88f4035cb87
verify
 void verify(final String host, final X509Certificate cert) throws SSLException
{    final HostNameType hostType = determineHostFormat(host);    final List<SubjectName> subjectAlts = getSubjectAltNames(cert);    if (subjectAlts != null && !subjectAlts.isEmpty()) {        switch(hostType) {            case IPv4:                matchIPAddress(host, subjectAlts);                break;            case IPv6:                matchIPv6Address(host, subjectAlts);                break;            default:                matchDNSName(host, subjectAlts);        }    } else {                        final X500Principal subjectPrincipal = cert.getSubjectX500Principal();        final String cn = extractCN(subjectPrincipal.getName(X500Principal.RFC2253));        if (cn == null) {            throw new SSLException("Certificate subject for <" + host + "> doesn't contain " + "a common name and does not have alternative names");        }        matchCN(host, cn);    }}
9a705b1a9d74728a638b3f6e9a48077544060f8bb9cc60d2f807da5f76231597
matchIPAddress
private static void matchIPAddress(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            if (host.equals(subjectAlt.getValue())) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
300d1ba1cb662c92d9f71e7ac6d7ca02b057b7c70906b81dc06cc503007a6912
matchIPv6Address
private static void matchIPv6Address(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalisedHost = normaliseAddress(host);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            final String normalizedSubjectAlt = normaliseAddress(subjectAlt.getValue());            if (normalisedHost.equals(normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
48586daf0d5bf73f2085f11613b6d3549f4c289cc09dfff65de415d7e1bfc74f
matchDNSName
private static void matchDNSName(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.DNS) {            final String normalizedSubjectAlt = subjectAlt.getValue().toLowerCase(Locale.ROOT);            if (matchIdentityStrict(normalizedHost, normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
7ba65ea0897552df11291e045f34c86621803f413d6f012e4f6aeea18904f44b
matchCN
private static void matchCN(final String host, final String cn) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    final String normalizedCn = cn.toLowerCase(Locale.ROOT);    if (!matchIdentityStrict(normalizedHost, normalizedCn)) {        throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match " + "common name of the certificate subject: " + cn);    }}
72b1bc4242f7083379b730b4bd2e8987ab901f5dd323ec168a93fb4874da2265
matchIdentity
private static boolean matchIdentity(final String host, final String identity, final boolean strict)
{                        final int asteriskIdx = identity.indexOf('*');    if (asteriskIdx != -1) {        final String prefix = identity.substring(0, asteriskIdx);        final String suffix = identity.substring(asteriskIdx + 1);        if (!prefix.isEmpty() && !host.startsWith(prefix)) {            return false;        }        if (!suffix.isEmpty() && !host.endsWith(suffix)) {            return false;        }                if (strict) {            final String remainder = host.substring(prefix.length(), host.length() - suffix.length());            return !remainder.contains(".");        }        return true;    }    return host.equalsIgnoreCase(identity);}
65ac606539e0fe4f1d04b639be481882af5465630cdd92f562bb634827ddbd6a
matchIdentityStrict
private static boolean matchIdentityStrict(final String host, final String identity)
{    return matchIdentity(host, identity, true);}
f7b15025839df93dd03dd92785d5798a25adb77b6db2d46b057b5dcc3d560892
extractCN
private static String extractCN(final String subjectPrincipal) throws SSLException
{    if (subjectPrincipal == null) {        return null;    }    try {        final LdapName subjectDN = new LdapName(subjectPrincipal);        final List<Rdn> rdns = subjectDN.getRdns();        for (int i = rdns.size() - 1; i >= 0; i--) {            final Rdn rds = rdns.get(i);            final Attributes attributes = rds.toAttributes();            final Attribute cn = attributes.get("cn");            if (cn != null) {                try {                    final Object value = cn.get();                    if (value != null) {                        return value.toString();                    }                } catch (final NoSuchElementException ignore) {                                } catch (final NamingException ignore) {                                }            }        }        return null;    } catch (final InvalidNameException e) {        throw new SSLException(subjectPrincipal + " is not a valid X500 distinguished name");    }}
d4a8981f675bfedb26d9798c919a75b35cd53eca007e9157b680d986d613dabf
determineHostFormat
private static HostNameType determineHostFormat(final String host)
{    if (InetAddressUtils.isIPv4Address(host)) {        return HostNameType.IPv4;    }    String s = host;    if (s.startsWith("[") && s.endsWith("]")) {        s = host.substring(1, host.length() - 1);    }    if (InetAddressUtils.isIPv6Address(s)) {        return HostNameType.IPv6;    }    return HostNameType.DNS;}
2810007767e3f473dfae086bbb5307fa3dd8ac43937d8e723a1e0a7c483f2686
getSubjectAltNames
private static List<SubjectName> getSubjectAltNames(final X509Certificate cert)
{    try {        final Collection<List<?>> entries = cert.getSubjectAlternativeNames();        if (entries == null) {            return Collections.emptyList();        }        final List<SubjectName> result = new ArrayList<SubjectName>();        for (List<?> entry : entries) {            final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;            if (type != null) {                final String s = (String) entry.get(1);                result.add(new SubjectName(s, type));            }        }        return result;    } catch (final CertificateParsingException ignore) {        return Collections.emptyList();    }}
8052cf2ddff63c209e9f6e8a02b8456d38a125d1edb91a9b0993d4e8d9b5286f
normaliseAddress
private static String normaliseAddress(final String hostname)
{    if (hostname == null) {        return hostname;    }    try {        final InetAddress inetAddress = InetAddress.getByName(hostname);        return inetAddress.getHostAddress();    } catch (final UnknownHostException unexpected) {                return hostname;    }}
b516c58bc22bde695ccdef782f17985d051ddc0b89329e35483cf2a3a576c7fe
getAcceptedIssuers
public X509Certificate[] getAcceptedIssuers()
{    return x509ExtendedTrustManager.getAcceptedIssuers();}
16e9277ac57d5fe6e189065c3ae3c83edf85c1026762acd78c25b4d4bc609b48
checkClientTrusted
public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, socket);    if (clientHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
667ad37e23ad3f06b94be6a35f9dd0c4ba61749b50990e937593d385ceee3b1a
checkServerTrusted
public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, socket);    if (serverHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
76e5b494cb4e8b39ac99f3475a800e781ba0d8a5c74ea800a4c27566409e9504
checkClientTrusted
public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);    if (clientHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
07eccfc60db1ad1f6fef4a2260c64d2e379eaa3f5c44158da091fa99bbc38c79
checkServerTrusted
public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);    if (serverHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
90517f191cb750994284134e55560a7721c1ce0abce635b9fa82fea40199ddfe
checkClientTrusted
public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType);}
b4f8e51fdd88049429540611f80d79900cf027c7024dffc82a8eceb056d8fce8
checkServerTrusted
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType);}
d522b523f329cab74e048ff28b0a1789a6832f69123b12894ac1d6a8042332ef
performHostVerification
private void performHostVerification(InetAddress inetAddress, X509Certificate certificate) throws CertificateException
{    String hostAddress = "";    String hostName = "";    try {        hostAddress = inetAddress.getHostAddress();        hostnameVerifier.verify(hostAddress, certificate);    } catch (SSLException addressVerificationException) {        try {            LOG.debug("Failed to verify host address: {} attempting to verify host name with reverse dns lookup", hostAddress, addressVerificationException);            hostName = inetAddress.getHostName();            hostnameVerifier.verify(hostName, certificate);        } catch (SSLException hostnameVerificationException) {            LOG.error("Failed to verify host address: {}", hostAddress, addressVerificationException);            LOG.error("Failed to verify hostname: {}", hostName, hostnameVerificationException);            throw new CertificateException("Failed to verify both host address and host name", hostnameVerificationException);        }    }}
21c9924733703a2e1411e4cd736098aa9475917977aa98cbcbf83d5b549f7a10
isEphemeral
public boolean isEphemeral()
{    return ephemeral;}
51082cbef457914814c45af9c04d60062fa466efb61457cc2760d48593b9b54f
isSequential
public boolean isSequential()
{    return sequential;}
6b2052578c66d5ff043717230ce14a7e68db744b3eb96e71ba9884eaad7834a9
isContainer
public boolean isContainer()
{    return isContainer;}
02c4f91d26b4ead58f6ed871fd1eac57ee924915099b9def42a568fcef5e26c5
isTTL
public boolean isTTL()
{    return isTTL;}
ceb1350f2cfc7e25356fa1c9ec43d3470b134f19f0c8d3b6ac4d4b4654988b20
toFlag
public int toFlag()
{    return flag;}
c7bb0ffd5fb15ab1f73cd846e1d575c71e2ec15ae38d730fa92356cbc54b3b87
fromFlag
public static CreateMode fromFlag(int flag) throws KeeperException
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            String errMsg = "Received an invalid flag value: " + flag + " to convert to a CreateMode";            LOG.error(errMsg);            throw new KeeperException.BadArgumentsException(errMsg);    }}
759a9f3772c60e861d77e9f2ad274d12675abacb5425a1569c30486cbb487151
fromFlag
public static CreateMode fromFlag(int flag, CreateMode defaultMode)
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            return defaultMode;    }}
71dcee8caa732fdfbbc9042fbd951dc9dfd911ed9a4cabf0966856ac5de53dfc
getKey
public String getKey()
{    return k;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return v;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return k + "=" + v;}
a7dc10d1577cc4a33943d08780be3d27d00c19946e9c05376585ea9f57eb2a91
put
private static void put(List<Entry> l, String k, String v)
{    l.add(new Entry(k, v));}
51c8f24d8e7d09bfc6e5d65e55709e7d2b59f24543f4d5203907bbff9de7e0a2
list
public static List<Entry> list()
{    List<Entry> l = new ArrayList<Entry>();    put(l, "zookeeper.version", Version.getFullVersion());    try {        put(l, "host.name", InetAddress.getLocalHost().getCanonicalHostName());    } catch (UnknownHostException e) {        put(l, "host.name", "<NA>");    }    put(l, "java.version", System.getProperty("java.version", "<NA>"));    put(l, "java.vendor", System.getProperty("java.vendor", "<NA>"));    put(l, "java.home", System.getProperty("java.home", "<NA>"));    put(l, "java.class.path", System.getProperty("java.class.path", "<NA>"));    put(l, "java.library.path", System.getProperty("java.library.path", "<NA>"));    put(l, "java.io.tmpdir", System.getProperty("java.io.tmpdir", "<NA>"));    put(l, "java.compiler", System.getProperty("java.compiler", "<NA>"));    put(l, "os.name", System.getProperty("os.name", "<NA>"));    put(l, "os.arch", System.getProperty("os.arch", "<NA>"));    put(l, "os.version", System.getProperty("os.version", "<NA>"));    put(l, "user.name", System.getProperty("user.name", "<NA>"));    put(l, "user.home", System.getProperty("user.home", "<NA>"));    put(l, "user.dir", System.getProperty("user.dir", "<NA>"));        Runtime runtime = Runtime.getRuntime();    int mb = 1024 * 1024;    put(l, "os.memory.free", runtime.freeMemory() / mb + "MB");    put(l, "os.memory.max", runtime.maxMemory() / mb + "MB");    put(l, "os.memory.total", runtime.totalMemory() / mb + "MB");    return l;}
d1838a1b82eb17163464815eb30b62297f4f8e00d5e5db4d5527092847669f6f
logEnv
public static void logEnv(String msg, Logger log)
{    List<Entry> env = Environment.list();    for (Entry e : env) {        log.info(msg + e.toString());    }}
ca2d57977da61a2af025851f54283a22981d001c91998aee9b050a2a2400f049
complete
public int complete(String buffer, int cursor, List candidates)
{        buffer = buffer.substring(0, cursor);    String token = "";    if (!buffer.endsWith(" ")) {        String[] tokens = buffer.split(" ");        if (tokens.length != 0) {            token = tokens[tokens.length - 1];        }    }    if (token.startsWith("/")) {        return completeZNode(buffer, token, candidates);    }    return completeCommand(buffer, token, candidates);}
f68a77c8ca68b707708298321a44485c6c7631f135d722570ad58263c7ff383c
completeCommand
private int completeCommand(String buffer, String token, List<String> candidates)
{    for (String cmd : ZooKeeperMain.getCommands()) {        if (cmd.startsWith(token)) {            candidates.add(cmd);        }    }    return buffer.lastIndexOf(" ") + 1;}
df068ad2076737990fb5de524bd66da77302d4a50b1dfee87406a31a8a15c78a
completeZNode
private int completeZNode(String buffer, String token, List<String> candidates)
{    String path = token;    int idx = path.lastIndexOf("/") + 1;    String prefix = path.substring(idx);    try {                String dir = idx == 1 ? "/" : path.substring(0, idx - 1);        List<String> children = zk.getChildren(dir, false);        for (String child : children) {            if (child.startsWith(prefix)) {                candidates.add(child);            }        }    } catch (InterruptedException e) {        return 0;    } catch (KeeperException e) {        return 0;    }    Collections.sort(candidates);    return candidates.size() == 0 ? buffer.length() : buffer.lastIndexOf("/") + 1;}
6e3423f1df3113463495da0e0581b54c3a1c5acda65606665b614538c5951533
isLog4jJmxEnabled
private static boolean isLog4jJmxEnabled()
{    boolean enabled = false;    try {        Class.forName("org.apache.log4j.spi.LoggerRepository");        if (Boolean.getBoolean("zookeeper.jmx.log4j.disable")) {            LOG.info("Log4j found but jmx support is disabled.");        } else {            enabled = true;            LOG.info("Log4j found with jmx enabled.");        }    } catch (ClassNotFoundException e) {        LOG.info("Log4j not found.");    }    return enabled;}
c2553236b74861ff742482c9cf370e124b8eafb153dae58ad29d183db2ba75eb
registerLog4jMBeans
public static void registerLog4jMBeans() throws JMException
{    if (isLog4jJmxEnabled()) {        LOG.debug("registerLog4jMBeans()");        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();        try {                                    Object hdm = Class.forName("org.apache.log4j.jmx.HierarchyDynamicMBean").getConstructor().newInstance();            String mbean = System.getProperty("zookeeper.jmx.log4j.mbean", "log4j:hierarchy=default");            ObjectName mbo = new ObjectName(mbean);            mbs.registerMBean(hdm, mbo);                                                Object rootLogger = Class.forName("org.apache.log4j.Logger").getMethod("getRootLogger", (Class<?>[]) null).invoke(null, (Object[]) null);                        Object rootLoggerName = rootLogger.getClass().getMethod("getName", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);            hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, rootLoggerName);                                                            Object r = Class.forName("org.apache.log4j.LogManager").getMethod("getLoggerRepository", (Class<?>[]) null).invoke(null, (Object[]) null);                        Enumeration enumer = (Enumeration) r.getClass().getMethod("getCurrentLoggers", (Class<?>[]) null).invoke(r, (Object[]) null);            while (enumer.hasMoreElements()) {                Object logger = enumer.nextElement();                                Object loggerName = logger.getClass().getMethod("getName", (Class<?>[]) null).invoke(logger, (Object[]) null);                hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, loggerName);            }        } catch (Exception e) {            LOG.error("Problems while registering log4j jmx beans!", e);            throw new JMException(e.toString());        }    }}
cf9afbf2e64d2e01424dbcc83d15250f4b270c2d3f18be47ed0e47afee505288
setInstance
public static void setInstance(MBeanRegistry instance)
{    MBeanRegistry.instance = instance;}
953d20de8031e83cc88ae37cff20346b79bfe6c00931b3cfa05433b9c41a495a
getInstance
public static MBeanRegistry getInstance()
{    return instance;}
09f2789a7697ef56c1439fe620b49dfa9d6a0cd6bfa46b99d9f743634b1638e5
getPlatformMBeanServer
public MBeanServer getPlatformMBeanServer()
{    return mBeanServer;}
941c095abfdb711bc7c9342f949cd27a846b273c541e9f6bbfdad290c3dfaf9a
register
public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{    assert bean != null;    String path = null;    if (parent != null) {        path = mapBean2Path.get(parent);        assert path != null;    }    path = makeFullPath(path, parent);    if (bean.isHidden()) {        return;    }    ObjectName oname = makeObjectName(path, bean);    try {        synchronized (LOCK) {            mBeanServer.registerMBean(bean, oname);            mapBean2Path.put(bean, path);        }    } catch (JMException e) {        LOG.warn("Failed to register MBean " + bean.getName());        throw e;    }}
6cb681f3878b9a5e1b99c00508ad7a6c98ee9160c6d1f7fe2613eab8739a4b61
unregister
private void unregister(String path, ZKMBeanInfo bean) throws JMException
{    if (path == null) {        return;    }    if (!bean.isHidden()) {        final ObjectName objName = makeObjectName(path, bean);        LOG.debug("Unregister MBean [{}]", objName);        synchronized (LOCK) {            mBeanServer.unregisterMBean(objName);        }    }}
71ccb959edee53bbbfd4bc90be2dabf7b340035814a733c495fa216c97bc36a3
getRegisteredBeans
public Set<ZKMBeanInfo> getRegisteredBeans()
{    return new HashSet<ZKMBeanInfo>(mapBean2Path.keySet());}
3ef02c3c7a889b4038e716e194cd70f1d18a5d5932351af6058cb9904a11ce0c
unregister
public void unregister(ZKMBeanInfo bean)
{    if (bean == null) {        return;    }    String path = mapBean2Path.remove(bean);    try {        unregister(path, bean);    } catch (JMException e) {        LOG.warn("Error during unregister of [{}]", bean.getName(), e);    } catch (Throwable t) {        LOG.error("Unexpected exception during unregister of [{}]. It should be reviewed and fixed.", bean.getName(), t);    }}
973e1b47761f2c7a1afcd95c449c376ac44a0e130cbee536e8fd09c1931b65e5
makeFullPath
public String makeFullPath(String prefix, String... name)
{    StringBuilder sb = new StringBuilder(prefix == null ? "/" : (prefix.equals("/") ? prefix : prefix + "/"));    boolean first = true;    for (String s : name) {        if (s == null) {            continue;        }        if (!first) {            sb.append("/");        } else {            first = false;        }        sb.append(s);    }    return sb.toString();}
12e314b8ed393e0efebdd22eb9d4ae2aed7bf30051f0f393feb55fded62e498b
makeFullPath
protected String makeFullPath(String prefix, ZKMBeanInfo bean)
{    return makeFullPath(prefix, bean == null ? null : bean.getName());}
bb9507ec7276c3397703abde2f8e3e62587ecabf4d0e990d87732aa84d0ca95c
tokenize
private int tokenize(StringBuilder sb, String path, int index)
{    String[] tokens = path.split("/");    for (String s : tokens) {        if (s.length() == 0) {            continue;        }        sb.append("name").append(index++).append("=").append(s).append(",");    }    return index;}
08ae8c1178e82ac4ded84cfa7cb31129ecd645d4e9401176a118c54e73e91816
makeObjectName
protected ObjectName makeObjectName(String path, ZKMBeanInfo bean) throws MalformedObjectNameException
{    if (path == null) {        return null;    }    StringBuilder beanName = new StringBuilder(DOMAIN + ":");    int counter = 0;    counter = tokenize(beanName, path, counter);    tokenize(beanName, bean.getName(), counter);    beanName.deleteCharAt(beanName.length() - 1);    try {        return new ObjectName(beanName.toString());    } catch (MalformedObjectNameException e) {        LOG.warn("Invalid name \"" + beanName.toString() + "\" for class " + bean.getClass().toString());        throw e;    }}
aae28cc49d46f2b099282de882129726d25b867d0ab4739a365b2e9671c77604
create
public static KeeperException create(Code code, String path)
{    KeeperException r = create(code);    r.path = path;    return r;}
5bfea398a04f870620530ec0b2a01b9b5bb022dca1ed66706fbc79e3d18e9104
create
public static KeeperException create(int code, String path)
{    KeeperException r = create(Code.get(code));    r.path = path;    return r;}
843bc26deb02c5030068190037bc4fe65227fc2f47c1ce98d5177e4b5139a0b0
create
public static KeeperException create(int code)
{    return create(Code.get(code));}
56b28f4aab2ca6baf4d28d8380ac051301cccaf4a3fd22ebd973d2aef51854d5
create
public static KeeperException create(Code code)
{    switch(code) {        case SYSTEMERROR:            return new SystemErrorException();        case RUNTIMEINCONSISTENCY:            return new RuntimeInconsistencyException();        case DATAINCONSISTENCY:            return new DataInconsistencyException();        case CONNECTIONLOSS:            return new ConnectionLossException();        case MARSHALLINGERROR:            return new MarshallingErrorException();        case UNIMPLEMENTED:            return new UnimplementedException();        case OPERATIONTIMEOUT:            return new OperationTimeoutException();        case NEWCONFIGNOQUORUM:            return new NewConfigNoQuorum();        case RECONFIGINPROGRESS:            return new ReconfigInProgress();        case BADARGUMENTS:            return new BadArgumentsException();        case APIERROR:            return new APIErrorException();        case NONODE:            return new NoNodeException();        case NOAUTH:            return new NoAuthException();        case BADVERSION:            return new BadVersionException();        case NOCHILDRENFOREPHEMERALS:            return new NoChildrenForEphemeralsException();        case NODEEXISTS:            return new NodeExistsException();        case INVALIDACL:            return new InvalidACLException();        case AUTHFAILED:            return new AuthFailedException();        case NOTEMPTY:            return new NotEmptyException();        case SESSIONEXPIRED:            return new SessionExpiredException();        case INVALIDCALLBACK:            return new InvalidCallbackException();        case SESSIONMOVED:            return new SessionMovedException();        case NOTREADONLY:            return new NotReadOnlyException();        case EPHEMERALONLOCALSESSION:            return new EphemeralOnLocalSessionException();        case NOWATCHER:            return new NoWatcherException();        case RECONFIGDISABLED:            return new ReconfigDisabledException();        case SESSIONCLOSEDREQUIRESASLAUTH:            return new SessionClosedRequireAuthException();        case REQUESTTIMEOUT:            return new RequestTimeoutException();        case OK:        default:            throw new IllegalArgumentException("Invalid exception code");    }}
52c71cd098f5267549bfeb4d4d11128cd144a16616c12f5bac0f7df096e76b64
setCode
public void setCode(int code)
{    this.code = Code.get(code);}
2e357842a94cbe0053b9335d638b77fbb7cf048124996f871e25c3069c81a0b7
intValue
public int intValue()
{    return code;}
1e14346378eb0a5b1ab2ea927af0bb3b690baf94244ccb91ed075f90d19e8b53
get
public static Code get(int code)
{    return lookup.get(code);}
2a55add25b03e8d7221fae4a60044560f15e0cc6e99f7a1562c19bbdc5efce5a
getCodeMessage
 static String getCodeMessage(Code code)
{    switch(code) {        case OK:            return "ok";        case SYSTEMERROR:            return "SystemError";        case RUNTIMEINCONSISTENCY:            return "RuntimeInconsistency";        case DATAINCONSISTENCY:            return "DataInconsistency";        case CONNECTIONLOSS:            return "ConnectionLoss";        case MARSHALLINGERROR:            return "MarshallingError";        case NEWCONFIGNOQUORUM:            return "NewConfigNoQuorum";        case RECONFIGINPROGRESS:            return "ReconfigInProgress";        case UNIMPLEMENTED:            return "Unimplemented";        case OPERATIONTIMEOUT:            return "OperationTimeout";        case BADARGUMENTS:            return "BadArguments";        case APIERROR:            return "APIError";        case NONODE:            return "NoNode";        case NOAUTH:            return "NoAuth";        case BADVERSION:            return "BadVersion";        case NOCHILDRENFOREPHEMERALS:            return "NoChildrenForEphemerals";        case NODEEXISTS:            return "NodeExists";        case INVALIDACL:            return "InvalidACL";        case AUTHFAILED:            return "AuthFailed";        case NOTEMPTY:            return "Directory not empty";        case SESSIONEXPIRED:            return "Session expired";        case INVALIDCALLBACK:            return "Invalid callback";        case SESSIONMOVED:            return "Session moved";        case NOTREADONLY:            return "Not a read-only call";        case EPHEMERALONLOCALSESSION:            return "Ephemeral node on local session";        case NOWATCHER:            return "No such watcher";        case RECONFIGDISABLED:            return "Reconfig is disabled";        case SESSIONCLOSEDREQUIRESASLAUTH:            return "Session closed because client failed to authenticate";        default:            return "Unknown error " + code;    }}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code.code;}
09d4bb3e995e4ee85348291a3c9a1cc416f64f8cad383e58e26b1dfcbb8a735f
code
public Code code()
{    return code;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    if (path == null || path.isEmpty()) {        return "KeeperErrorCode = " + getCodeMessage(code);    }    return "KeeperErrorCode = " + getCodeMessage(code) + " for " + path;}
6e62b464f94bae3adb92aae1791a532d1ee5e7498cd058a9c9e0966bc0be75e3
setMultiResults
 void setMultiResults(List<OpResult> results)
{    this.results = results;}
d00a7ab5482fef29b3335caf15bc84cc8e668914c8f2a37027c261d14a49d0fa
getResults
public List<OpResult> getResults()
{    return results != null ? new ArrayList<OpResult>(results) : null;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LOG.info("TGT refresh thread started.");    while (true) {                KerberosTicket tgt = getTGT();        long now = Time.currentWallTime();        long nextRefresh;        Date nextRefreshDate;        if (tgt == null) {            nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;            nextRefreshDate = new Date(nextRefresh);            LOG.warn("No TGT found: will try again at {}", nextRefreshDate);        } else {            nextRefresh = getRefreshTime(tgt);            long expiry = tgt.getEndTime().getTime();            Date expiryDate = new Date(expiry);            if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {                Object[] logPayload = { expiryDate, principal, principal };                LOG.error("The TGT cannot be renewed beyond the next expiry date: {}." + "This process will not be able to authenticate new SASL connections after that " + "time (for example, it will not be authenticate a new connection with a Zookeeper " + "Quorum member).  Ask your system administrator to either increase the " + "'renew until' time by doing : 'modprinc -maxrenewlife {}' within " + "kadmin, or instead, to generate a keytab for {}. Because the TGT's " + "expiry cannot be further extended by refreshing, exiting refresh thread now.", logPayload);                return;            }                        if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {                                nextRefresh = now;            } else {                if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {                                        Date until = new Date(nextRefresh);                    Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);                    Object[] logPayload = { until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000) };                    LOG.warn("TGT refresh thread time adjusted from : {} to : {} since " + "the former is sooner than the minimum refresh interval (" + "{} seconds) from now.", logPayload);                }                nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);            }            nextRefreshDate = new Date(nextRefresh);            if (nextRefresh > expiry) {                Object[] logPayload = { nextRefreshDate, expiryDate };                LOG.error("next refresh: {} is later than expiry {}." + " This may indicate a clock skew problem. Check that this host and the KDC's " + "hosts' clocks are in sync. Exiting refresh thread.", logPayload);                return;            }        }        if (now == nextRefresh) {            LOG.info("refreshing now because expiry is before next scheduled refresh time.");        } else if (now < nextRefresh) {            Date until = new Date(nextRefresh);            LOG.info("TGT refresh sleeping until: {}", until.toString());            try {                Thread.sleep(nextRefresh - now);            } catch (InterruptedException ie) {                LOG.warn("TGT renewal thread has been interrupted and will exit.");                break;            }        } else {            LOG.error("nextRefresh:{} is in the past: exiting refresh thread. Check" + " clock sync between this host and KDC - (KDC's clock is likely ahead of this host)." + " Manual intervention will be required for this client to successfully authenticate." + " Exiting refresh thread.", nextRefreshDate);            break;        }        if (isUsingTicketCache) {            String cmd = zkConfig.getProperty(ZKConfig.KINIT_COMMAND, KINIT_COMMAND_DEFAULT);            String kinitArgs = "-R";            int retry = 1;            while (retry >= 0) {                try {                    LOG.debug("running ticket cache refresh command: {} {}", cmd, kinitArgs);                    Shell.execCommand(cmd, kinitArgs);                    break;                } catch (Exception e) {                    if (retry > 0) {                        --retry;                                                try {                            Thread.sleep(10 * 1000);                        } catch (InterruptedException ie) {                            LOG.error("Interrupted while renewing TGT, exiting Login thread");                            return;                        }                    } else {                        Object[] logPayload = { cmd, kinitArgs, e.toString(), e };                        LOG.warn("Could not renew TGT due to problem running shell command: '{}" + " {}'; exception was:{}. Exiting refresh thread.", logPayload);                        return;                    }                }            }        }        try {            int retry = 1;            while (retry >= 0) {                try {                    reLogin();                    break;                } catch (LoginException le) {                    if (retry > 0) {                        --retry;                                                try {                            Thread.sleep(10 * 1000);                        } catch (InterruptedException e) {                            LOG.error("Interrupted during login retry after LoginException:", le);                            throw le;                        }                    } else {                        LOG.error("Could not refresh TGT for principal: {}.", principal, le);                    }                }            }        } catch (LoginException le) {            LOG.error("Failed to refresh TGT: refresh thread exiting now.", le);            break;        }    }}
6b6d67f9f4edbc3234220aa1a58b523f2a5dfb506bb295f1990c97ea14931567
startThreadIfNeeded
public void startThreadIfNeeded()
{        if (t != null) {        t.start();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if ((t != null) && (t.isAlive())) {        t.interrupt();        try {            t.join();        } catch (InterruptedException e) {            LOG.warn("error while waiting for Login thread to shutdown: ", e);        }    }}
f36174daca49b76f0fe37b2200e55b491533846c9b27004c242fdf178a9802ff
getSubject
public Subject getSubject()
{    return subject;}
42d6af42ac97cef2f72aa691f8c9544481e90860e19110f54ffe770fc950fb6f
getLoginContextName
public String getLoginContextName()
{    return loginContextName;}
7bbcd620668da720c4a9540f190631f6fc8de270b3156cb0b808f75ad4ec4cb1
login
private synchronized LoginContext login(final String loginContextName) throws LoginException
{    if (loginContextName == null) {        throw new LoginException("loginContext name (JAAS file section header) was null. " + "Please check your java.security.login.auth.config (=" + System.getProperty("java.security.login.auth.config") + ") and your " + getLoginContextMessage());    }    LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);    loginContext.login();    LOG.info("{} successfully logged in.", loginContextName);    return loginContext;}
e2cade7f613f916d070a77154d2075de0a3ca95393a531db720b034471275275
getLoginContextMessage
private String getLoginContextMessage()
{    if (zkConfig instanceof ZKClientConfig) {        return ZKClientConfig.LOGIN_CONTEXT_NAME_KEY + "(=" + zkConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT) + ")";    } else {        return ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + "(=" + System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME) + ")";    }}
0bc241eda12dff93481e406a5662062267cd513125964099a7e3a3b22ea13eca
getRefreshTime
private long getRefreshTime(KerberosTicket tgt)
{    long start = tgt.getStartTime().getTime();    long expires = tgt.getEndTime().getTime();    LOG.info("TGT valid starting at:        {}", tgt.getStartTime().toString());    LOG.info("TGT expires:                  {}", tgt.getEndTime().toString());    long proposedRefresh = start + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));    if (proposedRefresh > expires) {                return Time.currentWallTime();    } else {        return proposedRefresh;    }}
8dc2e3b41de71c58eabcb1a6e3d50369d0d2522ca7a47528f215848f65960985
getTGT
private synchronized KerberosTicket getTGT()
{    Set<KerberosTicket> tickets = subject.getPrivateCredentials(KerberosTicket.class);    for (KerberosTicket ticket : tickets) {        KerberosPrincipal server = ticket.getServer();        if (server.getName().equals("krbtgt/" + server.getRealm() + "@" + server.getRealm())) {            LOG.debug("Client principal is \"{}\".", ticket.getClient().getName());            LOG.debug("Server principal is \"{}\".", ticket.getServer().getName());            return ticket;        }    }    return null;}
19bcf7c3ac3be92934ede72b7f38ed2df0f21352b796c769e0a4042637d440ce
hasSufficientTimeElapsed
private boolean hasSufficientTimeElapsed()
{    long now = Time.currentElapsedTime();    if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) {        LOG.warn("Not attempting to re-login since the last re-login was " + "attempted less than {} seconds before.", (MIN_TIME_BEFORE_RELOGIN / 1000));        return false;    }        setLastLogin(now);    return true;}
162d020e4159a241b36214108f777839655bd172a63f1e3ff2464a7142e50a1b
getLogin
private LoginContext getLogin()
{    return login;}
325b45918f430152870d954b961dd4a4ac05f97c596506177303c8323ed6aa27
setLogin
private void setLogin(LoginContext login)
{    this.login = login;}
bd284ad3c5c701407cfe286a6ff9664fe7b744799422dd554e9c83b3d293b6a4
setLastLogin
private void setLastLogin(long time)
{    lastLogin = time;}
3699404f9989e0fff7f2c10167239301f366261b7c0abe6d7d327c9a5fd8c1c7
getLastLogin
private long getLastLogin()
{    return lastLogin;}
b931fdab6b2f543ed9e95eb7863c5bd1458afbccf56f7229e2de42249551acf4
reLogin
private synchronized void reLogin() throws LoginException
{    if (!isKrbTicket) {        return;    }    LoginContext login = getLogin();    if (login == null) {        throw new LoginException("login must be done first");    }    if (!hasSufficientTimeElapsed()) {        return;    }    LOG.info("Initiating logout for {}", principal);    synchronized (Login.class) {                                login.logout();                        login = new LoginContext(loginContextName, getSubject());        LOG.info("Initiating re-login for {}", principal);        login.login();        setLogin(login);    }}
2ae8644b0d598be210759ac95e0d25b902bbdc486c5e7bd3605f253792caadef
inc
 void inc()
{    add(1);}
e390648924e726b491f298368a785005e79ae81a83407c47b8fbb9626eaf06b3
configure
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{}
aa23481d8bd90f78e49a5e500dec98490654ae5479cc9426a36d2ccccada8dcd
getRootContext
public MetricsContext getRootContext()
{    return rootMetricsContext;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{        rootMetricsContext.gauges.clear();}
340d939336a8d9d074f5b17fbef7be8130c1d436e0bd0ce104c85ee060ef513a
dump
public void dump(BiConsumer<String, Object> sink)
{    rootMetricsContext.dump(sink);}
45422fa668d7c89937d4e2e3d11a6b1d2aa4f0b27b1259483c201037b224b7bd
resetAllValues
public void resetAllValues()
{    rootMetricsContext.reset();}
702687f7d9c8156c6ae67a5c34889ae40738fdd8c92a96cf44cde6ca80353195
getContext
public MetricsContext getContext(String name)
{        return this;}
5633b30ec05c77f25df04f3a4f0bde17cec6bd0a93316213f7573b14662517ce
getCounter
public Counter getCounter(String name)
{    return counters.computeIfAbsent(name, (n) -> {        return new SimpleCounter(n);    });}
254579dd86e8fbfd5534b3e25545de1b8cc119d70e496fd140f89c15e6281723
registerGauge
public void registerGauge(String name, Gauge gauge)
{    Objects.requireNonNull(gauge, "Cannot register a null Gauge for " + name);    gauges.put(name, gauge);}
ca09db82e3501ebbcaedc48a0c02c7335db0c2414ec384400cad129347d1cafa
unregisterGauge
public void unregisterGauge(String name)
{    gauges.remove(name);}
f39b1e617a9e696e043e7fe728e9cd9d9b58881269c9c003588e8e380dccf4e6
getSummary
public Summary getSummary(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new AvgMinMaxCounter(name);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new AvgMinMaxPercentileCounter(name);        });    }}
3204b50d1074cce7c6a8cb89bb32e896ca6b94185b2b77cd79747f61f7476f6c
getSummarySet
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new AvgMinMaxCounterSet(name);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new AvgMinMaxPercentileCounterSet(name);        });    }}
f270712ee24b181c1fd27bcee139a347bd0849d3ef3fefac97dd33bf7c62afc1
dump
 void dump(BiConsumer<String, Object> sink)
{    gauges.forEach((name, metric) -> {        Number value = metric.get();        if (value != null) {            sink.accept(name, value);        }    });    counters.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    summaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });    summarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    counters.values().forEach(metric -> {        metric.reset();    });    basicSummaries.values().forEach(metric -> {        metric.reset();    });    summaries.values().forEach(metric -> {        metric.reset();    });    basicSummarySets.values().forEach(metric -> {        metric.reset();    });    summarySets.values().forEach(metric -> {        metric.reset();    });}
d250928c41bab14ce26c633a024438d3666ba6c4ecace462de4a659ccc14d0f5
startMetricsProvider
public static MetricsProvider startMetricsProvider(String metricsProviderClassName, Properties configuration) throws MetricsProviderLifeCycleException
{    try {        Class<?> clazz = Class.forName(metricsProviderClassName, true, Thread.currentThread().getContextClassLoader());        MetricsProvider metricsProvider = (MetricsProvider) clazz.getConstructor().newInstance();        metricsProvider.configure(configuration);        metricsProvider.start();        return metricsProvider;    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException error) {        LOG.error("Cannot boot MetricsProvider {}", metricsProviderClassName, error);        throw new MetricsProviderLifeCycleException("Cannot boot MetricsProvider " + metricsProviderClassName, error);    } catch (MetricsProviderLifeCycleException error) {        LOG.error("Cannot boot MetricsProvider {}", metricsProviderClassName, error);        throw error;    }}
e390648924e726b491f298368a785005e79ae81a83407c47b8fbb9626eaf06b3
configure
public void configure(Properties configuration) throws MetricsProviderLifeCycleException
{}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{}
aa23481d8bd90f78e49a5e500dec98490654ae5479cc9426a36d2ccccada8dcd
getRootContext
public MetricsContext getRootContext()
{    return NullMetricsContext.INSTANCE;}
340d939336a8d9d074f5b17fbef7be8130c1d436e0bd0ce104c85ee060ef513a
dump
public void dump(BiConsumer<String, Object> sink)
{}
45422fa668d7c89937d4e2e3d11a6b1d2aa4f0b27b1259483c201037b224b7bd
resetAllValues
public void resetAllValues()
{}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{}
702687f7d9c8156c6ae67a5c34889ae40738fdd8c92a96cf44cde6ca80353195
getContext
public MetricsContext getContext(String name)
{    return INSTANCE;}
5633b30ec05c77f25df04f3a4f0bde17cec6bd0a93316213f7573b14662517ce
getCounter
public Counter getCounter(String name)
{    return NullCounter.INSTANCE;}
254579dd86e8fbfd5534b3e25545de1b8cc119d70e496fd140f89c15e6281723
registerGauge
public void registerGauge(String name, Gauge gauge)
{}
ca09db82e3501ebbcaedc48a0c02c7335db0c2414ec384400cad129347d1cafa
unregisterGauge
public void unregisterGauge(String name)
{}
f39b1e617a9e696e043e7fe728e9cd9d9b58881269c9c003588e8e380dccf4e6
getSummary
public Summary getSummary(String name, DetailLevel detailLevel)
{    return NullSummary.INSTANCE;}
3204b50d1074cce7c6a8cb89bb32e896ca6b94185b2b77cd79747f61f7476f6c
getSummarySet
public SummarySet getSummarySet(String name, DetailLevel detailLevel)
{    return NullSummarySet.INSTANCE;}
a24034b47c6f1e5f1d730be81cd9c52cdc49c4b9d237e333c05693c18d193c31
add
public void add(long delta)
{}
9c296a9ae6604f1ab76b67812ec53c653913df94f0267698b3e9a72e90441ce2
get
public long get()
{    return 0;}
940396fdb6f99c2073f47f03306548efb7fba34e64d0d5e5b499d32e0f95375b
add
public void add(long value)
{}
8afe3bc5a20d23fed03deefb3f9c911c73f164c0931dbfda26a2ac5b69076546
add
public void add(String key, long value)
{}
891171d51dc249c8cc130848051e9adf15b4229c0148444ee3c9cede020e8876
iterator
public Iterator<Op> iterator()
{    return ops.iterator();}
2b4e81225db23fe0cd6938af4e0d6b2a474e20ec16e5d19d93e738d4fa1b291d
add
public void add(Op op) throws IllegalArgumentException
{    setOrCheckOpKind(op.getKind());    ops.add(op);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return ops.size();}
894044d0a111e9179486e7f72056619d7918c4d2bc401aa6af41a674a6203b82
getOpKind
public Op.OpKind getOpKind()
{    return opKind;}
41d9b982968c677394aa124556c58afa883bf15413d7c2c4cb673b80a9eb4fbe
setOrCheckOpKind
private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException
{    if (opKind == null) {        opKind = ok;    } else if (ok != opKind) {        throw new IllegalArgumentException("Mixing read and write operations (transactions)" + " is not allowed in a multi request.");    }}
566843ef1af04dc455f72e373a1918840165aef618d7d7aeed93483799525966
serialize
public void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (Op op : ops) {        MultiHeader h = new MultiHeader(op.getType(), false, -1);        h.serialize(archive, tag);        switch(op.getType()) {            case ZooDefs.OpCode.create:            case ZooDefs.OpCode.create2:            case ZooDefs.OpCode.createTTL:            case ZooDefs.OpCode.createContainer:            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.setData:            case ZooDefs.OpCode.check:            case ZooDefs.OpCode.getChildren:            case ZooDefs.OpCode.getData:                op.toRequestRecord().serialize(archive, tag);                break;            default:                throw new IOException("Invalid type of op");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
3cbffe607716e6e9fb7248f6fd559ef61a8d01cfe7a7e1a1f40d8017e84fdad7
deserialize
public void deserialize(InputArchive archive, String tag) throws IOException
{    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    try {        while (!h.getDone()) {            switch(h.getType()) {                case ZooDefs.OpCode.create:                case ZooDefs.OpCode.create2:                case ZooDefs.OpCode.createContainer:                    CreateRequest cr = new CreateRequest();                    cr.deserialize(archive, tag);                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));                    break;                case ZooDefs.OpCode.createTTL:                    CreateTTLRequest crTtl = new CreateTTLRequest();                    crTtl.deserialize(archive, tag);                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));                    break;                case ZooDefs.OpCode.delete:                    DeleteRequest dr = new DeleteRequest();                    dr.deserialize(archive, tag);                    add(Op.delete(dr.getPath(), dr.getVersion()));                    break;                case ZooDefs.OpCode.setData:                    SetDataRequest sdr = new SetDataRequest();                    sdr.deserialize(archive, tag);                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));                    break;                case ZooDefs.OpCode.check:                    CheckVersionRequest cvr = new CheckVersionRequest();                    cvr.deserialize(archive, tag);                    add(Op.check(cvr.getPath(), cvr.getVersion()));                    break;                case ZooDefs.OpCode.getChildren:                    GetChildrenRequest gcr = new GetChildrenRequest();                    gcr.deserialize(archive, tag);                    add(Op.getChildren(gcr.getPath()));                    break;                case ZooDefs.OpCode.getData:                    GetDataRequest gdr = new GetDataRequest();                    gdr.deserialize(archive, tag);                    add(Op.getData(gdr.getPath()));                    break;                default:                    throw new IOException("Invalid type of op");            }            h.deserialize(archive, tag);        }    } catch (IllegalArgumentException e) {        throw new IOException("Mixing different kind of ops");    }    archive.endRecord(tag);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiOperationRecord)) {        return false;    }    MultiOperationRecord that = (MultiOperationRecord) o;    if (ops != null) {        Iterator<Op> other = that.ops.iterator();        for (Op op : ops) {            boolean hasMoreData = other.hasNext();            if (!hasMoreData) {                return false;            }            Op otherOp = other.next();            if (!op.equals(otherOp)) {                return false;            }        }        return !other.hasNext();    } else {        return that.ops == null;    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int h = 1023;    for (Op op : ops) {        h = h * 25 + op.hashCode();    }    return h;}
66d5631301f463ad0b663c40064d71bfd8992b29e97aab1d4da01af08c6468fd
add
public void add(OpResult x)
{    results.add(x);}
7902ad7a53d4ee4f62a614621ed96377da585452634cb1804c0a382e926e4203
iterator
public Iterator<OpResult> iterator()
{    return results.iterator();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return results.size();}
566843ef1af04dc455f72e373a1918840165aef618d7d7aeed93483799525966
serialize
public void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (OpResult result : results) {        int err = result.getType() == ZooDefs.OpCode.error ? ((OpResult.ErrorResult) result).getErr() : 0;        new MultiHeader(result.getType(), false, err).serialize(archive, tag);        switch(result.getType()) {            case ZooDefs.OpCode.create:                new CreateResponse(((OpResult.CreateResult) result).getPath()).serialize(archive, tag);                break;            case ZooDefs.OpCode.create2:                OpResult.CreateResult createResult = (OpResult.CreateResult) result;                new Create2Response(createResult.getPath(), createResult.getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.check:                break;            case ZooDefs.OpCode.setData:                new SetDataResponse(((OpResult.SetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getChildren:                new GetChildrenResponse(((OpResult.GetChildrenResult) result).getChildren()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getData:                new GetDataResponse(((OpResult.GetDataResult) result).getData(), ((OpResult.GetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.error:                new ErrorResponse(((OpResult.ErrorResult) result).getErr()).serialize(archive, tag);                break;            default:                throw new IOException("Invalid type " + result.getType() + " in MultiResponse");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
3cbffe607716e6e9fb7248f6fd559ef61a8d01cfe7a7e1a1f40d8017e84fdad7
deserialize
public void deserialize(InputArchive archive, String tag) throws IOException
{    results = new ArrayList<OpResult>();    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    while (!h.getDone()) {        switch(h.getType()) {            case ZooDefs.OpCode.create:                CreateResponse cr = new CreateResponse();                cr.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr.getPath()));                break;            case ZooDefs.OpCode.create2:                Create2Response cr2 = new Create2Response();                cr2.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr2.getPath(), cr2.getStat()));                break;            case ZooDefs.OpCode.delete:                results.add(new OpResult.DeleteResult());                break;            case ZooDefs.OpCode.setData:                SetDataResponse sdr = new SetDataResponse();                sdr.deserialize(archive, tag);                results.add(new OpResult.SetDataResult(sdr.getStat()));                break;            case ZooDefs.OpCode.check:                results.add(new OpResult.CheckResult());                break;            case ZooDefs.OpCode.getChildren:                GetChildrenResponse gcr = new GetChildrenResponse();                gcr.deserialize(archive, tag);                results.add(new OpResult.GetChildrenResult(gcr.getChildren()));                break;            case ZooDefs.OpCode.getData:                GetDataResponse gdr = new GetDataResponse();                gdr.deserialize(archive, tag);                results.add(new OpResult.GetDataResult(gdr.getData(), gdr.getStat()));                break;            case ZooDefs.OpCode.error:                                ErrorResponse er = new ErrorResponse();                er.deserialize(archive, tag);                results.add(new OpResult.ErrorResult(er.getErr()));                break;            default:                throw new IOException("Invalid type " + h.getType() + " in MultiResponse");        }        h.deserialize(archive, tag);    }    archive.endRecord(tag);}
8764acae4e24a17271a7899ea1fcfb50781ea1712fab349017031a794f1572c4
getResultList
public List<OpResult> getResultList()
{    return results;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiResponse)) {        return false;    }    MultiResponse other = (MultiResponse) o;    if (results != null) {        Iterator<OpResult> i = other.results.iterator();        for (OpResult result : results) {            if (i.hasNext()) {                if (!result.equals(i.next())) {                    return false;                }            } else {                return false;            }        }        return !i.hasNext();    } else {        return other.results == null;    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = results.size();    for (OpResult result : results) {        hash = (hash * 35) + result.hashCode();    }    return hash;}
e55c2aa108b1b8a6764e6f1e780cb4a595ce7e99c94397a88beb0881d3a387c1
create
public static Op create(String path, byte[] data, List<ACL> acl, int flags)
{    return new Create(path, data, acl, flags);}
29ea876a1d915782b6fb3f80bd56a77847e9afb25d3f7543fe30eb86477a4543
create
public static Op create(String path, byte[] data, List<ACL> acl, int flags, long ttl)
{    CreateMode createMode = CreateMode.fromFlag(flags, CreateMode.PERSISTENT);    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, flags);}
a8a40822e6c5288a881f1ebcfeab75681ca5807637e408bc3127a7842dc7dad6
create
public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    return new Create(path, data, acl, createMode);}
e7c10f52476846157ee9ff483f87201f26da1582a37ce92f35206b8fae7768fd
create
public static Op create(String path, byte[] data, List<ACL> acl, CreateMode createMode, long ttl)
{    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, createMode);}
742fcfa15a79114179bae0d601df37da95a4f28cbd7c21874bebc1f77a2d5d24
delete
public static Op delete(String path, int version)
{    return new Delete(path, version);}
c7eb39bb56f7b4ab2720e967e932e124bc234289bd0cbad97302ad85707298c5
setData
public static Op setData(String path, byte[] data, int version)
{    return new SetData(path, data, version);}
2b272efcafc31e0311a0e095864710d287e949c3db727988906233b4ac45dd8f
check
public static Op check(String path, int version)
{    return new Check(path, version);}
8359c5329a86b844f8ab79a136352485aa3ed922b91a6be48f9b169b4a481621
getChildren
public static Op getChildren(String path)
{    return new GetChildren(path);}
a77dd6bf5c6898c5daf42d3a8a442304925632b44eef23cf282f720850e16113
getData
public static Op getData(String path)
{    return new GetData(path);}
e13ca6770d128854311e967cbfe111c5323a9155e542cbb6a563c89bfcce6811
getType
public int getType()
{    return type;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
096945050d19808309f29a866e71a072344a2112e013306fb4d9a7eea448b551
getKind
public OpKind getKind()
{    return opKind;}
14ad11c1600f989fb93d04719e7667fe2edc7e66c232cd54a1594f04c0c04176
validate
 void validate() throws KeeperException
{    PathUtils.validatePath(path);}
2c823b47ed413b3f1f72671712830cc7a0b963938886a5b668057312e5d71a17
getOpcode
private static int getOpcode(CreateMode createMode)
{    if (createMode.isTTL()) {        return ZooDefs.OpCode.createTTL;    }    return createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Create)) {        return false;    }    Create op = (Create) o;    boolean aclEquals = true;    Iterator<ACL> i = op.acl.iterator();    for (ACL acl : op.acl) {        boolean hasMoreData = i.hasNext();        if (!hasMoreData) {            aclEquals = false;            break;        }        ACL otherAcl = i.next();        if (!acl.equals(otherAcl)) {            aclEquals = false;            break;        }    }    return !i.hasNext() && getType() == op.getType() && Arrays.equals(data, op.data) && flags == op.flags && aclEquals;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data);}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new CreateRequest(getPath(), data, acl, flags);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new Create(path, data, acl, flags);}
14ad11c1600f989fb93d04719e7667fe2edc7e66c232cd54a1594f04c0c04176
validate
 void validate() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    return super.equals(o) && (o instanceof CreateTTL) && (ttl == ((CreateTTL) o).ttl);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return super.hashCode() + (int) (ttl ^ (ttl >>> 32));}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new CreateTTLRequest(getPath(), data, acl, flags, ttl);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new CreateTTL(path, data, acl, flags, ttl);}
14ad11c1600f989fb93d04719e7667fe2edc7e66c232cd54a1594f04c0c04176
validate
 void validate() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Delete)) {        return false;    }    Delete op = (Delete) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode() + version;}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new DeleteRequest(getPath(), version);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new Delete(path, version);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetData)) {        return false;    }    SetData op = (SetData) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath()) && Arrays.equals(data, op.data);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data) + version;}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new SetDataRequest(getPath(), data, version);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new SetData(path, data, version);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Check)) {        return false;    }    Check op = (Check) o;    return getType() == op.getType() && getPath().equals(op.getPath()) && version == op.version;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode() + version;}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new CheckVersionRequest(getPath(), version);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new Check(path, version);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildren)) {        return false;    }    GetChildren op = (GetChildren) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode();}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new GetChildrenRequest(getPath(), false);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new GetChildren(path);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetData)) {        return false;    }    GetData op = (GetData) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() + getPath().hashCode();}
f1c859e0fc25ab96405875f158d66c3a1e9d98b6f8bc80740ecd82a71e0a856c
toRequestRecord
public Record toRequestRecord()
{    return new GetDataRequest(getPath(), false);}
57af3b8a7c0485c7e9850faedae6d0ca6c20385d7844d98d8715210a9f71571d
withChroot
 Op withChroot(String path)
{    return new GetData(path);}
e13ca6770d128854311e967cbfe111c5323a9155e542cbb6a563c89bfcce6811
getType
public int getType()
{    return type;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return stat;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CreateResult)) {        return false;    }    CreateResult other = (CreateResult) o;    boolean statsAreEqual = stat == null && other.stat == null || (stat != null && other.stat != null && stat.getMzxid() == other.stat.getMzxid());    return getType() == other.getType() && path.equals(other.getPath()) && statsAreEqual;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (getType() * 35 + path.hashCode() + (stat == null ? 0 : stat.getMzxid()));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof DeleteResult)) {        return false;    }    DeleteResult opResult = (DeleteResult) o;    return getType() == opResult.getType();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType();}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return stat;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetDataResult)) {        return false;    }    SetDataResult other = (SetDataResult) o;    return getType() == other.getType() && stat.getMzxid() == other.stat.getMzxid();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (getType() * 35 + stat.getMzxid());}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CheckResult)) {        return false;    }    CheckResult other = (CheckResult) o;    return getType() == other.getType();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType();}
f9a07229383743359732fe042350b4fce5dce7729a470b5778b4b95d5c46a97a
getChildren
public List<String> getChildren()
{    return children;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildrenResult)) {        return false;    }    GetChildrenResult other = (GetChildrenResult) o;    return getType() == other.getType() && children.equals(other.children);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() * 35 + children.hashCode();}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return data == null ? null : Arrays.copyOf(data, data.length);}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return stat;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetDataResult)) {        return false;    }    GetDataResult other = (GetDataResult) o;    return getType() == other.getType() && stat.equals(other.stat) && Arrays.equals(data, other.data);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (getType() * 35 + stat.getMzxid() + Arrays.hashCode(data));}
db61b2b3baa01338e74fb4441ab52687918c58915f1df36759d698b5424d93ef
getErr
public int getErr()
{    return err;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof ErrorResult)) {        return false;    }    ErrorResult other = (ErrorResult) o;    return getType() == other.getType() && err == other.getErr();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getType() * 35 + err;}
f116e2792bb36364a30710ab6984e796ccf0fceecff2b5a2b4395d63b7ad7802
quotaPath
public static String quotaPath(String path)
{    return quotaZookeeper + path + "/" + limitNode;}
46ae7ddd31441b37a5d9a53626dc57965622cf823b683e41ad8738bf2776b9c9
statPath
public static String statPath(String path)
{    return quotaZookeeper + path + "/" + statNode;}
8be71802c20b7ee5c040cc24d804a9489d017c8b3eb3befc80a0d01ae9d378d1
handle
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            NameCallback nc = (NameCallback) callback;            nc.setName(nc.getDefaultName());        } else {            if (callback instanceof PasswordCallback) {                PasswordCallback pc = (PasswordCallback) callback;                if (password != null) {                    pc.setPassword(this.password.toCharArray());                } else {                    LOG.warn("Could not login: the {} is being asked for a password, but the ZooKeeper {}" + " code does not currently support obtaining a password from the user." + " Make sure that the {} is configured to use a ticket cache (using" + " the JAAS configuration setting 'useTicketCache=true)' and restart the {}. If" + " you still get this message after that, the TGT in the ticket cache has expired and must" + " be manually refreshed. To do so, first determine if you are using a password or a" + " keytab. If the former, run kinit in a Unix shell in the environment of the user who" + " is running this Zookeeper {} using the command" + " 'kinit <princ>' (where <princ> is the name of the {}'s Kerberos principal)." + " If the latter, do" + " 'kinit -k -t <keytab> <princ>' (where <princ> is the name of the Kerberos principal, and" + " <keytab> is the location of the keytab file). After manually refreshing your cache," + " restart this {}. If you continue to see this message after manually refreshing" + " your cache, ensure that your KDC host's clock is in sync with this host's clock.", entity, entity, entity, entity, entity, entity, entity);                }            } else {                if (callback instanceof RealmCallback) {                    RealmCallback rc = (RealmCallback) callback;                    rc.setText(rc.getDefaultText());                } else {                    if (callback instanceof AuthorizeCallback) {                        AuthorizeCallback ac = (AuthorizeCallback) callback;                        String authid = ac.getAuthenticationID();                        String authzid = ac.getAuthorizationID();                        if (authid.equals(authzid)) {                            ac.setAuthorized(true);                        } else {                            ac.setAuthorized(false);                        }                        if (ac.isAuthorized()) {                            ac.setAuthorizedID(authzid);                        }                    } else {                        throw new UnsupportedCallbackException(callback, "Unrecognized SASL " + entity + "Callback");                    }                }            }        }    }}
767f47d9f3851e85eb90c4f374c94e354d2af44098a2bc0973c0d427ee494b7f
getServerPrincipal
 static String getServerPrincipal(InetSocketAddress addr, ZKClientConfig clientConfig)
{    return getServerPrincipal(new WrapperInetSocketAddress(addr), clientConfig);}
73867fd2a0a8ddb5df4f0d8c7e9739207fd08291f4b723eaaee33ba0997a97e9
getServerPrincipal
 static String getServerPrincipal(WrapperInetSocketAddress addr, ZKClientConfig clientConfig)
{    String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME, ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);    String hostName = addr.getHostName();    boolean canonicalize = true;    String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);    try {        canonicalize = Boolean.parseBoolean(canonicalizeText);    } catch (IllegalArgumentException ea) {        LOG.warn("Could not parse config {} \"{}\" into a boolean using default {}", ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, canonicalizeText, canonicalize);    }    if (canonicalize) {        WrapperInetAddress ia = addr.getAddress();        if (ia == null) {            throw new IllegalArgumentException("Unable to canonicalize address " + addr + " because it's not resolvable");        }        String canonicalHostName = ia.getCanonicalHostName();                if (!canonicalHostName.equals(ia.getHostAddress())) {            hostName = canonicalHostName;        }        LOG.debug("Canonicalized address to {}", hostName);    }    String serverPrincipal = principalUserName + "/" + hostName;    return serverPrincipal;}
39d9cd6f38baa59fab797f91a6856e0162449a9f7cddd492a3b663cf6cbec3fe
getHostName
public String getHostName()
{    return addr.getHostName();}
c00e4dd121499daf174c75b50888e46afc56bc414936ed8c0fd57478d41cc83a
getAddress
public WrapperInetAddress getAddress()
{    InetAddress ia = addr.getAddress();    return ia == null ? null : new WrapperInetAddress(ia);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return addr.toString();}
0d5e4829f8b61657188ca50c9c4ca2eb0c7a78ca5bf0dcbb98c7b9ed64043e29
getCanonicalHostName
public String getCanonicalHostName()
{    return ia.getCanonicalHostName();}
11661e6b503561c53725f639557b055d0097d9f55c2bb973d1191d568bdc31fb
getHostAddress
public String getHostAddress()
{    return ia.getHostAddress();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return ia.toString();}
e3f349a3a5fa7c99d34af688e9283f5d84e9425eeaab6c47f6dbde2e79ca446b
createAdminServer
public static AdminServer createAdminServer()
{    if (!"false".equals(System.getProperty("zookeeper.admin.enableServer"))) {        try {            Class<?> jettyAdminServerC = Class.forName("org.apache.zookeeper.server.admin.JettyAdminServer");            Object adminServer = jettyAdminServerC.getConstructor().newInstance();            return (AdminServer) adminServer;        } catch (ClassNotFoundException e) {            LOG.warn("Unable to start JettyAdminServer", e);        } catch (InstantiationException e) {            LOG.warn("Unable to start JettyAdminServer", e);        } catch (IllegalAccessException e) {            LOG.warn("Unable to start JettyAdminServer", e);        } catch (InvocationTargetException e) {            LOG.warn("Unable to start JettyAdminServer", e);        } catch (NoSuchMethodException e) {            LOG.warn("Unable to start JettyAdminServer", e);        } catch (NoClassDefFoundError e) {            LOG.warn("Unable to load jetty, not starting JettyAdminServer", e);        }    }    return new DummyAdminServer();}
f2c10ee8e03d5ca750157d431be3edfd242b0a5ff9ad43b1194ff15b1bc1b80b
getPrimaryName
public String getPrimaryName()
{    return primaryName;}
e15efc5817da19b09b055cde221a7b6a757b190304945fdba322e25b39c4915e
getNames
public Set<String> getNames()
{    return names;}
5999360274d9a522474168c24725752a4aae8dc4e9365423eb9f82baf4400700
getDoc
public String getDoc()
{    return doc;}
2a5b0102466760b6b82f6f771d7ea28f5e7dbf919eac1949635d9175e5e507a9
isServerRequired
public boolean isServerRequired()
{    return serverRequired;}
493aa36d8e7838f0b2696b4473718cda2c9d92d1a4ba318622b108da262d62c8
initializeResponse
protected CommandResponse initializeResponse()
{    return new CommandResponse(primaryName);}
1ff8ab376c470e3ba8b2811633435b5556ac959d0795e9752c296a86c8405913
getCommand
public String getCommand()
{    return command;}
735d2bd2d31b5695cc6801e48a1e2b92cd0a4cc38870ad4f31df08f8a70419a7
getError
public String getError()
{    return error;}
f1073e5a8be0cb3af931fda3da26436d6e5c44af79bbcedbde062c11ebb043ef
put
public Object put(String key, Object value)
{    return data.put(key, value);}
4701a46b21145b1daa261533a4dbe1b61298359823932589a8cc2f5ff6d8bc69
putAll
public void putAll(Map<? extends String, ?> m)
{    data.putAll(m);}
65b9204a280022d9bd71027843cc94ed9c65b18b91c1965857d22b6e4c663772
toMap
public Map<String, Object> toMap()
{    Map<String, Object> m = new LinkedHashMap<String, Object>(data);    m.put(KEY_COMMAND, command);    m.put(KEY_ERROR, error);    m.putAll(data);    return m;}
3c1db14518431f817d4cda0f424c9ebb6156ecf879e4aab5287d05a25a13d9f6
registerCommand
public static void registerCommand(Command command)
{    for (String name : command.getNames()) {        Command prev = commands.put(name, command);        if (prev != null) {            LOG.warn("Re-registering command {} (primary name = {})", name, command.getPrimaryName());        }    }    primaryNames.add(command.getPrimaryName());}
dcd2a77d2c8e8e20c1a528b6d16c547c58fc11445a199b4534bfeb484fba4a18
runCommand
public static CommandResponse runCommand(String cmdName, ZooKeeperServer zkServer, Map<String, String> kwargs)
{    Command command = getCommand(cmdName);    if (command == null) {        return new CommandResponse(cmdName, "Unknown command: " + cmdName);    }    if (command.isServerRequired() && (zkServer == null || !zkServer.isRunning())) {        return new CommandResponse(cmdName, "This ZooKeeper instance is not currently serving requests");    }    return command.run(zkServer, kwargs);}
290d70a579679c45a5397d58854fb2582c69b35896e90e06ce09f3cd9884c169
getPrimaryNames
public static Set<String> getPrimaryNames()
{    return primaryNames;}
e5cbe9ddea34bb7be0a6c3141f6a4f300bb3b24a109724c22fe12336f14e5144
getCommand
public static Command getCommand(String cmdName)
{    return commands.get(cmdName);}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.getServerCnxnFactory().resetAllConnectionStats();    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.putAll(zkServer.getConf().toMap());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    ServerCnxnFactory serverCnxnFactory = zkServer.getServerCnxnFactory();    if (serverCnxnFactory != null) {        response.put("connections", serverCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("connections", Collections.emptyList());    }    ServerCnxnFactory secureServerCnxnFactory = zkServer.getSecureServerCnxnFactory();    if (secureServerCnxnFactory != null) {        response.put("secure_connections", secureServerCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("secure_connections", Collections.emptyList());    }    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("datadir_size", zkServer.getDataDirSize());    response.put("logdir_size", zkServer.getLogDirSize());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("expiry_time_to_session_ids", zkServer.getSessionExpiryMap());    response.put("session_id_to_ephemeral_paths", zkServer.getEphemerals());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    for (Entry e : Environment.list()) {        response.put(e.getKey(), e.getValue());    }    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("digests", zkServer.getZKDatabase().getDataTree().getDigestLog());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("tracemask", ZooTrace.getTextTraceLevel());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("initial_configuration", zkServer.getInitialConfig());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    SnapshotInfo info = zkServer.getTxnLogFactory().getLastSnapshotInfo();    response.put("zxid", Long.toHexString(info == null ? -1L : info.zxid));    response.put("timestamp", info == null ? -1L : info.timestamp);    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        response.put("is_leader", zkServer instanceof LeaderZooKeeperServer);        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        response.put("leader_id", peer.getLeaderId());        String leaderAddress = peer.getLeaderAddress();        response.put("leader_ip", leaderAddress != null ? leaderAddress : "");    } else {        response.put("error", "server is not initialized");    }    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.dumpMonitorValues(response::put);    ServerMetrics.getMetrics().getMetricsProvider().dump(response::put);    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        leader.resetObserverConnectionStats();    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        follower.resetObserverConnectionStats();    }    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    return initializeResponse();}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    long traceMask;    if (!kwargs.containsKey("traceMask")) {        response.put("error", "setTraceMask requires long traceMask argument");        return response;    }    try {        traceMask = Long.parseLong(kwargs.get("traceMask"));    } catch (NumberFormatException e) {        response.put("error", "setTraceMask requires long traceMask argument, got " + kwargs.get("traceMask"));        return response;    }    ZooTrace.setTextTraceLevel(traceMask);    response.put("tracemask", traceMask);    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    LOG.info("running stat");    response.put("version", Version.getFullVersion());    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    response.put("server_stats", zkServer.serverStats());    response.put("client_response", zkServer.serverStats().getClientResponseStats());    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("proposal_stats", leader.getProposalStats());    }    response.put("node_count", zkServer.getZKDatabase().getNodeCount());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = super.run(zkServer, kwargs);    response.put("connections", zkServer.getServerCnxnFactory().getAllConnectionInfo(true));    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.serverStats().reset();    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("synced_observers", leader.getObservingLearners().size());        response.put("observers", leader.getObservingLearnersInfo());        return response;    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        Integer syncedObservers = follower.getSyncedObserverSize();        if (syncedObservers != null) {            response.put("synced_observers", syncedObservers);            response.put("observers", follower.getSyncedObserversInfo());            return response;        }    }    response.put("synced_observers", 0);    response.put("observers", Collections.emptySet());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    Properties systemProperties = System.getProperties();    SortedMap<String, String> sortedSystemProperties = new TreeMap<>();    systemProperties.forEach((k, v) -> sortedSystemProperties.put(k.toString(), v.toString()));    response.putAll(sortedSystemProperties);    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        VotingView votingView = new VotingView(peer.getVotingView());        response.put("current_config", votingView);    } else {        response.put("current_config", Collections.emptyMap());    }    return response;}
7d519f1835befc830b534d2ea88e4486d860d7803731aac9ecf5ec23427ab36e
getView
public Map<Long, String> getView()
{    return view;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("session_id_to_watched_paths", dt.getWatches().toMap());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("path_to_session_ids", dt.getWatchesByPath().toMap());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.putAll(dt.getWatchesSummary().toMap());    return response;}
d4eab907962f5288822aee58b2186e320145d8de33a3e97c30d3f35aad374fc8
run
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        QuorumPeer.ZabState zabState = peer.getZabState();        QuorumVerifier qv = peer.getQuorumVerifier();        QuorumPeer.QuorumServer voter = qv.getVotingMembers().get(peer.getId());        boolean voting = (voter != null && voter.addr.equals(peer.getQuorumAddress()) && voter.electionAddr.equals(peer.getElectionAddress()));        response.put("voting", voting);        response.put("zabstate", zabState.name().toLowerCase());    } else {        response.put("voting", false);        response.put("zabstate", "");    }    return response;}
d706cf83075a9e6486bd2fb57d651282815deb706534dca6f40f22c619f708c4
start
public void start() throws AdminServerException
{}
d0febcdad943ae326eaab920d05d730c7f2304c4790f3c42f6a5841da98cedcc
shutdown
public void shutdown() throws AdminServerException
{}
afac4d24c946a5705092daf98ad092c6ea7752ee886983b9e2001f4b50357602
setZooKeeperServer
public void setZooKeeperServer(ZooKeeperServer zkServer)
{}
d706cf83075a9e6486bd2fb57d651282815deb706534dca6f40f22c619f708c4
start
public void start() throws AdminServerException
{    try {        server.start();    } catch (Exception e) {                        String message = String.format("Problem starting AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }    LOG.info("Started AdminServer on address {}, port {} and command URL {}", address, port, commandUrl);}
d0febcdad943ae326eaab920d05d730c7f2304c4790f3c42f6a5841da98cedcc
shutdown
public void shutdown() throws AdminServerException
{    try {        server.stop();    } catch (Exception e) {        String message = String.format("Problem stopping AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }}
afac4d24c946a5705092daf98ad092c6ea7752ee886983b9e2001f4b50357602
setZooKeeperServer
public void setZooKeeperServer(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
5a0fc5243f26938427ca93c0ceddb95da8d9092a44dc54454178170f1d780dbe
doGet
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{        String cmd = request.getPathInfo();    if (cmd == null || cmd.equals("/")) {                for (String link : commandLinks()) {            response.getWriter().println(link);            response.getWriter().println("<br/>");        }        return;    }        cmd = cmd.substring(1);        @SuppressWarnings("unchecked")    Map<String, String[]> parameterMap = request.getParameterMap();    Map<String, String> kwargs = new HashMap<String, String>();    for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {        kwargs.put(entry.getKey(), entry.getValue()[0]);    }        CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs);        CommandOutputter outputter = new JsonOutputter();    response.setStatus(HttpServletResponse.SC_OK);    response.setContentType(outputter.getContentType());    outputter.output(cmdResponse, response.getWriter());}
7a0e915cee967227aaf61f73080d8fce44da053211b20caae66137c049824553
commandLinks
private List<String> commandLinks()
{    List<String> links = new ArrayList<String>();    List<String> commands = new ArrayList<String>(Commands.getPrimaryNames());    Collections.sort(commands);    for (String command : commands) {        String url = commandUrl + "/" + command;        links.add(String.format("<a href=\"%s\">%s</a>", url, command));    }    return links;}
baea39c86756a5efaaec8e2f01175d687e0a60e86379d9b91d98a3d4089abf86
getContentType
public String getContentType()
{    return "application/json";}
e9b54233ee6bdfee54a4a44c1d71cdb0202d11f5a482bacceda395fd4220511c
output
public void output(CommandResponse response, PrintWriter pw)
{    try {        mapper.writeValue(pw, response.toMap());    } catch (JsonGenerationException e) {        LOG.warn("Exception writing command response to JSON:", e);        pw.write(ERROR_RESPONSE);    } catch (JsonMappingException e) {        LOG.warn("Exception writing command response to JSON:", e);        pw.write(ERROR_RESPONSE);    } catch (IOException e) {        LOG.warn("Exception writing command response to JSON:", e);        pw.write(ERROR_RESPONSE);    }}
932c7deb6f166bae646eeeb2a602d70f876a6d84fb955006b41c6e45c5b97bab
getLocalAddress
public InetSocketAddress getLocalAddress()
{    return endPoint.getLocalAddress();}
e28fc2fbf4c8cb69d4d262f3d5df15a56ca383ddf8fcf24289608db6521e7a50
getRemoteAddress
public InetSocketAddress getRemoteAddress()
{    return endPoint.getRemoteAddress();}
19a24880b630c5416795a9247f56f3014ca8e567f85c7b8e4d6760590c45fccd
isOpen
public boolean isOpen()
{    return endPoint.isOpen();}
28797d28590c7b9b5a091d3994ed9ba53bdbd19be422581078b1dc07540148e3
getCreatedTimeStamp
public long getCreatedTimeStamp()
{    return endPoint.getCreatedTimeStamp();}
3bee5e57df98b10b8e49173c231df7f5742d55cd1b88f85d1cf0e34ef1bf0543
isOutputShutdown
public boolean isOutputShutdown()
{    return endPoint.isOutputShutdown();}
7aafc1c6f5950919631c274b5c5a50fdcf7d9da41e3e3409be448145827e023b
isInputShutdown
public boolean isInputShutdown()
{    return endPoint.isInputShutdown();}
9dc999adb9a67e52ce98fa43efe245d5388279f6d9250cb96f2f6bdf57ca5939
shutdownOutput
public void shutdownOutput()
{    endPoint.shutdownOutput();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    endPoint.close();}
879778cafd2e45e66e028d2e5d76d66e34d77dbb7c89299336f77c6a563d8017
getTransport
public Object getTransport()
{    return endPoint.getTransport();}
c0f541dbf5b74e7e6c071723b80cbf739faed664d40d19e7c028a63a009d0b09
getIdleTimeout
public long getIdleTimeout()
{    return endPoint.getIdleTimeout();}
e5cd3d66d722b9b2c7fbb750d7cc216a3157c176d700d9e859ce7ffe2547109f
getConnection
public Connection getConnection()
{    return endPoint.getConnection();}
32cf67ae5512b7dce5fd5536458e7fcd690dcc4d06b674a62f40f7a15a60de5f
onOpen
public void onOpen()
{    endPoint.onOpen();}
57d0024f83e93b42a9f21be42be18af0be352f92feb608172b4a1b865026e409
onClose
public void onClose()
{    endPoint.onClose();}
7c9c491559170cc8dd5bba80f116700009ec5822c39d3053c4ce5497908ce3c3
isOptimizedForDirectBuffers
public boolean isOptimizedForDirectBuffers()
{    return endPoint.isOptimizedForDirectBuffers();}
07f591e5cf94496997d06f98987a9e4ba8f69465f28e0c508d80a2f7d944544f
isFillInterested
public boolean isFillInterested()
{    return endPoint.isFillInterested();}
09034498a7695c1cae4eee7538987b306033e8cd945b993bc080baee59c4e697
tryFillInterested
public boolean tryFillInterested(Callback v)
{    return endPoint.tryFillInterested(v);}
e4acb421c0bd262357f6ebe62777a584f86ad240b9efa940dddf4402578dbed4
flush
public boolean flush(ByteBuffer... v) throws IOException
{    return endPoint.flush(v);}
5314e9677916c64558de4918e30def13e1781614165ddc7d7daebeffede35f63
setIdleTimeout
public void setIdleTimeout(long v)
{    endPoint.setIdleTimeout(v);}
baae8812ccdd6deed7270eb8844aa875f07aeb0b21acc3f17167112d3511e4c6
write
public void write(Callback v, ByteBuffer... b) throws WritePendingException
{    endPoint.write(v, b);}
6e253b8ca10f67c45a7afa1f8f12f0936db523db1c3a107188c6c4599b105530
setConnection
public void setConnection(Connection v)
{    endPoint.setConnection(v);}
156629f364eb6daf3c0b6145c77ee1e4c3280cab3d1fda12b833b127921433d0
upgrade
public void upgrade(Connection v)
{    endPoint.upgrade(v);}
5301db4f0ba63e3aaef7931f779c3e0f4ff1156b3900b28f68305ac3199c783a
fillInterested
public void fillInterested(Callback v) throws ReadPendingException
{    endPoint.fillInterested(v);}
929e87c88484b1984ff2c75bcdbbe5476cde484e5ba5f5581e4c6d074d9fbdaa
readAhead
private synchronized void readAhead() throws IOException
{    if (leftToRead > 0) {        int n = 0;        do {            n = endPoint.fill(start);        } while (n == 0 && endPoint.isOpen() && !endPoint.isInputShutdown());        if (n == -1) {            leftToRead = -1;        } else {            leftToRead -= n;        }        if (leftToRead <= 0) {            start.rewind();        }    }}
652b25756ccf19c5f202e5fb2465b3ead27c0151361336078098d24d53be0357
readFromStart
private int readFromStart(final ByteBuffer dst) throws IOException
{    final int n = Math.min(dst.remaining(), start.remaining());    if (n > 0) {        dst.put(bytes, start.position(), n);        start.position(start.position() + n);        dst.flip();    }    return n;}
19f362855d1d84dda0b3c0a29b6530c5511015a87a0f165d62693459b6a007a6
fill
public synchronized int fill(final ByteBuffer dst) throws IOException
{    throwPendingException();    if (leftToRead > 0) {        readAhead();    }    if (leftToRead > 0) {        return 0;    }    final int sr = start.remaining();    if (sr > 0) {        dst.compact();        final int n = readFromStart(dst);        if (n < sr) {            return n;        }    }    return sr + endPoint.fill(dst);}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    if (pendingException == null) {        try {            readAhead();        } catch (IOException e) {            pendingException = e;        }    }    byte[] ret = new byte[bytes.length];    System.arraycopy(bytes, 0, ret, 0, ret.length);    return ret;}
b15edf7d85249da8bf90779810039ac7d753ad1f7a1107fa1d13c6ea134ed50b
throwPendingException
private void throwPendingException() throws IOException
{    if (pendingException != null) {        IOException e = pendingException;        pendingException = null;        throw e;    }}
4b4e0bebedcc0489e7d90c08e8151a64fe128831922619cf126abd1b0696a810
doStart
protected void doStart() throws Exception
{    super.doStart();    SSLEngine engine = this.sslContextFactory.newSSLEngine();    SSLSession session = engine.getSession();    engine.setUseClientMode(false);    if (session.getPacketBufferSize() > this.getInputBufferSize()) {        this.setInputBufferSize(session.getPacketBufferSize());    }}
22a2f813ece569932f39277cd9289714d8d36db003b1120bbaf7b829e3080c08
newConnection
public Connection newConnection(Connector connector, EndPoint realEndPoint)
{    ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);    byte[] bytes = aheadEndpoint.getBytes();    boolean isSSL;    if (bytes == null || bytes.length == 0) {        isSSL = false;        LOG.warn("Incoming connection has no data");    } else {                byte b = bytes[0];                isSSL = b == 0x16;    }    LOG.debug(String.format("UnifiedConnectionFactory: newConnection() with SSL = %b", isSSL));    EndPoint plainEndpoint;    SslConnection sslConnection;    if (isSSL) {        SSLEngine engine = this.sslContextFactory.newSSLEngine(aheadEndpoint.getRemoteAddress());        engine.setUseClientMode(false);        sslConnection = this.newSslConnection(connector, aheadEndpoint, engine);        sslConnection.setRenegotiationAllowed(this.sslContextFactory.isRenegotiationAllowed());        this.configure(sslConnection, connector, aheadEndpoint);        plainEndpoint = sslConnection.getDecryptedEndPoint();    } else {        sslConnection = null;        plainEndpoint = aheadEndpoint;    }    ConnectionFactory next = connector.getConnectionFactory(nextProtocol);    Connection connection = next.newConnection(connector, plainEndpoint);    plainEndpoint.setConnection(connection);    return (sslConnection == null) ? connection : sslConnection;}
fab4522a31d75c6843b1bea3a408104f9127c66a0bbc8d2dc46d9e6c9b0f79e0
newSslConnection
protected SslConnection newSslConnection(final Connector connector, final EndPoint endPoint, final SSLEngine engine)
{    return new SslConnection(connector.getByteBufferPool(), connector.getExecutor(), endPoint, engine);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("%s@%x{%s->%s}", this.getClass().getSimpleName(), this.hashCode(), this.getProtocol(), this.nextProtocol);}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "digest";}
52bfa4bd603fedf18ccb28d3dea7376336308c745ed32d52c8249d2006ac345b
base64Encode
private static String base64Encode(byte[] b)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < b.length; ) {        int pad = 0;        int v = (b[i++] & 0xff) << 16;        if (i < b.length) {            v |= (b[i++] & 0xff) << 8;        } else {            pad++;        }        if (i < b.length) {            v |= (b[i++] & 0xff);        } else {            pad++;        }        sb.append(encode(v >> 18));        sb.append(encode(v >> 12));        if (pad < 2) {            sb.append(encode(v >> 6));        } else {            sb.append('=');        }        if (pad < 1) {            sb.append(encode(v));        } else {            sb.append('=');        }    }    return sb.toString();}
a75cb58c36330533e50fc356242bdcea463e825a4a0c3eee2247109791f6c8f0
encode
private static char encode(int i)
{    i &= 0x3f;    if (i < 26) {        return (char) ('A' + i);    }    if (i < 52) {        return (char) ('a' + i - 26);    }    if (i < 62) {        return (char) ('0' + i - 52);    }    return i == 62 ? '+' : '/';}
acc41fbbbe6f2750b7837d825a61b0b58403378342fe15d1550ddd2d39e6a3ad
generateDigest
public static String generateDigest(String idPassword) throws NoSuchAlgorithmException
{    String[] parts = idPassword.split(":", 2);    byte[] digest = MessageDigest.getInstance("SHA1").digest(idPassword.getBytes());    return parts[0] + ":" + base64Encode(digest);}
27ca6a1cc3eb3d3e1d05fbf5c216c12d3bcdfd1651a9c56f35f8c85fec4f6357
handleAuthentication
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    String id = new String(authData);    try {        String digest = generateDigest(id);        if (digest.equals(superDigest)) {            cnxn.addAuthInfo(new Id("super", ""));        }        cnxn.addAuthInfo(new Id(getScheme(), digest));        return KeeperException.Code.OK;    } catch (NoSuchAlgorithmException e) {        LOG.error("Missing algorithm", e);    }    return KeeperException.Code.AUTHFAILED;}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return true;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    String[] parts = id.split(":");    return parts.length == 2;}
3c3624d075688087970147fcb734f865536c936f2750ee30da74f1d7cf875dd1
matches
public boolean matches(String id, String aclExpr)
{    return id.equals(aclExpr);}
57b4e2b88c8d9ddbd04b81bfaaa0d3e0cbe35bfe31de7cca329d4d11b3c6bdcb
main
public static void main(String[] args) throws NoSuchAlgorithmException
{    for (int i = 0; i < args.length; i++) {        System.out.println(args[i] + "->" + generateDigest(args[i]));    }}
0aa2e84331dd30b23d347529fb4dd63dae91035fd0114a4ee7017a0c3f31bdec
abort
public boolean abort()
{    return false;}
436e987409960f71dfda90eb76e058d755c7b8dd0f2dc24e7c506587d6ec17d3
commit
public boolean commit()
{    return true;}
1a13eca94985a5a410f4f24caf9cd8b1c095412181497df706d9c24e861fc775
initialize
public void initialize(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
{    if (options.containsKey("username")) {                this.subject = subject;        String username = (String) options.get("username");        this.subject.getPublicCredentials().add(username);        String password = (String) options.get("password");        this.subject.getPrivateCredentials().add(password);    }    return;}
746ed27a49f65ef236460aa9c45cc6355ab69d64148e7d4cdc17a4cda8f06b62
logout
public boolean logout()
{    return true;}
e80355f6477694cedd009adbc5d175aaa7171b0ad76f4c9a84e6593f1c867b5d
login
public boolean login()
{        return true;}
3f7b66641c3cca72ac05b4cee812a23d98302969cb8b218eaaa5456eb7ca03b1
setEnsembleNames
public void setEnsembleNames(String namesCSV)
{    ensembleNames = new HashSet<String>();    for (String name : namesCSV.split(",")) {        ensembleNames.add(name.trim());    }}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "ensemble";}
27ca6a1cc3eb3d3e1d05fbf5c216c12d3bcdfd1651a9c56f35f8c85fec4f6357
handleAuthentication
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    if (authData == null || authData.length == 0) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    String receivedEnsembleName = new String(authData);    if (ensembleNames == null) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    if (ensembleNames.contains(receivedEnsembleName)) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SUCCESS.add(1);        return KeeperException.Code.OK;    }    long currentTime = System.currentTimeMillis();    if (lastFailureLogged + MIN_LOGGING_INTERVAL_MS < currentTime) {        String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();        LOG.warn("Unexpected ensemble name: ensemble name: {} client ip: {}", receivedEnsembleName, id);        lastFailureLogged = currentTime;    }    /*         * we are doing a close here rather than returning some other error         * since we want the client to choose another server to connect to. if         * we return an error, the client will get a fatal auth error and         * shutdown.         */    ServerMetrics.getMetrics().ENSEMBLE_AUTH_FAIL.add(1);    cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    return KeeperException.Code.BADARGUMENTS;}
3c3624d075688087970147fcb734f865536c936f2750ee30da74f1d7cf875dd1
matches
public boolean matches(String id, String aclExpr)
{    return false;}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return false;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    return false;}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "ip";}
27ca6a1cc3eb3d3e1d05fbf5c216c12d3bcdfd1651a9c56f35f8c85fec4f6357
handleAuthentication
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();    cnxn.addAuthInfo(new Id(getScheme(), id));    return KeeperException.Code.OK;}
e8e27528d30f13b230f371b1934172b30ac769ea4d6ab3441d043f8c12f66faa
addr2Bytes
private byte[] addr2Bytes(String addr)
{    byte[] b = v4addr2Bytes(addr);        return b;}
ccb832335bacffe426d3bb860709815b4b6ca82b96740fcf116d40985abf415a
v4addr2Bytes
private byte[] v4addr2Bytes(String addr)
{    String[] parts = addr.split("\\.", -1);    if (parts.length != 4) {        return null;    }    byte[] b = new byte[4];    for (int i = 0; i < 4; i++) {        try {            int v = Integer.parseInt(parts[i]);            if (v >= 0 && v <= 255) {                b[i] = (byte) v;            } else {                return null;            }        } catch (NumberFormatException e) {            return null;        }    }    return b;}
0294434228e0bd90e4d947470c9447f26bd33f738b32edc624652216b96081f9
mask
private void mask(byte[] b, int bits)
{    int start = bits / 8;    int startMask = (1 << (8 - (bits % 8))) - 1;    startMask = ~startMask;    while (start < b.length) {        b[start] &= startMask;        startMask = 0;        start++;    }}
3c3624d075688087970147fcb734f865536c936f2750ee30da74f1d7cf875dd1
matches
public boolean matches(String id, String aclExpr)
{    String[] parts = aclExpr.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    int bits = aclAddr.length * 8;    if (parts.length == 2) {        try {            bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    mask(aclAddr, bits);    byte[] remoteAddr = addr2Bytes(id);    if (remoteAddr == null) {        return false;    }    mask(remoteAddr, bits);    for (int i = 0; i < remoteAddr.length; i++) {        if (remoteAddr[i] != aclAddr[i]) {            return false;        }    }    return true;}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return false;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    String[] parts = id.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    if (parts.length == 2) {        try {            int bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    return true;}
3ab8f577f24b13a1ae531f8b4e2f05bd89eb5cabc788b2606d5e9b556dc67b53
getDefaultRealm
public String getDefaultRealm()
{    return defaultRealm;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder();    result.append(serviceName);    if (hostName != null) {        result.append('/');        result.append(hostName);    }    if (realm != null) {        result.append('@');        result.append(realm);    }    return result.toString();}
f75495abe1583cc2df4944c282c6a55c229516fe8ca77ba5d21036bf9eae604d
getServiceName
public String getServiceName()
{    return serviceName;}
39d9cd6f38baa59fab797f91a6856e0162449a9f7cddd492a3b663cf6cbec3fe
getHostName
public String getHostName()
{    return hostName;}
f1c45a4c4f150639a8cd469fed7c91e49bb2bc490a1fc61a7036b915aae5e0b2
getRealm
public String getRealm()
{    return realm;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buf = new StringBuilder();    if (isDefault) {        buf.append("DEFAULT");    } else {        buf.append("RULE:[");        buf.append(numOfComponents);        buf.append(':');        buf.append(format);        buf.append(']');        if (match != null) {            buf.append('(');            buf.append(match);            buf.append(')');        }        if (fromPattern != null) {            buf.append("s/");            buf.append(fromPattern);            buf.append('/');            buf.append(toPattern);            buf.append('/');            if (repeat) {                buf.append('g');            }        }    }    return buf.toString();}
470fc8c247d1ef491824986c1a9658d6fa291071fd3cefbea11a4f91a2d95d26
replaceParameters
 static String replaceParameters(String format, String[] params) throws BadFormatString
{    Matcher match = parameterPattern.matcher(format);    int start = 0;    StringBuilder result = new StringBuilder();    while (start < format.length() && match.find(start)) {        result.append(match.group(1));        String paramNum = match.group(3);        if (paramNum != null) {            try {                int num = Integer.parseInt(paramNum);                if (num < 0 || num > params.length) {                    throw new BadFormatString(String.format("index %d from %s is outside of the valid range 0 to %d", num, format, (params.length - 1)));                }                result.append(params[num]);            } catch (NumberFormatException nfe) {                throw new BadFormatString("bad format in username mapping in " + paramNum, nfe);            }        }        start = match.end();    }    return result.toString();}
641b25fbe434a6160a1303b4d493225e84e0561c9cf2b263b8d1be478bb41c8f
replaceSubstitution
 static String replaceSubstitution(String base, Pattern from, String to, boolean repeat)
{    Matcher match = from.matcher(base);    if (repeat) {        return match.replaceAll(to);    } else {        return match.replaceFirst(to);    }}
41f1fe9a6560ecc406b270542a0564f2c7b7545e91a6f676afb6c71da8f25ab7
apply
 String apply(String[] params) throws IOException
{    String result = null;    if (isDefault) {        if (defaultRealm.equals(params[0])) {            result = params[1];        }    } else if (params.length - 1 == numOfComponents) {        String base = replaceParameters(format, params);        if (match == null || match.matcher(base).matches()) {            if (fromPattern == null) {                result = base;            } else {                result = replaceSubstitution(base, fromPattern, toPattern, repeat);            }        }    }    if (result != null && nonSimplePattern.matcher(result).find()) {        throw new NoMatchingRule("Non-simple name " + result + " after auth_to_local rule " + this);    }    return result;}
d57c7bac33b2003e3ef956747d2d05a455971aa9ce6abfb1ddac007875d41156
parseRules
 static List<Rule> parseRules(String rules)
{    List<Rule> result = new ArrayList<Rule>();    String remaining = rules.trim();    while (remaining.length() > 0) {        Matcher matcher = ruleParser.matcher(remaining);        if (!matcher.lookingAt()) {            throw new IllegalArgumentException("Invalid rule: " + remaining);        }        if (matcher.group(2) != null) {            result.add(new Rule());        } else {            result.add(new Rule(Integer.parseInt(matcher.group(4)), matcher.group(5), matcher.group(7), matcher.group(9), matcher.group(10), "g".equals(matcher.group(11))));        }        remaining = remaining.substring(matcher.end());    }    return result;}
399ccacea0a8eced167bf3217b61171ba8091db6045199ef13e5b0f3f531c8c8
setConfiguration
public static void setConfiguration() throws IOException
{    String ruleString = System.getProperty("zookeeper.security.auth_to_local", "DEFAULT");    rules = parseRules(ruleString);}
a4bcd357c4b6e55565d96413a02a85951892a348bc6909568067a40d077b7f1a
getShortName
public String getShortName() throws IOException
{    String[] params;    if (hostName == null) {                if (realm == null) {            return serviceName;        }        params = new String[] { realm, serviceName };    } else {        params = new String[] { realm, serviceName, hostName };    }    for (Rule r : rules) {        String result = r.apply(params);        if (result != null) {            return result;        }    }    throw new NoMatchingRule("No rules applied to " + toString());}
8610b56de43e2762b102e0f98b8040c59c2407c8287f89e9aae193e9a225d5ff
printRules
 static void printRules() throws IOException
{    int i = 0;    for (Rule r : rules) {        System.out.println(++i + " " + r);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    for (String arg : args) {        KerberosName name = new KerberosName(arg);        System.out.println("Name: " + name + " to " + name.getShortName());    }}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "key";}
0e49442de81ad7047ed79525dac242934296b08ed2395f30955b7c09b00c4629
getKey
private byte[] getKey(ZooKeeperServer zks)
{    ZKDatabase db = zks.getZKDatabase();    if (db != null) {        try {            Stat stat = new Stat();            return db.getData("/key", stat, null);        } catch (NoNodeException e) {            LOG.error("getData failed", e);        }    }    return null;}
6963a41eecc07eb8cae33ea10d10eeb78a512d98044dc93014c19e0c7aa40d35
validate
private boolean validate(byte[] key, byte[] auth)
{        try {        String keyStr = new String(key, StandardCharsets.UTF_8);        String authStr = new String(auth, StandardCharsets.UTF_8);        int keyVal = Integer.parseInt(keyStr);        int authVal = Integer.parseInt(authStr);        if (keyVal != 0 && ((authVal % keyVal) != 0)) {            return false;        }    } catch (NumberFormatException nfe) {        LOG.error("bad formatting", nfe);        return false;    }    return true;}
1669fb76a6b52a87bddc0e7c4afaebcb37435836956a61fdf6d1d00980e42f29
handleAuthentication
public KeeperException.Code handleAuthentication(ServerObjs serverObjs, byte[] authData)
{    byte[] key = getKey(serverObjs.getZks());    String authStr = "";    String keyStr = "";    try {        authStr = new String(authData, StandardCharsets.UTF_8);    } catch (Exception e) {        LOG.error("UTF-8", e);    }    if (key != null) {        if (!validate(key, authData)) {            try {                keyStr = new String(key, StandardCharsets.UTF_8);            } catch (Exception e) {                LOG.error("UTF-8", e);                                keyStr = authStr;            }            LOG.debug("KeyAuthenticationProvider handleAuthentication ({}, {}) -> FAIL.\n", keyStr, authStr);            return KeeperException.Code.AUTHFAILED;        }    }        LOG.debug("KeyAuthenticationProvider handleAuthentication -> OK.\n");                        serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr));    return KeeperException.Code.OK;}
e12a35b64600339e7c1cb0266f412b0770f23e2df26900d09e50a19e96c78749
matches
public boolean matches(ServerObjs serverObjs, MatchValues matchValues)
{    return matchValues.getId().equals(matchValues.getAclExpr());}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return true;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    return true;}
8b14883896e9dbd16e433d8992a7e3362db19048b3a1baf1298796fbe5db7f6d
reset
public static void reset()
{    synchronized (ProviderRegistry.class) {        initialized = false;        authenticationProviders.clear();    }}
6e536afbff7373a7ad71ba4d90df8cef978b7eb57a7a6a6f57defdd29d76106a
initialize
public static void initialize()
{    synchronized (ProviderRegistry.class) {        IPAuthenticationProvider ipp = new IPAuthenticationProvider();        DigestAuthenticationProvider digp = new DigestAuthenticationProvider();        authenticationProviders.put(ipp.getScheme(), ipp);        authenticationProviders.put(digp.getScheme(), digp);        Enumeration<Object> en = System.getProperties().keys();        while (en.hasMoreElements()) {            String k = (String) en.nextElement();            if (k.startsWith("zookeeper.authProvider.")) {                String className = System.getProperty(k);                try {                    Class<?> c = ZooKeeperServer.class.getClassLoader().loadClass(className);                    AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor().newInstance();                    authenticationProviders.put(ap.getScheme(), ap);                } catch (Exception e) {                    LOG.warn("Problems loading " + className, e);                }            }        }        initialized = true;    }}
11481dec1b07c3bc4dce80b86c9ccc045045d6b33a70eea02d72388dba318e7d
getServerProvider
public static ServerAuthenticationProvider getServerProvider(String scheme)
{    return WrappedAuthenticationProvider.wrap(getProvider(scheme));}
3d2bcfe05aa39ce47ed7428aee058c36041adea90614f1847ac5592aaf4da9e2
getProvider
public static AuthenticationProvider getProvider(String scheme)
{    if (!initialized) {        initialize();    }    return authenticationProviders.get(scheme);}
025842c893268ba574a2f1966b6e2e0def6275689321c4426440de4cbeadd2d5
removeProvider
public static void removeProvider(String scheme)
{    authenticationProviders.remove(scheme);}
787d169d9b3fefe4533e7c51370ac548dd3d9c09c66b25933a7d989d740a97f4
listProviders
public static String listProviders()
{    StringBuilder sb = new StringBuilder();    for (String s : authenticationProviders.keySet()) {        sb.append(s).append(" ");    }    return sb.toString();}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "sasl";}
27ca6a1cc3eb3d3e1d05fbf5c216c12d3bcdfd1651a9c56f35f8c85fec4f6357
handleAuthentication
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{        return KeeperException.Code.AUTHFAILED;}
3c3624d075688087970147fcb734f865536c936f2750ee30da74f1d7cf875dd1
matches
public boolean matches(String id, String aclExpr)
{    if ((id.equals("super") || id.equals(aclExpr))) {        return true;    }    String readAccessUser = System.getProperty("zookeeper.letAnySaslUserDoX");    return readAccessUser != null && aclExpr.equals(readAccessUser);}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return true;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{        try {        new KerberosName(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
8be71802c20b7ee5c040cc24d804a9489d017c8b3eb3befc80a0d01ae9d378d1
handle
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
e3c32887d8e9e77de703fa38dcd0034e0d3c4653c3107640130821891f416869
handleNameCallback
private void handleNameCallback(NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {        LOG.warn("User '" + nc.getDefaultName() + "' not found in list of DIGEST-MD5 authenticateable users.");        return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
eeb9d8bb3bcbfe422eb274231ebf9272fb45c076ae257e861781a5bfcd25d7c6
handlePasswordCallback
private void handlePasswordCallback(PasswordCallback pc)
{    if ("super".equals(this.userName) && System.getProperty(SYSPROP_SUPER_PASSWORD) != null) {                pc.setPassword(System.getProperty(SYSPROP_SUPER_PASSWORD).toCharArray());    } else if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {        LOG.warn("No password found for user: " + userName);    }}
8abe0d98e762db40c9ddbc752a0f01b0d1f9a7dde5a212fb998d06950eb7776c
handleRealmCallback
private void handleRealmCallback(RealmCallback rc)
{    LOG.debug("client supplied realm: {}", rc.getDefaultText());    rc.setText(rc.getDefaultText());}
e81e1fa5ccef4d53e3b963ffe2d61d9a9d8968dd94b5332455b583e935b27760
handleAuthorizeCallback
private void handleAuthorizeCallback(AuthorizeCallback ac)
{    String authenticationID = ac.getAuthenticationID();    String authorizationID = ac.getAuthorizationID();    LOG.info("Successfully authenticated client: authenticationID={};  authorizationID={}.", authenticationID, authorizationID);    ac.setAuthorized(true);                KerberosName kerberosName = new KerberosName(authenticationID);    try {        StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());        if (shouldAppendHost(kerberosName)) {            userNameBuilder.append("/").append(kerberosName.getHostName());        }        if (shouldAppendRealm(kerberosName)) {            userNameBuilder.append("@").append(kerberosName.getRealm());        }        LOG.info("Setting authorizedID: " + userNameBuilder);        ac.setAuthorizedID(userNameBuilder.toString());    } catch (IOException e) {        LOG.error("Failed to set name based on Kerberos authentication rules.", e);    }}
359458c40109dc1cf846df67bb0cc8d85634ebb264b657215a27a154f02e3e03
shouldAppendRealm
private boolean shouldAppendRealm(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_REALM) && kerberosName.getRealm() != null;}
cd9f54bcacfc305b62cae760d7bd0a9ba75a308bef2c6c0a64691aa7a96f3980
shouldAppendHost
private boolean shouldAppendHost(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_HOST) && kerberosName.getHostName() != null;}
17a174911af026b95126909baece46ee5e93dd3a801d56b17acf729733d31bec
isSystemPropertyTrue
private boolean isSystemPropertyTrue(String propertyName)
{    return "true".equals(System.getProperty(propertyName));}
a97ac4991464583dd929c136fb0b52846585a97e5bc5f2a89642f86598c7e901
getZks
public ZooKeeperServer getZks()
{    return zks;}
8af225a4d60f8887d401958103a973d2f3f249731e31008a12af823826712ea9
getCnxn
public ServerCnxn getCnxn()
{    return cnxn;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
e243e178fbaf9ed48e620879c6bcde9656f7290838b8b5c241327f0700ec838b
getAclExpr
public String getAclExpr()
{    return aclExpr;}
273d1290f035e1b9ae17b057c46c69bdfc2072b23d7f6df3f216cd53a0d484a1
getPerm
public int getPerm()
{    return perm;}
f78aa85a6b28b88dc4e6c58737e077a479978457a1740eef48abf109e8fdd9de
getSetAcls
public List<ACL> getSetAcls()
{    return setAcls;}
a17f533173cb8da0291c7fadc81d2b353005a341cd9e125964825682f08599b4
handleAuthentication
public final KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    throw new UnsupportedOperationException();}
97d6d809a9a15a857837aeec233c12cd6d475be1c35ca9cd7e019941c3bc1dda
matches
public final boolean matches(String id, String aclExpr)
{    throw new UnsupportedOperationException();}
6e2ba134387f8bdb8ba1a5cacdff407f2c2f79eb3296e93cba564fd9f520c911
wrap
 static ServerAuthenticationProvider wrap(AuthenticationProvider provider)
{    if (provider == null) {        return null;    }    return (provider instanceof ServerAuthenticationProvider) ? (ServerAuthenticationProvider) provider : new WrappedAuthenticationProvider(provider);}
1669fb76a6b52a87bddc0e7c4afaebcb37435836956a61fdf6d1d00980e42f29
handleAuthentication
public KeeperException.Code handleAuthentication(ServerObjs serverObjs, byte[] authData)
{    return implementation.handleAuthentication(serverObjs.getCnxn(), authData);}
e12a35b64600339e7c1cb0266f412b0770f23e2df26900d09e50a19e96c78749
matches
public boolean matches(ServerObjs serverObjs, MatchValues matchValues)
{    return implementation.matches(matchValues.getId(), matchValues.getAclExpr());}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return implementation.getScheme();}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return implementation.isAuthenticated();}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    return implementation.isValid(id);}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return "x509";}
27ca6a1cc3eb3d3e1d05fbf5c216c12d3bcdfd1651a9c56f35f8c85fec4f6357
handleAuthentication
public KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte[] authData)
{    X509Certificate[] certChain = (X509Certificate[]) cnxn.getClientCertificateChain();    if (certChain == null || certChain.length == 0) {        return KeeperException.Code.AUTHFAILED;    }    if (trustManager == null) {        LOG.error("No trust manager available to authenticate session 0x{}", Long.toHexString(cnxn.getSessionId()));        return KeeperException.Code.AUTHFAILED;    }    X509Certificate clientCert = certChain[0];    try {                trustManager.checkClientTrusted(certChain, clientCert.getPublicKey().getAlgorithm());    } catch (CertificateException ce) {        LOG.error("Failed to trust certificate for session 0x{}", Long.toHexString(cnxn.getSessionId()), ce);        return KeeperException.Code.AUTHFAILED;    }    String clientId = getClientId(clientCert);    if (clientId.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER))) {        cnxn.addAuthInfo(new Id("super", clientId));        LOG.info("Authenticated Id '{}' as super user", clientId);    }    Id authInfo = new Id(getScheme(), clientId);    cnxn.addAuthInfo(authInfo);    LOG.info("Authenticated Id '{}' for Scheme '{}'", authInfo.getId(), authInfo.getScheme());    return KeeperException.Code.OK;}
53d7f888fd792245b716fbd9584a7d9c89d7d1d4c515de7f22ed1990a7330e1c
getClientId
protected String getClientId(X509Certificate clientCert)
{    return clientCert.getSubjectX500Principal().getName();}
3c3624d075688087970147fcb734f865536c936f2750ee30da74f1d7cf875dd1
matches
public boolean matches(String id, String aclExpr)
{    if (System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER) != null) {        return id.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER)) || id.equals(aclExpr);    }    return id.equals(aclExpr);}
dc65f02fa1d333f908424da1b3350b52f4bc6fefe9646d1266e579e3c5be7951
isAuthenticated
public boolean isAuthenticated()
{    return true;}
e252435470e6d5188f080f2d13305112932589231077e6cf056669abefa15e6b
isValid
public boolean isValid(String id)
{    try {        new X500Principal(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
3693070d9a7563cdbf42234e879838888d76518503c2882f322658ca51aa5fb7
getTrustManager
public X509TrustManager getTrustManager() throws TrustManagerException
{    if (trustManager == null) {        throw new TrustManagerException("No trust manager available");    }    return trustManager;}
512212fe8113e8457d0cbd115abc1d002a8c183e19e492f9218634f2ba5e69e1
getKeyManager
public X509KeyManager getKeyManager() throws KeyManagerException
{    if (keyManager == null) {        throw new KeyManagerException("No key manager available");    }    return keyManager;}
7a524cdb7e58edb04a11fb2537522be64d205f6c2c5108b9f4d6bf88f9d79199
setConnectionWeightEnabled
protected static void setConnectionWeightEnabled(boolean enabled)
{    connectionWeightEnabled = enabled;    logWeighedThrottlingSetting();}
38563d0b894554423ff910b7dcd2630633625585ac9e8c1affbd236483a68d3a
logWeighedThrottlingSetting
private static void logWeighedThrottlingSetting()
{    if (connectionWeightEnabled) {        LOG.info("Weighed connection throttling is enabled. " + "But it will only be effective if connection throttling is enabled");        LOG.info("The weights for different session types are: global {} renew {} local {}", DEFAULT_GLOBAL_SESSION_WEIGHT, DEFAULT_RENEW_SESSION_WEIGHT, DEFAULT_LOCAL_SESSION_WEIGHT);    } else {        LOG.info("Weighed connection throttling is disabled");    }}
a5af5a0ba542dbc509e621c9b2843edf9a64cca93465dba2eeeeeefa0a12c750
getDoubleProp
private static double getDoubleProp(String name, double def)
{    String val = System.getProperty(name);    if (val != null) {        return Double.parseDouble(val);    } else {        return def;    }}
398622e6d660915cd576b2df4a268afe5373e8d5aa91ae0c8987de5f088c3eee
setMaxTokens
public synchronized void setMaxTokens(int max)
{    int deficit = maxTokens - tokens;    maxTokens = max;    tokens = max - deficit;}
95732815d509126f7b2f2f672a32dc295abb56f3017ac5d6be799d7ff517fb37
setFillTime
public synchronized void setFillTime(int time)
{    fillTime = time;}
34cc0cef6ecc840917b4bb46651bb821aa924961b7828a6f7736428383779205
setFillCount
public synchronized void setFillCount(int count)
{    fillCount = count;}
7fd8eac4b96df7884bc8254f5e9cb881d64a86b881bde2f9c5052f39e479fc08
setFreezeTime
public synchronized void setFreezeTime(int time)
{    freezeTime = time;}
a60890934fbb11344ae3930eebfb864c854dddd11b8668c4678cd8d05eb90b66
setDropIncrease
public synchronized void setDropIncrease(double increase)
{    dropIncrease = increase;}
81cfa179566ae8e8c8678495713c492ecb5b2cc9f74e93b2f6b8a456ca071409
setDropDecrease
public synchronized void setDropDecrease(double decrease)
{    dropDecrease = decrease;}
a759ab067bcde6135fbfae201db46734acb205062301d50ce21919df463fd4ea
setDecreasePoint
public synchronized void setDecreasePoint(double ratio)
{    decreasePoint = ratio;}
240efa66045d135c11d9849b2c8c22302aa08a18455031aeee68c7ef38f5774b
getMaxTokens
public synchronized int getMaxTokens()
{    return maxTokens;}
1e408a86cda6f94c547c55a3945a5adbe56efe98dbf76ac4bdb1e6169ec0e6d5
getFillTime
public synchronized int getFillTime()
{    return fillTime;}
a24e40641c71da40be961a1ddb480323aa4aefd3c1b91727cf8101b3b39f20a3
getFillCount
public synchronized int getFillCount()
{    return fillCount;}
1e5ebdbf5fc8c7b5476915c0c15b0e589b611ca6e44aa438d2ee44288330ba8d
getFreezeTime
public synchronized int getFreezeTime()
{    return freezeTime;}
211e0a3db0c82d9563af2868ba5799cd898a4bcedbe69dfa7c82c5bbfba5fe45
getDropIncrease
public synchronized double getDropIncrease()
{    return dropIncrease;}
12f0deef7574011d1e9200ade3ac2226148048cb54a7477e83d4efde27c8f8f3
getDropDecrease
public synchronized double getDropDecrease()
{    return dropDecrease;}
a5c5ab434b2648411d0d971e5bfa7e3189c832fdd5550ffc3b5b765c65b95f0a
getDecreasePoint
public synchronized double getDecreasePoint()
{    return decreasePoint;}
b07b07e7850184377346ebd951a891eee3ed042271391f376c45b033ffc6ff04
getDropChance
public synchronized double getDropChance()
{    return drop;}
d7d2f28cb71298eb666cf8ede7afd6870b315df2d731c8bf8b5f4e965bc9bda0
getDeficit
public synchronized int getDeficit()
{    return maxTokens - tokens;}
e1052e5c70aaca6398a27b79b7cde6d03abc8e2829a31b9fc909954cb37f80b8
getRequiredTokensForGlobal
public int getRequiredTokensForGlobal()
{    return BlueThrottle.DEFAULT_GLOBAL_SESSION_WEIGHT;}
a0ab3e9ecb51d2e58b95fcb5949780c852211197faf944539196e853b0a5863e
getRequiredTokensForLocal
public int getRequiredTokensForLocal()
{    return BlueThrottle.DEFAULT_LOCAL_SESSION_WEIGHT;}
e9f954f053ade94afe59aad1bc46d53e2bb3b905c593692a3dd998d705435920
getRequiredTokensForRenew
public int getRequiredTokensForRenew()
{    return BlueThrottle.DEFAULT_RENEW_SESSION_WEIGHT;}
04ba4db4cf6da205384dcfea9a3583680299b8769246bf30d8ddb9a29d215200
isConnectionWeightEnabled
public boolean isConnectionWeightEnabled()
{    return BlueThrottle.connectionWeightEnabled;}
cc28838d824bae4681e90c206a9aa23d53dde497b85bdc532b2fafaa82eefddf
checkLimit
public synchronized boolean checkLimit(int need)
{        if (maxTokens == 0) {        return true;    }    long now = Time.currentElapsedTime();    long diff = now - lastTime;    if (diff > fillTime) {        int refill = (int) (diff * fillCount / fillTime);        tokens = Math.min(tokens + refill, maxTokens);        lastTime = now;    }        if (freezeTime != -1) {        if (!checkBlue(now)) {            return false;        }    }    if (tokens < need) {        return false;    }    tokens -= need;    return true;}
186bda1b53d9394c87ab032aab0fc4a88a7e8897c618d01f6896bd76365343c5
checkBlue
public synchronized boolean checkBlue(long now)
{    int length = maxTokens - tokens;    int limit = maxTokens;    long diff = now - lastFreeze;    long threshold = Math.round(maxTokens * decreasePoint);    if (diff > freezeTime) {        if ((length == limit) && (drop < 1)) {            drop = Math.min(drop + dropIncrease, 1);        } else if ((length <= threshold) && (drop > 0)) {            drop = Math.max(drop - dropDecrease, 0);        }        lastFreeze = now;    }    return !(rng.nextDouble() < drop);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    return bb.get() & 0xff;}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    return bb.remaining();}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    if (len > bb.remaining()) {        len = bb.remaining();    }    bb.get(b, off, len);    return len;}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    if (n < 0L) {        return 0;    }    n = Math.min(n, bb.remaining());    bb.position(bb.position() + (int) n);    return n;}
23a7b58d14576540ae469aa62eae6d6e8c309c43f4830f37ece174d83074e543
byteBuffer2Record
public static void byteBuffer2Record(ByteBuffer bb, Record record) throws IOException
{    BinaryInputArchive ia;    ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    record.deserialize(ia, "request");}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    bb.put((byte) b);}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{    bb.put(b);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    bb.put(b, off, len);}
888d97f8cb19d858592789b5b6f232424d1ad7f46d2539c3a2feb0bd336bb9dd
record2ByteBuffer
public static void record2ByteBuffer(Record record, ByteBuffer bb) throws IOException
{    BinaryOutputArchive oa;    oa = BinaryOutputArchive.getArchive(new ByteBufferOutputStream(bb));    record.serialize(oa, "request");}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    run();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        commandRun();    } catch (IOException ie) {        LOG.error("Error in running command ", ie);    } finally {        serverCnxn.cleanupWriterSocket(pw);    }}
8549d1c738dc5e7de435cadbcc76abfda37e197f2ffd2693443a0926e1a7ce69
setZkServer
public void setZkServer(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
452a4ff94777c76df44bc5eadffc0d712b51a73c6321728e940feb32f49377ee
isZKServerRunning
 boolean isZKServerRunning()
{    return zkServer != null && zkServer.isRunning();}
68dd9a2d236300f37f62d0f8df9a284580e8cd228627377ed3d66bf2f8077ae5
setFactory
public void setFactory(ServerCnxnFactory factory)
{    this.factory = factory;}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        factory.resetAllConnectionStats();        pw.println("Connection stats reset.");    }}
c4d29cf5f96598ec21a05bda71db08b1ce5d7cba4f0a031406fe80b462fabe7b
execute
public boolean execute(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode, ZooKeeperServer zkServer, ServerCnxnFactory factory)
{    AbstractFourLetterCommand command = getCommand(serverCnxn, pwriter, commandCode);    if (command == null) {        return false;    }    command.setZkServer(zkServer);    command.setFactory(factory);    command.start();    return true;}
69a6d66181e84b7b685f105a7369bbe40f6c8a129312564113ab7e9dd5876b76
getCommand
private AbstractFourLetterCommand getCommand(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode)
{    AbstractFourLetterCommand command = null;    if (commandCode == FourLetterCommands.ruokCmd) {        command = new RuokCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.getTraceMaskCmd) {        command = new TraceMaskCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.enviCmd) {        command = new EnvCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.confCmd) {        command = new ConfCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.srstCmd) {        command = new StatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.crstCmd) {        command = new CnxnStatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dirsCmd) {        command = new DirsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dumpCmd) {        command = new DumpCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.statCmd || commandCode == FourLetterCommands.srvrCmd) {        command = new StatCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.consCmd) {        command = new ConsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.wchpCmd || commandCode == FourLetterCommands.wchcCmd || commandCode == FourLetterCommands.wchsCmd) {        command = new WatchCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.mntrCmd) {        command = new MonitorCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.isroCmd) {        command = new IsroCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.hashCmd) {        command = new DigestCommand(pwriter, serverCnxn);    }    return command;}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        zkServer.dumpConf(pw);    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        for (ServerCnxn c : factory.getConnections()) {            c.dumpConnectionInfo(pw, false);            pw.println();        }        pw.println();    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.print(ZK_NOT_SERVING);    } else {        List<ZxidDigest> digestLog = zkServer.getZKDatabase().getDataTree().getDigestLog();        for (ZxidDigest zd : digestLog) {            pw.println(Long.toHexString(zd.getZxid()) + ": " + zd.getDigest());        }    }}
3d40fe06264d10fa727245f4033739eafce30a1ae42e665ef3a94f807884685a
commandRun
public void commandRun() throws IOException
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }    pw.println("datadir_size: " + zkServer.getDataDirSize());    pw.println("logdir_size: " + zkServer.getLogDirSize());}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.println("SessionTracker dump:");        zkServer.getSessionTracker().dumpSessions(pw);        pw.println("ephemeral nodes dump:");        zkServer.dumpEphemerals(pw);        pw.println("Connections dump:");                if (factory instanceof NIOServerCnxnFactory) {            ((NIOServerCnxnFactory) factory).dumpConnections(pw);        }    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    List<Environment.Entry> env = Environment.list();    pw.println("Environment:");    for (Environment.Entry e : env) {        pw.print(e.getKey());        pw.print("=");        pw.println(e.getValue());    }}
f3cbc1913d76c9ff2aac3132487ee42b52cf862b5cb81f6c2795c9506486cd43
resetWhiteList
public static synchronized void resetWhiteList()
{    whiteListInitialized = false;    whiteListedCommands.clear();}
b2e9a9680678227086ac0e75dbfab11a42db9d2e4c0908e853528738e1572587
getCommandString
public static String getCommandString(int command)
{    return cmd2String.get(command);}
a4aa2b130b2500abf6285e39627bab9b1b01598586a28e27698e9c96e8aed26c
isKnown
public static boolean isKnown(int command)
{    return cmd2String.containsKey(command);}
d3cab79170e80686a260f472bf703dbcdb35abfca133b30a0a5ce5bf5879a7fa
isEnabled
public static synchronized boolean isEnabled(String command)
{    if (whiteListInitialized) {        return whiteListedCommands.contains(command);    }    String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);    if (commands != null) {        String[] list = commands.split(",");        for (String cmd : list) {            if (cmd.trim().equals("*")) {                for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {                    whiteListedCommands.add(entry.getValue());                }                break;            }            if (!cmd.trim().isEmpty()) {                whiteListedCommands.add(cmd.trim());            }        }    }        if (System.getProperty("readonlymode.enabled", "false").equals("true")) {        whiteListedCommands.add("isro");    }        whiteListedCommands.add("srvr");    whiteListInitialized = true;    LOG.info("The list of known four letter word commands is : {}", Arrays.asList(cmd2String));    LOG.info("The list of enabled four letter word commands is : {}", Arrays.asList(whiteListedCommands));    return whiteListedCommands.contains(command);}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.print("null");    } else if (zkServer instanceof ReadOnlyZooKeeperServer) {        pw.print("ro");    } else {        pw.print("rw");    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }        zkServer.dumpMonitorValues(this::print);    ServerMetrics.getMetrics().getMetricsProvider().dump(this::print);}
34cc9aea7f22f281d4640dc07be9dffc2448dd15b04c90e010254988f5c2295b
print
private void print(String key, Object value)
{    if (value == null) {        output(key, null);    } else if (value instanceof Long || value instanceof Integer) {                output(key, value + "");    } else if (value instanceof Number) {                output(key, ((Number) value).doubleValue() + "");    } else {        output(key, value.toString());    }}
8020c894e8e26c72b3d57dc0906b24a673e823c3c04f7b026e954be5c17b2e8a
output
private void output(String key, String value)
{    pw.print("zk_");    pw.print(key);    pw.print("\t");    pw.println(value);}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    pw.println(msg);}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    pw.print("imok");}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    pw.print(trace);}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.print("Zookeeper version: ");        pw.println(Version.getFullVersion());        if (zkServer instanceof ReadOnlyZooKeeperServer) {            pw.println("READ-ONLY mode; serving only read-only clients");        }        if (len == FourLetterCommands.statCmd) {            LOG.info("Stat command output");            pw.println("Clients:");            for (ServerCnxn c : factory.getConnections()) {                c.dumpConnectionInfo(pw, true);                pw.println();            }            pw.println();        }        ServerStats serverStats = zkServer.serverStats();        pw.print(serverStats.toString());        pw.print("Node count: ");        pw.println(zkServer.getZKDatabase().getNodeCount());        if (serverStats.getServerState().equals("leader")) {            Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();            BufferStats proposalStats = leader.getProposalStats();            pw.printf("Proposal sizes last/min/max: %s%n", proposalStats.toString());        }    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        ServerStats serverStats = zkServer.serverStats();        serverStats.reset();        if (serverStats.getServerState().equals("leader")) {            ((LeaderZooKeeperServer) zkServer).getLeader().getProposalStats().reset();        }        pw.println("Server stats reset.");    }}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    long traceMask = ZooTrace.getTextTraceLevel();    pw.print(traceMask);}
4d69a1295c8be16e2bbe55a03d194477854fd6a03f6033ec9af704d64769d218
commandRun
public void commandRun()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        DataTree dt = zkServer.getZKDatabase().getDataTree();        if (len == FourLetterCommands.wchsCmd) {            dt.dumpWatchesSummary(pw);        } else if (len == FourLetterCommands.wchpCmd) {            dt.dumpWatches(pw, true);        } else {            dt.dumpWatches(pw, false);        }        pw.println();    }}
165b952c7539709ab5a775870e9661d08fe6a1ba321a032e1804a9bdabe6e6be
getSessionId
public String getSessionId()
{    return "0x" + Long.toHexString(sessionId);}
af8383277734923bea93f52a7957eb7c3ae1a44d0b44ea2c8ea74c82a9d74fa7
getSourceIP
public String getSourceIP()
{    InetSocketAddress sockAddr = connection.getRemoteSocketAddress();    if (sockAddr == null) {        return null;    }    return sockAddr.getAddress().getHostAddress() + ":" + sockAddr.getPort();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return MBeanRegistry.getInstance().makeFullPath("Connections", remoteIP, getSessionId());}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
3affcaef5c656b000f9b8ce68b7137d4b8d72aaf87380017d9706fff87e29656
getEphemeralNodes
public String[] getEphemeralNodes()
{    if (zk.getZKDatabase() != null) {        String[] res = zk.getZKDatabase().getEphemerals(sessionId).toArray(new String[0]);        Arrays.sort(res);        return res;    }    return null;}
4786c4ca8e1e7dfc71c40bed2b63878058fc6ea7af3764231e34eaaf0327c4e4
getStartedTime
public String getStartedTime()
{    return stats.getEstablished().toString();}
2bca3f968c1f31eac5db43d5e4c74170eef1e7a4da840e8cc748724ac5f77ec7
terminateSession
public void terminateSession()
{    try {        zk.closeSession(sessionId);    } catch (Exception e) {        LOG.warn("Unable to closeSession() for session: 0x" + getSessionId(), e);    }}
85855e7603732ccff679fc6284742be9c6bdb30a7500c8886361b7a59b873b3b
terminateConnection
public void terminateConnection()
{    connection.sendCloseSession();}
ff8c562df218c8b563bc392f45032585194d6eb958dc02668b9a38934f2ee025
resetCounters
public void resetCounters()
{    stats.resetStats();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ConnectionBean{ClientIP=" + ObjectName.quote(getSourceIP()) + ",SessionId=0x" + getSessionId() + "}";}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return stats.getOutstandingRequests();}
5007fe9fa665c1fbd4284e8036ff281fdd652aceda522cc6df718948fa452aaf
getPacketsReceived
public long getPacketsReceived()
{    return stats.getPacketsReceived();}
f229e1433c8ccf0fb3b2afe9022ffc0c9f054fffba05700a51a804fc4a51e991
getPacketsSent
public long getPacketsSent()
{    return stats.getPacketsSent();}
2436723c695636833e0ebfc52d684cb9ae4da078ffa3153b560d8213802ad011
getSessionTimeout
public int getSessionTimeout()
{    return connection.getSessionTimeout();}
34375a630b3741ec40c881f400e7257692930e1d1b025f8088be26ad73c23e78
getMinLatency
public long getMinLatency()
{    return stats.getMinLatency();}
a5534c6d7f818d3bfca5acd9986797180e9a3de3754312e97e57523b6458039d
getAvgLatency
public long getAvgLatency()
{    return stats.getAvgLatency();}
6e26ca4f63bcab4e0df4b6b5a7dfd7ec997606516fc50a325ae2b73d4b05496b
getMaxLatency
public long getMaxLatency()
{    return stats.getMaxLatency();}
ea9e2bd55a05f56348d7d96f6054a2b1e708fb00935abf41fb28c2a510c328da
getLastOperation
public String getLastOperation()
{    return stats.getLastOperation();}
a94b48d22970b5b8b87beeac56a9e3849ed82e19cb20e34413892e72fa1c306f
getLastCxid
public String getLastCxid()
{    return "0x" + Long.toHexString(stats.getLastCxid());}
6244117694f70b2f412f799bb5d24892ed4a797a94becfa16eb5376f299f28ff
getLastZxid
public String getLastZxid()
{    return "0x" + Long.toHexString(stats.getLastZxid());}
2e50bff9bc8787ca2d08490a3ae2e8452d30f0b7a8860603f39672c4574276c0
getLastResponseTime
public String getLastResponseTime()
{    return Time.elapsedTimeToDate(stats.getLastResponseTime()).toString();}
7c94b952e327bb53a86b3102607c6cff590c5f9b8c1525dfbb48dc6ab96a4496
getLastLatency
public long getLastLatency()
{    return stats.getLastLatency();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (task.get() == null) {        TimerTask timerTask = new TimerTask() {            @Override            public void run() {                try {                    checkContainers();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                    LOG.info("interrupted");                    cancel();                } catch (Throwable e) {                    LOG.error("Error checking containers", e);                }            }        };        if (task.compareAndSet(null, timerTask)) {            timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        checkContainers();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        LOG.info("interrupted");        cancel();    } catch (Throwable e) {        LOG.error("Error checking containers", e);    }}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    TimerTask timerTask = task.getAndSet(null);    if (timerTask != null) {        timerTask.cancel();    }    timer.cancel();}
86eba48b55639141c4d33d18560c8349c976f733f3cd8916571da02efe9e8b01
checkContainers
public void checkContainers() throws InterruptedException
{    long minIntervalMs = getMinIntervalMs();    for (String containerPath : getCandidates()) {        long startMs = Time.currentElapsedTime();        ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());        Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);        try {            LOG.info("Attempting to delete candidate container: {}", containerPath);            requestProcessor.processRequest(request);        } catch (Exception e) {            LOG.error("Could not delete container: {}", containerPath, e);        }        long elapsedMs = Time.currentElapsedTime() - startMs;        long waitMs = minIntervalMs - elapsedMs;        if (waitMs > 0) {            Thread.sleep(waitMs);        }    }}
7095b403948791f77ecbfe171636dd8e3f711b896f50e09f593cf0ce77515f29
getMinIntervalMs
protected long getMinIntervalMs()
{    return TimeUnit.MINUTES.toMillis(1) / maxPerMinute;}
fa5f65d432b0249fcaf3a885515c4009820a958c58f853d4716e178bcbecd25d
getCandidates
protected Collection<String> getCandidates()
{    Set<String> candidates = new HashSet<String>();    for (String containerPath : zkDb.getDataTree().getContainers()) {        DataNode node = zkDb.getDataTree().getNode(containerPath);        /*                cversion > 0: keep newly created containers from being deleted                before any children have been added. If you were to create the                container just before a container cleaning period the container                would be immediately be deleted.             */        if ((node != null) && (node.stat.getCversion() > 0) && (node.getChildren().isEmpty())) {            candidates.add(containerPath);        }    }    for (String ttlPath : zkDb.getDataTree().getTtls()) {        DataNode node = zkDb.getDataTree().getNode(ttlPath);        if (node != null) {            Set<String> children = node.getChildren();            if (children.isEmpty()) {                if (EphemeralType.get(node.stat.getEphemeralOwner()) == EphemeralType.TTL) {                    long elapsed = getElapsed(node);                    long ttl = EphemeralType.TTL.getValue(node.stat.getEphemeralOwner());                    if ((ttl != 0) && (getElapsed(node) > ttl)) {                        candidates.add(ttlPath);                    }                }            }        }    }    return candidates;}
a64f21e43dcfb0ced769bec047f96296979557f90ccf011b11a525cf58c7f64b
getElapsed
protected long getElapsed(DataNode node)
{    return Time.currentWallTime() - node.stat.getMtime();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {        LOG.warn("Purge task is already running.");        return;    }        if (purgeInterval <= 0) {        LOG.info("Purge task is not scheduled.");        return;    }    timer = new Timer("PurgeTask", true);    TimerTask task = new PurgeTask(dataLogDir, snapDir, snapRetainCount);    timer.scheduleAtFixedRate(task, 0, TimeUnit.HOURS.toMillis(purgeInterval));    purgeTaskStatus = PurgeTaskStatus.STARTED;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {        LOG.info("Shutting down purge task.");        timer.cancel();        purgeTaskStatus = PurgeTaskStatus.COMPLETED;    } else {        LOG.warn("Purge task not started. Ignoring shutdown!");    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LOG.info("Purge task started.");    try {        PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);    } catch (Exception e) {        LOG.error("Error occurred while purging.", e);    }    LOG.info("Purge task completed.");}
79500f9d7b6f7607864d0cca38f38d67b6de788de2388fa61e740fab46e7453a
getPurgeTaskStatus
public PurgeTaskStatus getPurgeTaskStatus()
{    return purgeTaskStatus;}
2b9e5e29a6fc50c7aa93f431e78b37d0fedb6831e2951819d6b65df32476d139
getSnapDir
public File getSnapDir()
{    return snapDir;}
2742bb58bdbfe1b66b2740996b6a766693e7057cb8802d4843c4e85eb1d5f32a
getDataLogDir
public File getDataLogDir()
{    return dataLogDir;}
6fa960549b44ead4739655dd705b8285b1287b6cc7b7f499ba1e43febb18e709
getPurgeInterval
public int getPurgeInterval()
{    return purgeInterval;}
dd2ac4033cadb287f37314e34697689c69dc23c8f7e9ed8bd41f8aefe205f527
getSnapRetainCount
public int getSnapRetainCount()
{    return snapRetainCount;}
2fbfe68312d33db3dca1c9a7816beec0c70a626243b3d7632f2941b4f3eeb87a
addChild
public synchronized boolean addChild(String child)
{    if (children == null) {                children = new HashSet<String>(8);    }    return children.add(child);}
2dd24bf4eecf4fedb539f5b91f2a4f1cd9a81aa916c904adb634f4998bedeb13
removeChild
public synchronized boolean removeChild(String child)
{    if (children == null) {        return false;    }    return children.remove(child);}
28c361ce8b7c50396364c27cfd59a19f5e54db68fbfc568e291290dbf01c4c7a
setChildren
public synchronized void setChildren(HashSet<String> children)
{    this.children = children;}
9656b14ee0df6d2952c3a55ad93ba4b87e968de678526c997bc0404d0677591e
getChildren
public synchronized Set<String> getChildren()
{    if (children == null) {        return EMPTY_SET;    }    return Collections.unmodifiableSet(children);}
3c58d59962a44492c446e4db62775e96ccc3f362354765cebf6bd487af41e364
copyStat
public synchronized void copyStat(Stat to)
{    to.setAversion(stat.getAversion());    to.setCtime(stat.getCtime());    to.setCzxid(stat.getCzxid());    to.setMtime(stat.getMtime());    to.setMzxid(stat.getMzxid());    to.setPzxid(stat.getPzxid());    to.setVersion(stat.getVersion());    to.setEphemeralOwner(getClientEphemeralOwner(stat));    to.setDataLength(data == null ? 0 : data.length);    int numChildren = 0;    if (this.children != null) {        numChildren = children.size();    }                to.setCversion(stat.getCversion() * 2 - numChildren);    to.setNumChildren(numChildren);}
565eb51ab432238331f400a3c36533a5e75075e21733ab2a52618aa0ade65373
getClientEphemeralOwner
private static long getClientEphemeralOwner(StatPersisted stat)
{    EphemeralType ephemeralType = EphemeralType.get(stat.getEphemeralOwner());    if (ephemeralType != EphemeralType.NORMAL) {        return 0;    }    return stat.getEphemeralOwner();}
cb1d5f0ce1c27bec1306edba78f391b8f3b68155665c66ab887a4006079ee436
deserialize
public synchronized void deserialize(InputArchive archive, String tag) throws IOException
{    archive.startRecord("node");    data = archive.readBuffer("data");    acl = archive.readLong("acl");    stat = new StatPersisted();    stat.deserialize(archive, "statpersisted");    archive.endRecord("node");}
919916b0c42999d8d5c0f583d66ef5fd0193e38f3c6c880c493ddc0b51cf5551
serialize
public synchronized void serialize(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, "node");    archive.writeBuffer(data, "data");    archive.writeLong(acl, "acl");    stat.serialize(archive, "statpersisted");    archive.endRecord(this, "node");}
f064e1fb30e08d1816f6c6a32c1733510469b40d219e8cb51ab187b5010b69c8
isDigestCached
public boolean isDigestCached()
{    return digestCached;}
56a2ede6812886a4b05231024d6c73ca12d38ff3125d8a786f79f308278c4595
setDigestCached
public void setDigestCached(boolean digestCached)
{    this.digestCached = digestCached;}
af8c658698c84be2b4a37ae1cf3a3193287a17c33afc74882fe3cfeb86091383
getDigest
public long getDigest()
{    return digest;}
c84aec4b0140a8f8ba22cfdaa592f5fba99e5a7d676d5cd8b36952a407450b74
setDigest
public void setDigest(long digest)
{    this.digest = digest;}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return data;}
f1b5efd63d699f8d9cd73fbab3a426ed4dfad71de6f3f9bed1c42aaa72d0bd2e
getEphemerals
public Set<String> getEphemerals(long sessionId)
{    HashSet<String> retv = ephemerals.get(sessionId);    if (retv == null) {        return new HashSet<String>();    }    Set<String> cloned = null;    synchronized (retv) {        cloned = (HashSet<String>) retv.clone();    }    return cloned;}
12c99d01ee2addfa7050048dd92cd42265e6b866b315fba164c883988b233e2a
getContainers
public Set<String> getContainers()
{    return new HashSet<String>(containers);}
a8ef7aea87cf544a7b792f9bb3246da560cbf4d88617effdce88d465029e3821
getTtls
public Set<String> getTtls()
{    return new HashSet<String>(ttls);}
12d76c9e8483774bde383e09c1f087f33a0e655c412772f73f8514f3b6932d16
getSessions
public Collection<Long> getSessions()
{    return ephemerals.keySet();}
93a20e581cc4a2d091243313b65daaba6fa4444990f81b1408c6a72e894d6d56
getNode
public DataNode getNode(String path)
{    return nodes.get(path);}
1b35d3943e93e7bd41c69894e5feefb9a54498a4bfd46389209c1216df41025a
getNodeCount
public int getNodeCount()
{    return nodes.size();}
b339fbb11fc521b7313a9ae8d0dc78ad65b43f11f3db269c233dfe7a76e7d593
getWatchCount
public int getWatchCount()
{    return dataWatches.size() + childWatches.size();}
1bcf891aa67a886fb2ca01c1412a219644afe91a23c35195992b1af1993076ed
getEphemeralsCount
public int getEphemeralsCount()
{    int result = 0;    for (HashSet<String> set : ephemerals.values()) {        result += set.size();    }    return result;}
6d8d43e08c9c4e66537bdd66d5e6f365ea5b478ca3e8dc1d023cd048577582e1
approximateDataSize
public long approximateDataSize()
{    long result = 0;    for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {        DataNode value = entry.getValue();        synchronized (value) {            result += getNodeSize(entry.getKey(), value.data);        }    }    return result;}
fef445704c096578a27533add6992b2ae09389ba578bf074b35232ef6c06c7e2
getNodeSize
private static long getNodeSize(String path, byte[] data)
{    return (path == null ? 0 : path.length()) + (data == null ? 0 : data.length);}
bed90199e3c9376250c932869064cf5c40476f982e386d38f9d82f8e88d28d30
cachedApproximateDataSize
public long cachedApproximateDataSize()
{    return nodeDataSize.get();}
d3f0e50f52da08a6530ec0524621204fe87437baccbe59005c491a87628916df
addConfigNode
public void addConfigNode()
{    DataNode zookeeperZnode = nodes.get(procZookeeper);    if (zookeeperZnode != null) {                zookeeperZnode.addChild(configChildZookeeper);    } else {        assert false : "There's no /zookeeper znode - this should never happen.";    }    nodes.put(configZookeeper, new DataNode(new byte[0], -1L, new StatPersisted()));    try {                setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoNodeException e) {        assert false : "There's no " + configZookeeper + " znode - this should never happen.";    }}
65727467cb27457072879baf6c86849d16a076d22e3bd7978b7db8ed52ad7b9a
isSpecialPath
 boolean isSpecialPath(String path)
{    return rootZookeeper.equals(path) || procZookeeper.equals(path) || quotaZookeeper.equals(path) || configZookeeper.equals(path);}
97ab3e8e3ec7176e43c1e7fcbd3fc60c6605902a918ef03901b50d395300a8d4
copyStatPersisted
public static void copyStatPersisted(StatPersisted from, StatPersisted to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());}
847fd8f0e18b4958b842607f9ad875754bb9c6cbac95c359ef916b708a629157
copyStat
public static void copyStat(Stat from, Stat to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());    to.setDataLength(from.getDataLength());    to.setNumChildren(from.getNumChildren());}
0edc867dd605492756a71384f75dbf27bad7d59e826f3ea3189c6b6d9f1330de
updateCountBytes
public void updateCountBytes(String lastPrefix, long bytesDiff, int countDiff)
{    String statNode = Quotas.statPath(lastPrefix);    DataNode node = nodes.get(statNode);    StatsTrack updatedStat = null;    if (node == null) {                LOG.error("Missing count node for stat " + statNode);        return;    }    synchronized (node) {        updatedStat = new StatsTrack(new String(node.data));        updatedStat.setCount(updatedStat.getCount() + countDiff);        updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);        node.data = updatedStat.toString().getBytes();    }        String quotaNode = Quotas.quotaPath(lastPrefix);    node = nodes.get(quotaNode);    StatsTrack thisStats = null;    if (node == null) {                LOG.error("Missing count node for quota " + quotaNode);        return;    }    synchronized (node) {        thisStats = new StatsTrack(new String(node.data));    }    if (thisStats.getCount() > -1 && (thisStats.getCount() < updatedStat.getCount())) {        LOG.warn("Quota exceeded: " + lastPrefix + " count=" + updatedStat.getCount() + " limit=" + thisStats.getCount());    }    if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {        LOG.warn("Quota exceeded: " + lastPrefix + " bytes=" + updatedStat.getBytes() + " limit=" + thisStats.getBytes());    }}
861690f4018cc49eed96683b783db0634b303af4c2afe712a0be7056e2547378
createNode
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time) throws NoNodeException, NodeExistsException
{    createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);}
26edf23657018a38a07f10d37ff661f0cda716c55344822a2a08ba66e51a898e
createNode
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws KeeperException.NoNodeException, KeeperException.NodeExistsException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);    StatPersisted stat = new StatPersisted();    stat.setCtime(time);    stat.setMtime(time);    stat.setCzxid(zxid);    stat.setMzxid(zxid);    stat.setPzxid(zxid);    stat.setVersion(0);    stat.setAversion(0);    stat.setEphemeralOwner(ephemeralOwner);    DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {                                                                                                Long longval = aclCache.convertAcls(acl);        Set<String> children = parent.getChildren();        if (children.contains(childName)) {            throw new KeeperException.NodeExistsException();        }        nodes.preChange(parentName, parent);        if (parentCVersion == -1) {            parentCVersion = parent.stat.getCversion();            parentCVersion++;        }                if (parentCVersion > parent.stat.getCversion()) {            parent.stat.setCversion(parentCVersion);            parent.stat.setPzxid(zxid);        }        DataNode child = new DataNode(data, longval, stat);        parent.addChild(childName);        nodes.postChange(parentName, parent);        nodeDataSize.addAndGet(getNodeSize(path, child.data));        nodes.put(path, child);        EphemeralType ephemeralType = EphemeralType.get(ephemeralOwner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.add(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.add(path);        } else if (ephemeralOwner != 0) {            HashSet<String> list = ephemerals.get(ephemeralOwner);            if (list == null) {                list = new HashSet<String>();                ephemerals.put(ephemeralOwner, list);            }            synchronized (list) {                list.add(path);            }        }        if (outputStat != null) {            child.copyStat(outputStat);        }    }        if (parentName.startsWith(quotaZookeeper)) {                if (Quotas.limitNode.equals(childName)) {                                    pTrie.addPath(parentName.substring(quotaZookeeper.length()));        }        if (Quotas.statNode.equals(childName)) {            updateQuotaForPath(parentName.substring(quotaZookeeper.length()));        }    }        String lastPrefix = getMaxPrefixWithQuota(path);    long bytes = data == null ? 0 : data.length;    if (lastPrefix != null) {                updateCountBytes(lastPrefix, bytes, 1);    }    updateWriteStat(path, bytes);    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);    childWatches.triggerWatch(parentName.equals("") ? "/" : parentName, Event.EventType.NodeChildrenChanged);}
556622b2a915147b15b040bbea8dce88d022f0464bd41f595ce2ed53b6416d03
deleteNode
public void deleteNode(String path, long zxid) throws KeeperException.NoNodeException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);                DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {        nodes.preChange(parentName, parent);        parent.removeChild(childName);                if (zxid > parent.stat.getPzxid()) {            parent.stat.setPzxid(zxid);        }        nodes.postChange(parentName, parent);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException();    }    nodes.remove(path);    synchronized (node) {        aclCache.removeUsage(node.acl);        nodeDataSize.addAndGet(-getNodeSize(path, node.data));    }        synchronized (parent) {        long eowner = node.stat.getEphemeralOwner();        EphemeralType ephemeralType = EphemeralType.get(eowner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.remove(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.remove(path);        } else if (eowner != 0) {            Set<String> nodes = ephemerals.get(eowner);            if (nodes != null) {                synchronized (nodes) {                    nodes.remove(path);                }            }        }    }    if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {                        pTrie.deletePath(parentName.substring(quotaZookeeper.length()));    }        String lastPrefix = getMaxPrefixWithQuota(path);    if (lastPrefix != null) {                int bytes = 0;        synchronized (node) {            bytes = (node.data == null ? 0 : -(node.data.length));        }        updateCountBytes(lastPrefix, bytes, -1);    }    updateWriteStat(path, 0L);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "dataWatches.triggerWatch " + path);        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "childWatches.triggerWatch " + parentName);    }    WatcherOrBitSet processed = dataWatches.triggerWatch(path, EventType.NodeDeleted);    childWatches.triggerWatch(path, EventType.NodeDeleted, processed);    childWatches.triggerWatch("".equals(parentName) ? "/" : parentName, EventType.NodeChildrenChanged);}
11e9b11ecda2a8453ffb9bfb93276df3b3eac2ca6d9430c7e02d758c09b51d01
setData
public Stat setData(String path, byte[] data, int version, long zxid, long time) throws KeeperException.NoNodeException
{    Stat s = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    byte[] lastdata = null;    synchronized (n) {        lastdata = n.data;        nodes.preChange(path, n);        n.data = data;        n.stat.setMtime(time);        n.stat.setMzxid(zxid);        n.stat.setVersion(version);        n.copyStat(s);        nodes.postChange(path, n);    }        String lastPrefix = getMaxPrefixWithQuota(path);    long dataBytes = data == null ? 0 : data.length;    if (lastPrefix != null) {        this.updateCountBytes(lastPrefix, dataBytes - (lastdata == null ? 0 : lastdata.length), 0);    }    nodeDataSize.addAndGet(getNodeSize(path, data) - getNodeSize(path, lastdata));    updateWriteStat(path, dataBytes);    dataWatches.triggerWatch(path, EventType.NodeDataChanged);    return s;}
6080e5dd039f246f9406bd1b9549cb6ebaf0111ffedbd55514aca48044f3aac1
getMaxPrefixWithQuota
public String getMaxPrefixWithQuota(String path)
{                String lastPrefix = pTrie.findMaxPrefix(path);    if (rootZookeeper.equals(lastPrefix) || lastPrefix.isEmpty()) {        return null;    } else {        return lastPrefix;    }}
e36791dcf003ee2d7f95c7eeb920eddd5544b3ba6e3203b42256907f4031b908
getData
public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    byte[] data = null;    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);        if (watcher != null) {            dataWatches.addWatch(path, watcher);        }        data = n.data;    }    updateReadStat(path, data == null ? 0 : data.length);    return data;}
909a0e966e6bd8d06e86430b6abd15ddf23d36fb5ef031fbdb48a417c6a1f37a
statNode
public Stat statNode(String path, Watcher watcher) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (watcher != null) {        dataWatches.addWatch(path, watcher);    }    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);    }    updateReadStat(path, 0L);    return stat;}
b2190cacc155dee623ad49186338866050d573e19c662e3b0d7d966be720d14b
getChildren
public List<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    List<String> children;    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        children = new ArrayList<String>(n.getChildren());        if (watcher != null) {            childWatches.addWatch(path, watcher);        }    }    int bytes = 0;    for (String child : children) {        bytes += child.length();    }    updateReadStat(path, bytes);    return children;}
0df3c46cd2f5a9af8a68890089ac47a113d2d7c27e09f4b828e78a6caf2a6127
getAllChildrenNumber
public int getAllChildrenNumber(String path)
{        if ("/".equals(path)) {        return nodes.size() - 2;    }    return (int) nodes.keySet().parallelStream().filter(key -> key.startsWith(path + "/")).count();}
1bdd448b17b72a2653492eb6dd0e0a9bccafb8f0a40ae2ccf2690003cedcc58a
setACL
public Stat setACL(String path, List<ACL> acl, int version) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        aclCache.removeUsage(n.acl);        nodes.preChange(path, n);        n.stat.setAversion(version);        n.acl = aclCache.convertAcls(acl);        n.copyStat(stat);        nodes.postChange(path, n);        return stat;    }}
0f08b10ed17262c10807893ae4064c9e508182636756ce7fd88e57c31ee3897f
getACL
public List<ACL> getACL(String path, Stat stat) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        return new ArrayList<ACL>(aclCache.convertLong(n.acl));    }}
252bb89b58cb6dc589592515144ad77088eb7e3c8ef94d1edb1aa3270b0b0f9c
getACL
public List<ACL> getACL(DataNode node)
{    synchronized (node) {        return aclCache.convertLong(node.acl);    }}
97d710ac9e22d0426dd514d04091f1c1ca2377bfea3ed8cc1b26e05e7c8dc4d9
aclCacheSize
public int aclCacheSize()
{    return aclCache.size();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof ProcessTxnResult) {        ProcessTxnResult other = (ProcessTxnResult) o;        return other.clientId == clientId && other.cxid == cxid;    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) ((clientId ^ cxid) % Integer.MAX_VALUE);}
0dceb8ee805e6cda42ef286322a0aaa9664a83b1cf44c65d84c5bfcc9f97977d
processTxn
public ProcessTxnResult processTxn(TxnHeader header, Record txn)
{    return this.processTxn(header, txn, false);}
254ef53d61050a8d9c3b7f2e89f30ffeabedb9417b03cbe636053f4b9465aa7e
processTxn
public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTxn)
{    ProcessTxnResult rc = new ProcessTxnResult();    try {        rc.clientId = header.getClientId();        rc.cxid = header.getCxid();        rc.zxid = header.getZxid();        rc.type = header.getType();        rc.err = 0;        rc.multiResult = null;        switch(header.getType()) {            case OpCode.create:                CreateTxn createTxn = (CreateTxn) txn;                rc.path = createTxn.getPath();                createNode(createTxn.getPath(), createTxn.getData(), createTxn.getAcl(), createTxn.getEphemeral() ? header.getClientId() : 0, createTxn.getParentCVersion(), header.getZxid(), header.getTime(), null);                break;            case OpCode.create2:                CreateTxn create2Txn = (CreateTxn) txn;                rc.path = create2Txn.getPath();                Stat stat = new Stat();                createNode(create2Txn.getPath(), create2Txn.getData(), create2Txn.getAcl(), create2Txn.getEphemeral() ? header.getClientId() : 0, create2Txn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createTTL:                CreateTTLTxn createTtlTxn = (CreateTTLTxn) txn;                rc.path = createTtlTxn.getPath();                stat = new Stat();                createNode(createTtlTxn.getPath(), createTtlTxn.getData(), createTtlTxn.getAcl(), EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()), createTtlTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createContainer:                CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;                rc.path = createContainerTxn.getPath();                stat = new Stat();                createNode(createContainerTxn.getPath(), createContainerTxn.getData(), createContainerTxn.getAcl(), EphemeralType.CONTAINER_EPHEMERAL_OWNER, createContainerTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.delete:            case OpCode.deleteContainer:                DeleteTxn deleteTxn = (DeleteTxn) txn;                rc.path = deleteTxn.getPath();                deleteNode(deleteTxn.getPath(), header.getZxid());                break;            case OpCode.reconfig:            case OpCode.setData:                SetDataTxn setDataTxn = (SetDataTxn) txn;                rc.path = setDataTxn.getPath();                rc.stat = setData(setDataTxn.getPath(), setDataTxn.getData(), setDataTxn.getVersion(), header.getZxid(), header.getTime());                break;            case OpCode.setACL:                SetACLTxn setACLTxn = (SetACLTxn) txn;                rc.path = setACLTxn.getPath();                rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());                break;            case OpCode.closeSession:                long sessionId = header.getClientId();                if (txn != null) {                    killSession(sessionId, header.getZxid(), ephemerals.remove(sessionId), ((CloseSessionTxn) txn).getPaths2Delete());                } else {                    killSession(sessionId, header.getZxid());                }                break;            case OpCode.error:                ErrorTxn errTxn = (ErrorTxn) txn;                rc.err = errTxn.getErr();                break;            case OpCode.check:                CheckVersionTxn checkTxn = (CheckVersionTxn) txn;                rc.path = checkTxn.getPath();                break;            case OpCode.multi:                MultiTxn multiTxn = (MultiTxn) txn;                List<Txn> txns = multiTxn.getTxns();                rc.multiResult = new ArrayList<ProcessTxnResult>();                boolean failed = false;                for (Txn subtxn : txns) {                    if (subtxn.getType() == OpCode.error) {                        failed = true;                        break;                    }                }                boolean post_failed = false;                for (Txn subtxn : txns) {                    ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());                    Record record = null;                    switch(subtxn.getType()) {                        case OpCode.create:                            record = new CreateTxn();                            break;                        case OpCode.createTTL:                            record = new CreateTTLTxn();                            break;                        case OpCode.createContainer:                            record = new CreateContainerTxn();                            break;                        case OpCode.delete:                        case OpCode.deleteContainer:                            record = new DeleteTxn();                            break;                        case OpCode.setData:                            record = new SetDataTxn();                            break;                        case OpCode.error:                            record = new ErrorTxn();                            post_failed = true;                            break;                        case OpCode.check:                            record = new CheckVersionTxn();                            break;                        default:                            throw new IOException("Invalid type of op: " + subtxn.getType());                    }                    assert (record != null);                    ByteBufferInputStream.byteBuffer2Record(bb, record);                    if (failed && subtxn.getType() != OpCode.error) {                        int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() : Code.OK.intValue();                        subtxn.setType(OpCode.error);                        record = new ErrorTxn(ec);                    }                    assert !failed || (subtxn.getType() == OpCode.error);                    TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(), header.getZxid(), header.getTime(), subtxn.getType());                    ProcessTxnResult subRc = processTxn(subHdr, record, true);                    rc.multiResult.add(subRc);                    if (subRc.err != 0 && rc.err == 0) {                        rc.err = subRc.err;                    }                }                break;        }    } catch (KeeperException e) {        LOG.debug("Failed: {}:{}", header, txn, e);        rc.err = e.code().intValue();    } catch (IOException e) {        LOG.debug("Failed: {}:{}", header, txn, e);    }    /*         * Snapshots are taken lazily. When serializing a node, it's data         * and children copied in a synchronization block on that node,         * which means newly created node won't be in the snapshot, so         * we won't have mismatched cversion and pzxid when replaying the         * createNode txn.         *         * But there is a tricky scenario that if the child is deleted due         * to session close and re-created in a different global session         * after that the parent is serialized, then when replay the txn         * because the node is belonging to a different session, replay the         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS         * error when replay the createNode txn. In this case, we need to         * update the cversion and pzxid to the new value.         *         * Note, such failures on DT should be seen only during         * restore.         */    if (header.getType() == OpCode.create && rc.err == Code.NODEEXISTS.intValue()) {        LOG.debug("Adjusting parent cversion for Txn: {} path: {} err: {}", header.getType(), rc.path, rc.err);        int lastSlash = rc.path.lastIndexOf('/');        String parentName = rc.path.substring(0, lastSlash);        CreateTxn cTxn = (CreateTxn) txn;        try {            setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());        } catch (KeeperException.NoNodeException e) {            LOG.error("Failed to set parent cversion for: " + parentName, e);            rc.err = e.code().intValue();        }    } else if (rc.err != Code.OK.intValue()) {        LOG.debug("Ignoring processTxn failure hdr: {} : error: {}", header.getType(), rc.err);    }    /*         * Things we can only update after the whole txn is applied to data         * tree.         *         * If we update the lastProcessedZxid with the first sub txn in multi         * and there is a snapshot in progress, it's possible that the zxid         * associated with the snapshot only include partial of the multi op.         *         * When loading snapshot, it will only load the txns after the zxid         * associated with snapshot file, which could cause data inconsistency         * due to missing sub txns.         *         * To avoid this, we only update the lastProcessedZxid when the whole         * multi-op txn is applied to DataTree.         */    if (!isSubTxn) {        /*             * A snapshot might be in progress while we are modifying the data             * tree. If we set lastProcessedZxid prior to making corresponding             * change to the tree, then the zxid associated with the snapshot             * file will be ahead of its contents. Thus, while restoring from             * the snapshot, the restore method will not apply the transaction             * for zxid associated with the snapshot file, since the restore             * method assumes that transaction to be present in the snapshot.             *             * To avoid this, we first apply the transaction and then modify             * lastProcessedZxid.  During restore, we correctly handle the             * case where the snapshot contains data ahead of the zxid associated             * with the file.             */        if (rc.zxid > lastProcessedZxid) {            lastProcessedZxid = rc.zxid;        }        if (digestFromLoadedSnapshot != null) {            compareSnapshotDigests(rc.zxid);        } else {                        logZxidDigest(rc.zxid, getTreeDigest());        }    }    return rc;}
a1230a581a7cc9da3bc1f9a224fd6d74c0625138bd79cb254cb2cb01be09b2d6
killSession
 void killSession(long session, long zxid)
{                            killSession(session, zxid, ephemerals.remove(session), null);}
b40e40a16a0c6ac3f0754333392ddcc275713212ef568b9a3613272cbf50f989
killSession
 void killSession(long session, long zxid, Set<String> paths2DeleteLocal, List<String> paths2DeleteInTxn)
{    if (paths2DeleteInTxn != null) {        deleteNodes(session, zxid, paths2DeleteInTxn);    }    if (paths2DeleteLocal == null) {        return;    }    if (paths2DeleteInTxn != null) {                for (String path : paths2DeleteInTxn) {            paths2DeleteLocal.remove(path);        }        if (!paths2DeleteLocal.isEmpty()) {            LOG.warn("Unexpected extra paths under session {} which " + "are not in txn 0x{}", paths2DeleteLocal, Long.toHexString(zxid));        }    }    deleteNodes(session, zxid, paths2DeleteLocal);}
e396ad95862f343dfee622157b9612c9550c3907090d38f2bbdfcaa70a27427f
deleteNodes
 void deleteNodes(long session, long zxid, Iterable<String> paths2Delete)
{    for (String path : paths2Delete) {        try {            deleteNode(path, zxid);            if (LOG.isDebugEnabled()) {                LOG.debug("Deleting ephemeral node {} for session 0x{}", path, Long.toHexString(session));            }        } catch (NoNodeException e) {            LOG.warn("Ignoring NoNodeException for path {} while removing ephemeral for dead session 0x{}", path, Long.toHexString(session));        }    }}
00e50056b2cf4696ab6a7203d6f67b6b9f2ae95b9eda72e7ec44579076ae0248
getCounts
private void getCounts(String path, Counts counts)
{    DataNode node = getNode(path);    if (node == null) {        return;    }    String[] children = null;    int len = 0;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);        len = (node.data == null ? 0 : node.data.length);    }        counts.count += 1;    counts.bytes += len;    for (String child : children) {        getCounts(path + "/" + child, counts);    }}
49294a578e46a16bba42a61f7c7332dce63448f2656269dd7c6759f7dd68e9ad
updateQuotaForPath
private void updateQuotaForPath(String path)
{    Counts c = new Counts();    getCounts(path, c);    StatsTrack strack = new StatsTrack();    strack.setBytes(c.bytes);    strack.setCount(c.count);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    DataNode node = getNode(statPath);        if (node == null) {        LOG.warn("Missing quota stat node " + statPath);        return;    }    synchronized (node) {        nodes.preChange(statPath, node);        node.data = strack.toString().getBytes();        nodes.postChange(statPath, node);    }}
8731265124e5de50ea63181dbb4f65812075494eb1a2f1b913a7ec9fc54b241b
traverseNode
private void traverseNode(String path)
{    DataNode node = getNode(path);    String[] children = null;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    if (children.length == 0) {                                String endString = "/" + Quotas.limitNode;        if (path.endsWith(endString)) {                                                String realPath = path.substring(Quotas.quotaZookeeper.length(), path.indexOf(endString));            updateQuotaForPath(realPath);            this.pTrie.addPath(realPath);        }        return;    }    for (String child : children) {        traverseNode(path + "/" + child);    }}
8371968a62e29a33dae2ed42a4309787b33ddf66aa306590650d9c8ed3220775
setupQuota
private void setupQuota()
{    String quotaPath = Quotas.quotaZookeeper;    DataNode node = getNode(quotaPath);    if (node == null) {        return;    }    traverseNode(quotaPath);}
f82faeb6354d15c4a1fd0c1ddd3e48530ab55c6d7025bf037137a9843e375d69
serializeNode
 void serializeNode(OutputArchive oa, StringBuilder path) throws IOException
{    String pathString = path.toString();    DataNode node = getNode(pathString);    if (node == null) {        return;    }    String[] children = null;    DataNode nodeCopy;    synchronized (node) {        StatPersisted statCopy = new StatPersisted();        copyStatPersisted(node.stat, statCopy);                        nodeCopy = new DataNode(node.data, node.acl, statCopy);        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    serializeNodeData(oa, pathString, nodeCopy);    path.append('/');    int off = path.length();    for (String child : children) {                                path.delete(off, Integer.MAX_VALUE);        path.append(child);        serializeNode(oa, path);    }}
3e59049fc4996bb2f40ee1c904e6df94d654a1a685d1f6f3b3d1dce8c860892c
serializeNodeData
public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException
{    oa.writeString(path, "path");    oa.writeRecord(node, "node");}
b5854c53809f727d8c6cd326fdfc2a9b07922c9f682eab3eede2558b61146bbd
serializeAcls
public void serializeAcls(OutputArchive oa) throws IOException
{    aclCache.serialize(oa);}
2c4d1aaf3794beefbd086c5c31a659a39a21b7f8480554f4d529547091b0d2b3
serializeNodes
public void serializeNodes(OutputArchive oa) throws IOException
{    serializeNode(oa, new StringBuilder());        if (root != null) {        oa.writeString("/", "path");    }}
6b1734d911e4728dac8a50e720694c91acf0b390337230914a2d2943f6253d92
serialize
public void serialize(OutputArchive oa, String tag) throws IOException
{    serializeAcls(oa);    serializeNodes(oa);}
43dc1de705906d6d1137d3d82d7c61c9a03a90aa974ad2848f8542de4ceb5aed
deserialize
public void deserialize(InputArchive ia, String tag) throws IOException
{    aclCache.deserialize(ia);    nodes.clear();    pTrie.clear();    nodeDataSize.set(0);    String path = ia.readString("path");    while (!"/".equals(path)) {        DataNode node = new DataNode();        ia.readRecord(node, "node");        nodes.put(path, node);        synchronized (node) {            aclCache.addUsage(node.acl);        }        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1) {            root = node;        } else {            String parentPath = path.substring(0, lastSlash);            DataNode parent = nodes.get(parentPath);            if (parent == null) {                throw new IOException("Invalid Datatree, unable to find " + "parent " + parentPath + " of path " + path);            }            parent.addChild(path.substring(lastSlash + 1));            long eowner = node.stat.getEphemeralOwner();            EphemeralType ephemeralType = EphemeralType.get(eowner);            if (ephemeralType == EphemeralType.CONTAINER) {                containers.add(path);            } else if (ephemeralType == EphemeralType.TTL) {                ttls.add(path);            } else if (eowner != 0) {                HashSet<String> list = ephemerals.get(eowner);                if (list == null) {                    list = new HashSet<String>();                    ephemerals.put(eowner, list);                }                list.add(path);            }        }        path = ia.readString("path");    }            nodes.putWithoutDigest("/", root);    nodeDataSize.set(approximateDataSize());                    setupQuota();    aclCache.purgeUnused();}
524b7023cf7d872b7108599a11d866f2ed01dd4eb812beb84458c6292b629eb6
dumpWatchesSummary
public synchronized void dumpWatchesSummary(PrintWriter pwriter)
{    pwriter.print(dataWatches.toString());}
fad82271f43c2bc71de4dd33470de43c84510903df4a1397ab35bec3228dbbf4
dumpWatches
public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath)
{    dataWatches.dumpWatches(pwriter, byPath);}
5e77c11b22290d7fbd6348c563dcd70e3d50e1d5cf2f10840c426ce9fee3949c
getWatches
public synchronized WatchesReport getWatches()
{    return dataWatches.getWatches();}
a8f41e443396bc6844c10b6e769c0dcc3525f39e0beef9a73d9ea8daee730db8
getWatchesByPath
public synchronized WatchesPathReport getWatchesByPath()
{    return dataWatches.getWatchesByPath();}
f977720a7eeebd4c657462825246f73124399fa40b24941b49c93db44807101d
getWatchesSummary
public synchronized WatchesSummary getWatchesSummary()
{    return dataWatches.getWatchesSummary();}
59a52baae91a6fdb9dbbb9c2fbe63c231bb1711bc6e80addc915f77123c1f636
dumpEphemerals
public void dumpEphemerals(PrintWriter pwriter)
{    pwriter.println("Sessions with Ephemerals (" + ephemerals.keySet().size() + "):");    for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {        pwriter.print("0x" + Long.toHexString(entry.getKey()));        pwriter.println(":");        Set<String> tmp = entry.getValue();        if (tmp != null) {            synchronized (tmp) {                for (String path : tmp) {                    pwriter.println("\t" + path);                }            }        }    }}
942d7c91460aa90055c50fe9199e858ef2529e7b6cdbe33acf6327a03e29cba1
shutdownWatcher
public void shutdownWatcher()
{    dataWatches.shutdown();    childWatches.shutdown();}
c2755b7b00c0543ed659f5cdbcb30aa55f6e2efd5e1b17ebe10bfd6505a86ee2
getEphemerals
public Map<Long, Set<String>> getEphemerals()
{    Map<Long, Set<String>> ephemeralsCopy = new HashMap<Long, Set<String>>();    for (Entry<Long, HashSet<String>> e : ephemerals.entrySet()) {        synchronized (e.getValue()) {            ephemeralsCopy.put(e.getKey(), new HashSet<String>(e.getValue()));        }    }    return ephemeralsCopy;}
69c60688d23bcddcdde20974526d3fc0237564c46eb2d85c6f8a78d9cfd70929
removeCnxn
public void removeCnxn(Watcher watcher)
{    dataWatches.removeWatcher(watcher);    childWatches.removeWatcher(watcher);}
1668f61ec7ea3753952da743c26469a5d73db71965e13c1efde29893f2e5083e
setWatches
public void setWatches(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    for (String path : dataWatches) {        DataNode node = getNode(path);        WatchedEvent e = null;        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getMzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : existWatches) {        DataNode node = getNode(path);        if (node != null) {            watcher.process(new WatchedEvent(EventType.NodeCreated, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : childWatches) {        DataNode node = getNode(path);        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getPzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, path));        } else {            this.childWatches.addWatch(path, watcher);        }    }}
7e02fc7c9a7b4d7d6011f4169019e142a4657a51adc4a2df3a15a5101f005078
setCversionPzxid
public void setCversionPzxid(String path, int newCversion, long zxid) throws KeeperException.NoNodeException
{    if (path.endsWith("/")) {        path = path.substring(0, path.length() - 1);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException(path);    }    synchronized (node) {        if (newCversion == -1) {            newCversion = node.stat.getCversion() + 1;        }        if (newCversion > node.stat.getCversion()) {            nodes.preChange(path, node);            node.stat.setCversion(newCversion);            node.stat.setPzxid(zxid);            nodes.postChange(path, node);        }    }}
e3c95dccbf7ac4c9bab2dafb46a76ab3cec25d1288c3187220f2d138d3d3d708
containsWatcher
public boolean containsWatcher(String path, WatcherType type, Watcher watcher)
{    boolean containsWatcher = false;    switch(type) {        case Children:            containsWatcher = this.childWatches.containsWatcher(path, watcher);            break;        case Data:            containsWatcher = this.dataWatches.containsWatcher(path, watcher);            break;        case Any:            if (this.childWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            if (this.dataWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            break;    }    return containsWatcher;}
c1b10ba9fca4e33b32806ff0caceb17bda156b9262d5854f9e1dda6d29375fa3
removeWatch
public boolean removeWatch(String path, WatcherType type, Watcher watcher)
{    boolean removed = false;    switch(type) {        case Children:            removed = this.childWatches.removeWatcher(path, watcher);            break;        case Data:            removed = this.dataWatches.removeWatcher(path, watcher);            break;        case Any:            if (this.childWatches.removeWatcher(path, watcher)) {                removed = true;            }            if (this.dataWatches.removeWatcher(path, watcher)) {                removed = true;            }            break;    }    return removed;}
2deddbcaaa5299e4648d0c56616642444fabba9532e50556efa3b14222a5f87a
getReferenceCountedAclCache
public ReferenceCountedACLCache getReferenceCountedAclCache()
{    return aclCache;}
54d54214d7cfac2b7d9ff7360a542653e547863f7d230cbe7575fd6a75e153a7
getTopNamespace
private String getTopNamespace(String path)
{    String[] parts = path.split("/");    return parts.length > 1 ? parts[1] : null;}
7dd54ebeaacb52bd65b3beb61309fcfaf523b16845d847138f3a4c9796f93f79
updateReadStat
private void updateReadStat(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    long totalBytes = path.length() + bytes + STAT_OVERHEAD_BYTES;    ServerMetrics.getMetrics().READ_PER_NAMESPACE.add(namespace, totalBytes);}
884cbfa1f0aa600f3f1f56e99bb2d7bcd522329cf9d6ecbc637fc4cc1338b2c1
updateWriteStat
private void updateWriteStat(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    ServerMetrics.getMetrics().WRITE_PER_NAMESPACE.add(namespace, path.length() + bytes);}
728c2b82cc35b26beafca1a919500a36f3cb083dcec5ac04c7d3da3d1183ca7f
logZxidDigest
private void logZxidDigest(long zxid, long digest)
{    ZxidDigest zxidDigest = new ZxidDigest(zxid, digestCalculator.getDigestVersion(), digest);    lastProcessedZxidDigest = zxidDigest;    if (zxidDigest.zxid % DIGEST_LOG_INTERVAL == 0) {        synchronized (digestLog) {            digestLog.add(zxidDigest);            if (digestLog.size() > DIGEST_LOG_LIMIT) {                digestLog.poll();            }        }    }}
4b7b0e4b8883ac2489e14c4de7890769b912a7f55d476d3b984038209f1a7cc4
serializeZxidDigest
public boolean serializeZxidDigest(OutputArchive oa) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    ZxidDigest zxidDigest = lastProcessedZxidDigest;    if (zxidDigest == null) {                zxidDigest = new ZxidDigest();    }    zxidDigest.serialize(oa);    return true;}
86d10ef52a694f9a2c4bc84354136087ddb9135574ef06bff802c4558bc6b725
deserializeZxidDigest
public boolean deserializeZxidDigest(InputArchive ia) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    try {        ZxidDigest zxidDigest = new ZxidDigest();        zxidDigest.deserialize(ia);        if (zxidDigest.zxid > 0) {            digestFromLoadedSnapshot = zxidDigest;        }        return true;    } catch (EOFException e) {        LOG.warn("Got EOF exception while reading the digest, " + "likely due to the reading an older snapshot.");        return false;    }}
ea99fef49857101e8131ef2571335a5867bb9bb3788cee4551c1e123c2cb8a2b
compareSnapshotDigests
public void compareSnapshotDigests(long zxid)
{    if (zxid == digestFromLoadedSnapshot.zxid) {        if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {            LOG.info("Digest version changed, local: {}, new: {}, " + "skip comparing digest now.", digestFromLoadedSnapshot.digestVersion, digestCalculator.getDigestVersion());            digestFromLoadedSnapshot = null;            return;        }        if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {            reportDigestMismatch(zxid);        }        digestFromLoadedSnapshot = null;    } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {        LOG.error("Watching for zxid 0x{} during snapshot recovery, but it wasn't found.", Long.toHexString(digestFromLoadedSnapshot.zxid));    }}
5f6ff08ce3066098d0aad7298361b810c549f31783722de176d7cb77a9f227bf
reportDigestMismatch
public void reportDigestMismatch(long zxid)
{    ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.add(1);    RATE_LOGGER.rateLimitLog("Digests are not matching. Value is Zxid.", String.valueOf(zxid));    for (DigestWatcher watcher : digestWatchers) {        watcher.process(zxid);    }}
65e660351057b06a6b17c5445344b50bf29f3a41734101e44a141c52f0136c5a
getTreeDigest
public long getTreeDigest()
{    return nodes.getDigest();}
f702b646c85d53845f278ba8defa978ddd1bc78a6d5fe7449bd4a8a8c531dc42
getLastProcessedZxidDigest
public ZxidDigest getLastProcessedZxidDigest()
{    return lastProcessedZxidDigest;}
9da24e98f247e4b27d246807acc945971661bfe1bec98404d0ea5534a30f8d4d
getDigestFromLoadedSnapshot
public ZxidDigest getDigestFromLoadedSnapshot()
{    return digestFromLoadedSnapshot;}
568b34ee1a6a29ad92f201ca137576242109b1fb335c4c7a6b1aed0f84eb0211
addDigestWatcher
public void addDigestWatcher(DigestWatcher digestWatcher)
{    digestWatchers.add(digestWatcher);}
8fd0dd9ce4aa1f0b68353598906c88362524c3dfe4c6229c651f19792bcea86e
getDigestLog
public List<ZxidDigest> getDigestLog()
{    synchronized (digestLog) {                return new LinkedList<ZxidDigest>(digestLog);    }}
804c2409666cc36674efb8ffc5a723d3dbd0ccf55f9e21e69f5eb37bdfb1e300
serialize
public void serialize(OutputArchive oa) throws IOException
{    oa.writeLong(zxid, "zxid");    oa.writeInt(digestVersion, "digestVersion");    oa.writeLong(digest, "digest");}
6049ffa8ca8b9f6d596c25a183a90e1a0887d136a2ba63e2aca5627e67bcc861
deserialize
public void deserialize(InputArchive ia) throws IOException
{    zxid = ia.readLong("zxid");    digestVersion = ia.readInt("digestVersion");        if (digestVersion < 2) {        String d = ia.readString("digest");        if (d != null) {            digest = Long.parseLong(d);        }    } else {        digest = ia.readLong("digest");    }}
801e4e9de7001eb2aab4d5e974b3815294de7fb0baf148bdf44fffbf5d770188
getZxid
public long getZxid()
{    return zxid;}
d64e1bf78baf53845530ce548ecf370f6e5cdde0f9804bd0eb7cd388d8b934f9
getDigestVersion
public int getDigestVersion()
{    return digestVersion;}
8dbf930b7294066caaa1c87aea27dd326260039411990ea13e5fa619977d797c
getDigest
public Long getDigest()
{    return digest;}
1b35d3943e93e7bd41c69894e5feefb9a54498a4bfd46389209c1216df41025a
getNodeCount
public int getNodeCount()
{    return dataTree.getNodeCount();}
6d8d43e08c9c4e66537bdd66d5e6f365ea5b478ca3e8dc1d023cd048577582e1
approximateDataSize
public long approximateDataSize()
{    return dataTree.cachedApproximateDataSize();}
44fe2a2eac108b0a73d94bfbbf0479cbc681c130c78166d6677c90a65fdd26d7
countEphemerals
public int countEphemerals()
{    return dataTree.getEphemeralsCount();}
b339fbb11fc521b7313a9ae8d0dc78ad65b43f11f3db269c233dfe7a76e7d593
getWatchCount
public int getWatchCount()
{    return dataTree.getWatchCount();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "InMemoryDataTree";}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
6244117694f70b2f412f799bb5d24892ed4a797a94becfa16eb5376f299f28ff
getLastZxid
public String getLastZxid()
{    return "0x" + Long.toHexString(dataTree.lastProcessedZxid);}
73c06741b4f98543dbbf5e406d734adb0a41c1c903fe6b3ead50210de2e3c074
calculateDigest
 long calculateDigest(String path, byte[] data, StatPersisted stat)
{    if (!ZooKeeperServer.isDigestEnabled()) {        return 0;    }        if (path.startsWith(ZooDefs.ZOOKEEPER_NODE_SUBTREE)) {        return 0;    }        if (path.equals("/")) {        path = "";    }        byte[] b = new byte[60];    ByteBuffer bb = ByteBuffer.wrap(b);    bb.putLong(stat.getCzxid());    bb.putLong(stat.getMzxid());    bb.putLong(stat.getPzxid());    bb.putLong(stat.getCtime());    bb.putLong(stat.getMtime());    bb.putInt(stat.getVersion());    bb.putInt(stat.getCversion());    bb.putInt(stat.getAversion());    bb.putLong(stat.getEphemeralOwner());    CRC32 crc = new CRC32();    crc.update(path.getBytes());    if (data != null) {        crc.update(data);    }    crc.update(b);    return crc.getValue();}
28e65260fd3eee0fd84ad78fdba9740b7d8ca9660a150e09cb52b40c0404d65b
calculateDigest
 long calculateDigest(String path, DataNode node)
{    if (!node.isDigestCached()) {        node.setDigest(calculateDigest(path, node.getData(), node.stat));        node.setDigestCached(true);    }    return node.getDigest();}
2fcdf64e2d2b67ac8463a2f1dfa21c3ae2c0a76629bb72091717fae781711f07
getDigestVersion
 int getDigestVersion()
{    return DIGEST_VERSION;}
1d4de09a3a2a487e449f81cf7918ae28d7fa8da97b1e4305eda9f1ad5d70eaac
setSessionTimeout
 void setSessionTimeout(int sessionTimeout)
{}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
d013dcb84977c811f89e0afbcfa0c2ffd22226ff8f2df083bf362d3529f7f50d
getSessionTimeout
 int getSessionTimeout()
{    return 0;}
1c9432fa2ab8f03d0e6084f264bde3395a658c6eae5d9f77ab6731b061727623
close
public void close(DisconnectReason reason)
{}
db6402a377fb9b7dff7dcb0769cd3009531d0793c8ee73f3aff6a977cfab07e6
sendResponse
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
83bedad6a94f8012a02f99fd25948c531ae8b56f5c41205e172df54952becfda
sendCloseSession
public void sendCloseSession()
{}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return sessionId;}
4caad7677e3c8669c49a7cf1a26239722e0cdff3b855e1e74d91e9ac9126f8d7
setSessionId
 void setSessionId(long sessionId)
{}
516f988d90d82fb15c8b4f84f8242702b22918ce02a776f8de79dd601eebe350
sendBuffer
 void sendBuffer(ByteBuffer... closeConn)
{}
58e68b4c85468ffa08c7f42ace5739cd939eca225af3ce7aafe5e31dd2a6513d
enableRecv
 void enableRecv()
{}
fe7a18ded4731107a3305283fa7ce03cf99850740564c8b731ad3853edf00003
disableRecv
 void disableRecv(boolean waitDisableRecv)
{}
907231e17b9059060ce5f7ec8aed9ef0cfaf0f263ebbdb7958c25318ca9b292f
serverStats
protected ServerStats serverStats()
{    return null;}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return 0;}
76a476412aec6ec4444db04281072f7ce0f60422f623a495c0cad0291582361e
getRemoteSocketAddress
public InetSocketAddress getRemoteSocketAddress()
{    return null;}
86eb23327d1db1d9d92af99641864e1a6bd00027abe7be9d5631d6288afd997b
getInterestOps
public int getInterestOps()
{    return 0;}
c6a8b35027b486f9efda96936274975b221803473bdc28c586ea3371f63c78bd
isSecure
public boolean isSecure()
{    return false;}
31723976639143740a59331b89e7d277a06f3d1c59275eadebaa8b8c1e08a73d
getClientCertificateChain
public Certificate[] getClientCertificateChain()
{    return null;}
3c4125d7fc81566a8a507cd911ec199b7df322e075d329f458f8ea707600fb9d
setClientCertificateChain
public void setClientCertificateChain(Certificate[] chain)
{}
fcbb03c16ca584a6ed56c2e92be05a78959a41285c90908f1702bee02a371f6f
maxValue
public long maxValue()
{    return 0;}
443059fedefdf00f27a8d344b96676a74c3ec710720745378536cc4be7781d0c
toEphemeralOwner
public long toEphemeralOwner(long value)
{    return 0;}
6ab7304644fb3b1f9e430c3368b91c7b7008282c5ee80d8260512fa376c993d9
getValue
public long getValue(long ephemeralOwner)
{    return 0;}
f6b09e552bb82b4a0aff8477c264661d3ec8c7b480c8461e5b74e3e9d3097cff
extendedEphemeralTypesEnabled
public static boolean extendedEphemeralTypesEnabled()
{    return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);}
5cf520bc72db6d3d8a6c162a3e773928966d1590cb1932ee6f37235d55825bb4
get
public static EphemeralType get(long ephemeralOwner)
{    if (extendedEphemeralTypesEnabled()) {        if (Boolean.getBoolean(TTL_3_5_3_EMULATION_PROPERTY)) {            if (EphemeralTypeEmulate353.get(ephemeralOwner) == EphemeralTypeEmulate353.TTL) {                return TTL;            }        }        if ((ephemeralOwner & EXTENDED_MASK) == EXTENDED_MASK) {            long extendedFeatureBit = getExtendedFeatureBit(ephemeralOwner);            EphemeralType ephemeralType = extendedFeatureMap.get(extendedFeatureBit);            if (ephemeralType == null) {                throw new IllegalArgumentException(String.format("Invalid ephemeralOwner. [%s]", Long.toHexString(ephemeralOwner)));            }            return ephemeralType;        }    }    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
5948372ad7f605fb30618b2ee222d290700732b094dfb6d69fe562b6f4ad4831
validateServerId
public static void validateServerId(long serverId)
{    if (extendedEphemeralTypesEnabled()) {        if (serverId > EphemeralType.MAX_EXTENDED_SERVER_ID) {            throw new RuntimeException("extendedTypesEnabled is true but Server ID is too large. Cannot be larger than " + EphemeralType.MAX_EXTENDED_SERVER_ID);        }    }}
e8bfa6de1d5b4bccf0c872f2bf7b19eeaa26137f1603ccddee6ab1ab2413244a
validateTTL
public static void validateTTL(CreateMode mode, long ttl)
{    if (mode.isTTL()) {        TTL.toEphemeralOwner(ttl);    } else if (ttl >= 0) {        throw new IllegalArgumentException("ttl not valid for mode: " + mode);    }}
097cbf7dc6bdea4cf3819b56505f7c6010416f22ef9fd53d886e0b955395b571
getExtendedFeatureBit
private static long getExtendedFeatureBit(long ephemeralOwner)
{    return (ephemeralOwner & RESERVED_BITS_MASK) >> RESERVED_BITS_SHIFT;}
6ad23681bb92a6d730d7a71afe7fdcd1b3dc5f438ea1cb4763be7fe00ac313ea
getExtendedFeatureValue
private static long getExtendedFeatureValue(long ephemeralOwner)
{    return ephemeralOwner & EXTENDED_FEATURE_VALUE_MASK;}
fcbb03c16ca584a6ed56c2e92be05a78959a41285c90908f1702bee02a371f6f
maxValue
public long maxValue()
{        return EXTENDED_FEATURE_VALUE_MASK;}
89b2ed3a4c250d54521e4663413a29c1681142a790884833ebda8d434cdace03
toEphemeralOwner
public long toEphemeralOwner(long ttl)
{    if ((ttl > TTL.maxValue()) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + TTL.maxValue());    }        return EXTENDED_MASK | EXTENDED_BIT_TTL |     ttl;}
6ab7304644fb3b1f9e430c3368b91c7b7008282c5ee80d8260512fa376c993d9
getValue
public long getValue(long ephemeralOwner)
{    return getExtendedFeatureValue(ephemeralOwner);}
58e70947cfe158c6d9277f772447b34aaf081c25ba9e464bf5504d2a22b39bc2
get
public static EphemeralTypeEmulate353 get(long ephemeralOwner)
{    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    if (ephemeralOwner < 0) {        return TTL;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
f9b65768e7cfc03e989ba9bdece86df47a354e95f45922415e33b44272578121
ttlToEphemeralOwner
public static long ttlToEphemeralOwner(long ttl)
{    if ((ttl > MAX_TTL) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + MAX_TTL);    }    return TTL_MASK | ttl;}
7f820eeb69ca0b6ba212f7fa738d25f53ebc1bc5cfb29c2200e154ad62791a65
getValue
public int getValue()
{    return value;}
8416426d2e8807b79972e93513914c39f8c65e00431ab69879edbf1e84575ece
roundToNextInterval
private long roundToNextInterval(long time)
{    return (time / expirationInterval + 1) * expirationInterval;}
97f658fa48961c7ff221cd9b14bfb0fac3ec8f0f45e8463a157c79115c74fc38
remove
public Long remove(E elem)
{    Long expiryTime = elemMap.remove(elem);    if (expiryTime != null) {        Set<E> set = expiryMap.get(expiryTime);        if (set != null) {            set.remove(elem);                        }    }    return expiryTime;}
60afd55fd47b1258da18b9c06407a6fcc45cc9c6eac359975403f09a5b74d431
update
public Long update(E elem, int timeout)
{    Long prevExpiryTime = elemMap.get(elem);    long now = Time.currentElapsedTime();    Long newExpiryTime = roundToNextInterval(now + timeout);    if (newExpiryTime.equals(prevExpiryTime)) {                return null;    }        Set<E> set = expiryMap.get(newExpiryTime);    if (set == null) {                set = Collections.newSetFromMap(new ConcurrentHashMap<E, Boolean>());                        Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(elem);            prevExpiryTime = elemMap.put(elem, newExpiryTime);    if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {        Set<E> prevSet = expiryMap.get(prevExpiryTime);        if (prevSet != null) {            prevSet.remove(elem);        }    }    return newExpiryTime;}
4297d8f6f5a0afee2346872629193e7dbd2519ff702e258d3f34accb2a8eb7bd
getWaitTime
public long getWaitTime()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    return now < expirationTime ? (expirationTime - now) : 0L;}
87083f8e1b12187bdca008c4e4b134e02940d32e97dc01a1fa5bab306aa2cd33
poll
public Set<E> poll()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    if (now < expirationTime) {        return Collections.emptySet();    }    Set<E> set = null;    long newExpirationTime = expirationTime + expirationInterval;    if (nextExpirationTime.compareAndSet(expirationTime, newExpirationTime)) {        set = expiryMap.remove(expirationTime);    }    if (set == null) {        return Collections.emptySet();    }    return set;}
d990018206119edb765a2ce10252752e8e95b0bfb627760bde66114978ca14da
dump
public void dump(PrintWriter pwriter)
{    pwriter.print("Sets (");    pwriter.print(expiryMap.size());    pwriter.print(")/(");    pwriter.print(elemMap.size());    pwriter.println("):");    ArrayList<Long> keys = new ArrayList<Long>(expiryMap.keySet());    Collections.sort(keys);    for (long time : keys) {        Set<E> set = expiryMap.get(time);        if (set != null) {            pwriter.print(set.size());            pwriter.print(" expire at ");            pwriter.print(Time.elapsedTimeToDate(time));            pwriter.println(":");            for (E elem : set) {                pwriter.print("\t");                pwriter.println(elem.toString());            }        }    }}
6d9133983d1882e4b63e8ccfd14095ec8348e4119ff6f3edd78e1061e119b111
getExpiryMap
public Map<Long, Set<E>> getExpiryMap()
{    return Collections.unmodifiableMap(expiryMap);}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    LOG.debug("Processing request:: {}", request);        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;    if (request.type == OpCode.ping) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logRequest(LOG, traceMask, 'E', request, "");    }    ProcessTxnResult rc = zks.processTxn(request);        if (request.type == OpCode.closeSession && connClosedByClient(request)) {                if (closeSession(zks.serverCnxnFactory, request.sessionId) || closeSession(zks.secureServerCnxnFactory, request.sessionId)) {            return;        }    }    if (request.getHdr() != null) {        /*             * Request header is created only by the leader, so this must be             * a quorum request. Since we're comparing timestamps across hosts,             * this metric may be incorrect. However, it's still a very useful             * metric to track in the happy case. If there is clock drift,             * the latency can go negative. Note: headers use wall time, not             * CLOCK_MONOTONIC.             */        long propagationLatency = Time.currentWallTime() - request.getHdr().getTime();        if (propagationLatency >= 0) {            ServerMetrics.getMetrics().PROPAGATION_LATENCY.add(propagationLatency);        }    }    if (request.cnxn == null) {        return;    }    ServerCnxn cnxn = request.cnxn;    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();    String lastOp = "NA";            zks.decInProcess();    zks.requestFinished(request);    Code err = Code.OK;    Record rsp = null;    String path = null;    try {        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {            /*                 * When local session upgrading is disabled, leader will                 * reject the ephemeral node creation due to session expire.                 * However, if this is the follower that issue the request,                 * it will have the correct error code, so we should use that                 * and report to user                 */            if (request.getException() != null) {                throw request.getException();            } else {                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));            }        }        KeeperException ke = request.getException();        if (ke instanceof SessionMovedException) {            throw ke;        }        if (ke != null && request.type != OpCode.multi) {            throw ke;        }        LOG.debug("{}", request);        if (request.isStale()) {            ServerMetrics.getMetrics().STALE_REPLIES.add(1);        }        switch(request.type) {            case OpCode.ping:                {                    lastOp = "PING";                    updateStats(request, lastOp, lastZxid);                    cnxn.sendResponse(new ReplyHeader(-2, lastZxid, 0), null, "response");                    return;                }            case OpCode.createSession:                {                    lastOp = "SESS";                    updateStats(request, lastOp, lastZxid);                    zks.finishSessionInit(request.cnxn, true);                    return;                }            case OpCode.multi:                {                    lastOp = "MULT";                    rsp = new MultiResponse();                    for (ProcessTxnResult subTxnResult : rc.multiResult) {                        OpResult subResult;                        switch(subTxnResult.type) {                            case OpCode.check:                                subResult = new CheckResult();                                break;                            case OpCode.create:                                subResult = new CreateResult(subTxnResult.path);                                break;                            case OpCode.create2:                            case OpCode.createTTL:                            case OpCode.createContainer:                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);                                break;                            case OpCode.delete:                            case OpCode.deleteContainer:                                subResult = new DeleteResult();                                break;                            case OpCode.setData:                                subResult = new SetDataResult(subTxnResult.stat);                                break;                            case OpCode.error:                                subResult = new ErrorResult(subTxnResult.err);                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {                                    throw new SessionMovedException();                                }                                break;                            default:                                throw new IOException("Invalid type of op");                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.multiRead:                {                    lastOp = "MLTR";                    MultiOperationRecord multiReadRecord = new MultiOperationRecord();                    ByteBufferInputStream.byteBuffer2Record(request.request, multiReadRecord);                    rsp = new MultiResponse();                    OpResult subResult;                    for (Op readOp : multiReadRecord) {                        try {                            Record rec;                            switch(readOp.getType()) {                                case OpCode.getChildren:                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());                                    break;                                case OpCode.getData:                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    GetDataResponse gdr = (GetDataResponse) rec;                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());                                    break;                                default:                                    throw new IOException("Invalid type of readOp");                            }                        } catch (KeeperException e) {                            subResult = new ErrorResult(e.code().intValue());                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.create:                {                    lastOp = "CREA";                    rsp = new CreateResponse(rc.path);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.create2:            case OpCode.createTTL:            case OpCode.createContainer:                {                    lastOp = "CREA";                    rsp = new Create2Response(rc.path, rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.delete:            case OpCode.deleteContainer:                {                    lastOp = "DELE";                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.setData:                {                    lastOp = "SETD";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.reconfig:                {                    lastOp = "RECO";                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.setACL:                {                    lastOp = "SETA";                    rsp = new SetACLResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.closeSession:                {                    lastOp = "CLOS";                    err = Code.get(rc.err);                    break;                }            case OpCode.sync:                {                    lastOp = "SYNC";                    SyncRequest syncRequest = new SyncRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, syncRequest);                    rsp = new SyncResponse(syncRequest.getPath());                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());                    break;                }            case OpCode.check:                {                    lastOp = "CHEC";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.exists:                {                    lastOp = "EXIS";                                        ExistsRequest existsRequest = new ExistsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, existsRequest);                    path = existsRequest.getPath();                    if (path.indexOf('\0') != -1) {                        throw new KeeperException.BadArgumentsException();                    }                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);                    rsp = new ExistsResponse(stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getData:                {                    lastOp = "GETD";                    GetDataRequest getDataRequest = new GetDataRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getDataRequest);                    path = getDataRequest.getPath();                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.setWatches:                {                    lastOp = "SETW";                    SetWatches setWatches = new SetWatches();                                        request.request.rewind();                    ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);                    long relativeZxid = setWatches.getRelativeZxid();                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), cnxn);                    break;                }            case OpCode.getACL:                {                    lastOp = "GETA";                    GetACLRequest getACLRequest = new GetACLRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getACLRequest);                    path = getACLRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);                    Stat stat = new Stat();                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());                    try {                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);                        rsp = new GetACLResponse(acl, stat);                    } catch (KeeperException.NoAuthException e) {                        List<ACL> acl1 = new ArrayList<ACL>(acl.size());                        for (ACL a : acl) {                            if ("digest".equals(a.getId().getScheme())) {                                Id id = a.getId();                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(":.*", ":x"));                                acl1.add(new ACL(a.getPerms(), id1));                            } else {                                acl1.add(a);                            }                        }                        rsp = new GetACLResponse(acl1, stat);                    }                    break;                }            case OpCode.getChildren:                {                    lastOp = "GETC";                    GetChildrenRequest getChildrenRequest = new GetChildrenRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildrenRequest);                    path = getChildrenRequest.getPath();                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getAllChildrenNumber:                {                    lastOp = "GETACN";                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = new GetAllChildrenNumberRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getAllChildrenNumberRequest);                    path = getAllChildrenNumberRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    int number = zks.getZKDatabase().getAllChildrenNumber(path);                    rsp = new GetAllChildrenNumberResponse(number);                    break;                }            case OpCode.getChildren2:                {                    lastOp = "GETC";                    GetChildren2Request getChildren2Request = new GetChildren2Request();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildren2Request);                    Stat stat = new Stat();                    path = getChildren2Request.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);                    rsp = new GetChildren2Response(children, stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.checkWatches:                {                    lastOp = "CHKW";                    CheckWatchesRequest checkWatches = new CheckWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, checkWatches);                    WatcherType type = WatcherType.fromInt(checkWatches.getType());                    path = checkWatches.getPath();                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);                    if (!containsWatcher) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());                    break;                }            case OpCode.removeWatches:                {                    lastOp = "REMW";                    RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, removeWatches);                    WatcherType type = WatcherType.fromInt(removeWatches.getType());                    path = removeWatches.getPath();                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);                    if (!removed) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());                    break;                }            case OpCode.getEphemerals:                {                    lastOp = "GETE";                    GetEphemeralsRequest getEphemerals = new GetEphemeralsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getEphemerals);                    String prefixPath = getEphemerals.getPrefixPath();                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);                    List<String> ephemerals = new ArrayList<>();                    if (StringUtils.isBlank(prefixPath) || "/".equals(prefixPath.trim())) {                        ephemerals.addAll(allEphems);                    } else {                        for (String p : allEphems) {                            if (p.startsWith(prefixPath)) {                                ephemerals.add(p);                            }                        }                    }                    rsp = new GetEphemeralsResponse(ephemerals);                    break;                }        }    } catch (SessionMovedException e) {                                                                        cnxn.sendCloseSession();        return;    } catch (KeeperException e) {        err = e.code();    } catch (Exception e) {                        LOG.error("Failed to process " + request, e);        StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        bb.rewind();        while (bb.hasRemaining()) {            sb.append(Integer.toHexString(bb.get() & 0xff));        }        LOG.error("Dumping request buffer: 0x" + sb.toString());        err = Code.MARSHALLINGERROR;    }    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());    updateStats(request, lastOp, lastZxid);    try {        if (request.type == OpCode.getData && path != null && rsp != null) {                                                GetDataResponse getDataResponse = (GetDataResponse) rsp;            Stat stat = null;            if (getDataResponse.getStat() != null) {                stat = getDataResponse.getStat();            }            cnxn.sendResponse(hdr, rsp, "response", path, stat);        } else {            cnxn.sendResponse(hdr, rsp, "response");        }        if (request.type == OpCode.closeSession) {            cnxn.sendCloseSession();        }    } catch (IOException e) {        LOG.error("FIXMSG", e);    }}
2429dada51818e5e39a667fcc429948bb39e21144177e1c12443153953480804
handleGetChildrenRequest
private Record handleGetChildrenRequest(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetChildrenRequest getChildrenRequest = (GetChildrenRequest) request;    String path = getChildrenRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    List<String> children = zks.getZKDatabase().getChildren(path, null, getChildrenRequest.getWatch() ? cnxn : null);    return new GetChildrenResponse(children);}
b9c500eba05dbab807477a85475304bc8cbc95883d4cc85ce217aacafbaae100
handleGetDataRequest
private Record handleGetDataRequest(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetDataRequest getDataRequest = (GetDataRequest) request;    String path = getDataRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    Stat stat = new Stat();    byte[] b = zks.getZKDatabase().getData(path, stat, getDataRequest.getWatch() ? cnxn : null);    return new GetDataResponse(b, stat);}
1e3bc43fe4997e1b83b3a77d00924f41cb011475516260f0e3d2c18442434b55
closeSession
private boolean closeSession(ServerCnxnFactory serverCnxnFactory, long sessionId)
{    if (serverCnxnFactory == null) {        return false;    }    return serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_CLOSED_SESSION);}
89b7e484dc2ff45bc26024a05eb5d93bea4dad1a94d8292595c93d103b4c181b
connClosedByClient
private boolean connClosedByClient(Request request)
{    return request.cnxn == null;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{        LOG.info("shutdown of request processor complete");}
924d22c98440a46f0090bdebf976d68690dd167afa0be5113a23942610655614
updateStats
private void updateStats(Request request, String lastOp, long lastZxid)
{    if (request.cnxn == null) {        return;    }    long currentTime = Time.currentElapsedTime();    zks.serverStats().updateLatency(request, currentTime);    request.cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp, request.createTime, currentTime);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("USAGE: LogFormatter log_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(args[0]);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileInputStream fis = new FileInputStream(args[0]);    BinaryInputArchive logStream = BinaryInputArchive.getArchive(fis);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number for " + args[0]);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())) + " session 0x" + Long.toHexString(hdr.getClientId()) + " cxid 0x" + Long.toHexString(hdr.getCxid()) + " zxid 0x" + Long.toHexString(hdr.getZxid()) + " " + Request.op2String(hdr.getType()) + " " + txn);        if (logStream.readByte("EOR") != 'B') {            LOG.error("Last transaction was partial.");            throw new EOFException("Last transaction was partial.");        }        count++;    }}
6c77605bf79e44a20d2132fd08a5c07ec22d9346e897c2266615ccf9f08f9091
addDataPoint
public void addDataPoint(long value)
{    total.addAndGet(value);    count.incrementAndGet();    setMin(value);    setMax(value);}
68b218ddb7097b146122b9d86318c99179d8c70163a59a937dc214b94770a7bb
setMax
private void setMax(long value)
{    long current;    while (value > (current = max.get()) && !max.compareAndSet(current, value)) {        }}
541c7cb1fb4238cab82c3e6cfbc5710169c985f4b2a2c44fe6b046bfade158d5
setMin
private void setMin(long value)
{    long current;    while (value < (current = min.get()) && !min.compareAndSet(current, value)) {        }}
4a2c7a2444af1c39b1e5812bdc9a5196c0b010d2c3f1f65f98d192c017fe042a
getAvg
public double getAvg()
{            long currentCount = count.get();    long currentTotal = total.get();    if (currentCount > 0) {        double avgLatency = currentTotal / (double) currentCount;        BigDecimal bg = new BigDecimal(avgLatency);        return bg.setScale(4, RoundingMode.HALF_UP).doubleValue();    }    return 0;}
4bf990342727536109cd77a29149345256f33b328f596b96f11cb4f2c9906922
getCount
public long getCount()
{    return count.get();}
186954df172aa73793e35935d4d56173de402d5bb93fb733250e56ecabcc93cf
getMax
public long getMax()
{    long current = max.get();    return (current == Long.MIN_VALUE) ? 0 : current;}
e5532703446ad984632281d343d0cf95efa3233ebe068d58acaafd92f78afafd
getMin
public long getMin()
{    long current = min.get();    return (current == Long.MAX_VALUE) ? 0 : current;}
83ff1289bdb87bea8b566d375fcf71338a9f70868cffbc36bc6739ee9fee4ef2
getTotal
public long getTotal()
{    return total.get();}
f509ba93e3f601de256a7c4695864a8973dc873258b6aad34c0b5f0c14bf5a39
resetMax
public void resetMax()
{    max.set(getMin());}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    count.set(0);    total.set(0);    min.set(Long.MAX_VALUE);    max.set(Long.MIN_VALUE);}
940396fdb6f99c2073f47f03306548efb7fba34e64d0d5e5b499d32e0f95375b
add
public void add(long value)
{    addDataPoint(value);}
6d192d08f73f69e58dabb611d479bfa2428ce154d76f399aa828ac5dd818a244
values
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put("avg_" + name, this.getAvg());    m.put("min_" + name, this.getMin());    m.put("max_" + name, this.getMax());    m.put("cnt_" + name, this.getCount());    m.put("sum_" + name, this.getTotal());    return m;}
9325759d7322b9424ecb990f8d3430b0cb08d5905d33137c35d95452ee87f8e8
getCounterForKey
private AvgMinMaxCounter getCounterForKey(String key)
{    AvgMinMaxCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
c66a67f33dc2945eadb0c0955a7190b8b6757e5c4f3d0bbf3e6d3c588c97b36c
addDataPoint
public void addDataPoint(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
f509ba93e3f601de256a7c4695864a8973dc873258b6aad34c0b5f0c14bf5a39
resetMax
public void resetMax()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
8afe3bc5a20d23fed03deefb3f9c911c73f164c0931dbfda26a2ac5b69076546
add
public void add(String key, long value)
{    addDataPoint(key, value);}
6d192d08f73f69e58dabb611d479bfa2428ce154d76f399aa828ac5dd818a244
values
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    final long c = count.get();    if (c > values.length()) {        return values.length();    }    return (int) c;}
a584b6622a7dc27bba2e1c8ea31dd391bcb4d672d8fd5b9e53d751ac750924c5
update
public void update(long value)
{    final long c = count.incrementAndGet();    if (c <= values.length()) {        values.set((int) c - 1, value);    } else {        final long r = nextLong(c);        if (r < values.length()) {            values.set((int) r, value);        }    }}
e5c1053f908ffa795e5052cd3d87f612efe3389333cd86cf3d758511dd6e49e3
nextLong
private static long nextLong(long n)
{    long bits, val;    do {        bits = ThreadLocalRandom.current().nextLong() & (~(1L << BITS_PER_LONG));        val = bits % n;    } while (bits - val + (n - 1) < 0L);    return val;}
13a4e56fbc8e4ffe4b51cbe576d9f30dae2d4d4df5dea3bd557b6178b6fa21fc
getSnapshot
public Snapshot getSnapshot()
{    final int s = size();    final List<Long> copy = new ArrayList<Long>(s);    for (int i = 0; i < s; i++) {        copy.add(values.get(i));    }    return new UniformSnapshot(copy);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    count.set(0);    values = new AtomicLongArray(DEFAULT_SIZE);}
6c77605bf79e44a20d2132fd08a5c07ec22d9346e897c2266615ccf9f08f9091
addDataPoint
public void addDataPoint(long value)
{    counter.add(value);    histogram.update(value);}
f509ba93e3f601de256a7c4695864a8973dc873258b6aad34c0b5f0c14bf5a39
resetMax
public void resetMax()
{        counter.resetMax();}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    counter.reset();    reservoir.reset();}
940396fdb6f99c2073f47f03306548efb7fba34e64d0d5e5b499d32e0f95375b
add
public void add(long value)
{    addDataPoint(value);}
6d192d08f73f69e58dabb611d479bfa2428ce154d76f399aa828ac5dd818a244
values
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    m.putAll(counter.values());    m.put("p50_" + name, Math.round(this.histogram.getSnapshot().getMedian()));    m.put("p95_" + name, Math.round(this.histogram.getSnapshot().get95thPercentile()));    m.put("p99_" + name, Math.round(this.histogram.getSnapshot().get99thPercentile()));    m.put("p999_" + name, Math.round(this.histogram.getSnapshot().get999thPercentile()));    return m;}
f5e01d34b5f7a6e21fd0edcaf948015ba190898c92efbf4641c47e7353b00af4
getCounterForKey
private AvgMinMaxPercentileCounter getCounterForKey(String key)
{    AvgMinMaxPercentileCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxPercentileCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
c66a67f33dc2945eadb0c0955a7190b8b6757e5c4f3d0bbf3e6d3c588c97b36c
addDataPoint
public void addDataPoint(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
f509ba93e3f601de256a7c4695864a8973dc873258b6aad34c0b5f0c14bf5a39
resetMax
public void resetMax()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
8afe3bc5a20d23fed03deefb3f9c911c73f164c0931dbfda26a2ac5b69076546
add
public void add(String key, long value)
{    addDataPoint(key, value);}
6d192d08f73f69e58dabb611d479bfa2428ce154d76f399aa828ac5dd818a244
values
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
940396fdb6f99c2073f47f03306548efb7fba34e64d0d5e5b499d32e0f95375b
add
public void add(long value)
{}
486e306c95aa960213ea4381a5305a18f8e7ee993b458a065c33aa560ba4a0ca
add
public void add(int key, long value)
{}
8afe3bc5a20d23fed03deefb3f9c911c73f164c0931dbfda26a2ac5b69076546
add
public void add(String key, long value)
{}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{}
940396fdb6f99c2073f47f03306548efb7fba34e64d0d5e5b499d32e0f95375b
add
public void add(long value)
{    counter.addAndGet(value);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    counter.set(0);}
9c296a9ae6604f1ab76b67812ec53c653913df94f0267698b3e9a72e90441ce2
get
public long get()
{    return counter.get();}
6d192d08f73f69e58dabb611d479bfa2428ce154d76f399aa828ac5dd818a244
values
public Map<String, Object> values()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put(name, this.get());    return m;}
1c9432fa2ab8f03d0e6084f264bde3395a658c6eae5d9f77ab6731b061727623
close
public void close(DisconnectReason reason)
{    disconnectReason = reason;    close();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    closingChannel = true;    if (LOG.isDebugEnabled()) {        LOG.debug("close called for sessionid:0x{}", Long.toHexString(sessionId));    }    setStale();                factory.unregisterConnection(this);        if (!factory.cnxns.remove(this)) {        if (LOG.isDebugEnabled()) {            LOG.debug("cnxns size:{}", factory.cnxns.size());        }        return;    }    if (LOG.isDebugEnabled()) {        LOG.debug("close in progress for sessionid:0x{}", Long.toHexString(sessionId));    }    factory.removeCnxnFromSessionMap(this);    factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (channel.isOpen()) {                                channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture future) {                future.channel().close().addListener(f -> releaseQueuedBuffer());            }        });    } else {        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);        channel.eventLoop().execute(this::releaseQueuedBuffer);    }}
9aef21835d4f51f1c39c378e9eaa39533f602d721c361215253cba063d4c658e
operationComplete
public void operationComplete(ChannelFuture future)
{    future.channel().close().addListener(f -> releaseQueuedBuffer());}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return sessionId;}
2436723c695636833e0ebfc52d684cb9ae4da078ffa3153b560d8213802ad011
getSessionTimeout
public int getSessionTimeout()
{    return sessionTimeout;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    try {        sendResponse(h, e, "notification");    } catch (IOException e1) {        if (LOG.isDebugEnabled()) {            LOG.debug("Problem sending to " + getRemoteSocketAddress(), e1);        }        close();    }}
db6402a377fb9b7dff7dcb0769cd3009531d0793c8ee73f3aff6a977cfab07e6
sendResponse
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{        if (closingChannel || !channel.isOpen()) {        return;    }    sendBuffer(serialize(h, r, tag, cacheKey, stat));    decrOutstandingAndCheckThrottle(h);}
91f18d9c3e10f1b7f5263074e38c28fa48018551fc4c88831c38d8803b1d8c51
setSessionId
public void setSessionId(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
737d8d6a95398a29600cb0306e2eaefc81f34cbe5def1f6f18fa3b9e0b6d7cbb
sendBuffer
public void sendBuffer(ByteBuffer... buffers)
{    if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {        close(DisconnectReason.CLIENT_CLOSED_CONNECTION);        return;    }    channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);}
e98bcfdb1a2687a780af10c2b225f931708556d106c9fe099b4b5616815cbd7f
checkFlush
private void checkFlush(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    checkFlush(true);}
e1a8f4065443590888d0a504354993fe93e0bf5b76f29d77ce33949e79fe5e10
write
public void write(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
62e0c2314c46a46ef3ebb493a3874e77741b96f807eef9f0d926e34860b326f7
checkFourLetterWord
private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len)
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);                channel.config().setAutoRead(false);    packetReceived(4);    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {        LOG.debug("Command {} is not executed because it is not in the whitelist.", cmd);        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }    LOG.info("Processing {} command from {}", cmd, channel.remoteAddress());    if (len == FourLetterCommands.setTraceMaskCmd) {        ByteBuffer mask = ByteBuffer.allocate(8);        message.readBytes(mask);        mask.flip();        long traceMask = mask.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
3980ef1ba321195b6272c07826530e9d67e9f6a7e52038c8810d83af812a3baa
checkIsInEventLoop
private void checkIsInEventLoop(String callerMethodName)
{    if (!channel.eventLoop().inEventLoop()) {        throw new IllegalStateException(callerMethodName + "() called from non-EventLoop thread");    }}
807227229f444aff11b09526828b57487bc201546901fe54709dd240c0927dc1
appendToQueuedBuffer
private void appendToQueuedBuffer(ByteBuf buf)
{    checkIsInEventLoop("appendToQueuedBuffer");    if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {                queuedBuffer.consolidate();    }    queuedBuffer.addComponent(true, buf);    ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());}
a86ab3c8a5bde58e0b4f085721d092b30137dddf10a40eaf2cab548d8f677916
processMessage
 void processMessage(ByteBuf buf)
{    checkIsInEventLoop("processMessage");    if (LOG.isDebugEnabled()) {        LOG.debug("0x{} queuedBuffer: {}", Long.toHexString(sessionId), queuedBuffer);    }    if (LOG.isTraceEnabled()) {        LOG.trace("0x{} buf {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));    }    if (throttled.get()) {        LOG.debug("Received message while throttled");                if (queuedBuffer == null) {            LOG.debug("allocating queue");            queuedBuffer = channel.alloc().compositeBuffer();        }        appendToQueuedBuffer(buf.retainedDuplicate());        if (LOG.isTraceEnabled()) {            LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }    } else {        LOG.debug("not throttled");        if (queuedBuffer != null) {            appendToQueuedBuffer(buf.retainedDuplicate());            processQueuedBuffer();        } else {            receiveMessage(buf);                        if (!closingChannel && buf.isReadable()) {                LOG.trace("Before copy {}", buf);                if (queuedBuffer == null) {                    queuedBuffer = channel.alloc().compositeBuffer();                }                appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));                if (LOG.isTraceEnabled()) {                    LOG.trace("Copy is {}", queuedBuffer);                    LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));                }            }        }    }}
5532aeadf3fc8043b23510865f4d69e25a4a3bfd3ee33609cb436456ab40db27
processQueuedBuffer
 void processQueuedBuffer()
{    checkIsInEventLoop("processQueuedBuffer");    if (queuedBuffer != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("processing queue 0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }        receiveMessage(queuedBuffer);        if (closingChannel) {                        LOG.debug("Processed queue - channel closed, dropping remaining bytes");        } else if (!queuedBuffer.isReadable()) {            LOG.debug("Processed queue - no bytes remaining");            releaseQueuedBuffer();        } else {            LOG.debug("Processed queue - bytes remaining");                                    queuedBuffer.discardReadComponents();        }    } else {        LOG.debug("queue empty");    }}
fe601c735d561d6d37f0f338f25a60d7e47bd80a59a5f19ce7bbed84b3c14974
releaseQueuedBuffer
private void releaseQueuedBuffer()
{    checkIsInEventLoop("releaseQueuedBuffer");    if (queuedBuffer != null) {        queuedBuffer.release();        queuedBuffer = null;    }}
968d9696af4c43a156179dda5a681f5f7f4ba377e559acfa6e3b18fa8a18b248
receiveMessage
private void receiveMessage(ByteBuf message)
{    checkIsInEventLoop("receiveMessage");    try {        while (message.isReadable() && !throttled.get()) {            if (bb != null) {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() > message.readableBytes()) {                    int newLimit = bb.position() + message.readableBytes();                    bb.limit(newLimit);                }                message.readBytes(bb);                bb.limit(bb.capacity());                if (LOG.isTraceEnabled()) {                    LOG.trace("after readBytes message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("after readbytes 0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() == 0) {                    bb.flip();                    packetReceived(4 + bb.remaining());                    ZooKeeperServer zks = this.zkServer;                    if (zks == null || !zks.isRunning()) {                        throw new IOException("ZK down");                    }                    if (initialized) {                                                                        zks.processPacket(this, bb);                    } else {                        LOG.debug("got conn req request from {}", getRemoteSocketAddress());                        zks.processConnectRequest(this, bb);                        initialized = true;                    }                    bb = null;                }            } else {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bblenrem {}", message.readableBytes(), bbLen.remaining());                    ByteBuffer dat = bbLen.duplicate();                    dat.flip();                    LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (message.readableBytes() < bbLen.remaining()) {                    bbLen.limit(bbLen.position() + message.readableBytes());                }                message.readBytes(bbLen);                bbLen.limit(bbLen.capacity());                if (bbLen.remaining() == 0) {                    bbLen.flip();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));                    }                    int len = bbLen.getInt();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen len is {}", Long.toHexString(sessionId), len);                    }                    bbLen.clear();                    if (!initialized) {                        if (checkFourLetterWord(channel, message, len)) {                            return;                        }                    }                    if (len < 0 || len > BinaryInputArchive.maxBuffer) {                        throw new IOException("Len error " + len);                    }                                        zkServer.checkRequestSizeWhenReceivingMessage(len);                    bb = ByteBuffer.allocate(len);                }            }        }    } catch (IOException e) {        LOG.warn("Closing connection to " + getRemoteSocketAddress(), e);        close(DisconnectReason.IO_EXCEPTION);    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        LOG.debug("Closing connection to " + getRemoteSocketAddress(), e);        close(DisconnectReason.CLIENT_RATE_LIMIT);    }}
06e9df67e52c5e4bff8d499a13b6f7098bf07dbbc720d59615408b51d43f2c3c
disableRecv
public void disableRecv(boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {        LOG.debug("Throttling - disabling recv {}", this);        channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);    }}
65e6660a78b099d547a0192dbab20e730e026d1b5ee5cb2102fbe0a0411baf05
enableRecv
public void enableRecv()
{    if (throttled.compareAndSet(true, false)) {        LOG.debug("Sending unthrottle event {}", this);        channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);    }}
813b571927a693f063624321689da4b9eb623d6c46cbffc62ba1cc7f26143165
setSessionTimeout
public void setSessionTimeout(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;}
86eb23327d1db1d9d92af99641864e1a6bd00027abe7be9d5631d6288afd997b
getInterestOps
public int getInterestOps()
{        if (channel == null || !channel.isOpen()) {        return 0;    }    int interestOps = 0;    if (!throttled.get()) {        interestOps |= SelectionKey.OP_READ;    }    if (!channel.isWritable()) {                        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
76a476412aec6ec4444db04281072f7ce0f60422f623a495c0cad0291582361e
getRemoteSocketAddress
public InetSocketAddress getRemoteSocketAddress()
{    return (InetSocketAddress) channel.remoteAddress();}
83bedad6a94f8012a02f99fd25948c531ae8b56f5c41205e172df54952becfda
sendCloseSession
public void sendCloseSession()
{    sendBuffer(ServerCnxnFactory.closeConn);}
907231e17b9059060ce5f7ec8aed9ef0cfaf0f263ebbdb7958c25318ca9b292f
serverStats
protected ServerStats serverStats()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
c6a8b35027b486f9efda96936274975b221803473bdc28c586ea3371f63c78bd
isSecure
public boolean isSecure()
{    return factory.secure;}
31723976639143740a59331b89e7d277a06f3d1c59275eadebaa8b8c1e08a73d
getClientCertificateChain
public Certificate[] getClientCertificateChain()
{    if (clientChain == null) {        return null;    }    return Arrays.copyOf(clientChain, clientChain.length);}
3c4125d7fc81566a8a507cd911ec199b7df322e075d329f458f8ea707600fb9d
setClientCertificateChain
public void setClientCertificateChain(Certificate[] chain)
{    if (chain == null) {        clientChain = null;    } else {        clientChain = Arrays.copyOf(chain, chain.length);    }}
f22998dac04d761b9481244e23123f11df19c6758b1f839d6c837b1bb611a516
getChannel
 Channel getChannel()
{    return channel;}
dc34c000fbab271ff640bbeae010a50411c7a744c315def6e9c6627832bc93c3
getQueuedReadableBytes
public int getQueuedReadableBytes()
{    checkIsInEventLoop("getQueuedReadableBytes");    if (queuedBuffer != null) {        return queuedBuffer.readableBytes();    }    return 0;}
a25a61635516faa14bc9ee47a8a20b93e7955b08302e0fdf6a901a897c6770f4
decode
protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> out) throws Exception
{    if (in.readableBytes() >= 5) {        super.decode(context, in, out);    } else if (in.readableBytes() > 0) {                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {            LOG.debug("first byte {} does not match TLS handshake, failing to plaintext", in.getByte(0));            handleNonSsl(context);        }    }}
040155007a042a3a9bf0c9b52a59f62d83b38c01596a45bd7dfe8ac78fd21215
handleNonSsl
private void handleNonSsl(ChannelHandlerContext context)
{    ChannelHandler handler = this.newNonSslHandler(context);    if (handler != null) {        context.pipeline().replace(this, this.newNonSslHandlerName(), handler);    } else {        context.pipeline().remove(this);    }}
9a37be09e0aa08a1e4b4386fbaff95a3a9ef7d0dc1a4a4906bfccf38e0c3b1fb
newSslHandler
protected SslHandler newSslHandler(ChannelHandlerContext context, SslContext sslContext)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());    LOG.debug("creating ssl handler for session {}", cnxn.getSessionId());    SslHandler handler = super.newSslHandler(context, sslContext);    Future<Channel> handshakeFuture = handler.handshakeFuture();    handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));    return handler;}
a20714a34472516ccec9c287cc7a27e04a58d5729062c6d8696e6f8ac68b86aa
newNonSslHandler
protected ChannelHandler newNonSslHandler(ChannelHandlerContext context)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());    LOG.debug("creating plaintext handler for session {}", cnxn.getSessionId());    allChannels.add(context.channel());    addCnxn(cnxn);    return super.newNonSslHandler(context);}
c7539c7f9d7b5d1dfacd5a43b5db29013f6bfa7008991aba4f65165f20445d6a
channelActive
public void channelActive(ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel active {}", ctx.channel());    }    final Channel channel = ctx.channel();    InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();    if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        LOG.warn("Too many connections from {} - max is {}", addr, maxClientCnxns);        channel.close();        return;    }    NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);    ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);    if (secure) {        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);        Future<Channel> handshakeFuture = sslHandler.handshakeFuture();        handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));    } else if (!shouldUsePortUnification) {        allChannels.add(ctx.channel());        addCnxn(cnxn);    }}
e3eadf870c8542dd216e415c3864eae1ce862e9b121c0701edbae3d151354ffe
channelInactive
public void channelInactive(ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel inactive {}", ctx.channel());    }    allChannels.remove(ctx.channel());    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("Channel inactive caused close {}", cnxn);        }        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);    }}
8ebb93e70cd72d973772b8e1ad55413956e7cece7a6004855f3dbf11ca3e0c97
exceptionCaught
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
{    LOG.warn("Exception caught", cause);    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {        LOG.debug("Closing {}", cnxn);        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);    }}
70aaabeb4608e2e9f9e609ca5d31f3e503d0ac291c741fcc275e5d0ed757df75
userEventTriggered
public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception
{    try {        if (evt == NettyServerCnxn.ReadEvent.ENABLE) {            LOG.debug("Received ReadEvent.ENABLE");            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();                        if (cnxn != null) {                if (cnxn.getQueuedReadableBytes() > 0) {                    cnxn.processQueuedBuffer();                    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {                                                                        ctx.read();                        LOG.debug("Issued a read after queuedBuffer drained");                    }                }            }            if (!advancedFlowControlEnabled) {                ctx.channel().config().setAutoRead(true);            }        } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {            LOG.debug("Received ReadEvent.DISABLE");            ctx.channel().config().setAutoRead(false);        }    } finally {        ReferenceCountUtil.release(evt);    }}
9485895021f85aa1e5065ba7709c83ef3c0330ec2b98f735c8a0ee67444212ac
channelRead
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
{    try {        LOG.trace("message received called {}", msg);        try {            LOG.debug("New message {} from {}", msg, ctx.channel());            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();            if (cnxn == null) {                LOG.error("channelRead() on a closed or closing NettyServerCnxn");            } else {                cnxn.processMessage((ByteBuf) msg);            }        } catch (Exception ex) {            LOG.error("Unexpected exception in receive", ex);            throw ex;        }    } finally {        ReferenceCountUtil.release(msg);    }}
a5a4c3e4adea3f9a940e6d67a0af56144275262dd35ede3c908cc89b5c45a2f1
channelReadComplete
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception
{    if (advancedFlowControlEnabled) {        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();        if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {            ctx.read();            LOG.debug("Issued a read since we do not have " + "anything to consume after channelReadComplete");        }    }    ctx.fireChannelReadComplete();}
1a79d7abef62e33a9229691f52b78766fc6f87f428ab1f5411e84627535aa067
write
public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception
{    if (LOG.isTraceEnabled()) {        promise.addListener(onWriteCompletedTracer);    }    super.write(ctx, msg, promise);}
a8fc827823753e8864e53170d85dfff2aac0d0b819d9804b877a8a678f24a39a
operationComplete
public void operationComplete(Future<Channel> future)
{    if (future.isSuccess()) {        if (LOG.isDebugEnabled()) {            LOG.debug("Successful handshake with session 0x{}", Long.toHexString(cnxn.getSessionId()));        }        SSLEngine eng = sslHandler.engine();                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {            SSLSession session = eng.getSession();            try {                cnxn.setClientCertificateChain(session.getPeerCertificates());            } catch (SSLPeerUnverifiedException e) {                if (eng.getNeedClientAuth()) {                                        LOG.error("Error getting peer certificates", e);                    cnxn.close();                    return;                } else {                                                            final Channel futureChannel = future.getNow();                    allChannels.add(Objects.requireNonNull(futureChannel));                    addCnxn(cnxn);                    return;                }            } catch (Exception e) {                LOG.error("Error getting peer certificates", e);                cnxn.close();                return;            }            String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), "x509");            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);            if (authProvider == null) {                LOG.error("X509 Auth provider not found: {}", authProviderProp);                cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);                return;            }            if (KeeperException.Code.OK != authProvider.handleAuthentication(cnxn, null)) {                LOG.error("Authentication failed for session 0x{}", Long.toHexString(cnxn.getSessionId()));                cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);                return;            }        }        final Channel futureChannel = future.getNow();        allChannels.add(Objects.requireNonNull(futureChannel));        addCnxn(cnxn);    } else {        LOG.error("Unsuccessful handshake with session 0x{}", Long.toHexString(cnxn.getSessionId()));        cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    }}
78c77b0720d7ac59866de38b4d831e717ee5d79eb1c6d1ff770523f3b4056d14
read
public void read(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete++;    }    ctx.read();}
a5a4c3e4adea3f9a940e6d67a0af56144275262dd35ede3c908cc89b5c45a2f1
channelReadComplete
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete = 0;    }    ctx.fireChannelReadComplete();}
61eecd5113345ff39b1f2fcc908b332a10dce8dc2b39aa843ce5c20b8cfdf0aa
configureBootstrapAllocator
private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator).childOption(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
bf534bb6a81e7653e772b45c660728e2ed8223b7f5c2fff9135bce2f0188c348
initChannel
protected void initChannel(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (advancedFlowControlEnabled) {        pipeline.addLast(readIssuedTrackingHandler);    }    if (secure) {        initSSL(pipeline, false);    } else if (shouldUsePortUnification) {        initSSL(pipeline, true);    }    pipeline.addLast("servercnxnfactory", channelHandler);}
a341c927fef4d3017f7662fadfe449172063459e472d059225b74cc73b7769e0
initSSL
private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException
{    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());    SslContext nettySslContext;    if (authProviderProp == null) {        SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();        nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);    } else {        SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), "x509"));        if (authProvider == null) {            LOG.error("Auth provider not found: {}", authProviderProp);            throw new SSLContextException("Could not create SSLContext with specified auth provider: " + authProviderProp);        }        sslContext.init(new X509KeyManager[] { authProvider.getKeyManager() }, new X509TrustManager[] { authProvider.getTrustManager() }, null);        nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);    }    if (supportPlaintext) {        p.addLast("ssl", new DualModeSslHandler(nettySslContext));        LOG.debug("dual mode SSL handler added for channel: {}", p.channel());    } else {        p.addLast("ssl", nettySslContext.newHandler(p.channel().alloc()));        LOG.debug("SSL handler added for channel: {}", p.channel());    }}
9618e3575be04e74d82d1804fa8dc911f0a105f5bb4a5a1eb9ce97317fd27e96
closeAll
public void closeAll(ServerCnxn.DisconnectReason reason)
{    LOG.debug("closeAll()");        int length = cnxns.size();    for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {            LOG.warn("Ignoring exception closing cnxn sessionid 0x" + Long.toHexString(cnxn.getSessionId()), e);        }    }    LOG.debug("allChannels size: {} cnxns size: {}", allChannels.size(), length);}
c28a64febd7fb5a60f4c8ac1caacb2e44eef8fed3d15a256f3ab55077f2cfbee
configure
public void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException
{    configureSaslLogin();    localAddress = addr;    this.maxClientCnxns = maxClientCnxns;    this.secure = secure;    this.listenBacklog = backlog;}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxns;}
78da50d2f121d55b38d4ba46ed3b47334752ed03e7f4016471440b07a443e60b
setMaxClientCnxnsPerHost
public void setMaxClientCnxnsPerHost(int max)
{    maxClientCnxns = max;}
8f86d51876296c7eed1e83dbd0f52004e0f019bff357df5cd0c681d950856f3c
getSocketListenBacklog
public int getSocketListenBacklog()
{    return listenBacklog;}
0f9342907a55818619d2e2cfa5fa813892dc2783be692f8ecc0da9029bc998d0
getLocalPort
public int getLocalPort()
{    return localAddress.getPort();}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{    synchronized (this) {        while (!killed) {            wait();        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    synchronized (this) {        if (killed) {            LOG.info("already shutdown {}", localAddress);            return;        }    }    LOG.info("shutdown called {}", localAddress);    x509Util.close();    if (login != null) {        login.shutdown();    }    final EventLoopGroup bossGroup = bootstrap.config().group();    final EventLoopGroup workerGroup = bootstrap.config().childGroup();        if (parentChannel != null) {        ChannelFuture parentCloseFuture = parentChannel.close();        if (bossGroup != null) {            parentCloseFuture.addListener(future -> {                bossGroup.shutdownGracefully();            });        }        closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        ChannelGroupFuture allChannelsCloseFuture = allChannels.close();        if (workerGroup != null) {            allChannelsCloseFuture.addListener(future -> {                workerGroup.shutdownGracefully();            });        }    } else {        if (bossGroup != null) {            bossGroup.shutdownGracefully();        }        if (workerGroup != null) {            workerGroup.shutdownGracefully();        }    }    if (zkServer != null) {        zkServer.shutdown();    }    synchronized (this) {        killed = true;        notifyAll();    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (listenBacklog != -1) {        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);    }    LOG.info("binding to port {}", localAddress);    parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();            localAddress = (InetSocketAddress) parentChannel.localAddress();    LOG.info("bound to port {}", getLocalPort());}
7b331c2708882f50d8f4b87c307968343a5187ab2acae4292c7fa54232b64442
reconfigure
public void reconfigure(InetSocketAddress addr)
{    LOG.info("binding to port {}, {}", addr, localAddress);    if (addr != null && localAddress != null) {        if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {            LOG.info("address is the same, skip rebinding");            return;        }    }    Channel oldChannel = parentChannel;    try {        parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();                        localAddress = (InetSocketAddress) parentChannel.localAddress();        LOG.info("bound to port {}", getLocalPort());    } catch (Exception e) {        LOG.error("Error while reconfiguring", e);    } finally {        oldChannel.close();    }}
8edd3f8570c686a1053f47f1efabcd6d5f26707cd268c26c9afe120a5ce6afd6
startup
public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
6de8cf9ab3f727cc2ed14c5955c80e7d8b809af8d0c2ac4fb0074e3d877e2074
getConnections
public Iterable<ServerCnxn> getConnections()
{    return cnxns;}
932c7deb6f166bae646eeeb2a602d70f876a6d84fb955006b41c6e45c5b97bab
getLocalAddress
public InetSocketAddress getLocalAddress()
{    return localAddress;}
4e88298cd458be5c6acbfb734dc6805103726dde0443b50a864cecc88b56b391
addCnxn
private void addCnxn(final NettyServerCnxn cnxn)
{    cnxns.add(cnxn);    InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();    ipMap.compute(addr, (a, cnxnCount) -> {        if (cnxnCount == null) {            cnxnCount = new AtomicInteger();        }        cnxnCount.incrementAndGet();        return cnxnCount;    });}
ba08685c12699087f67568bee31ed8cbe556b691b07659353a21dc4bb1177d73
removeCnxnFromIpMap
 void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress)
{    ipMap.compute(remoteAddress, (addr, cnxnCount) -> {        if (cnxnCount == null) {            LOG.error("Unexpected remote address {} when removing cnxn {}", remoteAddress, cnxn);            return null;        }        final int newValue = cnxnCount.decrementAndGet();        return newValue == 0 ? null : cnxnCount;    });}
d4b39987cf57f43dd24ac9ecc541ebf8470011a57244c1c43f7a566446589fdc
getClientCnxnCount
private int getClientCnxnCount(final InetAddress addr)
{    final AtomicInteger count = ipMap.get(addr);    return count == null ? 0 : count.get();}
615cf9dcbd18f11125b7fd2bc66c45596616007a5dbab858acd99aa19935522f
resetAllConnectionStats
public void resetAllConnectionStats()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
3c74c863c15ec83c7164e0cfae9f6a1820b2694bcac1e903f279dea9d9e9bdfd
getAllConnectionInfo
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    Set<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
0d9c0f399c900b7236b52940d5b335b825ff87ece1ae8202a1181a0b5e35f181
setTestAllocator
 static void setTestAllocator(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
5c396ec4a4c0e018e2e1defd5f584ce3159d17fea2b63dea6b82a57c597daa54
clearTestAllocator
 static void clearTestAllocator()
{    TEST_ALLOCATOR.set(null);}
ea3e20404afaf0dbb4758a86c9e06ddb68f920f6d25df5f95a66a12be32b88cf
setAdvancedFlowControlEnabled
public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled)
{    this.advancedFlowControlEnabled = advancedFlowControlEnabled;}
46de2bc850f6a2c6c43ba4b717020d5c84cd2a17f8d2785045556e61aaac20b9
setSecure
public void setSecure(boolean secure)
{    this.secure = secure;}
a9550651d6a56491283c9e491d02fc53b05cca36b2b68c0dd0d59be780b6b952
getParentChannel
public Channel getParentChannel()
{    return parentChannel;}
83bedad6a94f8012a02f99fd25948c531ae8b56f5c41205e172df54952becfda
sendCloseSession
public void sendCloseSession()
{    sendBuffer(ServerCnxnFactory.closeConn);}
4f37973bf59376530f5c8858e4d789d2168fa8510c241c77f38e0a7c7cb145aa
sendBufferSync
 void sendBufferSync(ByteBuffer bb)
{    try {        /* configure socket to be blocking             * so that we dont have to do write in             * a tight while loop             */        if (bb != ServerCnxnFactory.closeConn) {            if (sock.isOpen()) {                sock.configureBlocking(true);                sock.write(bb);            }            packetSent();        }    } catch (IOException ie) {        LOG.error("Error sending data synchronously ", ie);    }}
737d8d6a95398a29600cb0306e2eaefc81f34cbe5def1f6f18fa3b9e0b6d7cbb
sendBuffer
public void sendBuffer(ByteBuffer... buffers)
{    LOG.trace("Add a buffer to outgoingBuffers, sk {} is valid: {}", sk, sk.isValid());    synchronized (outgoingBuffers) {        for (ByteBuffer buffer : buffers) {            outgoingBuffers.add(buffer);        }        outgoingBuffers.add(packetSentinel);    }    requestInterestOpsUpdate();}
c37192d7ebbd8d5587709d4c47e8517b3620b0009ce061337faa875f1a7131ac
handleFailedRead
private void handleFailedRead() throws EndOfStreamException
{    setStale();    ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);    throw new EndOfStreamException("Unable to read additional data from client," + " it probably closed the socket:" + " address = " + sock.socket().getRemoteSocketAddress() + "," + " session = 0x" + Long.toHexString(sessionId), DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);}
f63d4426e3b7ab0c64b7fe4b6ee6b305bf269ee1ec92eea371e4e631138b398d
readPayload
private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (incomingBuffer.remaining() != 0) {                        int rc = sock.read(incomingBuffer);        if (rc < 0) {            handleFailedRead();        }    }    if (incomingBuffer.remaining() == 0) {                incomingBuffer.flip();        packetReceived(4 + incomingBuffer.remaining());        if (!initialized) {            readConnectRequest();        } else {            readRequest();        }        lenBuffer.clear();        incomingBuffer = lenBuffer;    }}
72fc5bb3aecc63ea4cb48a7c70dfbdd0f6c5ce742a980a6ed009887a086e9017
isSelectable
public boolean isSelectable()
{    return sk.isValid() && selectable.get();}
ebf2260572e96b1122faefce869818330b395b3c74b0b7ee5d4cf2ae672ae24e
disableSelectable
public void disableSelectable()
{    selectable.set(false);}
0e88b4d8378da4c0075e39d26ffd84952534e052f97f6587fa14dc8257074770
enableSelectable
public void enableSelectable()
{    selectable.set(true);}
6d3f0327d3634ec2761d11c3d2b048731f551a79844cccab4ae5174a6e839782
requestInterestOpsUpdate
private void requestInterestOpsUpdate()
{    if (isSelectable()) {        selectorThread.addInterestOpsUpdateRequest(sk);    }}
7eab82c815ef2434895dc8709ec0b783d5cd1093e08644f029a00128c46e9c9e
handleWrite
 void handleWrite(SelectionKey k) throws IOException
{    if (outgoingBuffers.isEmpty()) {        return;    }    /*         * This is going to reset the buffer position to 0 and the         * limit to the size of the buffer, so that we can fill it         * with data from the non-direct buffers that we need to         * send.         */    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();    if (directBuffer == null) {        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];                        sock.write(outgoingBuffers.toArray(bufferList));                ByteBuffer bb;        while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (bb.remaining() > 0) {                break;            }            outgoingBuffers.remove();        }    } else {        directBuffer.clear();        for (ByteBuffer b : outgoingBuffers) {            if (directBuffer.remaining() < b.remaining()) {                /*                     * When we call put later, if the directBuffer is to                     * small to hold everything, nothing will be copied,                     * so we've got to slice the buffer if it's too big.                     */                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());            }            /*                 * put() is going to modify the positions of both                 * buffers, put we don't want to change the position of                 * the source buffers (we'll do that after the send, if                 * needed), so we save and reset the position after the                 * copy                 */            int p = b.position();            directBuffer.put(b);            b.position(p);            if (directBuffer.remaining() == 0) {                break;            }        }        /*             * Do the flip: limit becomes position, position gets set to             * 0. This sets us up for the write.             */        directBuffer.flip();        int sent = sock.write(directBuffer);        ByteBuffer bb;                while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (sent < bb.remaining()) {                /*                     * We only partially sent this buffer, so we update                     * the position and exit the loop.                     */                bb.position(bb.position() + sent);                break;            }            /* We've sent the whole buffer, so drop the buffer */            sent -= bb.remaining();            outgoingBuffers.remove();        }    }}
d54692b66f45bd8a566793607b11103ecff3235302b7408ccb21f4d2a90da732
isSocketOpen
protected boolean isSocketOpen()
{    return sock.isOpen();}
c351974d314ef23e8e0a96ffdf7c8180b276a032c344b0b49b4d0f3991d320e7
doIO
 void doIO(SelectionKey k) throws InterruptedException
{    try {        if (!isSocketOpen()) {            LOG.warn("trying to do i/o on a null socket for session:0x" + Long.toHexString(sessionId));            return;        }        if (k.isReadable()) {            int rc = sock.read(incomingBuffer);            if (rc < 0) {                handleFailedRead();            }            if (incomingBuffer.remaining() == 0) {                boolean isPayload;                if (incomingBuffer == lenBuffer) {                                        incomingBuffer.flip();                    isPayload = readLength(k);                    incomingBuffer.clear();                } else {                                        isPayload = true;                }                if (isPayload) {                                        readPayload();                } else {                                        return;                }            }        }        if (k.isWritable()) {            handleWrite(k);            if (!initialized && !getReadInterest() && !getWriteInterest()) {                throw new CloseRequestException("responded to info probe", DisconnectReason.INFO_PROBE);            }        }    } catch (CancelledKeyException e) {        LOG.warn("CancelledKeyException causing close of session 0x" + Long.toHexString(sessionId));        LOG.debug("CancelledKeyException stack trace", e);        close(DisconnectReason.CANCELLED_KEY_EXCEPTION);    } catch (CloseRequestException e) {                close();    } catch (EndOfStreamException e) {        LOG.warn(e.getMessage());                close(e.getReason());    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        if (LOG.isDebugEnabled()) {            LOG.debug("Exception causing close of session 0x" + Long.toHexString(sessionId) + ": " + e.getMessage());        }        close(DisconnectReason.CLIENT_CNX_LIMIT);    } catch (IOException e) {        LOG.warn("Exception causing close of session 0x" + Long.toHexString(sessionId) + ": " + e.getMessage());        LOG.debug("IOException stack trace", e);        close(DisconnectReason.IO_EXCEPTION);    }}
960b99cebc43380fbddfd281cce1b5e29b6cffa2e72b78d71a860f6c1244d361
readRequest
private void readRequest() throws IOException
{    zkServer.processPacket(this, incomingBuffer);}
202b1483b9e74a5f72a0323e5c1de3a8def0f4aa944fbe1eb8c76b8cfe70f96b
getWriteInterest
private boolean getWriteInterest()
{    return !outgoingBuffers.isEmpty();}
6149a9eb41e9810bade8ab35bb20224de23b7f6f62030af5419e64753ebac3aa
getReadInterest
private boolean getReadInterest()
{    return !throttled.get();}
06e9df67e52c5e4bff8d499a13b6f7098bf07dbbc720d59615408b51d43f2c3c
disableRecv
public void disableRecv(boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {        requestInterestOpsUpdate();    }}
65e6660a78b099d547a0192dbab20e730e026d1b5ee5cb2102fbe0a0411baf05
enableRecv
public void enableRecv()
{    if (throttled.compareAndSet(true, false)) {        requestInterestOpsUpdate();    }}
138c1d0c27928f59e1aa08d3903fd871810fc36aee6ed222ce9ef16c6e7f60ec
readConnectRequest
private void readConnectRequest() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }    zkServer.processConnectRequest(this, incomingBuffer);    initialized = true;}
e98bcfdb1a2687a780af10c2b225f931708556d106c9fe099b4b5616815cbd7f
checkFlush
private void checkFlush(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    checkFlush(true);}
e1a8f4065443590888d0a504354993fe93e0bf5b76f29d77ce33949e79fe5e10
write
public void write(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
d0e354f4eca2bdafa9c06241c13961c9fb92a2aefaedf14173ed477f9498cd6d
checkFourLetterWord
private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);    packetReceived(4);    /**     * cancel the selection key to remove the socket handling     * from selector. This is to prevent netcat problem wherein     * netcat immediately closes the sending side after sending the     * commands and still keeps the receiving channel open.     * The idea is to remove the selectionkey from the selector     * so that the selector does not notice the closed read on the     * socket channel and keep the socket alive to write the data to     * and makes sure to close the socket after its done writing the data     */    if (k != null) {        try {            k.cancel();        } catch (Exception e) {            LOG.error("Error cancelling command selection key ", e);        }    }    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {        LOG.debug("Command {} is not executed because it is not in the whitelist.", cmd);        NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }    LOG.info("Processing " + cmd + " command from " + sock.socket().getRemoteSocketAddress());    if (len == FourLetterCommands.setTraceMaskCmd) {        incomingBuffer = ByteBuffer.allocate(8);        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new IOException("Read error");        }        incomingBuffer.flip();        long traceMask = incomingBuffer.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
3f41b9533b38221d68ab8890703b797c228062bd0affffa34df2c25a169e1ed0
readLength
private boolean readLength(SelectionKey k) throws IOException
{        int len = lenBuffer.getInt();    if (!initialized && checkFourLetterWord(sk, len)) {        return false;    }    if (len < 0 || len > BinaryInputArchive.maxBuffer) {        throw new IOException("Len error " + len);    }    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }        zkServer.checkRequestSizeWhenReceivingMessage(len);    incomingBuffer = ByteBuffer.allocate(len);    return true;}
452a4ff94777c76df44bc5eadffc0d712b51a73c6321728e940feb32f49377ee
isZKServerRunning
 boolean isZKServerRunning()
{    return zkServer != null && zkServer.isRunning();}
2436723c695636833e0ebfc52d684cb9ae4da078ffa3153b560d8213802ad011
getSessionTimeout
public int getSessionTimeout()
{    return sessionTimeout;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ip: " + sock.socket().getRemoteSocketAddress() + " sessionId: 0x" + Long.toHexString(sessionId);}
1c9432fa2ab8f03d0e6084f264bde3395a658c6eae5d9f77ab6731b061727623
close
public void close(DisconnectReason reason)
{    disconnectReason = reason;    close();}
48d47d73a0edad28ffa0e449b7a84e717b5def7f34f981b6be6dbdaaf780fe61
close
private void close()
{    setStale();    if (!factory.removeCnxn(this)) {        return;    }    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (sk != null) {        try {                        sk.cancel();        } catch (Exception e) {            LOG.debug("ignoring exception during selectionkey cancel", e);        }    }    closeSock();}
6330b4f42214c0f39b2d3483598ef46efe940852630b7dd7804579f12dc58a36
closeSock
private void closeSock()
{    if (!sock.isOpen()) {        return;    }    if (LOG.isDebugEnabled()) {        LOG.debug("Closed socket connection for client " + sock.socket().getRemoteSocketAddress() + (sessionId != 0 ? " which had sessionid 0x" + Long.toHexString(sessionId) : " (no session established for client)"));    }    closeSock(sock);}
04fc5318bff86fafa4c32a69ddabbb7b097cda66734aa7e82fc70d1caaca9724
closeSock
public static void closeSock(SocketChannel sock)
{    if (!sock.isOpen()) {        return;    }    try {        /*             * The following sequence of code is stupid! You would think that             * only sock.close() is needed, but alas, it doesn't work that way.             * If you just do sock.close() there are cases where the socket             * doesn't actually close...             */        sock.socket().shutdownOutput();    } catch (IOException e) {                LOG.debug("ignoring exception during output shutdown", e);    }    try {        sock.socket().shutdownInput();    } catch (IOException e) {                LOG.debug("ignoring exception during input shutdown", e);    }    try {        sock.socket().close();    } catch (IOException e) {        LOG.debug("ignoring exception during socket close", e);    }    try {        sock.close();    } catch (IOException e) {        LOG.debug("ignoring exception during socketchannel close", e);    }}
c81016d4ba1d0ac28bed24a197405a73699fcb607f316a0ad8c8f73f330cc6b5
sendResponse
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat)
{    try {        sendBuffer(serialize(h, r, tag, cacheKey, stat));        decrOutstandingAndCheckThrottle(h);    } catch (Exception e) {        LOG.warn("Unexpected exception. Destruction averted.", e);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    sendResponse(h, e, "notification", null, null);}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return sessionId;}
91f18d9c3e10f1b7f5263074e38c28fa48018551fc4c88831c38d8803b1d8c51
setSessionId
public void setSessionId(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
813b571927a693f063624321689da4b9eb623d6c46cbffc62ba1cc7f26143165
setSessionTimeout
public void setSessionTimeout(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;    factory.touchCnxn(this);}
86eb23327d1db1d9d92af99641864e1a6bd00027abe7be9d5631d6288afd997b
getInterestOps
public int getInterestOps()
{    if (!isSelectable()) {        return 0;    }    int interestOps = 0;    if (getReadInterest()) {        interestOps |= SelectionKey.OP_READ;    }    if (getWriteInterest()) {        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
76a476412aec6ec4444db04281072f7ce0f60422f623a495c0cad0291582361e
getRemoteSocketAddress
public InetSocketAddress getRemoteSocketAddress()
{    if (!sock.isOpen()) {        return null;    }    return (InetSocketAddress) sock.socket().getRemoteSocketAddress();}
fcf6329f9cdae059d79d78bc9930736e7c1dfd188b4443587e19f169c06fc02a
getSocketAddress
public InetAddress getSocketAddress()
{    if (!sock.isOpen()) {        return null;    }    return sock.socket().getInetAddress();}
907231e17b9059060ce5f7ec8aed9ef0cfaf0f263ebbdb7958c25318ca9b292f
serverStats
protected ServerStats serverStats()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
c6a8b35027b486f9efda96936274975b221803473bdc28c586ea3371f63c78bd
isSecure
public boolean isSecure()
{    return false;}
31723976639143740a59331b89e7d277a06f3d1c59275eadebaa8b8c1e08a73d
getClientCertificateChain
public Certificate[] getClientCertificateChain()
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
3c4125d7fc81566a8a507cd911ec199b7df322e075d329f458f8ea707600fb9d
setClientCertificateChain
public void setClientCertificateChain(Certificate[] chain)
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
f9e4832777f7af0982d696c7b64bd6626ebb43207fc112505ab6b4630a9e3d35
uncaughtException
public void uncaughtException(Thread t, Throwable e)
{    LOG.error("Thread " + t + " died", e);}
737eeec80ca925675080c9a5e7c17b115eef8925e2ce74527aa1c95e117e986d
wakeupSelector
public void wakeupSelector()
{    selector.wakeup();}
b4ca6141c0dd770cbd2c866589a203bd919186e97b4bcad78b06d46320c046e1
closeSelector
protected void closeSelector()
{    try {        selector.close();    } catch (IOException e) {        LOG.warn("ignored exception during selector close " + e.getMessage());    }}
39689d2a60b97d6ff71dba8825c81d6c5c46154d4f7da386122c258de09a45f2
cleanupSelectionKey
protected void cleanupSelectionKey(SelectionKey key)
{    if (key != null) {        try {            key.cancel();        } catch (Exception ex) {            LOG.debug("ignoring exception during selectionkey cancel", ex);        }    }}
bab6f4e5d6244fc285e2380c17a5cd70683dd6470bb3c24203aa7eee277205fc
fastCloseSock
protected void fastCloseSock(SocketChannel sc)
{    if (sc != null) {        try {                        sc.socket().setSoLinger(true, 0);        } catch (SocketException e) {            LOG.warn("Unable to set socket linger to 0, socket close" + " may stall in CLOSE_WAIT", e);        }        NIOServerCnxn.closeSock(sc);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!stopped && !acceptSocket.socket().isClosed()) {            try {                select();            } catch (RuntimeException e) {                LOG.warn("Ignoring unexpected runtime exception", e);            } catch (Exception e) {                LOG.warn("Ignoring unexpected exception", e);            }        }    } finally {        closeSelector();                if (!reconfiguring) {            NIOServerCnxnFactory.this.stop();        }        LOG.info("accept thread exitted run method");    }}
5bab1b87c692c96ed417e9657ea9ba170ff97eb6e2718eae4c2ef660b9a00c3a
setReconfiguring
public void setReconfiguring()
{    reconfiguring = true;}
af223b13612091e53bf8af772d8e0cc8d3ff61526c0183878ed157e48370e953
select
private void select()
{    try {        selector.select();        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selectedKeys.remove();            if (!key.isValid()) {                continue;            }            if (key.isAcceptable()) {                if (!doAccept()) {                                                                                                    pauseAccept(10);                }            } else {                LOG.warn("Unexpected ops in accept select " + key.readyOps());            }        }    } catch (IOException e) {        LOG.warn("Ignoring IOException while selecting", e);    }}
3e1c6a745fea73f890948093b9c2f3465b52077a25379b939e6f9940c07ce2a1
pauseAccept
private void pauseAccept(long millisecs)
{    acceptKey.interestOps(0);    try {        selector.select(millisecs);    } catch (IOException e) {        } finally {        acceptKey.interestOps(SelectionKey.OP_ACCEPT);    }}
565e2d620dc24098a4473686286c23dc14f61f4d07d2d1fb7a6ba87d2398c195
doAccept
private boolean doAccept()
{    boolean accepted = false;    SocketChannel sc = null;    try {        sc = acceptSocket.accept();        accepted = true;        InetAddress ia = sc.socket().getInetAddress();        int cnxncount = getClientCnxnCount(ia);        if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {            throw new IOException("Too many connections from " + ia + " - max is " + maxClientCnxns);        }        LOG.debug("Accepted socket connection from {}", sc.socket().getRemoteSocketAddress());        sc.configureBlocking(false);                if (!selectorIterator.hasNext()) {            selectorIterator = selectorThreads.iterator();        }        SelectorThread selectorThread = selectorIterator.next();        if (!selectorThread.addAcceptedConnection(sc)) {            throw new IOException("Unable to add connection to selector queue" + (stopped ? " (shutdown in progress)" : ""));        }        acceptErrorLogger.flush();    } catch (IOException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        acceptErrorLogger.rateLimitLog("Error accepting new connection: " + e.getMessage());        fastCloseSock(sc);    }    return accepted;}
961c487dc2249b25caa24e13584bcdb917c1e9ff277744c78111d44184024691
addAcceptedConnection
public boolean addAcceptedConnection(SocketChannel accepted)
{    if (stopped || !acceptedQueue.offer(accepted)) {        return false;    }    wakeupSelector();    return true;}
8ec66b82ff962ee9497f62aae0398c741b98c72c6606bab56e0066c3f1653f4f
addInterestOpsUpdateRequest
public boolean addInterestOpsUpdateRequest(SelectionKey sk)
{    if (stopped || !updateQueue.offer(sk)) {        return false;    }    wakeupSelector();    return true;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!stopped) {            try {                select();                processAcceptedConnections();                processInterestOpsUpdateRequests();            } catch (RuntimeException e) {                LOG.warn("Ignoring unexpected runtime exception", e);            } catch (Exception e) {                LOG.warn("Ignoring unexpected exception", e);            }        }                for (SelectionKey key : selector.keys()) {            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            if (cnxn.isSelectable()) {                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            }            cleanupSelectionKey(key);        }        SocketChannel accepted;        while ((accepted = acceptedQueue.poll()) != null) {            fastCloseSock(accepted);        }        updateQueue.clear();    } finally {        closeSelector();                        NIOServerCnxnFactory.this.stop();        LOG.info("selector thread exitted run method");    }}
af223b13612091e53bf8af772d8e0cc8d3ff61526c0183878ed157e48370e953
select
private void select()
{    try {        selector.select();        Set<SelectionKey> selected = selector.selectedKeys();        ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(selected);        Collections.shuffle(selectedList);        Iterator<SelectionKey> selectedKeys = selectedList.iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selected.remove(key);            if (!key.isValid()) {                cleanupSelectionKey(key);                continue;            }            if (key.isReadable() || key.isWritable()) {                handleIO(key);            } else {                LOG.warn("Unexpected ops in select " + key.readyOps());            }        }    } catch (IOException e) {        LOG.warn("Ignoring IOException while selecting", e);    }}
9e57221f003614ec1d0a97e7fcea15e34e4991dfc64c45e80260b99eddb5028c
handleIO
private void handleIO(SelectionKey key)
{    IOWorkRequest workRequest = new IOWorkRequest(this, key);    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            cnxn.disableSelectable();    key.interestOps(0);    touchCnxn(cnxn);    workerPool.schedule(workRequest);}
a4dfdc4d15e25367f40aa2897d88ff682a6f587d944a9b76949e3fec7bc1bd6b
processAcceptedConnections
private void processAcceptedConnections()
{    SocketChannel accepted;    while (!stopped && (accepted = acceptedQueue.poll()) != null) {        SelectionKey key = null;        try {            key = accepted.register(selector, SelectionKey.OP_READ);            NIOServerCnxn cnxn = createConnection(accepted, key, this);            key.attach(cnxn);            addCnxn(cnxn);        } catch (IOException e) {                        cleanupSelectionKey(key);            fastCloseSock(accepted);        }    }}
706d277cb7f91b13ed83bd9ca64ad299a6f177212fda157b27b1733a32040ec9
processInterestOpsUpdateRequests
private void processInterestOpsUpdateRequests()
{    SelectionKey key;    while (!stopped && (key = updateQueue.poll()) != null) {        if (!key.isValid()) {            cleanupSelectionKey(key);        }        NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();        if (cnxn.isSelectable()) {            key.interestOps(cnxn.getInterestOps());        }    }}
b436d60608eb78468dc9f4b29d5fde285db34990bed1a92a2c531d6e1ecfb670
doWork
public void doWork() throws InterruptedException
{    if (!key.isValid()) {        selectorThread.cleanupSelectionKey(key);        return;    }    if (key.isReadable() || key.isWritable()) {        cnxn.doIO(key);                if (stopped) {            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            return;        }        if (!key.isValid()) {            selectorThread.cleanupSelectionKey(key);            return;        }        touchCnxn(cnxn);    }        cnxn.enableSelectable();        if (!selectorThread.addInterestOpsUpdateRequest(key)) {        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);    }}
a317f472727975f13a20ef21472e1d5e0a0fd93702ee696b9c962178a725931f
cleanup
public void cleanup()
{    cnxn.close(ServerCnxn.DisconnectReason.CLEAN_UP);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!stopped) {            long waitTime = cnxnExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);            }        }    } catch (InterruptedException e) {        LOG.info("ConnnectionExpirerThread interrupted");    }}
4fce386cf0175b0ebec4023130dc8d926627290309b5d20a1156a885248a03cc
initialValue
protected ByteBuffer initialValue()
{    return ByteBuffer.allocateDirect(directBufferBytes);}
715a8ef70cd764950d9ae8805e7bae9d81a2c3bce2db6cd2a4f2a8fa3b697396
getDirectBuffer
public static ByteBuffer getDirectBuffer()
{    return directBufferBytes > 0 ? directBuffer.get() : null;}
9798a6b76995d70e00140cc3d8eec6f21c3aff22bfed6aa9370d520717b4107a
configure
public void configure(InetSocketAddress addr, int maxcc, int backlog, boolean secure) throws IOException
{    if (secure) {        throw new UnsupportedOperationException("SSL isn't supported in NIOServerCnxn");    }    configureSaslLogin();    maxClientCnxns = maxcc;    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);                    cnxnExpiryQueue = new ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);    expirerThread = new ConnectionExpirerThread();    int numCores = Runtime.getRuntime().availableProcessors();        numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));    if (numSelectorThreads < 1) {        throw new IOException("numSelectorThreads must be at least 1");    }    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);    LOG.info("Configuring NIO connection handler with " + (sessionlessCnxnTimeout / 1000) + "s sessionless connection timeout, " + numSelectorThreads + " selector thread(s), " + (numWorkerThreads > 0 ? numWorkerThreads : "no") + " worker threads, and " + (directBufferBytes == 0 ? "gathered writes." : ("" + (directBufferBytes / 1024) + " kB direct buffers.")));    for (int i = 0; i < numSelectorThreads; ++i) {        selectorThreads.add(new SelectorThread(i));    }    listenBacklog = backlog;    this.ss = ServerSocketChannel.open();    ss.socket().setReuseAddress(true);    LOG.info("binding to port " + addr);    if (listenBacklog == -1) {        ss.socket().bind(addr);    } else {        ss.socket().bind(addr, listenBacklog);    }    ss.configureBlocking(false);    acceptThread = new AcceptThread(ss, addr, selectorThreads);}
3f2c11be30ad88ddf6558c6926dbe7c07466bb561e2529dd358ba9c02014f1ca
tryClose
private void tryClose(ServerSocketChannel s)
{    try {        s.close();    } catch (IOException sse) {        LOG.error("Error while closing server socket.", sse);    }}
7b331c2708882f50d8f4b87c307968343a5187ab2acae4292c7fa54232b64442
reconfigure
public void reconfigure(InetSocketAddress addr)
{    ServerSocketChannel oldSS = ss;    try {        acceptThread.setReconfiguring();        tryClose(oldSS);        acceptThread.wakeupSelector();        try {            acceptThread.join();        } catch (InterruptedException e) {            LOG.error("Error joining old acceptThread when reconfiguring client port {}", e.getMessage());            Thread.currentThread().interrupt();        }        this.ss = ServerSocketChannel.open();        ss.socket().setReuseAddress(true);        LOG.info("binding to port " + addr);        ss.socket().bind(addr);        ss.configureBlocking(false);        acceptThread = new AcceptThread(ss, addr, selectorThreads);        acceptThread.start();    } catch (IOException e) {        LOG.error("Error reconfiguring client port to {} {}", addr, e.getMessage());        tryClose(oldSS);    }}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxns;}
78da50d2f121d55b38d4ba46ed3b47334752ed03e7f4016471440b07a443e60b
setMaxClientCnxnsPerHost
public void setMaxClientCnxnsPerHost(int max)
{    maxClientCnxns = max;}
8f86d51876296c7eed1e83dbd0f52004e0f019bff357df5cd0c681d950856f3c
getSocketListenBacklog
public int getSocketListenBacklog()
{    return listenBacklog;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    stopped = false;    if (workerPool == null) {        workerPool = new WorkerService("NIOWorker", numWorkerThreads, false);    }    for (SelectorThread thread : selectorThreads) {        if (thread.getState() == Thread.State.NEW) {            thread.start();        }    }        if (acceptThread.getState() == Thread.State.NEW) {        acceptThread.start();    }    if (expirerThread.getState() == Thread.State.NEW) {        expirerThread.start();    }}
8edd3f8570c686a1053f47f1efabcd6d5f26707cd268c26c9afe120a5ce6afd6
startup
public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
932c7deb6f166bae646eeeb2a602d70f876a6d84fb955006b41c6e45c5b97bab
getLocalAddress
public InetSocketAddress getLocalAddress()
{    return (InetSocketAddress) ss.socket().getLocalSocketAddress();}
0f9342907a55818619d2e2cfa5fa813892dc2783be692f8ecc0da9029bc998d0
getLocalPort
public int getLocalPort()
{    return ss.socket().getLocalPort();}
9c68ddc50f84aa769bad459ea131f2dc7466e798437839021dc3ee6e12c6d378
removeCnxn
public boolean removeCnxn(NIOServerCnxn cnxn)
{        if (!cnxns.remove(cnxn)) {        return false;    }    cnxnExpiryQueue.remove(cnxn);    removeCnxnFromSessionMap(cnxn);    InetAddress addr = cnxn.getSocketAddress();    if (addr != null) {        Set<NIOServerCnxn> set = ipMap.get(addr);        if (set != null) {            set.remove(cnxn);                        }    }        unregisterConnection(cnxn);    return true;}
073c4e8ef55ec4fcd99edb7ba66de181302bcb842266607c31fd40abdeef5086
touchCnxn
public void touchCnxn(NIOServerCnxn cnxn)
{    cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());}
00fac5e1b3e55c83b30a1645276e9f0963b81d927cab737d6d34fd30826dee01
addCnxn
private void addCnxn(NIOServerCnxn cnxn) throws IOException
{    InetAddress addr = cnxn.getSocketAddress();    if (addr == null) {        throw new IOException("Socket of " + cnxn + " has been closed");    }    Set<NIOServerCnxn> set = ipMap.get(addr);    if (set == null) {                                                        set = Collections.newSetFromMap(new ConcurrentHashMap<NIOServerCnxn, Boolean>(2));                        Set<NIOServerCnxn> existingSet = ipMap.putIfAbsent(addr, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(cnxn);    cnxns.add(cnxn);    touchCnxn(cnxn);}
56436ede5be71477eedd32f40b77d78b27ef379faa19d7f4a7e90dc6504f9e7c
createConnection
protected NIOServerCnxn createConnection(SocketChannel sock, SelectionKey sk, SelectorThread selectorThread) throws IOException
{    return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);}
00a22d66638b9d6e784eb98b4bab4fc7038bff59cf2084785215145a2572d355
getClientCnxnCount
private int getClientCnxnCount(InetAddress cl)
{    Set<NIOServerCnxn> s = ipMap.get(cl);    if (s == null) {        return 0;    }    return s.size();}
9618e3575be04e74d82d1804fa8dc911f0a105f5bb4a5a1eb9ce97317fd27e96
closeAll
public void closeAll(ServerCnxn.DisconnectReason reason)
{        for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {            LOG.warn("Ignoring exception closing cnxn sessionid 0x" + Long.toHexString(cnxn.getSessionId()), e);        }    }}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    stopped = true;        try {        ss.close();    } catch (IOException e) {        LOG.warn("Error closing listen socket", e);    }    if (acceptThread != null) {        if (acceptThread.isAlive()) {            acceptThread.wakeupSelector();        } else {            acceptThread.closeSelector();        }    }    if (expirerThread != null) {        expirerThread.interrupt();    }    for (SelectorThread thread : selectorThreads) {        if (thread.isAlive()) {            thread.wakeupSelector();        } else {            thread.closeSelector();        }    }    if (workerPool != null) {        workerPool.stop();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    try {                stop();                join();                closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        if (login != null) {            login.shutdown();        }    } catch (InterruptedException e) {        LOG.warn("Ignoring interrupted exception during shutdown", e);    } catch (Exception e) {        LOG.warn("Ignoring unexpected exception during shutdown", e);    }    if (zkServer != null) {        zkServer.shutdown();    }}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{    if (acceptThread != null) {        acceptThread.join();    }    for (SelectorThread thread : selectorThreads) {        thread.join();    }    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }}
6de8cf9ab3f727cc2ed14c5955c80e7d8b809af8d0c2ac4fb0074e3d877e2074
getConnections
public Iterable<ServerCnxn> getConnections()
{    return cnxns;}
d0128cb0bb01c72d6127ec4ee9ad78a0dc6e71d6d0e247aa75ae0cf0684eb0fb
dumpConnections
public void dumpConnections(PrintWriter pwriter)
{    pwriter.print("Connections ");    cnxnExpiryQueue.dump(pwriter);}
615cf9dcbd18f11125b7fd2bc66c45596616007a5dbab858acd99aa19935522f
resetAllConnectionStats
public void resetAllConnectionStats()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
3c74c863c15ec83c7164e0cfae9f6a1820b2694bcac1e903f279dea9d9e9bdfd
getAllConnectionInfo
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    HashSet<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
251e5912e67ddf18c4751e862e6e43f8656e3fd99745126a2826ad68ea41a1e3
put
public DataNode put(String path, DataNode node)
{    DataNode oldNode = nodes.put(path, node);    addDigest(path, node);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
a0de770ccc67ec0bd68da43596255242b7f1ff0cca390befd2514b3f97ef3d65
putWithoutDigest
public DataNode putWithoutDigest(String path, DataNode node)
{    return nodes.put(path, node);}
24f7e32a6614ac6fba82bd2eea2d0d2fc8acee2e69818199663b85c5b97677e7
get
public DataNode get(String path)
{    return nodes.get(path);}
7c8d85e7313402fcf61d1929390245e36e4b12c3f9df1d94bf921d5c991d5187
remove
public DataNode remove(String path)
{    DataNode oldNode = nodes.remove(path);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
98e5ce7d4985b315248317a06d700767a88d06325e62647468bff8d340101d65
keySet
public ConcurrentHashMap.KeySetView<String, DataNode> keySet()
{    return nodes.keySet();}
8e3eefb103306411db1f91fdfc21ce5dda1e1c33a40f7f121716c499c38aa88e
entrySet
public Set<Map.Entry<String, DataNode>> entrySet()
{    return nodes.entrySet();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    nodes.clear();    hash = new AdHash();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return nodes.size();}
bde2748942484102d854473571527b3a0b275bc5debf4708974d50fc9219b37a
preChange
public void preChange(String path, DataNode node)
{    removeDigest(path, node);}
50a2f04f3105aab872b8d3966603e528247c5825db3de2dab3acfe5d50361111
postChange
public void postChange(String path, DataNode node)
{            node.digestCached = false;    addDigest(path, node);}
411bdb66e4c920d8de979fc5a9c69d12d1875151855384436d8fe4e0a7842061
addDigest
private void addDigest(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.addDigest(digestCalculator.calculateDigest(path, node));    }}
4e63de5451b5a32f241ad9852715c2e1c5b3be4346a3ba6d2c9d23f9f11fb2db
removeDigest
private void removeDigest(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.removeDigest(digestCalculator.calculateDigest(path, node));    }}
af8c658698c84be2b4a37ae1cf3a3193287a17c33afc74882fe3cfeb86091383
getDigest
public long getDigest()
{    return hash.getHash();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "Observer";}
31f3fc9425ae0bb3417ac99a250c8d410a893d69def794732da3a57591a96616
getPendingRevalidationCount
public int getPendingRevalidationCount()
{    return this.observer.getPendingRevalidationsCount();}
4f1ec8c9033d0a4457283cded308db0fec7b84f7c76e3ab807775805037a55de
getQuorumAddress
public String getQuorumAddress()
{    return observer.getSocket().toString();}
9f32b70f7d17f18c53868311ae57a6a991297a423a50cf946f92541ec683d43d
getLearnerMaster
public String getLearnerMaster()
{    QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();    if (learnerMaster == null || learnerMaster.addr == null) {        return "Unknown";    }    return learnerMaster.addr.getAddress().getHostAddress() + ":" + learnerMaster.addr.getPort();}
ae6d1473b7ff687fff05e6a0dd7ad4aa79f4704d79daf135a74c5146aef7a274
setLearnerMaster
public void setLearnerMaster(String learnerMaster)
{    if (!observer.setLearnerMaster(learnerMaster)) {        throw new IllegalArgumentException("Not a valid learner master");    }}
dd6c160619caf8663385b8ef08a43f16752227c8457915f4ffeee42559774b69
getPreAllocSize
public static long getPreAllocSize()
{    return preAllocSize;}
24f56aeacd82e02fd6ca7e5ab98e6537e630f4c22f85c8e5f3cf9a798610c414
setPreallocSize
public static void setPreallocSize(long size)
{    preAllocSize = size;}
6a8243e52b7ce2848769213f680437c2bb57e78aea5a8a8565c5ee6a21c405ea
setCurrentSize
public void setCurrentSize(long currentSize)
{    this.currentSize = currentSize;}
6b925d6dcc0e12899940481c1b8eb204e1a7e17c74739497b6f8c5f36e5e0de7
padFile
 long padFile(FileChannel fileChannel) throws IOException
{    long newFileSize = calculateFileSizeWithPadding(fileChannel.position(), currentSize, preAllocSize);    if (currentSize != newFileSize) {        fileChannel.write((ByteBuffer) fill.position(0), newFileSize - fill.remaining());        currentSize = newFileSize;    }    return currentSize;}
c7e0582311dafbcb965f72334c0eb2a4f5f42ecbc51dcad0932f3fb67d9e089e
calculateFileSizeWithPadding
public static long calculateFileSizeWithPadding(long position, long fileSize, long preAllocSize)
{        if (preAllocSize > 0 && position + 4096 >= fileSize) {                if (position > fileSize) {            fileSize = position + preAllocSize;            fileSize -= fileSize % preAllocSize;        } else {            fileSize += preAllocSize;        }    }    return fileSize;}
331924a46171e4deb9d2fdb6dd415233f62a5d5d135eedbbe7cfef1021df95eb
getLastSnapshotInfo
public SnapshotInfo getLastSnapshotInfo()
{    return this.lastSnapshotInfo;}
cb6c000a99181abc9ca8793d8b964ebb15a2bb0ad5a143aff36f62d6286c4299
deserialize
public long deserialize(DataTree dt, Map<Long, Integer> sessions) throws IOException
{                List<File> snapList = findNValidSnapshots(100);    if (snapList.size() == 0) {        return -1L;    }    File snap = null;    boolean foundValid = false;    for (int i = 0, snapListSize = snapList.size(); i < snapListSize; i++) {        snap = snapList.get(i);        LOG.info("Reading snapshot " + snap);        try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {            InputArchive ia = BinaryInputArchive.getArchive(snapIS);            deserialize(dt, sessions, ia);            SnapStream.checkSealIntegrity(snapIS, ia);            if (dt.deserializeZxidDigest(ia)) {                SnapStream.checkSealIntegrity(snapIS, ia);            }            foundValid = true;            break;        } catch (IOException e) {            LOG.warn("problem reading snap file " + snap, e);        }    }    if (!foundValid) {        throw new IOException("Not able to find valid snapshots in " + snapDir);    }    dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);    lastSnapshotInfo = new SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / 1000);        if (dt.getDigestFromLoadedSnapshot() != null) {        dt.compareSnapshotDigests(dt.lastProcessedZxid);    }    return dt.lastProcessedZxid;}
d4e2bcbcc62cf70487c340c7fc0e8bb2effb6b95fdb4baf1a78bf8ccb77a34bb
deserialize
public void deserialize(DataTree dt, Map<Long, Integer> sessions, InputArchive ia) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != SNAP_MAGIC) {        throw new IOException("mismatching magic headers " + header.getMagic() + " !=  " + FileSnap.SNAP_MAGIC);    }    SerializeUtils.deserializeSnapshot(dt, ia, sessions);}
1ab8986e0298ca0a88ebe3e5eba4d75d2cee3146ad2b3f9be5d01d979d9c7df4
findMostRecentSnapshot
public File findMostRecentSnapshot() throws IOException
{    List<File> files = findNValidSnapshots(1);    if (files.size() == 0) {        return null;    }    return files.get(0);}
3a42bb1af9dbfbcad3cec811be7b5faa2d50d6422f3a2f0a2b0fe3a6720f0ca6
findNValidSnapshots
private List<File> findNValidSnapshots(int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {                try {            if (SnapStream.isValidSnapshot(f)) {                list.add(f);                count++;                if (count == n) {                    break;                }            }        } catch (IOException e) {            LOG.info("invalid snapshot " + f, e);        }    }    return list;}
8c39bab4741955cb1e93a9aecaad8df28f4e76faf793df050b47beba2b78a70a
findNRecentSnapshots
public List<File> findNRecentSnapshots(int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {        if (count == n) {            break;        }        if (Util.getZxidFromName(f.getName(), SNAPSHOT_FILE_PREFIX) != -1) {            count++;            list.add(f);        }    }    return list;}
3bb1357ae280e50dd55d0677a9d0041bc4158d34522813750cb3f8a28d5ce3f3
serialize
protected void serialize(DataTree dt, Map<Long, Integer> sessions, OutputArchive oa, FileHeader header) throws IOException
{        if (header == null) {        throw new IllegalStateException("Snapshot's not open for writing: uninitialized header");    }    header.serialize(oa, "fileheader");    SerializeUtils.serializeSnapshot(dt, oa, sessions);}
fe8c702e197f7d93447c86f23f8c1ea75fcfd495762f9b83fdf6ba9efd3aa9bf
serialize
public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{    if (!close) {        try (CheckedOutputStream snapOS = SnapStream.getOutputStream(snapShot)) {            OutputArchive oa = BinaryOutputArchive.getArchive(snapOS);            FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);            serialize(dt, sessions, oa, header);            SnapStream.sealStream(snapOS, oa);                        if (dt.serializeZxidDigest(oa)) {                SnapStream.sealStream(snapOS, oa);            }            lastSnapshotInfo = new SnapshotInfo(Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX), snapShot.lastModified() / 1000);        }    }}
35ca64bd038c6940441ea04192763bfb7ab4ce75b0657322f59055da9e767cad
writeChecksum
private void writeChecksum(CheckedOutputStream crcOut, OutputArchive oa) throws IOException
{    long val = crcOut.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
c189737cbf8634d577f6b561249eb45352b551da539ec4664846b40384c2e99e
checkChecksum
private void checkChecksum(CheckedInputStream crcIn, InputArchive ia) throws IOException
{    long checkSum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    close = true;}
24f56aeacd82e02fd6ca7e5ab98e6537e630f4c22f85c8e5f3cf9a798610c414
setPreallocSize
public static void setPreallocSize(long size)
{    FilePadding.setPreallocSize(size);}
dfaef1b94d61e0cf854ef9eb53b6bf5e784c56f9cfb01a47ce9ed43fbcb6666c
setServerStats
public synchronized void setServerStats(ServerStats serverStats)
{    this.serverStats = serverStats;}
518bf715eb04608943314359f3113f8c6ba67402b5c125a37968c889aa13d532
setTxnLogSizeLimit
public static void setTxnLogSizeLimit(long size)
{    txnLogSizeLimit = size;}
507dc8eff9200595fd1e54bb05f3cc3839e7d8a6790ed003aa02996ce79b4154
getCurrentLogSize
public synchronized long getCurrentLogSize()
{    if (logFileWrite != null) {        return logFileWrite.length();    }    return 0;}
494fe53f163f9731623b65f4bbac85767b799c3a1d0eb59a719d3310d79db01f
setTotalLogSize
public synchronized void setTotalLogSize(long size)
{    prevLogsRunningTotal = size;}
f25107d5f47c90be098032bae7839439c446ebce0d3e2a5a8864869d82bff28e
getTotalLogSize
public synchronized long getTotalLogSize()
{    return prevLogsRunningTotal + getCurrentLogSize();}
f45f8d65f82a05449d8a0afad76cbbe99acd992ad09f27c0f9932bbccbf2e28e
makeChecksumAlgorithm
protected Checksum makeChecksumAlgorithm()
{    return new Adler32();}
87d3be2a867eac393a0f9a8b519df3f4ea0a6b5f856d9e0a62b9a105bd6c3ba0
rollLog
public synchronized void rollLog() throws IOException
{    if (logStream != null) {        this.logStream.flush();        prevLogsRunningTotal += getCurrentLogSize();        this.logStream = null;        oa = null;        }}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    if (logStream != null) {        logStream.close();    }    for (FileOutputStream log : streamsToFlush) {        log.close();    }}
bee698df3cc5c70ef74a4e454695031484afde23dd829d831156a1093ab5e376
append
public synchronized boolean append(TxnHeader hdr, Record txn) throws IOException
{    if (hdr == null) {        return false;    }    if (hdr.getZxid() <= lastZxidSeen) {        LOG.warn("Current zxid " + hdr.getZxid() + " is <= " + lastZxidSeen + " for " + hdr.getType());    } else {        lastZxidSeen = hdr.getZxid();    }    if (logStream == null) {        if (LOG.isInfoEnabled()) {            LOG.info("Creating new log file: " + Util.makeLogName(hdr.getZxid()));        }        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));        fos = new FileOutputStream(logFileWrite);        logStream = new BufferedOutputStream(fos);        oa = BinaryOutputArchive.getArchive(logStream);        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);        fhdr.serialize(oa, "fileheader");                logStream.flush();        filePadding.setCurrentSize(fos.getChannel().position());        streamsToFlush.add(fos);    }    filePadding.padFile(fos.getChannel());    byte[] buf = Util.marshallTxnEntry(hdr, txn);    if (buf == null || buf.length == 0) {        throw new IOException("Faulty serialization for header " + "and txn");    }    Checksum crc = makeChecksumAlgorithm();    crc.update(buf, 0, buf.length);    oa.writeLong(crc.getValue(), "txnEntryCRC");    Util.writeTxnBytes(oa, buf);    return true;}
e9c867627888b7056c231a0154ae6faf3b99b19b691bce80e43e87498243ed28
getLogFiles
public static File[] getLogFiles(File[] logDirList, long snapshotZxid)
{    List<File> files = Util.sortDataDir(logDirList, LOG_FILE_PREFIX, true);    long logZxid = 0;        for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid > snapshotZxid) {            break;        }                if (fzxid > logZxid) {            logZxid = fzxid;        }    }    List<File> v = new ArrayList<File>(5);    for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid < logZxid) {            continue;        }        v.add(f);    }    return v.toArray(new File[0]);}
2c9670d04327ce3ca4f0ceca8f612ee06721695b2d2cd2a76287a9686e5cbc5b
getLastLoggedZxid
public long getLastLoggedZxid()
{    File[] files = getLogFiles(logDir.listFiles(), 0);    long maxLog = files.length > 0 ? Util.getZxidFromName(files[files.length - 1].getName(), LOG_FILE_PREFIX) : -1;            long zxid = maxLog;    TxnIterator itr = null;    try {        FileTxnLog txn = new FileTxnLog(logDir);        itr = txn.read(maxLog);        while (true) {            if (!itr.next()) {                break;            }            TxnHeader hdr = itr.getHeader();            zxid = hdr.getZxid();        }    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        close(itr);    }    return zxid;}
e08dec9630a304224ce5e78cef90e4bfae3c5b7a5c3e2906a14ce3534302da10
close
private void close(TxnIterator itr)
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {            LOG.warn("Error closing file iterator", ioe);        }    }}
5b37a0003f2890b03b0eca9cf61a2bab65918a82c504ce7097642f6699bed12a
commit
public synchronized void commit() throws IOException
{    if (logStream != null) {        logStream.flush();    }    for (FileOutputStream log : streamsToFlush) {        log.flush();        if (forceSync) {            long startSyncNS = System.nanoTime();            FileChannel channel = log.getChannel();            channel.force(false);            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);            if (syncElapsedMS > fsyncWarningThresholdMS) {                if (serverStats != null) {                    serverStats.incrementFsyncThresholdExceedCount();                }                LOG.warn("fsync-ing the write ahead log in " + Thread.currentThread().getName() + " took " + syncElapsedMS + "ms which will adversely effect operation latency. " + "File size is " + channel.size() + " bytes. " + "See the ZooKeeper troubleshooting guide");            }            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);        }    }    while (streamsToFlush.size() > 1) {        streamsToFlush.poll().close();    }        if (txnLogSizeLimit > 0) {        long logSize = getCurrentLogSize();        if (logSize > txnLogSizeLimit) {            LOG.debug("Log size limit reached: {}", logSize);            rollLog();        }    }}
51acd770940eaac6de287424d0f3e9280007b36168cf742249a5ef2328ebd4b1
getTxnLogSyncElapsedTime
public long getTxnLogSyncElapsedTime()
{    return syncElapsedMS;}
feba77eb2c479b190459ee22e5b7d16b7c7a893aeb961bb813625c9c4b9376be
read
public TxnIterator read(long zxid) throws IOException
{    return read(zxid, true);}
6e0d62b42dbf3b324b44fb90261f83bded871cb53f004616c0a9658349b0de18
read
public TxnIterator read(long zxid, boolean fastForward) throws IOException
{    return new FileTxnIterator(logDir, zxid, fastForward);}
b98de30302e14ca5460fdf8d085496a521b839986495483c6b0f7e054e5acf7d
truncate
public boolean truncate(long zxid) throws IOException
{    FileTxnIterator itr = null;    try {        itr = new FileTxnIterator(this.logDir, zxid);        PositionInputStream input = itr.inputStream;        if (input == null) {            throw new IOException("No log files found to truncate! This could " + "happen if you still have snapshots from an old setup or " + "log files were deleted accidentally or dataLogDir was changed in zoo.cfg.");        }        long pos = input.getPosition();                RandomAccessFile raf = new RandomAccessFile(itr.logFile, "rw");        raf.setLength(pos);        raf.close();        while (itr.goToNextLog()) {            if (!itr.logFile.delete()) {                LOG.warn("Unable to truncate {}", itr.logFile);            }        }    } finally {        close(itr);    }    return true;}
e7e6b99131f3dc80410c60062fb30173c51981330d45e20f3138dc4792d72415
readHeader
private static FileHeader readHeader(File file) throws IOException
{    InputStream is = null;    try {        is = new BufferedInputStream(new FileInputStream(file));        InputArchive ia = BinaryInputArchive.getArchive(is);        FileHeader hdr = new FileHeader();        hdr.deserialize(ia, "fileheader");        return hdr;    } finally {        try {            if (is != null) {                is.close();            }        } catch (IOException e) {            LOG.warn("Ignoring exception during close", e);        }    }}
c96a2941e9a3b8e23d497095df5170d190731490e30ba28ad7186117bb71733e
getDbId
public long getDbId() throws IOException
{    FileTxnIterator itr = new FileTxnIterator(logDir, 0);    FileHeader fh = readHeader(itr.logFile);    itr.close();    if (fh == null) {        throw new IOException("Unsupported Format.");    }    return fh.getDbid();}
45941e2b7f1db8cf4fc10e382fe2675652cc6f48af744972fea2ab185c703736
isForceSync
public boolean isForceSync()
{    return forceSync;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    int rc = super.read();    if (rc > -1) {        position++;    }    return rc;}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    int rc = super.read(b);    if (rc > 0) {        position += rc;    }    return rc;}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    int rc = super.read(b, off, len);    if (rc > 0) {        position += rc;    }    return rc;}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    long rc = super.skip(n);    if (rc > 0) {        position += rc;    }    return rc;}
440295a41d4e3cef67a12523813a1969b46946ef4ce8d8b8b75a27bceedd007b
getPosition
public long getPosition()
{    return position;}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return false;}
66e7c01ddabee382227faa94695ffd62c544d254a9cac44d08e2a0181cc24e7f
mark
public void mark(int readLimit)
{    throw new UnsupportedOperationException("mark");}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    throw new UnsupportedOperationException("reset");}
fc259524ccbd012f922831b0ebc8388017d3ec5b5915344d1a0e351db2800107
init
 void init() throws IOException
{    storedFiles = new ArrayList<>();    List<File> files = Util.sortDataDir(FileTxnLog.getLogFiles(logDir.listFiles(), 0), LOG_FILE_PREFIX, false);    for (File f : files) {        if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) >= zxid) {            storedFiles.add(f);        } else if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) < zxid) {                        storedFiles.add(f);            break;        }    }    goToNextLog();    next();}
63741c9e67653aa482dff711943c03ed9f649b41f00a5ee71c0be15467a8e162
getStorageSize
public long getStorageSize()
{    long sum = 0;    for (File f : storedFiles) {        sum += f.length();    }    return sum;}
a7e475494957046aaa681c70469c6255ad63da1cb1674133b8a1b923883a10a1
goToNextLog
private boolean goToNextLog() throws IOException
{    if (storedFiles.size() > 0) {        this.logFile = storedFiles.remove(storedFiles.size() - 1);        ia = createInputArchive(this.logFile);        return true;    }    return false;}
427d6918b41bc13cfeae2735997d4f01d193cf10e9af186dd5fc429f968d5ba3
inStreamCreated
protected void inStreamCreated(InputArchive ia, InputStream is) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        throw new IOException("Transaction log: " + this.logFile + " has invalid magic number " + header.getMagic() + " != " + FileTxnLog.TXNLOG_MAGIC);    }}
55f89baa3cad0e3ffb2e50ed111c75ebcad1e0ba29fedc7530917b3a78170d78
createInputArchive
protected InputArchive createInputArchive(File logFile) throws IOException
{    if (inputStream == null) {        inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));        LOG.debug("Created new input stream: {}", logFile);        ia = BinaryInputArchive.getArchive(inputStream);        inStreamCreated(ia, inputStream);        LOG.debug("Created new input archive: {}", logFile);    }    return ia;}
f45f8d65f82a05449d8a0afad76cbbe99acd992ad09f27c0f9932bbccbf2e28e
makeChecksumAlgorithm
protected Checksum makeChecksumAlgorithm()
{    return new Adler32();}
e7308b7772e8ce0a398ea8313a5709d1911eb5f4d5cb9fc0f73945700c6691ea
next
public boolean next() throws IOException
{    if (ia == null) {        return false;    }    try {        long crcValue = ia.readLong("crcvalue");        byte[] bytes = Util.readTxnBytes(ia);                if (bytes == null || bytes.length == 0) {            throw new EOFException("Failed to read " + logFile);        }                        Checksum crc = makeChecksumAlgorithm();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException(CRC_ERROR);        }        hdr = new TxnHeader();        record = SerializeUtils.deserializeTxn(bytes, hdr);    } catch (EOFException e) {        LOG.debug("EOF exception", e);        inputStream.close();        inputStream = null;        ia = null;        hdr = null;                if (!goToNextLog()) {            return false;        }                return next();    } catch (IOException e) {        inputStream.close();        throw e;    }    return true;}
62cee719483c1c13a75b3c4548d30b555c5f1dc1d078c12fdd8afdedeeb88ccc
getHeader
public TxnHeader getHeader()
{    return hdr;}
bcc5f4ab9662ab8429d6e57a2acfe9922f5bfecf749b25f24280aca0df56bcf9
getTxn
public Record getTxn()
{    return record;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (inputStream != null) {        inputStream.close();    }}
52274987007aecd0cdc4511111f250579494f08681f50ba27b6321215bb1d2c4
setServerStats
public void setServerStats(ServerStats serverStats)
{    txnLog.setServerStats(serverStats);}
100dd5a11683ba90af681671d880dcc259574ba3cf4512abd3a54a577f6aed2f
checkLogDir
private void checkLogDir() throws LogDirContentCheckException
{    File[] files = this.dataDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isSnapshotFileName(name);        }    });    if (files != null && files.length > 0) {        throw new LogDirContentCheckException("Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.");    }}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return Util.isSnapshotFileName(name);}
d454f7bdaba411ff1df5acc555a7dc552d86ac511a131b93cf615f98d3673798
checkSnapDir
private void checkSnapDir() throws SnapDirContentCheckException
{    File[] files = this.snapDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isLogFileName(name);        }    });    if (files != null && files.length > 0) {        throw new SnapDirContentCheckException("Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.");    }}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return Util.isLogFileName(name);}
260452c67ee229efb360439b03779c159761f631bb6945711988d544e37e5140
getDataDir
public File getDataDir()
{    return this.dataDir;}
2b9e5e29a6fc50c7aa93f431e78b37d0fedb6831e2951819d6b65df32476d139
getSnapDir
public File getSnapDir()
{    return this.snapDir;}
331924a46171e4deb9d2fdb6dd415233f62a5d5d135eedbbe7cfef1021df95eb
getLastSnapshotInfo
public SnapshotInfo getLastSnapshotInfo()
{    return this.snapLog.getLastSnapshotInfo();}
bd1ef631e26817c96c11f6cbd7fb6ac7a3e55e967e813bd42c860c54c25ca2ab
restore
public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    long snapLoadingStartTime = Time.currentElapsedTime();    long deserializeResult = snapLog.deserialize(dt, sessions);    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);    FileTxnLog txnLog = new FileTxnLog(dataDir);    boolean trustEmptyDB;    File initFile = new File(dataDir.getParent(), "initialize");    if (Files.deleteIfExists(initFile.toPath())) {        LOG.info("Initialize file found, an empty database will not block voting participation");        trustEmptyDB = true;    } else {        trustEmptyDB = autoCreateDB;    }    if (-1L == deserializeResult) {        /* this means that we couldn't find any snapshot, so we need to             * initialize an empty database (reported in ZOOKEEPER-2325) */        if (txnLog.getLastLoggedZxid() != -1) {                        if (!trustEmptySnapshot) {                throw new IOException(EMPTY_SNAPSHOT_WARNING + "Something is broken!");            } else {                LOG.warn(EMPTY_SNAPSHOT_WARNING + "This should only be allowed during upgrading.");            }        }        if (trustEmptyDB) {            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()                 *       or use Map on save() */            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);            /* return a zxid of 0, since we know the database is empty */            return 0L;        } else {            /* return a zxid of -1, since we are possibly missing data */            LOG.warn("Unexpected empty data tree, setting zxid to -1");            dt.lastProcessedZxid = -1L;            return -1L;        }    }    long highestZxid = fastForwardFromEdits(dt, sessions, listener);                    DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();    if (snapshotZxidDigest != null) {        LOG.warn("Highest txn zxid 0x{} is not covering the snapshot " + "digest zxid 0x{}, which might lead to inconsistent state", Long.toHexString(highestZxid), Long.toHexString(snapshotZxidDigest.getZxid()));    }    return highestZxid;}
3627f5dd1b8a04e0efe86c9c2d7c68573c0707124ecd865aed8290b1ba212048
fastForwardFromEdits
public long fastForwardFromEdits(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);    long highestZxid = dt.lastProcessedZxid;    TxnHeader hdr;    int txnLoaded = 0;    long startTime = Time.currentElapsedTime();    try {        while (true) {                                    hdr = itr.getHeader();            if (hdr == null) {                                return dt.lastProcessedZxid;            }            if (hdr.getZxid() < highestZxid && highestZxid != 0) {                LOG.error("{}(highestZxid) > {}(next log) for type {}", highestZxid, hdr.getZxid(), hdr.getType());            } else {                highestZxid = hdr.getZxid();            }            try {                processTransaction(hdr, dt, sessions, itr.getTxn());                txnLoaded++;            } catch (KeeperException.NoNodeException e) {                throw new IOException("Failed to process transaction type: " + hdr.getType() + " error: " + e.getMessage(), e);            }            listener.onTxnLoaded(hdr, itr.getTxn());            if (!itr.next()) {                break;            }        }    } finally {        if (itr != null) {            itr.close();        }    }    long loadTime = Time.currentElapsedTime() - startTime;    LOG.info("{} txns loaded in {} ms", txnLoaded, loadTime);    ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);    return highestZxid;}
0b056f20c2b7b19ab130c14b5a6d40b3aa7f394cea604668211e16b59ca39aa6
readTxnLog
public TxnIterator readTxnLog(long zxid) throws IOException
{    return readTxnLog(zxid, true);}
8dbac730c8a5b54ead959c9b4e7ea7bdd08a8b2c1f409f06d6de946f4338eddc
readTxnLog
public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.read(zxid, fastForward);}
250aea9edf85fb8d0a3551cafca7c4983e512e84fd7f984a8c299171956c72f8
processTransaction
public void processTransaction(TxnHeader hdr, DataTree dt, Map<Long, Integer> sessions, Record txn) throws KeeperException.NoNodeException
{    ProcessTxnResult rc;    switch(hdr.getType()) {        case OpCode.createSession:            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- create session in log: 0x" + Long.toHexString(hdr.getClientId()) + " with timeout: " + ((CreateSessionTxn) txn).getTimeOut());            }                        rc = dt.processTxn(hdr, txn);            break;        case OpCode.closeSession:            sessions.remove(hdr.getClientId());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- close session in log: 0x" + Long.toHexString(hdr.getClientId()));            }            rc = dt.processTxn(hdr, txn);            break;        default:            rc = dt.processTxn(hdr, txn);    }    /*         * Snapshots are lazily created. So when a snapshot is in progress,         * there is a chance for later transactions to make into the         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS         * errors could occur. It should be safe to ignore these.         */    if (rc.err != Code.OK.intValue()) {        LOG.debug("Ignoring processTxn failure hdr: {}, error: {}, path: {}", hdr.getType(), rc.err, rc.path);    }}
2c9670d04327ce3ca4f0ceca8f612ee06721695b2d2cd2a76287a9686e5cbc5b
getLastLoggedZxid
public long getLastLoggedZxid()
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.getLastLoggedZxid();}
bed112a6d3be8e1db7c1ee9f538a022c827c95c27ec9782c9f7169f63133b6c1
save
public void save(DataTree dataTree, ConcurrentHashMap<Long, Integer> sessionsWithTimeouts, boolean syncSnap) throws IOException
{    long lastZxid = dataTree.lastProcessedZxid;    File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));    LOG.info("Snapshotting: 0x{} to {}", Long.toHexString(lastZxid), snapshotFile);    try {        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);    } catch (IOException e) {        if (snapshotFile.length() == 0) {            /* This may be caused by a full disk. In such a case, the server                 * will get stuck in a loop where it tries to write a snapshot                 * out to disk, and ends up creating an empty file instead.                 * Doing so will eventually result in valid snapshots being                 * removed during cleanup. */            if (snapshotFile.delete()) {                LOG.info("Deleted empty snapshot file: " + snapshotFile.getAbsolutePath());            } else {                LOG.warn("Could not delete empty snapshot file: " + snapshotFile.getAbsolutePath());            }        } else {        /* Something else went wrong when writing the snapshot out to                 * disk. If this snapshot file is invalid, when restarting,                 * ZooKeeper will skip it, and find the last known good snapshot                 * instead. */        }        throw e;    }}
f6668015d8d8a47df8745d3037b667ac17ecb3550f2b9728df27d7fa09bc3417
truncateLog
public boolean truncateLog(long zxid) throws IOException
{        close();        FileTxnLog truncLog = new FileTxnLog(dataDir);    boolean truncated = truncLog.truncate(zxid);    truncLog.close();                    txnLog = new FileTxnLog(dataDir);    snapLog = new FileSnap(snapDir);    return truncated;}
1ab8986e0298ca0a88ebe3e5eba4d75d2cee3146ad2b3f9be5d01d979d9c7df4
findMostRecentSnapshot
public File findMostRecentSnapshot() throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findMostRecentSnapshot();}
8c39bab4741955cb1e93a9aecaad8df28f4e76faf793df050b47beba2b78a70a
findNRecentSnapshots
public List<File> findNRecentSnapshots(int n) throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findNRecentSnapshots(n);}
0d1502480b059d27c5b0b7ca136a8825163ef7262e6ca4caea01ad179e0a865d
getSnapshotLogs
public File[] getSnapshotLogs(long zxid)
{    return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);}
8f79bde80291d9839ada9ad5e5b53cca94bd063e3a7d06c1ba57ba571917965b
append
public boolean append(Request si) throws IOException
{    return txnLog.append(si.getHdr(), si.getTxn());}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    txnLog.commit();}
7864df53f01bb25ce9754b42cd0b1cff9b40d908cb6df9cb4ca1c44b2506cb5c
getTxnLogElapsedSyncTime
public long getTxnLogElapsedSyncTime()
{    return txnLog.getTxnLogSyncElapsedTime();}
cd4f94fe6aeb66cd1ebbab0dfafcc9fea3ad20b8f993df7acb8d19d414f47fc1
rollLog
public void rollLog() throws IOException
{    txnLog.rollLog();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    txnLog.close();    snapLog.close();}
4bca0cb597cefcece5fa866019cf4015f12793dd548a6085628103bc07386923
setTotalLogSize
public void setTotalLogSize(long size)
{    txnLog.setTotalLogSize(size);}
d3439bc743f6a0b77dff72da6002e7adc47eaacc5a91da7e231098a169a0dd25
getTotalLogSize
public long getTotalLogSize()
{    return txnLog.getTotalLogSize();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
39f2783f4f89b53bea03fb512c6d180f8c668c0e706fed6c72c382b2df3ba218
getFileExtension
public String getFileExtension()
{    return name.isEmpty() ? "" : "." + name;}
8600680c6e6ef15ed6c8d8129fdf34fe3b129a3c1f7a5615b66b13f3f84a8390
fromString
public static StreamMode fromString(String name)
{    for (StreamMode c : values()) {        if (c.getName().compareToIgnoreCase(name) == 0) {            return c;        }    }    return DEFAULT_MODE;}
f4e3a62119c68af3689e71defb12df129a905c8e6aad12d86a1de2083906e1f2
getInputStream
public static CheckedInputStream getInputStream(File file) throws IOException
{    FileInputStream fis = new FileInputStream(file);    InputStream is;    switch(getStreamMode(file.getName())) {        case GZIP:            is = new GZIPInputStream(fis);            break;        case SNAPPY:            is = new SnappyInputStream(fis);            break;        case CHECKED:        default:            is = new BufferedInputStream(fis);    }    return new CheckedInputStream(is, new Adler32());}
75d6a131ce6413e0844c4f8d268aa35e96bd225143ceb0a1474138c319749019
getOutputStream
public static CheckedOutputStream getOutputStream(File file) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    OutputStream os;    switch(streamMode) {        case GZIP:            os = new GZIPOutputStream(fos);            break;        case SNAPPY:            os = new SnappyOutputStream(fos);            break;        case CHECKED:        default:            os = new BufferedOutputStream(fos);    }    return new CheckedOutputStream(os, new Adler32());}
834457edf107915e171df2fb7fcea79a9a2944d102ae86b9fb4be076b314ee5b
sealStream
public static void sealStream(CheckedOutputStream os, OutputArchive oa) throws IOException
{    long val = os.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
993c7d8ebe3e85f14c6543f7916e204400c3ade4d53dfa89f17693688095cf80
checkSealIntegrity
 static void checkSealIntegrity(CheckedInputStream is, InputArchive ia) throws IOException
{    long checkSum = is.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
203877270f9a17e86eb3ed986b8d03dc2300ee3b0bb14eb3f9a7d4ed87bca282
isValidSnapshot
public static boolean isValidSnapshot(File file) throws IOException
{    if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {        return false;    }    boolean isValid = false;    switch(getStreamMode(file.getName())) {        case GZIP:            isValid = isValidGZipStream(file);            break;        case SNAPPY:            isValid = isValidSnappyStream(file);            break;        case CHECKED:        default:            isValid = isValidCheckedStream(file);    }    return isValid;}
b374f3dd551f2ad6edf8b38603e71f1a11f7d5bf7370dfc4613097a9e1cff321
setStreamMode
public static void setStreamMode(StreamMode mode)
{    streamMode = mode;}
c166f56a7ee6ff94264e81c3b21cb990d235a502e7aa47e58598dc50d09db110
getStreamMode
public static StreamMode getStreamMode()
{    return streamMode;}
f7db85f49390ae5ce8c60c191ccc9eb3d19b92c208f8f9879a5e6d687f5e5237
getStreamMode
public static StreamMode getStreamMode(String fileName)
{    String[] splitSnapName = fileName.split("\\.");        if (splitSnapName.length > 1) {        String mode = splitSnapName[splitSnapName.length - 1];        return StreamMode.fromString(mode);    }    return StreamMode.CHECKED;}
b7c637486e2fb6d26500d8214e7931baa01e3ea1c9e06bd7dd77a54a524ff288
isValidGZipStream
private static boolean isValidGZipStream(File f) throws IOException
{    byte[] byteArray = new byte[2];    try (FileInputStream fis = new FileInputStream(f)) {        if (2 != fis.read(byteArray, 0, 2)) {            LOG.error("Read incorrect number of bytes from " + f.getName());            return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[2];        bb.get(magicHeader, 0, 2);        int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);        return magic == GZIPInputStream.GZIP_MAGIC;    } catch (FileNotFoundException e) {        LOG.error("Unable to open file " + f.getName() + " : ", e);        return false;    }}
1d6e50757437762cb672d0607e65a612b2ce4189c8b4956620245d85eca22145
isValidSnappyStream
private static boolean isValidSnappyStream(File f) throws IOException
{    byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];    try (FileInputStream fis = new FileInputStream(f)) {        if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {            LOG.error("Read incorrect number of bytes from " + f.getName());            return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];        bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);        return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());    } catch (FileNotFoundException e) {        LOG.error("Unable to open file " + f.getName() + " : ", e);        return false;    }}
e569e608900489c7ee93dbe4b145d78272cc92de23389bb5405c9706c7455875
isValidCheckedStream
private static boolean isValidCheckedStream(File f) throws IOException
{    try (RandomAccessFile raf = new RandomAccessFile(f, "r")) {                if (raf.length() < 10) {            return false;        }        raf.seek(raf.length() - 5);        byte[] bytes = new byte[5];        int readlen = 0;        int l;        while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {            readlen += l;        }        if (readlen != bytes.length) {            LOG.info("Invalid snapshot " + f.getName() + ". too short, len = " + readlen + " bytes");            return false;        }        ByteBuffer bb = ByteBuffer.wrap(bytes);        int len = bb.getInt();        byte b = bb.get();        if (len != 1 || b != '/') {            LOG.info("Invalid snapshot " + f.getName() + ". len = " + len + ", byte = " + (b & 0xff));            return false;        }    }    return true;}
ae6846d8cd787df7fd99aa4701f8314b3d4b1852cca537d7cf977267cda0d0b1
getExitCode
 int getExitCode()
{    return exitCode;}
d98e5a52777c94f3a1bafd670a9f55bd508ecca6d2fc96fba36761353e658cd5
getOptions
 Options getOptions()
{    return options;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    try (final TxnLogToolkit lt = parseCommandLine(args)) {        if (lt.isDumpMode()) {            lt.dump(new Scanner(System.in));            lt.printStat();        } else {            lt.chop();        }    } catch (TxnLogToolkitParseException e) {        System.err.println(e.getMessage() + "\n");        printHelpAndExit(e.getExitCode(), e.getOptions());    } catch (TxnLogToolkitException e) {        System.err.println(e.getMessage());        System.exit(e.getExitCode());    }}
840cfc793f78cb41ed5c4545788060efcf08b55aca454ef4b20c36f77523effc
loadTxnFile
private File loadTxnFile(String txnLogFileName) throws TxnLogToolkitException
{    File logFile = new File(txnLogFileName);    if (!logFile.exists() || !logFile.canRead()) {        throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "File doesn't exist or not readable: %s", logFile);    }    return logFile;}
14f581c812a11ffb0a126ddc1e2caa01ba3605060ef4b6d7958f1833009ab32f
dump
public void dump(Scanner scanner) throws Exception
{    crcFixed = 0;    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != TXNLOG_MAGIC) {        throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Invalid magic number for %s", txnLogFile.getName());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    if (recoveryMode) {        fhdr.serialize(recoveryOa, "fileheader");        recoveryFos.flush();        filePadding.setCurrentSize(recoveryFos.getChannel().position());    }    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            if (recoveryMode) {                if (!force) {                    printTxn(bytes, "CRC ERROR");                    if (askForFix(scanner)) {                        crcValue = crc.getValue();                        ++crcFixed;                    }                } else {                    crcValue = crc.getValue();                    printTxn(bytes, "CRC FIXED");                    ++crcFixed;                }            } else {                printTxn(bytes, "CRC ERROR");            }        }        if (!recoveryMode || verbose) {            printTxn(bytes);        }        if (logStream.readByte("EOR") != 'B') {            throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "Last transaction was partial.");        }        if (recoveryMode) {            filePadding.padFile(recoveryFos.getChannel());            recoveryOa.writeLong(crcValue, "crcvalue");            recoveryOa.writeBuffer(bytes, "txnEntry");            recoveryOa.writeByte((byte) 'B', "EOR");        }        count++;    }}
f0f025358ea3ac25a63c177107cacfc34d538c53722d4cdb800610a26df26170
chop
public void chop()
{    File targetFile = new File(txnLogFile.getParentFile(), txnLogFile.getName() + ".chopped" + zxid);    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLogFile));        OutputStream os = new BufferedOutputStream(new FileOutputStream(targetFile))) {        if (!LogChopper.chop(is, os, zxid)) {            throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Failed to chop %s", txnLogFile.getName());        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }}
b35457a4df66373e52398d4992a43218a9ed7d9990cd659305d96e538fca0347
isDumpMode
public boolean isDumpMode()
{    return zxid < 0;}
956fa931dc1ee0646f07fe8109be49a7767f27eddb454f72f2e744be54199175
askForFix
private boolean askForFix(Scanner scanner) throws TxnLogToolkitException
{    while (true) {        System.out.print("Would you like to fix it (Yes/No/Abort) ? ");        char answer = Character.toUpperCase(scanner.next().charAt(0));        switch(answer) {            case 'Y':                return true;            case 'N':                return false;            case 'A':                throw new TxnLogToolkitException(ExitCode.EXECUTION_FINISHED.getValue(), "Recovery aborted.");        }    }}
9a6abd083bb2bc0835c36bdfcbf55142cffe0bafb57fa25fa753e434ed5b527c
printTxn
private void printTxn(byte[] bytes) throws IOException
{    printTxn(bytes, "");}
a6d69447663e264eda62d94a86dcddc04f568c705235a58ce1f83a3ced574e9e
printTxn
private void printTxn(byte[] bytes, String prefix) throws IOException
{    TxnHeader hdr = new TxnHeader();    Record txn = SerializeUtils.deserializeTxn(bytes, hdr);    String txnStr = getFormattedTxnStr(txn);    String txns = String.format("%s session 0x%s cxid 0x%s zxid 0x%s %s %s", DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())), Long.toHexString(hdr.getClientId()), Long.toHexString(hdr.getCxid()), Long.toHexString(hdr.getZxid()), Request.op2String(hdr.getType()), txnStr);    if (prefix != null && !"".equals(prefix.trim())) {        System.out.print(prefix + " - ");    }    if (txns.endsWith("\n")) {        System.out.print(txns);    } else {        System.out.println(txns);    }}
fd8dfbc6ad049e7833a2e696cdb8931efca4e3b4fbfb258343c89d80322a97a6
getFormattedTxnStr
private static String getFormattedTxnStr(Record txn) throws IOException
{    StringBuilder txnData = new StringBuilder();    if (txn == null) {        return txnData.toString();    }    if (txn instanceof CreateTxn) {        CreateTxn createTxn = ((CreateTxn) txn);        txnData.append(createTxn.getPath() + "," + checkNullToEmpty(createTxn.getData())).append("," + createTxn.getAcl() + "," + createTxn.getEphemeral()).append("," + createTxn.getParentCVersion());    } else if (txn instanceof SetDataTxn) {        SetDataTxn setDataTxn = ((SetDataTxn) txn);        txnData.append(setDataTxn.getPath() + "," + checkNullToEmpty(setDataTxn.getData())).append("," + setDataTxn.getVersion());    } else if (txn instanceof CreateContainerTxn) {        CreateContainerTxn createContainerTxn = ((CreateContainerTxn) txn);        txnData.append(createContainerTxn.getPath() + "," + checkNullToEmpty(createContainerTxn.getData())).append("," + createContainerTxn.getAcl() + "," + createContainerTxn.getParentCVersion());    } else if (txn instanceof CreateTTLTxn) {        CreateTTLTxn createTTLTxn = ((CreateTTLTxn) txn);        txnData.append(createTTLTxn.getPath() + "," + checkNullToEmpty(createTTLTxn.getData())).append("," + createTTLTxn.getAcl() + "," + createTTLTxn.getParentCVersion()).append("," + createTTLTxn.getTtl());    } else if (txn instanceof MultiTxn) {        MultiTxn multiTxn = ((MultiTxn) txn);        List<Txn> txnList = multiTxn.getTxns();        for (int i = 0; i < txnList.size(); i++) {            Txn t = txnList.get(i);            if (i == 0) {                txnData.append(Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            } else {                txnData.append(";" + Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            }        }    } else {        txnData.append(txn.toString());    }    return txnData.toString();}
c234535a805eae824360484c0f2f438e85e44ecd2cd1c8b0a72caf01c8beee44
checkNullToEmpty
private static String checkNullToEmpty(byte[] data) throws IOException
{    if (data == null || data.length == 0) {        return "";    }    return new String(data, StandardCharsets.UTF_8);}
18171d67f721303f338d5f7539d9b4b0b1e12f7c75d97e6ffd027cdfbb8500f6
openTxnLogFile
private void openTxnLogFile() throws FileNotFoundException
{    txnFis = new FileInputStream(txnLogFile);    logStream = BinaryInputArchive.getArchive(txnFis);}
b3b2389efaffdd04ca125e0fdc3e78979cf052bfefdc2ca474ca712f7749dd0f
closeTxnLogFile
private void closeTxnLogFile() throws IOException
{    if (txnFis != null) {        txnFis.close();    }}
b95e2abe868176e21cf5eb0d083111a6d2871badcb16899a9d5a248a498261a5
openRecoveryFile
private void openRecoveryFile() throws FileNotFoundException
{    recoveryFos = new FileOutputStream(recoveryLogFile);    recoveryOa = BinaryOutputArchive.getArchive(recoveryFos);}
a44bb33b319a8baae76788c120455afd1372addfa6316b80e0b10e201daac962
closeRecoveryFile
private void closeRecoveryFile() throws IOException
{    if (recoveryFos != null) {        recoveryFos.close();    }}
888622c7a210b0a06400ba581bd45f975620b80a19a20bbe3159202c80fd6c22
parseCommandLine
private static TxnLogToolkit parseCommandLine(String[] args) throws TxnLogToolkitException, FileNotFoundException
{    CommandLineParser parser = new PosixParser();    Options options = new Options();    Option helpOpt = new Option("h", "help", false, "Print help message");    options.addOption(helpOpt);    Option recoverOpt = new Option("r", "recover", false, "Recovery mode. Re-calculate CRC for broken entries.");    options.addOption(recoverOpt);    Option quietOpt = new Option("v", "verbose", false, "Be verbose in recovery mode: print all entries, not just fixed ones.");    options.addOption(quietOpt);    Option dumpOpt = new Option("d", "dump", false, "Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)");    options.addOption(dumpOpt);    Option forceOpt = new Option("y", "yes", false, "Non-interactive mode: repair all CRC errors without asking");    options.addOption(forceOpt);        Option chopOpt = new Option("c", "chop", false, "Chop mode. Chop txn file to a zxid.");    Option zxidOpt = new Option("z", "zxid", true, "Used with chop. Zxid to which to chop.");    options.addOption(chopOpt);    options.addOption(zxidOpt);    try {        CommandLine cli = parser.parse(options, args);        if (cli.hasOption("help")) {            printHelpAndExit(0, options);        }        if (cli.getArgs().length < 1) {            printHelpAndExit(1, options);        }        if (cli.hasOption("chop") && cli.hasOption("zxid")) {            return new TxnLogToolkit(cli.getArgs()[0], cli.getOptionValue("zxid"));        }        return new TxnLogToolkit(cli.hasOption("recover"), cli.hasOption("verbose"), cli.getArgs()[0], cli.hasOption("yes"));    } catch (ParseException e) {        throw new TxnLogToolkitParseException(options, ExitCode.UNEXPECTED_ERROR.getValue(), e.getMessage());    }}
53fc63eca5b714a29749a596a87d2ff1b381307b0a41fb04288c6c5c26369550
printHelpAndExit
private static void printHelpAndExit(int exitCode, Options options)
{    HelpFormatter help = new HelpFormatter();    help.printHelp(120, "TxnLogToolkit [-dhrvc] <txn_log_file_name> (-z <zxid>)", "", options, "");    System.exit(exitCode);}
2e6271bf260eb166490005d2a5cbf3ed39a14dcf946d0aadecacf3782eb6e0c3
printStat
private void printStat()
{    if (recoveryMode) {        System.out.printf("Recovery file %s has been written with %d fixed CRC error(s)%n", recoveryLogFile, crcFixed);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (recoveryMode) {        closeRecoveryFile();    }    closeTxnLogFile();}
083557f87b8166a284d53254963b2d9dfb86d22a339f62088dfcc730e3782cf7
makeURIString
public static String makeURIString(String dataDir, String dataLogDir, String convPolicy)
{    String uri = "file:" + SNAP_DIR + "=" + dataDir + ";" + LOG_DIR + "=" + dataLogDir;    if (convPolicy != null) {        uri += ";" + DB_FORMAT_CONV + "=" + convPolicy;    }    return uri.replace('\\', '/');}
7e36af20b83929f43f931ce6ca4f4da77cec2385597682aeaea2267788ce6805
makeFileLoggerURL
public static URI makeFileLoggerURL(File dataDir, File dataLogDir)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), null));}
c583046eacb41da6b723d901d22333cd4343afc0a241eac60ddfa814972ad32f
makeFileLoggerURL
public static URI makeFileLoggerURL(File dataDir, File dataLogDir, String convPolicy)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), convPolicy));}
4d494b64674e716e65f9b32d3e76a126b00e912e7fe74674aeac7bc6b2e24e60
makeLogName
public static String makeLogName(long zxid)
{    return FileTxnLog.LOG_FILE_PREFIX + "." + Long.toHexString(zxid);}
3ab8f6901157f64e58b93be31290f1fb8e690f7aa376b2cf2e71d689b2ffea6f
makeSnapshotName
public static String makeSnapshotName(long zxid)
{    return FileSnap.SNAPSHOT_FILE_PREFIX + "." + Long.toHexString(zxid) + SnapStream.getStreamMode().getFileExtension();}
ba71ca6997fcba34f9c2add654ce253a7c93240e8765e19dfc073c5d08ef3037
getSnapDir
public static File getSnapDir(Properties props)
{    return new File(props.getProperty(SNAP_DIR));}
23a0046b46eb4498d01839a2e0ab0fd94e8456b3314363aec2a0e075ecb0e433
getLogDir
public static File getLogDir(Properties props)
{    return new File(props.getProperty(LOG_DIR));}
3322b79df6f4a5d820bfb8c960c5204ba4917fabedea4e918390dbda9864dd01
getFormatConversionPolicy
public static String getFormatConversionPolicy(Properties props)
{    return props.getProperty(DB_FORMAT_CONV);}
bd0cc29d17bcc955486ce9554267f9bd82cac7b5d092e21bead27394e4f638ac
getZxidFromName
public static long getZxidFromName(String name, String prefix)
{    long zxid = -1;    String[] nameParts = name.split("\\.");    if (nameParts.length >= 2 && nameParts[0].equals(prefix)) {        try {            zxid = Long.parseLong(nameParts[1], 16);        } catch (NumberFormatException e) {        }    }    return zxid;}
86d372158ca06416640677fabbd677a4e433ff6e0d07977063ecb3c4eaeb61c0
readTxnBytes
public static byte[] readTxnBytes(InputArchive ia) throws IOException
{    try {        byte[] bytes = ia.readBuffer("txtEntry");                if (bytes.length == 0) {            return bytes;        }        if (ia.readByte("EOF") != 'B') {            LOG.error("Last transaction was partial.");            return null;        }        return bytes;    } catch (EOFException e) {    }    return null;}
7c00a18593c1e6db8795db62f9bb4ffc3b5d7d7935b2f82c193ff38e1f8d7c5a
marshallTxnEntry
public static byte[] marshallTxnEntry(TxnHeader hdr, Record txn) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    hdr.serialize(boa, "hdr");    if (txn != null) {        txn.serialize(boa, "txn");    }    return baos.toByteArray();}
f9ed584ebe4b4e0e3fb5fc6ecdf37da9690a87ea9efe6542c7cc4b1021fb5f1a
writeTxnBytes
public static void writeTxnBytes(OutputArchive oa, byte[] bytes) throws IOException
{    oa.writeBuffer(bytes, "txnEntry");        oa.writeByte((byte) 0x42, "EOR");}
6839c12feb29f4c058a4da429666bc9c963be53674393df89ab6de5e2d15ad6b
compare
public int compare(File o1, File o2)
{    long z1 = Util.getZxidFromName(o1.getName(), prefix);    long z2 = Util.getZxidFromName(o2.getName(), prefix);    int result = z1 < z2 ? -1 : (z1 > z2 ? 1 : 0);    return ascending ? result : -result;}
fc877ed19db0c951e074a0aa63a5a419455f1fbc41cb521341adf36ce91058cd
sortDataDir
public static List<File> sortDataDir(File[] files, String prefix, boolean ascending)
{    if (files == null) {        return new ArrayList<File>(0);    }    List<File> filelist = Arrays.asList(files);    Collections.sort(filelist, new DataDirFileComparator(prefix, ascending));    return filelist;}
7ad726dc10ee8e14b76a1908f8b176978b06e72fd91eaa1aac227f4c0480e458
isLogFileName
public static boolean isLogFileName(String fileName)
{    return fileName.startsWith(FileTxnLog.LOG_FILE_PREFIX + ".");}
500e4c0387bcaa924ee0e651dd539f16c5886d8bbef3231ecbaeb0f35c5368a7
isSnapshotFileName
public static boolean isSnapshotFileName(String fileName)
{    return fileName.startsWith(FileSnap.SNAPSHOT_FILE_PREFIX + ".");}
3e5a90ddff97192f324c1f3b8233c85f2b843c6c170307018f27ebb00f821178
setFailCreate
public static void setFailCreate(boolean b)
{    failCreate = b;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (true) {            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());            Request request = submittedRequests.take();            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'P', request, "");            }            if (Request.requestOfDeath == request) {                break;            }            request.prepStartTime = Time.currentElapsedTime();            pRequest(request);        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {            LOG.info(e.getCause().getMessage());        }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    LOG.info("PrepRequestProcessor exited loop!");}
6de37592ca2b7d542c891a794c6bc0b16f0ba123bc46ead95280be3ea8bc500b
getRecordForPath
private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException
{    ChangeRecord lastChange = null;    synchronized (zks.outstandingChanges) {        lastChange = zks.outstandingChangesForPath.get(path);        if (lastChange == null) {            DataNode n = zks.getZKDatabase().getNode(path);            if (n != null) {                Set<String> children;                synchronized (n) {                    children = n.getChildren();                }                lastChange = new ChangeRecord(-1, path, n.stat, children.size(), zks.getZKDatabase().aclForNode(n));            }        }    }    if (lastChange == null || lastChange.stat == null) {        throw new KeeperException.NoNodeException(path);    }    return lastChange;}
4896635a0aba5ff693c0add00858db3ccc9d19d313607b2d171f5691cbab97fd
getOutstandingChange
private ChangeRecord getOutstandingChange(String path)
{    synchronized (zks.outstandingChanges) {        return zks.outstandingChangesForPath.get(path);    }}
24117721d066d562a935d9c74c58b5e93fd964dec02b6c4b9fc74e04fd16aedd
addChangeRecord
protected void addChangeRecord(ChangeRecord c)
{    synchronized (zks.outstandingChanges) {        zks.outstandingChanges.add(c);        zks.outstandingChangesForPath.put(c.path, c);        ServerMetrics.getMetrics().OUTSTANDING_CHANGES_QUEUED.add(1);    }}
a327819a1af5f53d41138e4b95a871512a9e0093ac907046c58e28ec308a0c15
getPendingChanges
private Map<String, ChangeRecord> getPendingChanges(MultiOperationRecord multiRequest)
{    Map<String, ChangeRecord> pendingChangeRecords = new HashMap<String, ChangeRecord>();    for (Op op : multiRequest) {        String path = op.getPath();        ChangeRecord cr = getOutstandingChange(path);                if (cr != null) {            pendingChangeRecords.put(path, cr);        }        /*             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord             * of the parent node of a request. So that if this is a             * sequential node creation request, rollbackPendingChanges()             * can restore previous parent's ChangeRecord correctly.             *             * Otherwise, sequential node name generation will be incorrect             * for a subsequent request.             */        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1 || path.indexOf('\0') != -1) {            continue;        }        String parentPath = path.substring(0, lastSlash);        ChangeRecord parentCr = getOutstandingChange(parentPath);        if (parentCr != null) {            pendingChangeRecords.put(parentPath, parentCr);        }    }    return pendingChangeRecords;}
89850b2c06625db2e3fdfcd4c862ca4323344696cec67a0ce27475d1a2a8a2b3
rollbackPendingChanges
 void rollbackPendingChanges(long zxid, Map<String, ChangeRecord> pendingChangeRecords)
{    synchronized (zks.outstandingChanges) {                Iterator<ChangeRecord> iter = zks.outstandingChanges.descendingIterator();        while (iter.hasNext()) {            ChangeRecord c = iter.next();            if (c.zxid == zxid) {                iter.remove();                                                zks.outstandingChangesForPath.remove(c.path);            } else {                break;            }        }                if (zks.outstandingChanges.isEmpty()) {            return;        }        long firstZxid = zks.outstandingChanges.peek().zxid;        for (ChangeRecord c : pendingChangeRecords.values()) {                        if (c.zxid < firstZxid) {                continue;            }                        zks.outstandingChangesForPath.put(c.path, c);        }    }}
927c7d45de46a196a482f4c2839ade658d841cb5ddf1fcdcb72a35312c3e4e53
validatePathForCreate
private String validatePathForCreate(String path, long sessionId) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {        LOG.info("Invalid path %s with session 0x%s", path, Long.toHexString(sessionId));        throw new KeeperException.BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
4d082b3279627b07bcfd95a6d2aa2e75f9a6dc2e0ec41beed49932fea140f7fe
pRequest2Txn
protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
{    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));    switch(type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:            {                pRequest2TxnCreate(type, request, record, deserialize);                break;            }        case OpCode.deleteContainer:            {                String path = new String(request.request.array());                String parentPath = getParentPathAndValidate(path);                ChangeRecord nodeRecord = getRecordForPath(path);                if (nodeRecord.childCount > 0) {                    throw new KeeperException.NotEmptyException(path);                }                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {                    throw new KeeperException.BadVersionException(path);                }                ChangeRecord parentRecord = getRecordForPath(parentPath);                request.setTxn(new DeleteTxn(path));                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());                parentRecord.childCount--;                addChangeRecord(parentRecord);                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));                break;            }        case OpCode.delete:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            DeleteRequest deleteRequest = (DeleteRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);            }            String path = deleteRequest.getPath();            String parentPath = getParentPathAndValidate(path);            ChangeRecord parentRecord = getRecordForPath(parentPath);            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);            ChangeRecord nodeRecord = getRecordForPath(path);            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);            if (nodeRecord.childCount > 0) {                throw new KeeperException.NotEmptyException(path);            }            request.setTxn(new DeleteTxn(path));            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());            parentRecord.childCount--;            addChangeRecord(parentRecord);            addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));            break;        case OpCode.setData:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetDataRequest setDataRequest = (SetDataRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);            }            path = setDataRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.reconfig:            if (!QuorumPeerConfig.isReconfigEnabled()) {                LOG.error("Reconfig operation requested but reconfig feature is disabled.");                throw new KeeperException.ReconfigDisabledException();            }            if (ZooKeeperServer.skipACL) {                LOG.warn("skipACL is set, reconfig operation will skip ACL checks!");            }            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            LeaderZooKeeperServer lzks;            try {                lzks = (LeaderZooKeeperServer) zks;            } catch (ClassCastException e) {                                throw new KeeperException.UnimplementedException();            }            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                        if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {                throw new KeeperException.ReconfigInProgress();            }            ReconfigRequest reconfigRequest = (ReconfigRequest) record;            long configId = reconfigRequest.getCurConfigId();            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {                String msg = "Reconfiguration from version " + configId + " failed -- last seen version is " + lzks.self.getLastSeenQuorumVerifier().getVersion();                throw new KeeperException.BadVersionException(msg);            }            String newMembers = reconfigRequest.getNewMembers();            if (newMembers != null) {                                LOG.info("Non-incremental reconfig");                                newMembers = newMembers.replaceAll(",", "\n");                try {                    Properties props = new Properties();                    props.load(new StringReader(newMembers));                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);                    request.qv.setVersion(request.getHdr().getZxid());                } catch (IOException | ConfigException e) {                    throw new KeeperException.BadArgumentsException(e.getMessage());                }            } else {                                LOG.info("Incremental reconfig");                List<String> joiningServers = null;                String joiningServersString = reconfigRequest.getJoiningServers();                if (joiningServersString != null) {                    joiningServers = StringUtils.split(joiningServersString, ",");                }                List<String> leavingServers = null;                String leavingServersString = reconfigRequest.getLeavingServers();                if (leavingServersString != null) {                    leavingServers = StringUtils.split(leavingServersString, ",");                }                if (!(lastSeenQV instanceof QuorumMaj)) {                    String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";                    LOG.warn(msg);                    throw new KeeperException.BadArgumentsException(msg);                }                Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());                try {                    if (leavingServers != null) {                        for (String leaving : leavingServers) {                            long sid = Long.parseLong(leaving);                            nextServers.remove(sid);                        }                    }                    if (joiningServers != null) {                        for (String joiner : joiningServers) {                                                        String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);                            if (parts.length != 2) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string");                            }                                                        Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));                            QuorumServer qs = new QuorumServer(sid, parts[1]);                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified");                            }                                                        for (QuorumServer nqs : nextServers.values()) {                                if (qs.id == nqs.id) {                                    continue;                                }                                qs.checkAddressDuplicate(nqs);                            }                            nextServers.remove(qs.id);                            nextServers.put(qs.id, qs);                        }                    }                } catch (ConfigException e) {                    throw new KeeperException.BadArgumentsException("Reconfiguration failed");                }                request.qv = new QuorumMaj(nextServers);                request.qv.setVersion(request.getHdr().getZxid());            }            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {                String msg = "Reconfig failed - new configuration must include at least 2 followers";                LOG.warn(msg);                throw new KeeperException.BadArgumentsException(msg);            } else if (request.qv.getVotingMembers().size() < 1) {                String msg = "Reconfig failed - new configuration must include at least 1 follower";                LOG.warn(msg);                throw new KeeperException.BadArgumentsException(msg);            }            if (!lzks.getLeader().isQuorumSynced(request.qv)) {                String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";                LOG.warn(msg2);                throw new KeeperException.NewConfigNoQuorum();            }            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);            request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(-1);            addChangeRecord(nodeRecord);            break;        case OpCode.setACL:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetACLRequest setAclRequest = (SetACLRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);            }            path = setAclRequest.getPath();            validatePath(path, request.sessionId);            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);            request.setTxn(new SetACLTxn(path, listACL, newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setAversion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.createSession:            request.request.rewind();            int to = request.request.getInt();            request.setTxn(new CreateSessionTxn(to));            request.request.rewind();                        zks.sessionTracker.trackSession(request.sessionId, to);            zks.setOwner(request.sessionId, request.getOwner());            break;        case OpCode.closeSession:                                                            long startTime = Time.currentElapsedTime();            synchronized (zks.outstandingChanges) {                                                                                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);                for (ChangeRecord c : zks.outstandingChanges) {                    if (c.stat == null) {                                                es.remove(c.path);                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {                        es.add(c.path);                    }                }                for (String path2Delete : es) {                    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));                }                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));                }                zks.sessionTracker.setSessionClosing(request.sessionId);            }            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);            break;        case OpCode.check:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);            }            path = checkVersionRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);            request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));            break;        default:            LOG.warn("unknown type " + type);            break;    }}
7e9f50c2214386d1912eb1248ae49310e3e46d290455b06023e02753f22c113f
pRequest2TxnCreate
private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException
{    if (deserialize) {        ByteBufferInputStream.byteBuffer2Record(request.request, record);    }    int flags;    String path;    List<ACL> acl;    byte[] data;    long ttl;    if (type == OpCode.createTTL) {        CreateTTLRequest createTtlRequest = (CreateTTLRequest) record;        flags = createTtlRequest.getFlags();        path = createTtlRequest.getPath();        acl = createTtlRequest.getAcl();        data = createTtlRequest.getData();        ttl = createTtlRequest.getTtl();    } else {        CreateRequest createRequest = (CreateRequest) record;        flags = createRequest.getFlags();        path = createRequest.getPath();        acl = createRequest.getAcl();        data = createRequest.getData();        ttl = -1;    }    CreateMode createMode = CreateMode.fromFlag(flags);    validateCreateRequest(path, createMode, request, ttl);    String parentPath = validatePathForCreate(path, request.sessionId);    List<ACL> listACL = fixupACL(path, request.authInfo, acl);    ChangeRecord parentRecord = getRecordForPath(parentPath);    zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);    int parentCVersion = parentRecord.stat.getCversion();    if (createMode.isSequential()) {        path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);    }    validatePath(path, request.sessionId);    try {        if (getRecordForPath(path) != null) {            throw new KeeperException.NodeExistsException(path);        }    } catch (KeeperException.NoNodeException e) {        }    boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;    if (ephemeralParent) {        throw new KeeperException.NoChildrenForEphemeralsException(path);    }    int newCversion = parentRecord.stat.getCversion() + 1;    if (type == OpCode.createContainer) {        request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));    } else if (type == OpCode.createTTL) {        request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));    } else {        request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(), newCversion));    }    StatPersisted s = new StatPersisted();    if (createMode.isEphemeral()) {        s.setEphemeralOwner(request.sessionId);    }    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());    parentRecord.childCount++;    parentRecord.stat.setCversion(newCversion);    addChangeRecord(parentRecord);    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));}
300d05cdd3a47a97ee96bd18dfbdc1933bda422a3662a9232937e209ce5cf2b3
validatePath
private void validatePath(String path, long sessionId) throws BadArgumentsException
{    try {        PathUtils.validatePath(path);    } catch (IllegalArgumentException ie) {        LOG.info("Invalid path {} with session 0x{}, reason: {}", path, Long.toHexString(sessionId), ie.getMessage());        throw new BadArgumentsException(path);    }}
e7a0da47cda09462f0c72d0b681acb8bdfc03303108020842ed2df87d0da3c56
getParentPathAndValidate
private String getParentPathAndValidate(String path) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || zks.getZKDatabase().isSpecialPath(path)) {        throw new BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
46691a70c080a1ebae91429056b4395028c188c3e53c3071eff8d5315b157844
checkAndIncVersion
private static int checkAndIncVersion(int currentVersion, int expectedVersion, String path) throws KeeperException.BadVersionException
{    if (expectedVersion != -1 && expectedVersion != currentVersion) {        throw new KeeperException.BadVersionException(path);    }    return currentVersion + 1;}
762e31dafa1e930d00aebf3a62ab329278c4aea280ead326f65623461273196b
pRequest
protected void pRequest(Request request) throws RequestProcessorException
{            request.setHdr(null);    request.setTxn(null);    try {        switch(request.type) {            case OpCode.createContainer:            case OpCode.create:            case OpCode.create2:                CreateRequest create2Request = new CreateRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);                break;            case OpCode.createTTL:                CreateTTLRequest createTtlRequest = new CreateTTLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, true);                break;            case OpCode.deleteContainer:            case OpCode.delete:                DeleteRequest deleteRequest = new DeleteRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);                break;            case OpCode.setData:                SetDataRequest setDataRequest = new SetDataRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);                break;            case OpCode.reconfig:                ReconfigRequest reconfigRequest = new ReconfigRequest();                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);                break;            case OpCode.setACL:                SetACLRequest setAclRequest = new SetACLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);                break;            case OpCode.check:                CheckVersionRequest checkRequest = new CheckVersionRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);                break;            case OpCode.multi:                MultiOperationRecord multiRequest = new MultiOperationRecord();                try {                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);                } catch (IOException e) {                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));                    throw e;                }                List<Txn> txns = new ArrayList<Txn>();                                long zxid = zks.getNextZxid();                KeeperException ke = null;                                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);                for (Op op : multiRequest) {                    Record subrequest = op.toRequestRecord();                    int type;                    Record txn;                    /* If we've already failed one of the ops, don't bother                     * trying the rest as we know it's going to fail and it                     * would be confusing in the logfiles.                     */                    if (ke != null) {                        type = OpCode.error;                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());                    } else {                        /* Prep the request and convert to a Txn */                        try {                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);                            type = request.getHdr().getType();                            txn = request.getTxn();                        } catch (KeeperException e) {                            ke = e;                            type = OpCode.error;                            txn = new ErrorTxn(e.code().intValue());                            if (e.code().intValue() > Code.APIERROR.intValue()) {                                LOG.info("Got user-level KeeperException when processing {} aborting" + " remaining multi ops. Error Path:{} Error:{}", request.toString(), e.getPath(), e.getMessage());                            }                            request.setException(e);                            /* Rollback change records from failed multi-op */                            rollbackPendingChanges(zxid, pendingChanges);                        }                    }                                        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                        txn.serialize(boa, "request");                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());                        txns.add(new Txn(type, bb.array()));                    }                }                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));                request.setTxn(new MultiTxn(txns));                break;                        case OpCode.createSession:            case OpCode.closeSession:                if (!request.isLocalSession()) {                    pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);                }                break;                        case OpCode.sync:            case OpCode.exists:            case OpCode.getData:            case OpCode.getACL:            case OpCode.getChildren:            case OpCode.getAllChildrenNumber:            case OpCode.getChildren2:            case OpCode.ping:            case OpCode.setWatches:            case OpCode.checkWatches:            case OpCode.removeWatches:            case OpCode.getEphemerals:            case OpCode.multiRead:                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());                break;            default:                LOG.warn("unknown type " + request.type);                break;        }    } catch (KeeperException e) {        if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(e.code().intValue()));        }        if (e.code().intValue() > Code.APIERROR.intValue()) {            LOG.info("Got user-level KeeperException when processing {} Error Path:{} Error:{}", request.toString(), e.getPath(), e.getMessage());        }        request.setException(e);    } catch (Exception e) {                        LOG.error("Failed to process " + request, e);        StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        if (bb != null) {            bb.rewind();            while (bb.hasRemaining()) {                sb.append(Integer.toHexString(bb.get() & 0xff));            }        } else {            sb.append("request buffer is null");        }        LOG.error("Dumping request buffer: 0x" + sb.toString());        if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));        }    }    request.zxid = zks.getZxid();    ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(Time.currentElapsedTime() - request.prepStartTime);    nextProcessor.processRequest(request);}
02a3dbd47c417f9e9c0f0e2375819c6dcd13535cc0e715da8a76feafdb098d70
removeDuplicates
private static List<ACL> removeDuplicates(final List<ACL> acls)
{    if (acls == null || acls.isEmpty()) {        return Collections.emptyList();    }            final ArrayList<ACL> retval = new ArrayList<>(acls.size());    for (final ACL acl : acls) {        if (!retval.contains(acl)) {            retval.add(acl);        }    }    return retval;}
89174046325b014b07e8e9acf9f894d5e3f5416d96bf11784ac14f9d289e0270
validateCreateRequest
private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl) throws KeeperException
{    if (createMode.isTTL() && !EphemeralType.extendedEphemeralTypesEnabled()) {        throw new KeeperException.UnimplementedException();    }    try {        EphemeralType.validateTTL(createMode, ttl);    } catch (IllegalArgumentException e) {        throw new BadArgumentsException(path);    }    if (createMode.isEphemeral()) {                if (request.getException() != null) {            throw request.getException();        }        zks.sessionTracker.checkGlobalSession(request.sessionId, request.getOwner());    } else {        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());    }}
89d06499cd4d9165e2b69ddb284dbfab0f49b4429e35d173c6ce34eb6d6074cf
fixupACL
public static List<ACL> fixupACL(String path, List<Id> authInfo, List<ACL> acls) throws KeeperException.InvalidACLException
{            List<ACL> uniqacls = removeDuplicates(acls);    if (uniqacls == null || uniqacls.size() == 0) {        throw new KeeperException.InvalidACLException(path);    }    List<ACL> rv = new ArrayList<>();    for (ACL a : uniqacls) {        LOG.debug("Processing ACL: {}", a);        if (a == null) {            throw new KeeperException.InvalidACLException(path);        }        Id id = a.getId();        if (id == null || id.getScheme() == null) {            throw new KeeperException.InvalidACLException(path);        }        if (id.getScheme().equals("world") && id.getId().equals("anyone")) {            rv.add(a);        } else if (id.getScheme().equals("auth")) {                                    boolean authIdValid = false;            for (Id cid : authInfo) {                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());                if (ap == null) {                    LOG.error("Missing AuthenticationProvider for " + cid.getScheme());                } else if (ap.isAuthenticated()) {                    authIdValid = true;                    rv.add(new ACL(a.getPerms(), cid));                }            }            if (!authIdValid) {                throw new KeeperException.InvalidACLException(path);            }        } else {            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap == null || !ap.isValid(id.getId())) {                throw new KeeperException.InvalidACLException(path);            }            rv.add(a);        }    }    return rv;}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    request.prepQueueStartTime = Time.currentElapsedTime();    submittedRequests.add(request);    ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUED.add(1);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    submittedRequests.clear();    submittedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
8e29584f151dc80a8ba21f7b5b273050efae239cf9263a6e82a701b3dd60529b
printUsage
 static void printUsage()
{    System.out.println("Usage:");    System.out.println("PurgeTxnLog dataLogDir [snapDir] -n count");    System.out.println("\tdataLogDir -- path to the txn log directory");    System.out.println("\tsnapDir -- path to the snapshot directory");    System.out.println("\tcount -- the number of old snaps/logs you want " + "to keep, value should be greater than or equal to 3");}
a515681043d246504951f5d2c31196b7e63fc72f9039dc17ea5215e687d04325
purge
public static void purge(File dataDir, File snapDir, int num) throws IOException
{    if (num < 3) {        throw new IllegalArgumentException(COUNT_ERR_MSG);    }    FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);    List<File> snaps = txnLog.findNRecentSnapshots(num);    int numSnaps = snaps.size();    if (numSnaps > 0) {        purgeOlderSnapshots(txnLog, snaps.get(numSnaps - 1));    }}
1b6161ca737926eddfda49f03cd17b08dc3c72fb0be35a3d46eeea5e04eea55e
purgeOlderSnapshots
 static void purgeOlderSnapshots(FileTxnSnapLog txnLog, File snapShot)
{    final long leastZxidToBeRetain = Util.getZxidFromName(snapShot.getName(), PREFIX_SNAPSHOT);    /**     * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.     * This rule applies to both snapshot files as well as log files, with the following     * exception for log files.     *     * A log file with zxid less than X may contain transactions with zxid larger than X.  More     * precisely, a log file named log.(X-a) may contain transactions newer than snapshot.X if     * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the     * latter condition is true, log.(X-a) must be retained to ensure that snapshot.X is     * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer     * snapshot files if these newer snapshots were not accompanied by log rollover (possible in     * the learner state machine at the time of this writing).  We can make more precise     * determination of whether log.(leastZxidToBeRetain-a) for the smallest 'a' is actually     * needed or not (e.g. not needed if there's a log file named log.(leastZxidToBeRetain+1)),     * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and     * simple to just preserve log.(leastZxidToBeRetain-a) for the smallest 'a' to ensure     * recoverability of all snapshots being retained.  We determine that log file here by     * calling txnLog.getSnapshotLogs().     */    final Set<File> retainedTxnLogs = new HashSet<File>();    retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));    /**     * Finds all candidates for deletion, which are files with a zxid in their name that is less     * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.     */    class MyFileFilter implements FileFilter {        private final String prefix;        MyFileFilter(String prefix) {            this.prefix = prefix;        }        public boolean accept(File f) {            if (!f.getName().startsWith(prefix + ".")) {                return false;            }            if (retainedTxnLogs.contains(f)) {                return false;            }            long fZxid = Util.getZxidFromName(f.getName(), prefix);            return fZxid < leastZxidToBeRetain;        }    }        File[] logs = txnLog.getDataDir().listFiles(new MyFileFilter(PREFIX_LOG));    List<File> files = new ArrayList<>();    if (logs != null) {        files.addAll(Arrays.asList(logs));    }        File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));    if (snapshots != null) {        files.addAll(Arrays.asList(snapshots));    }        for (File f : files) {        final String msg = "Removing file: " + DateFormat.getDateTimeInstance().format(f.lastModified()) + "\t" + f.getPath();        LOG.info(msg);        System.out.println(msg);        if (!f.delete()) {            System.err.println("Failed to remove " + f.getPath());        }    }}
3ddf4adf2e073ddb34da50750ea2111be644970e4e68cdd43b1513e259bba38b
accept
public boolean accept(File f)
{    if (!f.getName().startsWith(prefix + ".")) {        return false;    }    if (retainedTxnLogs.contains(f)) {        return false;    }    long fZxid = Util.getZxidFromName(f.getName(), prefix);    return fZxid < leastZxidToBeRetain;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length < 3 || args.length > 4) {        printUsageThenExit();    }    File dataDir = validateAndGetFile(args[0]);    File snapDir = dataDir;    int num = -1;    String countOption = "";    if (args.length == 3) {        countOption = args[1];        num = validateAndGetCount(args[2]);    } else {        snapDir = validateAndGetFile(args[1]);        countOption = args[2];        num = validateAndGetCount(args[3]);    }    if (!"-n".equals(countOption)) {        printUsageThenExit();    }    purge(dataDir, snapDir, num);}
d46fd9e30e38ee6bbc8dad8e53146adaf69ad3627030557fb78c1581813fccb1
validateAndGetFile
private static File validateAndGetFile(String path)
{    File file = new File(path);    if (!file.exists()) {        System.err.println("Path '" + file.getAbsolutePath() + "' does not exist. ");        printUsageThenExit();    }    return file;}
28bd67e77c9ac61473f14f5b55cf03eed493a618efe5207c93eb87b1b75f1d05
validateAndGetCount
private static int validateAndGetCount(String number)
{    int result = 0;    try {        result = Integer.parseInt(number);        if (result < 3) {            System.err.println(COUNT_ERR_MSG);            printUsageThenExit();        }    } catch (NumberFormatException e) {        System.err.println("'" + number + "' can not be parsed to integer.");        printUsageThenExit();    }    return result;}
ffd2ae4655b404534e96c8b1a5a63f1198892239b9f1c3b617f6e52b385f3023
printUsageThenExit
private static void printUsageThenExit()
{    printUsage();    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    QuorumPeer self = leader.self;    if (self != null) {        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);        leader.processAck(self.getId(), request.zxid, null);    } else {        LOG.error("Null QuorumPeer");    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
e649d464af9837921e2d0a3c0249618e0cb2884b0ea9617e987bf7b8ce2fb134
authenticate
public void authenticate(Socket sock, String hostname)
{        return;}
be363f416476590ca841154c5eb1dc4c7f2f80062c82592e5b1fb0d2ce51332c
authenticate
public void authenticate(final Socket sock, final DataInputStream din)
{}
716f90bc0b92043f906b876cfd149d0b31ca0aea4a7cef5e3080d8684cf031a9
getStatus
 static Status getStatus(int status)
{    switch(status) {        case 0:            return IN_PROGRESS;        case 1:            return SUCCESS;        case -1:            return ERROR;        default:            LOG.error("Unknown status:{}!", status);            assert false : "Unknown status!";            return ERROR;    }}
ccdea0ce1b07a4ba5f4fb11195399584a6b03bcd6d4dcc835d8538955230a37a
status
 int status()
{    return status;}
06d1be3bb340b940c7b401138d1edc8723cfb3e796c893d79c5ed2c5b98bfa48
createPacket
public static QuorumAuthPacket createPacket(Status status, byte[] response)
{    return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER, status.status(), response);}
1adbbbca6e49ddd8ab5cc32cc1dfd2a4a164b4acfe5cdc8843b960c30d910292
nextPacketIsAuth
public static boolean nextPacketIsAuth(DataInputStream din) throws IOException
{    din.mark(32);    BinaryInputArchive bia = new BinaryInputArchive(din);    boolean firstIsAuth = (bia.readLong("NO_TAG") == QuorumAuth.QUORUM_AUTH_MAGIC_NUMBER);    din.reset();    return firstIsAuth;}
8420bd4e13e98f145a9b3c8e0c5684868994f6b9f07dd215ed45d97763314976
authenticate
public void authenticate(Socket sock, String hostName) throws IOException
{    if (!quorumRequireSasl) {                LOG.info("Skipping SASL authentication as {}={}", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, quorumRequireSasl);        return;    }    SaslClient sc = null;    String principalConfig = SecurityUtils.getServerPrincipal(quorumServicePrincipal, hostName);    try {        DataOutputStream dout = new DataOutputStream(sock.getOutputStream());        DataInputStream din = new DataInputStream(sock.getInputStream());        byte[] responseToken = new byte[0];        sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(), principalConfig, QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, "QuorumLearner");        if (sc.hasInitialResponse()) {            responseToken = createSaslToken(new byte[0], sc, learnerLogin);        }        send(dout, responseToken);        QuorumAuthPacket authPacket = receive(din);        QuorumAuth.Status qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());        while (!sc.isComplete()) {            switch(qpStatus) {                case SUCCESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                                        if (responseToken != null) {                        throw new SaslException("Protocol error: attempting to send response after completion");                    }                    break;                case IN_PROGRESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                    send(dout, responseToken);                    authPacket = receive(din);                    qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());                    break;                case ERROR:                    throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());                default:                    LOG.warn("Unknown status:{}!", qpStatus);                    throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());            }        }                checkAuthStatus(sock, qpStatus);    } finally {        if (sc != null) {            try {                sc.dispose();            } catch (SaslException e) {                LOG.error("SaslClient dispose() failed", e);            }        }    }}
b41d5548f839f9fa041f52500a90250f6803bbbb111a7dc553bc66b00948a461
checkAuthStatus
private void checkAuthStatus(Socket sock, QuorumAuth.Status qpStatus) throws SaslException
{    if (qpStatus == QuorumAuth.Status.SUCCESS) {        LOG.info("Successfully completed the authentication using SASL. server addr: {}, status: {}", sock.getRemoteSocketAddress(), qpStatus);    } else {        throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress() + ", qpStatus: " + qpStatus);    }}
b3ca9cb52e557ae25770c1c2310cfd3183b4e65216384d0e8e07178371fb8e3f
receive
private QuorumAuthPacket receive(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket;}
aa87a9363ede5961e41482947039d14b1f349b9902927b59a2a92ae4457779ba
send
private void send(DataOutputStream dout, byte[] response) throws IOException
{    QuorumAuthPacket authPacket;    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, response);    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
8e2ae6cc3e27163a6a37bbf3a904c2c3e2a7df2b3265334471fab6c5a363b1d1
createSaslToken
private byte[] createSaslToken(final byte[] saslToken, final SaslClient saslClient, final Login login) throws SaslException
{    if (saslToken == null) {        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    if (login.getSubject() != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                        LOG.debug("saslClient.evaluateChallenge(len={})", saslToken.length);                        return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's received SASL token.";                                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.";                }                LOG.error(error);                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
cabddfad6ece7010bf35d8db56919a4a2dbdc3c06f3a9f412066a5c204984361
run
public byte[] run() throws SaslException
{    LOG.debug("saslClient.evaluateChallenge(len={})", saslToken.length);    return saslClient.evaluateChallenge(saslToken);}
300cea32426f083831c71dc1e26958bde8c1cbbeea6e23c3a5dd877f813716c1
authenticate
public void authenticate(Socket sock, DataInputStream din) throws SaslException
{    DataOutputStream dout = null;    SaslServer ss = null;    try {        if (!QuorumAuth.nextPacketIsAuth(din)) {            if (quorumRequireSasl) {                throw new SaslException("Learner not trying to authenticate" + " and authentication is required");            } else {                                return;            }        }        byte[] token = receive(din);        int tries = 0;        dout = new DataOutputStream(sock.getOutputStream());        byte[] challenge = null;        ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);        while (!ss.isComplete()) {            challenge = ss.evaluateResponse(token);            if (!ss.isComplete()) {                                if (++tries > MAX_RETRIES) {                    send(dout, challenge, QuorumAuth.Status.ERROR);                    LOG.warn("Failed to authenticate using SASL, server addr: {}, retries={} exceeded.", sock.getRemoteSocketAddress(), tries);                    break;                }                send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);                token = receive(din);            }        }                if (ss.isComplete()) {            send(dout, challenge, QuorumAuth.Status.SUCCESS);            LOG.info("Successfully completed the authentication using SASL. learner addr: {}", sock.getRemoteSocketAddress());        }    } catch (Exception e) {        try {            if (dout != null) {                                send(dout, new byte[0], QuorumAuth.Status.ERROR);            }        } catch (IOException ioe) {            LOG.warn("Exception while sending failed status", ioe);        }                if (quorumRequireSasl) {            LOG.error("Failed to authenticate using SASL", e);            throw new SaslException("Failed to authenticate using SASL: " + e.getMessage());        } else {            LOG.warn("Failed to authenticate using SASL", e);            LOG.warn("Maintaining learner connection despite SASL authentication failure. server addr: {}, {}: {}", sock.getRemoteSocketAddress(), QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, quorumRequireSasl);                }    } finally {        if (ss != null) {            try {                ss.dispose();            } catch (SaslException e) {                LOG.error("SaslServer dispose() failed", e);            }        }    }}
3cf40ff86f3641dcd2b6c5388329d71d44b55805bacc50adb5ce032616f50509
receive
private byte[] receive(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket.getToken();}
6ffa43d4d786042b8623c233212784debf211076dbb00a6c42feb79e0782d93a
send
private void send(DataOutputStream dout, byte[] challenge, QuorumAuth.Status s) throws IOException
{    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    QuorumAuthPacket authPacket;    if (challenge == null && s != QuorumAuth.Status.SUCCESS) {        authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, null);    } else {        authPacket = QuorumAuth.createPacket(s, challenge);    }    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
8be71802c20b7ee5c040cc24d804a9489d017c8b3eb3befc80a0d01ae9d378d1
handle
public void handle(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
e3c32887d8e9e77de703fa38dcd0034e0d3c4653c3107640130821891f416869
handleNameCallback
private void handleNameCallback(NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {        LOG.warn("User '{}' not found in list of DIGEST-MD5 authenticateable users.", nc.getDefaultName());        return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
eeb9d8bb3bcbfe422eb274231ebf9272fb45c076ae257e861781a5bfcd25d7c6
handlePasswordCallback
private void handlePasswordCallback(PasswordCallback pc)
{    if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {        LOG.warn("No password found for user: {}", userName);    }}
8abe0d98e762db40c9ddbc752a0f01b0d1f9a7dde5a212fb998d06950eb7776c
handleRealmCallback
private void handleRealmCallback(RealmCallback rc)
{    LOG.debug("QuorumLearner supplied realm: {}", rc.getDefaultText());    rc.setText(rc.getDefaultText());}
e81e1fa5ccef4d53e3b963ffe2d61d9a9d8968dd94b5332455b583e935b27760
handleAuthorizeCallback
private void handleAuthorizeCallback(AuthorizeCallback ac)
{    String authenticationID = ac.getAuthenticationID();    String authorizationID = ac.getAuthorizationID();    boolean authzFlag = false;        authzFlag = authenticationID.equals(authorizationID);        if (authzFlag) {        String[] components = authorizationID.split("[/@]");        if (components.length == 3) {            authzFlag = authzHosts.contains(components[1]);        }        if (!authzFlag) {            LOG.error("SASL authorization completed, {} is not authorized to connect", components[1]);        }    }        ac.setAuthorized(authzFlag);    if (ac.isAuthorized()) {        ac.setAuthorizedID(authorizationID);        LOG.info("Successfully authenticated learner: authenticationID={};  authorizationID={}.", authenticationID, authorizationID);    }    LOG.debug("SASL authorization completed, authorized flag set to {}", ac.isAuthorized());}
808bc514ba2d02416998b2230f9ec3b6a81afb2940787f0215eec9cc594feba5
saveChallenge
 boolean saveChallenge(long tag, long challenge)
{    Semaphore s = challengeMutex.get(tag);    if (s != null) {        synchronized (Messenger.this) {            challengeMap.put(tag, challenge);            challengeMutex.remove(tag);        }        s.release();    } else {        LOG.error("No challenge mutex object");    }    return true;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    byte[] responseBytes = new byte[48];    ByteBuffer responseBuffer = ByteBuffer.wrap(responseBytes);    DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length);    while (true) {                try {            responseBuffer.clear();            mySocket.receive(responsePacket);        } catch (IOException e) {            LOG.warn("Ignoring exception receiving", e);        }                if (responsePacket.getLength() != responseBytes.length) {            LOG.warn("Got a short response: " + responsePacket.getLength() + " " + responsePacket.toString());            continue;        }        responseBuffer.clear();        int type = responseBuffer.getInt();        if ((type > 3) || (type < 0)) {            LOG.warn("Got bad Msg type: " + type);            continue;        }        long tag = responseBuffer.getLong();        QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;        switch(responseBuffer.getInt()) {            case 0:                ackstate = QuorumPeer.ServerState.LOOKING;                break;            case 1:                ackstate = QuorumPeer.ServerState.LEADING;                break;            case 2:                ackstate = QuorumPeer.ServerState.FOLLOWING;                break;            default:                LOG.warn("unknown type " + responseBuffer.getInt());                break;        }        Vote current = self.getCurrentVote();        switch(type) {            case 0:                                ToSend c = new ToSend(ToSend.mType.challenge, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                sendqueue.offer(c);                break;            case 1:                                long challenge = responseBuffer.getLong();                saveChallenge(tag, challenge);                break;            case 2:                Notification n = new Notification();                n.leader = responseBuffer.getLong();                n.zxid = responseBuffer.getLong();                n.epoch = responseBuffer.getLong();                n.state = ackstate;                n.addr = (InetSocketAddress) responsePacket.getSocketAddress();                if ((myMsg.lastEpoch <= n.epoch) && ((n.zxid > myMsg.lastProposedZxid) || ((n.zxid == myMsg.lastProposedZxid) && (n.leader > myMsg.lastProposedLeader)))) {                    myMsg.lastProposedZxid = n.zxid;                    myMsg.lastProposedLeader = n.leader;                    myMsg.lastEpoch = n.epoch;                }                long recChallenge;                InetSocketAddress addr = (InetSocketAddress) responsePacket.getSocketAddress();                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(addr);                    if (tmpMap != null) {                        if (tmpMap.get(tag) != null) {                            recChallenge = responseBuffer.getLong();                            if (tmpMap.get(tag) == recChallenge) {                                recvqueue.offer(n);                                ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), addr);                                sendqueue.offer(a);                            } else {                                LOG.warn("Incorrect challenge: " + recChallenge + ", " + addrChallengeMap.toString());                            }                        } else {                            LOG.warn("No challenge for host: " + addr + " " + tag);                        }                    }                } else {                    recvqueue.offer(n);                    ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                    sendqueue.offer(a);                }                break;                        case 3:                Semaphore s = ackMutex.get(tag);                if (s != null) {                    s.release();                } else {                    LOG.error("Empty ack semaphore");                }                ackset.add(tag);                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(responsePacket.getSocketAddress());                    if (tmpMap != null) {                        tmpMap.remove(tag);                    } else {                        LOG.warn("No such address in the ensemble configuration " + responsePacket.getSocketAddress());                    }                }                if (ackstate != QuorumPeer.ServerState.LOOKING) {                    Notification outofsync = new Notification();                    outofsync.leader = responseBuffer.getLong();                    outofsync.zxid = responseBuffer.getLong();                    outofsync.epoch = responseBuffer.getLong();                    outofsync.state = ackstate;                    outofsync.addr = (InetSocketAddress) responsePacket.getSocketAddress();                    recvqueue.offer(outofsync);                }                break;                        default:                LOG.warn("Received message of incorrect type " + type);                break;        }    }}
587092dd8a54b7d74e78715e3b7e21ef26f9c36c36a36eb17c60b95d91b9bb76
genChallenge
 long genChallenge()
{    byte[] buf = new byte[8];    buf[0] = (byte) ((challengeCounter & 0xff000000) >>> 24);    buf[1] = (byte) ((challengeCounter & 0x00ff0000) >>> 16);    buf[2] = (byte) ((challengeCounter & 0x0000ff00) >>> 8);    buf[3] = (byte) ((challengeCounter & 0x000000ff));    challengeCounter++;    int secret = rand.nextInt(java.lang.Integer.MAX_VALUE);    buf[4] = (byte) ((secret & 0xff000000) >>> 24);    buf[5] = (byte) ((secret & 0x00ff0000) >>> 16);    buf[6] = (byte) ((secret & 0x0000ff00) >>> 8);    buf[7] = (byte) ((secret & 0x000000ff));    return (((long) (buf[0] & 0xFF)) << 56) + (((long) (buf[1] & 0xFF)) << 48) + (((long) (buf[2] & 0xFF)) << 40) + (((long) (buf[3] & 0xFF)) << 32) + (((long) (buf[4] & 0xFF)) << 24) + (((long) (buf[5] & 0xFF)) << 16) + (((long) (buf[6] & 0xFF)) << 8) + ((long) (buf[7] & 0xFF));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (true) {        try {            ToSend m = sendqueue.take();            process(m);        } catch (InterruptedException e) {            break;        }    }}
2d1e8a249b114056731447d5db24241d88232b4cffb9873ccf96993893595952
process
private void process(ToSend m)
{    int attempts = 0;    byte[] zeroes;    byte[] requestBytes = new byte[48];    DatagramPacket requestPacket = new DatagramPacket(requestBytes, requestBytes.length);    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    switch(m.type) {        case 0:            /*                     * Building challenge request packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(ToSend.mType.crequest.ordinal());            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            zeroes = new byte[32];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                if (challengeMap.get(m.tag) == null) {                    mySocket.send(requestPacket);                }            } catch (IOException e) {                LOG.warn("Exception while sending challenge: ", e);            }            break;        case 1:            /*                     * Building challenge packet to send                     */            long newChallenge;            ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(m.addr);            if (tmpMap != null) {                Long tmpLong = tmpMap.get(m.tag);                if (tmpLong != null) {                    newChallenge = tmpLong;                } else {                    newChallenge = genChallenge();                }                tmpMap.put(m.tag, newChallenge);                requestBuffer.clear();                requestBuffer.putInt(ToSend.mType.challenge.ordinal());                requestBuffer.putLong(m.tag);                requestBuffer.putInt(m.state.ordinal());                requestBuffer.putLong(newChallenge);                zeroes = new byte[24];                requestBuffer.put(zeroes);                requestPacket.setLength(48);                try {                    requestPacket.setSocketAddress(m.addr);                } catch (IllegalArgumentException e) {                                        throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);                }                try {                    mySocket.send(requestPacket);                } catch (IOException e) {                    LOG.warn("Exception while sending challenge: ", e);                }            } else {                LOG.error("Address is not in the configuration: " + m.addr);            }            break;        case 2:            /*                     * Building notification packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            zeroes = new byte[8];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            boolean myChallenge = false;            boolean myAck = false;            while (attempts < maxAttempts) {                try {                    if (!myChallenge && authEnabled) {                        ToSend crequest = new ToSend(ToSend.mType.crequest, m.tag, m.leader, m.zxid, m.epoch, QuorumPeer.ServerState.LOOKING, m.addr);                        sendqueue.offer(crequest);                        try {                            double timeout = ackWait * java.lang.Math.pow(2, attempts);                            Semaphore s = new Semaphore(0);                            synchronized (Messenger.this) {                                challengeMutex.put(m.tag, s);                                s.tryAcquire((long) timeout, TimeUnit.MILLISECONDS);                                myChallenge = challengeMap.containsKey(m.tag);                            }                        } catch (InterruptedException e) {                            LOG.warn("Challenge request exception: ", e);                        }                    }                    if (authEnabled && !myChallenge) {                        attempts++;                        continue;                    }                    if (authEnabled) {                        requestBuffer.position(40);                        Long tmpLong = challengeMap.get(m.tag);                        if (tmpLong != null) {                            requestBuffer.putLong(tmpLong);                        } else {                            LOG.warn("No challenge with tag: " + m.tag);                        }                    }                    mySocket.send(requestPacket);                    try {                        Semaphore s = new Semaphore(0);                        double timeout = ackWait * java.lang.Math.pow(10, attempts);                        ackMutex.put(m.tag, s);                        s.tryAcquire((int) timeout, TimeUnit.MILLISECONDS);                    } catch (InterruptedException e) {                        LOG.warn("Ack exception: ", e);                    }                    if (ackset.remove(m.tag)) {                        myAck = true;                    }                } catch (IOException e) {                    LOG.warn("Sending exception: ", e);                /*                             * Do nothing, just try again                             */                }                if (myAck) {                    /*                             * Received ack successfully, so return                             */                    challengeMap.remove(m.tag);                    return;                } else {                    attempts++;                }            }            /*                     * Return message to queue for another attempt later if                     * epoch hasn't changed.                     */            if (m.epoch == logicalclock.get()) {                challengeMap.remove(m.tag);                sendqueue.offer(m);            }            break;        case 3:            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                mySocket.send(requestPacket);            } catch (IOException e) {                LOG.warn("Exception while sending ack: ", e);            }            break;        default:            LOG.warn("unknown type " + m.type);            break;    }}
aff0587742d08e98525ee493ca013fdc3666b4569da29b58e446a2e7c3b13d96
starter
private void starter(QuorumPeer self)
{    this.self = self;    port = self.getVotingView().get(self.getId()).electionAddr.getPort();    proposedLeader = -1;    proposedZxid = -1;    try {        mySocket = new DatagramSocket(port);        } catch (SocketException e1) {        e1.printStackTrace();        throw new RuntimeException();    }    sendqueue = new LinkedBlockingQueue<ToSend>(2 * self.getVotingView().size());    recvqueue = new LinkedBlockingQueue<Notification>(2 * self.getVotingView().size());    new Messenger(self.getVotingView().size() * 2, mySocket);}
3c1d4d3afe28c383a00df116ebe7e9dba2d08a8655ade1666fd66ac12a348f62
leaveInstance
private void leaveInstance()
{    logicalclock.incrementAndGet();}
8ce03e43b019d8b4b7eb6eed4c2561de700eba6acd4eec660772c13b3215f189
sendNotifications
private void sendNotifications()
{    for (QuorumServer server : self.getView().values()) {        ToSend notmsg = new ToSend(ToSend.mType.notification, AuthFastLeaderElection.sequencer++, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, self.getView().get(server.id).electionAddr);        sendqueue.offer(notmsg);    }}
d7cf2af6b016278a88567db127e06167523e34e43c1988347cc31e4bf39b9778
totalOrderPredicate
private boolean totalOrderPredicate(long id, long zxid)
{    return (zxid > proposedZxid) || ((zxid == proposedZxid) && (id > proposedLeader));}
8f6179796651cacfe3c92dbf7aff334c0c12ba25eede62ee17ca6e0ec3a8f259
termPredicate
private boolean termPredicate(Map<InetSocketAddress, Vote> votes, long l, long zxid)
{    Collection<Vote> votesCast = votes.values();    int count = 0;    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Vote v : votesCast) {        if ((v.getId() == l) && (v.getZxid() == zxid)) {            count++;        }    }    return count > (self.getVotingView().size() / 2);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
2d8d6feccda6139051ddb3e7277c1967d7f0893f924f982c3cbe44fcce2ffed8
lookForLeader
public Vote lookForLeader() throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        self.jmxLeaderElectionBean = null;    }    try {        HashMap<InetSocketAddress, Vote> recvset = new HashMap<InetSocketAddress, Vote>();        HashMap<InetSocketAddress, Vote> outofelection = new HashMap<InetSocketAddress, Vote>();        logicalclock.incrementAndGet();        proposedLeader = self.getId();        proposedZxid = self.getLastLoggedZxid();        LOG.info("Election tally");        sendNotifications();        while (self.getPeerState() == ServerState.LOOKING) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(2 * finalizeWait, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (((!outofelection.isEmpty()) || (recvset.size() > 1))) {                    sendNotifications();                }            } else {                switch(n.state) {                    case LOOKING:                        if (n.epoch > logicalclock.get()) {                            logicalclock.set(n.epoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid)) {                                proposedLeader = n.leader;                                proposedZxid = n.zxid;                            }                            sendNotifications();                        } else if (n.epoch < logicalclock.get()) {                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid)) {                            proposedLeader = n.leader;                            proposedZxid = n.zxid;                            sendNotifications();                        }                        recvset.put(n.addr, new Vote(n.leader, n.zxid));                                                if (self.getVotingView().size() == recvset.size()) {                            self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                                                                                                leaveInstance();                            return new Vote(proposedLeader, proposedZxid);                        } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {                                                        LOG.info("Passed predicate");                            Thread.sleep(finalizeWait);                                                        while ((!recvqueue.isEmpty()) && !totalOrderPredicate(recvqueue.peek().leader, recvqueue.peek().zxid)) {                                recvqueue.poll();                            }                            if (recvqueue.isEmpty()) {                                                                                                self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                leaveInstance();                                return new Vote(proposedLeader, proposedZxid);                            }                        }                        break;                    case LEADING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    case FOLLOWING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    default:                        break;                }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {            LOG.warn("Failed to unregister with JMX", e);        }        self.jmxLeaderElectionBean = null;    }}
2ad0103c07b9163da4fbb37727e04897fa2335d9ccb7fba71c5e92b6469c5840
getLastBufferSize
public synchronized int getLastBufferSize()
{    return lastBufferSize;}
20fbc3bc634821b0d88b08396781098a3a9e9e12d6ed345c053f9bee4c36e6cb
setLastBufferSize
public synchronized void setLastBufferSize(int value)
{    lastBufferSize = value;    if (minBufferSize == INIT_VALUE || value < minBufferSize) {        minBufferSize = value;    }    if (value > maxBufferSize) {        maxBufferSize = value;    }}
a6455e38e8561ce38b68523d786600bf08cc3d1a0fdab25041252eb1e6ec94e8
getMinBufferSize
public synchronized int getMinBufferSize()
{    return minBufferSize;}
506f0a23f3ca8059079fdfd3adf7430b1e3ca15a4ca1b135dcde3753e9f39e75
getMaxBufferSize
public synchronized int getMaxBufferSize()
{    return maxBufferSize;}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    lastBufferSize = INIT_VALUE;    minBufferSize = INIT_VALUE;    maxBufferSize = INIT_VALUE;}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.format("%d/%d/%d", lastBufferSize, minBufferSize, maxBufferSize);}
d467d183dc34467b24437f402b40a8eac2dda3d4da7cff338b63f51d7553a611
isProcessingRequest
private boolean isProcessingRequest()
{    return numRequestsProcessing.get() != 0;}
f5da741bec33fec8add054e4f0663881eb56423e2cc15a0ceddc8ca52b242f70
needCommit
protected boolean needCommit(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setData:        case OpCode.reconfig:        case OpCode.multi:        case OpCode.setACL:        case OpCode.check:            return true;        case OpCode.sync:            return matchSyncs;        case OpCode.createSession:        case OpCode.closeSession:            return !request.isLocalSession();        default:            return false;    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        /*             * In each iteration of the following loop we process at most             * requestsToProcess requests of queuedRequests. We have to limit             * the number of request we poll from queuedRequests, since it is             * possible to endlessly poll read requests from queuedRequests, and             * that will lead to a starvation of non-local committed requests.             */        int requestsToProcess = 0;        boolean commitIsWaiting = false;        do {            /*                 * Since requests are placed in the queue before being sent to                 * the leader, if commitIsWaiting = true, the commit belongs to                 * the first update operation in the queuedRequests or to a                 * request from a client on another server (i.e., the order of                 * the following two lines is important!).                 */            commitIsWaiting = !committedRequests.isEmpty();            requestsToProcess = queuedRequests.size();                        if (requestsToProcess == 0 && !commitIsWaiting) {                                synchronized (this) {                    while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {                        wait();                        commitIsWaiting = !committedRequests.isEmpty();                        requestsToProcess = queuedRequests.size();                    }                }            }            ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());            ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());            ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());            long time = Time.currentElapsedTime();            /*                 * Processing up to requestsToProcess requests from the incoming                 * queue (queuedRequests). If maxReadBatchSize is set then no                 * commits will be processed until maxReadBatchSize number of                 * reads are processed (or no more reads remain in the queue).                 * After the loop a single committed request is processed if                 * one is waiting (or a batch of commits if maxCommitBatchSize                 * is set).                 */            Request request;            int readsProcessed = 0;            while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {                requestsToProcess--;                if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {                                        Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());                    requests.addLast(request);                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());                } else {                    readsProcessed++;                    numReadQueuedRequests.decrementAndGet();                    sendToNextProcessor(request);                }                /*                     * Stop feeding the pool if there is a local pending update                     * and a committed request that is ready. Once we have a                     * pending request with a waiting committed request, we know                     * we can process the committed one. This is because commits                     * for local requests arrive in the order they appeared in                     * the queue, so if we have a pending request and a                     * committed request, the committed request must be for that                     * pending write or for a write originating at a different                     * server. We skip this if maxReadBatchSize is set.                     */                if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {                    /*                         * We set commitIsWaiting so that we won't check                         * committedRequests again.                         */                    commitIsWaiting = true;                    break;                }            }            ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);            if (!commitIsWaiting) {                commitIsWaiting = !committedRequests.isEmpty();            }            /*                 * Handle commits, if any.                 */            if (commitIsWaiting && !stopped) {                /*                     * Drain outstanding reads                     */                waitForEmptyPool();                if (stopped) {                    return;                }                int commitsToProcess = maxCommitBatchSize;                /*                     * Loop through all the commits, and try to drain them.                     */                Set<Long> queuesToDrain = new HashSet<>();                long startWriteTime = Time.currentElapsedTime();                int commitsProcessed = 0;                while (commitIsWaiting && !stopped && commitsToProcess > 0) {                                        request = committedRequests.peek();                    /*                         * Check if this is a local write request is pending,                         * if so, update it with the committed info. If the commit matches                         * the first write queued in the blockedRequestQueue, we know this is                         * a commit for a local write, as commits are received in order. Else                         * it must be a commit for a remote write.                         */                    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {                        /*                             * Commit matches the earliest write in our write queue.                             */                        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);                        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());                        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {                            /*                                 * Can't process this write yet.                                 * Either there are reads pending in this session, or we                                 * haven't gotten to this write yet.                                 */                            break;                        } else {                            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());                                                        Request topPending = sessionQueue.poll();                            /*                                 * Generally, we want to send to the next processor our version of the request,                                 * since it contains the session information that is needed for post update processing.                                 * In more details, when a request is in the local queue, there is (or could be) a client                                 * attached to this server waiting for a response, and there is other bookkeeping of                                 * requests that are outstanding and have originated from this server                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an                                 * outstanding request completes. Note that in the other case, the operation                                 * originated from a different server and there is no local bookkeeping or a local client                                 * session that needs to be notified.                                 */                            topPending.setHdr(request.getHdr());                            topPending.setTxn(request.getTxn());                            topPending.zxid = request.zxid;                            topPending.commitRecvTime = request.commitRecvTime;                            request = topPending;                                                        numWriteQueuedRequests.decrementAndGet();                            queuedWriteRequests.poll();                            queuesToDrain.add(request.sessionId);                        }                    }                    /*                         * Pull the request off the commit queue, now that we are going                         * to process it.                         */                    committedRequests.remove();                    commitsToProcess--;                    commitsProcessed++;                                        processWrite(request);                    commitIsWaiting = !committedRequests.isEmpty();                }                ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);                ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);                /*                     * Process following reads if any, remove session queue(s) if                     * empty.                     */                readsProcessed = 0;                for (Long sessionId : queuesToDrain) {                    Deque<Request> sessionQueue = pendingRequests.get(sessionId);                    int readsAfterWrite = 0;                    while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {                        numReadQueuedRequests.decrementAndGet();                        sendToNextProcessor(sessionQueue.poll());                        readsAfterWrite++;                    }                    ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);                    readsProcessed += readsAfterWrite;                                        if (sessionQueue.isEmpty()) {                        pendingRequests.remove(sessionId);                    }                }                ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());                ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);            }            ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);            endOfIteration();        } while (!stoppedMainLoop);    } catch (Throwable e) {        handleException(this.getName(), e);    }    LOG.info("CommitProcessor exited loop!");}
f0ee54364cf015f7c6effae717a52184576477daf9c67a1b88cf3de288f43b19
endOfIteration
protected void endOfIteration()
{}
bdaecb4de872c2fe5356b8050cf96897374b07f6f474c75d9a4facf747912154
waitForEmptyPool
protected void waitForEmptyPool() throws InterruptedException
{    int numRequestsInProcess = numRequestsProcessing.get();    if (numRequestsInProcess != 0) {        ServerMetrics.getMetrics().CONCURRENT_REQUEST_PROCESSING_IN_COMMIT_PROCESSOR.add(numRequestsInProcess);    }    long startWaitTime = Time.currentElapsedTime();    synchronized (emptyPoolSync) {        while ((!stopped) && isProcessingRequest()) {            emptyPoolSync.wait();        }    }    ServerMetrics.getMetrics().TIME_WAITING_EMPTY_POOL_IN_COMMIT_PROCESSOR_READ.add(Time.currentElapsedTime() - startWaitTime);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    int numCores = Runtime.getRuntime().availableProcessors();    int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000);    initBatchSizes();    LOG.info("Configuring CommitProcessor with " + (numWorkerThreads > 0 ? numWorkerThreads : "no") + " worker threads.");    if (workerPool == null) {        workerPool = new WorkerService("CommitProcWork", numWorkerThreads, true);    }    stopped = false;    stoppedMainLoop = false;    super.start();}
511d3ea662b04ef7fb4cf61b9c6f69a8df365bb7f8ab8414f4c4ea63a48bd560
sendToNextProcessor
private void sendToNextProcessor(Request request)
{    numRequestsProcessing.incrementAndGet();    workerPool.schedule(new CommitWorkRequest(request), request.sessionId);}
a1af1625cf2b4ad8863ecf123aa59f49882d68756e3d905e42476fe9df71f324
processWrite
private void processWrite(Request request) throws RequestProcessorException
{    processCommitMetrics(request, true);    long timeBeforeFinalProc = Time.currentElapsedTime();    nextProcessor.processRequest(request);    ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);}
3e6c0a5d8235fe05ece1d687b130f426580b04c1ed5e2864d892568bbf4b606e
initBatchSizes
private static void initBatchSizes()
{    maxReadBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_READ_BATCH_SIZE, -1);    maxCommitBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_COMMIT_BATCH_SIZE, 1);    if (maxCommitBatchSize <= 0) {        String errorMsg = "maxCommitBatchSize must be positive, was " + maxCommitBatchSize;        throw new IllegalArgumentException(errorMsg);    }    LOG.info("Configuring CommitProcessor with readBatchSize {} commitBatchSize {}", maxReadBatchSize, maxCommitBatchSize);}
969380c1eea9b19d2f03a31d87b6aa680af5674eb40549637473b97d6b4f53a2
processCommitMetrics
private static void processCommitMetrics(Request request, boolean isWrite)
{    if (isWrite) {        if (request.commitProcQueueStartTime != -1 && request.commitRecvTime != -1) {                        long currentTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().WRITE_COMMITPROC_TIME.add(currentTime - request.commitProcQueueStartTime);            ServerMetrics.getMetrics().LOCAL_WRITE_COMMITTED_TIME.add(currentTime - request.commitRecvTime);        } else if (request.commitRecvTime != -1) {                        ServerMetrics.getMetrics().SERVER_WRITE_COMMITTED_TIME.add(Time.currentElapsedTime() - request.commitRecvTime);        }    } else {        if (request.commitProcQueueStartTime != -1) {            ServerMetrics.getMetrics().READ_COMMITPROC_TIME.add(Time.currentElapsedTime() - request.commitProcQueueStartTime);        }    }}
c8ad29521342cb7f49fafedda86e3182dc15d55aa9ece20215c203fe531e8c80
getMaxReadBatchSize
public static int getMaxReadBatchSize()
{    return maxReadBatchSize;}
c8f49fe48fe91fe21f275ea250d85c061cae2e6f6530113a4055d63a2d1f6bc7
getMaxCommitBatchSize
public static int getMaxCommitBatchSize()
{    return maxCommitBatchSize;}
9c5211c39f508d30dc5142f271fa59208229c1d78f388a2654d01025b4eee957
setMaxReadBatchSize
public static void setMaxReadBatchSize(int size)
{    maxReadBatchSize = size;    LOG.info("Configuring CommitProcessor with readBatchSize {}", maxReadBatchSize);}
942a12a369e8c2a639244b9f0d5fd7846d6318e74fbba2dbf341014a44ef6dce
setMaxCommitBatchSize
public static void setMaxCommitBatchSize(int size)
{    if (size > 0) {        maxCommitBatchSize = size;        LOG.info("Configuring CommitProcessor with commitBatchSize {}", maxCommitBatchSize);    }}
a317f472727975f13a20ef21472e1d5e0a0fd93702ee696b9c962178a725931f
cleanup
public void cleanup()
{    if (!stopped) {        LOG.error("Exception thrown by downstream processor," + " unable to continue.");        CommitProcessor.this.halt();    }}
bd34e051339f18f24461eeef78c32ccd8092929365c6d049e3ca487f8c1a728c
doWork
public void doWork() throws RequestProcessorException
{    try {        processCommitMetrics(request, needCommit(request));        long timeBeforeFinalProc = Time.currentElapsedTime();        nextProcessor.processRequest(request);        if (needCommit(request)) {            ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        } else {            ServerMetrics.getMetrics().READ_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        }    } finally {        if (numRequestsProcessing.decrementAndGet() == 0) {            wakeupOnEmpty();        }    }}
1244412540a09cb925d81ea3ce8bb8373204b83e168b2411620fc4a7239a0d9d
wakeup
private synchronized void wakeup()
{    notifyAll();}
eaa9d15eaed427e15ca6ef05eabe0031b0570ee7d9103f68268cbfde66ad52ef
wakeupOnEmpty
private void wakeupOnEmpty()
{    synchronized (emptyPoolSync) {        emptyPoolSync.notifyAll();    }}
af7ac3908c3a10218fd6c23dd607767f0622ce720d1ee3a7f014560f513e0f6c
commit
public void commit(Request request)
{    if (stopped || request == null) {        return;    }    LOG.debug("Committing request:: {}", request);    request.commitRecvTime = Time.currentElapsedTime();    ServerMetrics.getMetrics().COMMITS_QUEUED.add(1);    committedRequests.add(request);    wakeup();}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    if (stopped) {        return;    }    LOG.debug("Processing request:: {}", request);    request.commitProcQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);        if (needCommit(request)) {        queuedWriteRequests.add(request);        numWriteQueuedRequests.incrementAndGet();    } else {        numReadQueuedRequests.incrementAndGet();    }    wakeup();}
4927eeba3d7e2f97b9b173bba59398c2060ca2e6cfd233e67a323d3087d0ebf8
halt
private void halt()
{    stoppedMainLoop = true;    stopped = true;    wakeupOnEmpty();    wakeup();    queuedRequests.clear();    if (workerPool != null) {        workerPool.stop();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    halt();    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Message response;    while (!stop) {                try {            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (response == null) {                continue;            }                        if (response.buffer.capacity() < 28) {                LOG.error("Got a short response: " + response.buffer.capacity());                continue;            }                                                boolean backCompatibility28 = (response.buffer.capacity() == 28);                        boolean backCompatibility40 = (response.buffer.capacity() == 40);            response.buffer.clear();                        Notification n = new Notification();            int rstate = response.buffer.getInt();            long rleader = response.buffer.getLong();            long rzxid = response.buffer.getLong();            long relectionEpoch = response.buffer.getLong();            long rpeerepoch;            int version = 0x0;            if (!backCompatibility28) {                rpeerepoch = response.buffer.getLong();                if (!backCompatibility40) {                    /*                                 * Version added in 3.4.6                                 */                    version = response.buffer.getInt();                } else {                    LOG.info("Backward compatibility mode (36 bits), server id: {}", response.sid);                }            } else {                LOG.info("Backward compatibility mode (28 bits), server id: {}", response.sid);                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);            }            QuorumVerifier rqv = null;                        if (version > 0x1) {                int configLength = response.buffer.getInt();                byte[] b = new byte[configLength];                response.buffer.get(b);                synchronized (self) {                    try {                        rqv = self.configFromString(new String(b));                        QuorumVerifier curQV = self.getQuorumVerifier();                        if (rqv.getVersion() > curQV.getVersion()) {                            LOG.info("{} Received version: {} my version: {}", self.getId(), Long.toHexString(rqv.getVersion()), Long.toHexString(self.getQuorumVerifier().getVersion()));                            if (self.getPeerState() == ServerState.LOOKING) {                                LOG.debug("Invoking processReconfig(), state: {}", self.getServerState());                                self.processReconfig(rqv, null, null, false);                                if (!rqv.equals(curQV)) {                                    LOG.info("restarting leader election");                                    self.shuttingDownLE = true;                                    self.getElectionAlg().shutdown();                                    break;                                }                            } else {                                LOG.debug("Skip processReconfig(), state: {}", self.getServerState());                            }                        }                    } catch (IOException e) {                        LOG.error("Something went wrong while processing config received from {}", response.sid);                    } catch (ConfigException e) {                        LOG.error("Something went wrong while processing config received from {}", response.sid);                    }                }            } else {                LOG.info("Backward compatibility mode (before reconfig), server id: {}", response.sid);            }            /*                         * If it is from a non-voting server (such as an observer or                         * a non-voting follower), respond right away.                         */            if (!validVoter(response.sid)) {                Vote current = self.getCurrentVote();                QuorumVerifier qv = self.getQuorumVerifier();                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                sendqueue.offer(notmsg);            } else {                                LOG.debug("Receive new notification message. My id = {}", self.getId());                                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;                switch(rstate) {                    case 0:                        ackstate = QuorumPeer.ServerState.LOOKING;                        break;                    case 1:                        ackstate = QuorumPeer.ServerState.FOLLOWING;                        break;                    case 2:                        ackstate = QuorumPeer.ServerState.LEADING;                        break;                    case 3:                        ackstate = QuorumPeer.ServerState.OBSERVING;                        break;                    default:                        continue;                }                n.leader = rleader;                n.zxid = rzxid;                n.electionEpoch = relectionEpoch;                n.state = ackstate;                n.sid = response.sid;                n.peerEpoch = rpeerepoch;                n.version = version;                n.qv = rqv;                /*                             * Print notification info                             */                if (LOG.isInfoEnabled()) {                    printNotification(n);                }                if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {                    recvqueue.offer(n);                    /*                                 * Send a notification back if the peer that sent this                                 * message is also looking and its logical clock is                                 * lagging behind.                                 */                    if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {                        Vote v = getVote();                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                } else {                    /*                                 * If this server is not looking, but the one that sent the ack                                 * is looking, then send back what it believes to be the leader.                                 */                    Vote current = self.getCurrentVote();                    if (ackstate == QuorumPeer.ServerState.LOOKING) {                        if (self.leader != null) {                            if (leadingVoteSet != null) {                                self.leader.setLeadingVoteSet(leadingVoteSet);                                leadingVoteSet = null;                            }                            self.leader.reportLookingSid(response.sid);                        }                        if (LOG.isDebugEnabled()) {                            LOG.debug("Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}", self.getId(), response.sid, Long.toHexString(current.getZxid()), current.getId(), Long.toHexString(self.getQuorumVerifier().getVersion()));                        }                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                }            }        } catch (InterruptedException e) {            LOG.warn("Interrupted Exception while waiting for new message" + e.toString());        }    }    LOG.info("WorkerReceiver is down");}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stop) {        try {            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);            if (m == null) {                continue;            }            process(m);        } catch (InterruptedException e) {            break;        }    }    LOG.info("WorkerSender is down");}
a30979491f9d1405360eab436f9e25946ad4d2167d315a394515d1ba9693d3a6
process
 void process(ToSend m)
{    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch, m.configData);    manager.toSend(m.sid, requestBuffer);}
45d085a61b0d7f7c587e5b8b449b868ebc6772c33e5957892ccde283d250ae87
start
 void start()
{    this.wsThread.start();    this.wrThread.start();}
c7a62c62f11c17267dd28ca70052aea01cc4a0b57ac5bd3aec5a8a331845760c
halt
 void halt()
{    this.ws.stop = true;    this.wr.stop = true;}
e1f047c0d90dcf67c7004f3e7a13707186b124376be65300696e2bc124b2ab5d
getLogicalClock
public long getLogicalClock()
{    return logicalclock.get();}
f8de2679a63a57f02d66d47fab5e1714081a9606e6937927c9cdd5dbf6441b57
buildMsg
 static ByteBuffer buildMsg(int state, long leader, long zxid, long electionEpoch, long epoch)
{    byte[] requestBytes = new byte[40];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send, this is called directly only in tests         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(0x1);    return requestBuffer;}
189f72d34dfd9fe488370f3504b47a64946ac38f6df5f32f2cf016c7461798df
buildMsg
 static ByteBuffer buildMsg(int state, long leader, long zxid, long electionEpoch, long epoch, byte[] configData)
{    byte[] requestBytes = new byte[44 + configData.length];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(Notification.CURRENTVERSION);    requestBuffer.putInt(configData.length);    requestBuffer.put(configData);    return requestBuffer;}
601e13301227c11e094fd84691d1a614ffe4d4f7bfbe8731f579186533004c17
starter
private void starter(QuorumPeer self, QuorumCnxManager manager)
{    this.self = self;    proposedLeader = -1;    proposedZxid = -1;    sendqueue = new LinkedBlockingQueue<ToSend>();    recvqueue = new LinkedBlockingQueue<Notification>();    this.messenger = new Messenger(manager);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    this.messenger.start();}
5101300ef5de59b7b7abf1539d48d39d2b7894f73f9376ca68c742ce42e3730c
leaveInstance
private void leaveInstance(Vote v)
{    if (LOG.isDebugEnabled()) {        LOG.debug("About to leave FLE instance: leader={}, zxid=0x{}, my id={}, my state={}", v.getId(), Long.toHexString(v.getZxid()), self.getId(), self.getPeerState());    }    recvqueue.clear();}
7875287eee26f61e42b2e849e8c5cf6fc990cfaeb1ebc8799db72e9887f2eeb3
getCnxManager
public QuorumCnxManager getCnxManager()
{    return manager;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stop = true;    proposedLeader = -1;    proposedZxid = -1;    leadingVoteSet = null;    LOG.debug("Shutting down connection manager");    manager.halt();    LOG.debug("Shutting down messenger");    messenger.halt();    LOG.debug("FLE is down");}
8ce03e43b019d8b4b7eb6eed4c2561de700eba6acd4eec660772c13b3215f189
sendNotifications
private void sendNotifications()
{    for (long sid : self.getCurrentAndNextConfigVoters()) {        QuorumVerifier qv = self.getQuorumVerifier();        ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes());        if (LOG.isDebugEnabled()) {            LOG.debug("Sending Notification: " + proposedLeader + " (n.leader), 0x" + Long.toHexString(proposedZxid) + " (n.zxid), 0x" + Long.toHexString(logicalclock.get()) + " (n.round), " + sid + " (recipient), " + self.getId() + " (myid), 0x" + Long.toHexString(proposedEpoch) + " (n.peerEpoch)");        }        sendqueue.offer(notmsg);    }}
9f208a2410dbba8ab79a4b15c8c6572fb4ef8ba5c70aa7af5d1751c0701f9c7b
printNotification
private void printNotification(Notification n)
{    LOG.info("Notification: my state:{}; n.sid:{}, n.state:{}, n.leader:{}, n.round:0x{}, " + "n.peerEpoch:0x{}, n.zxid:0x{}, message format version:0x{}, n.config version:0x{}", self.getPeerState(), n.sid, n.state, n.leader, Long.toHexString(n.electionEpoch), Long.toHexString(n.peerEpoch), Long.toHexString(n.zxid), Long.toHexString(n.version), (n.qv != null ? (Long.toHexString(n.qv.getVersion())) : "0"));}
bd74ce9e4e5c7962e36f9b9905cd8350fbee60361afc4cbdbb2b839272c67617
totalOrderPredicate
protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    if (LOG.isDebugEnabled()) {        LOG.debug("id: " + newId + ", proposed id: " + curId + ", zxid: 0x" + Long.toHexString(newZxid) + ", proposed zxid: 0x" + Long.toHexString(curZxid));    }    if (self.getQuorumVerifier().getWeight(newId) == 0) {        return false;    }    return ((newEpoch > curEpoch) || ((newEpoch == curEpoch) && ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));}
c84db16dc55b9db2d0f71301444ba90694a7f1c4e6598687a3ae3c8a30f1a864
getVoteTracker
protected SyncedLearnerTracker getVoteTracker(Map<Long, Vote> votes, Vote vote)
{    SyncedLearnerTracker voteSet = new SyncedLearnerTracker();    voteSet.addQuorumVerifier(self.getQuorumVerifier());    if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {        voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());    }    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Map.Entry<Long, Vote> entry : votes.entrySet()) {        if (vote.equals(entry.getValue())) {            voteSet.addAck(entry.getKey());        }    }    return voteSet;}
c28cbf313598582ce325f6ab4c523f107b67f64d4d91f58523fbfb0983b28e6c
checkLeader
protected boolean checkLeader(Map<Long, Vote> votes, long leader, long electionEpoch)
{    boolean predicate = true;    if (leader != self.getId()) {        if (votes.get(leader) == null) {            predicate = false;        } else if (votes.get(leader).getState() != ServerState.LEADING) {            predicate = false;        }    } else if (logicalclock.get() != electionEpoch) {        predicate = false;    }    return predicate;}
7304e69c4b4a7ff7deeeb7835547905cb3bf5616c9fb6b781b0a0cbff71f224b
updateProposal
 synchronized void updateProposal(long leader, long zxid, long epoch)
{    if (LOG.isDebugEnabled()) {        LOG.debug("Updating proposal: " + leader + " (newleader), 0x" + Long.toHexString(zxid) + " (newzxid), " + proposedLeader + " (oldleader), 0x" + Long.toHexString(proposedZxid) + " (oldzxid)");    }    proposedLeader = leader;    proposedZxid = zxid;    proposedEpoch = epoch;}
5af1c3a3d5bd3645b406396a0d427b150b36cfe7570ee55b2389d905e2b64693
getVote
public synchronized Vote getVote()
{    return new Vote(proposedLeader, proposedZxid, proposedEpoch);}
b348b751246a6bace2d0fe58af2109b5f534ffb7658fd4d354d383f3bf5c418d
learningState
private ServerState learningState()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        LOG.debug("I am a participant: {}", self.getId());        return ServerState.FOLLOWING;    } else {        LOG.debug("I am an observer: {}", self.getId());        return ServerState.OBSERVING;    }}
034b5987d86df5352477d31e496fbdb49cc924af3a51dee41111829979576cee
getInitId
private long getInitId()
{    if (self.getQuorumVerifier().getVotingMembers().containsKey(self.getId())) {        return self.getId();    } else {        return Long.MIN_VALUE;    }}
81f529b977e38f33a34022e12dbfbd3156a92e1e2e876a5737d55609032552f7
getInitLastLoggedZxid
private long getInitLastLoggedZxid()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        return self.getLastLoggedZxid();    } else {        return Long.MIN_VALUE;    }}
3c5f0591b63cf34421f95996c352e97211eb2ae5c6aafaf7a627499531419a7d
getPeerEpoch
private long getPeerEpoch()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        try {            return self.getCurrentEpoch();        } catch (IOException e) {            RuntimeException re = new RuntimeException(e.getMessage());            re.setStackTrace(e.getStackTrace());            throw re;        }    } else {        return Long.MIN_VALUE;    }}
d436bcf56d5c33f963987affca2f3bd9eced37a77e1b5f594ad195ef6fc55f69
setPeerState
private void setPeerState(long proposedLeader, SyncedLearnerTracker voteSet)
{    ServerState ss = (proposedLeader == self.getId()) ? ServerState.LEADING : learningState();    self.setPeerState(ss);    if (ss == ServerState.LEADING) {        leadingVoteSet = voteSet;    }}
2d8d6feccda6139051ddb3e7277c1967d7f0893f924f982c3cbe44fcce2ffed8
lookForLeader
public Vote lookForLeader() throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        self.jmxLeaderElectionBean = null;    }    self.start_fle = Time.currentElapsedTime();    try {        Map<Long, Vote> recvset = new HashMap<Long, Vote>();        Map<Long, Vote> outofelection = new HashMap<Long, Vote>();        int notTimeout = minNotificationInterval;        synchronized (this) {            logicalclock.incrementAndGet();            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());        }        LOG.info("New election. My id =  " + self.getId() + ", proposed zxid=0x" + Long.toHexString(proposedZxid));        sendNotifications();        SyncedLearnerTracker voteSet;        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (manager.haveDelivered()) {                    sendNotifications();                } else {                    manager.connectAll();                }                /*                     * Exponential backoff                     */                int tmpTimeOut = notTimeout * 2;                notTimeout = (tmpTimeOut < maxNotificationInterval ? tmpTimeOut : maxNotificationInterval);                LOG.info("Notification time out: " + notTimeout);            } else if (validVoter(n.sid) && validVoter(n.leader)) {                /*                     * Only proceed if the vote comes from a replica in the current or next                     * voting view for a replica in the current or next voting view.                     */                switch(n.state) {                    case LOOKING:                        if (getInitLastLoggedZxid() == -1) {                            LOG.debug("Ignoring notification as our zxid is -1");                            break;                        }                        if (n.zxid == -1) {                            LOG.debug("Ignoring notification from member with -1 zxid {}", n.sid);                            break;                        }                                                if (n.electionEpoch > logicalclock.get()) {                            logicalclock.set(n.electionEpoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {                                updateProposal(n.leader, n.zxid, n.peerEpoch);                            } else {                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());                            }                            sendNotifications();                        } else if (n.electionEpoch < logicalclock.get()) {                            if (LOG.isDebugEnabled()) {                                LOG.debug("Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x" + Long.toHexString(n.electionEpoch) + ", logicalclock=0x" + Long.toHexString(logicalclock.get()));                            }                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                            updateProposal(n.leader, n.zxid, n.peerEpoch);                            sendNotifications();                        }                        if (LOG.isDebugEnabled()) {                            LOG.debug("Adding vote: from=" + n.sid + ", proposed leader=" + n.leader + ", proposed zxid=0x" + Long.toHexString(n.zxid) + ", proposed election epoch=0x" + Long.toHexString(n.electionEpoch));                        }                                                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));                        if (voteSet.hasAllQuorums()) {                                                        while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                                    recvqueue.put(n);                                    break;                                }                            }                            /*                             * This predicate is true once we don't read any new                             * relevant message from the reception queue                             */                            if (n == null) {                                setPeerState(proposedLeader, voteSet);                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        break;                    case OBSERVING:                        LOG.debug("Notification from observer: {}", n.sid);                        break;                    case FOLLOWING:                    case LEADING:                        /*                         * Consider all notifications from the same epoch                         * together.                         */                        if (n.electionEpoch == logicalclock.get()) {                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                            voteSet = getVoteTracker(recvset, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                            if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                                setPeerState(n.leader, voteSet);                                Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        /*                         * Before joining an established ensemble, verify that                         * a majority are following the same leader.                         */                        outofelection.put(n.sid, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        voteSet = getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                            synchronized (this) {                                logicalclock.set(n.electionEpoch);                                setPeerState(n.leader, voteSet);                            }                            Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                            leaveInstance(endVote);                            return endVote;                        }                        break;                    default:                        LOG.warn("Notification state unrecoginized: " + n.state + " (n.state), " + n.sid + " (n.sid)");                        break;                }            } else {                if (!validVoter(n.leader)) {                    LOG.warn("Ignoring notification for non-cluster member sid {} from sid {}", n.leader, n.sid);                }                if (!validVoter(n.sid)) {                    LOG.warn("Ignoring notification for sid {} from non-quorum member sid {}", n.leader, n.sid);                }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {            LOG.warn("Failed to unregister with JMX", e);        }        self.jmxLeaderElectionBean = null;        LOG.debug("Number of connection processing threads: {}", manager.getConnectionThreadCount());    }}
ba56a980726bae4d9698d952e1d4c1f67c17b70987ce2a8a5d32060752775f47
validVoter
private boolean validVoter(long sid)
{    return self.getCurrentAndNextConfigVoters().contains(sid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof QuorumHierarchical)) {        return false;    }    QuorumHierarchical qm = (QuorumHierarchical) o;    if (qm.getVersion() == version) {        return true;    }    if ((allMembers.size() != qm.getAllMembers().size()) || (serverWeight.size() != qm.serverWeight.size()) || (groupWeight.size() != qm.groupWeight.size()) || (serverGroup.size() != qm.serverGroup.size())) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    for (Entry<Long, Long> entry : serverWeight.entrySet()) {        if (!entry.getValue().equals(qm.serverWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : groupWeight.entrySet()) {        if (!entry.getValue().equals(qm.groupWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        if (!entry.getValue().equals(qm.serverGroup.get(entry.getKey()))) {            return false;        }    }    return true;}
6d8ff2c19c7290e7b15ee5aae0dabc3fb3bb61cadc7bc57b6dc234aae409dd81
getWeight
public long getWeight(long id)
{    return serverWeight.get(id);}
d3f17cc181c677544c7b429d70f53172f874b4604640e6fc83b408e6d5a136ec
readConfigFile
private void readConfigFile(String filename) throws ConfigException
{    File configFile = new File(filename);    LOG.info("Reading configuration from: " + configFile);    try {        if (!configFile.exists()) {            throw new IllegalArgumentException(configFile.toString() + " file is missing");        }        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parse(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + filename, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + filename, e);    }}
95209e635256232654e2ee975b49758ffa958474b0afd99aebd3812337b62a72
parse
private void parse(Properties quorumProp) throws ConfigException
{    for (Entry<Object, Object> entry : quorumProp.entrySet()) {        String key = entry.getKey().toString();        String value = entry.getValue().toString();        if (key.startsWith("server.")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            QuorumServer qs = new QuorumServer(sid, value);            allMembers.put(Long.valueOf(sid), qs);            if (qs.type == LearnerType.PARTICIPANT) {                participatingMembers.put(Long.valueOf(sid), qs);            } else {                observingMembers.put(Long.valueOf(sid), qs);            }        } else if (key.startsWith("group")) {            int dot = key.indexOf('.');            long gid = Long.parseLong(key.substring(dot + 1));            numGroups++;            String[] parts = value.split(":");            for (String s : parts) {                long sid = Long.parseLong(s);                if (serverGroup.containsKey(sid)) {                    throw new ConfigException("Server " + sid + "is in multiple groups");                } else {                    serverGroup.put(sid, gid);                }            }        } else if (key.startsWith("weight")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            serverWeight.put(sid, Long.parseLong(value));        } else if (key.equals("version")) {            version = Long.parseLong(value, 16);        }    }    for (QuorumServer qs : allMembers.values()) {        Long id = qs.id;        if (qs.type == LearnerType.PARTICIPANT) {            if (!serverGroup.containsKey(id)) {                throw new ConfigException("Server " + id + "is not in a group");            }            if (!serverWeight.containsKey(id)) {                serverWeight.put(id, (long) 1);            }        }    }    computeGroupWeight();}
b3699c3723339d8eb201f83a1477d55af7d4f329059a5d345a94a37ea0b8dc2f
getAllMembers
public Map<Long, QuorumServer> getAllMembers()
{    return allMembers;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringWriter sw = new StringWriter();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    Map<Long, String> groups = new HashMap<Long, String>();    for (Entry<Long, Long> pair : serverGroup.entrySet()) {        Long sid = pair.getKey();        Long gid = pair.getValue();        String str = groups.get(gid);        if (str == null) {            str = sid.toString();        } else {            str = str.concat(":").concat(sid.toString());        }        groups.put(gid, str);    }    for (Entry<Long, String> pair : groups.entrySet()) {        Long gid = pair.getKey();        String key = "group." + gid.toString();        String value = pair.getValue();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    for (Entry<Long, Long> pair : serverWeight.entrySet()) {        Long sid = pair.getKey();        String key = "weight." + sid.toString();        String value = pair.getValue().toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    sw.append("version=" + Long.toHexString(version));    return sw.toString();}
537df939476656539d159c74cc7b1d2256caaaa9c1b7304ebaec6d694b1a5978
computeGroupWeight
private void computeGroupWeight()
{    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        Long sid = entry.getKey();        Long gid = entry.getValue();        if (!groupWeight.containsKey(gid)) {            groupWeight.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);            groupWeight.put(gid, totalWeight);        }    }    /*         * Do not consider groups with weight zero         */    for (long weight : groupWeight.values()) {        LOG.debug("Group weight: {}", weight);        if (weight == ((long) 0)) {            numGroups--;            LOG.debug("One zero-weight group: 1, {}", numGroups);        }    }}
f989da9f5d17437c8bf766964d8b4db670188c5442799c2991af402042595d7a
containsQuorum
public boolean containsQuorum(Set<Long> set)
{    HashMap<Long, Long> expansion = new HashMap<Long, Long>();    /*         * Adds up weights per group         */    LOG.debug("Set size: {}", set.size());    if (set.size() == 0) {        return false;    }    for (long sid : set) {        Long gid = serverGroup.get(sid);        if (gid == null) {            continue;        }        if (!expansion.containsKey(gid)) {            expansion.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + expansion.get(gid);            expansion.put(gid, totalWeight);        }    }    /*         * Check if all groups have majority         */    int majGroupCounter = 0;    for (Entry<Long, Long> entry : expansion.entrySet()) {        Long gid = entry.getKey();        LOG.debug("Group info: {}, {}, {}", entry.getValue(), gid, groupWeight.get(gid));        if (entry.getValue() > (groupWeight.get(gid) / 2)) {            majGroupCounter++;        }    }    LOG.debug("Majority group counter: {}, {}", majGroupCounter, numGroups);    if ((majGroupCounter > (numGroups / 2))) {        LOG.debug("Positive set size: {}", set.size());        return true;    } else {        LOG.debug("Negative set size: {}", set.size());        return false;    }}
55973b53b5a342b92ffd8f94ef721335d8ea48330937ae6a20739fc7677467bd
getVotingMembers
public Map<Long, QuorumServer> getVotingMembers()
{    return participatingMembers;}
618562cc5cfe45910868e94c7ac91971b16dff189570413a0970d06d31a552ad
getObservingMembers
public Map<Long, QuorumServer> getObservingMembers()
{    return observingMembers;}
edaadfac3a1954925781e062997f12f3209e86d3488593bc0c0bfc5968cb52f3
getVersion
public long getVersion()
{    return version;}
e78b8e2a43eebb9bc2d6399f12466e0dea89a13aa6a8784ae7cc23147073f886
setVersion
public void setVersion(long ver)
{    version = ver;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof QuorumMaj)) {        return false;    }    QuorumMaj qm = (QuorumMaj) o;    if (qm.getVersion() == version) {        return true;    }    if (allMembers.size() != qm.getAllMembers().size()) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    return true;}
6d8ff2c19c7290e7b15ee5aae0dabc3fb3bb61cadc7bc57b6dc234aae409dd81
getWeight
public long getWeight(long id)
{    return 1;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sw = new StringBuilder();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    String hexVersion = Long.toHexString(version);    sw.append("version=");    sw.append(hexVersion);    return sw.toString();}
31bdf62b01de1cf176d9a6cb2e1f3a176eae0ff1a446666a2010e1275421178a
containsQuorum
public boolean containsQuorum(Set<Long> ackSet)
{    return (ackSet.size() > half);}
b3699c3723339d8eb201f83a1477d55af7d4f329059a5d345a94a37ea0b8dc2f
getAllMembers
public Map<Long, QuorumServer> getAllMembers()
{    return allMembers;}
55973b53b5a342b92ffd8f94ef721335d8ea48330937ae6a20739fc7677467bd
getVotingMembers
public Map<Long, QuorumServer> getVotingMembers()
{    return votingMembers;}
618562cc5cfe45910868e94c7ac91971b16dff189570413a0970d06d31a552ad
getObservingMembers
public Map<Long, QuorumServer> getObservingMembers()
{    return observingMembers;}
edaadfac3a1954925781e062997f12f3209e86d3488593bc0c0bfc5968cb52f3
getVersion
public long getVersion()
{    return version;}
e78b8e2a43eebb9bc2d6399f12466e0dea89a13aa6a8784ae7cc23147073f886
setVersion
public void setVersion(long ver)
{    version = ver;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Follower ").append(sock);    sb.append(" lastQueuedZxid:").append(lastQueued);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
71ec733f454a8062047c0e3774bca532ac3f4efbabb34898f72995f2722bf5ee
followLeader
 void followLeader() throws InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);    LOG.info("FOLLOWING - LEADER ELECTION TOOK - {} {}", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);    self.start_fle = 0;    self.end_fle = 0;    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);    long connectionTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer leaderServer = findLeader();        try {            connectToLeader(leaderServer.addr, leaderServer.hostname);            connectionTime = System.currentTimeMillis();            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }                                    long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);            if (newEpoch < self.getAcceptedEpoch()) {                LOG.error("Proposed leader epoch " + ZxidUtils.zxidToString(newEpochZxid) + " is less than our accepted epoch " + ZxidUtils.zxidToString(self.getAcceptedEpoch()));                throw new IOException("Error: Epoch of leader is lower");            }            long startTime = Time.currentElapsedTime();            try {                self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);                syncWithLeader(newEpochZxid);                self.setZabState(QuorumPeer.ZabState.BROADCAST);                completedSync = true;            } finally {                long syncTime = Time.currentElapsedTime() - startTime;                ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);            }            if (self.getObserverMasterPort() > 0) {                LOG.info("Starting ObserverMaster");                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());                om.start();            } else {                om = null;            }                        QuorumPacket qp = new QuorumPacket();            while (this.isRunning()) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {            LOG.warn("Exception when following the leader", e);            closeSocket();                        pendingRevalidations.clear();        }    } finally {        if (om != null) {            om.stop();        }        zk.unregisterJMX(this);        if (connectionTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectionTime;            LOG.info("Disconnected from leader (with address: {}). " + "Was connected for {}ms. Sync state: {}", leaderAddr, connectionDuration, completedSync);            messageTracker.dumpToLog(leaderAddr.toString());        }    }}
3c48129e174442c741c73efe4e75fb1b7199a7e9897b2a57fa106015e86974e4
processPacket
protected void processPacket(QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            if (hdr.getZxid() != lastQueued + 1) {                LOG.warn("Got zxid 0x" + Long.toHexString(hdr.getZxid()) + " expected 0x" + Long.toHexString(lastQueued + 1));            }            lastQueued = hdr.getZxid();            if (hdr.getType() == OpCode.reconfig) {                SetDataTxn setDataTxn = (SetDataTxn) txn;                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                self.setLastSeenQuorumVerifier(qv, true);            }            fzk.logRequest(hdr, txn);            if (hdr != null) {                /*                 * Request header is created only by the leader, so this is only set                 * for quorum packets. If there is a clock drift, the latency may be                 * negative. Headers use wall time, not CLOCK_MONOTONIC.                 */                long now = Time.currentWallTime();                long latency = now - hdr.getTime();                if (latency >= 0) {                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);                }            }            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalReceived(qp);                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMIT:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            fzk.commit(qp.getZxid());            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalCommitted(qp.getZxid());                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMITANDACTIVATE:                        Request request = fzk.pendingTxns.element();            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            final long zxid = qp.getZxid();            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);                        fzk.commit(zxid);            if (om != null) {                om.informAndActivate(zxid, suggestedLeaderId);            }            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        case Leader.UPTODATE:            LOG.error("Received an UPTODATE message after Follower started");            break;        case Leader.REVALIDATE:            if (om == null || !om.revalidateLearnerSession(qp)) {                revalidate(qp);            }            break;        case Leader.SYNC:            fzk.sync();            break;        default:            LOG.warn("Unknown packet type: {}", LearnerHandler.packetToString(qp));            break;    }}
801e4e9de7001eb2aab4d5e974b3815294de7fb0baf148bdf44fffbf5d770188
getZxid
public long getZxid()
{    try {        synchronized (fzk) {            return fzk.getZxid();        }    } catch (NullPointerException e) {        LOG.warn("error getting zxid", e);    }    return -1;}
e8391f828b77de4e8cb73c75cad8b97eca43b918e9b209207f55a625238a36e7
getLastQueued
protected long getLastQueued()
{    return lastQueued;}
5d3ff2fe611c499a5cb6188970270bbdede229a4a3b4ea338d2145d6326f8c83
getSyncedObserverSize
public Integer getSyncedObserverSize()
{    return om == null ? null : om.getNumActiveObservers();}
93a326fbe26b3c51546a4d515e0105db3edf12c4599ee6461c76c1bdca783b30
getSyncedObserversInfo
public Iterable<Map<String, Object>> getSyncedObserversInfo()
{    if (om != null && om.getNumActiveObservers() > 0) {        return om.getActiveObservers();    }    return Collections.emptySet();}
bd4a022dd78d31e1264024c16d58f0c3401530d6762e8226c308883687af1d76
resetObserverConnectionStats
public void resetObserverConnectionStats()
{    if (om != null && om.getNumActiveObservers() > 0) {        om.resetObserverConnectionStats();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("shutdown called", new Exception("shutdown Follower"));    super.shutdown();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "Follower";}
4f1ec8c9033d0a4457283cded308db0fec7b84f7c76e3ab807775805037a55de
getQuorumAddress
public String getQuorumAddress()
{    return follower.sock.toString();}
4ee6d1470f205edf5a9c5cd0f92841e406158434e23a62935afcabcc0f4ebfa0
getLastQueuedZxid
public String getLastQueuedZxid()
{    return "0x" + Long.toHexString(follower.getLastQueued());}
31f3fc9425ae0bb3417ac99a250c8d410a893d69def794732da3a57591a96616
getPendingRevalidationCount
public int getPendingRevalidationCount()
{    return follower.getPendingRevalidationsCount();}
592984bb8fd8dfd3780dbc7c311474353ec225fb0536322775403dfe8fa59279
getElectionTimeTaken
public long getElectionTimeTaken()
{    return follower.self.getElectionTimeTaken();}
86415d7e421beded77a73ae68e700c7893f3f0d1c8138c0c600aa89ede39c1bc
getObserverMasterPacketSizeLimit
public int getObserverMasterPacketSizeLimit()
{    return follower.om == null ? -1 : follower.om.getPktsSizeLimit();}
1e54e0929da62068f47dfdbafc89e76cc59a16e63c404a4c42df961f4c8e9f44
setObserverMasterPacketSizeLimit
public void setObserverMasterPacketSizeLimit(int sizeLimit)
{    ObserverMaster.setPktsSizeLimit(sizeLimit);}
effe2b111b7d2562cb0579bb71ecb9e5964e69a42c011dc9ea78bb86cbfe3bbc
getMaxConcurrentSnapSyncs
public int getMaxConcurrentSnapSyncs()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentSnapSyncs();}
cb1d390c7a3687ba726bebd8f64624aacd1984a4bf7cedc86ba6980f011651e2
setMaxConcurrentSnapSyncs
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapshots)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);    }}
9963f5c3c27beaab3c6b73119e3b7a1832f0baf79b14c48c03a2c619c130f6b3
getMaxConcurrentDiffSyncs
public int getMaxConcurrentDiffSyncs()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentDiffSyncs();}
ba7ab6209f111504ffe99a89df6f0d58357c239068d0c1c59b8d99cb86f9e0d5
setMaxConcurrentDiffSyncs
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getFollower().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getFollower().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getFollower().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    LOG.info("FollowerRequestProcessor exited loop!");}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    processRequest(request, true);}
188ca8fc461442d019218fce035f1f2cc2a5a105e89b0dc670165f7cc2d4e090
processRequest
 void processRequest(Request request, boolean checkForUpgrade)
{    if (!finished) {        if (checkForUpgrade) {                                                Request upgradeRequest = null;            try {                upgradeRequest = zks.checkUpgradeSession(request);            } catch (KeeperException ke) {                if (request.getHdr() != null) {                    request.getHdr().setType(OpCode.error);                    request.setTxn(new ErrorTxn(ke.code().intValue()));                }                request.setException(ke);                LOG.info("Error creating upgrade request", ke);            } catch (IOException ie) {                LOG.error("Unexpected error in upgrade", ie);            }            if (upgradeRequest != null) {                queuedRequests.add(upgradeRequest);            }        }        queuedRequests.add(request);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
f6ef72d8cf62f14acb828d2cde9a3eb11486f1258e056a14085cc01b3d7bd568
getFollower
public Follower getFollower()
{    return self.follower;}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new FollowerRequestProcessor(this, commitProcessor);    ((FollowerRequestProcessor) firstProcessor).start();    syncProcessor = new SyncRequestProcessor(this, new SendAckRequestProcessor(getFollower()));    syncProcessor.start();}
4d92aa758aa57fc22df12045af5a1456270fa706c2f8b101622b75249605a782
logRequest
public void logRequest(TxnHeader hdr, Record txn)
{    Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    if ((request.zxid & 0xffffffffL) != 0) {        pendingTxns.add(request);    }    syncProcessor.processRequest(request);}
cbede01f4eed780706cdb555227e3c8dd11c38cde15c4c774981e6c8bdbdbf62
commit
public void commit(long zxid)
{    if (pendingTxns.size() == 0) {        LOG.warn("Committing " + Long.toHexString(zxid) + " without seeing txn");        return;    }    long firstElementZxid = pendingTxns.element().zxid;    if (firstElementZxid != zxid) {        LOG.error("Committing zxid 0x" + Long.toHexString(zxid) + " but next pending txn 0x" + Long.toHexString(firstElementZxid));        System.exit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());    }    Request request = pendingTxns.remove();    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);    commitProcessor.commit(request);}
8c833bce92b79c69de87a5498bf4c1c6debbfaa7da8ccab5a54e20c6911e3d9b
sync
public synchronized void sync()
{    if (pendingSyncs.size() == 0) {        LOG.warn("Not expecting a sync.");        return;    }    Request r = pendingSyncs.remove();    if (r instanceof LearnerSyncRequest) {        LearnerSyncRequest lsr = (LearnerSyncRequest) r;        lsr.fh.queuePacket(new QuorumPacket(Leader.SYNC, 0, null, null));    }    commitProcessor.commit(r);}
c9038b65c2f4fbf257d00190088ff8420d485b048bbe0d78c9f47f278fd55fbe
getGlobalOutstandingLimit
public int getGlobalOutstandingLimit()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return "follower";}
d4d6215fb456119d106b5f717a681421488775b8c85a263aae42ba59890c4a09
getLearner
public Learner getLearner()
{    return getFollower();}
079b5a5e2fcbc10fde0a9d34f2f2dd070eb3cd4e94c4e917a0bc699a15fc5c23
processObserverRequest
 void processObserverRequest(Request request)
{    ((FollowerRequestProcessor) firstProcessor).processRequest(request, false);}
1c53f5bb5268d005d4ad3fc006e95ba0fa7d119f22fe36cb6129e3a446a2c2b5
registerJMX
 boolean registerJMX(LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {        LOG.warn("Could not register connection", e);    }    return false;}
79285532c7fb8fc78a40e7457ab3382e4f205c333dc4a989a8d9deb0895c344b
registerMetrics
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);}
7a1592c7f6f4561e51579c42c380094baff7002d616a43b17459fdd0f834dec2
unregisterMetrics
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("synced_observers");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return packet.getType() + ", " + packet.getZxid() + ", " + request;}
f3efce84c9c6e4986b7091d84387952cfea5c4cf9466fa40f5961dcd7266f7af
setAckLoggingFrequency
public static void setAckLoggingFrequency(int frequency)
{    ackLoggingFrequency = frequency;}
e6ed9373df60c1c8a3370b5af40fc91706e82597e59f2d58b8d9f15a04874628
getAckLoggingFrequency
public static int getAckLoggingFrequency()
{    return ackLoggingFrequency;}
fbea3abba19d10ff309e208e855e390520230e837a045272e819c61d861d7c2a
getProposalStats
public BufferStats getProposalStats()
{    return proposalStats;}
3dbc2f11cafaabf4f377afed0d2060b4372b92e51d0909ebf33964019bc3ab69
getLearners
public List<LearnerHandler> getLearners()
{    synchronized (learners) {        return new ArrayList<LearnerHandler>(learners);    }}
4cf147efe73071808fcc3838558a636ce510b6339a0f1a951b13dbd4df44fee0
getForwardingFollowers
public List<LearnerHandler> getForwardingFollowers()
{    synchronized (forwardingFollowers) {        return new ArrayList<LearnerHandler>(forwardingFollowers);    }}
59a6e62befa1406a4faffdd46fc1739b40023d35d604a765d513f038da03f1cf
getNonVotingFollowers
public List<LearnerHandler> getNonVotingFollowers()
{    List<LearnerHandler> nonVotingFollowers = new ArrayList<LearnerHandler>();    synchronized (forwardingFollowers) {        for (LearnerHandler lh : forwardingFollowers) {            if (!isParticipant(lh.getSid())) {                nonVotingFollowers.add(lh);            }        }    }    return nonVotingFollowers;}
a4bc0e6ce7be3abd2fac923840d213c309ee1c2bd261b9338fc03aa037c5878d
addForwardingFollower
 void addForwardingFollower(LearnerHandler lh)
{    synchronized (forwardingFollowers) {        forwardingFollowers.add(lh);    }}
3543d3c874a75fa8b4039c2276f009cab35246ed69fad1c9c894d31bf3605157
getObservingLearners
public List<LearnerHandler> getObservingLearners()
{    synchronized (observingLearners) {        return new ArrayList<LearnerHandler>(observingLearners);    }}
71802befa9a80f5ed1597c6b81aa0a5464ebc13646801c15fc268837d469c65d
addObserverLearnerHandler
private void addObserverLearnerHandler(LearnerHandler lh)
{    synchronized (observingLearners) {        observingLearners.add(lh);    }}
c0819328e1fbeeebe96db0120be7cb25e00ea035a8137048f3c31f379aaf27a7
getObservingLearnersInfo
public Iterable<Map<String, Object>> getObservingLearnersInfo()
{    Set<Map<String, Object>> info = new HashSet<>();    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            info.add(lh.getLearnerHandlerInfo());        }    }    return info;}
bd4a022dd78d31e1264024c16d58f0c3401530d6762e8226c308883687af1d76
resetObserverConnectionStats
public void resetObserverConnectionStats()
{    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            lh.resetObserverConnectionStats();        }    }}
8554de6a359409f376c515867370e989487005a61222ced9d763b6f802b10b18
getNumPendingSyncs
public synchronized int getNumPendingSyncs()
{    return pendingSyncs.size();}
35ec07c95a6355550c76bf311be7e44ed6084c520fbd0f7429326318ab8cfca0
addLearnerHandler
public void addLearnerHandler(LearnerHandler learner)
{    synchronized (learners) {        learners.add(learner);    }}
4e94073f77b0f46356d18b0b2f339b4eed2985fc338a3262a28653ccd9d02eec
removeLearnerHandler
public void removeLearnerHandler(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        forwardingFollowers.remove(peer);    }    synchronized (learners) {        learners.remove(peer);    }    synchronized (observingLearners) {        observingLearners.remove(peer);    }}
27b3ab4ce9838e82872563059dffd2d4a67e60485859fb5662a0de6d779f6119
isLearnerSynced
 boolean isLearnerSynced(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        return forwardingFollowers.contains(peer);    }}
a8f3087165b9d412406adaa5601298d0a749ab84582df7fbe9dfd6fcc02a981a
isQuorumSynced
public boolean isQuorumSynced(QuorumVerifier qv)
{    HashSet<Long> ids = new HashSet<Long>();    if (qv.getVotingMembers().containsKey(self.getId())) {        ids.add(self.getId());    }    synchronized (forwardingFollowers) {        for (LearnerHandler learnerHandler : forwardingFollowers) {            if (learnerHandler.synced() && qv.getVotingMembers().containsKey(learnerHandler.getSid())) {                ids.add(learnerHandler.getSid());            }        }    }    return qv.containsQuorum(ids);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!stop) {            Socket s = null;            boolean error = false;            try {                s = ss.accept();                                                s.setSoTimeout(self.tickTime * self.initLimit);                s.setTcpNoDelay(nodelay);                BufferedInputStream is = new BufferedInputStream(s.getInputStream());                LearnerHandler fh = new LearnerHandler(s, is, Leader.this);                fh.start();            } catch (SocketException e) {                error = true;                if (stop) {                    LOG.info("exception while shutting down acceptor: " + e);                                                                                stop = true;                } else {                    throw e;                }            } catch (SaslException e) {                LOG.error("Exception while connecting to quorum learner", e);                error = true;            } catch (Exception e) {                error = true;                throw e;            } finally {                                if (error && s != null && !s.isClosed()) {                    try {                        s.close();                    } catch (IOException e) {                        LOG.warn("Error closing socket", e);                    }                }            }        }    } catch (Exception e) {        LOG.warn("Exception while accepting follower", e.getMessage());        handleException(this.getName(), e);    }}
09eaf0ae5188f6f2b67a395d40350eaef55fcab24a60bddfabdfe951df9354c8
halt
public void halt()
{    stop = true;}
5d0ba75a6b8eae682c0c19de1919b94078bcaeb61093a692fb66268a58d6351f
getUptime
public long getUptime()
{    if (leaderStartTime > 0) {        return Time.currentElapsedTime() - leaderStartTime;    }    return 0;}
1fe48b350f5f7f38c891e0a51de35a28b06841dcf31d0c988c1da6d392820b1f
lead
 void lead() throws IOException, InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);    LOG.info("LEADING - LEADER ELECTION TOOK - {} {}", electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);    self.start_fle = 0;    self.end_fle = 0;    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        self.tick.set(0);        zk.loadData();        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());                        cnxAcceptor = new LearnerCnxAcceptor();        cnxAcceptor.start();        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));        synchronized (this) {            lastProposed = zk.getZxid();        }        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {            LOG.info("NEWLEADER proposal has Zxid of " + Long.toHexString(newLeaderProposal.packet.getZxid()));        }        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        QuorumVerifier curQV = self.getQuorumVerifier();        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {                        try {                QuorumVerifier newQV = self.configFromString(curQV.toString());                newQV.setVersion(zk.getZxid());                self.setLastSeenQuorumVerifier(newQV, true);            } catch (Exception e) {                throw new IOException(e);            }        }        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }                                waitForEpochAck(self.getId(), leaderStateSummary);        self.setCurrentEpoch(epoch);        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getId());        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);        try {            waitForNewLeaderAck(self.getId(), zk.getZxid());        } catch (InterruptedException e) {            shutdown("Waiting for a quorum of followers, only synced with sids: [ " + newLeaderProposal.ackSetsToString() + " ]");            HashSet<Long> followerSet = new HashSet<Long>();            for (LearnerHandler f : getLearners()) {                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {                    followerSet.add(f.getSid());                }            }            boolean initTicksShouldBeIncreased = true;            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {                    initTicksShouldBeIncreased = false;                    break;                }            }            if (initTicksShouldBeIncreased) {                LOG.warn("Enough followers present. " + "Perhaps the initTicks need to be increased.");            }            return;        }        startZkServer();        /**         * WARNING: do not use this for anything other than QA testing         * on a real cluster. Specifically to enable verification that quorum         * can handle the lower 32bit roll-over issue identified in         * ZOOKEEPER-1277. Without this option it would take a very long         * time (on order of a month say) to see the 4 billion writes         * necessary to cause the roll-over to occur.         *         * This field allows you to override the zxid of the server. Typically         * you'll want to set it to something like 0xfffffff0 and then         * start the quorum, run some operations and see the re-election.         */        String initialZxid = System.getProperty("zookeeper.testingonly.initialZxid");        if (initialZxid != null) {            long zxid = Long.parseLong(initialZxid);            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);        }        if (!System.getProperty("zookeeper.leaderServes", "yes").equals("no")) {            self.setZooKeeperServer(zk);        }        self.setZabState(QuorumPeer.ZabState.BROADCAST);        self.adminServer.setZooKeeperServer(zk);                                                                                boolean tickSkip = true;                String shutdownMessage = null;        while (true) {            synchronized (this) {                long start = Time.currentElapsedTime();                long cur = start;                long end = start + self.tickTime / 2;                while (cur < end) {                    wait(end - cur);                    cur = Time.currentElapsedTime();                }                if (!tickSkip) {                    self.tick.incrementAndGet();                }                                                                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());                }                syncedAckSet.addAck(self.getId());                for (LearnerHandler f : getLearners()) {                    if (f.synced()) {                        syncedAckSet.addAck(f.getSid());                    }                }                                if (!this.isRunning()) {                                        shutdownMessage = "Unexpected internal error";                    break;                }                if (!tickSkip && !syncedAckSet.hasAllQuorums()) {                                                            shutdownMessage = "Not sufficient followers synced, only synced with sids: [ " + syncedAckSet.ackSetsToString() + " ]";                    break;                }                tickSkip = !tickSkip;            }            for (LearnerHandler f : getLearners()) {                f.ping();            }        }        if (shutdownMessage != null) {            shutdown(shutdownMessage);                }    } finally {        zk.unregisterJMX(this);    }}
5ee41a1c7b4577c5c9b6ebd43881eec2a74fe3b593aec45ab5a9c343d766f7cd
shutdown
 void shutdown(String reason)
{    LOG.info("Shutting down");    if (isShutdown) {        return;    }    LOG.info("Shutdown called", new Exception("shutdown Leader! reason: " + reason));    if (cnxAcceptor != null) {        cnxAcceptor.halt();    }        self.setZooKeeperServer(null);    self.adminServer.setZooKeeperServer(null);    try {        ss.close();    } catch (IOException e) {        LOG.warn("Ignoring unexpected exception during close", e);    }    self.closeAllConnections();        if (zk != null) {        zk.shutdown();    }    synchronized (learners) {        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {            LearnerHandler f = it.next();            it.remove();            f.shutdown();        }    }    isShutdown = true;}
6e57cdae4af0030cfa1b79c076445e466969202b08e3f6c661e21980c0b9092e
getDesignatedLeader
private long getDesignatedLeader(Proposal reconfigProposal, long zxid)
{        Proposal.QuorumVerifierAcksetPair newQVAcksetPair = reconfigProposal.qvAcksetPairs.get(reconfigProposal.qvAcksetPairs.size() - 1);        if (newQVAcksetPair.getQuorumVerifier().getVotingMembers().containsKey(self.getId()) && newQVAcksetPair.getQuorumVerifier().getVotingMembers().get(self.getId()).addr.equals(self.getQuorumAddress())) {        return self.getId();    }                HashSet<Long> candidates = new HashSet<Long>(newQVAcksetPair.getAckset());        candidates.remove(self.getId());    long curCandidate = candidates.iterator().next();            long curZxid = zxid + 1;    Proposal p = outstandingProposals.get(curZxid);    while (p != null && !candidates.isEmpty()) {        for (Proposal.QuorumVerifierAcksetPair qvAckset : p.qvAcksetPairs) {                        candidates.retainAll(qvAckset.getAckset());                        if (candidates.isEmpty()) {                return curCandidate;            }                        curCandidate = candidates.iterator().next();            if (candidates.size() == 1) {                return curCandidate;            }        }        curZxid++;        p = outstandingProposals.get(curZxid);    }    return curCandidate;}
87fc243608d938403c82eb4671b7a2a59b669e0a42af0deef04b4f83ae747c1d
tryToCommit
public synchronized boolean tryToCommit(Proposal p, long zxid, SocketAddress followerAddr)
{        if (outstandingProposals.containsKey(zxid - 1)) {        return false;    }        if (!p.hasAllQuorums()) {        return false;    }        if (zxid != lastCommitted + 1) {        LOG.warn("Commiting zxid 0x" + Long.toHexString(zxid) + " from " + followerAddr + " not first!");        LOG.warn("First is " + (lastCommitted + 1));    }    outstandingProposals.remove(zxid);    if (p.request != null) {        toBeApplied.add(p);    }    if (p.request == null) {        LOG.warn("Going to commmit null: " + p);    } else if (p.request.getHdr().getType() == OpCode.reconfig) {        LOG.debug("Committing a reconfiguration! {}", outstandingProposals.size());                                        Long designatedLeader = getDesignatedLeader(p, zxid);                QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);        if (designatedLeader != self.getId()) {            allowedToCommit = false;        }                                commitAndActivate(zxid, designatedLeader);        informAndActivate(p, designatedLeader);        } else {        p.request.logLatency(ServerMetrics.getMetrics().QUORUM_ACK_LATENCY);        commit(zxid);        inform(p);    }    zk.commitProcessor.commit(p.request);    if (pendingSyncs.containsKey(zxid)) {        for (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {            sendSync(r);        }    }    return true;}
96649a3a8bf25f9482131ed56681511bd5b48fe47d06f66149e17a39c21991e8
processAck
public synchronized void processAck(long sid, long zxid, SocketAddress followerAddr)
{    if (!allowedToCommit) {                return;    }        if (LOG.isTraceEnabled()) {        LOG.trace("Ack zxid: 0x{}", Long.toHexString(zxid));        for (Proposal p : outstandingProposals.values()) {            long packetZxid = p.packet.getZxid();            LOG.trace("outstanding proposal: 0x{}", Long.toHexString(packetZxid));        }        LOG.trace("outstanding proposals all");    }    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack with this method. However,             * the learner sends an ack back to the leader after it gets             * UPTODATE, so we just ignore the message.             */        return;    }    if (outstandingProposals.size() == 0) {        LOG.debug("outstanding is 0");        return;    }    if (lastCommitted >= zxid) {        if (LOG.isDebugEnabled()) {            LOG.debug("proposal has already been committed, pzxid: 0x{} zxid: 0x{}", Long.toHexString(lastCommitted), Long.toHexString(zxid));        }                return;    }    Proposal p = outstandingProposals.get(zxid);    if (p == null) {        LOG.warn("Trying to commit future proposal: zxid 0x{} from {}", Long.toHexString(zxid), followerAddr);        return;    }    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));    }    p.addAck(sid);    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {        long curZxid = zxid;        while (allowedToCommit && hasCommitted && p != null) {            curZxid++;            p = outstandingProposals.get(curZxid);            if (p != null) {                hasCommitted = tryToCommit(p, curZxid, null);            }        }    }}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    next.processRequest(request);        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        Iterator<Proposal> iter = leader.toBeApplied.iterator();        if (iter.hasNext()) {            Proposal p = iter.next();            if (p.request != null && p.request.zxid == zxid) {                iter.remove();                return;            }        }        LOG.error("Committed request not found on toBeApplied: " + request);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    next.shutdown();}
07cf12ca841bbba43e94b3bacc6fcfe0f38c8f024140750aba984fa629e98e19
sendPacket
 void sendPacket(QuorumPacket qp)
{    synchronized (forwardingFollowers) {        for (LearnerHandler f : forwardingFollowers) {            f.queuePacket(qp);        }    }}
5bb1bf7eb7c3a1ac4939c1cb5cac830d9eb5633c441176e896cfdf90d72018f3
sendObserverPacket
 void sendObserverPacket(QuorumPacket qp)
{    for (LearnerHandler f : getObservingLearners()) {        f.queuePacket(qp);    }}
cbede01f4eed780706cdb555227e3c8dd11c38cde15c4c774981e6c8bdbdbf62
commit
public void commit(long zxid)
{    synchronized (this) {        lastCommitted = zxid;    }    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);    sendPacket(qp);    ServerMetrics.getMetrics().COMMIT_COUNT.add(1);}
5d04ba554d22a1d28caa04582007417beca0e57942112dab9b3371cf0dd8826c
commitAndActivate
public void commitAndActivate(long zxid, long designatedLeader)
{    synchronized (this) {        lastCommitted = zxid;    }    byte[] data = new byte[8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    QuorumPacket qp = new QuorumPacket(Leader.COMMITANDACTIVATE, zxid, data, null);    sendPacket(qp);}
c981fc0c9275b7fa80b3302f39106b477b44e97b28c7626fdc077236f3c819f2
inform
public void inform(Proposal proposal)
{    QuorumPacket qp = new QuorumPacket(Leader.INFORM, proposal.request.zxid, proposal.packet.getData(), null);    sendObserverPacket(qp);}
134559e25a429d5bc7a9a3f568a2168bf4f180a11c1e0b4987c6824c41f7ac0c
buildInformAndActivePacket
public static QuorumPacket buildInformAndActivePacket(long zxid, long designatedLeader, byte[] proposalData)
{    byte[] data = new byte[proposalData.length + 8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    buffer.put(proposalData);    return new QuorumPacket(Leader.INFORMANDACTIVATE, zxid, data, null);}
0dc983b1df525ade22c8f85d6ff7c60af84f18c33e84ef408493e4b4334b0792
informAndActivate
public void informAndActivate(Proposal proposal, long designatedLeader)
{    sendObserverPacket(buildInformAndActivePacket(proposal.request.zxid, designatedLeader, proposal.packet.getData()));}
0440447f13d488a15bc2cca6d567d3ec1b92b2b99769cff21daf5b2c0b155a8c
getLastProposed
public synchronized long getLastProposed()
{    return lastProposed;}
586e981b68952128e7b531d3cb6994d5ed31bafd03343c05932c9173a82c6c97
getEpoch
public long getEpoch()
{    return ZxidUtils.getEpochFromZxid(lastProposed);}
42e7b4ae933bcc33c5f6c16669ca75e1dd1ad3237fbe8562dbda74ba7aa09780
propose
public Proposal propose(Request request) throws XidRolloverException
{    /**     * Address the rollover issue. All lower 32bits set indicate a new leader     * election. Force a re-election instead. See ZOOKEEPER-1277     */    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {        String msg = "zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start";        shutdown(msg);        throw new XidRolloverException(msg);    }    byte[] data = SerializeUtils.serializeRequest(request);    proposalStats.setLastBufferSize(data.length);    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);    Proposal p = new Proposal();    p.packet = pp;    p.request = request;    synchronized (this) {        p.addQuorumVerifier(self.getQuorumVerifier());        if (request.getHdr().getType() == OpCode.reconfig) {            self.setLastSeenQuorumVerifier(request.qv, true);        }        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }        LOG.debug("Proposing:: {}", request);        lastProposed = p.packet.getZxid();        outstandingProposals.put(lastProposed, p);        sendPacket(pp);    }    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);    return p;}
af6e0518f61171115e0b0fa082a00a71b95ef676f39fd0b522988a6becb1e959
processSync
public synchronized void processSync(LearnerSyncRequest r)
{    if (outstandingProposals.isEmpty()) {        sendSync(r);    } else {        List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);        if (l == null) {            l = new ArrayList<LearnerSyncRequest>();        }        l.add(r);        pendingSyncs.put(lastProposed, l);    }}
d61bcfec2844b223072a6a0a5ad543a71406cd4121ec8d3f73cd3aaa6241ced8
sendSync
public void sendSync(LearnerSyncRequest r)
{    QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);    r.fh.queuePacket(qp);}
002b0c656de65343d3bf204168ae2436211bc9fc0b957e173f0cb0c62c763200
startForwarding
public synchronized long startForwarding(LearnerHandler handler, long lastSeenZxid)
{        if (lastProposed > lastSeenZxid) {        for (Proposal p : toBeApplied) {            if (p.packet.getZxid() <= lastSeenZxid) {                continue;            }            handler.queuePacket(p.packet);                                    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet.getZxid(), null, null);            handler.queuePacket(qp);        }                if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            List<Long> zxids = new ArrayList<Long>(outstandingProposals.keySet());            Collections.sort(zxids);            for (Long zxid : zxids) {                if (zxid <= lastSeenZxid) {                    continue;                }                handler.queuePacket(outstandingProposals.get(zxid).packet);            }        }    }    if (handler.getLearnerType() == LearnerType.PARTICIPANT) {        addForwardingFollower(handler);    } else {        addObserverLearnerHandler(handler);    }    return lastProposed;}
188db1c46c470d572ad6a01e2d26ef7e8e1f31462c3e431be76b48a3a5958d13
waitForStartup
public void waitForStartup() throws InterruptedException
{    synchronized (zk) {        while (!zk.isRunning() && !Thread.currentThread().isInterrupted()) {            zk.wait(20);        }    }}
bf8ffd87d27a149f0aee684bc2ae0fbc0e3f543a8bfcb579f957894c4a23164f
setMaxTimeToWaitForEpoch
public static void setMaxTimeToWaitForEpoch(int maxTimeToWaitForEpoch)
{    Leader.maxTimeToWaitForEpoch = maxTimeToWaitForEpoch;    LOG.info("Set {} to {}ms", MAX_TIME_TO_WAIT_FOR_EPOCH, Leader.maxTimeToWaitForEpoch);}
2df7c9fa40220c34c80e89b7bbcbc32b4e3f5fc809658399a452ffefd00f5db0
quitLeading
private void quitLeading()
{    synchronized (connectingFollowers) {        quitWaitForEpoch = true;        connectingFollowers.notifyAll();    }    ServerMetrics.getMetrics().QUIT_LEADING_DUE_TO_DISLOYAL_VOTER.add(1);    LOG.info("Quit leading due to voter changed mind.");}
a1fd6e59eba004a672f0ccb27f4e3ca5a7974612de42fbb5cb5945e019a97a56
setLeadingVoteSet
public void setLeadingVoteSet(SyncedLearnerTracker voteSet)
{    this.voteSet = voteSet;}
e4506be0ea4f4c095b4eebe28abef4a45e0cc8f8fe59856583410d68960da317
reportLookingSid
public void reportLookingSid(long sid)
{    if (maxTimeToWaitForEpoch < 0 || timeStartWaitForEpoch < 0 || !waitingForNewEpoch) {        return;    }    if (voteSet == null || !voteSet.hasSid(sid)) {        return;    }    if (Time.currentElapsedTime() - timeStartWaitForEpoch > maxTimeToWaitForEpoch) {        quitLeading();    }}
d076b9d95cbcaa2c669b84eed1dd41044e30d802e782eb9f609bac00a8f114da
getEpochToPropose
public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    synchronized (connectingFollowers) {        if (!waitingForNewEpoch) {            return epoch;        }        if (lastAcceptedEpoch >= epoch) {            epoch = lastAcceptedEpoch + 1;        }        if (isParticipant(sid)) {            connectingFollowers.add(sid);        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) {            waitingForNewEpoch = false;            self.setAcceptedEpoch(epoch);            connectingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            if (sid == self.getId()) {                timeStartWaitForEpoch = start;            }            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (waitingForNewEpoch && cur < end && !quitWaitForEpoch) {                connectingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (waitingForNewEpoch) {                throw new InterruptedException("Timeout while waiting for epoch from quorum");            }        }        return epoch;    }}
0a398a5b161acf7b53049b13c6b7c236f158603b5bc782af221df9037a70dec0
getZKDatabase
public ZKDatabase getZKDatabase()
{    return zk.getZKDatabase();}
6bc988789da5c4d940c581d16998b59ef3b1c5e630d6783e599c67253ac16091
waitForEpochAck
public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException
{    synchronized (electingFollowers) {        if (electionFinished) {            return;        }        if (ss.getCurrentEpoch() != -1) {            if (ss.isMoreRecentThan(leaderStateSummary)) {                throw new IOException("Follower is ahead of the leader, leader summary: " + leaderStateSummary.getCurrentEpoch() + " (current epoch), " + leaderStateSummary.getLastZxid() + " (last zxid)");            }            if (ss.getLastZxid() != -1 && isParticipant(id)) {                electingFollowers.add(id);            }        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {            electionFinished = true;            electingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!electionFinished && cur < end) {                electingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!electionFinished) {                throw new InterruptedException("Timeout while waiting for epoch to be acked by quorum");            }        }    }}
3783dd02b1860bde7b7e723eb12b004212ffb9c640d1833990613cfd439380c2
getSidSetString
private String getSidSetString(Set<Long> sidSet)
{    StringBuilder sids = new StringBuilder();    Iterator<Long> iter = sidSet.iterator();    while (iter.hasNext()) {        sids.append(iter.next());        if (!iter.hasNext()) {            break;        }        sids.append(",");    }    return sids.toString();}
250b62928e62740754dd9597f178a7dc42f706baeb7a5961846e6b637f63dc01
startZkServer
private synchronized void startZkServer()
{        lastCommitted = zk.getZxid();    LOG.info("Have quorum of supporters, sids: [{}]; starting up and setting last processed zxid: 0x{}", newLeaderProposal.ackSetsToString(), Long.toHexString(zk.getZxid()));    /*         * ZOOKEEPER-1324. the leader sends the new config it must complete         *  to others inside a NEWLEADER message (see LearnerHandler where         *  the NEWLEADER message is constructed), and once it has enough         *  acks we must execute the following code so that it applies the         *  config to itself.         */    QuorumVerifier newQV = self.getLastSeenQuorumVerifier();    Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());    self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);    if (designatedLeader != self.getId()) {        allowedToCommit = false;    }    leaderStartTime = Time.currentElapsedTime();    zk.startup();    /*         * Update the election vote here to ensure that all members of the         * ensemble report the same vote to new servers that start up and         * send leader election notifications to the ensemble.         *         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732         */    self.updateElectionVote(getEpoch());    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());}
74d45323f0f04253233e826ccfe7e7ce0ba45de56d8da5a43ac697892ed4c9a5
waitForNewLeaderAck
public void waitForNewLeaderAck(long sid, long zxid) throws InterruptedException
{    synchronized (newLeaderProposal.qvAcksetPairs) {        if (quorumFormed) {            return;        }        long currentZxid = newLeaderProposal.packet.getZxid();        if (zxid != currentZxid) {            LOG.error("NEWLEADER ACK from sid: " + sid + " is from a different epoch - current 0x" + Long.toHexString(currentZxid) + " receieved 0x" + Long.toHexString(zxid));            return;        }        /*             * Note that addAck already checks that the learner             * is a PARTICIPANT.             */        newLeaderProposal.addAck(sid);        if (newLeaderProposal.hasAllQuorums()) {            quorumFormed = true;            newLeaderProposal.qvAcksetPairs.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!quorumFormed && cur < end) {                newLeaderProposal.qvAcksetPairs.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!quorumFormed) {                throw new InterruptedException("Timeout while waiting for NEWLEADER to be acked by quorum");            }        }    }}
b3ab21f72930db6d9103366bffbabb3a4027f21926985b9c9dbd97f576187eed
getPacketType
public static String getPacketType(int packetType)
{    switch(packetType) {        case DIFF:            return "DIFF";        case TRUNC:            return "TRUNC";        case SNAP:            return "SNAP";        case OBSERVERINFO:            return "OBSERVERINFO";        case NEWLEADER:            return "NEWLEADER";        case FOLLOWERINFO:            return "FOLLOWERINFO";        case UPTODATE:            return "UPTODATE";        case LEADERINFO:            return "LEADERINFO";        case ACKEPOCH:            return "ACKEPOCH";        case REQUEST:            return "REQUEST";        case PROPOSAL:            return "PROPOSAL";        case ACK:            return "ACK";        case COMMIT:            return "COMMIT";        case COMMITANDACTIVATE:            return "COMMITANDACTIVATE";        case PING:            return "PING";        case REVALIDATE:            return "REVALIDATE";        case SYNC:            return "SYNC";        case INFORM:            return "INFORM";        case INFORMANDACTIVATE:            return "INFORMANDACTIVATE";        default:            return "UNKNOWN";    }}
672f52b075e8fa3b810afb0a97559f16d775a1aa4633101c0c8db18a0336f215
isRunning
private boolean isRunning()
{    return self.isRunning() && zk.isRunning();}
3ca8d058e4357e3a3111f4e4befeb6dfeb9d798693ce3068021aa2fab4b43d7d
isParticipant
private boolean isParticipant(long sid)
{    return self.getQuorumVerifier().getVotingMembers().containsKey(sid);}
ba79b4b278cd146c4f5fcbc0ba9da9fe512b81afa7be9b1a14891b66a72c09cd
getCurrentTick
public int getCurrentTick()
{    return self.tick.get();}
c9197edf852683da0548d07961e6b6ade10e06ef02e8ec9e6ab92be9a64ac6be
syncTimeout
public int syncTimeout()
{    return self.tickTime * self.syncLimit;}
9a5455755f758ee6626544d269e0381aaefda5135e435c71a1731a599b3cf410
getTickOfNextAckDeadline
public int getTickOfNextAckDeadline()
{    return self.tick.get() + self.syncLimit;}
29fd723bb1bdf6e6ad0c2947bb51c15a74288fe3d818d0adc54d4facd2e939a9
getTickOfInitialAckDeadline
public int getTickOfInitialAckDeadline()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
88b57206c2073a75ca47c3c5afd757f93cafa2a8a1eb29ff16417933dab1c75e
getAndDecrementFollowerCounter
public long getAndDecrementFollowerCounter()
{    return followerCounter.getAndDecrement();}
765d1fa0c986ecd405ef14119aab875891b0c300838edd246fb51406c94df2c4
touch
public void touch(long sess, int to)
{    zk.touch(sess, to);}
d9ee00f26e1fe95cdd8c5459d1adef9e43a7d0085545a3edbafc5b28568dc648
submitLearnerRequest
public void submitLearnerRequest(Request si)
{    zk.submitLearnerRequest(si);}
106bd3161febaa7b0eb4f32cdf4eda134c9696c6f58d815dd71c582142105a53
getQuorumVerifierVersion
public long getQuorumVerifierVersion()
{    return self.getQuorumVerifier().getVersion();}
3162a750cefee17242386bc4647d6d48373e8df94493972906a41a5ba733865c
getPeerInfo
public String getPeerInfo(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
192c5d44fd09ac1bd4da4f46915dd6f269c47a6f533a731f4ed98ddda0d213c1
getQuorumVerifierBytes
public byte[] getQuorumVerifierBytes()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
c5bcf0c2c6d34d32e4f8b27728ac683fedfe5d8f9fcaba8628699409a1308d62
getQuorumAuthServer
public QuorumAuthServer getQuorumAuthServer()
{    return (self == null) ? null : self.authServer;}
7dc5f23caa37bbd14810e053c4278869d5392c24b72af71fba6b4b7106ccbb79
revalidateSession
public void revalidateSession(QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);    boolean valid = zk.checkIfValidGlobalSession(id, to);    if (valid) {        try {                        zk.setOwner(id, learnerHandler);        } catch (KeeperException.SessionExpiredException e) {            LOG.error("Somehow session " + Long.toHexString(id) + " expired right after being renewed! (impossible)", e);        }    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(id) + " is valid: " + valid);    }    dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    learnerHandler.queuePacket(qp);}
289ed63ad09752b2fe747baadc2b964801ce6c5a5dce8bf02946f0ba223f6338
registerLearnerHandlerBean
public void registerLearnerHandlerBean(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zk.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
d5db1f05b74ae1ce7bdd253bb3825aa85838b37964ba00e3b2ebb734ea63075d
unregisterLearnerHandlerBean
public void unregisterLearnerHandlerBean(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "Leader";}
00832b7df1f6e9d4175b1e996264918ba18b1a4615513e0051c682151be8ba67
getCurrentZxid
public String getCurrentZxid()
{    return "0x" + Long.toHexString(zks.getZxid());}
c82ca8b3a4405dd9274f8f3c8d72d6d82acf7c41dfdf4eb3196fd79100c23d46
followerInfo
public String followerInfo()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getLearners()) {        if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            sb.append(handler.toString()).append("\n");        }    }    return sb.toString();}
6d1043a40a172c05447d88fc11981b23e5edc37a3db79c47f51c21edb53a3ec1
nonVotingFollowerInfo
public String nonVotingFollowerInfo()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getNonVotingFollowers()) {        sb.append(handler.toString()).append("\n");    }    return sb.toString();}
592984bb8fd8dfd3780dbc7c311474353ec225fb0536322775403dfe8fa59279
getElectionTimeTaken
public long getElectionTimeTaken()
{    return leader.self.getElectionTimeTaken();}
bf03b548bab14a08b7f49bd62f081779fca4d70303f9131bbaf4282970481816
getLastProposalSize
public int getLastProposalSize()
{    return leader.getProposalStats().getLastBufferSize();}
18c7645dd44816a1188287e0c39f396e5914d4e38fb90a290b248791334b3b4e
getMinProposalSize
public int getMinProposalSize()
{    return leader.getProposalStats().getMinBufferSize();}
e9dcd33d7bfca0b85fa7fa549f8ee4fcfe6851caca072a9cb527404164fda815
getMaxProposalSize
public int getMaxProposalSize()
{    return leader.getProposalStats().getMaxBufferSize();}
17c33a302f7c5ddb1e52da065d22a04e53ab79ad97c1582675879d1b840cec7f
resetProposalStatistics
public void resetProposalStatistics()
{    leader.getProposalStats().reset();}
effe2b111b7d2562cb0579bb71ecb9e5964e69a42c011dc9ea78bb86cbfe3bbc
getMaxConcurrentSnapSyncs
public int getMaxConcurrentSnapSyncs()
{    return leader.getMaxConcurrentSnapSyncs();}
cb1d390c7a3687ba726bebd8f64624aacd1984a4bf7cedc86ba6980f011651e2
setMaxConcurrentSnapSyncs
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapshots)
{    leader.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);}
9963f5c3c27beaab3c6b73119e3b7a1832f0baf79b14c48c03a2c619c130f6b3
getMaxConcurrentDiffSyncs
public int getMaxConcurrentDiffSyncs()
{    return leader.getMaxConcurrentDiffSyncs();}
ba7ab6209f111504ffe99a89df6f0d58357c239068d0c1c59b8d99cb86f9e0d5
setMaxConcurrentDiffSyncs
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{    leader.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "LeaderElection";}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
8303d5084d47fc5be0af240478176fb41cfc08788476e7a91d731842a77de2c9
getStartTime
public String getStartTime()
{    return startTime.toString();}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{        if (!lzks.authWriteRequest(request)) {        return;    }            Request upgradeRequest = null;    try {        upgradeRequest = lzks.checkUpgradeSession(request);    } catch (KeeperException ke) {        if (request.getHdr() != null) {            LOG.debug("Updating header");            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(ke.code().intValue()));        }        request.setException(ke);        LOG.info("Error creating upgrade request " + ke.getMessage());    } catch (IOException ie) {        LOG.error("Unexpected error in upgrade", ie);    }    if (upgradeRequest != null) {        nextProcessor.processRequest(upgradeRequest);    }    nextProcessor.processRequest(request);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    nextProcessor.shutdown();}
6055190cbe55525602a491409aa248706ec1074de2c17a49b4594a9de615633e
removeSession
public void removeSession(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionTracker.removeSession(sessionId);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    globalSessionTracker.start();    if (localSessionTracker != null) {        localSessionTracker.start();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }    globalSessionTracker.shutdown();}
98f9ba8d684113c948c79428852e77290b44a1aae4e73fd15f26ac1b0853fd3b
isGlobalSession
public boolean isGlobalSession(long sessionId)
{    return globalSessionTracker.isTrackingSession(sessionId);}
b60a5dfc3d8d915a881d21dcbf09d7f87c896a7898d7782d0a68a38bebb43061
trackSession
public boolean trackSession(long sessionId, int sessionTimeout)
{    boolean tracked = globalSessionTracker.trackSession(sessionId, sessionTimeout);    if (localSessionsEnabled && tracked) {                        LOG.info("Tracking global session 0x" + Long.toHexString(sessionId));    }    return tracked;}
4a19be9b5864bc17252345f8308f0f92216a0527e01bac5454ee28ac731700f8
commitSession
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    boolean added = globalSessionTracker.commitSession(sessionId, sessionTimeout);    if (added) {        LOG.info("Committing global session 0x" + Long.toHexString(sessionId));    }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    return added;}
7e5a4e6298052c4653ec1b80ed2336b41d598fd29f3e851ef1b7c09116eecf28
touchSession
public boolean touchSession(long sessionId, int sessionTimeout)
{    if (localSessionTracker != null && localSessionTracker.touchSession(sessionId, sessionTimeout)) {        return true;    }    return globalSessionTracker.touchSession(sessionId, sessionTimeout);}
26a20a147958953e3c25a582180e937ad56ac181b2ec844d0de659c5027d7c8a
createSession
public long createSession(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return globalSessionTracker.createSession(sessionTimeout);}
e2c2a8430b234cda675db3c10143b76e6679fd80ee6bf62da902e67e354a420f
getServerIdFromSessionId
public static long getServerIdFromSessionId(long sessionId)
{    return sessionId >> 56;}
d2fd93557910350f0012cd1b7e20486db54f43321daf681cc9578c9305e8e2c3
checkSession
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException, UnknownSessionException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);                        if (!isGlobalSession(sessionId)) {                return;            }        } catch (UnknownSessionException e) {                }    }    try {        globalSessionTracker.checkSession(sessionId, owner);                return;    } catch (UnknownSessionException e) {        }    /*         * if local session is not enabled or it used to be our local session         * throw sessions expires         */    if (!localSessionsEnabled || (getServerIdFromSessionId(sessionId) == serverId)) {        throw new SessionExpiredException();    }}
cb073a7fdc6bdfbc54fe1d4b8a18afb6f4becf4998e9c934ff8df4077de87ae9
checkGlobalSession
public void checkGlobalSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    try {        globalSessionTracker.checkSession(sessionId, owner);    } catch (UnknownSessionException e) {                throw new SessionExpiredException();    }}
cd23fd4918aedacaa73ac08b382d3549730a0537c44f12f6de6c49f7d647f462
setOwner
public void setOwner(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                }    }    globalSessionTracker.setOwner(sessionId, owner);}
059bdb7fdfcd8a7cc5ac1afcbadf7c985185ac6be02df299e669a9effa7195ce
dumpSessions
public void dumpSessions(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);        pwriter.print("Global ");    }    globalSessionTracker.dumpSessions(pwriter);}
1183d8f3ef078b53b34ad1087fd0509544c0642f748a8d1e078c40dad3e6e92b
setSessionClosing
public void setSessionClosing(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }    globalSessionTracker.setSessionClosing(sessionId);}
3af14c5b72bdfc3edf46603772a1f71ddd60055b7766802e1ca02228886adc63
getSessionExpiryMap
public Map<Long, Set<Long>> getSessionExpiryMap()
{    Map<Long, Set<Long>> sessionExpiryMap;        if (localSessionTracker != null) {        sessionExpiryMap = localSessionTracker.getSessionExpiryMap();    } else {        sessionExpiryMap = new TreeMap<Long, Set<Long>>();    }    sessionExpiryMap.putAll(globalSessionTracker.getSessionExpiryMap());    return sessionExpiryMap;}
8b10ddb3e9687dbebf5b147f95db368d22328349ea4550dfcb22259971f0a3d5
getLeader
public Leader getLeader()
{    return self.leader;}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);    setupContainerManager();}
9e4b10cb6d65f0bd10358f8a619a36f2d7a780a63b2d88e3c35d166f62214f1b
setupContainerManager
private synchronized void setupContainerManager()
{    containerManager = new ContainerManager(getZKDatabase(), prepRequestProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));}
da36f3b9d36ac447eb82095d5bedab6921b56e31fcb45bf35d22208f35f9d226
startup
public synchronized void startup()
{    super.startup();    if (containerManager != null) {        containerManager.start();    }}
79285532c7fb8fc78a40e7457ab3382e4f205c333dc4a989a8d9deb0895c344b
registerMetrics
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("learners", () -> {        return getLeader().getLearners().size();    });    rootContext.registerGauge("synced_followers", () -> {        return getLeader().getForwardingFollowers().size();    });    rootContext.registerGauge("synced_non_voting_followers", () -> {        return getLeader().getNonVotingFollowers().size();    });    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);    rootContext.registerGauge("pending_syncs", () -> {        return getLeader().getNumPendingSyncs();    });    rootContext.registerGauge("leader_uptime", () -> {        return getLeader().getUptime();    });    rootContext.registerGauge("last_proposal_size", () -> {        return getLeader().getProposalStats().getLastBufferSize();    });    rootContext.registerGauge("max_proposal_size", () -> {        return getLeader().getProposalStats().getMaxBufferSize();    });    rootContext.registerGauge("min_proposal_size", () -> {        return getLeader().getProposalStats().getMinBufferSize();    });}
7a1592c7f6f4561e51579c42c380094baff7002d616a43b17459fdd0f834dec2
unregisterMetrics
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("learners");    rootContext.unregisterGauge("synced_followers");    rootContext.unregisterGauge("synced_non_voting_followers");    rootContext.unregisterGauge("synced_observers");    rootContext.unregisterGauge("pending_syncs");    rootContext.unregisterGauge("leader_uptime");    rootContext.unregisterGauge("last_proposal_size");    rootContext.unregisterGauge("max_proposal_size");    rootContext.unregisterGauge("min_proposal_size");}
adee6d577ad1124bcdd55d9356083ab1be7b96b41b09ad125a756c3523b15a7e
shutdown
public synchronized void shutdown()
{    if (containerManager != null) {        containerManager.stop();    }    super.shutdown();}
c9038b65c2f4fbf257d00190088ff8420d485b048bbe0d78c9f47f278fd55fbe
getGlobalOutstandingLimit
public int getGlobalOutstandingLimit()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
a6fb3fd47d2002c10e5c5307384249f559df942b1ae57f305136a504c7f36ca4
createSessionTracker
public void createSessionTracker()
{    sessionTracker = new LeaderSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
7296579fef81451da0e89bb183f986b43fd80982a75ecbc4c59f1e7c78cd930c
touch
public boolean touch(long sess, int to)
{    return sessionTracker.touchSession(sess, to);}
cd409510a0341d63fd29cf9cbf66947c837e7bb7fa6943b19931d44b36e2a819
checkIfValidGlobalSession
public boolean checkIfValidGlobalSession(long sess, int to)
{    if (self.areLocalSessionsEnabled() && !upgradeableSessionTracker.isGlobalSession(sess)) {        return false;    }    return sessionTracker.touchSession(sess, to);}
88c1e073d88488896ca3a51067de11dbb36f49425c9db550637348aedc13379c
submitLearnerRequest
public void submitLearnerRequest(Request request)
{    /*         * Requests coming from the learner should have gone through         * submitRequest() on each server which already perform some request         * validation, so we don't need to do it again.         *         * Additionally, LearnerHandler should start submitting requests into         * the leader's pipeline only when the leader's server is started, so we         * can submit the request directly into PrepRequestProcessor.         *         * This is done so that requests from learners won't go through         * LeaderRequestProcessor which perform local session upgrade.         */    prepRequestProcessor.processRequest(request);}
e6f3bb16f7c86279ca0b0f6bdfc4ca1bbf019bd9710ded3d2320084bbedcc6a2
registerJMX
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxDataTreeBean = null;    }}
ac5d98b8bd29506ef50d72a5e87ed431739f18489e80a674e2d20faaaa633366
registerJMX
public void registerJMX(LeaderBean leaderBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {            LOG.warn("Failed to register with JMX", e);        }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = leaderBean;        MBeanRegistry.getInstance().register(leaderBean, localPeerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxServerBean = null;    }}
1c53f5bb5268d005d4ad3fc006e95ba0fa7d119f22fe36cb6129e3a446a2c2b5
registerJMX
 boolean registerJMX(LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {        LOG.warn("Could not register connection", e);    }    return false;}
85e7e25a941f134236cd570c8e63b18ce60539fbd1cc088cec570f9a426f4eb3
unregisterJMX
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxDataTreeBean = null;}
7b188b85f295de7aba2be8771f2ae10c2b7d59c5872c1f1219d3681ca74bb752
unregisterJMX
protected void unregisterJMX(Leader leader)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxServerBean = null;}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return "leader";}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return self.getId();}
8564f0212992ab8be2b48d947902852b2e350a858bf2d3eb3dc193c9cb325f67
revalidateSession
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    super.revalidateSession(cnxn, sessionId, sessionTimeout);    try {                        setOwner(sessionId, ServerCnxn.me);    } catch (SessionExpiredException e) {        }}
2f44c9bdf41048d434bec1c478ddc90b731aabc69d60d679bcc7123c3449ba9b
getSocket
public Socket getSocket()
{    return sock;}
de353d7a71a4343b65d3dbcd9912315a562836782dd398e70452b504063a413a
getPendingRevalidationsCount
public int getPendingRevalidationsCount()
{    return pendingRevalidations.size();}
36b0d328de6ae8d91f097104e77b2efb245eca6f057ae26acab00bb5fc64c256
validateSession
 void validateSession(ServerCnxn cnxn, long clientId, int timeout) throws IOException
{    LOG.info("Revalidating client: 0x" + Long.toHexString(clientId));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(clientId);    dos.writeInt(timeout);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    pendingRevalidations.put(clientId, cnxn);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "To validate session 0x" + Long.toHexString(clientId));    }    writePacket(qp, true);}
e0f349fa3e3119acd373bcc1eab40223a2138b1e3caae22f4e925347425c4127
writePacket
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    synchronized (leaderOs) {        if (pp != null) {            messageTracker.trackSent(pp.getType());            leaderOs.writeRecord(pp, "packet");        }        if (flush) {            bufferedOutput.flush();        }    }}
0b2d868df21f605241f9aa5bf7167efe13965fa9632ba25c4a53608aff82bf36
readPacket
 void readPacket(QuorumPacket pp) throws IOException
{    synchronized (leaderIs) {        leaderIs.readRecord(pp, "packet");        messageTracker.trackReceived(pp.getType());    }    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    if (pp.getType() == Leader.PING) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);    }}
bb1e5df996457e49936e318d2802f7be7c609fdfb0146588041bfc7984ebe904
request
 void request(Request request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream oa = new DataOutputStream(baos);    oa.writeLong(request.sessionId);    oa.writeInt(request.cxid);    oa.writeInt(request.type);    if (request.request != null) {        request.request.rewind();        int len = request.request.remaining();        byte[] b = new byte[len];        request.request.get(b);        request.request.rewind();        oa.write(b);    }    oa.close();    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);    writePacket(qp, true);}
79070af7db730b6aaaa9b66c0f393c36123c405d6dcf30fbb73f94c323ce5069
findLeader
protected QuorumServer findLeader()
{    QuorumServer leaderServer = null;        Vote current = self.getCurrentVote();    for (QuorumServer s : self.getView().values()) {        if (s.id == current.getId()) {                                    s.recreateSocketAddresses();            leaderServer = s;            break;        }    }    if (leaderServer == null) {        LOG.warn("Couldn't find the leader with id = " + current.getId());    }    return leaderServer;}
9fb77193c5f2f0d63c984bf98fb11c8d84c72c7561eb08080678332b977079d6
nanoTime
protected long nanoTime()
{    return System.nanoTime();}
d0ab9a59ba1231ed9d4a3000d9ac29e1f92d486bb793a271f620d3466e95e5fc
sockConnect
protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    sock.connect(addr, timeout);}
c62d51cc5b88546a83a0e42c8c3bb712be58e8d5579649c9b409bb03d1591e35
connectToLeader
protected void connectToLeader(InetSocketAddress addr, String hostname) throws IOException, InterruptedException, X509Exception
{    this.sock = createSocket();    this.leaderAddr = addr;        int connectTimeout = self.tickTime * self.initLimit;        if (self.connectToLearnerMasterLimit > 0) {        connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;    }    int remainingTimeout;    long startNanoTime = nanoTime();    for (int tries = 0; tries < 5; tries++) {        try {                        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 0) {                LOG.error("connectToLeader exceeded on retries.");                throw new IOException("connectToLeader exceeded on retries.");            }            sockConnect(sock, addr, Math.min(connectTimeout, remainingTimeout));            if (self.isSslQuorum()) {                ((SSLSocket) sock).startHandshake();            }            sock.setTcpNoDelay(nodelay);            break;        } catch (IOException e) {            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 1000) {                LOG.error("Unexpected exception, connectToLeader exceeded. tries=" + tries + ", remaining init limit=" + remainingTimeout + ", connecting to " + addr, e);                throw e;            } else if (tries >= 4) {                LOG.error("Unexpected exception, retries exceeded. tries=" + tries + ", remaining init limit=" + remainingTimeout + ", connecting to " + addr, e);                throw e;            } else {                LOG.warn("Unexpected exception, tries=" + tries + ", remaining init limit=" + remainingTimeout + ", connecting to " + addr, e);                this.sock = createSocket();            }        }        Thread.sleep(leaderConnectDelayDuringRetryMs);    }    self.authLearner.authenticate(sock, hostname);    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);}
e5c66a4d493f837cf901474457495127c44ec63b9e21b0e309314efbf8a1f936
createSocket
private Socket createSocket() throws X509Exception, IOException
{    Socket sock;    if (self.isSslQuorum()) {        sock = self.getX509Util().createSSLSocket();    } else {        sock = new Socket();    }    sock.setSoTimeout(self.tickTime * self.initLimit);    return sock;}
55ffbc25a0404b79528f7b51df5a247c025b40b758fd9905670ea007114216a4
registerWithLeader
protected long registerWithLeader(int pktType) throws IOException
{    /*         * Send follower info, including last zxid and sid         */    long lastLoggedZxid = self.getLastLoggedZxid();    QuorumPacket qp = new QuorumPacket();    qp.setType(pktType);    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));    /*         * Add sid to payload         */    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());    ByteArrayOutputStream bsid = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);    boa.writeRecord(li, "LearnerInfo");    qp.setData(bsid.toByteArray());    writePacket(qp, true);    readPacket(qp);    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());    if (qp.getType() == Leader.LEADERINFO) {                leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();        byte[] epochBytes = new byte[4];        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);        if (newEpoch > self.getAcceptedEpoch()) {            wrappedEpochBytes.putInt((int) self.getCurrentEpoch());            self.setAcceptedEpoch(newEpoch);        } else if (newEpoch == self.getAcceptedEpoch()) {                                                            wrappedEpochBytes.putInt(-1);        } else {            throw new IOException("Leaders epoch, " + newEpoch + " is less than accepted epoch, " + self.getAcceptedEpoch());        }        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);        writePacket(ackNewEpoch, true);        return ZxidUtils.makeZxid(newEpoch, 0);    } else {        if (newEpoch > self.getAcceptedEpoch()) {            self.setAcceptedEpoch(newEpoch);        }        if (qp.getType() != Leader.NEWLEADER) {            LOG.error("First packet should have been NEWLEADER");            throw new IOException("First packet should have been NEWLEADER");        }        return qp.getZxid();    }}
ef6e2feeb5db29a339db59b6c036baf12e3347131fbc6c5416f29e26e5280fb4
syncWithLeader
protected void syncWithLeader(long newLeaderZxid) throws Exception
{    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);    QuorumPacket qp = new QuorumPacket();    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);    QuorumVerifier newLeaderQV = null;            boolean snapshotNeeded = true;    boolean syncSnapshot = false;    readPacket(qp);    Deque<Long> packetsCommitted = new ArrayDeque<>();    Deque<PacketInFlight> packetsNotCommitted = new ArrayDeque<>();    synchronized (zk) {        if (qp.getType() == Leader.DIFF) {            LOG.info("Getting a diff from the leader 0x{}", Long.toHexString(qp.getZxid()));            self.setSyncMode(QuorumPeer.SyncMode.DIFF);            snapshotNeeded = false;        } else if (qp.getType() == Leader.SNAP) {            self.setSyncMode(QuorumPeer.SyncMode.SNAP);            LOG.info("Getting a snapshot from leader 0x" + Long.toHexString(qp.getZxid()));                                    zk.getZKDatabase().deserializeSnapshot(leaderIs);                        if (!QuorumPeerConfig.isReconfigEnabled()) {                LOG.debug("Reset config node content from local config after deserialization of snapshot.");                zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());            }            String signature = leaderIs.readString("signature");            if (!signature.equals("BenWasHere")) {                LOG.error("Missing signature. Got " + signature);                throw new IOException("Missing signature");            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());                        syncSnapshot = true;        } else if (qp.getType() == Leader.TRUNC) {                        self.setSyncMode(QuorumPeer.SyncMode.TRUNC);            LOG.warn("Truncating log to get in sync with the leader 0x" + Long.toHexString(qp.getZxid()));            boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());            if (!truncated) {                                LOG.error("Not able to truncate the log " + Long.toHexString(qp.getZxid()));                System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());        } else {            LOG.error("Got unexpected packet from leader: {}, exiting ... ", LearnerHandler.packetToString(qp));            System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());        }        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());        zk.createSessionTracker();        long lastQueued = 0;                                boolean isPreZAB1_0 = true;                        boolean writeToTxnLog = !snapshotNeeded;                outerLoop: while (self.isRunning()) {            readPacket(qp);            switch(qp.getType()) {                case Leader.PROPOSAL:                    PacketInFlight pif = new PacketInFlight();                    pif.hdr = new TxnHeader();                    pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);                    if (pif.hdr.getZxid() != lastQueued + 1) {                        LOG.warn("Got zxid 0x" + Long.toHexString(pif.hdr.getZxid()) + " expected 0x" + Long.toHexString(lastQueued + 1));                    }                    lastQueued = pif.hdr.getZxid();                    if (pif.hdr.getType() == OpCode.reconfig) {                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        self.setLastSeenQuorumVerifier(qv, true);                    }                    packetsNotCommitted.add(pif);                    break;                case Leader.COMMIT:                case Leader.COMMITANDACTIVATE:                    pif = packetsNotCommitted.peekFirst();                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData()));                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (!writeToTxnLog) {                        if (pif.hdr.getZxid() != qp.getZxid()) {                            LOG.warn("Committing " + qp.getZxid() + ", but next proposal is " + pif.hdr.getZxid());                        } else {                            zk.processTxn(pif.hdr, pif.rec);                            packetsNotCommitted.remove();                        }                    } else {                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.INFORM:                case Leader.INFORMANDACTIVATE:                    PacketInFlight packet = new PacketInFlight();                    packet.hdr = new TxnHeader();                    if (qp.getType() == Leader.INFORMANDACTIVATE) {                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());                        long suggestedLeaderId = buffer.getLong();                        byte[] remainingdata = new byte[buffer.remaining()];                        buffer.get(remainingdata);                        packet.rec = SerializeUtils.deserializeTxn(remainingdata, packet.hdr);                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData()));                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    } else {                        packet.rec = SerializeUtils.deserializeTxn(qp.getData(), packet.hdr);                                                if (packet.hdr.getZxid() != lastQueued + 1) {                            LOG.warn("Got zxid 0x" + Long.toHexString(packet.hdr.getZxid()) + " expected 0x" + Long.toHexString(lastQueued + 1));                        }                        lastQueued = packet.hdr.getZxid();                    }                    if (!writeToTxnLog) {                                                zk.processTxn(packet.hdr, packet.rec);                    } else {                        packetsNotCommitted.add(packet);                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.UPTODATE:                    LOG.info("Learner received UPTODATE message");                    if (newLeaderQV != null) {                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (isPreZAB1_0) {                        zk.takeSnapshot(syncSnapshot);                        self.setCurrentEpoch(newEpoch);                    }                    self.setZooKeeperServer(zk);                    self.adminServer.setZooKeeperServer(zk);                    break outerLoop;                case                 Leader.NEWLEADER:                                        LOG.info("Learner received NEWLEADER message");                    if (qp.getData() != null && qp.getData().length > 1) {                        try {                            QuorumVerifier qv = self.configFromString(new String(qp.getData()));                            self.setLastSeenQuorumVerifier(qv, true);                            newLeaderQV = qv;                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                    if (snapshotNeeded) {                        zk.takeSnapshot(syncSnapshot);                    }                    self.setCurrentEpoch(newEpoch);                                        writeToTxnLog = true;                    isPreZAB1_0 = false;                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);                    break;            }        }    }    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));    writePacket(ack, true);    sock.setSoTimeout(self.tickTime * self.syncLimit);    self.setSyncMode(QuorumPeer.SyncMode.NONE);    zk.startup();    /*         * Update the election vote here to ensure that all members of the         * ensemble report the same vote to new servers that start up and         * send leader election notifications to the ensemble.         *         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732         */    self.updateElectionVote(newEpoch);        if (zk instanceof FollowerZooKeeperServer) {        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            fzk.logRequest(p.hdr, p.rec);        }        for (Long zxid : packetsCommitted) {            fzk.commit(zxid);        }    } else if (zk instanceof ObserverZooKeeperServer) {                        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            Long zxid = packetsCommitted.peekFirst();            if (p.hdr.getZxid() != zxid) {                                                LOG.warn("Committing " + Long.toHexString(zxid) + ", but next proposal is " + Long.toHexString(p.hdr.getZxid()));                continue;            }            packetsCommitted.remove();            Request request = new Request(null, p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), null, null);            request.setTxn(p.rec);            request.setHdr(p.hdr);            ozk.commitRequest(request);        }    } else {                throw new UnsupportedOperationException("Unknown server type");    }}
5e7d7e036a946d4227d6b5a917bc6a974eada06ff9d77090cb77eec524e2a6d2
revalidate
protected void revalidate(QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long sessionId = dis.readLong();    boolean valid = dis.readBoolean();    ServerCnxn cnxn = pendingRevalidations.remove(sessionId);    if (cnxn == null) {        LOG.warn("Missing session 0x" + Long.toHexString(sessionId) + " for validation");    } else {        zk.finishSessionInit(cnxn, valid);    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + valid);    }}
7fe218cb32c6f697cf698a23ac3a6bfb0044339ae2e9cef2e81c59ed9f60ff77
ping
protected void ping(QuorumPacket qp) throws IOException
{        ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    Map<Long, Integer> touchTable = zk.getTouchSnapshot();    for (Entry<Long, Integer> entry : touchTable.entrySet()) {        dos.writeLong(entry.getKey());        dos.writeInt(entry.getValue());    }    qp.setData(bos.toByteArray());    writePacket(qp, true);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    self.setZooKeeperServer(null);    self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);    closeSocket();        if (zk != null) {        zk.shutdown();    }}
3b25c3f33ac1e280172b3b80cf45cbcb505d4b1919b5080732263f6404ccb201
isRunning
 boolean isRunning()
{    return self.isRunning() && zk.isRunning();}
a80663ecf8035d6c317e1d3fe19e6bae9422614702eb2125fbec2c3eb714d9d5
closeSocket
 void closeSocket()
{    try {        if (sock != null) {            sock.close();        }    } catch (IOException e) {        LOG.warn("Ignoring error closing connection to leader", e);    }}
2f44c9bdf41048d434bec1c478ddc90b731aabc69d60d679bcc7123c3449ba9b
getSocket
public Socket getSocket()
{    return sock;}
7dc695a4a312064231fa43caec7333da4bd4db3f3cdde377daa66bc6b2a9a2c3
getSid
 long getSid()
{    return sid;}
9aad568ff31ff93f1b9d8ba8a95682f3a33f8af25d45ba0159b820e948e7ca4d
getRemoteAddress
 String getRemoteAddress()
{    return sock == null ? "<null>" : sock.getRemoteSocketAddress().toString();}
79a966a07ccbcb0b4d9ecf92f24220884c3e0f26014374b2d7a63a7f8c67d9a8
getVersion
 int getVersion()
{    return version;}
39b32aca97b8075bacd366c60f11d21d4147f3b008c946aae8281e8fdbb8620e
getLastZxid
public synchronized long getLastZxid()
{    return lastZxid;}
5ca5bb138730343c06cfd479da6662a2eaeb64e3c659f26a6cfb3f6ca9468f0f
getEstablished
public Date getEstablished()
{    return (Date) established.clone();}
5b05914888e421f26bff6f39231facdd35759f746a9af780ebac2cf5b2c81932
start
public synchronized void start()
{    started = true;}
3f6ac730ed3a7c253f0d4cd0a4611c72b00358ea4700e732581ad5ec9960e2ab
updateProposal
public synchronized void updateProposal(long zxid, long time)
{    if (!started) {        return;    }    if (currentTime == 0) {        currentTime = time;        currentZxid = zxid;    } else {        nextTime = time;        nextZxid = zxid;    }}
8879d3d0274e72657eb9ba8ae0b3174a022d32348a1ee822491edd146cdf47f9
updateAck
public synchronized void updateAck(long zxid)
{    if (currentZxid == zxid) {        currentTime = nextTime;        currentZxid = nextZxid;        nextTime = 0;        nextZxid = 0;    } else if (nextZxid == zxid) {        LOG.warn("ACK for " + zxid + " received before ACK for " + currentZxid + "!!!!");        nextTime = 0;        nextZxid = 0;    }}
776212d6e285217a26e08c94e2ccdf6b022792d5d57328ecd68681500409b564
check
public synchronized boolean check(long time)
{    if (currentTime == 0) {        return true;    } else {        long msDelay = (time - currentTime) / 1000000;        return (msDelay < learnerMaster.syncTimeout());    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(time);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    MarkerQuorumPacket that = (MarkerQuorumPacket) o;    return time == that.time;}
32442a83546f976908dd169612a57a4499549434b7067963ae593dafd617871d
setOutputArchive
protected void setOutputArchive(BinaryOutputArchive oa)
{    this.oa = oa;}
4ef46d46e1ba2642a9bd4d9bde489a167a709d5e9b468585b0b14b03ba0eed8f
setBufferedOutput
protected void setBufferedOutput(BufferedOutputStream bufferedOutput)
{    this.bufferedOutput = bufferedOutput;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("LearnerHandler ").append(sock);    sb.append(" tickOfNextAckDeadline:").append(tickOfNextAckDeadline());    sb.append(" synced?:").append(synced());    sb.append(" queuedPacketLength:").append(queuedPackets.size());    return sb.toString();}
a011ad4d61ad8cc3da7df8684ed9f78b9b0f6dd6ddee5a5c791497cd3c58c3e2
getLearnerType
public LearnerType getLearnerType()
{    return learnerType;}
5ccb98e8c1b49141557513e457e4e218d103bca491d79c3b19f2619d39b23393
sendPackets
private void sendPackets() throws InterruptedException
{    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    while (true) {        try {            QuorumPacket p;            p = queuedPackets.poll();            if (p == null) {                bufferedOutput.flush();                p = queuedPackets.take();            }            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());            if (p instanceof MarkerQuorumPacket) {                MarkerQuorumPacket m = (MarkerQuorumPacket) p;                ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);                continue;            }            queuedPacketsSize.addAndGet(-packetSize(p));            if (p == proposalOfDeath) {                                break;            }            if (p.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (p.getType() == Leader.PROPOSAL) {                syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);            }                        if (p.getZxid() > 0) {                lastZxid = p.getZxid();            }            oa.writeRecord(p, "packet");            packetsSent.incrementAndGet();            messageTracker.trackSent(p.getType());        } catch (IOException e) {            if (!sock.isClosed()) {                LOG.warn("Unexpected exception at " + this, e);                try {                                                                                sock.close();                } catch (IOException ie) {                    LOG.warn("Error closing socket for handler " + this, ie);                }            }            break;        }    }}
04fc14aa24e7d9fcfbc1896072136f3c644447a628992f3e7252ccc221259155
packetToString
public static String packetToString(QuorumPacket p)
{    String type;    String mess = null;    switch(p.getType()) {        case Leader.ACK:            type = "ACK";            break;        case Leader.COMMIT:            type = "COMMIT";            break;        case Leader.FOLLOWERINFO:            type = "FOLLOWERINFO";            break;        case Leader.NEWLEADER:            type = "NEWLEADER";            break;        case Leader.PING:            type = "PING";            break;        case Leader.PROPOSAL:            type = "PROPOSAL";            TxnHeader hdr = new TxnHeader();            try {                SerializeUtils.deserializeTxn(p.getData(), hdr);                        } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }            break;        case Leader.REQUEST:            type = "REQUEST";            break;        case Leader.REVALIDATE:            type = "REVALIDATE";            ByteArrayInputStream bis = new ByteArrayInputStream(p.getData());            DataInputStream dis = new DataInputStream(bis);            try {                long id = dis.readLong();                mess = " sessionid = " + id;            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }            break;        case Leader.UPTODATE:            type = "UPTODATE";            break;        case Leader.DIFF:            type = "DIFF";            break;        case Leader.TRUNC:            type = "TRUNC";            break;        case Leader.SNAP:            type = "SNAP";            break;        case Leader.ACKEPOCH:            type = "ACKEPOCH";            break;        case Leader.SYNC:            type = "SYNC";            break;        case Leader.INFORM:            type = "INFORM";            break;        case Leader.COMMITANDACTIVATE:            type = "COMMITANDACTIVATE";            break;        case Leader.INFORMANDACTIVATE:            type = "INFORMANDACTIVATE";            break;        default:            type = "UNKNOWN" + p.getType();    }    String entry = null;    if (type != null) {        entry = type + " " + Long.toHexString(p.getZxid()) + " " + mess;    }    return entry;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        learnerMaster.addLearnerHandler(this);        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();        ia = BinaryInputArchive.getArchive(bufferedInput);        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());        oa = BinaryOutputArchive.getArchive(bufferedOutput);        QuorumPacket qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {            LOG.error("First packet " + qp.toString() + " is not FOLLOWERINFO or OBSERVERINFO!");            return;        }        if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {            throw new IOException("Non observer attempting to connect to ObserverMaster. type = " + qp.getType());        }        byte[] learnerInfoData = qp.getData();        if (learnerInfoData != null) {            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);            if (learnerInfoData.length >= 8) {                this.sid = bbsid.getLong();            }            if (learnerInfoData.length >= 12) {                                this.version = bbsid.getInt();            }            if (learnerInfoData.length >= 20) {                long configVersion = bbsid.getLong();                if (configVersion > learnerMaster.getQuorumVerifierVersion()) {                    throw new IOException("Follower is ahead of the leader (has a later activated configuration)");                }            }        } else {            this.sid = learnerMaster.getAndDecrementFollowerCounter();        }        String followerInfo = learnerMaster.getPeerInfo(this.sid);        if (followerInfo.isEmpty()) {            LOG.info("Follower sid: " + this.sid + " not in the current config " + Long.toHexString(learnerMaster.getQuorumVerifierVersion()));        } else {            LOG.info("Follower sid: " + this.sid + " : info : " + followerInfo);        }        if (qp.getType() == Leader.OBSERVERINFO) {            learnerType = LearnerType.OBSERVER;        }        learnerMaster.registerLearnerHandlerBean(this, sock);        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());        long peerLastZxid;        StateSummary ss = null;        long zxid = qp.getZxid();        long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);        if (this.getVersion() < 0x10000) {                        long epoch = ZxidUtils.getEpochFromZxid(zxid);            ss = new StateSummary(epoch, zxid);                        learnerMaster.waitForEpochAck(this.getSid(), ss);        } else {            byte[] ver = new byte[4];            ByteBuffer.wrap(ver).putInt(0x10000);            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);            oa.writeRecord(newEpochPacket, "packet");            messageTracker.trackSent(Leader.LEADERINFO);            bufferedOutput.flush();            QuorumPacket ackEpochPacket = new QuorumPacket();            ia.readRecord(ackEpochPacket, "packet");            messageTracker.trackReceived(ackEpochPacket.getType());            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {                LOG.error(ackEpochPacket.toString() + " is not ACKEPOCH");                return;            }            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());            learnerMaster.waitForEpochAck(this.getSid(), ss);        }        peerLastZxid = ss.getLastZxid();                        boolean needSnap = syncFollower(peerLastZxid, learnerMaster);                                boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;        /* if we are not truncating or sending a diff just send a snapshot */        if (needSnap) {            syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            try {                long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), "packet");                messageTracker.trackSent(Leader.SNAP);                bufferedOutput.flush();                LOG.info("Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, " + "send zxid of db as 0x{}, {} concurrent snapshot sync, " + "snapshot sync was {} from throttle", Long.toHexString(peerLastZxid), Long.toHexString(leaderLastZxid), Long.toHexString(zxidToSend), syncThrottler.getSyncInProgress(), exemptFromThrottle ? "exempt" : "not exempt");                                learnerMaster.getZKDatabase().serializeSnapshot(oa);                oa.writeString("BenWasHere", "signature");                bufferedOutput.flush();            } finally {                ServerMetrics.getMetrics().SNAP_COUNT.add(1);            }        } else {            syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            ServerMetrics.getMetrics().DIFF_COUNT.add(1);        }        LOG.debug("Sending NEWLEADER message to {}", sid);                if (getVersion() < 0x10000) {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);            oa.writeRecord(newLeaderQP, "packet");        } else {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);            queuedPackets.add(newLeaderQP);        }        bufferedOutput.flush();                startSendingPackets();        /*             * Have to wait for the first ACK, wait until             * the learnerMaster is ready, and only then we can             * start processing messages.             */        qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.ACK) {            LOG.error("Next packet was supposed to be an ACK," + " but received packet: {}", packetToString(qp));            return;        }        LOG.debug("Received NEWLEADER-ACK message from {}", sid);        learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());        syncLimitCheck.start();                syncThrottler.endSync();        syncThrottler = null;                sock.setSoTimeout(learnerMaster.syncTimeout());        /*             * Wait until learnerMaster starts up             */        learnerMaster.waitForStartup();                                        LOG.debug("Sending UPTODATE message to {}", sid);        queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));        while (true) {            qp = new QuorumPacket();            ia.readRecord(qp, "packet");            messageTracker.trackReceived(qp.getType());            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;            if (qp.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);            }            tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();            packetsReceived.incrementAndGet();            ByteBuffer bb;            long sessionId;            int cxid;            int type;            switch(qp.getType()) {                case Leader.ACK:                    if (this.learnerType == LearnerType.OBSERVER) {                        LOG.debug("Received ACK from Observer {}", this.sid);                    }                    syncLimitCheck.updateAck(qp.getZxid());                    learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());                    break;                case Leader.PING:                                        ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());                    DataInputStream dis = new DataInputStream(bis);                    while (dis.available() > 0) {                        long sess = dis.readLong();                        int to = dis.readInt();                        learnerMaster.touch(sess, to);                    }                    break;                case Leader.REVALIDATE:                    ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);                    learnerMaster.revalidateSession(qp, this);                    break;                case Leader.REQUEST:                    bb = ByteBuffer.wrap(qp.getData());                    sessionId = bb.getLong();                    cxid = bb.getInt();                    type = bb.getInt();                    bb = bb.slice();                    Request si;                    if (type == OpCode.sync) {                        si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());                    } else {                        si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());                    }                    si.setOwner(this);                    learnerMaster.submitLearnerRequest(si);                    requestsReceived.incrementAndGet();                    break;                default:                    LOG.warn("unexpected quorum packet, type: {}", packetToString(qp));                    break;            }        }    } catch (IOException e) {        if (sock != null && !sock.isClosed()) {            LOG.error("Unexpected exception causing shutdown while sock " + "still open", e);                        try {                sock.close();            } catch (IOException ie) {                        }        }    } catch (InterruptedException e) {        LOG.error("Unexpected exception in LearnerHandler: ", e);    } catch (SyncThrottleException e) {        LOG.error("too many concurrent syncs: " + e);        syncThrottler = null;    } catch (Exception e) {        LOG.error("Unexpected exception in LearnerHandler: ", e);        throw e;    } finally {        if (syncThrottler != null) {            syncThrottler.endSync();            syncThrottler = null;        }        String remoteAddr = getRemoteAddress();        LOG.warn("******* GOODBYE {} ********", remoteAddr);        messageTracker.dumpToLog(remoteAddr);        shutdown();    }}
ede858cea5ab8c6f42dfd4f2ac5c9e0aea3a121fc9657ae9689cd3083268b6a0
startSendingPackets
protected void startSendingPackets()
{    if (!sendingThreadStarted) {                new Thread() {            public void run() {                Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());                try {                    sendPackets();                } catch (InterruptedException e) {                    LOG.warn("Unexpected interruption " + e.getMessage());                }            }        }.start();        sendingThreadStarted = true;    } else {        LOG.error("Attempting to start sending thread after it already started");    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());    try {        sendPackets();    } catch (InterruptedException e) {        LOG.warn("Unexpected interruption " + e.getMessage());    }}
fa04fd8f8a8413fce5f1c4abe90d0d1ffe481ea3643e1b7e562b4e8cfd2a665a
shouldSendMarkerPacketForLogging
protected boolean shouldSendMarkerPacketForLogging()
{    return true;}
a7097d997d266757e4342e91999178005071eaca8a308da4791dc5e39c2cb1dc
syncFollower
 boolean syncFollower(long peerLastZxid, LearnerMaster learnerMaster)
{    /*         * When leader election is completed, the leader will set its         * lastProcessedZxid to be (epoch < 32). There will be no txn associated         * with this zxid.         *         * The learner will set its lastProcessedZxid to the same value if         * it get DIFF or SNAP from the learnerMaster. If the same learner come         * back to sync with learnerMaster using this zxid, we will never find this         * zxid in our history. In this case, we will ignore TRUNC logic and         * always send DIFF if we have old enough history         */    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;        long currentZxid = peerLastZxid;    boolean needSnap = true;    ZKDatabase db = learnerMaster.getZKDatabase();    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();    ReentrantReadWriteLock lock = db.getLogLock();    ReadLock rl = lock.readLock();    try {        rl.lock();        long maxCommittedLog = db.getmaxCommittedLog();        long minCommittedLog = db.getminCommittedLog();        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();        LOG.info("Synchronizing with Learner sid: {} maxCommittedLog=0x{}" + " minCommittedLog=0x{} lastProcessedZxid=0x{}" + " peerLastZxid=0x{}", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid));        if (db.getCommittedLog().isEmpty()) {            /*                 * It is possible that committedLog is empty. In that case                 * setting these value to the latest txn in learnerMaster db                 * will reduce the case that we need to handle                 *                 * Here is how each case handle by the if block below                 * 1. lastProcessZxid == peerZxid -> Handle by (2)                 * 2. lastProcessZxid < peerZxid -> Handle by (3)                 * 3. lastProcessZxid > peerZxid -> Handle by (5)                 */            minCommittedLog = lastProcessedZxid;            maxCommittedLog = lastProcessedZxid;        }        if (forceSnapSync) {                        LOG.warn("Forcing snapshot sync - should not see this in production");        } else if (lastProcessedZxid == peerLastZxid) {                        LOG.info("Sending DIFF zxid=0x" + Long.toHexString(peerLastZxid) + " for peer sid: " + getSid());            queueOpPacket(Leader.DIFF, peerLastZxid);            needOpPacket = false;            needSnap = false;        } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {                        if (LOG.isDebugEnabled()) {                LOG.debug("Sending TRUNC to follower zxidToSend=0x" + Long.toHexString(maxCommittedLog) + " for peer sid:" + getSid());            }            queueOpPacket(Leader.TRUNC, maxCommittedLog);            currentZxid = maxCommittedLog;            needOpPacket = false;            needSnap = false;        } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {                        LOG.info("Using committedLog for peer sid: " + getSid());            Iterator<Proposal> itr = db.getCommittedLog().iterator();            currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);            needSnap = false;        } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {                                    long sizeLimit = db.calculateTxnLogSizeLimit();                                    Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);            if (txnLogItr.hasNext()) {                LOG.info("Use txnlog and committedLog for peer sid: " + getSid());                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);                if (currentZxid < minCommittedLog) {                    LOG.info("Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}", Long.toHexString(currentZxid), Long.toHexString(minCommittedLog));                    currentZxid = peerLastZxid;                                                            queuedPackets.clear();                    needOpPacket = true;                } else {                    if (LOG.isDebugEnabled()) {                        LOG.debug("Queueing committedLog 0x{}", Long.toHexString(currentZxid));                    }                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);                    needSnap = false;                }            }                        if (txnLogItr instanceof TxnLogProposalIterator) {                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;                txnProposalItr.close();            }        } else {            LOG.warn("Unhandled scenario for peer sid: {} maxCommittedLog=0x{}" + " minCommittedLog=0x{} lastProcessedZxid=0x{}" + " peerLastZxid=0x{} txnLogSyncEnabled={}", getSid(), Long.toHexString(maxCommittedLog), Long.toHexString(minCommittedLog), Long.toHexString(lastProcessedZxid), Long.toHexString(peerLastZxid), txnLogSyncEnabled);        }        if (needSnap) {            currentZxid = db.getDataTreeLastProcessedZxid();        }        if (LOG.isDebugEnabled()) {            LOG.debug("Start forwarding 0x" + Long.toHexString(currentZxid) + " for peer sid: " + getSid());        }        leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);    } finally {        rl.unlock();    }    if (needOpPacket && !needSnap) {                        LOG.error("Unhandled scenario for peer sid: " + getSid() + " fall back to use snapshot");        needSnap = true;    }    return needSnap;}
d8d332a70fd1804a90b0156a1da2c63f45d548df1b563aa303902ff742fe4c82
queueCommittedProposals
protected long queueCommittedProposals(Iterator<Proposal> itr, long peerLastZxid, Long maxZxid, Long lastCommittedZxid)
{    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;    long queuedZxid = peerLastZxid;            long prevProposalZxid = -1;    while (itr.hasNext()) {        Proposal propose = itr.next();        long packetZxid = propose.packet.getZxid();                if ((maxZxid != null) && (packetZxid > maxZxid)) {            break;        }                if (packetZxid < peerLastZxid) {            prevProposalZxid = packetZxid;            continue;        }                if (needOpPacket) {                        if (packetZxid == peerLastZxid) {                LOG.info("Sending DIFF zxid=0x" + Long.toHexString(lastCommittedZxid) + " for peer sid: " + getSid());                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;                continue;            }            if (isPeerNewEpochZxid) {                                LOG.info("Sending DIFF zxid=0x" + Long.toHexString(lastCommittedZxid) + " for peer sid: " + getSid());                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;            } else if (packetZxid > peerLastZxid) {                                if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {                                                                                LOG.warn("Cannot send TRUNC to peer sid: " + getSid() + " peer zxid is from different epoch");                    return queuedZxid;                }                LOG.info("Sending TRUNC zxid=0x" + Long.toHexString(prevProposalZxid) + " for peer sid: " + getSid());                queueOpPacket(Leader.TRUNC, prevProposalZxid);                needOpPacket = false;            }        }        if (packetZxid <= queuedZxid) {                        continue;        }                        queuePacket(propose.packet);        queueOpPacket(Leader.COMMIT, packetZxid);        queuedZxid = packetZxid;    }    if (needOpPacket && isPeerNewEpochZxid) {                                LOG.info("Sending DIFF zxid=0x" + Long.toHexString(lastCommittedZxid) + " for peer sid: " + getSid());        queueOpPacket(Leader.DIFF, lastCommittedZxid);        needOpPacket = false;    }    return queuedZxid;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{        try {        queuedPackets.clear();        queuedPackets.put(proposalOfDeath);    } catch (InterruptedException e) {        LOG.warn("Ignoring unexpected exception", e);    }    try {        if (sock != null && !sock.isClosed()) {            sock.close();        }    } catch (IOException e) {        LOG.warn("Ignoring unexpected exception during socket close", e);    }    this.interrupt();    learnerMaster.removeLearnerHandler(this);    learnerMaster.unregisterLearnerHandlerBean(this);}
ba9461bf8e55556a656723c065b20a2647064d3f61b3cc6ea0d7479c5ce178ab
tickOfNextAckDeadline
public long tickOfNextAckDeadline()
{    return tickOfNextAckDeadline;}
040c9691fa71f5c1923452e5014b9d631c4e1f287c925e4fbe1aead83373154c
ping
public void ping()
{        if (!sendingThreadStarted) {        return;    }    long id;    if (syncLimitCheck.check(System.nanoTime())) {        id = learnerMaster.getLastProposed();        QuorumPacket ping = new QuorumPacket(Leader.PING, id, null, null);        queuePacket(ping);    } else {        LOG.warn("Closing connection to peer due to transaction timeout.");        shutdown();    }}
1351b311da6c80fead7985517e19e94fece93d77481894a28ad6a3a27450eca3
queueOpPacket
private void queueOpPacket(int type, long zxid)
{    QuorumPacket packet = new QuorumPacket(type, zxid, null, null);    queuePacket(packet);}
ee2ff3c046e10a0212e3cfc100fee5c14994c6748c8b53bb91a92735b7dbde45
queuePacket
 void queuePacket(QuorumPacket p)
{    queuedPackets.add(p);        if (shouldSendMarkerPacketForLogging() && packetCounter.getAndIncrement() % markerPacketInterval == 0) {        queuedPackets.add(new MarkerQuorumPacket(System.nanoTime()));    }    queuedPacketsSize.addAndGet(packetSize(p));}
9c8e7ba2a018fb3a8e6d863f1c9f1c63cfb4c2423563ad301e9fc24709f5da50
packetSize
 static long packetSize(QuorumPacket p)
{    /* Approximate base size of QuorumPacket: int + long + byte[] + List */    long size = 4 + 8 + 8 + 8;    byte[] data = p.getData();    if (data != null) {        size += data.length;    }    return size;}
1a04f0ebe1d9b72d28b598774d438f51908b87c2a28ba7bd347125ec360caa3d
synced
public boolean synced()
{    return isAlive() && learnerMaster.getCurrentTick() <= tickOfNextAckDeadline;}
06bda47ab05f22e24516dc6f79b8c49f97fc23ba62ad7898367ce1118382966c
getLearnerHandlerInfo
public synchronized Map<String, Object> getLearnerHandlerInfo()
{    Map<String, Object> info = new LinkedHashMap<>(9);    info.put("remote_socket_address", getRemoteAddress());    info.put("sid", getSid());    info.put("established", getEstablished());    info.put("queued_packets", queuedPackets.size());    info.put("queued_packets_size", queuedPacketsSize.get());    info.put("packets_received", packetsReceived.longValue());    info.put("packets_sent", packetsSent.longValue());    info.put("requests", requestsReceived.longValue());    info.put("last_zxid", getLastZxid());    return info;}
979175c878d2742411a6a825a09f3050c486209fa0e9b1a6d83dee22e39483df
resetObserverConnectionStats
public synchronized void resetObserverConnectionStats()
{    packetsReceived.set(0);    packetsSent.set(0);    requestsReceived.set(0);    lastZxid = -1;}
a169ae655eec9f89fc96e33ca9ddcdc8e8cc19ac5a6e54d4300690ef15d3d0b9
getQueuedPackets
public Queue<QuorumPacket> getQueuedPackets()
{    return queuedPackets;}
a1d4d485391edad86c92c25adeb979562c719d93a389b8e545c07acbaca29353
setFirstPacket
public void setFirstPacket(boolean value)
{    needOpPacket = value;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return MBeanRegistry.getInstance().makeFullPath("Learner_Connections", ObjectName.quote(remoteAddr), String.format("\"id:%d\"", learnerHandler.getSid()));}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
85855e7603732ccff679fc6284742be9c6bdb30a7500c8886361b7a59b873b3b
terminateConnection
public void terminateConnection()
{    LOG.info("terminating learner handler connection on demand " + toString());    learnerHandler.shutdown();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LearnerHandlerBean{remoteIP=" + remoteAddr + ",ServerId=" + learnerHandler.getSid() + "}";}
effe2b111b7d2562cb0579bb71ecb9e5964e69a42c011dc9ea78bb86cbfe3bbc
getMaxConcurrentSnapSyncs
public int getMaxConcurrentSnapSyncs()
{    return maxConcurrentSnapSyncs;}
5b3295693ccd87ff60308acab4d15c768cd5d9aaa14114df386dcdfd7d3224a4
setMaxConcurrentSnapSyncs
public void setMaxConcurrentSnapSyncs(int maxConcurrentSnapSyncs)
{    LOG.info("Set maxConcurrentSnapSyncs to {}", maxConcurrentSnapSyncs);    this.maxConcurrentSnapSyncs = maxConcurrentSnapSyncs;    learnerSnapSyncThrottler.setMaxConcurrentSyncs(maxConcurrentSnapSyncs);}
9963f5c3c27beaab3c6b73119e3b7a1832f0baf79b14c48c03a2c619c130f6b3
getMaxConcurrentDiffSyncs
public int getMaxConcurrentDiffSyncs()
{    return maxConcurrentDiffSyncs;}
ba7ab6209f111504ffe99a89df6f0d58357c239068d0c1c59b8d99cb86f9e0d5
setMaxConcurrentDiffSyncs
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs)
{    LOG.info("Set maxConcurrentDiffSyncs to {}", maxConcurrentDiffSyncs);    this.maxConcurrentDiffSyncs = maxConcurrentDiffSyncs;    learnerDiffSyncThrottler.setMaxConcurrentSyncs(maxConcurrentDiffSyncs);}
f6833568ea6b3db84e35a7914da79ae7629ffc8227a8f36c8c1ceb12695af99a
getLearnerSnapSyncThrottler
public LearnerSyncThrottler getLearnerSnapSyncThrottler()
{    return learnerSnapSyncThrottler;}
8d73e1481dc31f9c73d68c0b2edd16ca9bf54a5d153afe72ecb2e4a418018564
getLearnerDiffSyncThrottler
public LearnerSyncThrottler getLearnerDiffSyncThrottler()
{    return learnerDiffSyncThrottler;}
6055190cbe55525602a491409aa248706ec1074de2c17a49b4594a9de615633e
removeSession
public void removeSession(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionsWithTimeouts.remove(sessionId);    touchTable.get().remove(sessionId);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (localSessionTracker != null) {        localSessionTracker.start();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }}
98f9ba8d684113c948c79428852e77290b44a1aae4e73fd15f26ac1b0853fd3b
isGlobalSession
public boolean isGlobalSession(long sessionId)
{    return globalSessionsWithTimeouts.containsKey(sessionId);}
b60a5dfc3d8d915a881d21dcbf09d7f87c896a7898d7782d0a68a38bebb43061
trackSession
public boolean trackSession(long sessionId, int sessionTimeout)
{        return false;}
4a19be9b5864bc17252345f8308f0f92216a0527e01bac5454ee28ac731700f8
commitSession
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    boolean added = globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;    if (added) {                        LOG.info("Committing global session 0x" + Long.toHexString(sessionId));    }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    touchTable.get().put(sessionId, sessionTimeout);    return added;}
7e5a4e6298052c4653ec1b80ed2336b41d598fd29f3e851ef1b7c09116eecf28
touchSession
public boolean touchSession(long sessionId, int sessionTimeout)
{    if (localSessionsEnabled) {        if (localSessionTracker.touchSession(sessionId, sessionTimeout)) {            return true;        }        if (!isGlobalSession(sessionId) && !isUpgradingSession(sessionId)) {            return false;        }    }    touchTable.get().put(sessionId, sessionTimeout);    return true;}
36154d1a37b5ad1b9032ffef0a57cb1ddb5f29cc03a6727829ccb63f8617610b
snapshot
public Map<Long, Integer> snapshot()
{    return touchTable.getAndSet(new ConcurrentHashMap<Long, Integer>());}
26a20a147958953e3c25a582180e937ad56ac181b2ec844d0de659c5027d7c8a
createSession
public long createSession(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return nextSessionId.getAndIncrement();}
3731d03709a6efad73b79adc0407f37edbbe529903884633ff018141c9c77841
checkSession
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);            return;        } catch (UnknownSessionException e) {                        if (!isGlobalSession(sessionId)) {                throw new SessionExpiredException();            }        }    }}
cd23fd4918aedacaa73ac08b382d3549730a0537c44f12f6de6c49f7d647f462
setOwner
public void setOwner(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                        if (!isGlobalSession(sessionId)) {                throw e;            }        }    }}
059bdb7fdfcd8a7cc5ac1afcbadf7c985185ac6be02df299e669a9effa7195ce
dumpSessions
public void dumpSessions(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);    }    pwriter.print("Global Sessions(");    pwriter.print(globalSessionsWithTimeouts.size());    pwriter.println("):");    SortedSet<Long> sessionIds = new TreeSet<Long>(globalSessionsWithTimeouts.keySet());    for (long sessionId : sessionIds) {        pwriter.print("0x");        pwriter.print(Long.toHexString(sessionId));        pwriter.print("\t");        pwriter.print(globalSessionsWithTimeouts.get(sessionId));        pwriter.println("ms");    }}
1183d8f3ef078b53b34ad1087fd0509544c0642f748a8d1e078c40dad3e6e92b
setSessionClosing
public void setSessionClosing(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }}
3af14c5b72bdfc3edf46603772a1f71ddd60055b7766802e1ca02228886adc63
getSessionExpiryMap
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return new HashMap<Long, Set<Long>>();}
3dc4c8c32c07b72f5a9e33e744dd8f7ed915239562ab852f912f62580405f306
beginSync
protected void beginSync(boolean essential) throws SyncThrottleException, InterruptedException
{    synchronized (countSyncObject) {        if (essential || syncInProgress < maxConcurrentSyncs) {            syncInProgress++;        } else {            throw new SyncThrottleException(syncInProgress + 1, maxConcurrentSyncs, syncType);        }    }}
cb9a25d643ff223a2320d436eb39f76a76475094d50e9fe3244871606e3ec93f
endSync
public void endSync()
{    int newCount;    synchronized (countSyncObject) {        syncInProgress--;        newCount = syncInProgress;        countSyncObject.notify();    }    if (newCount < 0) {        String errorMsg = "endSync() called incorrectly; current sync count is " + newCount;        LOG.error(errorMsg);    }}
f73e3f08d5a98fbfb7656b7237033863ee90ad965243e038af4c466030567586
setMaxConcurrentSyncs
public void setMaxConcurrentSyncs(int maxConcurrentSyncs)
{    this.maxConcurrentSyncs = maxConcurrentSyncs;}
894984a360e4e4ce878924a08d3c50963f8eb6b14b75b1109937619fbc09f156
getSyncInProgress
public int getSyncInProgress()
{    return syncInProgress;}
1067f69960ace250b71c9a9545ace1902203743a908af592f24ae9311a7f3557
getTouchSnapshot
protected Map<Long, Integer> getTouchSnapshot()
{    if (sessionTracker != null) {        return ((LearnerSessionTracker) sessionTracker).snapshot();    }    Map<Long, Integer> map = Collections.emptyMap();    return map;}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return self.getId();}
a6fb3fd47d2002c10e5c5307384249f559df942b1ae57f305136a504c7f36ca4
createSessionTracker
public void createSessionTracker()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
8564f0212992ab8be2b48d947902852b2e350a858bf2d3eb3dc193c9cb325f67
revalidateSession
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    if (upgradeableSessionTracker.isLocalSession(sessionId)) {        super.revalidateSession(cnxn, sessionId, sessionTimeout);    } else {        getLearner().validateSession(cnxn, sessionId, sessionTimeout);    }}
e6f3bb16f7c86279ca0b0f6bdfc4ca1bbf019bd9710ded3d2320084bbedcc6a2
registerJMX
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxDataTreeBean = null;    }}
f0319c6b00f4ade84897bf31fc3fb5d667c87c59587edd13b35f0483f60fe40d
registerJMX
public void registerJMX(ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {            LOG.warn("Failed to register with JMX", e);        }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxServerBean = null;    }}
85e7e25a941f134236cd570c8e63b18ce60539fbd1cc088cec570f9a426f4eb3
unregisterJMX
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxDataTreeBean = null;}
a15aaa651679af41c4b4a08fb81949d945b85a10cbd682dc41689a57eced450f
unregisterJMX
protected void unregisterJMX(Learner peer)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxServerBean = null;}
adee6d577ad1124bcdd55d9356083ab1be7b96b41b09ad125a756c3523b15a7e
shutdown
public synchronized void shutdown()
{    if (!canShutdown()) {        LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");        return;    }    LOG.info("Shutting down");    try {        super.shutdown();    } catch (Exception e) {        LOG.warn("Ignoring unexpected exception during shutdown", e);    }    try {        if (syncProcessor != null) {            syncProcessor.shutdown();        }    } catch (Exception e) {        LOG.warn("Ignoring unexpected exception in syncprocessor shutdown", e);    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "replica." + peer.getId();}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return peer.getTickTime();}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return peer.getMaxClientCnxnsPerHost();}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return peer.getMinSessionTimeout();}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return peer.getMaxSessionTimeout();}
388547177a6cafeb8c7b497ec5fafed00cdc5eeb526612bd565c9966f951d5ac
getInitLimit
public int getInitLimit()
{    return peer.getInitLimit();}
2644301152fe601b1f7b76d52dc6e356d05bcfacf4d779994a44b0d12a07883f
getSyncLimit
public int getSyncLimit()
{    return peer.getSyncLimit();}
a48b86e447b7caee31ddd3bb32ba70614eee601f8b3d9b8bd8586208efad3643
setInitLimit
public void setInitLimit(int initLimit)
{    peer.setInitLimit(initLimit);}
ffade3a1568b507e1a257705f19722391b602b5b13effffbaebbb03ced7efe29
setSyncLimit
public void setSyncLimit(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
9882bc525a6f8f9a45efba59fca68d684fe4984d864a8948fe11ce54be311be5
getTick
public int getTick()
{    return peer.getTick();}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return peer.getServerState();}
4f1ec8c9033d0a4457283cded308db0fec7b84f7c76e3ab807775805037a55de
getQuorumAddress
public String getQuorumAddress()
{    return formatInetAddr(peer.getQuorumAddress());}
17988e743985334f563e269fa11881f30201b043978d440804c47e8ce9568594
getElectionType
public int getElectionType()
{    return peer.getElectionType();}
514186471f5a021d8c5ea09bcda12ab34e3a72c49a91c2364760187b3dcaac51
getElectionAddress
public String getElectionAddress()
{    return formatInetAddr(peer.getElectionAddress());}
0fb808b56ebdb6386bad979b8f93f01e194664965d5285cf445d090ad0fd3e6b
getClientAddress
public String getClientAddress()
{    if (null != peer.cnxnFactory) {        return formatInetAddr(peer.cnxnFactory.getLocalAddress());    } else {        return "";    }}
7641fec0017465a8a698cefc69a9f26280473649e240294b6966d49c05072e0e
getLearnerType
public String getLearnerType()
{    return peer.getLearnerType().toString();}
ee0ed1060bc8bc9372d5cb1eaa76f7616e4810c3c7af1d3240308f455a1d3131
getConfigVersion
public long getConfigVersion()
{    return peer.getQuorumVerifier().getVersion();}
b049cb8c9626b7d0ec3208aa26502078731fd70ffc823f62de5d44efa6a5712d
getQuorumSystemInfo
public String getQuorumSystemInfo()
{    return peer.getQuorumVerifier().toString();}
e2bd1972048a56cbd12b452917e32da2a3962adb6aae9da1e2536835705459c0
isPartOfEnsemble
public boolean isPartOfEnsemble()
{    return peer.getView().containsKey(peer.getId());}
261b1d5329a359f54179b707447d10aad0876e9640502da1514ed8a1925a3d54
isLeader
public boolean isLeader()
{    return peer.isLeader(peer.getId());}
39fa1f1b69df2be4909a68a70417b83cbf2497fb9718462eb0a17da78fe424a3
isLocalSession
public boolean isLocalSession(long sessionId)
{    return isTrackingSession(sessionId);}
98f9ba8d684113c948c79428852e77290b44a1aae4e73fd15f26ac1b0853fd3b
isGlobalSession
public boolean isGlobalSession(long sessionId)
{    return false;}
26a20a147958953e3c25a582180e937ad56ac181b2ec844d0de659c5027d7c8a
createSession
public long createSession(int sessionTimeout)
{    long sessionId = super.createSession(sessionTimeout);    commitSession(sessionId, sessionTimeout);    return sessionId;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Observer ").append(sock);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
f465b57437444068f71fb956b9d0d5533e087c8ef8b3b7586eba5ac4660bff7a
observeLeader
 void observeLeader() throws Exception
{    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);    long connectTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer master = findLearnerMaster();        try {            connectToLeader(master.addr, master.hostname);            connectTime = System.currentTimeMillis();            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }            self.setLeaderAddressAndId(master.addr, master.getId());            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);            syncWithLeader(newLeaderZxid);            self.setZabState(QuorumPeer.ZabState.BROADCAST);            completedSync = true;            QuorumPacket qp = new QuorumPacket();            while (this.isRunning() && nextLearnerMaster.get() == null) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {            LOG.warn("Exception when observing the leader", e);            closeSocket();                        pendingRevalidations.clear();        }    } finally {        currentLearnerMaster = null;        zk.unregisterJMX(this);        if (connectTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectTime;            LOG.info("Disconnected from leader (with address: {}). " + "Was connected for {}ms. Sync state: {}", leaderAddr, connectionDuration, completedSync);            messageTracker.dumpToLog(leaderAddr.toString());        }    }}
bc5fe4acd68ad10a9b75bd9ec5bdf60cc5b9d6d867ee240432ad98b92c03d9f3
findLearnerMaster
private QuorumServer findLearnerMaster()
{    QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);    if (prescribedLearnerMaster != null && self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {        LOG.warn("requested next learner master {} is no longer valid", prescribedLearnerMaster);        prescribedLearnerMaster = null;    }    final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null) ? self.findLearnerMaster(findLeader()) : prescribedLearnerMaster;    currentLearnerMaster = master;    if (master == null) {        LOG.warn("No learner master found");    } else {        LOG.info("Observing new leader sid={} addr={}", master.id, master.addr);    }    return master;}
3c48129e174442c741c73efe4e75fb1b7199a7e9897b2a57fa106015e86974e4
processPacket
protected void processPacket(QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:            LOG.warn("Ignoring proposal");            break;        case Leader.COMMIT:            LOG.warn("Ignoring commit");            break;        case Leader.UPTODATE:            LOG.error("Received an UPTODATE message after Observer started");            break;        case Leader.REVALIDATE:            revalidate(qp);            break;        case Leader.SYNC:            ((ObserverZooKeeperServer) zk).sync();            break;        case Leader.INFORM:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;            obs.commitRequest(request);            break;        case Leader.INFORMANDACTIVATE:            hdr = new TxnHeader();                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            byte[] remainingdata = new byte[buffer.remaining()];            buffer.get(remainingdata);            txn = SerializeUtils.deserializeTxn(remainingdata, hdr);            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData()));            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            obs = (ObserverZooKeeperServer) zk;            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);            obs.commitRequest(request);            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        default:            LOG.warn("Unknown packet type: {}", LearnerHandler.packetToString(qp));            break;    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("shutdown called", new Exception("shutdown Observer"));    super.shutdown();}
57b8d479442d058bb1b5dd54ea1d6d9b7b7fcabb0a7c4296a548716db969d72f
waitForReconnectDelay
 static void waitForReconnectDelay()
{    waitForReconnectDelayHelper(reconnectDelayMs);}
f9fe54e2c9bda7b52b314f577d8bc6885cd6fe468936906a2886e038c5c8bd17
waitForObserverElectionDelay
 static void waitForObserverElectionDelay()
{    waitForReconnectDelayHelper(observerElectionDelayMs);}
514de7d6f4fbd82e6d2de25681493bbb46c16d3df9940ac568edb91296491ca6
waitForReconnectDelayHelper
private static void waitForReconnectDelayHelper(long delayValueMs)
{    if (delayValueMs > 0) {        long randomDelay = (long) (delayValueMs * Math.random());        LOG.info("Waiting for " + randomDelay + " ms before reconnecting with the leader");        try {            Thread.sleep(randomDelay);        } catch (InterruptedException e) {            LOG.warn("Interrupted while waiting" + e.getMessage());        }    }}
264b77c2f59131c825dfc3c4972661517e0141d334b6b7e878cb0c1c8b597895
getLearnerMasterId
public long getLearnerMasterId()
{    QuorumPeer.QuorumServer current = currentLearnerMaster;    return current == null ? -1 : current.id;}
78001c5cf27ff0d535095b19e566c25cb8c10e35ebc93b6589c457914fcd0196
setLearnerMaster
public boolean setLearnerMaster(String learnerMaster)
{    final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);    if (server == null) {        return false;    } else if (server.equals(currentLearnerMaster)) {        LOG.info("Already connected to requested learner master sid={} addr={}", server.id, server.addr);        return true;    } else {        LOG.info("Requesting disconnect and reconnect to new learner master sid={} addr={}", server.id, server.addr);        nextLearnerMaster.set(server);        return true;    }}
be842719f0cbde08283d8f5b179f24a288c15f185f4ab921c0730ca9ed7c88c6
getCurrentLearnerMaster
public QuorumPeer.QuorumServer getCurrentLearnerMaster()
{    return currentLearnerMaster;}
96fb000884f0f33b8cc845b21c8fce8d335c2533e0f4cb41c345b61eca169f10
getObserverElectionDelayMs
public static long getObserverElectionDelayMs()
{    return observerElectionDelayMs;}
1b5e652de2cce8fe378b9363366338b361cd6230c4bb60e26a78488ff3aff3bd
setObserverElectionDelayMs
public static void setObserverElectionDelayMs(long electionDelayMs)
{    observerElectionDelayMs = electionDelayMs;    LOG.info(OBSERVER_ELECTION_DELAY_MS + " = " + observerElectionDelayMs);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    final Revalidation that = (Revalidation) o;    return sessionId == that.sessionId && timeout == that.timeout && handler.equals(that.handler);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = (int) (sessionId ^ (sessionId >>> 32));    result = 31 * result + timeout;    result = 31 * result + handler.hashCode();    return result;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    for (LearnerHandler lh : activeObservers) {        lh.ping();    }}
0964437c6f4ebd0c3be980cb7525aba6051b0737f83c3e60965f12d6b7cdff15
addLearnerHandler
public void addLearnerHandler(LearnerHandler learnerHandler)
{    if (!listenerRunning) {        throw new RuntimeException(("ObserverMaster is not running"));    }}
1a65a91f5e42ae2bcc2a87c6ad85a65d35354215d383477908fc8c41f65c57f1
removeLearnerHandler
public void removeLearnerHandler(LearnerHandler learnerHandler)
{    activeObservers.remove(learnerHandler);}
c9197edf852683da0548d07961e6b6ade10e06ef02e8ec9e6ab92be9a64ac6be
syncTimeout
public int syncTimeout()
{    return self.getSyncLimit() * self.getTickTime();}
9a5455755f758ee6626544d269e0381aaefda5135e435c71a1731a599b3cf410
getTickOfNextAckDeadline
public int getTickOfNextAckDeadline()
{    return self.tick.get() + self.syncLimit;}
29fd723bb1bdf6e6ad0c2947bb51c15a74288fe3d818d0adc54d4facd2e939a9
getTickOfInitialAckDeadline
public int getTickOfInitialAckDeadline()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
88b57206c2073a75ca47c3c5afd757f93cafa2a8a1eb29ff16417933dab1c75e
getAndDecrementFollowerCounter
public long getAndDecrementFollowerCounter()
{    return followerCounter.getAndDecrement();}
e4f3fef966256247fd03f66f70728c6785dc8c0e4cbdad92b5259cb1fb57a60f
waitForEpochAck
public void waitForEpochAck(long sid, StateSummary ss) throws IOException, InterruptedException
{}
188db1c46c470d572ad6a01e2d26ef7e8e1f31462c3e431be76b48a3a5958d13
waitForStartup
public void waitForStartup() throws InterruptedException
{}
0440447f13d488a15bc2cca6d567d3ec1b92b2b99769cff21daf5b2c0b155a8c
getLastProposed
public synchronized long getLastProposed()
{    return lastProposedZxid;}
d076b9d95cbcaa2c669b84eed1dd41044e30d802e782eb9f609bac00a8f114da
getEpochToPropose
public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    return self.getCurrentEpoch();}
0a398a5b161acf7b53049b13c6b7c236f158603b5bc782af221df9037a70dec0
getZKDatabase
public ZKDatabase getZKDatabase()
{    return zks.getZKDatabase();}
74d45323f0f04253233e826ccfe7e7ce0ba45de56d8da5a43ac697892ed4c9a5
waitForNewLeaderAck
public void waitForNewLeaderAck(long sid, long zxid) throws InterruptedException
{}
ba79b4b278cd146c4f5fcbc0ba9da9fe512b81afa7be9b1a14891b66a72c09cd
getCurrentTick
public int getCurrentTick()
{    return self.tick.get();}
8512515cc55d49afc178c4ca483f4491d59ca8eabc8e8756f58e260c6ae0e71e
processAck
public void processAck(long sid, long zxid, SocketAddress localSocketAddress)
{    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack by this method. However,             * the learner sends ack back to the leader after it gets UPTODATE             * so we just ignore the message.             */        return;    }    throw new RuntimeException("Observers shouldn't send ACKS ack = " + Long.toHexString(zxid));}
765d1fa0c986ecd405ef14119aab875891b0c300838edd246fb51406c94df2c4
touch
public void touch(long sess, int to)
{    zks.getSessionTracker().touchSession(sess, to);}
220bba51d98a00b484f907fddb4b987eeade72193be67e938eb8c9ff9a7e2bbb
revalidateLearnerSession
 boolean revalidateLearnerSession(QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    boolean valid = dis.readBoolean();    Iterator<Revalidation> itr = pendingRevalidations.iterator();    if (!itr.hasNext()) {                return false;    }    Revalidation revalidation = itr.next();    if (revalidation.sessionId != id) {                return false;    }    itr.remove();    LearnerHandler learnerHandler = revalidation.handler;        QuorumPacket deepCopy = new QuorumPacket(qp.getType(), qp.getZxid(), Arrays.copyOf(qp.getData(), qp.getData().length), qp.getAuthinfo() == null ? null : new ArrayList<>(qp.getAuthinfo()));    learnerHandler.queuePacket(deepCopy);        if (valid) {        touch(revalidation.sessionId, revalidation.timeout);    }    return true;}
7dc5f23caa37bbd14810e053c4278869d5392c24b72af71fba6b4b7106ccbb79
revalidateSession
public void revalidateSession(QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    synchronized (revalidateSessionLock) {        pendingRevalidations.add(new Revalidation(id, to, learnerHandler));        Learner learner = zks.getLearner();        if (learner != null) {            learner.writePacket(qp, true);        }    }}
d9ee00f26e1fe95cdd8c5459d1adef9e43a7d0085545a3edbafc5b28568dc648
submitLearnerRequest
public void submitLearnerRequest(Request si)
{    zks.processObserverRequest(si);}
e7d441801bf84b18a4cb44e1ac1c202df753240bc223c162c262a00d42321652
startForwarding
public synchronized long startForwarding(LearnerHandler learnerHandler, long lastSeenZxid)
{    Iterator<QuorumPacket> itr = committedPkts.iterator();    if (itr.hasNext()) {        QuorumPacket packet = itr.next();        if (packet.getZxid() > lastSeenZxid + 1) {            LOG.error("LearnerHandler is too far behind ({} < {}), disconnecting {} at {}", Long.toHexString(lastSeenZxid + 1), Long.toHexString(packet.getZxid()), learnerHandler.getSid(), learnerHandler.getRemoteAddress());            learnerHandler.shutdown();            return -1;        } else if (packet.getZxid() == lastSeenZxid + 1) {            learnerHandler.queuePacket(packet);        }        long queueHeadZxid = packet.getZxid();        long queueBytesUsed = LearnerHandler.packetSize(packet);        while (itr.hasNext()) {            packet = itr.next();            if (packet.getZxid() <= lastSeenZxid) {                continue;            }            learnerHandler.queuePacket(packet);            queueBytesUsed += LearnerHandler.packetSize(packet);        }        LOG.info("finished syncing observer from retained commit queue: sid {}, " + "queue head 0x{}, queue tail 0x{}, sync position 0x{}, num packets used {}, " + "num bytes used {}", learnerHandler.getSid(), Long.toHexString(queueHeadZxid), Long.toHexString(packet.getZxid()), Long.toHexString(lastSeenZxid), packet.getZxid() - lastSeenZxid, queueBytesUsed);    }    activeObservers.add(learnerHandler);    return lastProposedZxid;}
106bd3161febaa7b0eb4f32cdf4eda134c9696c6f58d815dd71c582142105a53
getQuorumVerifierVersion
public long getQuorumVerifierVersion()
{    return self.getQuorumVerifier().getVersion();}
3162a750cefee17242386bc4647d6d48373e8df94493972906a41a5ba733865c
getPeerInfo
public String getPeerInfo(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
192c5d44fd09ac1bd4da4f46915dd6f269c47a6f533a731f4ed98ddda0d213c1
getQuorumVerifierBytes
public byte[] getQuorumVerifierBytes()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
c5bcf0c2c6d34d32e4f8b27728ac683fedfe5d8f9fcaba8628699409a1308d62
getQuorumAuthServer
public QuorumAuthServer getQuorumAuthServer()
{    return (self == null) ? null : self.authServer;}
d9ec5e333e60f6fd1b63112968833828cd835f23f21f3edef75a6b2d5275aecd
proposalReceived
 void proposalReceived(QuorumPacket qp)
{    proposedPkts.add(new QuorumPacket(Leader.INFORM, qp.getZxid(), qp.getData(), null));}
ba3cdb85694d0b356d901219252d59db94669a0973aecf7823a285f026a04644
removeProposedPacket
private synchronized QuorumPacket removeProposedPacket(long zxid)
{    QuorumPacket pkt = proposedPkts.peek();    if (pkt == null || pkt.getZxid() > zxid) {        LOG.debug("ignore missing proposal packet for {}", Long.toHexString(zxid));        return null;    }    if (pkt.getZxid() != zxid) {        final String m = String.format("Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d", zxid, pkt.getZxid());        LOG.error(m);        throw new RuntimeException(m);    }    proposedPkts.remove();    return pkt;}
e5732cbde3feef8466604930a0d086ab1f5304ac82b82fb3c67ca02914cab073
cacheCommittedPacket
private synchronized void cacheCommittedPacket(final QuorumPacket pkt)
{    committedPkts.add(pkt);    pktsSize += LearnerHandler.packetSize(pkt);        for (int i = 0; pktsSize > pktsSizeLimit * 0.8 && i < 5; i++) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }        while (pktsSize > pktsSizeLimit) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }}
b6c2111cf0af9df98a91b6fe135f7c0cdda576fe4bdb925b0fbf52418b719846
sendPacket
private synchronized void sendPacket(final QuorumPacket pkt)
{    for (LearnerHandler lh : activeObservers) {        lh.queuePacket(pkt);    }    lastProposedZxid = pkt.getZxid();}
6c823250618e236683f21dd8831d692dc1ea6f008d6f74b6642d571d540ed0fa
proposalCommitted
 synchronized void proposalCommitted(long zxid)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }    cacheCommittedPacket(pkt);    sendPacket(pkt);}
176f8ace97c53df083f64d580fba75fceb95cde047b4ccfcb93c21d666fb7313
informAndActivate
 synchronized void informAndActivate(long zxid, long suggestedLeaderId)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }        QuorumPacket informAndActivateQP = Leader.buildInformAndActivePacket(zxid, suggestedLeaderId, pkt.getData());    cacheCommittedPacket(informAndActivateQP);    sendPacket(informAndActivateQP);}
196b6ef41bae6564e10a91199cdb4299fc5c33f967b1de8208fd320cb9902a8b
start
public synchronized void start() throws IOException
{    if (thread != null && thread.isAlive()) {        return;    }    listenerRunning = true;        int backlog = 10;    if (self.shouldUsePortUnification() || self.isSslQuorum()) {        boolean allowInsecureConnection = self.shouldUsePortUnification();        if (self.getQuorumListenOnAllIPs()) {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog);        } else {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog, self.getQuorumAddress().getAddress());        }    } else {        if (self.getQuorumListenOnAllIPs()) {            ss = new ServerSocket(port, backlog);        } else {            ss = new ServerSocket(port, backlog, self.getQuorumAddress().getAddress());        }    }    thread = new Thread(this, "ObserverMaster");    thread.start();    pinger = Executors.newSingleThreadScheduledExecutor();    pinger.scheduleAtFixedRate(ping, self.tickTime / 2, self.tickTime / 2, TimeUnit.MILLISECONDS);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    ServerSocket ss;    synchronized (this) {        ss = this.ss;    }    while (listenerRunning) {        try {            Socket s = ss.accept();                                    s.setSoTimeout(self.tickTime * self.initLimit);            BufferedInputStream is = new BufferedInputStream(s.getInputStream());            LearnerHandler lh = new LearnerHandler(s, is, this);            lh.start();        } catch (Exception e) {            if (listenerRunning) {                LOG.debug("Ignoring accept exception (maybe shutting down)", e);            } else {                LOG.debug("Ignoring accept exception (maybe client closed)", e);            }        }    }/*         * we don't need to close ss because we only got here because listenerRunning is         * false and that is set and then ss is closed() in stop()         */}
06e1ddba8663c90da407ac517f29ed70555cfe57b0332c9a96e7c696e0255364
stop
public synchronized void stop()
{    listenerRunning = false;    if (pinger != null) {        pinger.shutdownNow();    }    if (ss != null) {        try {            ss.close();        } catch (IOException e) {            e.printStackTrace();        }    }    for (LearnerHandler lh : activeObservers) {        lh.shutdown();    }}
ffccc20e11c631c089c2b81b0c3202c0b9e5f2cf1a2ad7e5666f33e2208a8fe8
getNumActiveObservers
 int getNumActiveObservers()
{    return activeObservers.size();}
ecf0b9e4665b014826e84c6259a94a58a43c3bebb3308f02b54cf742dd75f055
getActiveObservers
public Iterable<Map<String, Object>> getActiveObservers()
{    Set<Map<String, Object>> info = new HashSet<>();    for (LearnerHandler lh : activeObservers) {        info.add(lh.getLearnerHandlerInfo());    }    return info;}
bd4a022dd78d31e1264024c16d58f0c3401530d6762e8226c308883687af1d76
resetObserverConnectionStats
public void resetObserverConnectionStats()
{    for (LearnerHandler lh : activeObservers) {        lh.resetObserverConnectionStats();    }}
8cf258817074551fee59d4af4aa6ba509dd92394eee73e3eaac302fea6e93ac2
getPktsSizeLimit
 int getPktsSizeLimit()
{    return pktsSizeLimit;}
b34527e451d43cf559b7248e01396dea07b13acdee7457fddcc801f7e9746067
setPktsSizeLimit
 static void setPktsSizeLimit(final int sizeLimit)
{    pktsSizeLimit = sizeLimit;}
289ed63ad09752b2fe747baadc2b964801ce6c5a5dce8bf02946f0ba223f6338
registerLearnerHandlerBean
public void registerLearnerHandlerBean(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zks.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
d5db1f05b74ae1ce7bdd253bb3825aa85838b37964ba00e3b2ebb734ea63075d
unregisterLearnerHandlerBean
public void unregisterLearnerHandlerBean(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getObserver().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getObserver().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getObserver().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    LOG.info("ObserverRequestProcessor exited loop!");}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    if (!finished) {        Request upgradeRequest = null;        try {            upgradeRequest = zks.checkUpgradeSession(request);        } catch (KeeperException ke) {            if (request.getHdr() != null) {                request.getHdr().setType(OpCode.error);                request.setTxn(new ErrorTxn(ke.code().intValue()));            }            request.setException(ke);            LOG.info("Error creating upgrade request", ke);        } catch (IOException ie) {            LOG.error("Unexpected error in upgrade", ie);        }        if (upgradeRequest != null) {            queuedRequests.add(upgradeRequest);        }        queuedRequests.add(request);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
4dd53ed0ccc22367294bbed6ed566e71c86dfcc21fd96dabf5d9bc25864bcddb
getObserver
public Observer getObserver()
{    return self.observer;}
d4d6215fb456119d106b5f717a681421488775b8c85a263aae42ba59890c4a09
getLearner
public Learner getLearner()
{    return self.observer;}
2cdb19fed51cd766964e60e479ea5f55ab0a9c3822058e0069c41a9982eb5e78
commitRequest
public void commitRequest(Request request)
{    if (syncRequestProcessorEnabled) {                syncProcessor.processRequest(request);    }    commitProcessor.commit(request);}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{                RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new ObserverRequestProcessor(this, commitProcessor);    ((ObserverRequestProcessor) firstProcessor).start();    /*         * Observer should write to disk, so that the it won't request         * too old txn from the leader which may lead to getting an entire         * snapshot.         *         * However, this may degrade performance as it has to write to disk         * and do periodic snapshot which may double the memory requirements         */    if (syncRequestProcessorEnabled) {        syncProcessor = new SyncRequestProcessor(this, null);        syncProcessor.start();    }}
8c833bce92b79c69de87a5498bf4c1c6debbfaa7da8ccab5a54e20c6911e3d9b
sync
public synchronized void sync()
{    if (pendingSyncs.size() == 0) {        LOG.warn("Not expecting a sync.");        return;    }    Request r = pendingSyncs.remove();    commitProcessor.commit(r);}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return "observer";}
adee6d577ad1124bcdd55d9356083ab1be7b96b41b09ad125a756c3523b15a7e
shutdown
public synchronized void shutdown()
{    if (!canShutdown()) {        LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");        return;    }    super.shutdown();    if (syncRequestProcessorEnabled && syncProcessor != null) {        syncProcessor.shutdown();    }}
97a068231300388a78bf304b913f979af3c1dd05574e3b94738f52ec65f5b8ff
dumpMonitorValues
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("observer_master_id", getObserver().getLearnerMasterId());}
1bb9d826482de87041e929f03d6073d7bca36bd7359f7658f22d33e1af426037
getInputStream
public InputStream getInputStream() throws IOException
{    if (pushbackInputStream == null) {        return super.getInputStream();    }    return pushbackInputStream;}
36343ba4177f56a42a39418b593b9f60c581d04b2cacdeae8a6c8f6186cc6e11
prependToInputStream
public void prependToInputStream(byte[] bytes, int offset, int length) throws IOException
{    if (length == 0) {                return;    }    if (pushbackInputStream != null) {        throw new IOException("prependToInputStream() called more than once");    }    PushbackInputStream pushbackInputStream = new PushbackInputStream(getInputStream(), length);    pushbackInputStream.unread(bytes, offset, length);    this.pushbackInputStream = pushbackInputStream;}
46ffa8d56c2364376c7a2fb00ff1e97ead501825886406f582f8797ba07e934c
initialize
public void initialize()
{    syncProcessor.start();}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    if (request instanceof LearnerSyncRequest) {        zks.getLeader().processSync((LearnerSyncRequest) request);    } else {        nextProcessor.processRequest(request);        if (request.getHdr() != null) {                        try {                zks.getLeader().propose(request);            } catch (XidRolloverException e) {                throw new RequestProcessorException(e.getMessage(), e);            }            syncProcessor.processRequest(request);        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    nextProcessor.shutdown();    syncProcessor.shutdown();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
3f794345238de65591b64d2bba1e8755ecb34c8dc810c950cc4325312f482b69
getQuorumSize
public int getQuorumSize()
{    return peer.getQuorumSize();}
2644301152fe601b1f7b76d52dc6e356d05bcfacf4d779994a44b0d12a07883f
getSyncLimit
public int getSyncLimit()
{    return peer.getSyncLimit();}
388547177a6cafeb8c7b497ec5fafed00cdc5eeb526612bd565c9966f951d5ac
getInitLimit
public int getInitLimit()
{    return peer.getInitLimit();}
a48b86e447b7caee31ddd3bb32ba70614eee601f8b3d9b8bd8586208efad3643
setInitLimit
public void setInitLimit(int initLimit)
{    peer.setInitLimit(initLimit);}
ffade3a1568b507e1a257705f19722391b602b5b13effffbaebbb03ced7efe29
setSyncLimit
public void setSyncLimit(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
1f24414b90ab196cc53c9ade945cde75dd11aaf59d844c377e139d98115b69c8
isSslQuorum
public boolean isSslQuorum()
{    return peer.isSslQuorum();}
d3b081998a09f1556fcdd4a64a33fa84348afd8cf7822415e4b4461f734f2ac8
isPortUnification
public boolean isPortUnification()
{    return peer.shouldUsePortUnification();}
cd12704e9fde772d312061a1cf60cca0ce7c93793df4c7c4b0c93222e319f531
getObserverElectionDelayMS
public long getObserverElectionDelayMS()
{    return Observer.getObserverElectionDelayMs();}
549107f5379d5bfaa5daa3156f56f8ca23d509bbda535393fd489e70516aa7b1
setObserverElectionDelayMS
public void setObserverElectionDelayMS(long delayMS)
{    Observer.setObserverElectionDelayMs(delayMS);}
d56e7136c179879f076ce4331396b8a86b3f33fde94e15fb27982437cf3204e6
parse
public static InitialMessage parse(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException
{    Long sid;    if (protocolVersion != PROTOCOL_VERSION) {        throw new InitialMessageException("Got unrecognized protocol version %s", protocolVersion);    }    sid = din.readLong();    int remaining = din.readInt();    if (remaining <= 0 || remaining > maxBuffer) {        throw new InitialMessageException("Unreasonable buffer length: %s", remaining);    }    byte[] b = new byte[remaining];    int num_read = din.read(b);    if (num_read != remaining) {        throw new InitialMessageException("Read only %s bytes out of %s sent by server %s", num_read, remaining, sid);    }    String addr = new String(b);    String[] host_port;    try {        host_port = ConfigUtils.getHostAndPort(addr);    } catch (ConfigException e) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    if (host_port.length != 2) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    int port;    try {        port = Integer.parseInt(host_port[1]);    } catch (NumberFormatException e) {        throw new InitialMessageException("Bad port number: %s", host_port[1]);    } catch (ArrayIndexOutOfBoundsException e) {        throw new InitialMessageException("No port number in: %s", addr);    }    return new InitialMessage(sid, new InetSocketAddress(host_port[0], port));}
088e19fdbb2e68f2e7413999cd172afc813e0d238d238b7c0107668d7ba723fd
initializeAuth
private void initializeAuth(final long mySid, final QuorumAuthServer authServer, final QuorumAuthLearner authLearner, final int quorumCnxnThreadsSize, final boolean quorumSaslAuthEnabled)
{    this.authServer = authServer;    this.authLearner = authLearner;    this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;    if (!this.quorumSaslAuthEnabled) {        LOG.debug("Not initializing connection executor as quorum sasl auth is disabled");        return;    }        final AtomicInteger threadIndex = new AtomicInteger(1);    SecurityManager s = System.getSecurityManager();    final ThreadGroup group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();    ThreadFactory daemonThFactory = new ThreadFactory() {        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());            return t;        }    };    this.connectionExecutor = new ThreadPoolExecutor(3, quorumCnxnThreadsSize, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), daemonThFactory);    this.connectionExecutor.allowCoreThreadTimeOut(true);}
02166686c9ffef8abcca97b0bc3e38cb95c97860d78686958b46127a2ecadb18
newThread
public Thread newThread(Runnable r)
{    Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());    return t;}
7fd35ead9aa6da2ac49843a7218fc5f9663bea4449485d17a0c6c517e292c4fb
testInitiateConnection
public void testInitiateConnection(long sid) throws Exception
{    LOG.debug("Opening channel to server {}", sid);    Socket sock = new Socket();    setSockOpts(sock);    sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);    initiateConnection(sock, sid);}
443c69f877e9cc5ebecbb6e8581ed9670f21f1e9d699b7c445f5db4dadc534f6
initiateConnection
public void initiateConnection(final Socket sock, final Long sid)
{    try {        startConnection(sock, sid);    } catch (IOException e) {        LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection", new Object[] { sid, sock.getRemoteSocketAddress() }, e);        closeSocket(sock);        return;    }}
04daa46187bab64f8cce4dc1eaf5e86c1307db6a4fee0c77f88ce30cea446391
initiateConnectionAsync
public void initiateConnectionAsync(final Socket sock, final Long sid)
{    if (!inprogressConnections.add(sid)) {                        LOG.debug("Connection request to server id: {} is already in progress, so skipping this request", sid);        closeSocket(sock);        return;    }    try {        connectionExecutor.execute(new QuorumConnectionReqThread(sock, sid));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {                                inprogressConnections.remove(sid);        LOG.error("Exception while submitting quorum connection request", e);        closeSocket(sock);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        initiateConnection(sock, sid);    } finally {        inprogressConnections.remove(sid);    }}
b5af4478e1936e4c4ea6be8fdb5068432732e88cd98cd5856b96c5149401fe3f
startConnection
private boolean startConnection(Socket sock, Long sid) throws IOException
{    DataOutputStream dout = null;    DataInputStream din = null;    try {                        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());        dout = new DataOutputStream(buf);                        dout.writeLong(PROTOCOL_VERSION);        dout.writeLong(self.getId());        String addr = formatInetAddr(self.getElectionAddress());        byte[] addr_bytes = addr.getBytes();        dout.writeInt(addr_bytes.length);        dout.write(addr_bytes);        dout.flush();        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));    } catch (IOException e) {        LOG.warn("Ignoring exception reading or writing challenge: ", e);        closeSocket(sock);        return false;    }        QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);    if (qps != null) {                authLearner.authenticate(sock, qps.hostname);    }        if (sid > self.getId()) {        LOG.info("Have smaller server identifier, so dropping the " + "connection: (" + sid + ", " + self.getId() + ")");        closeSocket(sock);        } else {        SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();        return true;    }    return false;}
82b0df28f40ffc60e828e0c2765b23ec3852292430c63bc534ebe6d1ccb9651d
receiveConnection
public void receiveConnection(final Socket sock)
{    DataInputStream din = null;    try {        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));        handleConnection(sock, din);    } catch (IOException e) {        LOG.error("Exception handling connection, addr: {}, closing server connection", sock.getRemoteSocketAddress());        closeSocket(sock);    }}
c877930220a500b1f9135823448735ac79ba7a6dccff52c7e8c246de487125f5
receiveConnectionAsync
public void receiveConnectionAsync(final Socket sock)
{    try {        connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {        LOG.error("Exception handling connection, addr: {}, closing server connection", sock.getRemoteSocketAddress());        closeSocket(sock);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    receiveConnection(sock);}
2af78f830146c1d1d3fdfdd69c82c380c24241f3e2a888ebbf61adb74b91535d
handleConnection
private void handleConnection(Socket sock, DataInputStream din) throws IOException
{    Long sid = null, protocolVersion = null;    InetSocketAddress electionAddr = null;    try {        protocolVersion = din.readLong();        if (protocolVersion >= 0) {                        sid = protocolVersion;        } else {            try {                InitialMessage init = InitialMessage.parse(protocolVersion, din);                sid = init.sid;                electionAddr = init.electionAddr;            } catch (InitialMessage.InitialMessageException ex) {                LOG.error(ex.toString());                closeSocket(sock);                return;            }        }        if (sid == QuorumPeer.OBSERVER_ID) {            /*                 * Choose identifier at random. We need a value to identify                 * the connection.                 */            sid = observerCounter.getAndDecrement();            LOG.info("Setting arbitrary identifier to observer: " + sid);        }    } catch (IOException e) {        LOG.warn("Exception reading or writing challenge: {}", e);        closeSocket(sock);        return;    }        authServer.authenticate(sock, din);        if (sid < self.getId()) {        /*             * This replica might still believe that the connection to sid is             * up, so we have to shut down the workers before trying to open a             * new connection.             */        SendWorker sw = senderWorkerMap.get(sid);        if (sw != null) {            sw.finish();        }        /*             * Now we start a new connection             */        LOG.debug("Create new connection to server: {}", sid);        closeSocket(sock);        if (electionAddr != null) {            connectOne(sid, electionAddr);        } else {            connectOne(sid);        }    } else {                SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();    }}
57c0eff3fb4619dafd4b83e9d830b9da0ea88666666fa02785e383cad9cddcf3
toSend
public void toSend(Long sid, ByteBuffer b)
{    /*         * If sending message to myself, then simply enqueue it (loopback).         */    if (this.mySid == sid) {        b.position(0);        addToRecvQueue(new Message(b.duplicate(), sid));    /*             * Otherwise send to the corresponding thread to send.             */    } else {        /*             * Start a new connection if doesn't have one already.             */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.computeIfAbsent(sid, serverId -> new ArrayBlockingQueue<>(SEND_CAPACITY));        addToSendQueue(bq, b);        connectOne(sid);    }}
97aea28c599d41b8a7a7707cc6f2d2fbc1f281f4b2543b73f7738750f0bafe0b
connectOne
 synchronized boolean connectOne(long sid, InetSocketAddress electionAddr)
{    if (senderWorkerMap.get(sid) != null) {        LOG.debug("There is a connection already for server {}", sid);        return true;    }    Socket sock = null;    try {        LOG.debug("Opening channel to server {}", sid);        if (self.isSslQuorum()) {            sock = self.getX509Util().createSSLSocket();        } else {            sock = new Socket();        }        setSockOpts(sock);        sock.connect(electionAddr, cnxTO);        if (sock instanceof SSLSocket) {            SSLSocket sslSock = (SSLSocket) sock;            sslSock.startHandshake();            LOG.info("SSL handshake complete with {} - {} - {}", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());        }        LOG.debug("Connected to server {}", sid);                if (quorumSaslAuthEnabled) {            initiateConnectionAsync(sock, sid);        } else {            initiateConnection(sock, sid);        }        return true;    } catch (UnresolvedAddressException e) {                                        LOG.warn("Cannot open channel to " + sid + " at election address " + electionAddr, e);        closeSocket(sock);        throw e;    } catch (X509Exception e) {        LOG.warn("Cannot open secure channel to " + sid + " at election address " + electionAddr, e);        closeSocket(sock);        return false;    } catch (IOException e) {        LOG.warn("Cannot open channel to " + sid + " at election address " + electionAddr, e);        closeSocket(sock);        return false;    }}
aeb69954755a00f525d4511b0c0cf10df98dc798efbbf23c53cf4667f129d60c
connectOne
 synchronized void connectOne(long sid)
{    if (senderWorkerMap.get(sid) != null) {        LOG.debug("There is a connection already for server {}", sid);        return;    }    synchronized (self.QV_LOCK) {        boolean knownId = false;                        self.recreateSocketAddresses(sid);        Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();        if (lastCommittedView.containsKey(sid)) {            knownId = true;            if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {                return;            }        }        if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {            knownId = true;            if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {                return;            }        }        if (!knownId) {            LOG.warn("Invalid server id: " + sid);        }    }}
754f5f0b5bbda581b985244cc42c0128807a226ddee2ba1d233019ce79740ead
connectAll
public void connectAll()
{    long sid;    for (Enumeration<Long> en = queueSendMap.keys(); en.hasMoreElements(); ) {        sid = en.nextElement();        connectOne(sid);    }}
c8d5ad6ad39d65fb0ad4e8912eac0861aa21b3d5a8a6490563ddf2ef78ff39c8
haveDelivered
 boolean haveDelivered()
{    for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {        LOG.debug("Queue size: {}", queue.size());        if (queue.size() == 0) {            return true;        }    }    return false;}
09eaf0ae5188f6f2b67a395d40350eaef55fcab24a60bddfabdfe951df9354c8
halt
public void halt()
{    shutdown = true;    LOG.debug("Halting listener");    listener.halt();        try {        listener.join();    } catch (InterruptedException ex) {        LOG.warn("Got interrupted before joining the listener", ex);    }    softHalt();        if (connectionExecutor != null) {        connectionExecutor.shutdown();    }    inprogressConnections.clear();    resetConnectionThreadCount();}
b48705bafd5960c4fdbebc82cf8f2401bd6a40e05f53d5103cfe0bb7a214fa61
softHalt
public void softHalt()
{    for (SendWorker sw : senderWorkerMap.values()) {        LOG.debug("Halting sender: {}", sw);        sw.finish();    }}
bf13a4240d7d7fc86e14a7095afa4e99f3983ac955f999434c9aa3593226685d
setSockOpts
private void setSockOpts(Socket sock) throws SocketException
{    sock.setTcpNoDelay(true);    sock.setKeepAlive(tcpKeepAlive);    sock.setSoTimeout(this.socketTimeout);}
6335a581c1f2d02f2a5d9ddfc36c9d070ab3b57a90d455b30342ed2d567ce76f
closeSocket
private void closeSocket(Socket sock)
{    if (sock == null) {        return;    }    try {        sock.close();    } catch (IOException ie) {        LOG.error("Exception while closing", ie);    }}
8893206df1bccc3fea8c226f99697ea947387855d6c2b4db5834919cfc4ea03f
getThreadCount
public long getThreadCount()
{    return threadCnt.get();}
b6bfa57f98965f1497c27efd9bca6f1a20e667e88becdd31bbbce2ca905a78a4
getConnectionThreadCount
public long getConnectionThreadCount()
{    return connectionThreadCnt.get();}
9a4675afb4039f79afc6b881f1bf62e617ff173a861195189218c3d322abb40e
resetConnectionThreadCount
private void resetConnectionThreadCount()
{    connectionThreadCnt.set(0);}
d9dee01d49bdb6f99fec2b003224d38a134b0e231d80934699cf5a9d0229fef4
setSocketBindErrorHandler
 void setSocketBindErrorHandler(Runnable errorHandler)
{    this.socketBindErrorHandler = errorHandler;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    int numRetries = 0;    InetSocketAddress addr;    Socket client = null;    Exception exitException = null;    while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {        try {            if (self.shouldUsePortUnification()) {                LOG.info("Creating TLS-enabled quorum server socket");                ss = new UnifiedServerSocket(self.getX509Util(), true);            } else if (self.isSslQuorum()) {                LOG.info("Creating TLS-only quorum server socket");                ss = new UnifiedServerSocket(self.getX509Util(), false);            } else {                ss = new ServerSocket();            }            ss.setReuseAddress(true);            if (self.getQuorumListenOnAllIPs()) {                int port = self.getElectionAddress().getPort();                addr = new InetSocketAddress(port);            } else {                                                self.recreateSocketAddresses(self.getId());                addr = self.getElectionAddress();            }            LOG.info("My election bind port: " + addr.toString());            setName(addr.toString());            ss.bind(addr);            while (!shutdown) {                try {                    client = ss.accept();                    setSockOpts(client);                    LOG.info("Received connection request " + formatInetAddr((InetSocketAddress) client.getRemoteSocketAddress()));                                        if (quorumSaslAuthEnabled) {                        receiveConnectionAsync(client);                    } else {                        receiveConnection(client);                    }                    numRetries = 0;                } catch (SocketTimeoutException e) {                    LOG.warn("The socket is listening for the election accepted " + "and it timed out unexpectedly, but will retry." + "see ZOOKEEPER-2836");                }            }        } catch (IOException e) {            if (shutdown) {                break;            }            LOG.error("Exception while listening", e);            exitException = e;            numRetries++;            try {                ss.close();                Thread.sleep(1000);            } catch (IOException ie) {                LOG.error("Error closing server socket", ie);            } catch (InterruptedException ie) {                LOG.error("Interrupted while sleeping. " + "Ignoring exception", ie);            }            closeSocket(client);        }    }    LOG.info("Leaving listener");    if (!shutdown) {        LOG.error("As I'm leaving the listener thread after " + numRetries + " errors. " + "I won't be able to participate in leader " + "election any longer: " + formatInetAddr(self.getElectionAddress()) + ". Use " + ELECTION_PORT_BIND_RETRY + " property to " + "increase retry count.");        if (exitException instanceof SocketException) {                                                socketBindErrorHandler.run();        }    } else if (ss != null) {                try {            ss.close();        } catch (IOException ie) {                        LOG.debug("Error closing server socket", ie);        }    }}
c7a62c62f11c17267dd28ca70052aea01cc4a0b57ac5bd3aec5a8a331845760c
halt
 void halt()
{    try {        LOG.debug("Trying to close listener: {}", ss);        if (ss != null) {            LOG.debug("Closing listener: {}", +QuorumCnxManager.this.mySid);            ss.close();        }    } catch (IOException e) {        LOG.warn("Exception when shutting down listener: " + e);    }}
81278721d82349ac1acd91971db361d8a2b64017a098d54c3227c5a83adc7546
setRecv
 synchronized void setRecv(RecvWorker recvWorker)
{    this.recvWorker = recvWorker;}
0d336ee4a68a89d1a3d8b84a6be693cb67cbebeea1f82800b50df27af727f287
getRecvWorker
 synchronized RecvWorker getRecvWorker()
{    return recvWorker;}
fdd63581ae75fc11fd1ed94d8b5eccf15febf16ed8932394569ffb6af0f84253
finish
 synchronized boolean finish()
{    LOG.debug("Calling finish for {}", sid);    if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    closeSocket(sock);    this.interrupt();    if (recvWorker != null) {        recvWorker.finish();    }    LOG.debug("Removing entry from senderWorkerMap sid={}", sid);    senderWorkerMap.remove(sid, this);    threadCnt.decrementAndGet();    return running;}
ec8cf3fc5b5efec5ca813d86e7182ba125177322826d32843d092010a2022168
send
 synchronized void send(ByteBuffer b) throws IOException
{    byte[] msgBytes = new byte[b.capacity()];    try {        b.position(0);        b.get(msgBytes);    } catch (BufferUnderflowException be) {        LOG.error("BufferUnderflowException ", be);        return;    }    dout.writeInt(b.capacity());    dout.write(b.array());    dout.flush();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    threadCnt.incrementAndGet();    try {        /**         * If there is nothing in the queue to send, then we         * send the lastMessage to ensure that the last message         * was received by the peer. The message could be dropped         * in case self or the peer shutdown their connection         * (and exit the thread) prior to reading/processing         * the last message. Duplicate messages are handled correctly         * by the peer.         *         * If the send queue is non-empty, then we have a recent         * message than that stored in lastMessage. To avoid sending         * stale message, we should send the message in the send queue.         */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);        if (bq == null || isSendQueueEmpty(bq)) {            ByteBuffer b = lastMessageSent.get(sid);            if (b != null) {                LOG.debug("Attempting to send lastMessage to sid={}", sid);                send(b);            }        }    } catch (IOException e) {        LOG.error("Failed to send last message. Shutting down thread.", e);        this.finish();    }    try {        while (running && !shutdown && sock != null) {            ByteBuffer b = null;            try {                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                if (bq != null) {                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);                } else {                    LOG.error("No queue of incoming messages for " + "server " + sid);                    break;                }                if (b != null) {                    lastMessageSent.put(sid, b);                    send(b);                }            } catch (InterruptedException e) {                LOG.warn("Interrupted while waiting for message on queue", e);            }        }    } catch (Exception e) {        LOG.warn("Exception when using channel: for id " + sid + " my id = " + QuorumCnxManager.this.mySid + " error = " + e);    }    this.finish();    LOG.warn("Send worker leaving thread " + " id " + sid + " my id = " + self.getId());}
fdd63581ae75fc11fd1ed94d8b5eccf15febf16ed8932394569ffb6af0f84253
finish
 synchronized boolean finish()
{    if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    this.interrupt();    threadCnt.decrementAndGet();    return running;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    threadCnt.incrementAndGet();    try {        while (running && !shutdown && sock != null) {            /**             * Reads the first int to determine the length of the             * message             */            int length = din.readInt();            if (length <= 0 || length > PACKETMAXSIZE) {                throw new IOException("Received packet with invalid packet: " + length);            }            /**             * Allocates a new ByteBuffer to receive the message             */            final byte[] msgArray = new byte[length];            din.readFully(msgArray, 0, length);            addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));        }    } catch (Exception e) {        LOG.warn("Connection broken for id " + sid + ", my id = " + QuorumCnxManager.this.mySid + ", error = ", e);    } finally {        LOG.warn("Interrupting SendWorker");        sw.finish();        closeSocket(sock);    }}
c38e84559aa7619263fd1a58a4f560ea174856cf501d949f83225331344fa703
addToSendQueue
private void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue, ByteBuffer buffer)
{    if (queue.remainingCapacity() == 0) {        try {            queue.remove();        } catch (NoSuchElementException ne) {                        LOG.debug("Trying to remove from an empty " + "Queue. Ignoring exception.", ne);        }    }    try {        queue.add(buffer);    } catch (IllegalStateException ie) {                LOG.error("Unable to insert an element in the queue " + ie);    }}
aa020b67bef225d0f520eae77a21a69c54f43ea0af4fe854bf4551cc07f56be3
isSendQueueEmpty
private boolean isSendQueueEmpty(ArrayBlockingQueue<ByteBuffer> queue)
{    return queue.isEmpty();}
8357a6846d0b4244e79c7877cef42bce5340a63fe1a2d293f15939111ab0fe80
pollSendQueue
private ByteBuffer pollSendQueue(ArrayBlockingQueue<ByteBuffer> queue, long timeout, TimeUnit unit) throws InterruptedException
{    return queue.poll(timeout, unit);}
ba31a3ececfd23c685505798d21a7d7a434c870b49b2a5d69af0d56976f758f0
addToRecvQueue
public void addToRecvQueue(Message msg)
{    synchronized (recvQLock) {        if (recvQueue.remainingCapacity() == 0) {            try {                recvQueue.remove();            } catch (NoSuchElementException ne) {                                LOG.debug("Trying to remove from an empty " + "recvQueue. Ignoring exception.", ne);            }        }        try {            recvQueue.add(msg);        } catch (IllegalStateException ie) {                        LOG.error("Unable to insert element in the recvQueue " + ie);        }    }}
5328e6c76eb19b172f662b07fecb6e5fecb17f20728dd6f01dc7b21c8ef73ca9
pollRecvQueue
public Message pollRecvQueue(long timeout, TimeUnit unit) throws InterruptedException
{    return recvQueue.poll(timeout, unit);}
f28d2628451a69c0f9d300ab95ddc8f002edb9b043cc6c5597f6534be1be4509
connectedToPeer
public boolean connectedToPeer(long peerSid)
{    return senderWorkerMap.get(peerSid) != null;}
22acfff0375c43781616e1e5fbad958defdb85eb68bf618040bb5f3cb9644e8d
getObserverMasterPort
public int getObserverMasterPort()
{    return observerMasterPort;}
a8405893bcba8cb0b95c18960a39e5d49066559497b0d1323d9815f46210f2e5
setObserverMasterPort
public void setObserverMasterPort(int observerMasterPort)
{    this.observerMasterPort = observerMasterPort;}
12988e32fb9e7822231bf05b7d2b2013fd70cf350e185d48e6fdacbe7847e62e
getId
public long getId()
{    return id;}
f8fafe9e48d5693b89b57775db4c99e74c2652fa8a11be36660664215ba8c816
recreateSocketAddresses
public void recreateSocketAddresses()
{    if (this.addr == null) {        LOG.warn("Server address has not been initialized");        return;    }    if (this.electionAddr == null) {        LOG.warn("Election address has not been initialized");        return;    }    String host = this.addr.getHostString();    InetAddress address = null;    try {        address = InetAddress.getByName(host);    } catch (UnknownHostException ex) {        LOG.warn("Failed to resolve address: {}", host, ex);        return;    }    LOG.debug("Resolved address for {}: {}", host, address);    int port = this.addr.getPort();    this.addr = new InetSocketAddress(address, port);    port = this.electionAddr.getPort();    this.electionAddr = new InetSocketAddress(address, port);}
82785754dd9ef370f3b64e63e604ead941c86f19acf0372055e9828f5b54bd05
setType
private void setType(String s) throws ConfigException
{    if (s.toLowerCase().equals("observer")) {        type = LearnerType.OBSERVER;    } else if (s.toLowerCase().equals("participant")) {        type = LearnerType.PARTICIPANT;    } else {        throw new ConfigException("Unrecognised peertype: " + s);    }}
7f560969d5ad17fee0faa5ea936ee36f446312e0b2358fe3f34981cc873825e1
setMyAddrs
private void setMyAddrs()
{    this.myAddrs = new ArrayList<InetSocketAddress>();    this.myAddrs.add(this.addr);    this.myAddrs.add(this.clientAddr);    this.myAddrs.add(this.electionAddr);    this.myAddrs = excludedSpecialAddresses(this.myAddrs);}
efb0bba512b8ceb1f55545051590b773fd8407d7bea9f6d5d656ae0af1a8248b
delimitedHostString
public static String delimitedHostString(InetSocketAddress addr)
{    String host = addr.getHostString();    if (host.contains(":")) {        return "[" + host + "]";    } else {        return host;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringWriter sw = new StringWriter();        if (addr != null) {        sw.append(delimitedHostString(addr));        sw.append(":");        sw.append(String.valueOf(addr.getPort()));    }    if (electionAddr != null) {        sw.append(":");        sw.append(String.valueOf(electionAddr.getPort()));    }    if (type == LearnerType.OBSERVER) {        sw.append(":observer");    } else if (type == LearnerType.PARTICIPANT) {        sw.append(":participant");    }    if (clientAddr != null && !isClientAddrFromStatic) {        sw.append(";");        sw.append(delimitedHostString(clientAddr));        sw.append(":");        sw.append(String.valueOf(clientAddr.getPort()));    }    return sw.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    assert false : "hashCode not designed";        return 42;}
4ac81e282005cc05927943678a4706d304de57064e55390d8940c843f2d6211e
checkAddressesEqual
private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2)
{    return (addr1 != null || addr2 == null) && (addr1 == null || addr2 != null) && (addr1 == null || addr2 == null || addr1.equals(addr2));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof QuorumServer)) {        return false;    }    QuorumServer qs = (QuorumServer) o;    if ((qs.id != id) || (qs.type != type)) {        return false;    }    if (!checkAddressesEqual(addr, qs.addr)) {        return false;    }    if (!checkAddressesEqual(electionAddr, qs.electionAddr)) {        return false;    }    return checkAddressesEqual(clientAddr, qs.clientAddr);}
653fd61e73681c243d679922a481c8170e0715df6fccd3a080cc280919751478
checkAddressDuplicate
public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException
{    List<InetSocketAddress> otherAddrs = new ArrayList<InetSocketAddress>();    otherAddrs.add(s.addr);    otherAddrs.add(s.clientAddr);    otherAddrs.add(s.electionAddr);    otherAddrs = excludedSpecialAddresses(otherAddrs);    for (InetSocketAddress my : this.myAddrs) {        for (InetSocketAddress other : otherAddrs) {            if (my.equals(other)) {                String error = String.format("%s of server.%d conflicts %s of server.%d", my, this.id, other, s.id);                throw new BadArgumentsException(error);            }        }    }}
1e3ec9e5c573b222417fd946b4de2da2644f77115a88e905e4a97fcb6af3d2b3
excludedSpecialAddresses
private List<InetSocketAddress> excludedSpecialAddresses(List<InetSocketAddress> addrs)
{    List<InetSocketAddress> included = new ArrayList<>();    for (InetSocketAddress addr : addrs) {        if (addr == null) {            continue;        }        InetAddress inetaddr = addr.getAddress();        if (        inetaddr == null || inetaddr.isAnyLocalAddress() || inetaddr.isLoopbackAddress()) {                        continue;        }        included.add(addr);    }    return included;}
a011ad4d61ad8cc3da7df8684ed9f78b9b0f6dd6ddee5a5c791497cd3c58c3e2
getLearnerType
public LearnerType getLearnerType()
{    return learnerType;}
c9b023b9c237745d3ff6cc0a1f586c7a3c51cedf66bfab1aa5b82a1d02f12d94
setLearnerType
public void setLearnerType(LearnerType p)
{    learnerType = p;}
0e1e3cad8add68a31b21452bfe2bd2b07c0a6540722c3c973202abf4b4ea3ac6
setConfigFileName
protected synchronized void setConfigFileName(String s)
{    configFilename = s;}
3f794345238de65591b64d2bba1e8755ecb34c8dc810c950cc4325312f482b69
getQuorumSize
public int getQuorumSize()
{    return getVotingView().size();}
e2b322583c435266c39500e673181d397a9c5df96a541b8a958193342cdf2c2c
setJvmPauseMonitor
public void setJvmPauseMonitor(JvmPauseMonitor jvmPauseMonitor)
{    this.jvmPauseMonitor = jvmPauseMonitor;}
12988e32fb9e7822231bf05b7d2b2013fd70cf350e185d48e6fdacbe7847e62e
getId
public long getId()
{    return myid;}
6d837b61a6faeafecf5ef77bd9ea80fcc33753437de255356b7a311bbeb8659b
setId
 void setId(long id)
{    this.myid = id;}
1f24414b90ab196cc53c9ade945cde75dd11aaf59d844c377e139d98115b69c8
isSslQuorum
public boolean isSslQuorum()
{    return sslQuorum;}
17147c8d7a539a4c13f2d32180e066d1caf3a4c7fc017d3200a625a4d797fcdd
shouldUsePortUnification
public boolean shouldUsePortUnification()
{    return shouldUsePortUnification;}
fa65742bcd3167f669a4c2599432e05b532b9440d5bad75a3f6706104e5ade7f
getX509Util
 QuorumX509Util getX509Util()
{    return x509Util;}
eecf36016afd00cbc35e3f4cd02b9371fbbecaf3e51e7438757e91553d371489
getCurrentVote
public synchronized Vote getCurrentVote()
{    return currentVote;}
02043e4ec6f6ab84d4ed678a02505979a65704f7f5920af51e8260d573eb1884
setCurrentVote
public synchronized void setCurrentVote(Vote v)
{    currentVote = v;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        byte[] b = new byte[36];        ByteBuffer responseBuffer = ByteBuffer.wrap(b);        DatagramPacket packet = new DatagramPacket(b, b.length);        while (running) {            udpSocket.receive(packet);            if (packet.getLength() != 4) {                LOG.warn("Got more than just an xid! Len = " + packet.getLength());            } else {                responseBuffer.clear();                                responseBuffer.getInt();                responseBuffer.putLong(myid);                Vote current = getCurrentVote();                switch(getPeerState()) {                    case LOOKING:                        responseBuffer.putLong(current.getId());                        responseBuffer.putLong(current.getZxid());                        break;                    case LEADING:                        responseBuffer.putLong(myid);                        try {                            long proposed;                            synchronized (leader) {                                proposed = leader.lastProposed;                            }                            responseBuffer.putLong(proposed);                        } catch (NullPointerException npe) {                                                                        }                        break;                    case FOLLOWING:                        responseBuffer.putLong(current.getId());                        try {                            responseBuffer.putLong(follower.getZxid());                        } catch (NullPointerException npe) {                                                                        }                        break;                    case OBSERVING:                                                break;                }                packet.setData(b);                udpSocket.send(packet);            }            packet.setLength(b.length);        }    } catch (RuntimeException e) {        LOG.warn("Unexpected runtime exception in ResponderThread", e);    } catch (IOException e) {        LOG.warn("Unexpected IO exception in ResponderThread", e);    } finally {        LOG.warn("QuorumPeer responder thread exited");    }}
21d1d43509f2d59af6546c417b7375858e625b6eadc14515a82f0a3494dc30a7
setPeerState
public synchronized void setPeerState(ServerState newState)
{    state = newState;    if (newState == ServerState.LOOKING) {        setLeaderAddressAndId(null, -1);        setZabState(ZabState.ELECTION);    } else {        LOG.info("Peer state changed: {}", getDetailedPeerState());    }}
4f4d3af1bf6fefd4726eb68962111d1d64c7871750b8c2c52b9410b755a02b34
setZabState
public void setZabState(ZabState zabState)
{    this.zabState.set(zabState);    LOG.info("Peer state changed: {}", getDetailedPeerState());}
1e6dcdec2db0ca8f3c3819dfc3380f396d53a128519233cce0d15fb1c908beb8
setSyncMode
public void setSyncMode(SyncMode syncMode)
{    this.syncMode.set(syncMode);    LOG.info("Peer state changed: {}", getDetailedPeerState());}
0adb2220a8105e4aae58781e98804ff853579b94d1c40e843232a08268a5a037
getZabState
public ZabState getZabState()
{    return zabState.get();}
bd954ca62c766ee06c514839631e66363c31827e7ea3fda3dc4a0b3970887006
getSyncMode
public SyncMode getSyncMode()
{    return syncMode.get();}
af5ffb6dfbb4cddc19c71f74f24ebb9102d1a62d88c1a8ada1b23d0cfa0b388a
setLeaderAddressAndId
public void setLeaderAddressAndId(InetSocketAddress addr, long newId)
{    if (addr != null) {        leaderAddress.set(addr.getHostString());    } else {        leaderAddress.set(null);    }    leaderId.set(newId);}
30d436753fbe86eb13f0cf1d09d8feb2f5cbd99af592e816cb7e84e62bb7f161
getLeaderAddress
public String getLeaderAddress()
{    return leaderAddress.get();}
ee282172b3d7bee087a83d5dd68fabdbb017e771bc8b011ff2c48ddee3dc73b5
getLeaderId
public long getLeaderId()
{    return leaderId.get();}
926ce65b31158bd99b25b6e33753dd165fcc773bb0449ec4827d3f01d87c35b5
getDetailedPeerState
public String getDetailedPeerState()
{    final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());    final ZabState zabState = getZabState();    if (!ZabState.ELECTION.equals(zabState)) {        sb.append(" - ").append(zabState.toString().toLowerCase());    }    final SyncMode syncMode = getSyncMode();    if (!SyncMode.NONE.equals(syncMode)) {        sb.append(" - ").append(syncMode.toString().toLowerCase());    }    return sb.toString();}
16514113b43f233db7a44e0397b3fee7719448487fcecea46d921a7a18c93008
reconfigFlagSet
public synchronized void reconfigFlagSet()
{    reconfigFlag = true;}
9030038f497ff5b9d68e4dfe23c9497ba5fe847039c48d77dae368d90135d7a9
reconfigFlagClear
public synchronized void reconfigFlagClear()
{    reconfigFlag = false;}
339185951ab9e1c5807ad0335a25c6ed7cd5c52dc74f9047b539bb2e1adea047
isReconfigStateChange
public synchronized boolean isReconfigStateChange()
{    return reconfigFlag;}
f3a6e9f66ab327dd4c910ab39724f71273d8407dbeed46ae78947366282e7e4d
getPeerState
public synchronized ServerState getPeerState()
{    return state;}
e33e8ae08d92b1602e6f9733edb4728603fd065086822520d15ef5315c219ab2
recreateSocketAddresses
public void recreateSocketAddresses(long id)
{    QuorumVerifier qv = getQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();            if (id == getId()) {                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);            }        }    }    qv = getLastSeenQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();        }    }}
10e65dd563e3d3886b344021d8ba491769b570ba174418a86123640ced0f0c30
getAddrs
private AddressTuple getAddrs()
{    AddressTuple addrs = myAddrs.get();    if (addrs != null) {        return addrs;    }    try {        synchronized (QV_LOCK) {            addrs = myAddrs.get();            while (addrs == null) {                QV_LOCK.wait();                addrs = myAddrs.get();            }            return addrs;        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw new RuntimeException(e);    }}
fe49c1bcdd9cc1f431f353df1d094c8194b9f49bbed51ca0f2348d646e99f6a7
getQuorumAddress
public InetSocketAddress getQuorumAddress()
{    return getAddrs().quorumAddr;}
f739cb64aa8b25e307a33dd04b9bb3df6d58c03948d8a3d37da57af6f10a86b1
getElectionAddress
public InetSocketAddress getElectionAddress()
{    return getAddrs().electionAddr;}
f34cd24720360f65540b537bc796effb0e88616905acfb2e710ac240b47ed084
getClientAddress
public InetSocketAddress getClientAddress()
{    final AddressTuple addrs = myAddrs.get();    return (addrs == null) ? null : addrs.clientAddr;}
f2355477a31e8a7674a940efcf8fdae37ec2d698ab20b7d794f61b6a0e0c0114
setAddrs
private void setAddrs(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr)
{    synchronized (QV_LOCK) {        myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));        QV_LOCK.notifyAll();    }}
cabc3b772104518be87f485ba5fd767a52f0371516b4f7ea9e64a5f21c17aefb
testingQuorumPeer
public static QuorumPeer testingQuorumPeer() throws SaslException
{    return new QuorumPeer();}
cf85373306321df6b784fb5bbfccd9dc3facce15d9f658a24f19e13f3e24925c
createX509Util
 QuorumX509Util createX509Util()
{    return new QuorumX509Util();}
1ec1c4c35c3dd8f790da3b869390b1727915272a7306217d6e90f669721c93ce
initialize
public void initialize() throws SaslException
{        if (isQuorumSaslAuthEnabled()) {        Set<String> authzHosts = new HashSet<String>();        for (QuorumServer qs : getView().values()) {            authzHosts.add(qs.hostname);        }        authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);        authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);    } else {        authServer = new NullQuorumAuthServer();        authLearner = new NullQuorumAuthLearner();    }}
6395d59fe01daf17405c1641679e2f10d4d67e4992086aa8bff6fda54ed8c3e6
quorumStats
 QuorumStats quorumStats()
{    return quorumStats;}
5b05914888e421f26bff6f39231facdd35759f746a9af780ebac2cf5b2c81932
start
public synchronized void start()
{    if (!getView().containsKey(myid)) {        throw new RuntimeException("My id " + myid + " not in the peer list");    }    loadDataBase();    startServerCnxnFactory();    try {        adminServer.start();    } catch (AdminServerException e) {        LOG.warn("Problem starting AdminServer", e);        System.out.println(e);    }    startLeaderElection();    startJvmPauseMonitor();    super.start();}
ff164492a8c23dc5fac7252ff1a6e7ea5cbde9494c46afddb0e7c8e435aabf12
loadDataBase
private void loadDataBase()
{    try {        zkDb.loadDataBase();                long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);        try {            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                currentEpoch = epochOfZxid;            LOG.info(CURRENT_EPOCH_FILENAME + " not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation", currentEpoch);            writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);        }        if (epochOfZxid > currentEpoch) {            throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + ", is older than the last zxid, " + lastProcessedZxid);        }        try {            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                acceptedEpoch = epochOfZxid;            LOG.info(ACCEPTED_EPOCH_FILENAME + " not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation", acceptedEpoch);            writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);        }        if (acceptedEpoch < currentEpoch) {            throw new IOException("The accepted epoch, " + ZxidUtils.zxidToString(acceptedEpoch) + " is less than the current epoch, " + ZxidUtils.zxidToString(currentEpoch));        }    } catch (IOException ie) {        LOG.error("Unable to load database on disk", ie);        throw new RuntimeException("Unable to run quorum server ", ie);    }}
1e26fbb6e40d1a1526ebcd8f729342411e2e04185791caa95c148332a77a1d97
stopLeaderElection
public synchronized void stopLeaderElection()
{    responder.running = false;    responder.interrupt();}
a45e55763a2f452abe418c25a26855acb61cb796ba8d8668bf849849f23bb35c
startLeaderElection
public synchronized void startLeaderElection()
{    try {        if (getPeerState() == ServerState.LOOKING) {            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());        }    } catch (IOException e) {        RuntimeException re = new RuntimeException(e.getMessage());        re.setStackTrace(e.getStackTrace());        throw re;    }    this.electionAlg = createElectionAlgorithm(electionType);}
99faf53167f2309d6e57e0036cae01f2d9c9104ae3ef310d2309a6fc456537b1
startJvmPauseMonitor
private void startJvmPauseMonitor()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
2ca56aa3c4cc37305418a57f59a7e28170a496c1734e12cc64212e6b0b77399a
countParticipants
protected static int countParticipants(Map<Long, QuorumServer> peers)
{    int count = 0;    for (QuorumServer q : peers.values()) {        if (q.type == LearnerType.PARTICIPANT) {            count++;        }    }    return count;}
512fca70953b4e3dd632aa6bdd9349a187c4fe33f11d7e0b208a7eb2db758270
getClientAddress
private static InetSocketAddress getClientAddress(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort) throws IOException
{    QuorumServer quorumServer = quorumPeers.get(myid);    if (null == quorumServer) {        throw new IOException("No QuorumServer correspoding to myid " + myid);    }    if (null == quorumServer.clientAddr) {        return new InetSocketAddress(clientPort);    }    if (quorumServer.clientAddr.getPort() != clientPort) {        throw new IOException("QuorumServer port " + quorumServer.clientAddr.getPort() + " does not match with given port " + clientPort);    }    return quorumServer.clientAddr;}
2c9670d04327ce3ca4f0ceca8f612ee06721695b2d2cd2a76287a9686e5cbc5b
getLastLoggedZxid
public long getLastLoggedZxid()
{    if (!zkDb.isInitialized()) {        loadDataBase();    }    return zkDb.getDataTreeLastProcessedZxid();}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));}
9105ffbff8576ef0e9b7d69e245693472292266ab9ff7dec3ef6d54033fdb402
makeLeader
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));}
25c587e33f5a06e39ba45b3b3f7a22e156ed0ffc825a7a80d28b163a844905db
makeObserver
protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException
{    return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));}
c63c9277e93c024f486983d709d75e1e6da997024a838ee0a4a196dfaf1920ee
createElectionAlgorithm
protected Election createElectionAlgorithm(int electionAlgorithm)
{    Election le = null;        switch(electionAlgorithm) {        case 1:            le = new AuthFastLeaderElection(this);            break;        case 2:            le = new AuthFastLeaderElection(this, true);            break;        case 3:            QuorumCnxManager qcm = createCnxnManager();            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);            if (oldQcm != null) {                LOG.warn("Clobbering already-set QuorumCnxManager (restarting leader election?)");                oldQcm.halt();            }            QuorumCnxManager.Listener listener = qcm.listener;            if (listener != null) {                listener.start();                FastLeaderElection fle = new FastLeaderElection(this, qcm);                fle.start();                le = fle;            } else {                LOG.error("Null listener when initializing cnx manager");            }            break;        default:            assert false;    }    return le;}
99e06a3e825390291cb4eb6202c5f372e986b487a8208de7d83fd0933e8fca1d
makeLEStrategy
protected Election makeLEStrategy()
{    LOG.debug("Initializing leader election protocol...");    return electionAlg;}
00fa9db8df2f699570060e81a7d49fa52d9b3a3de14b7bede472b83e5349c6f2
setLeader
protected synchronized void setLeader(Leader newLeader)
{    leader = newLeader;}
8e59580291667233579429637de227bf7144074716ddab9b0ba2b4cac1aeb216
setFollower
protected synchronized void setFollower(Follower newFollower)
{    follower = newFollower;}
aa05d5e556329a394d2c7f05bc6216a00fd4505cb99cefb4ac06bd0fbca6f81b
setObserver
protected synchronized void setObserver(Observer newObserver)
{    observer = newObserver;}
e78792c2876d98602764c864ef6e50471b97027d3a5dafa6d24119f78f780f82
getActiveServer
public synchronized ZooKeeperServer getActiveServer()
{    if (leader != null) {        return leader.zk;    } else if (follower != null) {        return follower.zk;    } else if (observer != null) {        return observer.zk;    }    return null;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    updateThreadName();    LOG.debug("Starting quorum peer");    try {        jmxQuorumBean = new QuorumBean(this);        MBeanRegistry.getInstance().register(jmxQuorumBean, null);        for (QuorumServer s : getView().values()) {            ZKMBeanInfo p;            if (getId() == s.id) {                p = jmxLocalPeerBean = new LocalPeerBean(this);                try {                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);                } catch (Exception e) {                    LOG.warn("Failed to register with JMX", e);                    jmxLocalPeerBean = null;                }            } else {                RemotePeerBean rBean = new RemotePeerBean(this, s);                try {                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);                    jmxRemotePeerBean.put(s.id, rBean);                } catch (Exception e) {                    LOG.warn("Failed to register with JMX", e);                }            }        }    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxQuorumBean = null;    }    try {        /*             * Main loop             */        while (running) {            switch(getPeerState()) {                case LOOKING:                    LOG.info("LOOKING");                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);                    if (Boolean.getBoolean("readonlymode.enabled")) {                        LOG.info("Attempting to start ReadOnlyZooKeeperServer");                                                final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);                                                                                                                                                                        Thread roZkMgr = new Thread() {                            public void run() {                                try {                                                                        sleep(Math.max(2000, tickTime));                                    if (ServerState.LOOKING.equals(getPeerState())) {                                        roZk.startup();                                    }                                } catch (InterruptedException e) {                                    LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");                                } catch (Exception e) {                                    LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);                                }                            }                        };                        try {                            roZkMgr.start();                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                            LOG.warn("Unexpected exception", e);                            setPeerState(ServerState.LOOKING);                        } finally {                                                                                    roZkMgr.interrupt();                            roZk.shutdown();                        }                    } else {                        try {                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                            LOG.warn("Unexpected exception", e);                            setPeerState(ServerState.LOOKING);                        }                    }                    break;                case OBSERVING:                    try {                        LOG.info("OBSERVING");                        setObserver(makeObserver(logFactory));                        observer.observeLeader();                    } catch (Exception e) {                        LOG.warn("Unexpected exception", e);                    } finally {                        observer.shutdown();                        setObserver(null);                        updateServerState();                                                if (isRunning()) {                            Observer.waitForObserverElectionDelay();                        }                    }                    break;                case FOLLOWING:                    try {                        LOG.info("FOLLOWING");                        setFollower(makeFollower(logFactory));                        follower.followLeader();                    } catch (Exception e) {                        LOG.warn("Unexpected exception", e);                    } finally {                        follower.shutdown();                        setFollower(null);                        updateServerState();                    }                    break;                case LEADING:                    LOG.info("LEADING");                    try {                        setLeader(makeLeader(logFactory));                        leader.lead();                        setLeader(null);                    } catch (Exception e) {                        LOG.warn("Unexpected exception", e);                    } finally {                        if (leader != null) {                            leader.shutdown("Forcing shutdown");                            setLeader(null);                        }                        updateServerState();                    }                    break;            }        }    } finally {        LOG.warn("QuorumPeer main thread exited");        MBeanRegistry instance = MBeanRegistry.getInstance();        instance.unregister(jmxQuorumBean);        instance.unregister(jmxLocalPeerBean);        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {            instance.unregister(remotePeerBean);        }        jmxQuorumBean = null;        jmxLocalPeerBean = null;        jmxRemotePeerBean = null;    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {                sleep(Math.max(2000, tickTime));        if (ServerState.LOOKING.equals(getPeerState())) {            roZk.startup();        }    } catch (InterruptedException e) {        LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");    } catch (Exception e) {        LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);    }}
ef00eb21ba0ac17b30c1396fac61f12f12dfb8e4ea956ec0ec1ce84f9617dad2
updateServerState
private synchronized void updateServerState()
{    if (!reconfigFlag) {        setPeerState(ServerState.LOOKING);        LOG.warn("PeerState set to LOOKING");        return;    }    if (getId() == getCurrentVote().getId()) {        setPeerState(ServerState.LEADING);        LOG.debug("PeerState set to LEADING");    } else if (getLearnerType() == LearnerType.PARTICIPANT) {        setPeerState(ServerState.FOLLOWING);        LOG.debug("PeerState set to FOLLOWING");    } else if (getLearnerType() == LearnerType.OBSERVER) {        setPeerState(ServerState.OBSERVING);        LOG.debug("PeerState set to OBSERVER");    } else {                setPeerState(ServerState.LOOKING);        LOG.debug("Should not be here");    }    reconfigFlag = false;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    running = false;    x509Util.close();    if (leader != null) {        leader.shutdown("quorum Peer shutdown");    }    if (follower != null) {        follower.shutdown();    }    shutdownServerCnxnFactory();    if (udpSocket != null) {        udpSocket.close();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    try {        adminServer.shutdown();    } catch (AdminServerException e) {        LOG.warn("Problem stopping AdminServer", e);    }    if (getElectionAlg() != null) {        this.interrupt();        getElectionAlg().shutdown();    }    try {        zkDb.close();    } catch (IOException ie) {        LOG.warn("Error closing logs ", ie);    }}
232bd2c33861df5a08ad9a6d1a2b9b13d7f0492cae47bf0d84849e2b0df7b3d1
getView
public Map<Long, QuorumPeer.QuorumServer> getView()
{    return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());}
7d26602c3f3d0ba0b45b0f184cd6ad942a78f0471ace38ffb3b5d3eae66ca871
getVotingView
public Map<Long, QuorumPeer.QuorumServer> getVotingView()
{    return getQuorumVerifier().getVotingMembers();}
1dd188225d110950ff457683b061e417530dd2efaee770a871c133fe07520917
getObservingView
public Map<Long, QuorumPeer.QuorumServer> getObservingView()
{    return getQuorumVerifier().getObservingMembers();}
b99ba7ce34f7bc42973fe4bdf5fcc47a77d2d2fcd5f9b7a87f3665cce68b239e
getCurrentAndNextConfigVoters
public synchronized Set<Long> getCurrentAndNextConfigVoters()
{    Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());    if (getLastSeenQuorumVerifier() != null) {        voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());    }    return voterIds;}
8e8016f8af7578a7f63d7fd300d98565b7809a1fe82041c1e8b709760f18e52c
viewContains
public boolean viewContains(Long sid)
{    return this.getView().containsKey(sid);}
9c37ac8657f610d850a2f6ee72ef31edfa9428d837eff4ecc6366af0d1bb7fba
getQuorumPeers
public String[] getQuorumPeers()
{    List<String> l = new ArrayList<String>();    synchronized (this) {        if (leader != null) {            for (LearnerHandler fh : leader.getLearners()) {                if (fh.getSocket() != null) {                    String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());                    if (leader.isLearnerSynced(fh)) {                        s += "*";                    }                    l.add(s);                }            }        } else if (follower != null) {            l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));        }    }    return l.toArray(new String[0]);}
37bd970c873b1caba1f416cd3451f9136748408cb1498857ffad8d8312e41b1f
getServerState
public String getServerState()
{    switch(getPeerState()) {        case LOOKING:            return QuorumStats.Provider.LOOKING_STATE;        case LEADING:            return QuorumStats.Provider.LEADING_STATE;        case FOLLOWING:            return QuorumStats.Provider.FOLLOWING_STATE;        case OBSERVING:            return QuorumStats.Provider.OBSERVING_STATE;    }    return QuorumStats.Provider.UNKNOWN_STATE;}
9581fe0ac39677469214a8023936696919c17fe627c959f18b74fe12ad866965
setMyid
public void setMyid(long myid)
{    this.myid = myid;}
69ee006e6da6399457df589c94a87885c17ec171b14900a73388d9708dc26cd3
setInitialConfig
public void setInitialConfig(String initialConfig)
{    this.initialConfig = initialConfig;}
325790059f5a28565470268695098e1c1c93b49e375e1585af6007fbd67a53b5
getInitialConfig
public String getInitialConfig()
{    return initialConfig;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
0d6966d4d2bfb5d3b8035f2c56cec288052672eb0e42eb6d15d224b082eb65ea
setTickTime
public void setTickTime(int tickTime)
{    LOG.info("tickTime set to " + tickTime);    this.tickTime = tickTime;}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    if (cnxnFactory != null) {        return cnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureCnxnFactory != null) {        return secureCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
e0f64db7c5bc5c260b2fd1005366491fbf1e65f7c0c4412f4f3e3c17da260e69
areLocalSessionsEnabled
public boolean areLocalSessionsEnabled()
{    return localSessionsEnabled;}
048d3b210a30c7bc09ca87909e89a503dd48a5afb2b2fd5727a8537e6581429e
enableLocalSessions
public void enableLocalSessions(boolean flag)
{    LOG.info("Local sessions " + (flag ? "enabled" : "disabled"));    localSessionsEnabled = flag;}
9b5f9e97c3ccdb2959cac0e38fd1db22d0f45901c30be48d6e1fa1ff8b693fbd
isLocalSessionsUpgradingEnabled
public boolean isLocalSessionsUpgradingEnabled()
{    return localSessionsUpgradingEnabled;}
3d8a7b65e2d3b3df250653aac30ac7e109a331913c033328e244f9510862c1ca
enableLocalSessionsUpgrading
public void enableLocalSessionsUpgrading(boolean flag)
{    LOG.info("Local session upgrading " + (flag ? "enabled" : "disabled"));    localSessionsUpgradingEnabled = flag;}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return minSessionTimeout;}
a03c3c05a71bf800194b521733ced5214de44c096d31920ced1b52e5b654940f
setMinSessionTimeout
public void setMinSessionTimeout(int min)
{    LOG.info("minSessionTimeout set to " + min);    this.minSessionTimeout = min;}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
e9b7c64f4f17dddb9212cd8da3a73048bf6c25b41d3a43266bfafdc6e8e0fa48
setMaxSessionTimeout
public void setMaxSessionTimeout(int max)
{    LOG.info("maxSessionTimeout set to " + max);    this.maxSessionTimeout = max;}
ec5585a4b2b943741ce33cf2955fc89a6570f314127c8e967a69575e8e422e3e
getClientPortListenBacklog
public int getClientPortListenBacklog()
{    return this.clientPortListenBacklog;}
4d4e0837f07117cdb2aee64697c76d07d427be9df2abb90f7708dfe90c9902c6
setClientPortListenBacklog
public void setClientPortListenBacklog(int backlog)
{    this.clientPortListenBacklog = backlog;}
388547177a6cafeb8c7b497ec5fafed00cdc5eeb526612bd565c9966f951d5ac
getInitLimit
public int getInitLimit()
{    return initLimit;}
a48b86e447b7caee31ddd3bb32ba70614eee601f8b3d9b8bd8586208efad3643
setInitLimit
public void setInitLimit(int initLimit)
{    LOG.info("initLimit set to " + initLimit);    this.initLimit = initLimit;}
9882bc525a6f8f9a45efba59fca68d684fe4984d864a8948fe11ce54be311be5
getTick
public int getTick()
{    return tick.get();}
90c765c8d602bb717b8fb46895f877b53922c8ed15f8def364121ece9dd0a17f
configFromString
public QuorumVerifier configFromString(String s) throws IOException, ConfigException
{    Properties props = new Properties();    props.load(new StringReader(s));    return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);}
785b85f08dee7b212958218d2d7f8c76780c8081183577ec7554e802c0bab5d8
getQuorumVerifier
public QuorumVerifier getQuorumVerifier()
{    synchronized (QV_LOCK) {        return quorumVerifier;    }}
dc23c7082de41583ff1445c2403001c6ef13d70c4207119910edfda672516747
getLastSeenQuorumVerifier
public QuorumVerifier getLastSeenQuorumVerifier()
{    synchronized (QV_LOCK) {        return lastSeenQuorumVerifier;    }}
ca48f882a38187434926747691285a2008b22af2756685955abbe521217c3863
restartLeaderElection
public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW)
{    if (qvOLD == null || !qvOLD.equals(qvNEW)) {        LOG.warn("Restarting Leader Election");        getElectionAlg().shutdown();        shuttingDownLE = false;        startLeaderElection();    }}
d7554258689ffde4ab573449a264a3380ef79144422551c301d56a3985fe6823
getNextDynamicConfigFilename
public String getNextDynamicConfigFilename()
{    if (configFilename == null) {        LOG.warn("configFilename is null! This should only happen in tests.");        return null;    }    return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;}
a21d05c2df59360f3aaf032e816ff5f7ef378db64d1293aec837e48f67ce4a3a
connectNewPeers
private void connectNewPeers(QuorumCnxManager qcm)
{    if (quorumVerifier != null && lastSeenQuorumVerifier != null) {        Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();        for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {            if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {                qcm.connectOne(e.getKey());            }        }    }}
e43d08492b5ffa52c83444c7f60a0bd4215620bfea7df4debdbda1f49c49f81b
setLastSeenQuorumVerifier
public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk)
{                                QuorumCnxManager qcm = qcmRef.get();    Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;    synchronized (outerLockObject) {        synchronized (QV_LOCK) {            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {                LOG.error("setLastSeenQuorumVerifier called with stale config " + qv.getVersion() + ". Current version: " + quorumVerifier.getVersion());            }                        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {                return;            }            lastSeenQuorumVerifier = qv;            if (qcm != null) {                connectNewPeers(qcm);            }            if (writeToDisk) {                try {                    String fileName = getNextDynamicConfigFilename();                    if (fileName != null) {                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);                    }                } catch (IOException e) {                    LOG.error("Error writing next dynamic config file to disk: ", e.getMessage());                }            }        }    }}
63c890d750c43403fa96d4d4eac25ee474ad6b1588bfd9a5abb243e08a7ed790
setQuorumVerifier
public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk)
{    synchronized (QV_LOCK) {        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {                                    LOG.debug("{} setQuorumVerifier called with known or old config {}." + " Current version: {}", getId(), qv.getVersion(), quorumVerifier.getVersion());            return quorumVerifier;        }        QuorumVerifier prevQV = quorumVerifier;        quorumVerifier = qv;        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {            lastSeenQuorumVerifier = qv;        }        if (writeToDisk) {                        if (configFilename != null) {                try {                    String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);                    QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());                } catch (IOException e) {                    LOG.error("Error closing file: ", e.getMessage());                }            } else {                LOG.info("writeToDisk == true but configFilename == null");            }        }        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {            QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());        }        QuorumServer qs = qv.getAllMembers().get(getId());        if (qs != null) {            setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);        }        updateObserverMasterList();        return prevQV;    }}
0cf73382351f61479d6b1d601086ba2edb8b695dae457562ff97ac78a5f59966
makeDynamicConfigFilename
private String makeDynamicConfigFilename(long version)
{    return configFilename + ".dynamic." + Long.toHexString(version);}
15c59d2b330161e2c044f0b52c1079bc29738cfaae79e01a267a97a33c6d65b9
needEraseClientInfoFromStaticConfig
private boolean needEraseClientInfoFromStaticConfig()
{    QuorumServer server = quorumVerifier.getAllMembers().get(getId());    return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);}
4985d0f69ae53fd9ea58d1cfa6d5429dbc07131fd272a1b7e433ce3116d2e3f5
getElectionAlg
public Election getElectionAlg()
{    return electionAlg;}
2644301152fe601b1f7b76d52dc6e356d05bcfacf4d779994a44b0d12a07883f
getSyncLimit
public int getSyncLimit()
{    return syncLimit;}
ffade3a1568b507e1a257705f19722391b602b5b13effffbaebbb03ced7efe29
setSyncLimit
public void setSyncLimit(int syncLimit)
{    LOG.info("syncLimit set to " + syncLimit);    this.syncLimit = syncLimit;}
f36102ee6808fa70c7610d623493ac36424669959f4c7f0a9a5dcc1f6613f890
getConnectToLearnerMasterLimit
public int getConnectToLearnerMasterLimit()
{    return connectToLearnerMasterLimit;}
0da84b37798337d1e696a6fa82b1e78edfc1fe03bac8d8251d6c0c25f6a94c8b
setConnectToLearnerMasterLimit
public void setConnectToLearnerMasterLimit(int connectToLearnerMasterLimit)
{    LOG.info("connectToLearnerMasterLimit set to " + connectToLearnerMasterLimit);    this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;}
4be4b31b171ad0a3a29d43b6ccbe5c0f0470f64b922d027c6ae2edfa82857367
getSyncEnabled
public boolean getSyncEnabled()
{    if (System.getProperty(SYNC_ENABLED) != null) {        LOG.info(SYNC_ENABLED + "=" + Boolean.getBoolean(SYNC_ENABLED));        return Boolean.getBoolean(SYNC_ENABLED);    } else {        return syncEnabled;    }}
17da2946742f37b74021353073935fef97ec14fe0356585cb0e140eb61b377ec
setSyncEnabled
public void setSyncEnabled(boolean syncEnabled)
{    this.syncEnabled = syncEnabled;}
17988e743985334f563e269fa11881f30201b043978d440804c47e8ce9568594
getElectionType
public int getElectionType()
{    return electionType;}
2df9760b16595f9e6ac0175002b998eabe29b0a47f18bea7bd1510a0c116551e
setElectionType
public void setElectionType(int electionType)
{    this.electionType = electionType;}
91b4381d6848904501a083d9207594f662d43672a35b808b89e03bb6c0334807
getQuorumListenOnAllIPs
public boolean getQuorumListenOnAllIPs()
{    return quorumListenOnAllIPs;}
e7919c6ae9b89c7b4f8cb993027f49840202c2ca7280fc1d49fce65bf3ed9810
setQuorumListenOnAllIPs
public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs)
{    this.quorumListenOnAllIPs = quorumListenOnAllIPs;}
d8295311683a0fcb081194ec8352ca0a0f8e04bdf1c202106e0653e960c326ef
setCnxnFactory
public void setCnxnFactory(ServerCnxnFactory cnxnFactory)
{    this.cnxnFactory = cnxnFactory;}
221ca00ad98e7bbc391cb11568864b683d0121c7b3480793298c33cf42a13436
setSecureCnxnFactory
public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory)
{    this.secureCnxnFactory = secureCnxnFactory;}
afa4fbcc83e5ac074ebbd84bf1d4b92437e9c35d06217cfe7d9ea3821610d9bb
setSslQuorum
public void setSslQuorum(boolean sslQuorum)
{    if (sslQuorum) {        LOG.info("Using TLS encrypted quorum communication");    } else {        LOG.info("Using insecure (non-TLS) quorum communication");    }    this.sslQuorum = sslQuorum;}
28926ea7b20f0535ac3e3abae9011c968f55a8df86cfe0b122d9f8d38e6648d1
setUsePortUnification
public void setUsePortUnification(boolean shouldUsePortUnification)
{    LOG.info("Port unification {}", shouldUsePortUnification ? "enabled" : "disabled");    this.shouldUsePortUnification = shouldUsePortUnification;}
2a3e03232d3f0ecf383624b51e442d857a92f8b496223a8886cf4f7036088a8b
startServerCnxnFactory
private void startServerCnxnFactory()
{    if (cnxnFactory != null) {        cnxnFactory.start();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.start();    }}
a9154cd3644284478655def4e462bc70b74f9126ed6d6da90cdd190ba8d580d0
shutdownServerCnxnFactory
private void shutdownServerCnxnFactory()
{    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }}
47fabfd42e3ae6437cbf597bd6aea745fd98f405347a97ff421d05b96b1132a9
setZooKeeperServer
public void setZooKeeperServer(ZooKeeperServer zks)
{    if (cnxnFactory != null) {        cnxnFactory.setZooKeeperServer(zks);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.setZooKeeperServer(zks);    }}
0dd73f8d43c4941bbddfdf23df83be967409a3aef66cb2567675e4615f40e772
closeAllConnections
public void closeAllConnections()
{    if (cnxnFactory != null) {        cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }}
d2c843315f9f9d41844653347865765b26cd16135f4af42c425b6d8b969322b1
getClientPort
public int getClientPort()
{    if (cnxnFactory != null) {        return cnxnFactory.getLocalPort();    }    return -1;}
d2542c3a0a7be1c9307ff6e97e74209b2400887499ba99541e17146847143c8d
setTxnFactory
public void setTxnFactory(FileTxnSnapLog factory)
{    this.logFactory = factory;}
aa32d00dc6c23338946d990d25aa0128cdc836a145b592724bfa5f4afae53508
getTxnFactory
public FileTxnSnapLog getTxnFactory()
{    return this.logFactory;}
8c22206dd430d77e6a82ac25e03d18439a5c76c922f706b7cae422dfdf36b700
setZKDatabase
public void setZKDatabase(ZKDatabase database)
{    this.zkDb = database;}
852a202222a758523ab9d25284144d2021a0c96871372fe1dc45b7d8a6d5fc75
getZkDb
protected ZKDatabase getZkDb()
{    return zkDb;}
a1928c4918b499a3c8b2723821cf3f238a0db24d5f695673ae6b90b07cbb6890
initConfigInZKDatabase
public synchronized void initConfigInZKDatabase()
{    if (zkDb != null) {        zkDb.initConfigInZKDatabase(getQuorumVerifier());    }}
1cd1b470351cc164620985e84951745a66160c6782dec39e46562afc0eaa2246
isRunning
public boolean isRunning()
{    return running;}
45e056d251bb6caf0ed18f7a9e0883f69d7133ef5cbef7e8637ba5698050426c
getQuorumCnxManager
public QuorumCnxManager getQuorumCnxManager()
{    return qcmRef.get();}
6c9ff5f18639f8560a87d38e3876efdb854c8e914110f96b3b2c8086445056df
readLongFromFile
private long readLongFromFile(String name) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    BufferedReader br = new BufferedReader(new FileReader(file));    String line = "";    try {        line = br.readLine();        return Long.parseLong(line);    } catch (NumberFormatException e) {        throw new IOException("Found " + line + " in " + file);    } finally {        br.close();    }}
ab504e6345d323e16b6039f41b0ec522cfa9c73837838118443ee72a121247f4
writeLongToFile
private void writeLongToFile(String name, final long value) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    new AtomicFileWritingIdiom(file, new WriterStatement() {        @Override        public void write(Writer bw) throws IOException {            bw.write(Long.toString(value));        }    });}
a29863a6649c252d9bbe944b84d87af627f548ecf6a6c89806c00d7c06af80be
write
public void write(Writer bw) throws IOException
{    bw.write(Long.toString(value));}
f3ef97a39cc44ac9886db93ed7e6f16f06a53d2b9a9341cfafb57b50849a200c
getCurrentEpoch
public long getCurrentEpoch() throws IOException
{    if (currentEpoch == -1) {        currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);    }    return currentEpoch;}
5cf18bcf122c9cd62112abd8fabf2ee14fb40071843b4d7834f3143a182cf679
getAcceptedEpoch
public long getAcceptedEpoch() throws IOException
{    if (acceptedEpoch == -1) {        acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);    }    return acceptedEpoch;}
b11df89c105e9ad194bd3df9692bc225cbccc3715450c970d5e1652de6e083ff
setCurrentEpoch
public void setCurrentEpoch(long e) throws IOException
{    currentEpoch = e;    writeLongToFile(CURRENT_EPOCH_FILENAME, e);}
494caecdae57ca4e9e4bbedabbeaaed1590c4bfd6dc3e9a96047bb4638e175ee
setAcceptedEpoch
public void setAcceptedEpoch(long e) throws IOException
{    acceptedEpoch = e;    writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);}
7626f83cf8874e635ad3ea83018552886dcace34821d5a4c368099d4a8683b59
processReconfig
public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE)
{    if (!QuorumPeerConfig.isReconfigEnabled()) {        LOG.debug("Reconfig feature is disabled, skip reconfig processing.");        return false;    }    InetSocketAddress oldClientAddr = getClientAddress();            QuorumVerifier prevQV = setQuorumVerifier(qv, true);                                    initConfigInZKDatabase();    if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {        Map<Long, QuorumServer> newMembers = qv.getAllMembers();        updateRemotePeerMXBeans(newMembers);        if (restartLE) {            restartLeaderElection(prevQV, qv);        }        QuorumServer myNewQS = newMembers.get(getId());        if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {            cnxnFactory.reconfigure(myNewQS.clientAddr);            updateThreadName();        }        boolean roleChange = updateLearnerType(qv);        boolean leaderChange = false;        if (suggestedLeaderId != null) {                        leaderChange = updateVote(suggestedLeaderId, zxid);        } else {            long currentLeaderId = getCurrentVote().getId();            QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);            QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);            leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));                                    reconfigFlagClear();        }        return roleChange || leaderChange;    }    return false;}
8b7a897ba7076c274dfbc6de9ef05f3fd6b72eea2343590277f028a5933ffa09
updateRemotePeerMXBeans
private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers)
{    Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());    existingMembers.retainAll(jmxRemotePeerBean.keySet());    for (Long id : existingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.get(id);        rBean.setQuorumServer(newMembers.get(id));    }    Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());    joiningMembers.removeAll(jmxRemotePeerBean.keySet());        joiningMembers.remove(getId());    for (Long id : joiningMembers) {        QuorumServer qs = newMembers.get(id);        RemotePeerBean rBean = new RemotePeerBean(this, qs);        try {            MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);            jmxRemotePeerBean.put(qs.id, rBean);        } catch (Exception e) {            LOG.warn("Failed to register with JMX", e);        }    }    Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());    leavingMembers.removeAll(newMembers.keySet());    for (Long id : leavingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.remove(id);        try {            MBeanRegistry.getInstance().unregister(rBean);        } catch (Exception e) {            LOG.warn("Failed to unregister with JMX", e);        }    }}
4919a228e5bb9994a3ebdc6cae02ef8c560dac176d59c04dff6d2038b959b651
updateObserverMasterList
private void updateObserverMasterList()
{    if (observerMasterPort <= 0) {                return;    }    observerMasters.clear();    StringBuilder sb = new StringBuilder();    for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {        InetSocketAddress addr = new InetSocketAddress(server.addr.getAddress(), observerMasterPort);        observerMasters.add(new QuorumServer(server.id, addr));        sb.append(addr).append(",");    }    LOG.info("Updated learner master list to be {}", sb.toString());    Collections.shuffle(observerMasters);            nextObserverMaster = 0;}
87d67f4e9a6cdf9cc9623353d678f17b410eb528be4a97dd0bfd862a2f83e503
useObserverMasters
private boolean useObserverMasters()
{    return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;}
8bc397639ae90af8d6a63c4f25440db342b9ade75b3a00bcd04ffbf63e3cf416
nextObserverMaster
private QuorumServer nextObserverMaster()
{    if (nextObserverMaster >= observerMasters.size()) {        nextObserverMaster = 0;                if (isRunning()) {            Observer.waitForReconnectDelay();        }    }    return observerMasters.get(nextObserverMaster++);}
6468a96835d589e426090a648a334a34a93db74a6c8d27744d48ec7481e030a4
findLearnerMaster
 QuorumServer findLearnerMaster(QuorumServer leader)
{    if (useObserverMasters()) {        return nextObserverMaster();    } else {                if (isRunning()) {            Observer.waitForReconnectDelay();        }        return leader;    }}
b626e3a8004ba2cad9d414e44ade02c293a096266968465db4bfd0b8f98e017f
validateLearnerMaster
 QuorumServer validateLearnerMaster(String desiredMaster)
{    if (useObserverMasters()) {        Long sid;        try {            sid = Long.parseLong(desiredMaster);        } catch (NumberFormatException e) {            sid = null;        }        for (QuorumServer server : observerMasters) {            if (sid == null) {                String serverAddr = server.addr.getAddress().getHostAddress() + ':' + server.addr.getPort();                if (serverAddr.startsWith(desiredMaster)) {                    return server;                }            } else {                if (sid.equals(server.id)) {                    return server;                }            }        }        if (sid == null) {            LOG.info("could not find learner master address={}", desiredMaster);        } else {            LOG.warn("could not find learner master sid={}", sid);        }    } else {        LOG.info("cannot validate request, observer masters not enabled");    }    return null;}
b696cba0f51c46eba5ed4f34addd92794928ffb50966e1bd30239e6cfec3e229
updateLearnerType
private boolean updateLearnerType(QuorumVerifier newQV)
{        if (newQV.getObservingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.OBSERVER) {            setLearnerType(LearnerType.OBSERVER);            LOG.info("Becoming an observer");            reconfigFlagSet();            return true;        } else {            return false;        }    } else if (newQV.getVotingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.PARTICIPANT) {            setLearnerType(LearnerType.PARTICIPANT);            LOG.info("Becoming a voting participant");            reconfigFlagSet();            return true;        } else {            return false;        }    }        if (getLearnerType() != LearnerType.PARTICIPANT) {        setLearnerType(LearnerType.PARTICIPANT);        LOG.info("Becoming a non-voting participant");        reconfigFlagSet();        return true;    }    return false;}
9d1e7e06d6f49c69c3be6945273bdfd424c92dfff5c0fec8aad9c860ed3a3f59
updateVote
private boolean updateVote(long designatedLeader, long zxid)
{    Vote currentVote = getCurrentVote();    if (currentVote != null && designatedLeader != currentVote.getId()) {        setCurrentVote(new Vote(designatedLeader, zxid));        reconfigFlagSet();        LOG.warn("Suggested leader: " + designatedLeader);        return true;    }    return false;}
7954fa057f3af9048580910652cfe4b638fa749ba9a799656daa808d4836b5e4
updateElectionVote
protected void updateElectionVote(long newEpoch)
{    Vote currentVote = getCurrentVote();    if (currentVote != null) {        setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote.getState()));    }}
ab54156e5ed361e03ce55ba88b8b9d6615fe80d94d592f18c5211b5051899051
updateThreadName
private void updateThreadName()
{    String plain = cnxnFactory != null ? cnxnFactory.getLocalAddress() != null ? formatInetAddr(cnxnFactory.getLocalAddress()) : "disabled" : "disabled";    String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : "disabled";    setName(String.format("QuorumPeer[myid=%d](plain=%s)(secure=%s)", getId(), plain, secure));}
f15316b5951cc469ef7145539f213e89d05d9b242c1985c26168510a62003010
setElectionTimeTaken
 void setElectionTimeTaken(long electionTimeTaken)
{    this.electionTimeTaken = electionTimeTaken;}
77c414d7c4314f3c72acd5b9447e68c03833627901ca33dab752cc8e8ceceab9
getElectionTimeTaken
 long getElectionTimeTaken()
{    return electionTimeTaken;}
4d8d954c7c7ae8c38b34f3e804b23d73ad36a9aea2603585f114b70b4f557fba
setQuorumServerSaslRequired
 void setQuorumServerSaslRequired(boolean serverSaslRequired)
{    quorumServerSaslAuthRequired = serverSaslRequired;    LOG.info("{} set to {}", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);}
2f99857ae2777c4ac9ca52cf462bcdc57b78acb573a8d96730438c63d285fbf9
setQuorumLearnerSaslRequired
 void setQuorumLearnerSaslRequired(boolean learnerSaslRequired)
{    quorumLearnerSaslAuthRequired = learnerSaslRequired;    LOG.info("{} set to {}", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);}
a32286c3425e77d1040ffa5df75ec9b63825b01229bf84c39b7af5be2acc824f
setQuorumSaslEnabled
 void setQuorumSaslEnabled(boolean enableAuth)
{    quorumSaslEnableAuth = enableAuth;    if (!quorumSaslEnableAuth) {        LOG.info("QuorumPeer communication is not secured! (SASL auth disabled)");    } else {        LOG.info("{} set to {}", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);    }}
a7bbb6eade11bae1de6d5fbaa0489c0091ac06f717486faae100fe2f7e247de8
setQuorumServicePrincipal
 void setQuorumServicePrincipal(String servicePrincipal)
{    quorumServicePrincipal = servicePrincipal;    LOG.info("{} set to {}", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);}
a8f1fb85cc874f44688e56bf4c05a8508e1a5eb96d88e7a71eb10cd3a02f4836
setQuorumLearnerLoginContext
 void setQuorumLearnerLoginContext(String learnerContext)
{    quorumLearnerLoginContext = learnerContext;    LOG.info("{} set to {}", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);}
31b8a0246a0a1fe2e76ace62ecfae713a097dd7167f630f67320b75ac8781652
setQuorumServerLoginContext
 void setQuorumServerLoginContext(String serverContext)
{    quorumServerLoginContext = serverContext;    LOG.info("{} set to {}", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);}
cf6d9db467fc12fe0a85e35126d1ff766765064db4e0f462c32d812847ae0faa
setQuorumCnxnThreadsSize
 void setQuorumCnxnThreadsSize(int qCnxnThreadsSize)
{    if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {        quorumCnxnThreadsSize = qCnxnThreadsSize;    }    LOG.info("quorum.cnxn.threads.size set to {}", quorumCnxnThreadsSize);}
b7a6ce4642a531d1c37e299a556c3d5930da9e9886cf7376e2672f43a08209b5
isQuorumSaslAuthEnabled
 boolean isQuorumSaslAuthEnabled()
{    return quorumSaslEnableAuth;}
44e41f99862f56ab303ad3c477102a6e11fd1d153ce228f0900747906e239305
isQuorumServerSaslAuthRequired
private boolean isQuorumServerSaslAuthRequired()
{    return quorumServerSaslAuthRequired;}
5ad6d402274d407245c0a712cf4eebe1a97ae95dfcbce9670e52043084817597
isQuorumLearnerSaslAuthRequired
private boolean isQuorumLearnerSaslAuthRequired()
{    return quorumLearnerSaslAuthRequired;}
be403de686cb44821323132131b367fb722f18d1919051d87010fd065945af6c
createCnxnManager
public QuorumCnxManager createCnxnManager()
{    int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;    LOG.info("Using {}ms as the quorum cnxn socket timeout", timeout);    return new QuorumCnxManager(this, this.getId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());}
2f27393cae6019d9f4d8bdefcbf93df4c69f7e12da083acf26e4935d27f61bc6
isLeader
 boolean isLeader(long id)
{    Vote vote = getCurrentVote();    return vote != null && id == vote.getId();}
c4a4edb0a7525c7105eb834d6d270aec112d24d8b6eb9c1dff7fb98c8e101781
getSynced_observers_metric
public Integer getSynced_observers_metric()
{    if (leader != null) {        return leader.getObservingLearners().size();    } else if (follower != null) {        return follower.getSyncedObserverSize();    } else {        return null;    }}
d871f9e5eaf3c5a27e645f9aa8ab6ea190b83d8a54e3cc7b7e3a5d0f2f6886bf
parse
public void parse(String path) throws ConfigException
{    LOG.info("Reading configuration from: " + path);    try {        File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(path);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);            configFileStr = path;        } finally {            in.close();        }        /* Read entire config file as initial configuration */        initialConfig = new String(Files.readAllBytes(configFile.toPath()));        parseProperties(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + path, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + path, e);    }    if (dynamicConfigFileStr != null) {        try {            Properties dynamicCfg = new Properties();            FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);            try {                dynamicCfg.load(inConfig);                if (dynamicCfg.getProperty("version") != null) {                    throw new ConfigException("dynamic file shouldn't have version inside");                }                String version = getVersionFromFilename(dynamicConfigFileStr);                                if (version != null) {                    dynamicCfg.setProperty("version", version);                }            } finally {                inConfig.close();            }            setupQuorumPeerConfig(dynamicCfg, false);        } catch (IOException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        } catch (IllegalArgumentException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        }        File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);        if (nextDynamicConfigFile.exists()) {            try {                Properties dynamicConfigNextCfg = new Properties();                FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);                try {                    dynamicConfigNextCfg.load(inConfigNext);                } finally {                    inConfigNext.close();                }                boolean isHierarchical = false;                for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {                    String key = entry.getKey().toString().trim();                    if (key.startsWith("group") || key.startsWith("weight")) {                        isHierarchical = true;                        break;                    }                }                lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);            } catch (IOException e) {                LOG.warn("NextQuorumVerifier is initiated to null");            }        }    }}
52354f1188622ec76f6c48199f9de95dd8a93038bb353fba435789d4254c415f
getVersionFromFilename
public static String getVersionFromFilename(String filename)
{    int i = filename.lastIndexOf('.');    if (i < 0 || i >= filename.length()) {        return null;    }    String hexVersion = filename.substring(i + 1);    try {        long version = Long.parseLong(hexVersion, 16);        return Long.toHexString(version);    } catch (NumberFormatException e) {        return null;    }}
efacfc3132df0f25b71a355a3759e62ef815b1dd1a267495958726dd8973397e
parseProperties
public void parseProperties(Properties zkProp) throws IOException, ConfigException
{    int clientPort = 0;    int secureClientPort = 0;    int observerMasterPort = 0;    String clientPortAddress = null;    String secureClientPortAddress = null;    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();    for (Entry<Object, Object> entry : zkProp.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("dataDir")) {            dataDir = vff.create(value);        } else if (key.equals("dataLogDir")) {            dataLogDir = vff.create(value);        } else if (key.equals("clientPort")) {            clientPort = Integer.parseInt(value);        } else if (key.equals("localSessionsEnabled")) {            localSessionsEnabled = Boolean.parseBoolean(value);        } else if (key.equals("localSessionsUpgradingEnabled")) {            localSessionsUpgradingEnabled = Boolean.parseBoolean(value);        } else if (key.equals("clientPortAddress")) {            clientPortAddress = value.trim();        } else if (key.equals("secureClientPort")) {            secureClientPort = Integer.parseInt(value);        } else if (key.equals("secureClientPortAddress")) {            secureClientPortAddress = value.trim();        } else if (key.equals("observerMasterPort")) {            observerMasterPort = Integer.parseInt(value);        } else if (key.equals("clientPortListenBacklog")) {            clientPortListenBacklog = Integer.parseInt(value);        } else if (key.equals("tickTime")) {            tickTime = Integer.parseInt(value);        } else if (key.equals("maxClientCnxns")) {            maxClientCnxns = Integer.parseInt(value);        } else if (key.equals("minSessionTimeout")) {            minSessionTimeout = Integer.parseInt(value);        } else if (key.equals("maxSessionTimeout")) {            maxSessionTimeout = Integer.parseInt(value);        } else if (key.equals("initLimit")) {            initLimit = Integer.parseInt(value);        } else if (key.equals("syncLimit")) {            syncLimit = Integer.parseInt(value);        } else if (key.equals("connectToLearnerMasterLimit")) {            connectToLearnerMasterLimit = Integer.parseInt(value);        } else if (key.equals("electionAlg")) {            electionAlg = Integer.parseInt(value);            if (electionAlg != 1 && electionAlg != 2 && electionAlg != 3) {                throw new ConfigException("Invalid electionAlg value. Only 1, 2, 3 are supported.");            }        } else if (key.equals("quorumListenOnAllIPs")) {            quorumListenOnAllIPs = Boolean.parseBoolean(value);        } else if (key.equals("peerType")) {            if (value.toLowerCase().equals("observer")) {                peerType = LearnerType.OBSERVER;            } else if (value.toLowerCase().equals("participant")) {                peerType = LearnerType.PARTICIPANT;            } else {                throw new ConfigException("Unrecognised peertype: " + value);            }        } else if (key.equals("syncEnabled")) {            syncEnabled = Boolean.parseBoolean(value);        } else if (key.equals("dynamicConfigFile")) {            dynamicConfigFileStr = value;        } else if (key.equals("autopurge.snapRetainCount")) {            snapRetainCount = Integer.parseInt(value);        } else if (key.equals("autopurge.purgeInterval")) {            purgeInterval = Integer.parseInt(value);        } else if (key.equals("standaloneEnabled")) {            if (value.toLowerCase().equals("true")) {                setStandaloneEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setStandaloneEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for standalone mode. Choose 'true' or 'false.'");            }        } else if (key.equals("reconfigEnabled")) {            if (value.toLowerCase().equals("true")) {                setReconfigEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setReconfigEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for reconfigEnabled flag. Choose 'true' or 'false.'");            }        } else if (key.equals("sslQuorum")) {            sslQuorum = Boolean.parseBoolean(value);        } else if (key.equals("portUnification")) {            shouldUsePortUnification = Boolean.parseBoolean(value);        } else if (key.equals("sslQuorumReloadCertFiles")) {            sslQuorumReloadCertFiles = Boolean.parseBoolean(value);        } else if ((key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight")) && zkProp.containsKey("dynamicConfigFile")) {            throw new ConfigException("parameter: " + key + " must be in a separate dynamic config file");        } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {            quorumEnableSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {            quorumServerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {            quorumLearnerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {            quorumLearnerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {            quorumServerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {            quorumServicePrincipal = value;        } else if (key.equals("quorum.cnxn.threads.size")) {            quorumCnxnThreadsSize = Integer.parseInt(value);        } else if (key.equals(JvmPauseMonitor.INFO_THRESHOLD_KEY)) {            jvmPauseInfoThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.WARN_THRESHOLD_KEY)) {            jvmPauseWarnThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.SLEEP_TIME_MS_KEY)) {            jvmPauseSleepTimeMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY)) {            jvmPauseMonitorToRun = Boolean.parseBoolean(value);        } else if (key.equals("metricsProvider.className")) {            metricsProviderClassName = value;        } else if (key.startsWith("metricsProvider.")) {            String keyForMetricsProvider = key.substring(16);            metricsProviderConfiguration.put(keyForMetricsProvider, value);        } else {            System.setProperty("zookeeper." + key, value);        }    }    if (!quorumEnableSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }    if (!quorumEnableSasl && quorumLearnerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);    }        if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {        LOG.warn("Invalid autopurge.snapRetainCount: " + snapRetainCount + ". Defaulting to " + MIN_SNAP_RETAIN_COUNT);        snapRetainCount = MIN_SNAP_RETAIN_COUNT;    }    if (dataDir == null) {        throw new IllegalArgumentException("dataDir is not set");    }    if (dataLogDir == null) {        dataLogDir = dataDir;    }    if (clientPort == 0) {        LOG.info("clientPort is not set");        if (clientPortAddress != null) {            throw new IllegalArgumentException("clientPortAddress is set but clientPort is not set");        }    } else if (clientPortAddress != null) {        this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);        LOG.info("clientPortAddress is {}", formatInetAddr(this.clientPortAddress));    } else {        this.clientPortAddress = new InetSocketAddress(clientPort);        LOG.info("clientPortAddress is {}", formatInetAddr(this.clientPortAddress));    }    if (secureClientPort == 0) {        LOG.info("secureClientPort is not set");        if (secureClientPortAddress != null) {            throw new IllegalArgumentException("secureClientPortAddress is set but secureClientPort is not set");        }    } else if (secureClientPortAddress != null) {        this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);        LOG.info("secureClientPortAddress is {}", formatInetAddr(this.secureClientPortAddress));    } else {        this.secureClientPortAddress = new InetSocketAddress(secureClientPort);        LOG.info("secureClientPortAddress is {}", formatInetAddr(this.secureClientPortAddress));    }    if (this.secureClientPortAddress != null) {        configureSSLAuth();    }    if (observerMasterPort <= 0) {        LOG.info("observerMasterPort is not set");    } else {        this.observerMasterPort = observerMasterPort;        LOG.info("observerMasterPort is {}", observerMasterPort);    }    if (tickTime == 0) {        throw new IllegalArgumentException("tickTime is not set");    }    minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;    maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;    if (minSessionTimeout > maxSessionTimeout) {        throw new IllegalArgumentException("minSessionTimeout must not be larger than maxSessionTimeout");    }    LOG.info("metricsProvider.className is {}", metricsProviderClassName);    try {        Class.forName(metricsProviderClassName, false, Thread.currentThread().getContextClassLoader());    } catch (ClassNotFoundException error) {        throw new IllegalArgumentException("metrics provider class was not found", error);    }        if (dynamicConfigFileStr == null) {        setupQuorumPeerConfig(zkProp, true);        if (isDistributed() && isReconfigEnabled()) {                                    backupOldConfig();        }    }}
e6dff6e5aba9f508c6cbabace3090f304a47937b49d3730bfd20bfc2e0ba86bd
configureSSLAuth
public static void configureSSLAuth() throws ConfigException
{    try (ClientX509Util clientX509Util = new ClientX509Util()) {        String sslAuthProp = "zookeeper.authProvider." + System.getProperty(clientX509Util.getSslAuthProviderProperty(), "x509");        if (System.getProperty(sslAuthProp) == null) {            if ("zookeeper.authProvider.x509".equals(sslAuthProp)) {                System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");            } else {                throw new ConfigException("No auth provider configured for the SSL authentication scheme '" + System.getProperty(clientX509Util.getSslAuthProviderProperty()) + "'.");            }        }    }}
2c11ed89ea37a4432294fd0628d11677236c086207dd838704f4fbb858d0be38
backupOldConfig
private void backupOldConfig() throws IOException
{    new AtomicFileWritingIdiom(new File(configFileStr + ".bak"), new OutputStreamStatement() {        @Override        public void write(OutputStream output) throws IOException {            InputStream input = null;            try {                input = new FileInputStream(new File(configFileStr));                byte[] buf = new byte[1024];                int bytesRead;                while ((bytesRead = input.read(buf)) > 0) {                    output.write(buf, 0, bytesRead);                }            } finally {                if (input != null) {                    input.close();                }            }        }    });}
d4f41cb1085142ff7c0c5db0bdd7b867dd61441850f76028e20f5a91bf0445df
write
public void write(OutputStream output) throws IOException
{    InputStream input = null;    try {        input = new FileInputStream(new File(configFileStr));        byte[] buf = new byte[1024];        int bytesRead;        while ((bytesRead = input.read(buf)) > 0) {            output.write(buf, 0, bytesRead);        }    } finally {        if (input != null) {            input.close();        }    }}
c363c0ea795f78e8e6b10a77e06a490d36f30e6604647752dca58f06acc69228
writeDynamicConfig
public static void writeDynamicConfig(final String dynamicConfigFilename, final QuorumVerifier qv, final boolean needKeepVersion) throws IOException
{    new AtomicFileWritingIdiom(new File(dynamicConfigFilename), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            Properties cfg = new Properties();            cfg.load(new StringReader(qv.toString()));            List<String> servers = new ArrayList<String>();            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (!needKeepVersion && key.startsWith("version")) {                    continue;                }                String value = entry.getValue().toString().trim();                servers.add(key.concat("=").concat(value));            }            Collections.sort(servers);            out.write(StringUtils.joinStrings(servers, "\n"));        }    });}
bd0b710180ac20a572d941a1e3a3dcd4223b659c6b089e518b64db0ae6cd12af
write
public void write(Writer out) throws IOException
{    Properties cfg = new Properties();    cfg.load(new StringReader(qv.toString()));    List<String> servers = new ArrayList<String>();    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (!needKeepVersion && key.startsWith("version")) {            continue;        }        String value = entry.getValue().toString().trim();        servers.add(key.concat("=").concat(value));    }    Collections.sort(servers);    out.write(StringUtils.joinStrings(servers, "\n"));}
116b49806d4bd15b3e79173bfdfd9fff4fecaa178844ab0de9c94256fa605f93
editStaticConfig
public static void editStaticConfig(final String configFileStr, final String dynamicFileStr, final boolean eraseClientPortAddress) throws IOException
{        if (configFileStr == null) {        return;    }    File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(configFileStr);    final File dynamicFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(dynamicFileStr);    final Properties cfg = new Properties();    FileInputStream in = new FileInputStream(configFile);    try {        cfg.load(in);    } finally {        in.close();    }    new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                                        continue;                }                String value = entry.getValue().toString().trim();                out.write(key.concat("=").concat(value).concat("\n"));            }                        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());            out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));        }    });}
bd0b710180ac20a572d941a1e3a3dcd4223b659c6b089e518b64db0ae6cd12af
write
public void write(Writer out) throws IOException
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                        continue;        }        String value = entry.getValue().toString().trim();        out.write(key.concat("=").concat(value).concat("\n"));    }        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());    out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));}
d3d5fc932b09675d82cb198dcb7bb98bda94e08076d52072583bbd9659ab8c44
deleteFile
public static void deleteFile(String filename)
{    if (filename == null) {        return;    }    File f = new File(filename);    if (f.exists()) {        try {            f.delete();        } catch (Exception e) {            LOG.warn("deleting " + filename + " failed");        }    }}
781a88cf54e7bcafefdf59f91a812e7e76296e772ed5a50f5ffc81bdf0110984
createQuorumVerifier
private static QuorumVerifier createQuorumVerifier(Properties dynamicConfigProp, boolean isHierarchical) throws ConfigException
{    if (isHierarchical) {        return new QuorumHierarchical(dynamicConfigProp);    } else {                return new QuorumMaj(dynamicConfigProp);    }}
7fc7e94204882bfb9c6a0dc25b3184484a56db2426acae0f5a89c69f9ff49732
setupQuorumPeerConfig
 void setupQuorumPeerConfig(Properties prop, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);    setupMyId();    setupClientPort();    setupPeerType();    checkValidity();}
86b96de34e49de4ca59fa3eaa14db36254f1607faa77b7106fab1e66c59b9973
parseDynamicConfig
public static QuorumVerifier parseDynamicConfig(Properties dynamicConfigProp, int eAlg, boolean warnings, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    boolean isHierarchical = false;    for (Entry<Object, Object> entry : dynamicConfigProp.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("group") || key.startsWith("weight")) {            isHierarchical = true;        } else if (!configBackwardCompatibilityMode && !key.startsWith("server.") && !key.equals("version")) {            LOG.info(dynamicConfigProp.toString());            throw new ConfigException("Unrecognised parameter: " + key);        }    }    QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical);    int numParticipators = qv.getVotingMembers().size();    int numObservers = qv.getObservingMembers().size();    if (numParticipators == 0) {        if (!standaloneEnabled) {            throw new IllegalArgumentException("standaloneEnabled = false then " + "number of participants should be >0");        }        if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o participants is an invalid configuration");        }    } else if (numParticipators == 1 && standaloneEnabled) {                                        LOG.error("Invalid configuration, only one server specified (ignoring)");        if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o quorum is an invalid configuration");        }    } else {        if (warnings) {            if (numParticipators <= 2) {                LOG.warn("No server failure will be tolerated. " + "You need at least 3 servers.");            } else if (numParticipators % 2 == 0) {                LOG.warn("Non-optimial configuration, consider an odd number of servers.");            }        }        for (QuorumServer s : qv.getVotingMembers().values()) {            if (s.electionAddr == null) {                throw new IllegalArgumentException("Missing election port for server: " + s.id);            }        }    }    return qv;}
1ca2798f3915a20fa8d75345c1451ef0765f062fb9fa437d3fcf2e9ff6d9a5de
setupMyId
private void setupMyId() throws IOException
{    File myIdFile = new File(dataDir, "myid");        if (!myIdFile.isFile()) {        return;    }    BufferedReader br = new BufferedReader(new FileReader(myIdFile));    String myIdString;    try {        myIdString = br.readLine();    } finally {        br.close();    }    try {        serverId = Long.parseLong(myIdString);        MDC.put("myid", myIdString);    } catch (NumberFormatException e) {        throw new IllegalArgumentException("serverid " + myIdString + " is not a number");    }}
e9a95c77ad899e02d5d758826be7a09230ea9a061f9fb575ea35599a0fa118f0
setupClientPort
private void setupClientPort() throws ConfigException
{    if (serverId == UNSET_SERVERID) {        return;    }    QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);    if (clientPortAddress != null && qs != null && qs.clientAddr != null) {        if ((!clientPortAddress.getAddress().isAnyLocalAddress() && !clientPortAddress.equals(qs.clientAddr)) || (clientPortAddress.getAddress().isAnyLocalAddress() && clientPortAddress.getPort() != qs.clientAddr.getPort())) {            throw new ConfigException("client address for this server (id = " + serverId + ") in static config file is " + clientPortAddress + " is different from client address found in dynamic file: " + qs.clientAddr);        }    }    if (qs != null && qs.clientAddr != null) {        clientPortAddress = qs.clientAddr;    }    if (qs != null && qs.clientAddr == null) {        qs.clientAddr = clientPortAddress;        qs.isClientAddrFromStatic = true;    }}
d330448e798d25fb85af7683b09c844b90f51fda910d1aa470d93c2d6342d3b1
setupPeerType
private void setupPeerType()
{        LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER : LearnerType.PARTICIPANT;    if (roleByServersList != peerType) {        LOG.warn("Peer type from servers list (" + roleByServersList + ") doesn't match peerType (" + peerType + "). Defaulting to servers list.");        peerType = roleByServersList;    }}
8bd7deb72977b3af5f80c2920909ea614f9896c654587ea471e32b4754a455e7
checkValidity
public void checkValidity() throws IOException, ConfigException
{    if (isDistributed()) {        if (initLimit == 0) {            throw new IllegalArgumentException("initLimit is not set");        }        if (syncLimit == 0) {            throw new IllegalArgumentException("syncLimit is not set");        }        if (serverId == UNSET_SERVERID) {            throw new IllegalArgumentException("myid file is missing");        }    }}
3e89e35e73b5019caeb3463b6d2aba6ad29be8bb78a5a30f23942b0f2012f47a
getClientPortAddress
public InetSocketAddress getClientPortAddress()
{    return clientPortAddress;}
db6c3e811fb6600184102e53dce5a387450abd2972e323d4aa2603f5b0de6943
getSecureClientPortAddress
public InetSocketAddress getSecureClientPortAddress()
{    return secureClientPortAddress;}
22acfff0375c43781616e1e5fbad958defdb85eb68bf618040bb5f3cb9644e8d
getObserverMasterPort
public int getObserverMasterPort()
{    return observerMasterPort;}
260452c67ee229efb360439b03779c159761f631bb6945711988d544e37e5140
getDataDir
public File getDataDir()
{    return dataDir;}
2742bb58bdbfe1b66b2740996b6a766693e7057cb8802d4843c4e85eb1d5f32a
getDataLogDir
public File getDataLogDir()
{    return dataLogDir;}
325790059f5a28565470268695098e1c1c93b49e375e1585af6007fbd67a53b5
getInitialConfig
public String getInitialConfig()
{    return initialConfig;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
e1bdc6adf813fb8e32ea311d72e069682199fd33de94a8a2e7ac4918c58a4ffc
getMaxClientCnxns
public int getMaxClientCnxns()
{    return maxClientCnxns;}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return minSessionTimeout;}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
78645ceb9553427481798fe5b5b5d3a3b940a4834c282352e6b2d087d02c3939
getMetricsProviderClassName
public String getMetricsProviderClassName()
{    return metricsProviderClassName;}
966b66646d5c92e9f08fc81a691835a66271312657c3a36a6672404a19a1a6ba
getMetricsProviderConfiguration
public Properties getMetricsProviderConfiguration()
{    return metricsProviderConfiguration;}
e0f64db7c5bc5c260b2fd1005366491fbf1e65f7c0c4412f4f3e3c17da260e69
areLocalSessionsEnabled
public boolean areLocalSessionsEnabled()
{    return localSessionsEnabled;}
9b5f9e97c3ccdb2959cac0e38fd1db22d0f45901c30be48d6e1fa1ff8b693fbd
isLocalSessionsUpgradingEnabled
public boolean isLocalSessionsUpgradingEnabled()
{    return localSessionsUpgradingEnabled;}
1f24414b90ab196cc53c9ade945cde75dd11aaf59d844c377e139d98115b69c8
isSslQuorum
public boolean isSslQuorum()
{    return sslQuorum;}
17147c8d7a539a4c13f2d32180e066d1caf3a4c7fc017d3200a625a4d797fcdd
shouldUsePortUnification
public boolean shouldUsePortUnification()
{    return shouldUsePortUnification;}
ec5585a4b2b943741ce33cf2955fc89a6570f314127c8e967a69575e8e422e3e
getClientPortListenBacklog
public int getClientPortListenBacklog()
{    return clientPortListenBacklog;}
388547177a6cafeb8c7b497ec5fafed00cdc5eeb526612bd565c9966f951d5ac
getInitLimit
public int getInitLimit()
{    return initLimit;}
2644301152fe601b1f7b76d52dc6e356d05bcfacf4d779994a44b0d12a07883f
getSyncLimit
public int getSyncLimit()
{    return syncLimit;}
f36102ee6808fa70c7610d623493ac36424669959f4c7f0a9a5dcc1f6613f890
getConnectToLearnerMasterLimit
public int getConnectToLearnerMasterLimit()
{    return connectToLearnerMasterLimit;}
ec4f33302e78ae71627d2251f137ab900498e02e8816e6ed31db90e4e9ee4a9f
getElectionAlg
public int getElectionAlg()
{    return electionAlg;}
3624ce633146fb20859deefb93010183e99b5d513b6b0c2303dbc367c9ca4ff1
getElectionPort
public int getElectionPort()
{    return electionPort;}
dd2ac4033cadb287f37314e34697689c69dc23c8f7e9ed8bd41f8aefe205f527
getSnapRetainCount
public int getSnapRetainCount()
{    return snapRetainCount;}
6fa960549b44ead4739655dd705b8285b1287b6cc7b7f499ba1e43febb18e709
getPurgeInterval
public int getPurgeInterval()
{    return purgeInterval;}
4be4b31b171ad0a3a29d43b6ccbe5c0f0470f64b922d027c6ae2edfa82857367
getSyncEnabled
public boolean getSyncEnabled()
{    return syncEnabled;}
785b85f08dee7b212958218d2d7f8c76780c8081183577ec7554e802c0bab5d8
getQuorumVerifier
public QuorumVerifier getQuorumVerifier()
{    return quorumVerifier;}
dc23c7082de41583ff1445c2403001c6ef13d70c4207119910edfda672516747
getLastSeenQuorumVerifier
public QuorumVerifier getLastSeenQuorumVerifier()
{    return lastSeenQuorumVerifier;}
77cf345149dc278c673794da3ead22172dab6dfa4e8a0d27324ffd0ea41637a8
getServers
public Map<Long, QuorumServer> getServers()
{        return Collections.unmodifiableMap(quorumVerifier.getAllMembers());}
cf3b67d26a57e8c59e67188a67ca79f74a07ab45c0b1c529d5270384283f8a1d
getJvmPauseInfoThresholdMs
public long getJvmPauseInfoThresholdMs()
{    return jvmPauseInfoThresholdMs;}
eb92c8dfcd46287551baec3b86da941516c5fd82ed53aced6f8f216c66c33e01
getJvmPauseWarnThresholdMs
public long getJvmPauseWarnThresholdMs()
{    return jvmPauseWarnThresholdMs;}
a0afdea06220ce3dfe60b9d58e941246a4af86d48e5c41c73b36f8a5a7aaa9c3
getJvmPauseSleepTimeMs
public long getJvmPauseSleepTimeMs()
{    return jvmPauseSleepTimeMs;}
effd036aed2c64c4c04857d80791bfc965ae4a392af4b58f56f0a0f6247e14aa
isJvmPauseMonitorToRun
public boolean isJvmPauseMonitorToRun()
{    return jvmPauseMonitorToRun;}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return serverId;}
dbec1072c4f8b1d4611450e3d17fa537febe01742bba04d42703ad4d314b0a01
isDistributed
public boolean isDistributed()
{    return quorumVerifier != null && (!standaloneEnabled || quorumVerifier.getVotingMembers().size() > 1);}
2865fcf7f02e6f18f1a4a5c7753775dfa54a6c6d11df9b9fdecbf6b36ac4faf7
getPeerType
public LearnerType getPeerType()
{    return peerType;}
a4fe8b6ac421a38aba9a768166f9fa1ea7a73a34da544e8bafb4aaa9c24e8a1c
getConfigFilename
public String getConfigFilename()
{    return configFileStr;}
7548709481c5c433c5e258908371a54510e760289745c6b6450673d17f9a6826
getQuorumListenOnAllIPs
public Boolean getQuorumListenOnAllIPs()
{    return quorumListenOnAllIPs;}
714942d2fe8da8be254f1943befc44f9db1e166c2b02b1f6702032a3dd876112
isStandaloneEnabled
public static boolean isStandaloneEnabled()
{    return standaloneEnabled;}
cb6a43a4ac592af60086b93ee63d04aba015718c2317492d3abca82fa886a4bc
setStandaloneEnabled
public static void setStandaloneEnabled(boolean enabled)
{    standaloneEnabled = enabled;}
3fc3a76665797e64f837203a1be7f83305a3fd06f4a02d02e70bc921e56cf31a
isReconfigEnabled
public static boolean isReconfigEnabled()
{    return reconfigEnabled;}
5d8c587f9575980924456859a87b3035c9ddbaadd5a788b6075cdf7c02553268
setReconfigEnabled
public static void setReconfigEnabled(boolean enabled)
{    reconfigEnabled = enabled;}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    QuorumPeerMain main = new QuorumPeerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {        LOG.error("Invalid arguments, exiting abnormally", e);        LOG.info(USAGE);        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {        LOG.error("Invalid config, exiting abnormally", e);        System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {        LOG.error("Unable to access datadir, exiting abnormally", e);        System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {        LOG.error("Unable to start AdminServer, exiting abnormally", e);        System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {        LOG.error("Unexpected exception, exiting abnormally", e);        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    LOG.info("Exiting normally");    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
6d39fb3cad6019ff86a2d18a5659592a40234f6f04afecb6902f3b0683b24103
initializeAndRun
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException
{    QuorumPeerConfig config = new QuorumPeerConfig();    if (args.length == 1) {        config.parse(args[0]);    }        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());    purgeMgr.start();    if (args.length == 1 && config.isDistributed()) {        runFromConfig(config);    } else {        LOG.warn("Either no config or no quorum defined in config, running " + " in standalone mode");                ZooKeeperServerMain.main(args);    }}
ba8f4a39ffacc86b5c20f0e8e0cc7fa78750a31035f05b9df13090ba10057be0
runFromConfig
public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {        LOG.warn("Unable to register log4j JMX control", e);    }    LOG.info("Starting quorum peer");    MetricsProvider metricsProvider;    try {        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());    } catch (MetricsProviderLifeCycleException error) {        throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);    }    try {        ServerMetrics.metricsProviderInitialized(metricsProvider);        ServerCnxnFactory cnxnFactory = null;        ServerCnxnFactory secureCnxnFactory = null;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);        }        quorumPeer = getQuorumPeer();        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());                quorumPeer.setElectionType(config.getElectionAlg());        quorumPeer.setMyid(config.getServerId());        quorumPeer.setTickTime(config.getTickTime());        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());        quorumPeer.setInitLimit(config.getInitLimit());        quorumPeer.setSyncLimit(config.getSyncLimit());        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());        quorumPeer.setConfigFileName(config.getConfigFilename());        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);        if (config.getLastSeenQuorumVerifier() != null) {            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);        }        quorumPeer.initConfigInZKDatabase();        quorumPeer.setCnxnFactory(cnxnFactory);        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);        quorumPeer.setSslQuorum(config.isSslQuorum());        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());        quorumPeer.setLearnerType(config.getPeerType());        quorumPeer.setSyncEnabled(config.getSyncEnabled());        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());        if (config.sslQuorumReloadCertFiles) {            quorumPeer.getX509Util().enableCertFileReloading();        }                quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);        if (quorumPeer.isQuorumSaslAuthEnabled()) {            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);        }        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);        quorumPeer.initialize();        if (config.jvmPauseMonitorToRun) {            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));        }        quorumPeer.start();        quorumPeer.join();    } catch (InterruptedException e) {                LOG.warn("Quorum Peer interrupted", e);    } finally {        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                LOG.warn("Error while stopping metrics", error);            }        }    }}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer();}
37bd970c873b1caba1f416cd3451f9136748408cb1498857ffad8d8312e41b1f
getServerState
public String getServerState()
{    return provider.getServerState();}
9c37ac8657f610d850a2f6ee72ef31edfa9428d837eff4ecc6366af0d1bb7fba
getQuorumPeers
public String[] getQuorumPeers()
{    return provider.getQuorumPeers();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder(super.toString());    String state = getServerState();    if (state.equals(Provider.LEADING_STATE)) {        sb.append("Followers:");        for (String f : getQuorumPeers()) {            sb.append(" ").append(f);        }        sb.append("\n");    } else if (state.equals(Provider.FOLLOWING_STATE) || state.equals(Provider.OBSERVING_STATE)) {        sb.append("Leader: ");        String[] ldr = getQuorumPeers();        if (ldr.length > 0) {            sb.append(ldr[0]);        } else {            sb.append("not connected");        }        sb.append("\n");    }    return sb.toString();}
1596c867967c4f562c3e42c2ca0b63bf683c41e165b5e6ef1a63600c5b4ad69a
startSessionTracker
protected void startSessionTracker()
{    upgradeableSessionTracker = (UpgradeableSessionTracker) sessionTracker;    upgradeableSessionTracker.start();}
3db39f39930ccb372c757d1c9271c56edc63e3d99787de43607524563342320a
checkUpgradeSession
public Request checkUpgradeSession(Request request) throws IOException, KeeperException
{        if ((request.type != OpCode.create && request.type != OpCode.create2 && request.type != OpCode.multi) || !upgradeableSessionTracker.isLocalSession(request.sessionId)) {        return null;    }    if (OpCode.multi == request.type) {        MultiOperationRecord multiTransactionRecord = new MultiOperationRecord();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, multiTransactionRecord);        request.request.rewind();        boolean containsEphemeralCreate = false;        for (Op op : multiTransactionRecord) {            if (op.getType() == OpCode.create || op.getType() == OpCode.create2) {                CreateRequest createRequest = (CreateRequest) op.toRequestRecord();                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                if (createMode.isEphemeral()) {                    containsEphemeralCreate = true;                    break;                }            }        }        if (!containsEphemeralCreate) {            return null;        }    } else {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());        if (!createMode.isEphemeral()) {            return null;        }    }        if (!self.isLocalSessionsUpgradingEnabled()) {        throw new KeeperException.EphemeralOnLocalSessionException();    }    return makeUpgradeRequest(request.sessionId);}
8bec1dc5c0c8387f18b5520b71982d18a322699c9ddd8c755c75760c067d59e6
makeUpgradeRequest
private Request makeUpgradeRequest(long sessionId)
{        synchronized (upgradeableSessionTracker) {        if (upgradeableSessionTracker.isLocalSession(sessionId)) {            int timeout = upgradeableSessionTracker.upgradeSession(sessionId);            ByteBuffer to = ByteBuffer.allocate(4);            to.putInt(timeout);            return new Request(null, sessionId, 0, OpCode.createSession, to, null);        }    }    return null;}
dca92a0725f2cd249275d12f797acbfcd8a249d983ee930ddab88955b14310f3
upgrade
public void upgrade(long sessionId)
{    Request request = makeUpgradeRequest(sessionId);    if (request != null) {        LOG.info("Upgrading session 0x" + Long.toHexString(sessionId));                submitRequest(request);    }}
82e806c9fbe3cb5b84bfaf8af782f9f56b98656d0c5d14022445c91b3362113b
setLocalSessionFlag
protected void setLocalSessionFlag(Request si)
{        switch(si.type) {        case OpCode.createSession:            if (self.areLocalSessionsEnabled()) {                                si.setLocalSession(true);            }            break;        case OpCode.closeSession:            String reqType = "global";            if (upgradeableSessionTracker.isLocalSession(si.sessionId)) {                si.setLocalSession(true);                reqType = "local";            }            LOG.info("Submitting " + reqType + " closeSession request" + " for session 0x" + Long.toHexString(si.sessionId));            break;        default:            break;    }}
9676c751cfd23b3e9a635c6c412564753bb76ee853dc2dbfd043b7f361b97b38
dumpConf
public void dumpConf(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());    pwriter.println("membership: ");    pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));}
c1fb0acefc598c56ec326dc3b4778c056ac59608c9aca70ed1d136ac1a0cc817
setState
protected void setState(State state)
{    this.state = state;}
79285532c7fb8fc78a40e7457ab3382e4f205c333dc4a989a8d9deb0895c344b
registerMetrics
protected void registerMetrics()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("quorum_size", () -> {        return self.getQuorumSize();    });}
7a1592c7f6f4561e51579c42c380094baff7002d616a43b17459fdd0f834dec2
unregisterMetrics
protected void unregisterMetrics()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("quorum_size");}
97a068231300388a78bf304b913f979af3c1dd05574e3b94738f52ec65f5b8ff
dumpMonitorValues
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("peer_state", self.getDetailedPeerState());}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "ReadOnlyServer";}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!finished) {            Request request = queuedRequests.take();                        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'R', request, "");            }            if (Request.requestOfDeath == request) {                break;            }                        switch(request.type) {                case OpCode.sync:                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase().getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());                    try {                        request.cnxn.sendResponse(hdr, null, null);                    } catch (IOException e) {                        LOG.error("IO exception while sending response", e);                    }                    continue;            }                        if (nextProcessor != null) {                nextProcessor.processRequest(request);            }        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {            LOG.info(e.getCause().getMessage());        }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    LOG.info("ReadOnlyRequestProcessor exited loop!");}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    if (!finished) {        queuedRequests.add(request);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor prepProcessor = new PrepRequestProcessor(this, finalProcessor);    ((PrepRequestProcessor) prepProcessor).start();    firstProcessor = new ReadOnlyRequestProcessor(this, prepProcessor);    ((ReadOnlyRequestProcessor) firstProcessor).start();}
da36f3b9d36ac447eb82095d5bedab6921b56e31fcb45bf35d22208f35f9d226
startup
public synchronized void startup()
{        if (shutdown) {        LOG.warn("Not starting Read-only server as startup follows shutdown!");        return;    }    registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);    super.startup();    self.setZooKeeperServer(this);    self.adminServer.setZooKeeperServer(this);    LOG.info("Read-only server started");}
e6f3bb16f7c86279ca0b0f6bdfc4ca1bbf019bd9710ded3d2320084bbedcc6a2
registerJMX
protected void registerJMX()
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxDataTreeBean = null;    }}
f0319c6b00f4ade84897bf31fc3fb5d667c87c59587edd13b35f0483f60fe40d
registerJMX
public void registerJMX(ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxServerBean = null;    }}
85e7e25a941f134236cd570c8e63b18ce60539fbd1cc088cec570f9a426f4eb3
unregisterJMX
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxDataTreeBean = null;}
73dcb98800c12a13eb9fd2459f789f802c7672f2a65f23e7547411b3c4f288cc
unregisterJMX
protected void unregisterJMX(ZooKeeperServer zks)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxServerBean = null;}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return "read-only";}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return self.getId();}
adee6d577ad1124bcdd55d9356083ab1be7b96b41b09ad125a756c3523b15a7e
shutdown
public synchronized void shutdown()
{    if (!canShutdown()) {        LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");        return;    }    shutdown = true;    unregisterJMX(this);        self.setZooKeeperServer(null);        self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);        super.shutdown();}
9676c751cfd23b3e9a635c6c412564753bb76ee853dc2dbfd043b7f361b97b38
dumpConf
public void dumpConf(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());}
c1fb0acefc598c56ec326dc3b4778c056ac59608c9aca70ed1d136ac1a0cc817
setState
protected void setState(State state)
{    this.state = state;}
596a7802c6f66987dbb5e0b1cab458fcc2af90da6c7c4093870086275968969b
setQuorumServer
public void setQuorumServer(QuorumPeer.QuorumServer peer)
{    this.peer = peer;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "replica." + peer.id;}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
4f1ec8c9033d0a4457283cded308db0fec7b84f7c76e3ab807775805037a55de
getQuorumAddress
public String getQuorumAddress()
{    return peer.addr.getHostString() + ":" + peer.addr.getPort();}
514186471f5a021d8c5ea09bcda12ab34e3a72c49a91c2364760187b3dcaac51
getElectionAddress
public String getElectionAddress()
{    return peer.electionAddr.getHostString() + ":" + peer.electionAddr.getPort();}
0fb808b56ebdb6386bad979b8f93f01e194664965d5285cf445d090ad0fd3e6b
getClientAddress
public String getClientAddress()
{    if (null == peer.clientAddr) {        return "";    }    return peer.clientAddr.getHostString() + ":" + peer.clientAddr.getPort();}
7641fec0017465a8a698cefc69a9f26280473649e240294b6966d49c05072e0e
getLearnerType
public String getLearnerType()
{    return peer.type.toString();}
261b1d5329a359f54179b707447d10aad0876e9640502da1514ed8a1925a3d54
isLeader
public boolean isLeader()
{    return localPeer.isLeader(peer.getId());}
a9d237bff7679d293d913de88577995236e4913f8fb5daafc8f0dc5540800001
processRequest
public void processRequest(Request si)
{    if (si.type != OpCode.sync) {        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);        try {            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);            learner.writePacket(qp, false);        } catch (IOException e) {            LOG.warn("Closing connection to leader, exception during packet send", e);            try {                if (!learner.sock.isClosed()) {                    learner.sock.close();                }            } catch (IOException e1) {                                LOG.debug("Ignoring error closing the connection", e1);            }        }    }}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    try {        learner.writePacket(null, true);    } catch (IOException e) {        LOG.warn("Closing connection to leader, exception during packet send", e);        try {            if (!learner.sock.isClosed()) {                learner.sock.close();            }        } catch (IOException e1) {                        LOG.debug("Ignoring error closing the connection", e1);        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
8303d5084d47fc5be0af240478176fb41cfc08788476e7a91d731842a77de2c9
getStartTime
public String getStartTime()
{    return startTime.toString();}
9547a690ff8e65617126fa33175b760c34c334dbf58c50e4595edc1b03894fbb
getCurrentEpoch
public long getCurrentEpoch()
{    return currentEpoch;}
d2f73a962ac8f805f35d213cfeba4c256a65716d467e27f87e37a18c92065dfa
getLastZxid
public long getLastZxid()
{    return lastZxid;}
2969fb0637ba02d72c4301e7ff46fb1834f154bbc7a1055c9cb262ef2eb65142
isMoreRecentThan
public boolean isMoreRecentThan(StateSummary ss)
{    return (currentEpoch > ss.currentEpoch) || (currentEpoch == ss.currentEpoch && lastZxid > ss.lastZxid);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof StateSummary)) {        return false;    }    StateSummary ss = (StateSummary) obj;    return currentEpoch == ss.currentEpoch && lastZxid == ss.lastZxid;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (currentEpoch ^ lastZxid);}
46a0fb322474809cae3758b5f50141c32cafb011d7ea9ba40908bfcf4e75da9a
addQuorumVerifier
public void addQuorumVerifier(QuorumVerifier qv)
{    qvAcksetPairs.add(new QuorumVerifierAcksetPair(qv, new HashSet<Long>(qv.getVotingMembers().size())));}
d632f76a71e641703551970e7079786a3ecc25ce9d0996fa19b92754e6857cb3
addAck
public boolean addAck(Long sid)
{    boolean change = false;    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            qvAckset.getAckset().add(sid);            change = true;        }    }    return change;}
2e1b79e14b9363657ba113ff85a571f309915a0a5677144307ebf8115024c5d5
hasSid
public boolean hasSid(long sid)
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            return false;        }    }    return true;}
20d81145b03fd1742dff43353a973aab212d509fb0754bd2af6bcfd2dc7eca9d
hasAllQuorums
public boolean hasAllQuorums()
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset())) {            return false;        }    }    return true;}
66b4db40c97064b696e8149aac97ea32d9e1a61eaec5bd65440fdb4383bdad1f
ackSetsToString
public String ackSetsToString()
{    StringBuilder sb = new StringBuilder();    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        sb.append(qvAckset.getAckset().toString()).append(",");    }    return sb.substring(0, sb.length() - 1);}
785b85f08dee7b212958218d2d7f8c76780c8081183577ec7554e802c0bab5d8
getQuorumVerifier
public QuorumVerifier getQuorumVerifier()
{    return this.qv;}
f31f8f7f7f815f2c77690f7a96ee68c330550539b1dfd605e766de34f4ec571f
getAckset
public HashSet<Long> getAckset()
{    return this.ackset;}
4b5ab03387b8ab04b9d5bf70434d2d33b441ffdace80fb74c43a1cf8410c23f2
getMessage
private static String getMessage(int concurrentSyncNumber, int throttleThreshold, LearnerSyncThrottler.SyncType syncType)
{    return String.format("new %s sync would make %d concurrently in progress; maximum is %d", syncType.toString().toLowerCase(), concurrentSyncNumber, throttleThreshold);}
edec944f9520151a910f01bcb4a6e61c71fae64d720764e1cab42b9055a62eec
accept
public Socket accept() throws IOException
{    if (isClosed()) {        throw new SocketException("Socket is closed");    }    if (!isBound()) {        throw new SocketException("Socket is not bound yet");    }    final PrependableSocket prependableSocket = new PrependableSocket(null);    implAccept(prependableSocket);    return new UnifiedSocket(x509Util, allowInsecureConnection, prependableSocket);}
b2b05d98cff7513478051b08a9067eb1cb0185222b312fb934433b68605b30c9
isSecureSocket
public boolean isSecureSocket()
{    return mode == Mode.TLS;}
7c7a21cb73fa52cf61c9c559ecf24b1d7f2e484605b414bd60fe7ef7ae418166
isPlaintextSocket
public boolean isPlaintextSocket()
{    return mode == Mode.PLAINTEXT;}
eab8ab3e6f3062d8c658b8dc38d6f19c46022312f981dfca259af878244b35ee
isModeKnown
public boolean isModeKnown()
{    return mode != Mode.UNKNOWN;}
b5f4fa8dfc4f7e473718fb03577881484db101e4939c573b17d696271acf78ce
detectMode
private void detectMode() throws IOException
{    byte[] litmus = new byte[5];    int oldTimeout = -1;    int bytesRead = 0;    int newTimeout = x509Util.getSslHandshakeTimeoutMillis();    try {        oldTimeout = prependableSocket.getSoTimeout();        prependableSocket.setSoTimeout(newTimeout);        bytesRead = prependableSocket.getInputStream().read(litmus, 0, litmus.length);    } catch (SocketTimeoutException e) {                LOG.warn("Socket mode detection timed out after " + newTimeout + " ms, assuming PLAINTEXT");    } finally {                try {            if (oldTimeout != -1) {                prependableSocket.setSoTimeout(oldTimeout);            }        } catch (Exception e) {            LOG.warn("Failed to restore old socket timeout value of " + oldTimeout + " ms", e);        }    }    if (bytesRead < 0) {                bytesRead = 0;    }    if (bytesRead == litmus.length && SslHandler.isEncrypted(Unpooled.wrappedBuffer(litmus))) {        try {            sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);        } catch (X509Exception e) {            throw new IOException("failed to create SSL context", e);        }        prependableSocket = null;        mode = Mode.TLS;        LOG.info("Accepted TLS connection from {} - {} - {}", sslSocket.getRemoteSocketAddress(), sslSocket.getSession().getProtocol(), sslSocket.getSession().getCipherSuite());    } else if (allowInsecureConnection) {        prependableSocket.prependToInputStream(litmus, 0, bytesRead);        mode = Mode.PLAINTEXT;        LOG.info("Accepted plaintext connection from {}", prependableSocket.getRemoteSocketAddress());    } else {        prependableSocket.close();        mode = Mode.PLAINTEXT;        throw new IOException("Blocked insecure connection attempt");    }}
47297e553f806e19c55a0f0949631608c094b03f79d01758347bf6c8cd41c389
getSocketAllowUnknownMode
private Socket getSocketAllowUnknownMode()
{    if (isSecureSocket()) {        return sslSocket;    } else {                return prependableSocket;    }}
ab49a7ff31b015301e7b4a2a9ea0e761705cff7dc905ba2cfdc721ef9f84ef90
getSocket
private Socket getSocket() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (mode == Mode.TLS) {        return sslSocket;    } else {        return prependableSocket;    }}
96d6f4f9b4550673010ea6b83df4730814f53a5a40e168e3a6256e1fe9e187d7
getSslSocket
public SSLSocket getSslSocket() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (!isSecureSocket()) {        throw new SocketException("Socket mode is not TLS");    }    return sslSocket;}
17298964161f55f59564ce4cd466b1a4b9c0c16211aea9d41d428d38cf56cd3e
connect
public void connect(SocketAddress endpoint) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint);}
a2f7caf9ba5d4ce02f93b8be892390d74f714c104651ef96ad8e7af4fad9e6b5
connect
public void connect(SocketAddress endpoint, int timeout) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint, timeout);}
5049dc0240af379a7e2d8ef798660c42beda6723d2566e20ca754f7c6d8b12f6
bind
public void bind(SocketAddress bindpoint) throws IOException
{    getSocketAllowUnknownMode().bind(bindpoint);}
8a97b7a4714b0b78e75ea5cabaed8f99dbebe873a5959dda6680f1eec2ae467d
getInetAddress
public InetAddress getInetAddress()
{    return getSocketAllowUnknownMode().getInetAddress();}
d9fd74e9a4e35f1314f9e4c8416598da1f35a065f051c3b787df91c178bcff93
getLocalAddress
public InetAddress getLocalAddress()
{    return getSocketAllowUnknownMode().getLocalAddress();}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return getSocketAllowUnknownMode().getPort();}
0f9342907a55818619d2e2cfa5fa813892dc2783be692f8ecc0da9029bc998d0
getLocalPort
public int getLocalPort()
{    return getSocketAllowUnknownMode().getLocalPort();}
6526974c1ab7a1b5d671ae6c4ecf01c5752750a1ee078dc51a0e1488b02316cb
getRemoteSocketAddress
public SocketAddress getRemoteSocketAddress()
{    return getSocketAllowUnknownMode().getRemoteSocketAddress();}
9822ffa3e2717549e19c7f139072ce642954f3a97b32552731f1cb19a194fa60
getLocalSocketAddress
public SocketAddress getLocalSocketAddress()
{    return getSocketAllowUnknownMode().getLocalSocketAddress();}
cd98abc0faf367e33db6c874717f5cc05f6912da887e4d4b79d2d8c4f3f24b0e
getChannel
public SocketChannel getChannel()
{    return getSocketAllowUnknownMode().getChannel();}
1bb9d826482de87041e929f03d6073d7bca36bd7359f7658f22d33e1af426037
getInputStream
public InputStream getInputStream() throws IOException
{    return new UnifiedInputStream(this);}
0a43eb2b54ffe1f82a972a0f65fb297f14a6a9b65afd3e794a5c44647a4b9c62
getOutputStream
public OutputStream getOutputStream() throws IOException
{    return new UnifiedOutputStream(this);}
28acdcaa7971f3268155abb1c2f10e12c8bbf12f2237bec3ea691944a0cbd29b
setTcpNoDelay
public void setTcpNoDelay(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setTcpNoDelay(on);}
5b1ef10780ee1bfc12995c93be953b65ee648179ce79632a2bdbe3f43c3b14c7
getTcpNoDelay
public boolean getTcpNoDelay() throws SocketException
{    return getSocketAllowUnknownMode().getTcpNoDelay();}
ae2932686633f07d72843dedb4f1f2656592ad1b6d6e6d373a767953581d279b
setSoLinger
public void setSoLinger(boolean on, int linger) throws SocketException
{    getSocketAllowUnknownMode().setSoLinger(on, linger);}
20ca0ddd7c90df64aacd7e8329b2c36f9c2cfa26f2fe64dc1cc5b340f61d782e
getSoLinger
public int getSoLinger() throws SocketException
{    return getSocketAllowUnknownMode().getSoLinger();}
60793f8306c04072e2b0fff454194224399eb1c0eaca04b74854ae8e2847cfba
sendUrgentData
public void sendUrgentData(int data) throws IOException
{    getSocket().sendUrgentData(data);}
b2229d34999dcd34a55c2d7d4b55014f0a24d93b06e166c9883a873999eb3258
setOOBInline
public void setOOBInline(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setOOBInline(on);}
e86023e274e0166fb250f855b7c221afe0e53807b34f5cf0acd131d10f4da51e
getOOBInline
public boolean getOOBInline() throws SocketException
{    return getSocketAllowUnknownMode().getOOBInline();}
15724b7fa1beaeb9b8989a5b3fcf3ff65d35bd8bd15fec16aabf019db396d0e3
setSoTimeout
public synchronized void setSoTimeout(int timeout) throws SocketException
{    getSocketAllowUnknownMode().setSoTimeout(timeout);}
98f11003ab0a3be0d96f742f8ae5f8325d1edd2e7aa7798991f5d3089c30fa91
getSoTimeout
public synchronized int getSoTimeout() throws SocketException
{    return getSocketAllowUnknownMode().getSoTimeout();}
687d139c389bc6261579ac3626982025f71e354161221251ef7af92d87f788db
setSendBufferSize
public synchronized void setSendBufferSize(int size) throws SocketException
{    getSocketAllowUnknownMode().setSendBufferSize(size);}
38529783169035d55a7692ef3aba1ef8eebc4564e4e13159f308363bb24c91d8
getSendBufferSize
public synchronized int getSendBufferSize() throws SocketException
{    return getSocketAllowUnknownMode().getSendBufferSize();}
81f5726092aa584aee286711665dd4701dd628f44eb05853f3366ef3b9478108
setReceiveBufferSize
public synchronized void setReceiveBufferSize(int size) throws SocketException
{    getSocketAllowUnknownMode().setReceiveBufferSize(size);}
826c612a64807fd0cbe995e955ba6806aee2436aa8130d33d8519ffe8dc583ec
getReceiveBufferSize
public synchronized int getReceiveBufferSize() throws SocketException
{    return getSocketAllowUnknownMode().getReceiveBufferSize();}
b23e5ead9321dad26e8c0dab4bd60796a33947306baf5ac49005721d0b8be647
setKeepAlive
public void setKeepAlive(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setKeepAlive(on);}
cffc7b811fdcc675479b67532ccacda7ec789e245d9b766b36e590a5b088d588
getKeepAlive
public boolean getKeepAlive() throws SocketException
{    return getSocketAllowUnknownMode().getKeepAlive();}
2d882213df68141d833abdd367e25d9085da9698fe7df7dedd00f700f533c498
setTrafficClass
public void setTrafficClass(int tc) throws SocketException
{    getSocketAllowUnknownMode().setTrafficClass(tc);}
2943a5e465c4f8641bc70164eaa45a05e4610a0e8c94f37bcd6daaebdf980917
getTrafficClass
public int getTrafficClass() throws SocketException
{    return getSocketAllowUnknownMode().getTrafficClass();}
dd2621827a0207c1ff37810b68f1f8964c62dffa20429cfe2acfbc416c014ec8
setReuseAddress
public void setReuseAddress(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setReuseAddress(on);}
5fbacd8a8ffa37453e32c10d3b26cfce6c261d63b5f313c96e99e6ea3d860855
getReuseAddress
public boolean getReuseAddress() throws SocketException
{    return getSocketAllowUnknownMode().getReuseAddress();}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    getSocketAllowUnknownMode().close();}
c749ef04bf52236a3730a0b605ef962b6fd65e8fae78f3463bcd7780372da99f
shutdownInput
public void shutdownInput() throws IOException
{    getSocketAllowUnknownMode().shutdownInput();}
5819857e96d7fb08e12243208e53472930393b943bfee3c3798c22c27823a54a
shutdownOutput
public void shutdownOutput() throws IOException
{    getSocketAllowUnknownMode().shutdownOutput();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UnifiedSocket[mode=" + mode.toString() + "socket=" + getSocketAllowUnknownMode().toString() + "]";}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return getSocketAllowUnknownMode().isConnected();}
731c71fb63c1ccb3fbba8308809f854d092f167bfb65094bd9a5cd49eff04197
isBound
public boolean isBound()
{    return getSocketAllowUnknownMode().isBound();}
fb428ee224c53451dffb98bb037b7c463bedfea2a2ba682d1af54cbe652a1ac9
isClosed
public boolean isClosed()
{    return getSocketAllowUnknownMode().isClosed();}
7aafc1c6f5950919631c274b5c5a50fdcf7d9da41e3e3409be448145827e023b
isInputShutdown
public boolean isInputShutdown()
{    return getSocketAllowUnknownMode().isInputShutdown();}
3bee5e57df98b10b8e49173c231df7f5742d55cd1b88f85d1cf0e34ef1bf0543
isOutputShutdown
public boolean isOutputShutdown()
{    return getSocketAllowUnknownMode().isOutputShutdown();}
087b8c4b15363c8378a921cf03fef95049fd47938a784671dcbc7fcca4afb185
setPerformancePreferences
public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
{    getSocketAllowUnknownMode().setPerformancePreferences(connectionTime, latency, bandwidth);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return getRealInputStream().read();}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return getRealInputStream().read(b);}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return getRealInputStream().read(b, off, len);}
cc404644feec8c3784d1a0da55e5637d3b946988469ca0cfdfdda5de43ed7b95
getRealInputStream
private InputStream getRealInputStream() throws IOException
{    if (realInputStream == null) {                realInputStream = unifiedSocket.getSocket().getInputStream();    }    return realInputStream;}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    return getRealInputStream().skip(n);}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    return getRealInputStream().available();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    getRealInputStream().close();}
0169b61fd7df5553eaf3da19f6641403b1f73320c5d14f2784a1382976af5520
mark
public synchronized void mark(int readlimit)
{    try {        getRealInputStream().mark(readlimit);    } catch (IOException e) {        throw new RuntimeException(e);    }}
8dffc85e05aab40453485468b7327673d537932322af366b28f0c26e5fcccd02
reset
public synchronized void reset() throws IOException
{    getRealInputStream().reset();}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    try {        return getRealInputStream().markSupported();    } catch (IOException e) {        throw new RuntimeException(e);    }}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    getRealOutputStream().write(b);}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{    getRealOutputStream().write(b);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    getRealOutputStream().write(b, off, len);}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    getRealOutputStream().flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    getRealOutputStream().close();}
6be98d07a5f973bbc9939d7aaa637ed1e7e17770ea6d5cc4bd48e2ce202bd1a7
getRealOutputStream
private OutputStream getRealOutputStream() throws IOException
{    if (realOutputStream == null) {                realOutputStream = unifiedSocket.getSocket().getOutputStream();    }    return realOutputStream;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
677a5bbae2620bb35fa328d2ee7ca7a55fca534b8fe0bd1ee15a0da66aec485c
createLocalSessionTracker
public void createLocalSessionTracker(SessionExpirer expirer, int tickTime, long id, ZooKeeperServerListener listener)
{    this.localSessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();    this.localSessionTracker = new LocalSessionTracker(expirer, this.localSessionsWithTimeouts, tickTime, id, listener);    this.upgradingSessions = new ConcurrentHashMap<Long, Integer>();}
b73bf7e716f61557372d976521bc74ae2335362f0749028510f86154f816787c
isTrackingSession
public boolean isTrackingSession(long sessionId)
{    return isLocalSession(sessionId) || isGlobalSession(sessionId);}
39fa1f1b69df2be4909a68a70417b83cbf2497fb9718462eb0a17da78fe424a3
isLocalSession
public boolean isLocalSession(long sessionId)
{    return localSessionTracker != null && localSessionTracker.isTrackingSession(sessionId);}
3b7c1330fc3efc999615334279ed2539d3495c17199f15a2cd557ca4c775c546
isLocalSessionsEnabled
public boolean isLocalSessionsEnabled()
{    return localSessionsEnabled;}
8d6ed98e02ebf3bad57f0379a6e8c4922d68a5e2e4bd3fdfc280e680714d71e8
isUpgradingSession
public boolean isUpgradingSession(long sessionId)
{    return upgradingSessions != null && upgradingSessions.containsKey(sessionId);}
dd33c4938046041dd5e72643151b956ed33f5e507c46da12856a19fa9ec23197
finishedUpgrading
public void finishedUpgrading(long sessionId)
{    if (upgradingSessions != null) {        upgradingSessions.remove(sessionId);    }}
ee39b918928f75ab701501f39ce8ea2815dc1a967b02e484cb9643c474e07e9f
upgradeSession
public int upgradeSession(long sessionId)
{    if (localSessionsWithTimeouts == null) {        return -1;    }            Integer timeout = localSessionsWithTimeouts.remove(sessionId);    if (timeout != null) {        LOG.info("Upgrading session 0x" + Long.toHexString(sessionId));                                        trackSession(sessionId, timeout);                        upgradingSessions.put(sessionId, timeout);        localSessionTracker.removeSession(sessionId);        return timeout;    }    return -1;}
a5723ca4b758186a58d9b64c47926f2d021f46a746cb975d2dc9c420034e106e
removeLocalSession
protected void removeLocalSession(long sessionId)
{    if (localSessionTracker == null) {        return;    }    localSessionTracker.removeSession(sessionId);}
499e3a44e2100043165524b1d156803435958d31737f80bf86cb5159f62ee7ed
checkGlobalSession
public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    throw new UnsupportedOperationException();}
a4ad0e6cfe447eb5c45c50b13ef0390e9b8a8491f5fcba889908b4f506465171
getLocalSessionCount
public long getLocalSessionCount()
{    if (localSessionsWithTimeouts == null) {        return 0;    }    return localSessionsWithTimeouts.size();}
54bc0b349a40e5994cc6b2b7c63b7bdb8eaebafd56321e290c868307cb2a4574
getVersion
public int getVersion()
{    return version;}
12988e32fb9e7822231bf05b7d2b2013fd70cf350e185d48e6fdacbe7847e62e
getId
public long getId()
{    return id;}
801e4e9de7001eb2aab4d5e974b3815294de7fb0baf148bdf44fffbf5d770188
getZxid
public long getZxid()
{    return zxid;}
19677090707f7154d4e612aecb0910a3a0ec42a11d59d244eac2b0c8e90a25ad
getElectionEpoch
public long getElectionEpoch()
{    return electionEpoch;}
4194e709383e191f4b35359e8759c87f34448ec810f3372b85a0e4a6ff690a1f
getPeerEpoch
public long getPeerEpoch()
{    return peerEpoch;}
1079ad8f427f584b2d3688512943ec5f0329566d9f0bf71b7b8a855fe46d2c85
getState
public ServerState getState()
{    return state;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Vote)) {        return false;    }    Vote other = (Vote) o;    if ((state == ServerState.LOOKING) || (other.state == ServerState.LOOKING)) {        return id == other.id && zxid == other.zxid && electionEpoch == other.electionEpoch && peerEpoch == other.peerEpoch;    } else {        /*             * There are two things going on in the logic below:             *             * 1. skip comparing the zxid and electionEpoch for votes for servers             *    out of election.             *             *    Need to skip those because they can be inconsistent due to             *    scenarios described in QuorumPeer.updateElectionVote.             *             *    And given that only one ensemble can be running at a single point             *    in time and that each epoch is used only once, using only id and             *    epoch to compare the votes is sufficient.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1805}             *             * 2. skip comparing peerEpoch if if we're running with mixed ensemble             *    with (version > 0x0) and without the change (version = 0x0)             *    introduced in ZOOKEEPER-1732.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}             *             *    The server running with and without ZOOKEEPER-1732 will return             *    different peerEpoch. During rolling upgrades, it's possible             *    that 2/5 servers are returning epoch 1, while the other 2/5             *    are returning epoch 2, the other server need to ignore the             *    peerEpoch to be able to join it.             */        if ((version > 0x0) ^ (other.version > 0x0)) {            return id == other.id;        } else {            return (id == other.id && peerEpoch == other.peerEpoch);        }    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (id & zxid);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "(" + id + ", " + Long.toHexString(zxid) + ", " + Long.toHexString(peerEpoch) + ")";}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    if (msg != null && count > 0) {        String log = "";        if (count > 1) {            log = "[" + count + " times] ";        }        log += "Message: " + msg;        if (value != null) {            log += " Last value:" + value;        }        LOG.warn(log);    }    msg = null;    value = null;    count = 0;}
cb13f481090586e6f56671ed5895e5a2e9534613168eb2df4380c6e9141711a9
rateLimitLog
public void rateLimitLog(String newMsg)
{    rateLimitLog(newMsg, null);}
5f4426ea88f4ca02ddc91db969a02ba9be361060e5704b2e46a08f8620f5fad0
rateLimitLog
public void rateLimitLog(String newMsg, String value)
{    long now = Time.currentElapsedTime();    if (newMsg.equals(msg)) {        ++count;        this.value = value;        if (now - timestamp >= LOG_INTERVAL) {            flush();            msg = newMsg;            timestamp = now;            this.value = value;        }    } else {        flush();        msg = newMsg;        this.value = value;        timestamp = now;        LOG.warn("Message:{} Value:{}", msg, value);    }}
ba32d3731d3e5f55a31623a6dc7208263d6e780486c1beadd391f25317652ae2
convertAcls
public synchronized Long convertAcls(List<ACL> acls)
{    if (acls == null) {        return OPEN_UNSAFE_ACL_ID;    }        Long ret = aclKeyMap.get(acls);    if (ret == null) {        ret = incrementIndex();        longKeyMap.put(ret, acls);        aclKeyMap.put(acls, ret);    }    addUsage(ret);    return ret;}
82134ed1365c0682707ba820e2035a563b5be8d7643b6e4b7f0279f270af04b1
convertLong
public synchronized List<ACL> convertLong(Long longVal)
{    if (longVal == null) {        return null;    }    if (longVal == OPEN_UNSAFE_ACL_ID) {        return ZooDefs.Ids.OPEN_ACL_UNSAFE;    }    List<ACL> acls = longKeyMap.get(longVal);    if (acls == null) {        LOG.error("ERROR: ACL not available for long " + longVal);        throw new RuntimeException("Failed to fetch acls for " + longVal);    }    return acls;}
3df9ec696c436d6941e6c1d400801be88ebe0c8e908a35f243f9fc0a88bcb6ac
incrementIndex
private long incrementIndex()
{    return ++aclIndex;}
d7bf31a5b5fc4cad5f822f2acce606726565ed9a3c54c47d1eff965d9cbaa165
deserialize
public synchronized void deserialize(InputArchive ia) throws IOException
{    clear();    int i = ia.readInt("map");    while (i > 0) {        Long val = ia.readLong("long");        if (aclIndex < val) {            aclIndex = val;        }        List<ACL> aclList = new ArrayList<ACL>();        Index j = ia.startVector("acls");        if (j == null) {            throw new RuntimeException("Incorrent format of InputArchive when deserialize DataTree - missing acls");        }        while (!j.done()) {            ACL acl = new ACL();            acl.deserialize(ia, "acl");            aclList.add(acl);            j.incr();        }        longKeyMap.put(val, aclList);        aclKeyMap.put(aclList, val);        referenceCounter.put(val, new AtomicLongWithEquals(0));        i--;    }}
7d27302df89a8ecd04da7f48ebedf864b377e433d8a743b6b1f831de92d62b13
serialize
public synchronized void serialize(OutputArchive oa) throws IOException
{    oa.writeInt(longKeyMap.size(), "map");    Set<Map.Entry<Long, List<ACL>>> set = longKeyMap.entrySet();    for (Map.Entry<Long, List<ACL>> val : set) {        oa.writeLong(val.getKey(), "long");        List<ACL> aclList = val.getValue();        oa.startVector(aclList, "acls");        for (ACL acl : aclList) {            acl.serialize(oa, "acl");        }        oa.endVector(aclList, "acls");    }}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return aclKeyMap.size();}
b3e79869c74977c719c14b7eabf310dd0a6e88ee53d46bbcceb8b8839243798e
clear
private void clear()
{    aclKeyMap.clear();    longKeyMap.clear();    referenceCounter.clear();}
ad2bd77fb61814b53653e0b747f51e3bb817cf720487edc86c9c50b997f0d52a
addUsage
public synchronized void addUsage(Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {        LOG.info("Ignoring acl " + acl + " as it does not exist in the cache");        return;    }    AtomicLong count = referenceCounter.get(acl);    if (count == null) {        referenceCounter.put(acl, new AtomicLongWithEquals(1));    } else {        count.incrementAndGet();    }}
e84a2a1a779adeb9a68c83e45c8e37bbac001042af1912102b89d864d846a564
removeUsage
public synchronized void removeUsage(Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {        LOG.info("Ignoring acl " + acl + " as it does not exist in the cache");        return;    }    long newCount = referenceCounter.get(acl).decrementAndGet();    if (newCount <= 0) {        referenceCounter.remove(acl);        aclKeyMap.remove(longKeyMap.get(acl));        longKeyMap.remove(acl);    }}
d67bb3247d0012aa5f1139acda57a0a175cb994bb8131c4b543b00f8b8bab9cb
purgeUnused
public synchronized void purgeUnused()
{    Iterator<Map.Entry<Long, AtomicLongWithEquals>> refCountIter = referenceCounter.entrySet().iterator();    while (refCountIter.hasNext()) {        Map.Entry<Long, AtomicLongWithEquals> entry = refCountIter.next();        if (entry.getValue().get() <= 0) {            Long acl = entry.getKey();            aclKeyMap.remove(longKeyMap.get(acl));            longKeyMap.remove(acl);            refCountIter.remove();        }    }}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    return equals((AtomicLongWithEquals) o);}
3d92171a67e0b85d21ec4b1a3c4614fa0ad998baaa378698d7e4ea93de85b3d5
equals
public boolean equals(AtomicLongWithEquals that)
{    return get() == that.get();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 31 * Long.valueOf(get()).hashCode();}
73ff64bf0ac2a03263e5e7650fbb489c45165e021f3a1927c826e6ee66fd8d59
isLocalSession
public boolean isLocalSession()
{    return isLocalSession;}
7460e8a033ea93c0bf42488eb03413a4768a833ccb40d0f6190782b74cc46a85
setLocalSession
public void setLocalSession(boolean isLocalSession)
{    this.isLocalSession = isLocalSession;}
6de030b60c1b06f114ff4cb712df904f9a87ded137069214305b24d55b9fdcee
setLargeRequestSize
public void setLargeRequestSize(int size)
{    largeRequestSize = size;}
024ecc7d0f7b2e2145b3c4ca5c3e6dbdc4425848d75bcbca1cdcc4694ded504c
getLargeRequestSize
public int getLargeRequestSize()
{    return largeRequestSize;}
4421a695ff04d675187a711554630eb5ce678027ee8e1fac8164c142cdfc60ba
getOwner
public Object getOwner()
{    return owner;}
2231e1f491dbcef8fbcb4ff61bea325b8379ca0329778b15b92372c1160a48b9
setOwner
public void setOwner(Object owner)
{    this.owner = owner;}
84b7ab1f87c53f46d884a92a28688e8009c9dc86c8459a8e7d757436c15221d8
getHdr
public TxnHeader getHdr()
{    return hdr;}
968cb83e9b3018eecfea6b26fa73ecc146157dd5d69525de47619326edd5c4ae
setHdr
public void setHdr(TxnHeader hdr)
{    this.hdr = hdr;}
bcc5f4ab9662ab8429d6e57a2acfe9922f5bfecf749b25f24280aca0df56bcf9
getTxn
public Record getTxn()
{    return txn;}
8367cc1ba64a9f1e408fa6a91c3a9acf5190c20b8fcc5d35bc8ea7f60361ae9f
setTxn
public void setTxn(Record txn)
{    this.txn = txn;}
0d0ea558ee9038194e81f71ae6a2d57c6984dc22f1c6dafc0b33c27b2c1e3906
getConnection
public ServerCnxn getConnection()
{    return cnxn;}
fb70dbd80fa4b503e8ce17ef21ffd2148485099727844e7528366b322468db5f
getStaleLatencyCheck
public static boolean getStaleLatencyCheck()
{    return staleLatencyCheck;}
984a033c4078dd8ee68fbb391878e1783a132f78fb3541c337783ec6a241fab7
setStaleLatencyCheck
public static void setStaleLatencyCheck(boolean check)
{    staleLatencyCheck = check;}
5c19d3bf40df016c9b868d032c58a90cba93832c9e3f1e7f71ecb64f29245e48
getStaleConnectionCheck
public static boolean getStaleConnectionCheck()
{    return staleConnectionCheck;}
45c11c3fccf4ec7ad2d13cec67e2c859f50e7fdb568259d2cbba1bfb546feed4
setStaleConnectionCheck
public static void setStaleConnectionCheck(boolean check)
{    staleConnectionCheck = check;}
833eecaf3ef30fbfad81449304a6c84a29c07c46396e1334c6462020fe69043d
isStale
public boolean isStale()
{    if (cnxn == null) {        return false;    }        if (type == OpCode.closeSession) {        return false;    }    if (staleConnectionCheck) {                if (cnxn.isStale() || cnxn.isInvalid()) {            return true;        }    }    if (staleLatencyCheck) {                        long currentTime = Time.currentElapsedTime();        return (currentTime - createTime) > cnxn.getSessionTimeout();    }    return false;}
6bec61509548547f3225e4b84aa651a04d82391b4f6fcd427e1e237c72c49384
mustDrop
public boolean mustDrop()
{    return ((cnxn != null) && cnxn.isInvalid());}
e12cf9952f4f462dd2f450b0cdd8ee18c7a392ed0b395ecdd53c16b1cc44832e
isValid
 static boolean isValid(int type)
{        switch(type) {        case OpCode.notification:            return false;        case OpCode.check:        case OpCode.closeSession:        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.createSession:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multi:        case OpCode.multiRead:        case OpCode.ping:        case OpCode.reconfig:        case OpCode.setACL:        case OpCode.setData:        case OpCode.setWatches:        case OpCode.sync:        case OpCode.checkWatches:        case OpCode.removeWatches:            return true;        default:            return false;    }}
0d6b1c3808c500dcbef977e8eb3645cd644ea80788762d90f40f19f1099c0f5d
isQuorum
public boolean isQuorum()
{    switch(this.type) {        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multiRead:            return false;        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.error:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setACL:        case OpCode.setData:        case OpCode.check:        case OpCode.multi:        case OpCode.reconfig:            return true;        case OpCode.closeSession:        case OpCode.createSession:            return !this.isLocalSession;        default:            return false;    }}
f3f1e90bc5c40b8951c37e75e049acc5ce1fe4df2cffa4b76d791a789fbbb742
op2String
public static String op2String(int op)
{    switch(op) {        case OpCode.notification:            return "notification";        case OpCode.create:            return "create";        case OpCode.delete:            return "delete";        case OpCode.exists:            return "exists";        case OpCode.getData:            return "getData";        case OpCode.setData:            return "setData";        case OpCode.getACL:            return "getACL";        case OpCode.setACL:            return "setACL";        case OpCode.getChildren:            return "getChildren";        case OpCode.sync:            return "sync";        case OpCode.ping:            return "ping";        case OpCode.getChildren2:            return "getChildren2";        case OpCode.check:            return "check";        case OpCode.multi:            return "multi";        case OpCode.create2:            return "create2";        case OpCode.reconfig:            return "reconfig";        case OpCode.checkWatches:            return "checkWatches";        case OpCode.removeWatches:            return "removeWatches";        case OpCode.createContainer:            return "createContainer";        case OpCode.deleteContainer:            return "deleteContainer";        case OpCode.createTTL:            return "createTtl";        case OpCode.multiRead:            return "multiRead";        case OpCode.auth:            return "auth";        case OpCode.setWatches:            return "setWatches";        case OpCode.sasl:            return "sasl";        case OpCode.getEphemerals:            return "getEphemerals";        case OpCode.getAllChildrenNumber:            return "getAllChildrenNumber";        case OpCode.createSession:            return "createSession";        case OpCode.closeSession:            return "closeSession";        case OpCode.error:            return "error";        default:            return "unknown " + op;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("sessionid:0x").append(Long.toHexString(sessionId)).append(" type:").append(op2String(type)).append(" cxid:0x").append(Long.toHexString(cxid)).append(" zxid:0x").append(Long.toHexString(hdr == null ? -2 : hdr.getZxid())).append(" txntype:").append(hdr == null ? "unknown" : "" + hdr.getType());        String path = "n/a";    if (type != OpCode.createSession && type != OpCode.setWatches && type != OpCode.closeSession && request != null && request.remaining() >= 4) {        try {                        ByteBuffer rbuf = request.asReadOnlyBuffer();            rbuf.clear();            int pathLen = rbuf.getInt();                        if (pathLen >= 0 && pathLen < 4096 && rbuf.remaining() >= pathLen) {                byte[] b = new byte[pathLen];                rbuf.get(b);                path = new String(b);            }        } catch (Exception e) {                }    }    sb.append(" reqpath:").append(path);    return sb.toString();}
f104b95ed358b03b233333a38275764fd92f7584762d0ec18c106614a84dd026
setException
public void setException(KeeperException e)
{    this.e = e;}
eef3a0733395b4439cab3643a1e092f4cc89bfc31af008ae1a9245e08d4dd6e0
getException
public KeeperException getException()
{    return e;}
ab9e363e42f73abb94a8cca5ff74407be46b1e9dc129119a30bda0d2ede2c9b0
logLatency
public void logLatency(Summary metric)
{    logLatency(metric, Time.currentWallTime());}
102e73032cda0bc53512f2498cde65f1607c04ca390d62d5f129ebfa9b4c8c67
logLatency
public void logLatency(Summary metric, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(latency);        }    }}
db302758e03df56c10b5ff41f2df6d4aa696d8f6a5774d9705177c5c62b2c3ea
logLatency
public void logLatency(SummarySet metric, String key, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(key, latency);        }    }}
0f41b782e5d8fdaea12539bf8b88008b04fe4bdf00dbefc6f7afa62cc3a0448a
logLatency
public void logLatency(SummarySet metric, String key)
{    logLatency(metric, key, Time.currentWallTime());}
a9253f93b6d1539d93f6b64cac1c9b861757d9ee9fe1c74893d4ea69d9ab44f7
getMaxRequests
public static int getMaxRequests()
{    return maxRequests;}
3ebf037ff6f38f5a3b49b388aab4b5f67a53c1efefb8bd32836fa6f1b81ccb11
setMaxRequests
public static void setMaxRequests(int requests)
{    maxRequests = requests;}
3e0adce54149ec84e643a48d4f8e0f48322adc468badc967db6a4dc6574248b6
getStallTime
public static int getStallTime()
{    return stallTime;}
6855fc9058d2610bee563f4a79019f077ddc2f2ceb1eccddd1e9905dccfd0475
setStallTime
public static void setStallTime(int time)
{    stallTime = time;}
9bf5935ceb2423daa4b6fde5be74cb90e2a68d90ec3f64b9dae5e581da85d77f
getDropStaleRequests
public static boolean getDropStaleRequests()
{    return dropStaleRequests;}
bc240b3d31876369d5c184a54e1adb220f314e928090b07b34cfc7e7ac725ffa
setDropStaleRequests
public static void setDropStaleRequests(boolean drop)
{    dropStaleRequests = drop;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (true) {            if (killed) {                break;            }            Request request = submittedRequests.take();            if (Request.requestOfDeath == request) {                break;            }            if (request.mustDrop()) {                continue;            }                        if (maxRequests > 0) {                while (!killed) {                    if (dropStaleRequests && request.isStale()) {                                                dropRequest(request);                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);                        request = null;                        break;                    }                    if (zks.getInProcess() < maxRequests) {                        break;                    }                    throttleSleep(stallTime);                }            }            if (killed) {                break;            }                        if (request != null) {                if (request.isStale()) {                    ServerMetrics.getMetrics().STALE_REQUESTS.add(1);                }                zks.submitRequestNow(request);            }        }    } catch (InterruptedException e) {        LOG.error("Unexpected interruption", e);    }    int dropped = drainQueue();    LOG.info("RequestThrottler shutdown. Dropped {} requests", dropped);}
ecf07f0e24c97d30fc43e24e1d6820e18412779ce6be22dd5b756e1259b13b72
throttleSleep
private synchronized void throttleSleep(int stallTime)
{    try {        ServerMetrics.getMetrics().REQUEST_THROTTLE_WAIT_COUNT.add(1);        this.wait(stallTime);    } catch (InterruptedException ie) {        return;    }}
a93c8088559bcf1a307fd84711b09f2b05335fabb692c3d0f6b36b5ea2944a59
throttleWake
public synchronized void throttleWake()
{    this.notify();}
3b408f54d6d7f8188a08cf4591877d626f6a11fd3a9f1396541fa1e6c99b27ed
drainQueue
private int drainQueue()
{                    int dropped = 0;    Request request;    LOG.info("Draining request throttler queue");    while ((request = submittedRequests.poll()) != null) {        dropped += 1;        dropRequest(request);    }    return dropped;}
7a171974da1e4e914d15d164e1cd4b358426527abb0a35ecf2a342476439c23b
dropRequest
private void dropRequest(Request request)
{                    ServerCnxn conn = request.getConnection();    if (conn != null) {                conn.setInvalid();    }            zks.requestFinished(request);}
859a3f8b9c55d89328b05ea672f5f43c04fe25cc3c52edfc4dc580253293627a
submitRequest
public void submitRequest(Request request)
{    if (stopping) {        LOG.debug("Shutdown in progress. Request cannot be processed");        dropRequest(request);    } else {        submittedRequests.add(request);    }}
36226848cc03a6faa6c8e95bc4c48444fd45a8eaab3402f150c015f74d982eb7
getInflight
public int getInflight()
{    return submittedRequests.size();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{        LOG.info("Shutting down");    stopping = true;    submittedRequests.add(Request.requestOfDeath);    try {        this.join(shutdownTimeout);    } catch (InterruptedException e) {        LOG.warn("Interrupted while waiting for {} to finish", this);    }            killed = true;    try {        this.join();    } catch (InterruptedException e) {        LOG.warn("Interrupted while waiting for {} to finish", this);                System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }}
96b71f92bda810c9ac0e805b75af04445f1d68d3c28827b9d57566ceb97786d1
put
public void put(String path, byte[] data, Stat stat)
{    Entry entry = new Entry();    entry.data = data;    entry.stat = stat;    cache.put(path, entry);}
b7b904a116400e0ec2f1a648dc9166051688fd7f536c8bac57726d25883c09e6
get
public byte[] get(String key, Stat stat)
{    Entry entry = cache.get(key);    if (entry == null) {        return null;    }    if (!stat.equals(entry.stat)) {                cache.remove(key);        return null;    } else {        return entry.data;    }}
8a9bc6c3771f4a75130b13fbcd31a045fe0daea351e432298ca1fbe02eff92d8
getResponseCacheSize
private static int getResponseCacheSize()
{    return Integer.getInteger("zookeeper.maxResponseCacheSize", DEFAULT_RESPONSE_CACHE_SIZE);}
e1d0d181270e298954afdc7172f6f928c265cff4050354f01cb0c91580a0131e
isEnabled
public static boolean isEnabled()
{    return getResponseCacheSize() > 0;}
c341cb07891b425ceec27035c76b65bc6cbf8020bd4488d998a901c9dbbfecaf
removeEldestEntry
protected boolean removeEldestEntry(Map.Entry<K, V> eldest)
{    return size() >= cacheSize;}
ccaf634aaa71b7fa889a6ef0997c51ddc590fc587b721aa9b1ad34337dd933d7
toDisconnectReasonString
public String toDisconnectReasonString()
{    return disconnectReason;}
becab8ba371b361ac5b7386e52be6143e71cc012e68c88809c009fd534d10237
incrOutstandingAndCheckThrottle
public void incrOutstandingAndCheckThrottle(RequestHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (zkServer.shouldThrottle(outstandingCount.incrementAndGet())) {        disableRecv(false);    }}
0213a76ea36bd03b2fd3cdfab6bec690de700a327c915cd4672e558cadb6451e
decrOutstandingAndCheckThrottle
public void decrOutstandingAndCheckThrottle(ReplyHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (!zkServer.shouldThrottle(outstandingCount.decrementAndGet())) {        enableRecv();    }}
590f9bc7a8fabb7bb4d64eb31f8c8749f09a2cf250eacbcdee954115f5d4c585
sendResponse
public void sendResponse(ReplyHeader h, Record r, String tag) throws IOException
{    sendResponse(h, r, tag, null, null);}
bada33e8c370e13267ff15fadc0ad7bdbf9c0a2ea632c842ba8ef2b624726630
serializeRecord
protected byte[] serializeRecord(Record record) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream(ZooKeeperServer.intBufferStartingSizeBytes);    BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);    bos.writeRecord(record, null);    return baos.toByteArray();}
4e69752bb312225bc38f00ece0ae28a0eb42833f94e41ce156b3d6a53b5075cc
serialize
protected ByteBuffer[] serialize(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{    byte[] header = serializeRecord(h);    byte[] data = null;    if (r != null) {        ResponseCache cache = zkServer.getReadResponseCache();        if (cache != null && stat != null && cacheKey != null && !cacheKey.endsWith(Quotas.statNode)) {                                                            data = cache.get(cacheKey, stat);            if (data == null) {                                data = serializeRecord(r);                cache.put(cacheKey, data, stat);                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_MISSING.add(1);            } else {                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_HITS.add(1);            }        } else {            data = serializeRecord(r);        }    }    int dataLength = data == null ? 0 : data.length;    int packetLength = header.length + dataLength;    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.updateClientResponseSize(packetLength);    }    ByteBuffer lengthBuffer = ByteBuffer.allocate(4).putInt(packetLength);    lengthBuffer.rewind();    int bufferLen = data != null ? 3 : 2;    ByteBuffer[] buffers = new ByteBuffer[bufferLen];    buffers[0] = lengthBuffer;    buffers[1] = ByteBuffer.wrap(header);    if (data != null) {        buffers[2] = ByteBuffer.wrap(data);    }    return buffers;}
7e1b651b18f4874000a3725a597378af45f372074dfe62f28c7561976a9d4977
getAuthInfo
public List<Id> getAuthInfo()
{    return Collections.unmodifiableList(new ArrayList<>(authInfo));}
aa6bc282472f634c35bd08e10ef0885f4968a64f5f949b9a1cc227441f63904b
addAuthInfo
public void addAuthInfo(Id id)
{    authInfo.add(id);}
0c6277f955756decb2dadddd06f7c4e60d6ed5c8dd658124d4675622e5a2bae7
removeAuthInfo
public boolean removeAuthInfo(Id id)
{    return authInfo.remove(id);}
0c86b72e64ad7d215c9e566ea1cec08e83d1bdcebed436bbbd50a3cdb005e614
disableRecv
 void disableRecv()
{    disableRecv(true);}
a466557fc90aad08a6408a8f75410e982cb580f88fbdf1439a64cfa1ea3dd446
getReason
public DisconnectReason getReason()
{    return reason;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EndOfStreamException: " + getMessage();}
a466557fc90aad08a6408a8f75410e982cb580f88fbdf1439a64cfa1ea3dd446
getReason
public DisconnectReason getReason()
{    return reason;}
833eecaf3ef30fbfad81449304a6c84a29c07c46396e1334c6462020fe69043d
isStale
public boolean isStale()
{    return stale;}
10da6d8e8fee3d5688fce0aaa90d4322786771b78f61073d43dc1cfd9ed837d4
setStale
public void setStale()
{    stale = true;}
fe007cfd700282f2f00d8080148f83058fd14e9099d7937e0d0dc90bd0ca68f5
isInvalid
public boolean isInvalid()
{    return invalid;}
6a4e507c62cca7c69e0ecd52a0a5311402686f38b6dda4bcaec41731ddb963e4
setInvalid
public void setInvalid()
{    if (!invalid) {        if (!stale) {            sendCloseSession();        }        invalid = true;    }}
d8698d3196c28241e3c101e0a59bc9d0a6851037344472f03ef60e3fd9d1f46e
packetReceived
protected void packetReceived(long bytes)
{    incrPacketsReceived();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats().incrementPacketsReceived();    }    ServerMetrics.getMetrics().BYTES_RECEIVED_COUNT.add(bytes);}
582283375a372a5b777560ded52c0f9ec7fc921f443b449dda269bd99cc9db40
packetSent
protected void packetSent()
{    incrPacketsSent();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.incrementPacketsSent();    }}
87a8de641f0875f5317a0e10862729e9f4a42d36993c79975a7da74461c26d99
resetStats
public synchronized void resetStats()
{    disconnectReason = DisconnectReason.RESET_COMMAND;    packetsReceived.set(0);    packetsSent.set(0);    minLatency = Long.MAX_VALUE;    maxLatency = 0;    lastOp = "NA";    lastCxid = -1;    lastZxid = -1;    lastResponseTime = 0;    lastLatency = 0;    count = 0;    totalLatency = 0;}
870e483827754a860c99d0554e3642999f07e85d0727f1e18185a93764c29464
incrPacketsReceived
protected long incrPacketsReceived()
{    return packetsReceived.incrementAndGet();}
fc89433ee1c2f3ba418922a7a68f86c459a1bedc6bf2df4f7ed7a6c3355e5d65
incrPacketsSent
protected long incrPacketsSent()
{    return packetsSent.incrementAndGet();}
925472c51f17f620f3fe4bbf25d6ef858a93cd42089561afa061a0ab9c7993b8
updateStatsForResponse
protected synchronized void updateStatsForResponse(long cxid, long zxid, String op, long start, long end)
{        if (cxid >= 0) {        lastCxid = cxid;    }    lastZxid = zxid;    lastOp = op;    lastResponseTime = end;    long elapsed = end - start;    lastLatency = elapsed;    if (elapsed < minLatency) {        minLatency = elapsed;    }    if (elapsed > maxLatency) {        maxLatency = elapsed;    }    count++;    totalLatency += elapsed;}
5ca5bb138730343c06cfd479da6662a2eaeb64e3c659f26a6cfb3f6ca9468f0f
getEstablished
public Date getEstablished()
{    return (Date) established.clone();}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return outstandingCount.longValue();}
5007fe9fa665c1fbd4284e8036ff281fdd652aceda522cc6df718948fa452aaf
getPacketsReceived
public long getPacketsReceived()
{    return packetsReceived.longValue();}
f229e1433c8ccf0fb3b2afe9022ffc0c9f054fffba05700a51a804fc4a51e991
getPacketsSent
public long getPacketsSent()
{    return packetsSent.longValue();}
baffa35867f8021da6bf3a923b3455aec1f25d8cafcfcf32c7ac7132bbe39ce4
getMinLatency
public synchronized long getMinLatency()
{    return minLatency == Long.MAX_VALUE ? 0 : minLatency;}
40c599a4de20f5a62d29cce33357c82170c911e876508d87ab3a6ca8357afa3f
getAvgLatency
public synchronized long getAvgLatency()
{    return count == 0 ? 0 : totalLatency / count;}
9ec17e2ddc1cf41979f73aa3592f851284df723b7ea4c735b8f610073f01c422
getMaxLatency
public synchronized long getMaxLatency()
{    return maxLatency;}
004c9adf2fb0f2d5328b9c037f40f801addea81ebbbb442162bc815f63399abb
getLastOperation
public synchronized String getLastOperation()
{    return lastOp;}
1269ec18aa6254ee698f3b1aaea95d59e444dfee6fe29d7fc06af0138f5937a7
getLastCxid
public synchronized long getLastCxid()
{    return lastCxid;}
39b32aca97b8075bacd366c60f11d21d4147f3b008c946aae8281e8fdbb8620e
getLastZxid
public synchronized long getLastZxid()
{    return lastZxid;}
463b487193d9e7a8609f2e7f3eb4357974fcefe2aa2c6df1a69bb76f57498fd0
getLastResponseTime
public synchronized long getLastResponseTime()
{    return lastResponseTime;}
0f3292dbaddc15eb18598932dfae30c15054e91083ce29aab16a2786fabb5db3
getLastLatency
public synchronized long getLastLatency()
{    return lastLatency;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpConnectionInfo(pwriter, false);    pwriter.flush();    pwriter.close();    return sw.toString();}
4597779e7bcc1455ddf215a80ccbc9c639bf91a23ca80cbbcd38aa182713642c
dumpConnectionInfo
public synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief)
{    pwriter.print(" ");    pwriter.print(getRemoteSocketAddress());    pwriter.print("[");    int interestOps = getInterestOps();    pwriter.print(interestOps == 0 ? "0" : Integer.toHexString(interestOps));    pwriter.print("](queued=");    pwriter.print(getOutstandingRequests());    pwriter.print(",recved=");    pwriter.print(getPacketsReceived());    pwriter.print(",sent=");    pwriter.print(getPacketsSent());    if (!brief) {        long sessionId = getSessionId();        if (sessionId != 0) {            pwriter.print(",sid=0x");            pwriter.print(Long.toHexString(sessionId));            pwriter.print(",lop=");            pwriter.print(getLastOperation());            pwriter.print(",est=");            pwriter.print(getEstablished().getTime());            pwriter.print(",to=");            pwriter.print(getSessionTimeout());            long lastCxid = getLastCxid();            if (lastCxid >= 0) {                pwriter.print(",lcxid=0x");                pwriter.print(Long.toHexString(lastCxid));            }            pwriter.print(",lzxid=0x");            pwriter.print(Long.toHexString(getLastZxid()));            pwriter.print(",lresp=");            pwriter.print(getLastResponseTime());            pwriter.print(",llat=");            pwriter.print(getLastLatency());            pwriter.print(",minlat=");            pwriter.print(getMinLatency());            pwriter.print(",avglat=");            pwriter.print(getAvgLatency());            pwriter.print(",maxlat=");            pwriter.print(getMaxLatency());        }    }    pwriter.print(")");}
5c1ab705cc5239538fa80283ce9ff2ba765f688576271f9b8f5253eb3b7f8d34
getConnectionInfo
public synchronized Map<String, Object> getConnectionInfo(boolean brief)
{    Map<String, Object> info = new LinkedHashMap<String, Object>();    info.put("remote_socket_address", getRemoteSocketAddress());    info.put("interest_ops", getInterestOps());    info.put("outstanding_requests", getOutstandingRequests());    info.put("packets_received", getPacketsReceived());    info.put("packets_sent", getPacketsSent());    if (!brief) {        info.put("session_id", getSessionId());        info.put("last_operation", getLastOperation());        info.put("established", getEstablished());        info.put("session_timeout", getSessionTimeout());        info.put("last_cxid", getLastCxid());        info.put("last_zxid", getLastZxid());        info.put("last_response_time", getLastResponseTime());        info.put("last_latency", getLastLatency());        info.put("min_latency", getMinLatency());        info.put("avg_latency", getAvgLatency());        info.put("max_latency", getMaxLatency());    }    return info;}
df186b5ed68979b497c7f07ee9d1aeb98b2f13fd66c87651d6603459a3515d21
cleanupWriterSocket
public void cleanupWriterSocket(PrintWriter pwriter)
{    try {        if (pwriter != null) {            pwriter.flush();            pwriter.close();        }    } catch (Exception e) {        LOG.info("Error closing PrintWriter ", e);    } finally {        try {            close(DisconnectReason.CLOSE_CONNECTION_COMMAND);        } catch (Exception e) {            LOG.error("Error closing a command socket ", e);        }    }}
e518f999d108d1bd6dc456ae9fda00c88465305e638003d96b895dad8bb24ea1
addSession
public void addSession(long sessionId, ServerCnxn cnxn)
{    sessionMap.put(sessionId, cnxn);}
4d6a1bfe632d153f58c8261361055323b198f223daca302364e52a62bbb52224
removeCnxnFromSessionMap
public void removeCnxnFromSessionMap(ServerCnxn cnxn)
{    long sessionId = cnxn.getSessionId();    if (sessionId != 0) {        sessionMap.remove(sessionId);    }}
f1e0156c1cca147486a7bbac7507dbeb5c0ebcd5299c0b712c2e22976e17c82b
closeSession
public boolean closeSession(long sessionId, ServerCnxn.DisconnectReason reason)
{    ServerCnxn cnxn = sessionMap.remove(sessionId);    if (cnxn != null) {        try {            cnxn.close(reason);        } catch (Exception e) {            LOG.warn("exception during session close", e);        }        return true;    }    return false;}
80f15d79a8f066a4ef679f0cbd2626c8f556717c0fc8117787226cdc8dc2a46b
getNumAliveConnections
public int getNumAliveConnections()
{    return cnxns.size();}
80e994108f023071d455617812e64d45cb04d73a5af0c845f4d76f399db6720f
getZooKeeperServer
public final ZooKeeperServer getZooKeeperServer()
{    return zkServer;}
ca9d137c3d49f3d1770918db2519c5490a641c91419ea2f709ba1f4c5f91e21b
configure
public void configure(InetSocketAddress addr, int maxcc) throws IOException
{    configure(addr, maxcc, -1);}
95d4575b1dc6b949414ae952c8b486fe9967b2d03c177c3a8386770db53598ba
configure
public void configure(InetSocketAddress addr, int maxcc, int backlog) throws IOException
{    configure(addr, maxcc, backlog, false);}
c6a8b35027b486f9efda96936274975b221803473bdc28c586ea3371f63c78bd
isSecure
public boolean isSecure()
{    return secure;}
01dd6a886658e848996b6ed1767596709cb6a1d15a5d0f30a0f7371d879a8b43
startup
public void startup(ZooKeeperServer zkServer) throws IOException, InterruptedException
{    startup(zkServer, true);}
6946552798adf565a52489ce32a6feef92b308e1fc85f525289120e0063a814e
setZooKeeperServer
public final void setZooKeeperServer(ZooKeeperServer zks)
{    this.zkServer = zks;    if (zks != null) {        if (secure) {            zks.setSecureServerCnxnFactory(this);        } else {            zks.setServerCnxnFactory(this);        }    }}
b4e7fdd6972b5968dea2446ea82016c17b770c03f9a7f8179fd09d8adeb8b5b0
createFactory
public static ServerCnxnFactory createFactory() throws IOException
{    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);    if (serverCnxnFactoryName == null) {        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();    }    try {        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();        LOG.info("Using {} as server connection factory", serverCnxnFactoryName);        return serverCnxnFactory;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + serverCnxnFactoryName, e);        throw ioe;    }}
0691720fd118b926e9d413f7c71bc5fcbf49ac724f1856fbe350972714b212b7
createFactory
public static ServerCnxnFactory createFactory(int clientPort, int maxClientCnxns) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, -1);}
7980f39dd5eed3631cd5288aefcc27d9c5ee88c620c8c5f49a0140937548e559
createFactory
public static ServerCnxnFactory createFactory(int clientPort, int maxClientCnxns, int backlog) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, backlog);}
6a159cf1cc3d1f5b13588529b0318d8cbfba11a3101565b0075879c3e9b39829
createFactory
public static ServerCnxnFactory createFactory(InetSocketAddress addr, int maxClientCnxns) throws IOException
{    return createFactory(addr, maxClientCnxns, -1);}
f13bfdf9ce2fff3ce6950d5c0efede3def5c21fb578bd16b8d232b714bd2320d
createFactory
public static ServerCnxnFactory createFactory(InetSocketAddress addr, int maxClientCnxns, int backlog) throws IOException
{    ServerCnxnFactory factory = createFactory();    factory.configure(addr, maxClientCnxns, backlog);    return factory;}
24ee17b3982541cd3800f2cf3c8207d309b1cb59874acfbc073dbcc8fee31183
unregisterConnection
public void unregisterConnection(ServerCnxn serverCnxn)
{    ConnectionBean jmxConnectionBean = connectionBeans.remove(serverCnxn);    if (jmxConnectionBean != null) {        MBeanRegistry.getInstance().unregister(jmxConnectionBean);    }}
0cbf1a5d8c9dd553612324a513a7c032522f39becb4ba33764949e3cf67af2ca
registerConnection
public void registerConnection(ServerCnxn serverCnxn)
{    if (zkServer != null) {        ConnectionBean jmxConnectionBean = new ConnectionBean(serverCnxn, zkServer);        try {            MBeanRegistry.getInstance().register(jmxConnectionBean, zkServer.jmxServerBean);            connectionBeans.put(serverCnxn, jmxConnectionBean);        } catch (JMException e) {            LOG.warn("Could not register connection", e);        }    }}
db218aa54afcc70397a5a90b189537893f498558e0a979f7e99e804fae185306
configureSaslLogin
protected void configureSaslLogin() throws IOException
{    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);        AppConfigurationEntry[] entries = null;    SecurityException securityException = null;    try {        entries = Configuration.getConfiguration().getAppConfigurationEntry(serverSection);    } catch (SecurityException e) {                securityException = e;    }        if (entries == null) {        String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);        String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);        if (securityException != null && (loginContextName != null || jaasFile != null)) {            String errorMessage = "No JAAS configuration section named '" + serverSection + "' was found";            if (jaasFile != null) {                errorMessage += " in '" + jaasFile + "'.";            }            if (loginContextName != null) {                errorMessage += " But " + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + " was set.";            }            LOG.error(errorMessage);            throw new IOException(errorMessage);        }        return;    }        try {        saslServerCallbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration());        login = new Login(serverSection, saslServerCallbackHandler, new ZKConfig());        login.startThreadIfNeeded();    } catch (LoginException e) {        throw new IOException("Could not configure server because SASL configuration did not allow the " + " ZooKeeper server to authenticate itself properly: " + e);    }}
04887a387e8c113be00a6b0a0c68179c9b8d0fc5ab2d0555199e0a923e17bf7b
parse
public void parse(String[] args)
{    if (args.length < 2 || args.length > 4) {        throw new IllegalArgumentException("Invalid number of arguments:" + Arrays.toString(args));    }    clientPortAddress = new InetSocketAddress(Integer.parseInt(args[0]));    dataDir = new File(args[1]);    dataLogDir = dataDir;    if (args.length >= 3) {        tickTime = Integer.parseInt(args[2]);    }    if (args.length == 4) {        maxClientCnxns = Integer.parseInt(args[3]);    }}
d871f9e5eaf3c5a27e645f9aa8ab6ea190b83d8a54e3cc7b7e3a5d0f2f6886bf
parse
public void parse(String path) throws ConfigException
{    QuorumPeerConfig config = new QuorumPeerConfig();    config.parse(path);            readFrom(config);}
48306d8f44550726de3c71b9171002035c42e5d50760f98510a669f32c0841f5
readFrom
public void readFrom(QuorumPeerConfig config)
{    clientPortAddress = config.getClientPortAddress();    secureClientPortAddress = config.getSecureClientPortAddress();    dataDir = config.getDataDir();    dataLogDir = config.getDataLogDir();    tickTime = config.getTickTime();    maxClientCnxns = config.getMaxClientCnxns();    minSessionTimeout = config.getMinSessionTimeout();    maxSessionTimeout = config.getMaxSessionTimeout();    jvmPauseMonitorToRun = config.isJvmPauseMonitorToRun();    jvmPauseInfoThresholdMs = config.getJvmPauseInfoThresholdMs();    jvmPauseWarnThresholdMs = config.getJvmPauseWarnThresholdMs();    jvmPauseSleepTimeMs = config.getJvmPauseSleepTimeMs();    metricsProviderClassName = config.getMetricsProviderClassName();    metricsProviderConfiguration = config.getMetricsProviderConfiguration();    listenBacklog = config.getClientPortListenBacklog();    initialConfig = config.getInitialConfig();}
3e89e35e73b5019caeb3463b6d2aba6ad29be8bb78a5a30f23942b0f2012f47a
getClientPortAddress
public InetSocketAddress getClientPortAddress()
{    return clientPortAddress;}
db6c3e811fb6600184102e53dce5a387450abd2972e323d4aa2603f5b0de6943
getSecureClientPortAddress
public InetSocketAddress getSecureClientPortAddress()
{    return secureClientPortAddress;}
260452c67ee229efb360439b03779c159761f631bb6945711988d544e37e5140
getDataDir
public File getDataDir()
{    return dataDir;}
2742bb58bdbfe1b66b2740996b6a766693e7057cb8802d4843c4e85eb1d5f32a
getDataLogDir
public File getDataLogDir()
{    return dataLogDir;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
e1bdc6adf813fb8e32ea311d72e069682199fd33de94a8a2e7ac4918c58a4ffc
getMaxClientCnxns
public int getMaxClientCnxns()
{    return maxClientCnxns;}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return minSessionTimeout;}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
cf3b67d26a57e8c59e67188a67ca79f74a07ab45c0b1c529d5270384283f8a1d
getJvmPauseInfoThresholdMs
public long getJvmPauseInfoThresholdMs()
{    return jvmPauseInfoThresholdMs;}
eb92c8dfcd46287551baec3b86da941516c5fd82ed53aced6f8f216c66c33e01
getJvmPauseWarnThresholdMs
public long getJvmPauseWarnThresholdMs()
{    return jvmPauseWarnThresholdMs;}
a0afdea06220ce3dfe60b9d58e941246a4af86d48e5c41c73b36f8a5a7aaa9c3
getJvmPauseSleepTimeMs
public long getJvmPauseSleepTimeMs()
{    return jvmPauseSleepTimeMs;}
effd036aed2c64c4c04857d80791bfc965ae4a392af4b58f56f0a0f6247e14aa
isJvmPauseMonitorToRun
public boolean isJvmPauseMonitorToRun()
{    return jvmPauseMonitorToRun;}
78645ceb9553427481798fe5b5b5d3a3b940a4834c282352e6b2d087d02c3939
getMetricsProviderClassName
public String getMetricsProviderClassName()
{    return metricsProviderClassName;}
966b66646d5c92e9f08fc81a691835a66271312657c3a36a6672404a19a1a6ba
getMetricsProviderConfiguration
public Properties getMetricsProviderConfiguration()
{    return metricsProviderConfiguration;}
ec5585a4b2b943741ce33cf2955fc89a6570f314127c8e967a69575e8e422e3e
getClientPortListenBacklog
public int getClientPortListenBacklog()
{    return listenBacklog;}
0869b4ebc140f14318347c5fe780683c1257020242ac624a158461ae7ed8f1f1
getMetrics
public static ServerMetrics getMetrics()
{    return CURRENT;}
30ed1169547911446d7fa9b647bfd526492efec2cf03b3224cf36072825aa490
metricsProviderInitialized
public static void metricsProviderInitialized(MetricsProvider metricsProvider)
{    LOG.info("ServerMetrics initialized with provider {}", metricsProvider);    CURRENT = new ServerMetrics(metricsProvider);}
8cde9904854cc37288c9e6f6dd9f08808af6f83fd6d04e746538114a9109004d
resetAll
public void resetAll()
{    metricsProvider.resetAllValues();}
9ca406c258070d4389fe3fd8f1d3be1bcd13fceca6d544639fd01f8dfc9c3c00
getMetricsProvider
public MetricsProvider getMetricsProvider()
{    return metricsProvider;}
34375a630b3741ec40c881f400e7257692930e1d1b025f8088be26ad73c23e78
getMinLatency
public long getMinLatency()
{    return requestLatency.getMin();}
4263da0ad1e7c552a442a0524abce25cf003bfb7d62f687ba29d495d7149fce2
getAvgLatency
public double getAvgLatency()
{    return requestLatency.getAvg();}
6e26ca4f63bcab4e0df4b6b5a7dfd7ec997606516fc50a325ae2b73d4b05496b
getMaxLatency
public long getMaxLatency()
{    return requestLatency.getMax();}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return provider.getOutstandingRequests();}
3b45c36fc47228f08f8ac1b7a127fa815ed079670744c1959d60562db117f92f
getLastProcessedZxid
public long getLastProcessedZxid()
{    return provider.getLastProcessedZxid();}
2102436c089af84b36f2055f79a3cac5070b818c7f99cf63cf921d97372f4976
getDataDirSize
public long getDataDirSize()
{    return provider.getDataDirSize();}
2e8fdfde7e62021bb8781d1d5aab02c1ce9d03211ba77b88e884724264074cdc
getLogDirSize
public long getLogDirSize()
{    return provider.getLogDirSize();}
5007fe9fa665c1fbd4284e8036ff281fdd652aceda522cc6df718948fa452aaf
getPacketsReceived
public long getPacketsReceived()
{    return packetsReceived.get();}
f229e1433c8ccf0fb3b2afe9022ffc0c9f054fffba05700a51a804fc4a51e991
getPacketsSent
public long getPacketsSent()
{    return packetsSent.get();}
37bd970c873b1caba1f416cd3451f9136748408cb1498857ffad8d8312e41b1f
getServerState
public String getServerState()
{    return provider.getState();}
114f2eaf5dc6f4df9dca9dd0542ecab803bc9d9377d835dd711b06e7b24ab918
getNumAliveClientConnections
public int getNumAliveClientConnections()
{    return provider.getNumAliveConnections();}
5d0ba75a6b8eae682c0c19de1919b94078bcaeb61093a692fb66268a58d6351f
getUptime
public long getUptime()
{    return Time.currentElapsedTime() - startTime;}
e94f8faccdf318bd6e84e89c6f789ec7d6024b3f9d722b600ca833bee1f96121
isProviderNull
public boolean isProviderNull()
{    return provider == null;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("Latency min/avg/max: " + getMinLatency() + "/" + getAvgLatency() + "/" + getMaxLatency() + "\n");    sb.append("Received: " + getPacketsReceived() + "\n");    sb.append("Sent: " + getPacketsSent() + "\n");    sb.append("Connections: " + getNumAliveClientConnections() + "\n");    if (provider != null) {        sb.append("Outstanding: " + getOutstandingRequests() + "\n");        sb.append("Zxid: 0x" + Long.toHexString(getLastProcessedZxid()) + "\n");    }    sb.append("Mode: " + getServerState() + "\n");    return sb.toString();}
5e1d93bb2d81590acb5242bd0416d10aff8cbf2e4a86c05a284ba4fd66ba10d3
updateLatency
public void updateLatency(Request request, long currentTime)
{    long latency = currentTime - request.createTime;    if (latency < 0) {        return;    }    requestLatency.addDataPoint(latency);    if (request.getHdr() != null) {                ServerMetrics.getMetrics().UPDATE_LATENCY.add(latency);    } else {                ServerMetrics.getMetrics().READ_LATENCY.add(latency);    }}
220d745649fe257794b6f899ab9cc70731b4c48c9d10b8379e39c0f6e3960889
resetLatency
public void resetLatency()
{    requestLatency.reset();}
7ba1bb1b210f1e5f6f987b260596adcd0523b72e7c41da7465040dca07f4841e
resetMaxLatency
public void resetMaxLatency()
{    requestLatency.resetMax();}
363cc85b00ca024d4f4dc94dd2c2c446a9667ee4ba223eb44a9b8ef55d7880f3
incrementPacketsReceived
public void incrementPacketsReceived()
{    packetsReceived.incrementAndGet();}
aa56e6958cd62729e7e153fb782cc227e83794e773dddb83a79bab7384467f4f
incrementPacketsSent
public void incrementPacketsSent()
{    packetsSent.incrementAndGet();}
2737e173901c63e1804d8f7c16d5c14f63c5cf0d8135ab333ec6dfbcd6ac4e2c
resetRequestCounters
public void resetRequestCounters()
{    packetsReceived.set(0);    packetsSent.set(0);}
648ac8732eb852abc6cc5e6a074e66b24c7f36be4b74b323b5ed30148ed8fd7b
getFsyncThresholdExceedCount
public long getFsyncThresholdExceedCount()
{    return fsyncThresholdExceedCount.get();}
5e02f47d798231936ab4e644bdf3bf31483e5f320681add1644ed6ce72db257f
incrementFsyncThresholdExceedCount
public void incrementFsyncThresholdExceedCount()
{    fsyncThresholdExceedCount.incrementAndGet();}
09137450428aca2f526bae76ca6e96b23f99f76f3015dcd9e02d342b8dc08d64
resetFsyncThresholdExceedCount
public void resetFsyncThresholdExceedCount()
{    fsyncThresholdExceedCount.set(0);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    resetLatency();    resetRequestCounters();    clientResponseStats.reset();    ServerMetrics.getMetrics().resetAll();}
85fe8909f9eafdfa2da6d89a0fd01abab4efa7051a1d0d2666db43c7cb93a833
updateClientResponseSize
public void updateClientResponseSize(int size)
{    clientResponseStats.setLastBufferSize(size);}
cb35130d3e0c6e2486ce998debc105d2b99ea45ab47e1e759dfb9fe90569f793
getClientResponseStats
public BufferStats getClientResponseStats()
{    return clientResponseStats;}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return sessionId;}
2c9177cd8b47bdfcc60afb6594715b20a3d24726d258bdf44bfb0787f6856413
getTimeout
public int getTimeout()
{    return timeout;}
fe2c623932c28d566901164eb4d60a5e45844197e66261a8841a32a27ab407e4
isClosing
public boolean isClosing()
{    return isClosing;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "0x" + Long.toHexString(sessionId);}
433184b95fc3c5e6afcdbd7a7cacfc5df33dd6694f25c036c5d95ea33490ad13
initializeNextSessionId
public static long initializeNextSessionId(long id)
{    long nextSid;    nextSid = (Time.currentElapsedTime() << 24) >>> 8;    nextSid = nextSid | (id << 56);    if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {                ++nextSid;    }    return nextSid;}
059bdb7fdfcd8a7cc5ac1afcbadf7c985185ac6be02df299e669a9effa7195ce
dumpSessions
public void dumpSessions(PrintWriter pwriter)
{    pwriter.print("Session ");    sessionExpiryQueue.dump(pwriter);}
23e8d274e791198c1496b38af0baf25af6c73905198060fedf7ffea25e59bb99
getSessionExpiryMap
public synchronized Map<Long, Set<Long>> getSessionExpiryMap()
{        Map<Long, Set<SessionImpl>> expiryMap = sessionExpiryQueue.getExpiryMap();    Map<Long, Set<Long>> sessionExpiryMap = new TreeMap<Long, Set<Long>>();    for (Entry<Long, Set<SessionImpl>> e : expiryMap.entrySet()) {        Set<Long> ids = new HashSet<Long>();        sessionExpiryMap.put(e.getKey(), ids);        for (SessionImpl s : e.getValue()) {            ids.add(s.sessionId);        }    }    return sessionExpiryMap;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpSessions(pwriter);    pwriter.flush();    pwriter.close();    return sw.toString();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (running) {            long waitTime = sessionExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (SessionImpl s : sessionExpiryQueue.poll()) {                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(1);                setSessionClosing(s.sessionId);                expirer.expire(s);            }        }    } catch (InterruptedException e) {        handleException(this.getName(), e);    }    LOG.info("SessionTrackerImpl exited loop!");}
3f9ed99ee0c60ae5ab2a4b2adf1f9d3d17d948a298eeab5f42b2452215188504
touchSession
public synchronized boolean touchSession(long sessionId, int timeout)
{    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        logTraceTouchInvalidSession(sessionId, timeout);        return false;    }    if (s.isClosing()) {        logTraceTouchClosingSession(sessionId, timeout);        return false;    }    updateSessionExpiry(s, timeout);    return true;}
ed07d52d2c00cb4a4ef87b162d7f6b42070432b2f507b369fe6469cadbf67286
updateSessionExpiry
private void updateSessionExpiry(SessionImpl s, int timeout)
{    logTraceTouchSession(s.sessionId, timeout, "");    sessionExpiryQueue.update(s, timeout);}
3667d8c6e753bddaa9e2501fa10f8200770334971fe1dd6960ca7ef6e2b26b90
logTraceTouchSession
private void logTraceTouchSession(long sessionId, int timeout, String sessionStatus)
{    if (!LOG.isTraceEnabled()) {        return;    }    String msg = MessageFormat.format("SessionTrackerImpl --- Touch {0}session: 0x{1} with timeout {2}", sessionStatus, Long.toHexString(sessionId), Integer.toString(timeout));    ZooTrace.logTraceMessage(LOG, ZooTrace.CLIENT_PING_TRACE_MASK, msg);}
08ab41be94113ccbe241af8a424ecae8948393ed92041ab05f49be029b102e5b
logTraceTouchInvalidSession
private void logTraceTouchInvalidSession(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "invalid ");}
19293c4ba23d43a7f7ad842e7d988b0620881ed29c69e9ab3a949f90383f5dc1
logTraceTouchClosingSession
private void logTraceTouchClosingSession(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "closing ");}
b5665ccd2cfe06eb8d4ad7bc5a8f1784db74c3548a0a5b83c35a6e81e837a015
getSessionTimeout
public int getSessionTimeout(long sessionId)
{    return sessionsWithTimeout.get(sessionId);}
024b505dec92824d17c260c8ef944f577872294c37d2d7af375103eadcb70f13
setSessionClosing
public synchronized void setSessionClosing(long sessionId)
{    if (LOG.isTraceEnabled()) {        LOG.trace("Session closing: 0x" + Long.toHexString(sessionId));    }    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        return;    }    s.isClosing = true;}
9f8d197dad5982629b516b0d9847752bcd02164faccff1490a9538551314b490
removeSession
public synchronized void removeSession(long sessionId)
{    if (LOG.isDebugEnabled()) {        LOG.debug("Removing session 0x{}", Long.toHexString(sessionId));    }    SessionImpl s = sessionsById.remove(sessionId);    sessionsWithTimeout.remove(sessionId);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- Removing session 0x" + Long.toHexString(sessionId));    }    if (s != null) {        sessionExpiryQueue.remove(s);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    running = false;    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "Shutdown SessionTrackerImpl!");    }}
26a20a147958953e3c25a582180e937ad56ac181b2ec844d0de659c5027d7c8a
createSession
public long createSession(int sessionTimeout)
{    long sessionId = nextSessionId.getAndIncrement();    trackSession(sessionId, sessionTimeout);    return sessionId;}
b621e65348df38713fa179cfc34276afcd03ea62dc65c6004f64704decf29664
trackSession
public synchronized boolean trackSession(long id, int sessionTimeout)
{    boolean added = false;    SessionImpl session = sessionsById.get(id);    if (session == null) {        session = new SessionImpl(id, sessionTimeout);    }            SessionImpl existedSession = sessionsById.putIfAbsent(id, session);    if (existedSession != null) {        session = existedSession;    } else {        added = true;        if (LOG.isDebugEnabled()) {            LOG.debug("Adding session 0x{}", Long.toHexString(id));        }    }    if (LOG.isTraceEnabled()) {        String actionStr = added ? "Adding" : "Existing";        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- " + actionStr + " session 0x" + Long.toHexString(id) + " " + sessionTimeout);    }    updateSessionExpiry(session, sessionTimeout);    return added;}
b1693c7ffe372cc122b692885bb98245c8db98703c1805cff59844e53fff5c21
commitSession
public synchronized boolean commitSession(long id, int sessionTimeout)
{    return sessionsWithTimeout.put(id, sessionTimeout) == null;}
b73bf7e716f61557372d976521bc74ae2335362f0749028510f86154f816787c
isTrackingSession
public boolean isTrackingSession(long sessionId)
{    return sessionsById.containsKey(sessionId);}
24a9da24dc3f4ead755d8caf5c995fa7756e2e7c6846e4c1e50d6c4ba4e1cbf6
checkSession
public synchronized void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException
{    if (LOG.isDebugEnabled()) {        LOG.debug("Checking session 0x" + Long.toHexString(sessionId));    }    SessionImpl session = sessionsById.get(sessionId);    if (session == null) {        throw new KeeperException.UnknownSessionException();    }    if (session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    if (session.owner == null) {        session.owner = owner;    } else if (session.owner != owner) {        throw new KeeperException.SessionMovedException();    }}
3738dc246c8b12559c141968f54a3f00ee21d433ca12d0319dcc4a888f8de786
setOwner
public synchronized void setOwner(long id, Object owner) throws SessionExpiredException
{    SessionImpl session = sessionsById.get(id);    if (session == null || session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    session.owner = owner;}
499e3a44e2100043165524b1d156803435958d31737f80bf86cb5159f62ee7ed
checkGlobalSession
public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    try {        checkSession(sessionId, owner);    } catch (KeeperException.UnknownSessionException e) {        throw new KeeperException.SessionExpiredException();    }}
a4ad0e6cfe447eb5c45c50b13ef0390e9b8a8491f5fcba889908b4f506465171
getLocalSessionCount
public long getLocalSessionCount()
{    return 0;}
3b7c1330fc3efc999615334279ed2539d3495c17199f15a2cd557ca4c775c546
isLocalSessionsEnabled
public boolean isLocalSessionsEnabled()
{    return false;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String snapshotFile = null;    boolean dumpData = false;    boolean dumpJson = false;    int i;    for (i = 0; i < args.length; i++) {        if (args[i].equals("-d")) {            dumpData = true;        } else if (args[i].equals("-json")) {            dumpJson = true;        } else {            snapshotFile = args[i];            i++;            break;        }    }    if (args.length != i || snapshotFile == null) {        System.err.println("USAGE: SnapshotFormatter [-d|-json] snapshot_file");        System.err.println("       -d dump the data for each znode");        System.err.println("       -json dump znode info in json format");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(snapshotFile);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    if (dumpData && dumpJson) {        System.err.println("Cannot specify both data dump (-d) and json mode (-json) in same call");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new SnapshotFormatter().run(snapshotFile, dumpData, dumpJson);}
f3537cad9a0032e6c1279d02e3c38ca217de51c38f2e0c2e1528b3e18030f0f0
run
public void run(String snapshotFileName, boolean dumpData, boolean dumpJson) throws IOException
{    File snapshotFile = new File(snapshotFileName);    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {        InputArchive ia = BinaryInputArchive.getArchive(is);        FileSnap fileSnap = new FileSnap(null);        DataTree dataTree = new DataTree();        Map<Long, Integer> sessions = new HashMap<Long, Integer>();        fileSnap.deserialize(dataTree, sessions, ia);        long fileNameZxid = Util.getZxidFromName(snapshotFile.getName(), SNAPSHOT_FILE_PREFIX);        if (dumpJson) {            printSnapshotJson(dataTree);        } else {            printDetails(dataTree, sessions, dumpData, fileNameZxid);        }    }}
46275d96042020102110bee8195d8b44447f16db5403ae7bfa25063400a7ae58
printDetails
private void printDetails(DataTree dataTree, Map<Long, Integer> sessions, boolean dumpData, long fileNameZxid)
{    long dtZxid = printZnodeDetails(dataTree, dumpData);    printSessionDetails(dataTree, sessions);    System.out.println(String.format("----%nLast zxid: 0x%s", Long.toHexString(Math.max(fileNameZxid, dtZxid))));}
c763bf5896d68d6108cd9ddb3efc58924e042a6bd356828bb539c2d6dd40c022
printZnodeDetails
private long printZnodeDetails(DataTree dataTree, boolean dumpData)
{    System.out.println(String.format("ZNode Details (count=%d):", dataTree.getNodeCount()));    final long zxid = printZnode(dataTree, "/", dumpData);    System.out.println("----");    return zxid;}
24801c26260c4b18f433011685d65d9a5d1fa995218620d5db5a16afc2fbbdb1
printZnode
private long printZnode(DataTree dataTree, String name, boolean dumpData)
{    System.out.println("----");    DataNode n = dataTree.getNode(name);    Set<String> children;    long zxid;    synchronized (n) {                System.out.println(name);        printStat(n.stat);        zxid = Math.max(n.stat.getMzxid(), n.stat.getPzxid());        if (dumpData) {            System.out.println("  data = " + (n.data == null ? "" : Base64.getEncoder().encodeToString(n.data)));        } else {            System.out.println("  dataLength = " + (n.data == null ? 0 : n.data.length));        }        children = n.getChildren();    }    if (children != null) {        for (String child : children) {            long cxid = printZnode(dataTree, name + (name.equals("/") ? "" : "/") + child, dumpData);            zxid = Math.max(zxid, cxid);        }    }    return zxid;}
ab977bb2b719e8caf22fb750c429795f3d546167c7750c6c5478cc6bddbb71ad
printSessionDetails
private void printSessionDetails(DataTree dataTree, Map<Long, Integer> sessions)
{    System.out.println("Session Details (sid, timeout, ephemeralCount):");    for (Map.Entry<Long, Integer> e : sessions.entrySet()) {        long sid = e.getKey();        System.out.println(String.format("%#016x, %d, %d", sid, e.getValue(), dataTree.getEphemerals(sid).size()));    }}
8a59881a2ec95cce0331d416a395a2a32d4931928117b269d9180b5d749c5354
printStat
private void printStat(StatPersisted stat)
{    printHex("cZxid", stat.getCzxid());    System.out.println("  ctime = " + new Date(stat.getCtime()).toString());    printHex("mZxid", stat.getMzxid());    System.out.println("  mtime = " + new Date(stat.getMtime()).toString());    printHex("pZxid", stat.getPzxid());    System.out.println("  cversion = " + stat.getCversion());    System.out.println("  dataVersion = " + stat.getVersion());    System.out.println("  aclVersion = " + stat.getAversion());    printHex("ephemeralOwner", stat.getEphemeralOwner());}
0f8e4137abf0eaee55130ce3c249cf096827a6b370a92f7148a20b321d6545cd
printHex
private void printHex(String prefix, long value)
{    System.out.println(String.format("  %s = %#016x", prefix, value));}
0d305ce11ad0c568cf2471780641c274129059e297c26221735bf7a916a03211
printSnapshotJson
private void printSnapshotJson(final DataTree dataTree)
{    System.out.printf("[1,0,{\"progname\":\"SnapshotFormatter.java\",\"progver\":\"0.01\",\"timestamp\":%d}", System.currentTimeMillis());    printZnodeJson(dataTree, "/");    System.out.print("]");}
c5372e31da60848305fb28eadc6ef5f53c6bb58c3d263289aa4d8922e66f8d1b
printZnodeJson
private void printZnodeJson(final DataTree dataTree, final String fullPath)
{    final DataNode n = dataTree.getNode(fullPath);    if (null == n) {        System.err.println("DataTree Node for " + fullPath + " doesn't exist");        return;    }    final String name = fullPath.equals("/") ? fullPath : fullPath.substring(fullPath.lastIndexOf("/") + 1);    System.out.print(",");    int dataLen;    synchronized (n) {                dataLen = (n.data == null) ? 0 : n.data.length;    }    StringBuilder nodeSB = new StringBuilder();    nodeSB.append("{");    nodeSB.append("\"name\":\"").append(JSONValue.escape(name)).append("\"").append(",");    nodeSB.append("\"asize\":").append(dataLen).append(",");    nodeSB.append("\"dsize\":").append(dataLen).append(",");    nodeSB.append("\"dev\":").append(0).append(",");    nodeSB.append("\"ino\":").append(++INODE_IDX);    nodeSB.append("}");    Set<String> children;    synchronized (n) {                children = n.getChildren();    }    if (children != null && children.size() > 0) {        System.out.print("[" + nodeSB);        for (String child : children) {            printZnodeJson(dataTree, fullPath + (fullPath.equals("/") ? "" : "/") + child);        }        System.out.print("]");    } else {        System.out.print(nodeSB);    }}
d031e1d23f780c5799a0f5fbadd563a4ece0adbc8870f05c92561c21a02ac6a2
setSnapCount
public static void setSnapCount(int count)
{    snapCount = count;}
61e5bc73f45a2f417912ea605be3c6d3d3f9e219104fbf0693c9366bfe9d1e63
getSnapCount
public static int getSnapCount()
{    return snapCount;}
c8c4e44e29b6ccbd12ac0edecd2d1fdb07a4d72cefd44b2af1c9f4b6f44b8d9d
getRemainingDelay
private long getRemainingDelay()
{    long flushDelay = zks.getFlushDelay();    long duration = Time.currentElapsedTime() - lastFlushTime;    if (duration < flushDelay) {        return flushDelay - duration;    }    return 0;}
da8d3a4c0c5f7a711fdf36c1bfe4bbc75768f2f59f92bd9110a0d8ef72ca1b80
shouldFlush
private boolean shouldFlush()
{    long flushDelay = zks.getFlushDelay();    long maxBatchSize = zks.getMaxBatchSize();    if ((flushDelay > 0) && (getRemainingDelay() == 0)) {        return true;    }    return (maxBatchSize > 0) && (toFlush.size() >= maxBatchSize);}
3c41f64512d4fb160ef39a7253c5ef54ca79e4c67e656260029af7d63a23de73
setSnapSizeInBytes
public static void setSnapSizeInBytes(long size)
{    snapSizeInBytes = size;}
9818ed04912e15e9d5678a840d769be60b9fcf3b09f9635772627cdbeed29f5f
shouldSnapshot
private boolean shouldSnapshot()
{    int logCount = zks.getZKDatabase().getTxnCount();    long logSize = zks.getZKDatabase().getTxnSize();    return (logCount > (snapCount / 2 + randRoll)) || (snapSizeInBytes > 0 && logSize > (snapSizeInBytes / 2 + randSize));}
49a6cd67b3ca500cf4678e97a0af12590136a5f006a8275db6f3d00370c69e05
resetSnapshotStats
private void resetSnapshotStats()
{    randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2);    randSize = Math.abs(ThreadLocalRandom.current().nextLong() % (snapSizeInBytes / 2));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {                        resetSnapshotStats();        lastFlushTime = Time.currentElapsedTime();        while (true) {            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);            if (si == null) {                /* We timed out looking for more writes to batch, go ahead and flush immediately */                flush();                si = queuedRequests.take();            }            if (si == REQUEST_OF_DEATH) {                break;            }            long startProcessTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);                        if (zks.getZKDatabase().append(si)) {                if (shouldSnapshot()) {                    resetSnapshotStats();                                        zks.getZKDatabase().rollLog();                                        if (!snapThreadMutex.tryAcquire()) {                        LOG.warn("Too busy to snap, skipping");                    } else {                        new ZooKeeperThread("Snapshot Thread") {                            public void run() {                                try {                                    zks.takeSnapshot();                                } catch (Exception e) {                                    LOG.warn("Unexpected exception", e);                                } finally {                                    snapThreadMutex.release();                                }                            }                        }.start();                    }                }            } else if (toFlush.isEmpty()) {                                if (nextProcessor != null) {                    nextProcessor.processRequest(si);                    if (nextProcessor instanceof Flushable) {                        ((Flushable) nextProcessor).flush();                    }                }                continue;            }            toFlush.add(si);            if (shouldFlush()) {                flush();            }            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);        }    } catch (Throwable t) {        handleException(this.getName(), t);    }    LOG.info("SyncRequestProcessor exited!");}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        zks.takeSnapshot();    } catch (Exception e) {        LOG.warn("Unexpected exception", e);    } finally {        snapThreadMutex.release();    }}
dcffdbb61e5f099df831cd6bbf0f6394345d53f85c030cfae04c3f7adf57b9a1
flush
private void flush() throws IOException, RequestProcessorException
{    if (this.toFlush.isEmpty()) {        return;    }    ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());    long flushStartTime = Time.currentElapsedTime();    zks.getZKDatabase().commit();    ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);    if (this.nextProcessor == null) {        this.toFlush.clear();    } else {        while (!this.toFlush.isEmpty()) {            final Request i = this.toFlush.remove();            long latency = Time.currentElapsedTime() - i.syncQueueStartTime;            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);            this.nextProcessor.processRequest(i);        }        if (this.nextProcessor instanceof Flushable) {            ((Flushable) this.nextProcessor).flush();        }        lastFlushTime = Time.currentElapsedTime();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("Shutting down");    queuedRequests.add(REQUEST_OF_DEATH);    try {        this.join();        this.flush();    } catch (InterruptedException e) {        LOG.warn("Interrupted while wating for " + this + " to finish");        Thread.currentThread().interrupt();    } catch (IOException e) {        LOG.warn("Got IO exception during shutdown");    } catch (RequestProcessorException e) {        LOG.warn("Got request processor exception during shutdown");    }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
7815fd6d03c9214eec01ebdd3264cf92f8088a837c6b64fe128d2079c4c41c7b
processRequest
public void processRequest(final Request request)
{    Objects.requireNonNull(request, "Request cannot be null");    request.syncQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);    ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUED.add(1);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("USAGE: TraceFormatter trace_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileChannel fc = new FileInputStream(args[0]).getChannel();    while (true) {        ByteBuffer bb = ByteBuffer.allocate(41);        fc.read(bb);        bb.flip();        byte app = bb.get();        long time = bb.getLong();        long id = bb.getLong();        int cxid = bb.getInt();        long zxid = bb.getLong();        int txnType = bb.getInt();        int type = bb.getInt();        int len = bb.getInt();        bb = ByteBuffer.allocate(len);        fc.read(bb);        bb.flip();        String path = "n/a";        if (bb.remaining() > 0) {            if (type != OpCode.createSession) {                int pathLen = bb.getInt();                byte[] b = new byte[pathLen];                bb.get(b);                path = new String(b);            }        }        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(time)) + ": " + (char) app + " id=0x" + Long.toHexString(id) + " cxid=" + cxid + " op=" + Request.op2String(type) + " zxid=0x" + Long.toHexString(zxid) + " txnType=" + txnType + " len=" + len + " path=" + path);    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return hasNext;}
54fb432d64abdf976ecbd29f2dd63b0cbbe16adeab32d7377045ac292c7c89da
next
public Proposal next()
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    Proposal p = new Proposal();    try {        TxnHeader hdr = itr.getHeader();        Record txn = itr.getTxn();        hdr.serialize(boa, "hdr");        if (txn != null) {            txn.serialize(boa, "txn");        }        baos.close();        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, itr.getHeader().getZxid(), baos.toByteArray(), null);        p.packet = pp;        p.request = null;                hasNext = itr.next();    } catch (IOException e) {        LOG.error("Unable to read txnlog from disk", e);        hasNext = false;    }    return p;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {            LOG.warn("Error closing file iterator", ioe);        }    }}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    KeeperException ke = new KeeperException.UnimplementedException();    request.setException(ke);    ReplyHeader rh = new ReplyHeader(request.cxid, request.zxid, ke.code().intValue());    try {        request.cnxn.sendResponse(rh, null, "response");    } catch (IOException e) {        throw new RequestProcessorException("Can't send the response", e);    }    request.cnxn.sendCloseSession();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
264bf902dc89430c8cdf6a7045ccdd3a39fa0e12ef1acc22cc69b3f05f175f19
addDigest
public AdHash addDigest(long digest)
{    hash += digest;    return this;}
d28d7d8ed46e3c9eaee054c73a435c37b92041cb4640a3ecb71cb99249df7f66
removeDigest
public AdHash removeDigest(long digest)
{    hash -= digest;    return this;}
464a7771b5542df76cc6b84e7bf3686b1423c188ae43348943aa02daf883f631
toHexString
public String toHexString()
{    return Long.toHexString(hash);}
734e526e8d0dd07f3e6cb6fa8beb390ddfbc701c25f1e7375001b5fb3402ce46
getHash
public long getHash()
{    return hash;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other instanceof AdHash && ((AdHash) other).hash == this.hash;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Long.hashCode(hash);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toHexString();}
00457be353b4a5928894b303237f316d7acb34a7ae8247569b9b041037675549
add
public synchronized boolean add(Integer elementBit)
{    if (elementBit == null || elementBits.get(elementBit)) {        return false;    }    if (cache.size() < cacheSize) {        cache.add(elementBit);    }    elementBits.set(elementBit);    elementCount++;    return true;}
702161026c1750a0ef4cc44b5199a99fc92aaadce2b04a1f5695fbff9007f35e
remove
public synchronized int remove(Set<Integer> bitSet, BitSet bits)
{    cache.removeAll(bitSet);    elementBits.andNot(bits);    int elementCountBefore = elementCount;    elementCount = elementBits.cardinality();    return elementCountBefore - elementCount;}
38074d6d89b88009829455378ceafe16655d36070c9126c01508bbd888917a69
remove
public synchronized boolean remove(Integer elementBit)
{    if (elementBit == null || !elementBits.get(elementBit)) {        return false;    }    cache.remove(elementBit);    elementBits.clear(elementBit);    elementCount--;    return true;}
00f91a5b169d41159e03d19dd0d71daf023cc74da5908e4b0f0814270f590e09
contains
public synchronized boolean contains(Integer elementBit)
{    if (elementBit == null) {        return false;    }    return elementBits.get(elementBit);}
eaafb4eb5b18fb3b34f16a6b742f9b616dd9970c142c488a7f39a82bc83df423
size
public synchronized int size()
{    return elementCount;}
3ec56406f9eac8cd68db60597b4d0f526c60b3bcb3433afefad8b8fa144251d1
iterator
public Iterator<Integer> iterator()
{        int currentSize = size();    if (cache.size() == currentSize) {        return cache.iterator();    }    return new Iterator<Integer>() {        int returnedCount = 0;        int bitIndex = 0;        @Override        public boolean hasNext() {            return returnedCount < currentSize;        }        @Override        public Integer next() {            int bit = elementBits.nextSetBit(bitIndex);            bitIndex = bit + 1;            returnedCount++;            return bit;        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return returnedCount < currentSize;}
62aa5055032a3ec849f4ced6cdbcc5afb88113a67f44857872d466bfe1d63a41
next
public Integer next()
{    int bit = elementBits.nextSetBit(bitIndex);    bitIndex = bit + 1;    returnedCount++;    return bit;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
e0fcd661b57ad8a83893f6dbd13703342caf908487b49503be1832d38780499f
cachedSize
public synchronized int cachedSize()
{    return cache.size();}
adb58d40b016a239028cd0924c116b168a979132f4df0641afc1195eba76a2d0
isEmpty
public synchronized boolean isEmpty()
{    return elementCount == 0;}
b111b79b71f1b6117b1b0d206d0679c188a29fa48ce2959bc4c1dce6b6245be6
add
public Integer add(T value)
{    /*         * Optimized for code which will add the same value again and again,         * more specifically this is used to add new bit for watcher, and         * the same watcher may watching thousands or even millions of nodes,         * which will call add the same value of this function, check exist         * using read lock will optimize the performance here.         */    Integer bit = getBit(value);    if (bit != null) {        return bit;    }    rwLock.writeLock().lock();    try {        bit = value2Bit.get(value);        if (bit != null) {            return bit;        }        bit = freedBitSet.nextSetBit(0);        if (bit > -1) {            freedBitSet.clear(bit);        } else {            bit = nextBit++;        }        value2Bit.put(value, bit);        bit2Value.put(bit, value);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
66351f7d8a65802c4579f0942d347eab19a10ea870ff5018b78143afbc4fb91f
get
public T get(int bit)
{    rwLock.readLock().lock();    try {        return bit2Value.get(bit);    } finally {        rwLock.readLock().unlock();    }}
54d1f7f638a23772e5511813e7592d02139a88eb1d7dfa81a719c2f6c0e66340
getBit
public Integer getBit(T value)
{    rwLock.readLock().lock();    try {        return value2Bit.get(value);    } finally {        rwLock.readLock().unlock();    }}
837d6b398668c746779378ceefd96d4131299d41db11366fc34017a7cd76816d
remove
public int remove(T value)
{    /*         * remove only called once when the session is closed, so use write         * lock directly without checking read lock.         */    rwLock.writeLock().lock();    try {        Integer bit = value2Bit.get(value);        if (bit == null) {            return -1;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
7b4d3d62281e4e26fc919d004936635cbbdd84d022c55b7a88aeecf5f1b8e3f9
remove
public T remove(int bit)
{    rwLock.writeLock().lock();    try {        T value = bit2Value.get(bit);        if (value == null) {            return null;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return value;    } finally {        rwLock.writeLock().unlock();    }}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    rwLock.readLock().lock();    try {        return value2Bit.size();    } finally {        rwLock.readLock().unlock();    }}
92486da9f004ea244adf3fdc71b10f031cca2d73d61c65760df99f922dc6b3ed
write
public synchronized void write(T element)
{    int newSize = numberOfElements.incrementAndGet();    if (newSize > capacity) {        buffer[oldest] = element;        oldest = ++oldest % capacity;        numberOfElements.decrementAndGet();    } else {        int index = (oldest + numberOfElements.get() - 1) % capacity;        buffer[index] = element;    }}
6184efde15ceec00d39e2c35e5f902ce460912db386d3605355bd63969aff1de
take
public synchronized T take()
{    int newSize = numberOfElements.decrementAndGet();    if (newSize < 0) {        numberOfElements.incrementAndGet();        return null;    }    T polled = buffer[oldest];    oldest = ++oldest % capacity;    return polled;}
cf922a9ace99693b66dbc62edb7f4c3f109b40d95c363adcdaf736f12cb52e21
peek
public synchronized T peek()
{    if (numberOfElements.get() <= 0) {        return null;    }    return buffer[oldest];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return numberOfElements.get();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return numberOfElements.get() <= 0;}
f9250f7e93eb3e332b3a283988590da4bb96eedcb77601ca789df57a5a3031fe
isFull
public boolean isFull()
{    return numberOfElements.get() >= capacity;}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    numberOfElements.set(0);}
4b5fd17046352ba09a2acb16b618138ec606fcb999911a62ce9480f373ebc3a8
getClientConfigStr
public static String getClientConfigStr(String configData)
{    Properties props = new Properties();    try {        props.load(new StringReader(configData));    } catch (IOException e) {        e.printStackTrace();        return "";    }    StringBuffer sb = new StringBuffer();    boolean first = true;    String version = "";    for (Entry<Object, Object> entry : props.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("version")) {            version = value;        }        if (!key.startsWith("server.")) {            continue;        }        QuorumPeer.QuorumServer qs;        try {            qs = new QuorumPeer.QuorumServer(-1, value);        } catch (ConfigException e) {            e.printStackTrace();            continue;        }        if (!first) {            sb.append(",");        } else {            first = false;        }        if (null != qs.clientAddr) {            sb.append(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort());        }    }    return version + " " + sb.toString();}
752dc6b1b9b88274720b41ca99524a3a6f7619b1708b26309a523c9180736d52
getHostAndPort
public static String[] getHostAndPort(String s) throws ConfigException
{    if (s.startsWith("[")) {        int i = s.indexOf("]");        if (i < 0) {            throw new ConfigException(s + " starts with '[' but has no matching ']:'");        }        if (i + 2 == s.length()) {            throw new ConfigException(s + " doesn't have a port after colon");        }        if (i + 2 < s.length()) {            String[] sa = s.substring(i + 2).split(":");            String[] nsa = new String[sa.length + 1];            nsa[0] = s.substring(1, i);            System.arraycopy(sa, 0, nsa, 1, sa.length);            return nsa;        }        return new String[] { s.replaceAll("\\[|\\]", "") };    } else {        return s.split(":");    }}
bb302c4a318659c491831cc189779c37d93d3c2f7396ffbe411842aa224d2fe3
serviceStart
public void serviceStart()
{    monitorThread = new Thread(new JVMMonitor());    monitorThread.setDaemon(true);    monitorThread.start();}
7a090dca8301743a237cff444ffb0b0165c128006c23b56aad2bbed98f97baa0
serviceStop
public void serviceStop()
{    shouldRun = false;    if (monitorThread != null) {        monitorThread.interrupt();        try {            monitorThread.join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }}
5c30d636d0c8b1febcea468cf0149466c576f16ad782e77e5e7abb20b02a12ea
isStarted
public boolean isStarted()
{    return monitorThread != null;}
e8204cdcb39bde74a6af77178220b793fdb7dd386c3f6cc5f36241f94b533aa9
getNumGcWarnThresholdExceeded
public long getNumGcWarnThresholdExceeded()
{    return numGcWarnThresholdExceeded;}
def79e0ba0ae8f41c826ee521ae923dafd753009d6d9c742e751b1ef3c6c1e58
getNumGcInfoThresholdExceeded
public long getNumGcInfoThresholdExceeded()
{    return numGcInfoThresholdExceeded;}
4b236e3ceb4ba4271289632681d2cd508ce68697a834c2c8f2fce1033ff00b8c
getTotalGcExtraSleepTime
public long getTotalGcExtraSleepTime()
{    return totalGcExtraSleepTime;}
ba4eb94a9e28bb19cb66f89391846fe17fe3c8fef8044e9d1ed431185c64278e
formatMessage
private String formatMessage(long extraSleepTime, Map<String, GcTimes> gcTimesAfterSleep, Map<String, GcTimes> gcTimesBeforeSleep)
{    Set<String> gcBeanNames = new HashSet<>(gcTimesAfterSleep.keySet());    gcBeanNames.retainAll(gcTimesBeforeSleep.keySet());    List<String> gcDiffs = new ArrayList<>();    for (String name : gcBeanNames) {        GcTimes diff = gcTimesAfterSleep.get(name).subtract(gcTimesBeforeSleep.get(name));        if (diff.gcCount != 0) {            gcDiffs.add("GC pool '" + name + "' had collection(s): " + diff.toString());        }    }    String ret = String.format("Detected pause in JVM or host machine (eg GC): pause of approximately %d ms, " + "total pause: info level: %d, warn level: %d %n", extraSleepTime, numGcInfoThresholdExceeded, numGcWarnThresholdExceeded);    if (gcDiffs.isEmpty()) {        ret += ("No GCs detected");    } else {        ret += String.join("\n", gcDiffs);    }    return ret;}
b1d2bca4c8ce775d8d94caf71688971119adce8e06edacf71a70b116fefd1743
getGcTimes
private Map<String, GcTimes> getGcTimes()
{    Map<String, GcTimes> map = new HashMap<>();    List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();    for (GarbageCollectorMXBean gcBean : gcBeans) {        map.put(gcBean.getName(), new GcTimes(gcBean));    }    return map;}
fdd857d07182d85f992af619b3222e1468de0d5c77fb7b28900ff65e0fac996c
subtract
private GcTimes subtract(GcTimes other)
{    return new GcTimes(this.gcCount - other.gcCount, this.gcTimeMillis - other.gcTimeMillis);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "count=" + gcCount + " time=" + gcTimeMillis + "ms";}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Map<String, GcTimes> gcTimesBeforeSleep = getGcTimes();    LOG.info("Starting JVM Pause Monitor with infoThresholdMs:{} warnThresholdMs:{} and sleepTimeMs:{}", infoThresholdMs, warnThresholdMs, sleepTimeMs);    while (shouldRun) {        long startTime = Instant.now().toEpochMilli();        try {            Thread.sleep(sleepTimeMs);        } catch (InterruptedException ie) {            return;        }        long endTime = Instant.now().toEpochMilli();        long extraSleepTime = (endTime - startTime) - sleepTimeMs;        Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();        if (extraSleepTime > warnThresholdMs) {            ++numGcWarnThresholdExceeded;            LOG.warn(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));        } else if (extraSleepTime > infoThresholdMs) {            ++numGcInfoThresholdExceeded;            LOG.info(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));        }        totalGcExtraSleepTime += extraSleepTime;        gcTimesBeforeSleep = gcTimesAfterSleep;    }}
b37839a83280906223b5be1c8f4a540247458b6ed5658d58e558e4067085b407
getDefaultRealm
public static String getDefaultRealm() throws IllegalArgumentException
{    return new KerberosPrincipal("tmp", 1).getRealm();}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    ExitCode rc = ExitCode.INVALID_INVOCATION;    if (args.length != 3) {        System.out.println("Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename");        System.out.println("    this program will read the txn_log_to_chop file and copy all the transactions");        System.out.println("    from it up to (and including) the given zxid into chopped_filename.");        System.exit(rc.getValue());    }    String txnLog = args[1];    String choppedLog = args[2];    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLog));        OutputStream os = new BufferedOutputStream(new FileOutputStream(choppedLog))) {        long zxid = Long.decode(args[0]);        if (chop(is, os, zxid)) {            rc = ExitCode.EXECUTION_FINISHED;        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }    System.exit(rc.getValue());}
f973c64f2f5e8aff8f445d4cdaaf54be1dec115d864f432a27aba6966db65257
chop
public static boolean chop(InputStream is, OutputStream os, long zxid) throws IOException
{    BinaryInputArchive logStream = BinaryInputArchive.getArchive(is);    BinaryOutputArchive choppedStream = BinaryOutputArchive.getArchive(os);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number in txn log file");        return false;    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    fhdr.serialize(choppedStream, "fileheader");    int count = 0;    boolean hasZxid = false;    long previousZxid = -1;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");                        return false;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");                        return false;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        if (logStream.readByte("EOR") != 'B') {            System.out.println("Last transaction was partial.");            throw new EOFException("Last transaction was partial.");        }        final long txnZxid = hdr.getZxid();        if (txnZxid == zxid) {            hasZxid = true;        }                if (previousZxid != -1 && txnZxid != previousZxid + 1) {            long txnEpoch = ZxidUtils.getEpochFromZxid(txnZxid);            long txnCounter = ZxidUtils.getCounterFromZxid(txnZxid);            long previousEpoch = ZxidUtils.getEpochFromZxid(previousZxid);            if (txnEpoch == previousEpoch) {                System.out.println(String.format("There is intra-epoch gap between %x and %x", previousZxid, txnZxid));            } else if (txnCounter != 1) {                System.out.println(String.format("There is inter-epoch gap between %x and %x", previousZxid, txnZxid));            }        }        previousZxid = txnZxid;        if (txnZxid > zxid) {            if (count == 0 || !hasZxid) {                System.out.println(String.format("This log does not contain zxid %x", zxid));                return false;            }            System.out.println(String.format("Chopping at %x new log has %d records", zxid, count));            return true;        }        choppedStream.writeLong(crcValue, "crcvalue");        choppedStream.writeBuffer(bytes, "txnEntry");        choppedStream.writeByte((byte) 'B', "EOR");        count++;    }}
f426129c6efdc20bc062478c29830ac1fbbf10d97c3ce1b53a868e48f6caeb9e
trackSent
public void trackSent(long timestamp)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(timestamp));    }}
771134256267a575d619b5332a891d3f5a456905e71d304518a6e4da394ba78f
trackSent
public void trackSent(int packetType)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(packetType));    }}
48080ef7409aa0d5a9357cd27f8fc7dd16d816323429f25e86e16a5a59ae0546
trackReceived
public void trackReceived(long timestamp)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(timestamp));    }}
d2153821f38e9ddd778d5d55c11814a4f10c455b903d9eea9ab9a47d9ac914c5
trackReceived
public void trackReceived(int packetType)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(packetType));    }}
b750ed2bf7eba80e5f6f0ff8dfcaa3a20313dbbc120757bb26df319ad8fe3a63
peekSent
public final BufferedMessage peekSent()
{    return sentBuffer.peek();}
98e7101ffac316e2bf5c888577d5b54f2c11630dbfe6c6755ff00e7042f69961
peekReceived
public final BufferedMessage peekReceived()
{    return receivedBuffer.peek();}
90f470a0ae650b86cc7fce27c908bce56aa817810278b590df58a02a88f4cba7
peekSentTimestamp
public final long peekSentTimestamp()
{    return enabled ? sentBuffer.peek().getTimestamp() : 0;}
68007541619ccd1f420b108f07cb2b220271a715b1e1406ad4ccc67348e4ce11
peekReceivedTimestamp
public final long peekReceivedTimestamp()
{    return enabled ? receivedBuffer.peek().getTimestamp() : 0;}
9f360d468dd997c3f99d0f703ad5777ed6e1ab14b2ed749aef32c23cd3eca003
dumpToLog
public void dumpToLog(String serverAddress)
{    if (!enabled) {        return;    }    logMessages(serverAddress, receivedBuffer, Direction.RECEIVED);    logMessages(serverAddress, sentBuffer, Direction.SENT);}
4e0e7b0851e77e04c8dfa812d0ab6ca60b4c2f270690e6a567fe264c4b4442f2
logMessages
private static void logMessages(String serverAddr, CircularBuffer<BufferedMessage> messages, Direction direction)
{    String sentOrReceivedText = direction == Direction.SENT ? "sentBuffer to" : "receivedBuffer from";    if (messages.isEmpty()) {        LOG.info("No buffered timestamps for messages {} {}", sentOrReceivedText, serverAddr);    } else {        LOG.warn("Last {} timestamps for messages {} {}:", messages.size(), sentOrReceivedText, serverAddr);        while (!messages.isEmpty()) {            LOG.warn("{} {}  {}", sentOrReceivedText, serverAddr, messages.take().toString());        }    }}
59e5f9db90632e9357d8d6365aefa3664552805bb17870b29124ca1237fd6fae
getTimestamp
private long getTimestamp()
{    return timestamp;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (messageType == -1) {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp));    } else {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp)) + " Type: " + Leader.getPacketType(messageType);    }}
eced2396ea176e1955c78396a8c87d88645ea55e300acaa7235d878c64f930c8
getUnix
public boolean getUnix()
{    if (windows) {        return false;    }    return (!ibmvendor || linux);}
2803a14af1e13b986463c79f1eec8e72b78a7b655ece57938239115357926c83
getOSUnixMXBeanMethod
private Long getOSUnixMXBeanMethod(String mBeanMethodName)
{    Object unixos;    Class<?> classRef;    Method mBeanMethod;    try {        classRef = Class.forName("com.sun.management.UnixOperatingSystemMXBean");        if (classRef.isInstance(osMbean)) {            mBeanMethod = classRef.getDeclaredMethod(mBeanMethodName);            unixos = classRef.cast(osMbean);            return (Long) mBeanMethod.invoke(unixos);        }    } catch (Exception e) {        LOG.warn("Not able to load class or method for com.sun.managment.UnixOperatingSystemMXBean.", e);    }    return null;}
5d68a1dda12119ee3811a516d853f427e04775a236e7979e30faa723318b9d3f
getOpenFileDescriptorCount
public long getOpenFileDescriptorCount()
{    Long ofdc;    if (!ibmvendor) {        ofdc = getOSUnixMXBeanMethod("getOpenFileDescriptorCount");        return (ofdc != null ? ofdc.longValue() : -1);    }    try {                RuntimeMXBean rtmbean = ManagementFactory.getRuntimeMXBean();        String rtname = rtmbean.getName();        String[] pidhost = rtname.split("@");                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ls /proc/" + pidhost[0] + "/fdinfo | wc -l" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String openFileDesCount;            if ((openFileDesCount = output.readLine()) != null) {                return Long.parseLong(openFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {        LOG.warn("Not able to get the number of open file descriptors", ie);    }    return -1;}
39a2c6f1b0f51b963d000a005d37a1df3af85023ec0e98b577cd07c40ca425cd
getMaxFileDescriptorCount
public long getMaxFileDescriptorCount()
{    Long mfdc;    if (!ibmvendor) {        mfdc = getOSUnixMXBeanMethod("getMaxFileDescriptorCount");        return (mfdc != null ? mfdc.longValue() : -1);    }    try {                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ulimit -n" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String maxFileDesCount;            if ((maxFileDesCount = output.readLine()) != null) {                return Long.parseLong(maxFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {        LOG.warn("Not able to get the max number of file descriptors", ie);    }    return -1;}
ee60e03319c7708c9d4a2ef1229688c0a424756985c611535a280582efc11565
isWriteOp
 static boolean isWriteOp(int requestType)
{    switch(requestType) {        case ZooDefs.OpCode.sync:        case ZooDefs.OpCode.create:        case ZooDefs.OpCode.create2:        case ZooDefs.OpCode.createContainer:        case ZooDefs.OpCode.delete:        case ZooDefs.OpCode.deleteContainer:        case ZooDefs.OpCode.setData:        case ZooDefs.OpCode.reconfig:        case ZooDefs.OpCode.setACL:        case ZooDefs.OpCode.multi:        case ZooDefs.OpCode.check:            return true;    }    return false;}
6e6921e97a328cddeafa3ee355ad5cd6d4150a72f5fada90052f10a2238e8641
trimPathDepth
 static String trimPathDepth(String path, int maxDepth)
{    int count = 0;    StringBuilder sb = new StringBuilder();    StringTokenizer pathTokenizer = new StringTokenizer(path, PATH_SEPERATOR);    while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {        sb.append(PATH_SEPERATOR);        sb.append(pathTokenizer.nextToken());    }    path = sb.toString();    return path;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (!enabled) {        return;    }    LOG.info("shutdown scheduledExecutor");    scheduledExecutor.shutdownNow();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (!enabled) {        return;    }    LOG.info("Start the RequestPath collector");    immutableRequestsMap.forEach((opType, pathStatsQueue) -> pathStatsQueue.start());        scheduledExecutor.scheduleWithFixedDelay(() -> {        LOG.info("%nHere are the top Read paths:");        logTopPaths(aggregatePaths(4, queue -> !queue.isWriteOperation()), entry -> LOG.info(entry.getKey() + " : " + entry.getValue()));        LOG.info("%nHere are the top Write paths:");        logTopPaths(aggregatePaths(4, queue -> queue.isWriteOperation()), entry -> LOG.info(entry.getKey() + " : " + entry.getValue()));    }, COLLECTOR_INITIAL_DELAY, COLLECTOR_DELAY, TimeUnit.MINUTES);}
92f2040cca54265c1c65f6401490c10b35441697f56622b5761fd58d04468de7
registerRequest
public void registerRequest(int type, String path)
{    if (!enabled) {        return;    }    if (sampler.nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));        if (pathStatsQueue != null) {            pathStatsQueue.registerRequest(path);        } else {            LOG.error("We should not handle {}", type);        }    }}
7a0351a03826761a8008b0ea2c71343788866a895be7357cf1a75bef383eb375
dumpTopRequestPath
public void dumpTopRequestPath(PrintWriter pwriter, String requestTypeName, int queryMaxDepth)
{    if (queryMaxDepth < 1) {        return;    }    PathStatsQueue pathStatsQueue = immutableRequestsMap.get(requestTypeName);    if (pathStatsQueue == null) {        pwriter.println("Can not find path stats for type: " + requestTypeName);        return;    } else {        pwriter.println("The top requests of type: " + requestTypeName);    }    Map<String, Integer> combinedMap;    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    combinedMap = pathStatsQueue.collectStats(maxDepth);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
67893f1bd9380430152278625729938f3b88d4a6719df3ff8855ef13805e2c32
dumpTopReadPaths
public void dumpTopReadPaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top read requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> !queue.isWriteOperation);}
5e8c32065f1c3de4637304a52642cdf38b4dd13c58327e6862f7317ca7b90610
dumpTopWritePaths
public void dumpTopWritePaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top write requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> queue.isWriteOperation);}
4078336aa523ffbc712e96f16e3806ca747aee54da91c4fe14793c17059b596c
dumpTopPaths
public void dumpTopPaths(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> true);}
c4734017f9ad2ea4c0053319c22b7540a19509ead40080a74851d9342c0d311a
dumpTopAggregatedPaths
private void dumpTopAggregatedPaths(PrintWriter pwriter, int queryMaxDepth, final Predicate<PathStatsQueue> predicate)
{    if (!enabled) {        return;    }    final Map<String, Integer> combinedMap = aggregatePaths(queryMaxDepth, predicate);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
76cc66f4f60ef4c87d1a9fab6cddde2060c75ed609be5e9f7df31bb3c61ed364
aggregatePaths
 Map<String, Integer> aggregatePaths(int queryMaxDepth, Predicate<PathStatsQueue> predicate)
{    final Map<String, Integer> combinedMap = new HashMap<>(REQUEST_PREPROCESS_TOPPATH_MAX);    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    immutableRequestsMap.values().stream().filter(predicate).forEach(pathStatsQueue -> pathStatsQueue.collectStats(maxDepth).forEach((path, count) -> combinedMap.put(path, combinedMap.getOrDefault(path, 0) + count)));    return combinedMap;}
3649141b52a86c63b621accd69e789522994b606246cf96339acea5085ac98cb
logTopPaths
 void logTopPaths(Map<String, Integer> combinedMap, final Consumer<Map.Entry<String, Integer>> output)
{    combinedMap.entrySet().stream().sorted(Comparator.comparing(Map.Entry<String, Integer>::getValue).reversed()).limit(REQUEST_PREPROCESS_TOPPATH_MAX).forEach(output);}
e8c4b31c1a3adfcbfa1ad4c5f095e400d7c52d198ab8980ab011234acf63fe5f
registerRequest
public void registerRequest(String path)
{    if (!enabled) {        return;    }    currentSlot.get().offer(path);}
aa77901f6227d1d96ee77cd897782cd5d33841a7a63e33f2e46b65368d92a4f6
getCurrentSlot
 ConcurrentLinkedQueue<String> getCurrentSlot()
{    return currentSlot.get();}
44aba169f4d64944a243e74eda5b1293641a06a1c566343efc141bfb7f3b69d5
mapReducePaths
 Map<String, Integer> mapReducePaths(int maxDepth, Collection<String> tobeProcessedSlot)
{    Map<String, Integer> newSlot = new ConcurrentHashMap<>();    tobeProcessedSlot.stream().filter(path -> path != null).forEach((path) -> {        path = trimPathDepth(path, maxDepth);        newSlot.put(path, newSlot.getOrDefault(path, 0) + 1);    });    return newSlot;}
415721cf26d5116934096afe270be1caa05c70252d204db11cc1e1bb0da31be3
collectStats
public Map<String, Integer> collectStats(int maxDepth)
{    Map<String, Integer> combinedMap;            Map<String, Integer> snapShot = mapReducePaths(maxDepth, Arrays.asList(currentSlot.get().toArray(new String[0])));        synchronized (accurateMode ? requestPathStats : new Object()) {        combinedMap = requestPathStats.stream().reduce(snapShot, (firstMap, secondMap) -> {            secondMap.forEach((key, value) -> {                String trimmedPath = trimPathDepth(key, maxDepth);                firstMap.put(trimmedPath, firstMap.getOrDefault(trimmedPath, 0) + value);            });            return firstMap;        });    }    return combinedMap;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (!enabled) {        return;    }        int delay = sampler.nextInt(REQUEST_STATS_SLOT_DURATION);            scheduledExecutor.scheduleWithFixedDelay(() -> {                ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());        try {                                    Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);            synchronized (accurateMode ? requestPathStats : new Object()) {                if (requestPathStats.remainingCapacity() <= 0) {                    requestPathStats.poll();                }                if (!requestPathStats.offer(latestSlot)) {                    LOG.error("Failed to insert the new request path stats for {}", requestTypeName);                }            }        } catch (Exception e) {            LOG.error("Failed to insert the new request path stats for {} with exception {}", requestTypeName, e);        }    }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);}
b9bd94abb665ea255dd95cfe2a55367a12b02a850c43162a048ea49509345477
isWriteOperation
 boolean isWriteOperation()
{    return isWriteOperation;}
fd14f59683d15ea00391825890c563d58ce5388783f9519e4540eb1180fb7a90
deserializeTxn
public static Record deserializeTxn(byte[] txnBytes, TxnHeader hdr) throws IOException
{    final ByteArrayInputStream bais = new ByteArrayInputStream(txnBytes);    InputArchive ia = BinaryInputArchive.getArchive(bais);    hdr.deserialize(ia, "hdr");    bais.mark(bais.available());    Record txn = null;    switch(hdr.getType()) {        case OpCode.createSession:                                    txn = new CreateSessionTxn();            break;        case OpCode.closeSession:            txn = ZooKeeperServer.isCloseSessionTxnEnabled() ? new CloseSessionTxn() : null;            break;        case OpCode.create:        case OpCode.create2:            txn = new CreateTxn();            break;        case OpCode.createTTL:            txn = new CreateTTLTxn();            break;        case OpCode.createContainer:            txn = new CreateContainerTxn();            break;        case OpCode.delete:        case OpCode.deleteContainer:            txn = new DeleteTxn();            break;        case OpCode.reconfig:        case OpCode.setData:            txn = new SetDataTxn();            break;        case OpCode.setACL:            txn = new SetACLTxn();            break;        case OpCode.error:            txn = new ErrorTxn();            break;        case OpCode.multi:            txn = new MultiTxn();            break;        default:            throw new IOException("Unsupported Txn with type=%d" + hdr.getType());    }    if (txn != null) {        try {            txn.deserialize(ia, "txn");        } catch (EOFException e) {                        if (hdr.getType() == OpCode.create) {                CreateTxn create = (CreateTxn) txn;                bais.reset();                CreateTxnV0 createv0 = new CreateTxnV0();                createv0.deserialize(ia, "txn");                                                create.setPath(createv0.getPath());                create.setData(createv0.getData());                create.setAcl(createv0.getAcl());                create.setEphemeral(createv0.getEphemeral());                create.setParentCVersion(-1);            } else if (hdr.getType() == OpCode.closeSession) {                                                txn = null;            } else {                throw e;            }        }    }    return txn;}
7172b0e95018000dfb8f0fc74dd6eb0089a17e63e1225980499f9a1932ea0f4d
deserializeSnapshot
public static void deserializeSnapshot(DataTree dt, InputArchive ia, Map<Long, Integer> sessions) throws IOException
{    int count = ia.readInt("count");    while (count > 0) {        long id = ia.readLong("id");        int to = ia.readInt("timeout");        sessions.put(id, to);        if (LOG.isTraceEnabled()) {            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "loadData --- session in archive: " + id + " with timeout: " + to);        }        count--;    }    dt.deserialize(ia, "tree");}
5d4d248f7ac03e1c158a9045fa98a55292aada56d2039cbd3b97ad2bca949dca
serializeSnapshot
public static void serializeSnapshot(DataTree dt, OutputArchive oa, Map<Long, Integer> sessions) throws IOException
{    HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(sessions);    oa.writeInt(sessSnap.size(), "count");    for (Entry<Long, Integer> entry : sessSnap.entrySet()) {        oa.writeLong(entry.getKey().longValue(), "id");        oa.writeInt(entry.getValue().intValue(), "timeout");    }    dt.serialize(oa, "tree");}
3a1dbdfc03d1328845deb6612c04864d1d72c5972e035647f2c8f6fc869f2b35
serializeRequest
public static byte[] serializeRequest(Request request)
{    if (request == null || request.getHdr() == null) {        return null;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    try {        request.getHdr().serialize(boa, "hdr");        if (request.getTxn() != null) {            request.getTxn().serialize(boa, "txn");        }    } catch (IOException e) {        LOG.error("This really should be impossible", e);    } finally {        IOUtils.cleanup(LOG, baos);    }    return baos.toByteArray();}
5ea7c8cfaf6514b202d7746d8a7d9a2f4a899b5e0f97501f80daa40e0a560297
create
public File create(String path)
{    File file = new File(path);    return validate(file);}
624376e9e53b2bccfacc226b6a6f0e94d7ef3416f3b7c6173528cb154e36c357
validate
public File validate(File file)
{    if (warnForRelativePath) {        doWarnForRelativePath(file);    }    if (failForNonExistingPath) {        doFailForNonExistingPath(file);    }    return file;}
ca298831bd4e1170cade7aac4e38f9b2b22e42ffe5eff4f477c47f4fb79ddcba
doFailForNonExistingPath
private void doFailForNonExistingPath(File file)
{    if (!file.exists()) {        throw new IllegalArgumentException(file.toString() + " file is missing");    }}
75bb019e5cd0174525632b6c9d30a9b1515af1341a3dea4ba7aa7f68a55f1cba
doWarnForRelativePath
private void doWarnForRelativePath(File file)
{    if (file.isAbsolute()) {        return;    }    if (file.getPath().substring(0, 2).equals("." + File.separator)) {        return;    }    log.warn(file.getPath() + " is relative. Prepend ." + File.separator + " to indicate that you're sure!");}
12fb6b978b1f33c682b8b34a3396475ba953fd27b09350e67e99c5065529272a
warnForRelativePath
public Builder warnForRelativePath()
{    warnForRelativePathOption = true;    return this;}
81d551cd1f7d659f6903d6331caa3515dbf599bbdb6424261c47d90190df84ba
failForNonExistingPath
public Builder failForNonExistingPath()
{    failForNonExistingPathOption = true;    return this;}
de6fa55c8ae13c972417b7a1b0b706cf587d9d65d0eca5adac231348e8429e08
build
public VerifyingFileFactory build()
{    return new VerifyingFileFactory(this);}
16e6ae9b1d294bf33d9b2a9c4522fed448511e483bad7f27f6b2cc636c2c612c
getEpochFromZxid
public static long getEpochFromZxid(long zxid)
{    return zxid >> 32L;}
b2f00a9b838a91d158e2f9503cfcb4c3db87acd3ec3ca7f7918887a9766e7a2c
getCounterFromZxid
public static long getCounterFromZxid(long zxid)
{    return zxid & 0xffffffffL;}
6fe75378ed9c2b04e878fafb0ec15b1079561d9f5f2105653ea13868cc450ae2
makeZxid
public static long makeZxid(long epoch, long counter)
{    return (epoch << 32L) | (counter & 0xffffffffL);}
cf67330f40e62ea6dcf6f362cef2efd92d0460ad219b7d7ae9ffbeab9f408326
zxidToString
public static String zxidToString(long zxid)
{    return Long.toHexString(zxid);}
d6cd296581fb7bac59df288dcfede1e2b3d8d9bccbf4d596234f1de87778935d
addDeadWatcher
public void addDeadWatcher(int watcherBit)
{        while (maxInProcessingDeadWatchers > 0 && !stopped && totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {        try {            RATE_LOGGER.rateLimitLog("Waiting for dead watchers cleaning");            long startTime = Time.currentElapsedTime();            synchronized (processingCompletedEvent) {                processingCompletedEvent.wait(100);            }            long latency = Time.currentElapsedTime() - startTime;            ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);        } catch (InterruptedException e) {            LOG.info("Got interrupted while waiting for dead watches " + "queue size");            break;        }    }    synchronized (this) {        if (deadWatchers.add(watcherBit)) {            totalDeadWatchers.incrementAndGet();            ServerMetrics.getMetrics().DEAD_WATCHERS_QUEUED.add(1);            if (deadWatchers.size() >= watcherCleanThreshold) {                synchronized (cleanEvent) {                    cleanEvent.notifyAll();                }            }        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped) {        synchronized (cleanEvent) {            try {                                if (!stopped && deadWatchers.size() < watcherCleanThreshold) {                    int maxWaitMs = (watcherCleanIntervalInSeconds + r.nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;                    cleanEvent.wait(maxWaitMs);                }            } catch (InterruptedException e) {                LOG.info("Received InterruptedException while " + "waiting for cleanEvent");                break;            }        }        if (deadWatchers.isEmpty()) {            continue;        }        synchronized (this) {                                                                        final Set<Integer> snapshot = new HashSet<Integer>(deadWatchers);            deadWatchers.clear();            int total = snapshot.size();            LOG.info("Processing {} dead watchers", total);            cleaners.schedule(new WorkRequest() {                @Override                public void doWork() throws Exception {                    long startTime = Time.currentElapsedTime();                    listener.processDeadWatchers(snapshot);                    long latency = Time.currentElapsedTime() - startTime;                    LOG.info("Takes {} to process {} watches", latency, total);                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);                    totalDeadWatchers.addAndGet(-total);                    synchronized (processingCompletedEvent) {                        processingCompletedEvent.notifyAll();                    }                }            });        }    }    LOG.info("WatcherCleaner thread exited");}
cace1ffc2b74c728baa14b3a9fb641d3a6929a0eeb87c9040670c3b062692d26
doWork
public void doWork() throws Exception
{    long startTime = Time.currentElapsedTime();    listener.processDeadWatchers(snapshot);    long latency = Time.currentElapsedTime() - startTime;    LOG.info("Takes {} to process {} watches", latency, total);    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);    totalDeadWatchers.addAndGet(-total);    synchronized (processingCompletedEvent) {        processingCompletedEvent.notifyAll();    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stopped = true;    deadWatchers.clear();    cleaners.stop();    this.interrupt();    if (LOG.isInfoEnabled()) {        LOG.info("WatcherCleaner thread shutdown is initiated");    }}
42f141ac900ced7b32f97a568f5de2ec2b50c5328f723498289728248cbe5a01
contains
public boolean contains(Watcher watcher)
{    if (watchers == null) {        return false;    }    return watchers.contains(watcher);}
830966f27fd1ab4ac60b473567f8d1b03f806318e7da2e5cd6c1e1db8282b425
contains
public boolean contains(int watcherBit)
{    if (watcherBits == null) {        return false;    }    return watcherBits.contains(watcherBit);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    if (watchers != null) {        return watchers.size();    }    if (watcherBits != null) {        return watcherBits.size();    }    return 0;}
dc0826b09dd3eb219fd78d3b06da0e2a617b70067a5ad061564e90e52b2c193e
deepCopy
private static Map<String, Set<Long>> deepCopy(Map<String, Set<Long>> m)
{    Map<String, Set<Long>> m2 = new HashMap<String, Set<Long>>();    for (Map.Entry<String, Set<Long>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<Long>(e.getValue()));    }    return m2;}
da21899b51f674f098e2f0e7c4a72a95f189fce7fbd4d6bd4af13194d22dfba2
hasSessions
public boolean hasSessions(String path)
{    return path2Ids.containsKey(path);}
31df0e36566b817516ceaabe5950d0ab1de9b634eaba06d259cd7a9c70b17cd9
getSessions
public Set<Long> getSessions(String path)
{    Set<Long> s = path2Ids.get(path);    return s != null ? Collections.unmodifiableSet(s) : null;}
9d23766b720287604d85a02b88105a2a51a03fbffb46f4bf3703920d608a75d6
toMap
public Map<String, Set<Long>> toMap()
{    return deepCopy(path2Ids);}
2fde8c483b9c2e3feced875668655181347cac9361e68d76340bac2cfa09f389
deepCopy
private static Map<Long, Set<String>> deepCopy(Map<Long, Set<String>> m)
{    Map<Long, Set<String>> m2 = new HashMap<Long, Set<String>>();    for (Map.Entry<Long, Set<String>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<String>(e.getValue()));    }    return m2;}
74bc19fc369bdd78adb343834f6e7a9010a5dedd826c28963c556a33060288f0
hasPaths
public boolean hasPaths(long sessionId)
{    return id2paths.containsKey(sessionId);}
2fd2e2bd9ee5f215d999502cd56fc951cf1e394147c490dc7a23e1535188f006
getPaths
public Set<String> getPaths(long sessionId)
{    Set<String> s = id2paths.get(sessionId);    return s != null ? Collections.unmodifiableSet(s) : null;}
60e92d1a8756a5152d432d3329a80163eb4fd2ddbc4b4e4a45e9355fad027b0f
toMap
public Map<Long, Set<String>> toMap()
{    return deepCopy(id2paths);}
a8b65845e0ccbe917d1322889bf8732268cf9ff70bfc0d2929426f941814d220
getNumConnections
public int getNumConnections()
{    return numConnections;}
0307fe10cdc6f2097dac2238fa6f6bdb1357a723a654191881622a50771008e5
getNumPaths
public int getNumPaths()
{    return numPaths;}
aa24f4c24dec7370a901c704e5f8e0cc616a46b097f6cff591a7c9362ae843ee
getTotalWatches
public int getTotalWatches()
{    return totalWatches;}
65b9204a280022d9bd71027843cc94ed9c65b18b91c1965857d22b6e4c663772
toMap
public Map<String, Object> toMap()
{    Map<String, Object> summary = new LinkedHashMap<String, Object>();    summary.put(KEY_NUM_CONNECTIONS, numConnections);    summary.put(KEY_NUM_PATHS, numPaths);    summary.put(KEY_NUM_TOTAL_WATCHES, totalWatches);    return summary;}
eaafb4eb5b18fb3b34f16a6b742f9b616dd9970c142c488a7f39a82bc83df423
size
public synchronized int size()
{    int result = 0;    for (Set<Watcher> watches : watchTable.values()) {        result += watches.size();    }    return result;}
d7b220148ad18d0fc4a5f350189742a8e3abe873c48f7263da3d702396c85516
isDeadWatcher
 boolean isDeadWatcher(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
bd9b1693d6b43a6c579394ddbd11cd0bd09055b2010755e0f05359ca9971cc36
addWatch
public synchronized boolean addWatch(String path, Watcher watcher)
{    if (isDeadWatcher(watcher)) {        LOG.debug("Ignoring addWatch with closed cnxn");        return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null) {                                list = new HashSet<Watcher>(4);        watchTable.put(path, list);    }    list.add(watcher);    Set<String> paths = watch2Paths.get(watcher);    if (paths == null) {                paths = new HashSet<String>();        watch2Paths.put(watcher, paths);    }    return paths.add(path);}
57e656dedc65d5de8d1d322ee6747dfefaa8ae74e53e715394730359a06ff399
removeWatcher
public synchronized void removeWatcher(Watcher watcher)
{    Set<String> paths = watch2Paths.remove(watcher);    if (paths == null) {        return;    }    for (String p : paths) {        Set<Watcher> list = watchTable.get(p);        if (list != null) {            list.remove(watcher);            if (list.isEmpty()) {                watchTable.remove(p);            }        }    }}
5209c2b9e2a8a8036c6fd7e5c653ea218aa3e67bb2a6e879770d2478fdf07fb3
triggerWatch
public WatcherOrBitSet triggerWatch(String path, EventType type)
{    return triggerWatch(path, type, null);}
9f062fc617468fe772c5ffae3bf293920752c2192beb3feff6b2ab16e5d4d5c4
triggerWatch
public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet supress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    Set<Watcher> watchers;    synchronized (this) {        watchers = watchTable.remove(path);        if (watchers == null || watchers.isEmpty()) {            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "No watchers for " + path);            }            return null;        }        for (Watcher w : watchers) {            Set<String> paths = watch2Paths.get(w);            if (paths != null) {                paths.remove(path);            }        }    }    for (Watcher w : watchers) {        if (supress != null && supress.contains(w)) {            continue;        }        w.process(e);    }    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(watchers.size());            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(watchers.size());            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(watchers.size());            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(watchers.size());            break;        default:                        break;    }    return new WatcherOrBitSet(watchers);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(watch2Paths.size()).append(" connections watching ").append(watchTable.size()).append(" paths\n");    int total = 0;    for (Set<String> paths : watch2Paths.values()) {        total += paths.size();    }    sb.append("Total watches:").append(total);    return sb.toString();}
fad82271f43c2bc71de4dd33470de43c84510903df4a1397ab35bec3228dbbf4
dumpWatches
public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {            pwriter.println(e.getKey());            for (Watcher w : e.getValue()) {                pwriter.print("\t0x");                pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                pwriter.print("\n");            }        }    } else {        for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
09ac970eac2e193da299143234825b3ecb8f960a2a12e16da23ea99728564564
containsWatcher
public synchronized boolean containsWatcher(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    return paths != null && paths.contains(path);}
fbd8c65fac15dc2b2972ad8fa8bbc723e6c12156492537a2588e689d32e2a2aa
removeWatcher
public synchronized boolean removeWatcher(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    if (paths == null || !paths.remove(path)) {        return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null || !list.remove(watcher)) {        return false;    }    if (list.isEmpty()) {        watchTable.remove(path);    }    return true;}
5e77c11b22290d7fbd6348c563dcd70e3d50e1d5cf2f10840c426ce9fee3949c
getWatches
public synchronized WatchesReport getWatches()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
a8f41e443396bc6844c10b6e769c0dcc3525f39e0beef9a73d9ea8daee730db8
getWatchesByPath
public synchronized WatchesPathReport getWatchesByPath()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {        Set<Long> ids = new HashSet<Long>(e.getValue().size());        path2ids.put(e.getKey(), ids);        for (Watcher watcher : e.getValue()) {            ids.add(((ServerCnxn) watcher).getSessionId());        }    }    return new WatchesPathReport(path2ids);}
f977720a7eeebd4c657462825246f73124399fa40b24941b49c93db44807101d
getWatchesSummary
public synchronized WatchesSummary getWatchesSummary()
{    int totalWatches = 0;    for (Set<String> paths : watch2Paths.values()) {        totalWatches += paths.size();    }    return new WatchesSummary(watch2Paths.size(), watchTable.size(), totalWatches);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{/* do nothing */}
79dd5f97278f7184b6ebeec13bdd3a7640eb3f78e7a341644c13ce113b95e53c
createWatchManager
public static IWatchManager createWatchManager() throws IOException
{    String watchManagerName = System.getProperty(ZOOKEEPER_WATCH_MANAGER_NAME);    if (watchManagerName == null) {        watchManagerName = WatchManager.class.getName();    }    try {        IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();        LOG.info("Using {} as watch manager", watchManagerName);        return watchManager;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + watchManagerName, e);        throw ioe;    }}
f0b708a73aaf861fdf52b1bb7060f08f07b8370d3797d548c10013958f6ee618
addWatch
public boolean addWatch(String path, Watcher watcher)
{    boolean result = false;                        addRemovePathRWLock.readLock().lock();    try {                if (isDeadWatcher(watcher)) {            LOG.debug("Ignoring addWatch with closed cnxn");        } else {            Integer bit = watcherBitIdMap.add(watcher);            BitHashSet watchers = pathWatches.get(path);            if (watchers == null) {                watchers = new BitHashSet();                BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);                                if (existingWatchers != null) {                    watchers = existingWatchers;                }            }            result = watchers.add(bit);        }    } finally {        addRemovePathRWLock.readLock().unlock();    }    return result;}
d94970dee63010f099f7c540f957692b41e50b50c8fbd80a7f0695cf7a60225a
containsWatcher
public boolean containsWatcher(String path, Watcher watcher)
{    BitHashSet watchers = pathWatches.get(path);    return watchers != null && watchers.contains(watcherBitIdMap.getBit(watcher));}
7ba623e7df1be39db6630d78080431f818edce832c65ce813b420d3563375359
removeWatcher
public boolean removeWatcher(String path, Watcher watcher)
{                        addRemovePathRWLock.writeLock().lock();    try {        BitHashSet list = pathWatches.get(path);        if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {            return false;        }        if (list.isEmpty()) {            pathWatches.remove(path);        }        return true;    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
91aa70099446d802a2828c9db9a64c77d669a69afa8a9c35e35d4fdaa4fd2249
removeWatcher
public void removeWatcher(Watcher watcher)
{    Integer watcherBit;            addRemovePathRWLock.writeLock().lock();    try {                watcherBit = watcherBitIdMap.getBit(watcher);        if (watcherBit == null) {            return;        }    } finally {        addRemovePathRWLock.writeLock().unlock();    }                                            watcherCleaner.addDeadWatcher(watcherBit);}
eb53518159a8e716cececc97c414a337c4508262cfd0428268e4cb60e8375cbd
processDeadWatchers
public void processDeadWatchers(Set<Integer> deadWatchers)
{                BitSet bits = new BitSet();    for (int dw : deadWatchers) {        bits.set(dw);    }        for (BitHashSet watchers : pathWatches.values()) {        watchers.remove(deadWatchers, bits);    }        for (Integer wbit : deadWatchers) {        watcherBitIdMap.remove(wbit);    }}
5209c2b9e2a8a8036c6fd7e5c653ea218aa3e67bb2a6e879770d2478fdf07fb3
triggerWatch
public WatcherOrBitSet triggerWatch(String path, EventType type)
{    return triggerWatch(path, type, null);}
0a70ea9faed777971d206fa60f1c481dc4e3bdc0463c446e5751a94c8be5f279
triggerWatch
public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet suppress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    BitHashSet watchers = remove(path);    if (watchers == null) {        return null;    }    int triggeredWatches = 0;        synchronized (watchers) {        for (Integer wBit : watchers) {            if (suppress != null && suppress.contains(wBit)) {                continue;            }            Watcher w = watcherBitIdMap.get(wBit);                        if (w == null || isDeadWatcher(w)) {                continue;            }            w.process(e);            triggeredWatches++;        }    }    updateMetrics(type, triggeredWatches);    return new WatcherOrBitSet(watchers);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    int size = 0;    for (BitHashSet watches : pathWatches.values()) {        size += watches.size();    }    return size;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    if (watcherCleaner != null) {        watcherCleaner.shutdown();    }}
200e18c80027a1c09e51ba4277f91ac93343b691fad555e743a86634645354f6
remove
private BitHashSet remove(String path)
{    addRemovePathRWLock.writeLock().lock();    try {        return pathWatches.remove(path);    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
437d94482908a5e72e0db96fbe68c4fb9dc5fa4dbaac6dbf6eb361daa057499d
updateMetrics
 void updateMetrics(final EventType type, int size)
{    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(size);            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(size);            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(size);            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(size);            break;        default:                        break;    }}
d7b220148ad18d0fc4a5f350189742a8e3abe873c48f7263da3d702396c85516
isDeadWatcher
 boolean isDeadWatcher(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
b83dc00c66e2dd7376568bddae3a5eaff6ed0bd6dc0a33f74da0779e74058f86
pathSize
 int pathSize()
{    return pathWatches.size();}
78c677b3f78d20128ee9cfb111fc6e86dab21caa9ad368ea54738bad486ae0d4
getWatchesSummary
public WatchesSummary getWatchesSummary()
{    return new WatchesSummary(watcherBitIdMap.size(), pathSize(), size());}
2752a0db37136e0d2aa3f839bfff749a605959fb205d0f62ebdbc32c226e7ee5
getWatches
public WatchesReport getWatches()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
b0fe8a77e7f9743959ad7c02382b6a47284f66daab4f60d22d7292f7d4ca0120
getWatchesByPath
public WatchesPathReport getWatchesByPath()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        BitHashSet watchers = e.getValue();        synchronized (watchers) {            Set<Long> ids = new HashSet<Long>(watchers.size());            path2ids.put(e.getKey(), ids);            for (Integer wbit : watchers) {                Watcher watcher = watcherBitIdMap.get(wbit);                if (watcher instanceof ServerCnxn) {                    ids.add(((ServerCnxn) watcher).getSessionId());                }            }        }    }    return new WatchesPathReport(path2ids);}
e6f952942e7c147feab2364d75714a0c5e021fd7efd4d15fd4470a56480cd66f
getWatcher2PathesMap
public Map<Watcher, Set<String>> getWatcher2PathesMap()
{    Map<Watcher, Set<String>> watcher2paths = new HashMap<Watcher, Set<String>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        String path = e.getKey();        BitHashSet watchers = e.getValue();                synchronized (watchers) {            for (Integer wbit : watchers) {                Watcher w = watcherBitIdMap.get(wbit);                if (w == null) {                    continue;                }                if (!watcher2paths.containsKey(w)) {                    watcher2paths.put(w, new HashSet<String>());                }                watcher2paths.get(w).add(path);            }        }    }    return watcher2paths;}
ee55067990067462674be3afb03e279e823120334af009a6af7fa5a5054e90a1
dumpWatches
public void dumpWatches(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {            pwriter.println(e.getKey());            BitHashSet watchers = e.getValue();            synchronized (watchers) {                for (Integer wbit : watchers) {                    Watcher w = watcherBitIdMap.get(wbit);                    if (!(w instanceof ServerCnxn)) {                        continue;                    }                    pwriter.print("\t0x");                    pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                    pwriter.print("\n");                }            }        }    } else {        for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(watcherBitIdMap.size()).append(" connections watching ").append(pathSize()).append(" paths\n");    sb.append("Total watches:").append(size());    return sb.toString();}
a317f472727975f13a20ef21472e1d5e0a0fd93702ee696b9c962178a725931f
cleanup
public void cleanup()
{}
ce47600b92f51b3092b3c405be5f5444c49ca90a6f5673717d429c165adb447d
schedule
public void schedule(WorkRequest workRequest)
{    schedule(workRequest, 0);}
dfe07bc1b05fd0bac7e895d43e8a56c88605051eb4648ef56026d05741021eb7
schedule
public void schedule(WorkRequest workRequest, long id)
{    if (stopped) {        workRequest.cleanup();        return;    }    ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);            int size = workers.size();    if (size > 0) {        try {                        int workerNum = ((int) (id % size) + size) % size;            ExecutorService worker = workers.get(workerNum);            worker.execute(scheduledWorkRequest);        } catch (RejectedExecutionException e) {            LOG.warn("ExecutorService rejected execution", e);            workRequest.cleanup();        }    } else {                        scheduledWorkRequest.run();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {                if (stopped) {            workRequest.cleanup();            return;        }        workRequest.doWork();    } catch (Exception e) {        LOG.warn("Unexpected exception", e);        workRequest.cleanup();    }}
02166686c9ffef8abcca97b0bc3e38cb95c97860d78686958b46127a2ecadb18
newThread
public Thread newThread(Runnable r)
{    Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);    if (!t.isDaemon()) {        t.setDaemon(true);    }    if (t.getPriority() != Thread.NORM_PRIORITY) {        t.setPriority(Thread.NORM_PRIORITY);    }    return t;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (numWorkerThreads > 0) {        if (threadsAreAssignable) {            for (int i = 1; i <= numWorkerThreads; ++i) {                workers.add(Executors.newFixedThreadPool(1, new DaemonThreadFactory(threadNamePrefix, i)));            }        } else {            workers.add(Executors.newFixedThreadPool(numWorkerThreads, new DaemonThreadFactory(threadNamePrefix)));        }    }    stopped = false;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    stopped = true;        for (ExecutorService worker : workers) {        worker.shutdown();    }}
9f2073c723f87334abef43ce7083e9d984c317ce761b1dc072c87c217bec19ed
join
public void join(long shutdownTimeoutMS)
{        long now = Time.currentElapsedTime();    long endTime = now + shutdownTimeoutMS;    for (ExecutorService worker : workers) {        boolean terminated = false;        while ((now = Time.currentElapsedTime()) <= endTime) {            try {                terminated = worker.awaitTermination(endTime - now, TimeUnit.MILLISECONDS);                break;            } catch (InterruptedException e) {                        }        }        if (!terminated) {                        worker.shutdownNow();        }    }}
dfae04ffcb321b3b2f415df4f77484ea3bc10e37b75d7f5729d8f50810084fe3
isInitialized
public boolean isInitialized()
{    return initialized;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    minCommittedLog = 0;    maxCommittedLog = 0;    /* to be safe we just create a new         * datatree.         */    dataTree.shutdownWatcher();    dataTree = createDataTree();    sessionsWithTimeouts.clear();    WriteLock lock = logLock.writeLock();    try {        lock.lock();        committedLog.clear();    } finally {        lock.unlock();    }    initialized = false;}
4c6c6f98626d9a32fa4f1c2d7d1458fa1c92e2233729129c702dc2904c44d2dc
getDataTree
public DataTree getDataTree()
{    return this.dataTree;}
56de2ca47f238ec0a6d8166ee0970a0283fbcc35c8fa7be2006d6613dd314565
getmaxCommittedLog
public long getmaxCommittedLog()
{    return maxCommittedLog;}
9a33bbd60fe73e14eb7b2eae4d40137a85f07077394e83cadb221f164f25965a
getminCommittedLog
public long getminCommittedLog()
{    return minCommittedLog;}
8cfa7c2ded13119c77114718a496189923a616c2b85f7320172e20febac5c66d
getLogLock
public ReentrantReadWriteLock getLogLock()
{    return logLock;}
8062062a9a92656ab681ac5c16c41b9f6702d7fe8d630e5be4240804c01c4143
getCommittedLog
public synchronized Collection<Proposal> getCommittedLog()
{    final Collection<Proposal> result;    ReadLock rl = logLock.readLock();        if (logLock.getReadHoldCount() > 0) {        result = this.committedLog;    } else {        rl.lock();        try {            result = new ArrayList<>(this.committedLog);        } finally {            rl.unlock();        }    }    return Collections.unmodifiableCollection(result);}
abc7ead92ff84d7deb4f99d8d3bc1f70a065f72016e9451ddfc05553f7ad5814
getDataTreeLastProcessedZxid
public long getDataTreeLastProcessedZxid()
{    return dataTree.lastProcessedZxid;}
12d76c9e8483774bde383e09c1f087f33a0e655c412772f73f8514f3b6932d16
getSessions
public Collection<Long> getSessions()
{    return dataTree.getSessions();}
62dc5a6b97de22576c7fb7651fe0aabed0de5fb1fe9b187fc590a15667825cf2
getSessionCount
public long getSessionCount()
{    return sessionsWithTimeouts.size();}
c162d50887a9826b8cc67f6a0404e9bd4631082498591020dd1119cde30f84ac
getSessionWithTimeOuts
public ConcurrentHashMap<Long, Integer> getSessionWithTimeOuts()
{    return sessionsWithTimeouts;}
b572bce2ce5cf4f4592f2f89e8a38e76d9210a30bcb296ec91b7d79aa230eb88
onTxnLoaded
public void onTxnLoaded(TxnHeader hdr, Record txn)
{    addCommittedProposal(hdr, txn);}
306af2647520ceea70538c4c2999eeef87a1bf92975595b0eba36c69f3d184fa
loadDataBase
public long loadDataBase() throws IOException
{    long startTime = Time.currentElapsedTime();    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    long loadTime = Time.currentElapsedTime() - startTime;    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);    LOG.info("Snapshot loaded in " + loadTime + " ms");    return zxid;}
ebafa7e4538eb6b5626561b4fde533fff41a36fe3da2d5a00137ce8926ab22f3
fastForwardDataBase
public long fastForwardDataBase() throws IOException
{    long zxid = snapLog.fastForwardFromEdits(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    return zxid;}
398fa042af4c7a4021fca9050c5754b76203c1397346b81fe7452a826da88f2d
addCommittedProposal
private void addCommittedProposal(TxnHeader hdr, Record txn)
{    Request r = new Request(0, hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    addCommittedProposal(r);}
42c2a467fd586ff3c23e1e15dc1d41abd382aba49f23e111604e02fd876c3915
addCommittedProposal
public void addCommittedProposal(Request request)
{    WriteLock wl = logLock.writeLock();    try {        wl.lock();        if (committedLog.size() > commitLogCount) {            committedLog.remove();            minCommittedLog = committedLog.peek().packet.getZxid();        }        if (committedLog.isEmpty()) {            minCommittedLog = request.zxid;            maxCommittedLog = request.zxid;        }        byte[] data = SerializeUtils.serializeRequest(request);        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);        Proposal p = new Proposal();        p.packet = pp;        p.request = request;        committedLog.add(p);        maxCommittedLog = p.packet.getZxid();    } finally {        wl.unlock();    }}
849593715aa5b484ba69ef5dd320a28a6611060512c353a363f5bed07fcf2798
isTxnLogSyncEnabled
public boolean isTxnLogSyncEnabled()
{    boolean enabled = snapshotSizeFactor >= 0;    if (enabled) {        LOG.info("On disk txn sync enabled with snapshotSizeFactor " + snapshotSizeFactor);    } else {        LOG.info("On disk txn sync disabled");    }    return enabled;}
98344d36b2ea1e152d0b9f4f04cec6ce8b32b389d0093d3abc5e8f31e36369cf
calculateTxnLogSizeLimit
public long calculateTxnLogSizeLimit()
{    long snapSize = 0;    try {        File snapFile = snapLog.findMostRecentSnapshot();        if (snapFile != null) {            snapSize = snapFile.length();        }    } catch (IOException e) {        LOG.error("Unable to get size of most recent snapshot");    }    return (long) (snapSize * snapshotSizeFactor);}
b5d33cceca9575cfe90407c4c4d1eea06ff288831b24978fbb9335e94d22f9a9
getProposalsFromTxnLog
public Iterator<Proposal> getProposalsFromTxnLog(long startZxid, long sizeLimit)
{    if (sizeLimit < 0) {        LOG.debug("Negative size limit - retrieving proposal via txnlog is disabled");        return TxnLogProposalIterator.EMPTY_ITERATOR;    }    TxnIterator itr = null;    try {        itr = snapLog.readTxnLog(startZxid, false);                if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {            LOG.warn("Unable to find proposals from txnlog for zxid: " + startZxid);            itr.close();            return TxnLogProposalIterator.EMPTY_ITERATOR;        }        if (sizeLimit > 0) {            long txnSize = itr.getStorageSize();            if (txnSize > sizeLimit) {                LOG.info("Txnlog size: " + txnSize + " exceeds sizeLimit: " + sizeLimit);                itr.close();                return TxnLogProposalIterator.EMPTY_ITERATOR;            }        }    } catch (IOException e) {        LOG.error("Unable to read txnlog from disk", e);        try {            if (itr != null) {                itr.close();            }        } catch (IOException ioe) {            LOG.warn("Error closing file iterator", ioe);        }        return TxnLogProposalIterator.EMPTY_ITERATOR;    }    return new TxnLogProposalIterator(itr);}
812019c9e5ede959315cdaf1d69b138b00cf52a70370dc1f946845c85fbcf0dd
aclForNode
public List<ACL> aclForNode(DataNode n)
{    return dataTree.getACL(n);}
b885136f016ce7614109ddcc9c608b201007131c255988bb2fdc10970e6d0741
removeCnxn
public void removeCnxn(ServerCnxn cnxn)
{    dataTree.removeCnxn(cnxn);}
de55573d9f58d09f16041e29d9ecfb4a04e1be6fd859624bf40acaf962432a2e
killSession
public void killSession(long sessionId, long zxid)
{    dataTree.killSession(sessionId, zxid);}
59a52baae91a6fdb9dbbb9c2fbe63c231bb1711bc6e80addc915f77123c1f636
dumpEphemerals
public void dumpEphemerals(PrintWriter pwriter)
{    dataTree.dumpEphemerals(pwriter);}
c2755b7b00c0543ed659f5cdbcb30aa55f6e2efd5e1b17ebe10bfd6505a86ee2
getEphemerals
public Map<Long, Set<String>> getEphemerals()
{    return dataTree.getEphemerals();}
1b35d3943e93e7bd41c69894e5feefb9a54498a4bfd46389209c1216df41025a
getNodeCount
public int getNodeCount()
{    return dataTree.getNodeCount();}
f1b5efd63d699f8d9cd73fbab3a426ed4dfad71de6f3f9bed1c42aaa72d0bd2e
getEphemerals
public Set<String> getEphemerals(long sessionId)
{    return dataTree.getEphemerals(sessionId);}
89518c2fa2140c32152e8469be61d8cf9f36ed2f1898acd614cbc7fcff070fc0
setlastProcessedZxid
public void setlastProcessedZxid(long zxid)
{    dataTree.lastProcessedZxid = zxid;}
38200ec746103925b24f49baa79d8d5ca2a4aa9d210e417a1dcbeb455eed4d38
processTxn
public ProcessTxnResult processTxn(TxnHeader hdr, Record txn)
{    return dataTree.processTxn(hdr, txn);}
981a59e80f6643cce91a0d8e18a57c2242461141ec151447b77be91de25d872f
statNode
public Stat statNode(String path, ServerCnxn serverCnxn) throws KeeperException.NoNodeException
{    return dataTree.statNode(path, serverCnxn);}
93a20e581cc4a2d091243313b65daaba6fa4444990f81b1408c6a72e894d6d56
getNode
public DataNode getNode(String path)
{    return dataTree.getNode(path);}
e36791dcf003ee2d7f95c7eeb920eddd5544b3ba6e3203b42256907f4031b908
getData
public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getData(path, stat, watcher);}
1668f61ec7ea3753952da743c26469a5d73db71965e13c1efde29893f2e5083e
setWatches
public void setWatches(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    dataTree.setWatches(relativeZxid, dataWatches, existWatches, childWatches, watcher);}
b2465ed801b9722e83b5e921fd46227a30fb2a1d58320d4f1678889f3497c8ad
getACL
public List<ACL> getACL(String path, Stat stat) throws NoNodeException
{    return dataTree.getACL(path, stat);}
b2190cacc155dee623ad49186338866050d573e19c662e3b0d7d966be720d14b
getChildren
public List<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getChildren(path, stat, watcher);}
69087f4a4644958c275904c5e0ac46943733ebb74c32c584dc84f41f3762b4aa
getAllChildrenNumber
public int getAllChildrenNumber(String path) throws KeeperException.NoNodeException
{    return dataTree.getAllChildrenNumber(path);}
ebbbb1989a881da58f10a23cb2e821d39a96845c31debd9a7aa0a04087358807
isSpecialPath
public boolean isSpecialPath(String path)
{    return dataTree.isSpecialPath(path);}
6050b09cfc1a40d321545cc785becfa839deac4985ac4637f618f859dd44e0c5
getAclSize
public int getAclSize()
{    return dataTree.aclCacheSize();}
f6668015d8d8a47df8745d3037b667ac17ecb3550f2b9728df27d7fa09bc3417
truncateLog
public boolean truncateLog(long zxid) throws IOException
{    clear();        boolean truncated = snapLog.truncateLog(zxid);    if (!truncated) {        return false;    }    loadDataBase();    return true;}
2f3472a8f67f1eaf2be10d11a2aafb1c90233162050d7800359ba8255d1671f8
deserializeSnapshot
public void deserializeSnapshot(InputArchive ia) throws IOException
{    clear();    SerializeUtils.deserializeSnapshot(getDataTree(), ia, getSessionWithTimeOuts());    initialized = true;}
85563c0251ef1b8184cb9e55b7da523107719d1c7f6461cbca3b29cb792c5863
serializeSnapshot
public void serializeSnapshot(OutputArchive oa) throws IOException, InterruptedException
{    SerializeUtils.serializeSnapshot(getDataTree(), oa, getSessionWithTimeOuts());}
8f79bde80291d9839ada9ad5e5b53cca94bd063e3a7d06c1ba57ba571917965b
append
public boolean append(Request si) throws IOException
{    txnCount.incrementAndGet();    return this.snapLog.append(si);}
cd4f94fe6aeb66cd1ebbab0dfafcc9fea3ad20b8f993df7acb8d19d414f47fc1
rollLog
public void rollLog() throws IOException
{    this.snapLog.rollLog();    resetTxnCount();}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    this.snapLog.commit();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    this.snapLog.close();}
7b89776a8c5896fc4cf169d13d70c069ce64702a21d72634ffb3456173d69cdc
initConfigInZKDatabase
public synchronized void initConfigInZKDatabase(QuorumVerifier qv)
{    if (qv == null) {                return;    }    try {        if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {                        LOG.warn("configuration znode missing (should only happen during upgrade), creating the node");            this.dataTree.addConfigNode();        }        this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());    } catch (NoNodeException e) {        System.out.println("configuration node missing - should not happen");    }}
159819f360f2b52a9d939d1a8d4ebbcf9436d0818452ae78f80695fc0d2393f1
setSnapshotSizeFactor
public void setSnapshotSizeFactor(double snapshotSizeFactor)
{    this.snapshotSizeFactor = snapshotSizeFactor;}
e3c95dccbf7ac4c9bab2dafb46a76ab3cec25d1288c3187220f2d138d3d3d708
containsWatcher
public boolean containsWatcher(String path, WatcherType type, Watcher watcher)
{    return dataTree.containsWatcher(path, type, watcher);}
c1b10ba9fca4e33b32806ff0caceb17bda156b9262d5854f9e1dda6d29375fa3
removeWatch
public boolean removeWatch(String path, WatcherType type, Watcher watcher)
{    return dataTree.removeWatch(path, type, watcher);}
5a4fd48b2f1deb12201b5af56a1f389e22c90dc44f61f7c6c2e57de7cf3d3b51
createDataTree
public DataTree createDataTree()
{    return new DataTree();}
9f7870471c15c634d6730775458f20c996ba280c53beea8856c8f5707178b077
resetTxnCount
public void resetTxnCount()
{    txnCount.set(0);    snapLog.setTotalLogSize(0);}
be9cf754b2d6e295963cdd1a590b71e20d127a356328ac65f1edc154be900e9e
getTxnCount
public int getTxnCount()
{    return txnCount.get();}
086267f31bde005ea164c617347dbb5754a93f58d3e737c8e0f59d7e074c8fe6
getTxnSize
public long getTxnSize()
{    return snapLog.getTotalLogSize();}
2d769849d4b2fd2a95dbcbeb387d4a14af8a3a1ade5080e085c3204c09a2c4c5
handleException
protected void handleException(String threadName, Throwable e)
{    LOG.error("Severe unrecoverable error, from thread : {}", threadName, e);    listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue());    ServerMetrics.getMetrics().UNRECOVERABLE_ERROR_COUNT.add(1);}
54bf8189c92a1a959d34a1a8b58f37f92b6f6dc8a6f1bc37cf92f77a456c4377
createSaslServer
private SaslServer createSaslServer(final Login login)
{    synchronized (login) {        Subject subject = login.getSubject();        return SecurityUtils.createSaslServer(subject, "zookeeper", "zk-sasl-md5", login.callbackHandler, LOG);    }}
1c263f708f74295d86756090093039fd02ad5f172db418d1b85ffff8f74bdba8
evaluateResponse
public byte[] evaluateResponse(byte[] response) throws SaslException
{    return saslServer.evaluateResponse(response);}
6b8341e3bf79cd81024e28fa7df191b8c1cc2c3e26c486ea6fa2a5e58e89ef5d
isComplete
public boolean isComplete()
{    return saslServer.isComplete();}
4a1d29d789ce0c0cf799c3534b4cc2ab33c00f205b421915994ebcc3e521e1cf
getAuthorizationID
public String getAuthorizationID()
{    return saslServer.getAuthorizationID();}
12f635af6b4914907cfb5726d54301360d5c37e2ed02fe26991de744456dc22d
isCloseSessionTxnEnabled
public static boolean isCloseSessionTxnEnabled()
{    return closeSessionTxnEnabled;}
33f54d481094673c441e3e5f749dced69680aed3de9e8f55f0630dba97f382e6
setCloseSessionTxnEnabled
public static void setCloseSessionTxnEnabled(boolean enabled)
{    ZooKeeperServer.closeSessionTxnEnabled = enabled;    LOG.info("Update {} to {}", CLOSE_SESSION_TXN_ENABLED, ZooKeeperServer.closeSessionTxnEnabled);}
81060f54003d429488485ee5eda7664a140d9946dd5e7a7c86d6369b877f1652
removeCnxn
 void removeCnxn(ServerCnxn cnxn)
{    zkDb.removeCnxn(cnxn);}
325790059f5a28565470268695098e1c1c93b49e375e1585af6007fbd67a53b5
getInitialConfig
public String getInitialConfig()
{    return initialConfig;}
60ebf0f8b9a3f4112b3bd42ac03f3c32e80c7b5e11562c75a38b92cdcb13d21e
serverStats
public ServerStats serverStats()
{    return serverStats;}
80acd449f0b946623eacecf1138722966586cff27d5c7123708662b1ffba236d
getRequestPathMetricsCollector
public RequestPathMetricsCollector getRequestPathMetricsCollector()
{    return requestPathMetricsCollector;}
bfbe6a252ae3c306c9e5547aacb82880c1f77ff4a9ba22d1933c96d13d1f7f04
connThrottle
public BlueThrottle connThrottle()
{    return connThrottle;}
9676c751cfd23b3e9a635c6c412564753bb76ee853dc2dbfd043b7f361b97b38
dumpConf
public void dumpConf(PrintWriter pwriter)
{    pwriter.print("clientPort=");    pwriter.println(getClientPort());    pwriter.print("secureClientPort=");    pwriter.println(getSecureClientPort());    pwriter.print("dataDir=");    pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());    pwriter.print("dataDirSize=");    pwriter.println(getDataDirSize());    pwriter.print("dataLogDir=");    pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());    pwriter.print("dataLogSize=");    pwriter.println(getLogDirSize());    pwriter.print("tickTime=");    pwriter.println(getTickTime());    pwriter.print("maxClientCnxns=");    pwriter.println(getMaxClientCnxnsPerHost());    pwriter.print("minSessionTimeout=");    pwriter.println(getMinSessionTimeout());    pwriter.print("maxSessionTimeout=");    pwriter.println(getMaxSessionTimeout());    pwriter.print("clientPortListenBacklog=");    pwriter.println(getClientPortListenBacklog());    pwriter.print("serverId=");    pwriter.println(getServerId());}
98982bcd0cfffde112341776cea516bf94c1bdb7ab6ae034e9117dbffb776208
getConf
public ZooKeeperServerConf getConf()
{    return new ZooKeeperServerConf(getClientPort(), zkDb.snapLog.getSnapDir().getAbsolutePath(), zkDb.snapLog.getDataDir().getAbsolutePath(), getTickTime(), serverCnxnFactory.getMaxClientCnxnsPerHost(), getMinSessionTimeout(), getMaxSessionTimeout(), getServerId(), getClientPortListenBacklog());}
0a398a5b161acf7b53049b13c6b7c236f158603b5bc782af221df9037a70dec0
getZKDatabase
public ZKDatabase getZKDatabase()
{    return this.zkDb;}
ca9e4799a93474d5a624508d33c2884c2368d7a04cd9e3319e3710009163e9ea
setZKDatabase
public void setZKDatabase(ZKDatabase zkDb)
{    this.zkDb = zkDb;}
b1f309a51f7466164b18138ba34519bc25385cad1e38798d47f07deccf99a7be
loadData
public void loadData() throws IOException, InterruptedException
{    /*         * When a new leader starts executing Leader#lead, it         * invokes this method. The database, however, has been         * initialized before running leader election so that         * the server could pick its zxid for its initial vote.         * It does it by invoking QuorumPeer#getLastLoggedZxid.         * Consequently, we don't need to initialize it once more         * and avoid the penalty of loading it a second time. Not         * reloading it is particularly important for applications         * that host a large database.         *         * The following if block checks whether the database has         * been initialized or not. Note that this method is         * invoked by at least one other method:         * ZooKeeperServer#startdata.         *         * See ZOOKEEPER-1642 for more detail.         */    if (zkDb.isInitialized()) {        setZxid(zkDb.getDataTreeLastProcessedZxid());    } else {        setZxid(zkDb.loadDataBase());    }        List<Long> deadSessions = new ArrayList<>();    for (Long session : zkDb.getSessions()) {        if (zkDb.getSessionWithTimeOuts().get(session) == null) {            deadSessions.add(session);        }    }    for (long session : deadSessions) {                killSession(session, zkDb.getDataTreeLastProcessedZxid());    }        takeSnapshot();}
ce871ccc713e19dc8f7374810b9a60384740793f463cba9e3777e356c109d5c8
takeSnapshot
public void takeSnapshot()
{    takeSnapshot(false);}
dbf954870fd7122e01540d058c634cad268b54fdd96640519aeee0835da8c7c8
takeSnapshot
public void takeSnapshot(boolean syncSnap)
{    long start = Time.currentElapsedTime();    try {        txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), syncSnap);    } catch (IOException e) {        LOG.error("Severe unrecoverable error, exiting", e);                        System.exit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());    }    long elapsed = Time.currentElapsedTime() - start;    LOG.info("Snapshot taken in " + elapsed + " ms");    ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);}
2102436c089af84b36f2055f79a3cac5070b818c7f99cf63cf921d97372f4976
getDataDirSize
public long getDataDirSize()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getDataDir();    return getDirSize(path);}
2e8fdfde7e62021bb8781d1d5aab02c1ce9d03211ba77b88e884724264074cdc
getLogDirSize
public long getLogDirSize()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getSnapDir();    return getDirSize(path);}
e320f851387a34a5a3fe10e7bcddcc4e3e2d50b9239c79cb765e560fea943f58
getDirSize
private long getDirSize(File file)
{    long size = 0L;    if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null) {            for (File f : files) {                size += getDirSize(f);            }        }    } else {        size = file.length();    }    return size;}
801e4e9de7001eb2aab4d5e974b3815294de7fb0baf148bdf44fffbf5d770188
getZxid
public long getZxid()
{    return hzxid.get();}
a43b2afc94a7034848c5889d438d7a71a4f1b3258f97c54b5aacd872e89022d3
getSessionTracker
public SessionTracker getSessionTracker()
{    return sessionTracker;}
0946c71b958e054ae00472c6c7beb85bf88cd46bab0903666f3d1341a0ec3565
getNextZxid
 long getNextZxid()
{    return hzxid.incrementAndGet();}
e3bd3e9577fe712336c9131704b597c473ba312bd38ebd3a5d0c8634c606eb17
setZxid
public void setZxid(long zxid)
{    hzxid.set(zxid);}
39c3e8c9f2329a9cadefe893336c1fe4a455aadf4da54a6793904dbbab748963
close
private void close(long sessionId)
{    Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);    setLocalSessionFlag(si);    submitRequest(si);}
2518f722e79e5d199e7969e30c7a83077bcda9fc21426923ae8576daf217b239
closeSession
public void closeSession(long sessionId)
{    LOG.info("Closing session 0x" + Long.toHexString(sessionId));            close(sessionId);}
e7eb1c767c618a2db453cec5fc977dddaf52f641e3439d546436e9a7f8af4088
killSession
protected void killSession(long sessionId, long zxid)
{    zkDb.killSession(sessionId, zxid);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "ZooKeeperServer --- killSession: 0x" + Long.toHexString(sessionId));    }    if (sessionTracker != null) {        sessionTracker.removeSession(sessionId);    }}
6143978b9aed171a0f1bdcd090bdbdefd04ff2a38cd72557e505df084e82d8b1
expire
public void expire(Session session)
{    long sessionId = session.getSessionId();    LOG.info("Expiring session 0x" + Long.toHexString(sessionId) + ", timeout of " + session.getTimeout() + "ms exceeded");    close(sessionId);}
7dd039eb75e225cd2d2a34cec5c8c6c8ad05094f12a1517cc21750f48651dd98
touch
 void touch(ServerCnxn cnxn) throws MissingSessionException
{    if (cnxn == null) {        return;    }    long id = cnxn.getSessionId();    int to = cnxn.getSessionTimeout();    if (!sessionTracker.touchSession(id, to)) {        throw new MissingSessionException("No session with sessionid 0x" + Long.toHexString(id) + " exists, probably expired and removed");    }}
e6f3bb16f7c86279ca0b0f6bdfc4ca1bbf019bd9710ded3d2320084bbedcc6a2
registerJMX
protected void registerJMX()
{        try {        jmxServerBean = new ZooKeeperServerBean(this);        MBeanRegistry.getInstance().register(jmxServerBean, null);        try {            jmxDataTreeBean = new DataTreeBean(zkDb.getDataTree());            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);        } catch (Exception e) {            LOG.warn("Failed to register with JMX", e);            jmxDataTreeBean = null;        }    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);        jmxServerBean = null;    }}
7512ea7a9b530fea24b731364ad2489f5f0c7cf71d5bdc774c289423492221a0
startdata
public void startdata() throws IOException, InterruptedException
{        if (zkDb == null) {        zkDb = new ZKDatabase(this.txnLogFactory);    }    if (!zkDb.isInitialized()) {        loadData();    }}
da36f3b9d36ac447eb82095d5bedab6921b56e31fcb45bf35d22208f35f9d226
startup
public synchronized void startup()
{    if (sessionTracker == null) {        createSessionTracker();    }    startSessionTracker();    setupRequestProcessors();    startRequestThrottler();    registerJMX();    startJvmPauseMonitor();    registerMetrics();    setState(State.RUNNING);    requestPathMetricsCollector.start();    localSessionEnabled = sessionTracker.isLocalSessionsEnabled();    notifyAll();}
a9b3e42052ee7f6cb98f361df3a7d8ab9066b8f0dce17da42a3c491b7bb102f8
startJvmPauseMonitor
protected void startJvmPauseMonitor()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
758e6e4146e862a74ab05b940147babadd1d2e24295fa1ad3e97c71d9fa123cd
startRequestThrottler
protected void startRequestThrottler()
{    requestThrottler = new RequestThrottler(this);    requestThrottler.start();}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new PrepRequestProcessor(this, syncProcessor);    ((PrepRequestProcessor) firstProcessor).start();}
9353c10bd44608e3c2ba04a5a1a9c49cb37df9796d1029b32f4ae8222b43517f
getZooKeeperServerListener
public ZooKeeperServerListener getZooKeeperServerListener()
{    return listener;}
1890c847ab21924600c6f3669fe8c9dece3e5ca1af884d95a697325b2d674345
setCreateSessionTrackerServerId
public void setCreateSessionTrackerServerId(int newId)
{    createSessionTrackerServerId = newId;}
9174dbc2cbb5913fc4b287726e74f81b60eca185b395506acddbc3e8d70acc7e
createSessionTracker
protected void createSessionTracker()
{    sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(), tickTime, createSessionTrackerServerId, getZooKeeperServerListener());}
1596c867967c4f562c3e42c2ca0b63bf683c41e165b5e6ef1a63600c5b4ad69a
startSessionTracker
protected void startSessionTracker()
{    ((SessionTrackerImpl) sessionTracker).start();}
c1fb0acefc598c56ec326dc3b4778c056ac59608c9aca70ed1d136ac1a0cc817
setState
protected void setState(State state)
{    this.state = state;        if (zkShutdownHandler != null) {        zkShutdownHandler.handle(state);    } else {        LOG.debug("ZKShutdownHandler is not registered, so ZooKeeper server " + "won't take any action on ERROR or SHUTDOWN server state changes");    }}
14df0cc8a2014f964e739b23b67c0342f516e0a61d55894bad3f4e434d873ea4
canShutdown
protected boolean canShutdown()
{    return state == State.RUNNING || state == State.ERROR;}
1cd1b470351cc164620985e84951745a66160c6782dec39e46562afc0eaa2246
isRunning
public boolean isRunning()
{    return state == State.RUNNING;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    shutdown(false);}
02b27ad7ae8acd0ab016066e42fcdf002b78c804c786814dc468b32043089465
shutdown
public synchronized void shutdown(boolean fullyShutDown)
{    if (!canShutdown()) {        LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");        return;    }    LOG.info("shutting down");        setState(State.SHUTDOWN);            unregisterMetrics();    if (requestThrottler != null) {        requestThrottler.shutdown();    }        if (sessionTracker != null) {        sessionTracker.shutdown();    }    if (firstProcessor != null) {        firstProcessor.shutdown();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    if (zkDb != null) {        if (fullyShutDown) {            zkDb.clear();        } else {                        try {                                zkDb.fastForwardDataBase();            } catch (IOException e) {                LOG.error("Error updating DB", e);                zkDb.clear();            }        }    }    requestPathMetricsCollector.shutdown();    unregisterJMX();}
85e7e25a941f134236cd570c8e63b18ce60539fbd1cc088cec570f9a426f4eb3
unregisterJMX
protected void unregisterJMX()
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {        LOG.warn("Failed to unregister with JMX", e);    }    jmxServerBean = null;    jmxDataTreeBean = null;}
c26f815691ec10ceda13aa05eb7307095dfd88737e3b812227f6b84a2e7911c6
incInProcess
public void incInProcess()
{    requestsInProcess.incrementAndGet();}
4a8761d8fd37c664d2b764becf5c0a2e6395338c8a56a19bd46a50d4916e8826
decInProcess
public void decInProcess()
{    requestsInProcess.decrementAndGet();    if (requestThrottler != null) {        requestThrottler.throttleWake();    }}
f4b3252ed1c7fbd5b87656a22d6a5a2eedc7905aab3c50e712101308f4c80111
getInProcess
public int getInProcess()
{    return requestsInProcess.get();}
36226848cc03a6faa6c8e95bc4c48444fd45a8eaab3402f150c015f74d982eb7
getInflight
public int getInflight()
{    return requestThrottleInflight();}
5fed0d70314cf5111d6ba5fabd4144fbdf3eb9bfcf24e37fc501ff41f5966918
requestThrottleInflight
private int requestThrottleInflight()
{    if (requestThrottler != null) {        return requestThrottler.getInflight();    }    return 0;}
5ac965ef5cf5f010f38ea04dd8b8806cf22f4ef88261cafbc64ca0f56f0e0fe7
duplicate
 ChangeRecord duplicate(long zxid)
{    StatPersisted stat = new StatPersisted();    if (this.stat != null) {        DataTree.copyStatPersisted(this.stat, stat);    }    return new ChangeRecord(zxid, path, stat, childCount, acl == null ? new ArrayList<>() : new ArrayList<>(acl));}
7ca2c9cadab8cb7d9e81b68ad081878aafbf5b2b2a849c0e48d9bf057c1afd88
generatePasswd
 byte[] generatePasswd(long id)
{    Random r = new Random(id ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    return p;}
b191996342853b1fe238145c7593b02454aa121e320d87012da0eb998e0f5db3
checkPasswd
protected boolean checkPasswd(long sessionId, byte[] passwd)
{    return sessionId != 0 && Arrays.equals(passwd, generatePasswd(sessionId));}
1e439d9803aa4412bcfb6e3c1ea47ae1fa0edc42a0916432a74e585c0af1dc30
createSession
 long createSession(ServerCnxn cnxn, byte[] passwd, int timeout)
{    if (passwd == null) {                passwd = new byte[0];    }    long sessionId = sessionTracker.createSession(timeout);    Random r = new Random(sessionId ^ superSecret);    r.nextBytes(passwd);    ByteBuffer to = ByteBuffer.allocate(4);    to.putInt(timeout);    cnxn.setSessionId(sessionId);    Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);    setLocalSessionFlag(si);    submitRequest(si);    return sessionId;}
61aae510438cc5b982944248a3c671fdb5dd74bc403f25cd8a0753973b461d9d
setOwner
public void setOwner(long id, Object owner) throws SessionExpiredException
{    sessionTracker.setOwner(id, owner);}
8564f0212992ab8be2b48d947902852b2e350a858bf2d3eb3dc193c9cb325f67
revalidateSession
protected void revalidateSession(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + rc);    }    finishSessionInit(cnxn, rc);}
51b1cf821d0bf310f6af4abd954a55f46086a39c188546f5c9655e6afa14c129
reopenSession
public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd, int sessionTimeout) throws IOException
{    if (checkPasswd(sessionId, passwd)) {        revalidateSession(cnxn, sessionId, sessionTimeout);    } else {        LOG.warn("Incorrect password from " + cnxn.getRemoteSocketAddress() + " for session 0x" + Long.toHexString(sessionId));        finishSessionInit(cnxn, false);    }}
39a6f0148141daadaa6e27304536f24d16258d4ae99cbe82611d5bcbe81f0891
finishSessionInit
public void finishSessionInit(ServerCnxn cnxn, boolean valid)
{        try {        if (valid) {            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {                serverCnxnFactory.registerConnection(cnxn);            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {                secureServerCnxnFactory.registerConnection(cnxn);            }        }    } catch (Exception e) {        LOG.warn("Failed to register with JMX", e);    }    try {        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0,         valid ? cnxn.getSessionId() : 0,         valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);        bos.writeInt(-1, "len");        rsp.serialize(bos, "connect");        if (!cnxn.isOldClient) {            bos.writeBool(this instanceof ReadOnlyZooKeeperServer, "readOnly");        }        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.remaining() - 4).rewind();        cnxn.sendBuffer(bb);        if (valid) {            if (LOG.isDebugEnabled()) {                LOG.debug("Established session 0x" + Long.toHexString(cnxn.getSessionId()) + " with negotiated timeout " + cnxn.getSessionTimeout() + " for client " + cnxn.getRemoteSocketAddress());            }            cnxn.enableRecv();        } else {            LOG.info("Invalid session 0x" + Long.toHexString(cnxn.getSessionId()) + " for client " + cnxn.getRemoteSocketAddress() + ", probably expired");            cnxn.sendBuffer(ServerCnxnFactory.closeConn);        }    } catch (Exception e) {        LOG.warn("Exception while establishing session, closing", e);        cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);    }}
95e4652b2b191618c1b78e1741f2a4ddd31300dcf8cf0885c0a4d15f4ab3b9f5
closeSession
public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader)
{    closeSession(cnxn.getSessionId());}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return 0;}
82e806c9fbe3cb5b84bfaf8af782f9f56b98656d0c5d14022445c91b3362113b
setLocalSessionFlag
protected void setLocalSessionFlag(Request si)
{}
05c91e8f4b123110aab2a85a840c8de16dd95b0bf4d4b293177674c9c960a81d
submitRequest
public void submitRequest(Request si)
{    enqueueRequest(si);}
e928f2064b49b82850a0dd734c6153a58eb5e9bb44b881d9d22355ec98ff19f4
enqueueRequest
public void enqueueRequest(Request si)
{    if (requestThrottler == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                LOG.warn("Unexpected interruption", e);            }            if (requestThrottler == null) {                throw new RuntimeException("Not started");            }        }    }    requestThrottler.submitRequest(si);}
a1f8b68e531c15f918a218e22d017d6239ccfa2002154716c0909bd2867223fc
submitRequestNow
public void submitRequestNow(Request si)
{    if (firstProcessor == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                LOG.warn("Unexpected interruption", e);            }            if (firstProcessor == null || state != State.RUNNING) {                throw new RuntimeException("Not started");            }        }    }    try {        touch(si.cnxn);        boolean validpacket = Request.isValid(si.type);        if (validpacket) {            firstProcessor.processRequest(si);            if (si.cnxn != null) {                incInProcess();            }        } else {            LOG.warn("Received packet at server of unknown type " + si.type);                        requestFinished(si);            new UnimplementedRequestProcessor().processRequest(si);        }    } catch (MissingSessionException e) {        if (LOG.isDebugEnabled()) {            LOG.debug("Dropping request: " + e.getMessage());        }                requestFinished(si);    } catch (RequestProcessorException e) {        LOG.error("Unable to process request:" + e.getMessage(), e);                requestFinished(si);    }}
61e5bc73f45a2f417912ea605be3c6d3d3f9e219104fbf0693c9366bfe9d1e63
getSnapCount
public static int getSnapCount()
{    String sc = System.getProperty(SNAP_COUNT);    try {        int snapCount = Integer.parseInt(sc);                if (snapCount < 2) {            LOG.warn("SnapCount should be 2 or more. Now, snapCount is reset to 2");            snapCount = 2;        }        return snapCount;    } catch (Exception e) {        return 100000;    }}
c9038b65c2f4fbf257d00190088ff8420d485b048bbe0d78c9f47f278fd55fbe
getGlobalOutstandingLimit
public int getGlobalOutstandingLimit()
{    String sc = System.getProperty(GLOBAL_OUTSTANDING_LIMIT);    int limit;    try {        limit = Integer.parseInt(sc);    } catch (Exception e) {        limit = 1000;    }    return limit;}
9e1cb6fcc3a1983c0b9a99932a97ec4312f6693a648c483fcdcf827add27fa2c
getSnapSizeInBytes
public static long getSnapSizeInBytes()
{        long size = Long.getLong("zookeeper.snapSizeLimitInKb", 4194304L);    if (size <= 0) {        LOG.info("zookeeper.snapSizeLimitInKb set to a non-positive value {}; disabling feature", size);    }        return size * 1024;}
bb217bda3b636287a85f241b2cee3235eb4615f29cfaf2fe8c2ae796fee8157a
setServerCnxnFactory
public void setServerCnxnFactory(ServerCnxnFactory factory)
{    serverCnxnFactory = factory;}
3a1312aee775d76247556cdb3c57933eed33f39c5c982d0e8b6c0940a2191bd1
getServerCnxnFactory
public ServerCnxnFactory getServerCnxnFactory()
{    return serverCnxnFactory;}
6d0e74b138755ea57f42a86259cc14c5b19e108aad96cd8dfa1ae3c5bb348687
getSecureServerCnxnFactory
public ServerCnxnFactory getSecureServerCnxnFactory()
{    return secureServerCnxnFactory;}
70c89ee1d852c4c8c1af91d7d511b471f31cbf2bf235f3d7b5b98f23b891305d
setSecureServerCnxnFactory
public void setSecureServerCnxnFactory(ServerCnxnFactory factory)
{    secureServerCnxnFactory = factory;}
3b45c36fc47228f08f8ac1b7a127fa815ed079670744c1959d60562db117f92f
getLastProcessedZxid
public long getLastProcessedZxid()
{    return zkDb.getDataTreeLastProcessedZxid();}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return getInProcess();}
80f15d79a8f066a4ef679f0cbd2626c8f556717c0fc8117787226cdc8dc2a46b
getNumAliveConnections
public int getNumAliveConnections()
{    int numAliveConnections = 0;    if (serverCnxnFactory != null) {        numAliveConnections += serverCnxnFactory.getNumAliveConnections();    }    if (secureServerCnxnFactory != null) {        numAliveConnections += secureServerCnxnFactory.getNumAliveConnections();    }    return numAliveConnections;}
2a6d555585edc1146598601cea6f0155ad4574ad92a862da8a6d44c0f1314969
truncateLog
public void truncateLog(long zxid) throws IOException
{    this.zkDb.truncateLog(zxid);}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
0d6966d4d2bfb5d3b8035f2c56cec288052672eb0e42eb6d15d224b082eb65ea
setTickTime
public void setTickTime(int tickTime)
{    LOG.info("tickTime set to " + tickTime);    this.tickTime = tickTime;}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return minSessionTimeout;}
a03c3c05a71bf800194b521733ced5214de44c096d31920ced1b52e5b654940f
setMinSessionTimeout
public void setMinSessionTimeout(int min)
{    this.minSessionTimeout = min == -1 ? tickTime * 2 : min;    LOG.info("minSessionTimeout set to {}", this.minSessionTimeout);}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
e9b7c64f4f17dddb9212cd8da3a73048bf6c25b41d3a43266bfafdc6e8e0fa48
setMaxSessionTimeout
public void setMaxSessionTimeout(int max)
{    this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;    LOG.info("maxSessionTimeout set to {}", this.maxSessionTimeout);}
ec5585a4b2b943741ce33cf2955fc89a6570f314127c8e967a69575e8e422e3e
getClientPortListenBacklog
public int getClientPortListenBacklog()
{    return listenBacklog;}
4d4e0837f07117cdb2aee64697c76d07d427be9df2abb90f7708dfe90c9902c6
setClientPortListenBacklog
public void setClientPortListenBacklog(int backlog)
{    this.listenBacklog = backlog;    LOG.info("clientPortListenBacklog set to " + backlog);}
d2c843315f9f9d41844653347865765b26cd16135f4af42c425b6d8b969322b1
getClientPort
public int getClientPort()
{    return serverCnxnFactory != null ? serverCnxnFactory.getLocalPort() : -1;}
efcd18490c2af15dfe61bcc96007765dbd9a18656590ce06b2382e44323b1ec6
getSecureClientPort
public int getSecureClientPort()
{    return secureServerCnxnFactory != null ? secureServerCnxnFactory.getLocalPort() : -1;}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    if (serverCnxnFactory != null) {        return serverCnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureServerCnxnFactory != null) {        return secureServerCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
a8d54d8889a1759202db4b703f41d9406f9b99651d7c359060af11896cb09a9d
setTxnLogFactory
public void setTxnLogFactory(FileTxnSnapLog txnLog)
{    this.txnLogFactory = txnLog;}
c93f05070168ba9098442bf123efd3215c3f84d88c592508e5cd3358e3212ff8
getTxnLogFactory
public FileTxnSnapLog getTxnLogFactory()
{    return this.txnLogFactory;}
7864df53f01bb25ce9754b42cd0b1cff9b40d908cb6df9cb4ca1c44b2506cb5c
getTxnLogElapsedSyncTime
public long getTxnLogElapsedSyncTime()
{    return txnLogFactory.getTxnLogElapsedSyncTime();}
d17c12779674ad9289623af81ae67e6c9c3904933cc85d8f41dc5fc3e4d4b729
getState
public String getState()
{    return "standalone";}
59a52baae91a6fdb9dbbb9c2fbe63c231bb1711bc6e80addc915f77123c1f636
dumpEphemerals
public void dumpEphemerals(PrintWriter pwriter)
{    zkDb.dumpEphemerals(pwriter);}
c2755b7b00c0543ed659f5cdbcb30aa55f6e2efd5e1b17ebe10bfd6505a86ee2
getEphemerals
public Map<Long, Set<String>> getEphemerals()
{    return zkDb.getEphemerals();}
d3733fee29905ac920f21bf9cf368e15d4383ea0f5f57e62c591e12542d8d8c6
getConnectionDropChance
public double getConnectionDropChance()
{    return connThrottle.getDropChance();}
8a28446737eba72449f4604301486f44db910670bc30a22f922d9abb2315e3bf
processConnectRequest
public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException, ClientCnxnLimitException
{    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));    ConnectRequest connReq = new ConnectRequest();    connReq.deserialize(bia, "connect");    if (LOG.isDebugEnabled()) {        LOG.debug("Session establishment request from client " + cnxn.getRemoteSocketAddress() + " client's lastZxid is 0x" + Long.toHexString(connReq.getLastZxidSeen()));    }    long sessionId = connReq.getSessionId();    int tokensNeeded = 1;    if (connThrottle.isConnectionWeightEnabled()) {        if (sessionId == 0) {            if (localSessionEnabled) {                tokensNeeded = connThrottle.getRequiredTokensForLocal();            } else {                tokensNeeded = connThrottle.getRequiredTokensForGlobal();            }        } else {            tokensNeeded = connThrottle.getRequiredTokensForRenew();        }    }    if (!connThrottle.checkLimit(tokensNeeded)) {        throw new ClientCnxnLimitException();    }    ServerMetrics.getMetrics().CONNECTION_TOKEN_DEFICIT.add(connThrottle.getDeficit());    ServerMetrics.getMetrics().CONNECTION_REQUEST_COUNT.add(1);    boolean readOnly = false;    try {        readOnly = bia.readBool("readOnly");        cnxn.isOldClient = false;    } catch (IOException e) {                        LOG.warn("Connection request from old client " + cnxn.getRemoteSocketAddress() + "; will be dropped if server is in r-o mode");    }    if (!readOnly && this instanceof ReadOnlyZooKeeperServer) {        String msg = "Refusing session request for not-read-only client " + cnxn.getRemoteSocketAddress();        LOG.info(msg);        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.CLIENT_ZXID_AHEAD);    }    if (connReq.getLastZxidSeen() > zkDb.dataTree.lastProcessedZxid) {        String msg = "Refusing session request for client " + cnxn.getRemoteSocketAddress() + " as it has seen zxid 0x" + Long.toHexString(connReq.getLastZxidSeen()) + " our last zxid is 0x" + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid()) + " client must try another server";        LOG.info(msg);        throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);    }    int sessionTimeout = connReq.getTimeOut();    byte[] passwd = connReq.getPasswd();    int minSessionTimeout = getMinSessionTimeout();    if (sessionTimeout < minSessionTimeout) {        sessionTimeout = minSessionTimeout;    }    int maxSessionTimeout = getMaxSessionTimeout();    if (sessionTimeout > maxSessionTimeout) {        sessionTimeout = maxSessionTimeout;    }    cnxn.setSessionTimeout(sessionTimeout);            cnxn.disableRecv();    if (sessionId == 0) {        long id = createSession(cnxn, passwd, sessionTimeout);        if (LOG.isDebugEnabled()) {            LOG.debug("Client attempting to establish new session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}", Long.toHexString(id), Long.toHexString(connReq.getLastZxidSeen()), connReq.getTimeOut(), cnxn.getRemoteSocketAddress());        }    } else {        long clientSessionId = connReq.getSessionId();        if (LOG.isDebugEnabled()) {            LOG.debug("Client attempting to renew session: session = 0x{}, zxid = 0x{}, timeout = {}, address = {}", Long.toHexString(clientSessionId), Long.toHexString(connReq.getLastZxidSeen()), connReq.getTimeOut(), cnxn.getRemoteSocketAddress());        }        if (serverCnxnFactory != null) {            serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);        }        if (secureServerCnxnFactory != null) {            secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);        }        cnxn.setSessionId(sessionId);        reopenSession(cnxn, sessionId, passwd, sessionTimeout);        ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(1);    }}
c97622e066c095b0c31596ea5da87c7a044fa3f2bdcb7ab89e8e151d15c991a5
shouldThrottle
public boolean shouldThrottle(long outStandingCount)
{    if (getGlobalOutstandingLimit() < getInflight()) {        return outStandingCount > 0;    }    return false;}
eedec735713debfedd6629aa8ce704ec31e63da384b6b031948e910c84845736
getFlushDelay
 long getFlushDelay()
{    return flushDelay;}
c6fa86017eb4b27060735dd2885475b3c4398de63353ad975127e32096ae0d77
setFlushDelay
 static void setFlushDelay(long delay)
{    LOG.info("{}={}", FLUSH_DELAY, delay);    flushDelay = delay;}
9f4449926fd5c78d0a1c97deba027f6eae65f18872b639b909cc5dd418c86cd6
getMaxWriteQueuePollTime
 long getMaxWriteQueuePollTime()
{    return maxWriteQueuePollTime;}
c7cb6aa11d4ec721c2de36677b1cb974a20880b653d1ffdebaeca57d5f23daf4
setMaxWriteQueuePollTime
 static void setMaxWriteQueuePollTime(long maxTime)
{    LOG.info("{}={}", MAX_WRITE_QUEUE_POLL_SIZE, maxTime);    maxWriteQueuePollTime = maxTime;}
9bdde4e2e6876db8c4bb7c446f1047772c984bec98ef6bda0ebab62c0f6bfb2d
getMaxBatchSize
 int getMaxBatchSize()
{    return maxBatchSize;}
bb9477b6925cbb402267bb03057cc81f1431210fb26cda94dc3cd8e3b063cd6d
setMaxBatchSize
 static void setMaxBatchSize(int size)
{    LOG.info("{}={}", MAX_BATCH_SIZE, size);    maxBatchSize = size;}
bb098164173ffc4976fafc9e918d4ab7acaf90ad443c41efc417b0810a0aa4fb
initLargeRequestThrottlingSettings
private void initLargeRequestThrottlingSettings()
{    setLargeRequestMaxBytes(Integer.getInteger("zookeeper.largeRequestMaxBytes", largeRequestMaxBytes));    setLargeRequestThreshold(Integer.getInteger("zookeeper.largeRequestThreshold", -1));}
877bf70967fd68c10bb7779c6b979cae07227fbd574891b447ee4be4880b430d
getLargeRequestMaxBytes
public int getLargeRequestMaxBytes()
{    return largeRequestMaxBytes;}
93afb12de05e6758067598953b1f52b0c113627fa2eee42d45253c879d42cb8b
setLargeRequestMaxBytes
public void setLargeRequestMaxBytes(int bytes)
{    if (bytes <= 0) {        LOG.warn("Invalid max bytes for all large requests {}. It should be a positive number.", bytes);        LOG.warn("Will not change the setting. The max bytes stay at {}", largeRequestMaxBytes);    } else {        largeRequestMaxBytes = bytes;        LOG.info("The max bytes for all large requests are set to {}", largeRequestMaxBytes);    }}
738c76ad62092ddcc7b0848c2b7305a1298b5977df369997514f12d213a81e29
getLargeRequestThreshold
public int getLargeRequestThreshold()
{    return largeRequestThreshold;}
19a8f0ff45397a03e690155451bb2f60425b6fda71e91b648674c9629e4e120d
setLargeRequestThreshold
public void setLargeRequestThreshold(int threshold)
{    if (threshold == 0 || threshold < -1) {        LOG.warn("Invalid large request threshold {}. It should be -1 or positive. Setting to -1 ", threshold);        largeRequestThreshold = -1;    } else {        largeRequestThreshold = threshold;        LOG.info("The large request threshold is set to {}", largeRequestThreshold);    }}
a0fd26aef3126aa4fae8e13414182c48269942a85e912d9adf320a09c1078dd7
getLargeRequestBytes
public int getLargeRequestBytes()
{    return currentLargeRequestBytes.get();}
16b3dc18af38c32a126567382e63f406fc8c37c60ef796f914b1bd0c42dd0a58
isLargeRequest
private boolean isLargeRequest(int length)
{        if (largeRequestThreshold == -1) {        return false;    }    return length > largeRequestThreshold;}
5bffe169dba49c86d8825da706da6ada236f6fccb6543c05d169ef2bc81bdbd7
checkRequestSizeWhenReceivingMessage
public boolean checkRequestSizeWhenReceivingMessage(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    if (currentLargeRequestBytes.get() + length <= largeRequestMaxBytes) {        return true;    } else {        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }}
34d21db586d795f1edeb5b35297778b59fa25a9b46d46bf6b9bb2b5796ec9cec
checkRequestSizeWhenMessageReceived
private boolean checkRequestSizeWhenMessageReceived(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    int bytes = currentLargeRequestBytes.addAndGet(length);    if (bytes > largeRequestMaxBytes) {        currentLargeRequestBytes.addAndGet(-length);        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }    return true;}
fd1df31d2223e16cc97a8f3063c8d3d103aabc9ee7d6e6d5f324a3a5d77f246b
requestFinished
public void requestFinished(Request request)
{    int largeRequestLength = request.getLargeRequestSize();    if (largeRequestLength != -1) {        currentLargeRequestBytes.addAndGet(-largeRequestLength);    }}
bcdaf58c8353e630e823c3f65b6f36765ebaed81b189bf1ad0cf195f15e12d5c
processPacket
public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException
{        InputStream bais = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);    RequestHeader h = new RequestHeader();    h.deserialize(bia, "header");                                        cnxn.incrOutstandingAndCheckThrottle(h);                incomingBuffer = incomingBuffer.slice();    if (h.getType() == OpCode.auth) {        LOG.info("got auth packet " + cnxn.getRemoteSocketAddress());        AuthPacket authPacket = new AuthPacket();        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);        String scheme = authPacket.getScheme();        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);        Code authReturn = KeeperException.Code.AUTHFAILED;        if (ap != null) {            try {                                                authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());            } catch (RuntimeException e) {                LOG.warn("Caught runtime exception from AuthenticationProvider: " + scheme + " due to " + e);                authReturn = KeeperException.Code.AUTHFAILED;            }        }        if (authReturn == KeeperException.Code.OK) {            LOG.debug("Authentication succeeded for scheme: {}", scheme);            LOG.info("auth success " + cnxn.getRemoteSocketAddress());            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());            cnxn.sendResponse(rh, null, null);        } else {            if (ap == null) {                LOG.warn("No authentication provider for scheme: " + scheme + " has " + ProviderRegistry.listProviders());            } else {                LOG.warn("Authentication failed for scheme: " + scheme);            }                        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());            cnxn.sendResponse(rh, null, null);                        cnxn.sendBuffer(ServerCnxnFactory.closeConn);            cnxn.disableRecv();        }        return;    } else if (h.getType() == OpCode.sasl) {        processSasl(incomingBuffer, cnxn, h);    } else {        if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0, Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());            cnxn.sendResponse(replyHeader, null, "response");            cnxn.sendCloseSession();            cnxn.disableRecv();        } else {            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), incomingBuffer, cnxn.getAuthInfo());            int length = incomingBuffer.limit();            if (isLargeRequest(length)) {                                checkRequestSizeWhenMessageReceived(length);                si.setLargeRequestSize(length);            }            si.setOwner(ServerCnxn.me);                                    setLocalSessionFlag(si);            submitRequest(si);        }    }}
11b16ac6730b01aff71dc2d1a82af32edf399847d864872c45f189313117e5b3
shouldAllowSaslFailedClientsConnect
private static boolean shouldAllowSaslFailedClientsConnect()
{    return Boolean.getBoolean(ALLOW_SASL_FAILED_CLIENTS);}
46ccceb3b78a7e1ef28c0fc020c4019cd075e4e72946fe84f49a5515a7222a66
shouldRequireClientSaslAuth
private static boolean shouldRequireClientSaslAuth()
{    return Boolean.getBoolean(SESSION_REQUIRE_CLIENT_SASL_AUTH);}
40527c705c7b985ebccdeb0810817f079b43ea296ddfe89be1b44a9647817bb9
hasCnxSASLAuthenticated
private boolean hasCnxSASLAuthenticated(ServerCnxn cnxn)
{    for (Id id : cnxn.getAuthInfo()) {        if (id.getScheme().equals(SASL_AUTH_SCHEME)) {            return true;        }    }    return false;}
916e3afa278572abcbfb5b72c451360516777c4e51176a88566be673eec902d2
processSasl
private void processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn, RequestHeader requestHeader) throws IOException
{    LOG.debug("Responding to client SASL token.");    GetSASLRequest clientTokenRecord = new GetSASLRequest();    ByteBufferInputStream.byteBuffer2Record(incomingBuffer, clientTokenRecord);    byte[] clientToken = clientTokenRecord.getToken();    LOG.debug("Size of client SASL token: {}", clientToken.length);    byte[] responseToken = null;    try {        ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;        try {                                                responseToken = saslServer.evaluateResponse(clientToken);            if (saslServer.isComplete()) {                String authorizationID = saslServer.getAuthorizationID();                LOG.info("adding SASL authorization for authorizationID: " + authorizationID);                cnxn.addAuthInfo(new Id("sasl", authorizationID));                if (System.getProperty("zookeeper.superUser") != null && authorizationID.equals(System.getProperty("zookeeper.superUser"))) {                    cnxn.addAuthInfo(new Id("super", ""));                }            }        } catch (SaslException e) {            LOG.warn("Client {} failed to SASL authenticate: {}", cnxn.getRemoteSocketAddress(), e);            if (shouldAllowSaslFailedClientsConnect() && !shouldRequireClientSaslAuth()) {                LOG.warn("Maintaining client connection despite SASL authentication failure.");            } else {                int error;                if (shouldRequireClientSaslAuth()) {                    LOG.warn("Closing client connection due to server requires client SASL authenticaiton," + "but client SASL authentication has failed, or client is not configured with SASL " + "authentication.");                    error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();                } else {                    LOG.warn("Closing client connection due to SASL authentication failure.");                    error = Code.AUTHFAILED.intValue();                }                ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);                cnxn.sendResponse(replyHeader, new SetSASLResponse(null), "response");                cnxn.sendCloseSession();                cnxn.disableRecv();                return;            }        }    } catch (NullPointerException e) {        LOG.error("cnxn.saslServer is null: cnxn object did not initialize its saslServer properly.");    }    if (responseToken != null) {        LOG.debug("Size of server SASL response: {}", responseToken.length);    }    ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, Code.OK.intValue());    Record record = new SetSASLResponse(responseToken);    cnxn.sendResponse(replyHeader, record, "response");}
38200ec746103925b24f49baa79d8d5ca2a4aa9d210e417a1dcbeb455eed4d38
processTxn
public ProcessTxnResult processTxn(TxnHeader hdr, Record txn)
{    processTxnForSessionEvents(null, hdr, txn);    return processTxnInDB(hdr, txn);}
e8fcde221b6733af9a9c8ce4c78d9e8b84503c23ddb77d33265aa816514270b4
processTxn
public ProcessTxnResult processTxn(Request request)
{    TxnHeader hdr = request.getHdr();    processTxnForSessionEvents(request, hdr, request.getTxn());    final boolean writeRequest = (hdr != null);    final boolean quorumRequest = request.isQuorum();        if (!writeRequest && !quorumRequest) {        return new ProcessTxnResult();    }    synchronized (outstandingChanges) {        ProcessTxnResult rc = processTxnInDB(hdr, request.getTxn());                if (writeRequest) {            long zxid = hdr.getZxid();            while (!outstandingChanges.isEmpty() && outstandingChanges.peek().zxid <= zxid) {                ChangeRecord cr = outstandingChanges.remove();                ServerMetrics.getMetrics().OUTSTANDING_CHANGES_REMOVED.add(1);                if (cr.zxid < zxid) {                    LOG.warn("Zxid outstanding " + cr.zxid + " is less than current " + zxid);                }                if (outstandingChangesForPath.get(cr.path) == cr) {                    outstandingChangesForPath.remove(cr.path);                }            }        }                if (quorumRequest) {            getZKDatabase().addCommittedProposal(request);        }        return rc;    }}
48308b009410e3d38fd9e9f1f47554dc4462a3dc201aaacd4c622c42037993df
processTxnForSessionEvents
private void processTxnForSessionEvents(Request request, TxnHeader hdr, Record txn)
{    int opCode = (request == null) ? hdr.getType() : request.type;    long sessionId = (request == null) ? hdr.getClientId() : request.sessionId;    if (opCode == OpCode.createSession) {        if (hdr != null && txn instanceof CreateSessionTxn) {            CreateSessionTxn cst = (CreateSessionTxn) txn;            sessionTracker.commitSession(sessionId, cst.getTimeOut());        } else if (request == null || !request.isLocalSession()) {            LOG.warn("*****>>>>> Got " + txn.getClass() + " " + txn.toString());        }    } else if (opCode == OpCode.closeSession) {        sessionTracker.removeSession(sessionId);    }}
1a86b429621c690e7c610a635c3a3e8126e531ba1deddaaf7fd513e00b8ff515
processTxnInDB
private ProcessTxnResult processTxnInDB(TxnHeader hdr, Record txn)
{    if (hdr == null) {        return new ProcessTxnResult();    } else {        return getZKDatabase().processTxn(hdr, txn);    }}
3af14c5b72bdfc3edf46603772a1f71ddd60055b7766802e1ca02228886adc63
getSessionExpiryMap
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return sessionTracker.getSessionExpiryMap();}
db2aa18e290a1546d469be3c03e21e690df17258fef5e646b88dd7f6d249f125
registerServerShutdownHandler
 void registerServerShutdownHandler(ZooKeeperServerShutdownHandler zkShutdownHandler)
{    this.zkShutdownHandler = zkShutdownHandler;}
26f34f1500df7ab7591a97f8d4786bab26cbab46637843e4ef2defaf2ab959fc
isResponseCachingEnabled
public boolean isResponseCachingEnabled()
{    return isResponseCachingEnabled;}
1e5ec4ed3b756efa71a29c172179cdad259e6667a99147afb12134ac888b9715
setResponseCachingEnabled
public void setResponseCachingEnabled(boolean isEnabled)
{    isResponseCachingEnabled = isEnabled;}
785d64768b78a79fd1751c9ea3d782c01447ce1a56266ab9bab8bf9ea4ce3baa
getReadResponseCache
public ResponseCache getReadResponseCache()
{    return isResponseCachingEnabled ? readResponseCache : null;}
79285532c7fb8fc78a40e7457ab3382e4f205c333dc4a989a8d9deb0895c344b
registerMetrics
protected void registerMetrics()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    final ZKDatabase zkdb = this.getZKDatabase();    final ServerStats stats = this.serverStats();    rootContext.registerGauge("avg_latency", stats::getAvgLatency);    rootContext.registerGauge("max_latency", stats::getMaxLatency);    rootContext.registerGauge("min_latency", stats::getMinLatency);    rootContext.registerGauge("packets_received", stats::getPacketsReceived);    rootContext.registerGauge("packets_sent", stats::getPacketsSent);    rootContext.registerGauge("num_alive_connections", stats::getNumAliveClientConnections);    rootContext.registerGauge("outstanding_requests", stats::getOutstandingRequests);    rootContext.registerGauge("uptime", stats::getUptime);    rootContext.registerGauge("znode_count", zkdb::getNodeCount);    rootContext.registerGauge("watch_count", zkdb.getDataTree()::getWatchCount);    rootContext.registerGauge("ephemerals_count", zkdb.getDataTree()::getEphemeralsCount);    rootContext.registerGauge("approximate_data_size", zkdb.getDataTree()::cachedApproximateDataSize);    rootContext.registerGauge("global_sessions", zkdb::getSessionCount);    rootContext.registerGauge("local_sessions", this.getSessionTracker()::getLocalSessionCount);    OSMXBean osMbean = new OSMXBean();    rootContext.registerGauge("open_file_descriptor_count", osMbean::getOpenFileDescriptorCount);    rootContext.registerGauge("max_file_descriptor_count", osMbean::getMaxFileDescriptorCount);    rootContext.registerGauge("connection_drop_probability", this::getConnectionDropChance);    rootContext.registerGauge("last_client_response_size", stats.getClientResponseStats()::getLastBufferSize);    rootContext.registerGauge("max_client_response_size", stats.getClientResponseStats()::getMaxBufferSize);    rootContext.registerGauge("min_client_response_size", stats.getClientResponseStats()::getMinBufferSize);}
7a1592c7f6f4561e51579c42c380094baff7002d616a43b17459fdd0f834dec2
unregisterMetrics
protected void unregisterMetrics()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("avg_latency");    rootContext.unregisterGauge("max_latency");    rootContext.unregisterGauge("min_latency");    rootContext.unregisterGauge("packets_received");    rootContext.unregisterGauge("packets_sent");    rootContext.unregisterGauge("num_alive_connections");    rootContext.unregisterGauge("outstanding_requests");    rootContext.unregisterGauge("uptime");    rootContext.unregisterGauge("znode_count");    rootContext.unregisterGauge("watch_count");    rootContext.unregisterGauge("ephemerals_count");    rootContext.unregisterGauge("approximate_data_size");    rootContext.unregisterGauge("global_sessions");    rootContext.unregisterGauge("local_sessions");    rootContext.unregisterGauge("open_file_descriptor_count");    rootContext.unregisterGauge("max_file_descriptor_count");    rootContext.unregisterGauge("connection_drop_probability");    rootContext.unregisterGauge("last_client_response_size");    rootContext.unregisterGauge("max_client_response_size");    rootContext.unregisterGauge("min_client_response_size");}
97a068231300388a78bf304b913f979af3c1dd05574e3b94738f52ec65f5b8ff
dumpMonitorValues
public void dumpMonitorValues(BiConsumer<String, Object> response)
{    ServerStats stats = serverStats();    response.accept("version", Version.getFullVersion());    response.accept("server_state", stats.getServerState());}
7824efec7f87f36ae80061f418989b096f04d3ae2ca8efd64a2c52e05683ddd0
checkACL
public void checkACL(ServerCnxn cnxn, List<ACL> acl, int perm, List<Id> ids, String path, List<ACL> setAcls) throws KeeperException.NoAuthException
{    if (skipACL) {        return;    }    LOG.debug("Permission requested: {} ", perm);    LOG.debug("ACLs for node: {}", acl);    LOG.debug("Client credentials: {}", ids);    if (acl == null || acl.size() == 0) {        return;    }    for (Id authId : ids) {        if (authId.getScheme().equals("super")) {            return;        }    }    for (ACL a : acl) {        Id id = a.getId();        if ((a.getPerms() & perm) != 0) {            if (id.getScheme().equals("world") && id.getId().equals("anyone")) {                return;            }            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap != null) {                for (Id authId : ids) {                    if (authId.getScheme().equals(id.getScheme()) && ap.matches(new ServerAuthenticationProvider.ServerObjs(this, cnxn), new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {                        return;                    }                }            }        }    }    throw new KeeperException.NoAuthException();}
35e274f2fdde0daa87b2033e02d8c51c8e4aef8987d04cd3b646cf2995362976
isDigestEnabled
public static boolean isDigestEnabled()
{    return digestEnabled;}
8053afda205de1054e538280305f4e47887aa4f3b2a4b1ae7ff49e5338ef81f0
setDigestEnabled
public static void setDigestEnabled(boolean digestEnabled)
{    LOG.info("{} = {}", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);    ZooKeeperServer.digestEnabled = digestEnabled;}
2d6865c51986c47823d43b61f5e148b6e15385b322ec7c9f4e7a09ddd5d99fb9
parentPath
private String parentPath(String path) throws KeeperException.BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || getZKDatabase().isSpecialPath(path)) {        throw new KeeperException.BadArgumentsException(path);    }    return lastSlash == 0 ? "/" : path.substring(0, lastSlash);}
4eaba113c227ea03a52e4e3a058bb2739e649b6ee6cb0ac3e41e2c69de6eb2e4
effectiveACLPath
private String effectiveACLPath(Request request) throws KeeperException.BadArgumentsException, KeeperException.InvalidACLException
{    boolean mustCheckACL = false;    String path = null;    List<ACL> acl = null;    switch(request.type) {        case OpCode.create:        case OpCode.create2:            {                CreateRequest req = new CreateRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = parentPath(req.getPath());                }                break;            }        case OpCode.delete:            {                DeleteRequest req = new DeleteRequest();                if (buffer2Record(request.request, req)) {                    path = parentPath(req.getPath());                }                break;            }        case OpCode.setData:            {                SetDataRequest req = new SetDataRequest();                if (buffer2Record(request.request, req)) {                    path = req.getPath();                }                break;            }        case OpCode.setACL:            {                SetACLRequest req = new SetACLRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = req.getPath();                }                break;            }    }    if (mustCheckACL) {        /* we ignore the extrapolated ACL returned by fixupACL because             * we only care about it being well-formed (and if it isn't, an             * exception will be raised).             */        PrepRequestProcessor.fixupACL(path, request.authInfo, acl);    }    return path;}
0cfd9802aa16a96de5b77f63f207d3c7b95d5f186fcf29235e7b236866a7c8f0
effectiveACLPerms
private int effectiveACLPerms(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:            return ZooDefs.Perms.CREATE;        case OpCode.delete:            return ZooDefs.Perms.DELETE;        case OpCode.setData:            return ZooDefs.Perms.WRITE;        case OpCode.setACL:            return ZooDefs.Perms.ADMIN;        default:            return ZooDefs.Perms.ALL;    }}
655982f828bb11af09bf95cf113f34b2c3e6b74d507675385df343c44ff32ff2
authWriteRequest
public boolean authWriteRequest(Request request)
{    int err;    String pathToCheck;    if (!enableEagerACLCheck) {        return true;    }    err = KeeperException.Code.OK.intValue();    try {        pathToCheck = effectiveACLPath(request);        if (pathToCheck != null) {            checkACL(request.cnxn, zkDb.getACL(pathToCheck, null), effectiveACLPerms(request), request.authInfo, pathToCheck, null);        }    } catch (KeeperException.NoAuthException e) {        LOG.debug("Request failed ACL check", e);        err = e.code().intValue();    } catch (KeeperException.InvalidACLException e) {        LOG.debug("Request has an invalid ACL check", e);        err = e.code().intValue();    } catch (KeeperException.NoNodeException e) {        LOG.debug("ACL check against non-existent node: {}", e.getMessage());    } catch (KeeperException.BadArgumentsException e) {        LOG.debug("ACL check against illegal node path: {}", e.getMessage());    } catch (Throwable t) {        LOG.error("Uncaught exception in authWriteRequest with: ", t);        throw t;    } finally {        if (err != KeeperException.Code.OK.intValue()) {            /*  This request has a bad ACL, so we are dismissing it early. */            decInProcess();            ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);            try {                request.cnxn.sendResponse(rh, null, null);            } catch (IOException e) {                LOG.error("IOException : {}", e);            }        }    }    return err == KeeperException.Code.OK.intValue();}
e65db543db76c57a3fb1daf9551d199c7c3f2e0ebe8a34e68b1329eca616758c
buffer2Record
private boolean buffer2Record(ByteBuffer request, Record record)
{    boolean rv = false;    try {        ByteBufferInputStream.byteBuffer2Record(request, record);        request.rewind();        rv = true;    } catch (IOException ex) {    }    return rv;}
84cf277b9def921bfe4d66c719cd89986452d7048b294931a669ffabed5d5af5
getClientPort
public String getClientPort()
{    return Integer.toString(zks.getClientPort());}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
0ee393bf265f65c3abfbbe35ce5ad7093523258c4d24a9c74f87bf9eddf75822
isHidden
public boolean isHidden()
{    return false;}
8303d5084d47fc5be0af240478176fb41cfc08788476e7a91d731842a77de2c9
getStartTime
public String getStartTime()
{    return startTime.toString();}
446b3b91c7c41085df1dc5542616b89ccd409f6a1d45e4d60d3ca00ac839ecf0
getVersion
public String getVersion()
{    return Version.getFullVersion();}
ecabee80196f5f640e408bc0166d0eab32e5eeb3b0bf0d0faed01fe0acde6117
getAvgRequestLatency
public double getAvgRequestLatency()
{    return zks.serverStats().getAvgLatency();}
6669e2eac507514561af73aa3181909ab3859337e403257a55ebdf7955365fbf
getMaxRequestLatency
public long getMaxRequestLatency()
{    return zks.serverStats().getMaxLatency();}
4e9b2a6571876acbed1750d25c11030d342896b738aa61f2b2845fae392fede6
getMinRequestLatency
public long getMinRequestLatency()
{    return zks.serverStats().getMinLatency();}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return zks.serverStats().getOutstandingRequests();}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return zks.getTickTime();}
0d6966d4d2bfb5d3b8035f2c56cec288052672eb0e42eb6d15d224b082eb65ea
setTickTime
public void setTickTime(int tickTime)
{    zks.setTickTime(tickTime);}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return zks.getMaxClientCnxnsPerHost();}
78da50d2f121d55b38d4ba46ed3b47334752ed03e7f4016471440b07a443e60b
setMaxClientCnxnsPerHost
public void setMaxClientCnxnsPerHost(int max)
{    if (zks.serverCnxnFactory != null) {        zks.serverCnxnFactory.setMaxClientCnxnsPerHost(max);    }    if (zks.secureServerCnxnFactory != null) {        zks.secureServerCnxnFactory.setMaxClientCnxnsPerHost(max);    }}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return zks.getMinSessionTimeout();}
a03c3c05a71bf800194b521733ced5214de44c096d31920ced1b52e5b654940f
setMinSessionTimeout
public void setMinSessionTimeout(int min)
{    zks.setMinSessionTimeout(min);}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return zks.getMaxSessionTimeout();}
e9b7c64f4f17dddb9212cd8da3a73048bf6c25b41d3a43266bfafdc6e8e0fa48
setMaxSessionTimeout
public void setMaxSessionTimeout(int max)
{    zks.setMaxSessionTimeout(max);}
2102436c089af84b36f2055f79a3cac5070b818c7f99cf63cf921d97372f4976
getDataDirSize
public long getDataDirSize()
{    return zks.getDataDirSize();}
2e8fdfde7e62021bb8781d1d5aab02c1ce9d03211ba77b88e884724264074cdc
getLogDirSize
public long getLogDirSize()
{    return zks.getLogDirSize();}
5007fe9fa665c1fbd4284e8036ff281fdd652aceda522cc6df718948fa452aaf
getPacketsReceived
public long getPacketsReceived()
{    return zks.serverStats().getPacketsReceived();}
f229e1433c8ccf0fb3b2afe9022ffc0c9f054fffba05700a51a804fc4a51e991
getPacketsSent
public long getPacketsSent()
{    return zks.serverStats().getPacketsSent();}
648ac8732eb852abc6cc5e6a074e66b24c7f36be4b74b323b5ed30148ed8fd7b
getFsyncThresholdExceedCount
public long getFsyncThresholdExceedCount()
{    return zks.serverStats().getFsyncThresholdExceedCount();}
220d745649fe257794b6f899ab9cc70731b4c48c9d10b8379e39c0f6e3960889
resetLatency
public void resetLatency()
{    zks.serverStats().resetLatency();}
7ba1bb1b210f1e5f6f987b260596adcd0523b72e7c41da7465040dca07f4841e
resetMaxLatency
public void resetMaxLatency()
{    zks.serverStats().resetMaxLatency();}
09137450428aca2f526bae76ca6e96b23f99f76f3015dcd9e02d342b8dc08d64
resetFsyncThresholdExceedCount
public void resetFsyncThresholdExceedCount()
{    zks.serverStats().resetFsyncThresholdExceedCount();}
6796d6969d1871f25466f988d5c9ad5407404d99f3a46ea6887e8a747b489966
resetStatistics
public void resetStatistics()
{    ServerStats serverStats = zks.serverStats();    serverStats.resetRequestCounters();    serverStats.resetLatency();    serverStats.resetFsyncThresholdExceedCount();}
fa9fc34c648bc36dbd319781232ef1032524f107fa3e99caf192df51890ab36b
getNumAliveConnections
public long getNumAliveConnections()
{    return zks.getNumAliveConnections();}
a7edecf0cc3b91423637148e0259b70b5287c49e27e0155a31d141046e6ed7a4
getSecureClientPort
public String getSecureClientPort()
{    if (zks.secureServerCnxnFactory != null) {        return Integer.toString(zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
e3c938ba4dae53426e68fdf12feb5923940566503236ab338ff397499d1c627d
getSecureClientAddress
public String getSecureClientAddress()
{    if (zks.secureServerCnxnFactory != null) {        return String.format("%s:%d", zks.secureServerCnxnFactory.getLocalAddress().getHostString(), zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
7864df53f01bb25ce9754b42cd0b1cff9b40d908cb6df9cb4ca1c44b2506cb5c
getTxnLogElapsedSyncTime
public long getTxnLogElapsedSyncTime()
{    return zks.getTxnLogElapsedSyncTime();}
a9b0bcf9a06db47f43027674d2a967c2d527ccfdf3660fe7a462194c0b7a4af6
getJuteMaxBufferSize
public int getJuteMaxBufferSize()
{    return BinaryInputArchive.maxBuffer;}
70faf099f3bd68e77d4f13aa112a1e1e2d322ffeb501e6c50036e8dd943dd228
getLastClientResponseSize
public int getLastClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getLastBufferSize();}
c1e49c6f196e365bb714f4051bca273d4947d897ece143325f630e9cf3fe996e
getMinClientResponseSize
public int getMinClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getMinBufferSize();}
bce9ba99ddfa741600f1d5263ce49d5c23aa7fc2fde9eda979864f3aeef568b0
getMaxClientResponseSize
public int getMaxClientResponseSize()
{    return zks.serverStats().getClientResponseStats().getMaxBufferSize();}
aaa6b5ffa5de5bbd8f7b542edd5414b7a5d3e82dd50670c8e18a34d7900a50a4
getResponseCachingEnabled
public boolean getResponseCachingEnabled()
{    return zks.isResponseCachingEnabled();}
1e5ec4ed3b756efa71a29c172179cdad259e6667a99147afb12134ac888b9715
setResponseCachingEnabled
public void setResponseCachingEnabled(boolean isEnabled)
{    zks.setResponseCachingEnabled(isEnabled);}
a1970f9fa9179fd5f9fbba8ca513cea880c37137224592687f91b256eaa2b6a4
getConnectionMaxTokens
public int getConnectionMaxTokens()
{    return zks.connThrottle().getMaxTokens();}
d1c4add144d1a174a66557aa2b44067182bfbdfa5b912c481ee26397dd01ed16
setConnectionMaxTokens
public void setConnectionMaxTokens(int val)
{    zks.connThrottle().setMaxTokens(val);}
7f8e8631060a4a70e551f7e58449e49dcc6574a2ed88b182ab927f2ba1b352ce
getConnectionTokenFillTime
public int getConnectionTokenFillTime()
{    return zks.connThrottle().getFillTime();}
afcc9c98ec08a78ce1e0d9d8aa347c44a98e97f455f0d890af352c835100b38a
setConnectionTokenFillTime
public void setConnectionTokenFillTime(int val)
{    zks.connThrottle().setFillTime(val);}
7b8b16784f7569841be27d42ad149669f3cd3fa5b206ec462a655b5ef5b69ca8
getConnectionTokenFillCount
public int getConnectionTokenFillCount()
{    return zks.connThrottle().getFillCount();}
874f91f29047c28e1c9ed52fa6c0b4c53a4996097c5d2e8c8d914c0df7adb5e3
setConnectionTokenFillCount
public void setConnectionTokenFillCount(int val)
{    zks.connThrottle().setFillCount(val);}
81d4a51803b058e7a482eff957792a44c33e04fa995f6912f108acb31201c6f7
getConnectionFreezeTime
public int getConnectionFreezeTime()
{    return zks.connThrottle().getFreezeTime();}
729a17198a7d089ab815950c19a23e5b73504dec6ab11c07503eb0c7bdb98bf8
setConnectionFreezeTime
public void setConnectionFreezeTime(int val)
{    zks.connThrottle().setFreezeTime(val);}
cc11833c4b2d17d3a795c1c71db12219acc041f09dc8d17e4349721f2cb360f3
getConnectionDropIncrease
public double getConnectionDropIncrease()
{    return zks.connThrottle().getDropIncrease();}
c5aab941729ac963d53e7e6a4bd9525dc9230d984968ef00297ea8750c167e46
setConnectionDropIncrease
public void setConnectionDropIncrease(double val)
{    zks.connThrottle().setDropIncrease(val);}
7ec2e7d936905ee450a93f6de83e5414646eb56c30f6e6cd1574f02b6abe5ae7
getConnectionDropDecrease
public double getConnectionDropDecrease()
{    return zks.connThrottle().getDropDecrease();}
6fd0e8c6b033a4405a5d4712e0f9249f3c4cd856ca98d60a899ea3b023f94213
setConnectionDropDecrease
public void setConnectionDropDecrease(double val)
{    zks.connThrottle().setDropDecrease(val);}
708c8230a0ff5484dcc34d05c0f06f71d98bc4f805430e5e6de46f8f20abec07
getConnectionDecreaseRatio
public double getConnectionDecreaseRatio()
{    return zks.connThrottle().getDecreasePoint();}
bb8cda071232b96d49c4457d2b2635ac6436939acc1073d71af2bc0d8b32a369
setConnectionDecreaseRatio
public void setConnectionDecreaseRatio(double val)
{    zks.connThrottle().setDecreasePoint(val);}
3691f6d7ff75373797ad03f4ec5e8b49204e281c364b1d677947d76c06083fb3
getCommitProcMaxReadBatchSize
public int getCommitProcMaxReadBatchSize()
{    return CommitProcessor.getMaxReadBatchSize();}
82d526be3f9911481dbfdfae0761ce5feda09d97faf6302b6bafe0194a8cc533
setCommitProcMaxReadBatchSize
public void setCommitProcMaxReadBatchSize(int size)
{    CommitProcessor.setMaxReadBatchSize(size);}
d7138d04e10ce0dff10ff9bc30ea97f6a5d8fb3f4e1ef7a7c17c9af83a9b44ec
getCommitProcMaxCommitBatchSize
public int getCommitProcMaxCommitBatchSize()
{    return CommitProcessor.getMaxCommitBatchSize();}
0723685d27a88a39f8544ce5848a674de3d6b4e48aba62aa8911422b9f0af025
setCommitProcMaxCommitBatchSize
public void setCommitProcMaxCommitBatchSize(int size)
{    CommitProcessor.setMaxCommitBatchSize(size);}
f3611b2c47bf1a5d2bff9368a33e1e0e4b329910e277c4b8db9b5118915458b3
getFlushDelay
public long getFlushDelay()
{    return zks.getFlushDelay();}
6e32074d2c81c1a95c88628c841fee727bccec5352cdc942cdb5d4f6dce1b7c2
setFlushDelay
public void setFlushDelay(long delay)
{    ZooKeeperServer.setFlushDelay(delay);}
401f2b5500633e3d71991bdba9eb0140ef2bf4914b2dc124bdaf9a4ca886343b
getRequestThrottleLimit
public int getRequestThrottleLimit()
{    return RequestThrottler.getMaxRequests();}
1de48a3fbad8e6829ee6aab3496918d03e681bb7c907ba5bc63b4acbb06c22a1
setRequestThrottleLimit
public void setRequestThrottleLimit(int requests)
{    RequestThrottler.setMaxRequests(requests);}
e6e54f18d220ba73b50bc493d9a87eab5e1f90b051f153f9b1b75754bcf08fd6
getRequestThrottleStallTime
public int getRequestThrottleStallTime()
{    return RequestThrottler.getStallTime();}
55d06a703c27385a9082c85807fc68bcfe992f75bc17234eee0b67c8768ebc0c
setRequestThrottleStallTime
public void setRequestThrottleStallTime(int time)
{    RequestThrottler.setStallTime(time);}
7793d4c1ff5a89d031c5d80e80c747ad28386fdaeb67746f3f64813eb1af9584
getRequestThrottleDropStale
public boolean getRequestThrottleDropStale()
{    return RequestThrottler.getDropStaleRequests();}
6fef30d34bff9d0eb68da3e0113168b39068c4acc9a68d28aaa0d9321c73f069
setRequestThrottleDropStale
public void setRequestThrottleDropStale(boolean drop)
{    RequestThrottler.setDropStaleRequests(drop);}
f0a525799a11fb601c45caeb262a1e21f34077e216f47971e28d03c4d9dd491f
getMaxWriteQueuePollTime
public long getMaxWriteQueuePollTime()
{    return zks.getMaxWriteQueuePollTime();}
58c6830e737e230b389a2054e618b5fdfb31a4aa686d02561d22e2bf0008db64
setMaxWriteQueuePollTime
public void setMaxWriteQueuePollTime(long delay)
{    ZooKeeperServer.setMaxWriteQueuePollTime(delay);}
b5d50d190542dce89d3ee9acb6f817d2ca045b7975f0f0374b114701ad50c1f9
getRequestStaleLatencyCheck
public boolean getRequestStaleLatencyCheck()
{    return Request.getStaleLatencyCheck();}
99a88ce97655cc683a29bf3ad2479a991d8109452242fd0bc7c09d5528085032
setRequestStaleLatencyCheck
public void setRequestStaleLatencyCheck(boolean check)
{    Request.setStaleLatencyCheck(check);}
c93753ecb341c0a2e4936ad5afcd5e9709540a43efb171af12d4feb2c8a14369
getMaxBatchSize
public int getMaxBatchSize()
{    return zks.getMaxBatchSize();}
4609cf0e02b6cafa4cc59e88c1227d9ce3775b2d6a86dcf3ac8e084815061837
setMaxBatchSize
public void setMaxBatchSize(int size)
{    ZooKeeperServer.setMaxBatchSize(size);}
4951d05c2a0a2eb4527e12c8a20e5e73a8a165f2d73df713e05aaa434df195af
getRequestStaleConnectionCheck
public boolean getRequestStaleConnectionCheck()
{    return Request.getStaleConnectionCheck();}
07b99fbe5c808fa0b31275ffe00005ae58f09934c8e4af3e357ab8804464eb53
setRequestStaleConnectionCheck
public void setRequestStaleConnectionCheck(boolean check)
{    Request.setStaleConnectionCheck(check);}
877bf70967fd68c10bb7779c6b979cae07227fbd574891b447ee4be4880b430d
getLargeRequestMaxBytes
public int getLargeRequestMaxBytes()
{    return zks.getLargeRequestMaxBytes();}
93afb12de05e6758067598953b1f52b0c113627fa2eee42d45253c879d42cb8b
setLargeRequestMaxBytes
public void setLargeRequestMaxBytes(int bytes)
{    zks.setLargeRequestMaxBytes(bytes);}
738c76ad62092ddcc7b0848c2b7305a1298b5977df369997514f12d213a81e29
getLargeRequestThreshold
public int getLargeRequestThreshold()
{    return zks.getLargeRequestThreshold();}
19a8f0ff45397a03e690155451bb2f60425b6fda71e91b648674c9629e4e120d
setLargeRequestThreshold
public void setLargeRequestThreshold(int threshold)
{    zks.setLargeRequestThreshold(threshold);}
d2c843315f9f9d41844653347865765b26cd16135f4af42c425b6d8b969322b1
getClientPort
public int getClientPort()
{    return clientPort;}
487706362627b66f0daa4556b6c9ae91ef787ec1e40f5c3c41205cbe864f90bd
getDataDir
public String getDataDir()
{    return dataDir;}
0f9d31cff3d3911a7157e3feddc807fb432a8cf12a85bea586b44adc8ff3a68f
getDataLogDir
public String getDataLogDir()
{    return dataLogDir;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return maxClientCnxnsPerHost;}
f452416df5b2a48a81c8e57811bfdf0d90c2a5f9a3330fbac8902cc1bbac1a16
getMinSessionTimeout
public int getMinSessionTimeout()
{    return minSessionTimeout;}
927bf160e84b121361251aeee71645ba61e2b60a50d95368e7334fcbb49b0246
getMaxSessionTimeout
public int getMaxSessionTimeout()
{    return maxSessionTimeout;}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return serverId;}
ec5585a4b2b943741ce33cf2955fc89a6570f314127c8e967a69575e8e422e3e
getClientPortListenBacklog
public int getClientPortListenBacklog()
{    return clientPortListenBacklog;}
65b9204a280022d9bd71027843cc94ed9c65b18b91c1965857d22b6e4c663772
toMap
public Map<String, Object> toMap()
{    Map<String, Object> conf = new LinkedHashMap<String, Object>();    conf.put(KEY_CLIENT_PORT, clientPort);    conf.put(KEY_DATA_DIR, dataDir);    conf.put(KEY_DATA_LOG_DIR, dataLogDir);    conf.put(KEY_TICK_TIME, tickTime);    conf.put(KEY_MAX_CLIENT_CNXNS, maxClientCnxnsPerHost);    conf.put(KEY_MIN_SESSION_TIMEOUT, minSessionTimeout);    conf.put(KEY_MAX_SESSION_TIMEOUT, maxSessionTimeout);    conf.put(KEY_SERVER_ID, serverId);    conf.put(KEY_CLIENT_PORT_LISTEN_BACKLOG, clientPortListenBacklog);    return conf;}
9bf12ae203d1de27adc4cafbdbafdbe8c826295c4a54e6489d3e5361348aed70
notifyStopping
public void notifyStopping(String threadName, int exitCode)
{    LOG.info("Thread {} exits, error code {}", threadName, exitCode);    zkServer.setState(State.ERROR);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    ZooKeeperServerMain main = new ZooKeeperServerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {        LOG.error("Invalid arguments, exiting abnormally", e);        LOG.info(USAGE);        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {        LOG.error("Invalid config, exiting abnormally", e);        System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {        LOG.error("Unable to access datadir, exiting abnormally", e);        System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {        LOG.error("Unable to start AdminServer, exiting abnormally", e);        System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {        LOG.error("Unexpected exception, exiting abnormally", e);        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    LOG.info("Exiting normally");    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
6d39fb3cad6019ff86a2d18a5659592a40234f6f04afecb6902f3b0683b24103
initializeAndRun
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {        LOG.warn("Unable to register log4j JMX control", e);    }    ServerConfig config = new ServerConfig();    if (args.length == 1) {        config.parse(args[0]);    } else {        config.parse(args);    }    runFromConfig(config);}
71881b0e18e35fd7d337fec2bc63316cca4ec62d3d52ae9921393c72decf6287
runFromConfig
public void runFromConfig(ServerConfig config) throws IOException, AdminServerException
{    LOG.info("Starting server");    FileTxnSnapLog txnLog = null;    try {        try {            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());        } catch (MetricsProviderLifeCycleException error) {            throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);        }        ServerMetrics.metricsProviderInitialized(metricsProvider);                                        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);        JvmPauseMonitor jvmPauseMonitor = null;        if (config.jvmPauseMonitorToRun) {            jvmPauseMonitor = new JvmPauseMonitor(config);        }        final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);        txnLog.setServerStats(zkServer.serverStats());                        final CountDownLatch shutdownLatch = new CountDownLatch(1);        zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));                adminServer = AdminServerFactory.createAdminServer();        adminServer.setZooKeeperServer(zkServer);        adminServer.start();        boolean needStartZKServer = true;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);            cnxnFactory.startup(zkServer);                        needStartZKServer = false;        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);            secureCnxnFactory.startup(zkServer, needStartZKServer);        }        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();                        shutdownLatch.await();        shutdown();        if (cnxnFactory != null) {            cnxnFactory.join();        }        if (secureCnxnFactory != null) {            secureCnxnFactory.join();        }        if (zkServer.canShutdown()) {            zkServer.shutdown(true);        }    } catch (InterruptedException e) {                LOG.warn("Server interrupted", e);    } finally {        if (txnLog != null) {            txnLog.close();        }        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                LOG.warn("Error while stopping metrics", error);            }        }    }}
334f60bd8bd8074ae7d3989caf3b2754f8cd195b04950c05d9a881ec12b17817
shutdown
protected void shutdown()
{    if (containerManager != null) {        containerManager.stop();    }    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }    try {        if (adminServer != null) {            adminServer.shutdown();        }    } catch (AdminServerException e) {        LOG.warn("Problem stopping AdminServer", e);    }}
034b1c3b47a9c067bf023cbaecaf6dea7932d969ef1661edd7d103df9b3782fc
getCnxnFactory
 ServerCnxnFactory getCnxnFactory()
{    return cnxnFactory;}
1ee593438addec04e074bd7670b3ed8df9c89d03b31fe7fd3fab3ce9c0c562c4
handle
 void handle(State state)
{    if (state == State.ERROR || state == State.SHUTDOWN) {        shutdownLatch.countDown();    }}
f9e4832777f7af0982d696c7b64bd6626ebb43207fc112505ab6b4630a9e3d35
uncaughtException
public void uncaughtException(Thread t, Throwable e)
{    handleException(t.getName(), e);}
8477e27bf2041a51b5bf41aca4a9fdcab86719dd3dad230f1581d2bda0e4b693
handleException
protected void handleException(String thName, Throwable e)
{    LOG.warn("Exception occurred from thread {}", thName, e);}
b0d4bd6534c5f951b7225a596bc098a994b158da3f45d4c18b47129e0c40756c
getTextTraceLevel
public static synchronized long getTextTraceLevel()
{    return traceMask;}
7d2f4ca567071e9aa45a17b23139f75a39e0b4422be116aca32f9e5e7cae9ac9
setTextTraceLevel
public static synchronized void setTextTraceLevel(long mask)
{    traceMask = mask;    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);    LOG.info("Set text trace mask to 0x" + Long.toHexString(mask));}
87a3b32d11efdf5e86a9f8295435ddca46d2cc59643d2d72fb73e76020616567
isTraceEnabled
public static synchronized boolean isTraceEnabled(Logger log, long mask)
{    return log.isTraceEnabled() && (mask & traceMask) != 0;}
9ea515fee8d2fc64a4b965c87e19e211d830cf68d681b2448349bd19d8469946
logTraceMessage
public static void logTraceMessage(Logger log, long mask, String msg)
{    if (isTraceEnabled(log, mask)) {        log.trace(msg);    }}
7143213e85812f7eb5f05d8a197df9b54513e2bfc1981096fe73c53ffd0e46e8
logQuorumPacket
public static void logQuorumPacket(Logger log, long mask, char direction, QuorumPacket qp)
{    if (isTraceEnabled(log, mask)) {        logTraceMessage(log, mask, direction + " " + LearnerHandler.packetToString(qp));    }}
048117f8ffa5ab2d123ec5f9443805ec468b1ed7a86adcd38b3a4855acaaeefe
logRequest
public static void logRequest(Logger log, long mask, char rp, Request request, String header)
{    if (isTraceEnabled(log, mask)) {        log.trace(header + ":" + rp + request.toString());    }}
7443597c5baa997ba4a458114af643c53550f496c940e9c9ae4fa3cbbe2453d8
ruok
public static void ruok(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("ruok".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
7fe0ba45a552c40f5c91851dec9ed3ca97536dfd74ed819016b35623ae6804c9
dump
public static void dump(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("dump".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
7aa44d8c39af526654a963e75ab6176b7d39b5226c9ce9bfbff548abfa2bb2f3
stat
public static void stat(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("stat".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
7b55c2df60c19cb85530b0b035d12462cbef21135d36d49f2e58e9e526b214b4
kill
public static void kill(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("kill".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
e26e3e1b2d67280e909fe07e68c1a8f84c496080e1fd4c23c62b5831b8123917
setTraceMask
public static void setTraceMask(String host, int port, String traceMaskStr)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        long traceMask = Long.parseLong(traceMaskStr, 8);        req.putInt(ByteBuffer.wrap("stmk".getBytes()).getInt());        req.putLong(traceMask);        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv) + " masks=0" + Long.toOctalString(traceMask));        assert (retv == traceMask);    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
f6d5b868d095a14d9272c1143248486bf9d89cbb6d5d304d4db60a4cd6fc7c9f
getTraceMask
public static void getTraceMask(String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("gtmk".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv));    } catch (IOException e) {        LOG.warn("Unexpected exception", e);    } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                LOG.warn("Unexpected exception", e);            }        }    }}
6c655505072f20944de454aea0c62e0c64dc3a771527717e8ff71d825b651203
usage
private static void usage()
{    System.out.println("usage: java [-cp CLASSPATH] org.apache.zookeeper.ServerAdminClient " + "host port op (ruok|stat|dump|kill|gettracemask|settracemask) [arguments]");}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length < 3) {        usage();        return;    }    String host = args[0];    int port = Integer.parseInt(args[1]);    String op = args[2];    if (op.equalsIgnoreCase("gettracemask")) {        getTraceMask(host, port);    } else if (op.equalsIgnoreCase("settracemask")) {        setTraceMask(host, port, args[3]);    } else if (op.equalsIgnoreCase("ruok")) {        ruok(host, port);    } else if (op.equalsIgnoreCase("kill")) {        kill(host, port);    } else if (op.equalsIgnoreCase("stat")) {        stat(host, port);    } else if (op.equalsIgnoreCase("dump")) {        dump(host, port);    } else {        System.out.println("Unrecognized op: " + op);    }}
11380623e6cf484f1b09c5fec65f33c740bac1553eb7a177f905cb0828a615de
getGroupsCommand
public static String[] getGroupsCommand()
{    return new String[] { "bash", "-c", "groups" };}
aec0ef92b9cc075548800da663c629a939d3ffabe6aeb201ba18493312f1d41e
getGroupsForUserCommand
public static String[] getGroupsForUserCommand(final String user)
{        return new String[] { "bash", "-c", "id -Gn " + user };}
6d97de3cfdebf160a8fc3e18ef35d4633eb933ac6ab73dc43403f478ba6aec92
getGET_PERMISSION_COMMAND
public static String[] getGET_PERMISSION_COMMAND()
{        return new String[] { (WINDOWS ? "ls" : "/bin/ls"), "-ld" };}
75298257ba613cd33e10e68978a375eba8d1705736cdecb76e6a8e0823e2cca1
getUlimitMemoryCommand
public static String[] getUlimitMemoryCommand(int memoryLimit)
{        if (WINDOWS) {        return null;    }    return new String[] { ULIMIT_COMMAND, "-v", String.valueOf(memoryLimit) };}
bda03b8572559f5e2866fb0905adc5792290968f22d2c8d2fcaabefcb3bddd62
setEnvironment
protected void setEnvironment(Map<String, String> env)
{    this.environment = env;}
b04098907d2e55720b622a6274a0da3b76bbfa9b2f07ef2e9ad3fc187abfaf4b
setWorkingDirectory
protected void setWorkingDirectory(File dir)
{    this.dir = dir;}
3199d5deda69a3b52f68cf8f3f84bd60b85dc49a47ad812c346c9288398a154a
run
protected void run() throws IOException
{    if (lastTime + interval > Time.currentElapsedTime()) {        return;    }        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    runCommand();}
24420ae538c22b142585076e0738984e3c63c3000c57ee364c701f735ea49939
runCommand
private void runCommand() throws IOException
{    ProcessBuilder builder = new ProcessBuilder(getExecString());    Timer timeOutTimer = null;    ShellTimeoutTimerTask timeoutTimerTask = null;    timedOut = new AtomicBoolean(false);    completed = new AtomicBoolean(false);    if (environment != null) {        builder.environment().putAll(this.environment);    }    if (dir != null) {        builder.directory(this.dir);    }    process = builder.start();    if (timeOutInterval > 0) {        timeOutTimer = new Timer();        timeoutTimerTask = new ShellTimeoutTimerTask(this);                timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);    }    final BufferedReader errReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));    BufferedReader inReader = new BufferedReader(new InputStreamReader(process.getInputStream()));    final StringBuffer errMsg = new StringBuffer();            Thread errThread = new Thread() {        @Override        public void run() {            try {                String line = errReader.readLine();                while ((line != null) && !isInterrupted()) {                    errMsg.append(line);                    errMsg.append(System.getProperty("line.separator"));                    line = errReader.readLine();                }            } catch (IOException ioe) {                LOG.warn("Error reading the error stream", ioe);            }        }    };    try {        errThread.start();    } catch (IllegalStateException ise) {    }    try {                parseExecResult(inReader);                String line = inReader.readLine();        while (line != null) {            line = inReader.readLine();        }                exitCode = process.waitFor();        try {                        errThread.join();        } catch (InterruptedException ie) {            LOG.warn("Interrupted while reading the error stream", ie);        }        completed.set(true);                if (exitCode != ExitCode.EXECUTION_FINISHED.getValue()) {            throw new ExitCodeException(exitCode, errMsg.toString());        }    } catch (InterruptedException ie) {        throw new IOException(ie.toString());    } finally {        if ((timeOutTimer != null) && !timedOut.get()) {            timeOutTimer.cancel();        }                try {            inReader.close();        } catch (IOException ioe) {            LOG.warn("Error while closing the input stream", ioe);        }        if (!completed.get()) {            errThread.interrupt();        }        try {            errReader.close();        } catch (IOException ioe) {            LOG.warn("Error while closing the error stream", ioe);        }        process.destroy();        lastTime = Time.currentElapsedTime();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        String line = errReader.readLine();        while ((line != null) && !isInterrupted()) {            errMsg.append(line);            errMsg.append(System.getProperty("line.separator"));            line = errReader.readLine();        }    } catch (IOException ioe) {        LOG.warn("Error reading the error stream", ioe);    }}
2957c50a3f8238c79aa64e4fae02b8507f8d78723276f49017299fba47fa7f03
getProcess
public Process getProcess()
{    return process;}
5e3ba7e60b4abd2e6f951792ccf4acc15a3126f7d3eff8cac85e8d00388c4378
getExitCode
public int getExitCode()
{    return exitCode;}
5e3ba7e60b4abd2e6f951792ccf4acc15a3126f7d3eff8cac85e8d00388c4378
getExitCode
public int getExitCode()
{    return exitCode;}
70f18b10576e78b485cc9e360188384750a8d98a8ff4d82191e25c5952b05cd5
execute
public void execute() throws IOException
{    this.run();}
ae9045ec6a54a5839ccaf19137ac0f57e108817fec17c0755db4d28c0c195d1d
getExecString
protected String[] getExecString()
{    return command;}
b12aaf58da173353615c793a52a6a530222bec746d1ae8fb68b993c4fd9ff487
parseExecResult
protected void parseExecResult(BufferedReader lines) throws IOException
{    output = new StringBuffer();    char[] buf = new char[512];    int nRead;    while ((nRead = lines.read(buf, 0, buf.length)) > 0) {        output.append(buf, 0, nRead);    }}
d50b6d29ac37cfa68ef4739158c0c2870add3c542392976cbe2f04d503807c32
getOutput
public String getOutput()
{    return (output == null) ? "" : output.toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    String[] args = getExecString();    for (String s : args) {        if (s.indexOf(' ') >= 0) {            builder.append('"').append(s).append('"');        } else {            builder.append(s);        }        builder.append(' ');    }    return builder.toString();}
8042bda2a2bb0121986f307c80fac4cb6ed29438f001664c4f4ff20354712149
isTimedOut
public boolean isTimedOut()
{    return timedOut.get();}
501c373f51a85530d8f5eeca28a36bfec92656eec9341452cd54e65752a8c22d
setTimedOut
private void setTimedOut()
{    this.timedOut.set(true);}
029cfe8b8671590175081876620e8d1e7d66b901121a2de4376d042c2f5d1447
execCommand
public static String execCommand(String... cmd) throws IOException
{    return execCommand(null, cmd, 0L);}
5976a285af88bfbfb50f67be6acef0f004b91195cd9c5374009abbbcf3f99598
execCommand
public static String execCommand(Map<String, String> env, String[] cmd, long timeout) throws IOException
{    ShellCommandExecutor exec = new ShellCommandExecutor(cmd, null, env, timeout);    exec.execute();    return exec.getOutput();}
98949c5eecb044ea7d65662d855e264656c43ecdcef8aa561e74345f2071eb61
execCommand
public static String execCommand(Map<String, String> env, String... cmd) throws IOException
{    return execCommand(env, cmd, 0L);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Process p = shell.getProcess();    try {        p.exitValue();    } catch (Exception e) {                if (p != null && !shell.completed.get()) {            shell.setTimedOut();            p.destroy();        }    }}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return this.count;}
252b9f86c92f6b1c8a0c8f316498fec361f0c1c4e7aabab47583f0d4590afe5b
setCount
public void setCount(int count)
{    this.count = count;}
d76f2a28457ae5f0f402725b61a4d97e33efca7db9cd57dc63c19e0e302ac7d7
getBytes
public long getBytes()
{    return this.bytes;}
374425cd379384ced1101e70fe54721b205e7cf050f288702a2a27da5e92f200
setBytes
public void setBytes(long bytes)
{    this.bytes = bytes;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return countStr + "=" + count + "," + byteStr + "=" + bytes;}
54932ee3711119c21c298461d43c6412594690f73464efcb0337792490af64b2
create
public Transaction create(final String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    ops.add(Op.create(path, data, acl, createMode.toFlag()));    return this;}
7ab4dd27d722cc03848058949cdc9f12a9cdf44bdef27c44cd1a4e1704dc4dae
delete
public Transaction delete(final String path, int version)
{    ops.add(Op.delete(path, version));    return this;}
1ca2b109c84d593cea20991f0b29a79d970a7bd99108ebecfef0fa51dd7dfd1b
check
public Transaction check(String path, int version)
{    ops.add(Op.check(path, version));    return this;}
7b6afd367c3dfcb79782f785ee284b96d2a04423a08f222bacaff349bc41de7b
setData
public Transaction setData(final String path, byte[] data, int version)
{    ops.add(Op.setData(path, data, version));    return this;}
af022fd62acdea725fc164cbadf27e4e07e211c997e278a2be1411169976999a
commit
public List<OpResult> commit() throws InterruptedException, KeeperException
{    return zk.multi(ops);}
88e1fe970506c7e9ac0d213fcb086733cab09e59e5f6baa56f192115d08d05f5
commit
public void commit(MultiCallback cb, Object ctx)
{    zk.multi(ops, cb, ctx);}
1f2b473df3df04380f0be7230d602705d8afcf1a8b949c2daee4e255032b4924
loadTrustStore
public static KeyStore loadTrustStore(File certificateChainFile) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    for (X509Certificate certificate : certificateChain) {        X500Principal principal = certificate.getSubjectX500Principal();        keyStore.setCertificateEntry(principal.getName("RFC2253"), certificate);    }    return keyStore;}
59d0a0d55b37664e5bdddf2467a26e047db004cbd31ea9be5996aa6dc7892ee5
loadKeyStore
public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    if (certificateChain.isEmpty()) {        throw new CertificateException("Certificate file does not contain any certificates: " + certificateChainFile);    }    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    keyStore.setKeyEntry("key", key, keyPassword.orElse("").toCharArray(), certificateChain.toArray(new Certificate[0]));    return keyStore;}
d0e14b3da55d10835600e29cad08c8774f12ecb07369adafb369af267b2cfa9c
readCertificateChain
public static List<X509Certificate> readCertificateChain(File certificateChainFile) throws IOException, GeneralSecurityException
{    String contents = new String(Files.readAllBytes(certificateChainFile.toPath()), US_ASCII);    return readCertificateChain(contents);}
b7b03aaa48d3e25d1d8df0392f682c75ba833d8c2a2d067bea464f60eed89bd8
readCertificateChain
public static List<X509Certificate> readCertificateChain(String certificateChain) throws CertificateException
{    Matcher matcher = CERT_PATTERN.matcher(certificateChain);    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");    List<X509Certificate> certificates = new ArrayList<>();    int start = 0;    while (matcher.find(start)) {        byte[] buffer = base64Decode(matcher.group(1));        certificates.add((X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(buffer)));        start = matcher.end();    }    return certificates;}
fb9d1bd585a20e6a2dcd754f77f32ab2c93a55a0afb22933f274aa60005be9ee
loadPrivateKey
public static PrivateKey loadPrivateKey(File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    String privateKey = new String(Files.readAllBytes(privateKeyFile.toPath()), US_ASCII);    return loadPrivateKey(privateKey, keyPassword);}
4425f55931024522bddf8b60aa20b2323972d0486032fbf9be019138c8e095e7
loadPrivateKey
public static PrivateKey loadPrivateKey(String privateKey, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    Matcher matcher = PRIVATE_KEY_PATTERN.matcher(privateKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a private key");    }    byte[] encodedKey = base64Decode(matcher.group(1));    PKCS8EncodedKeySpec encodedKeySpec;    if (keyPassword.isPresent()) {        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(encodedKey);        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());        SecretKey secretKey = keyFactory.generateSecret(new PBEKeySpec(keyPassword.get().toCharArray()));        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName());        cipher.init(DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters());        encodedKeySpec = encryptedPrivateKeyInfo.getKeySpec(cipher);    } else {        encodedKeySpec = new PKCS8EncodedKeySpec(encodedKey);    }        try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePrivate(encodedKeySpec);}
002f3e00237c4be36475ef411b909c9efba2d3fe6675016e656f9b0a803e3313
loadPublicKey
public static PublicKey loadPublicKey(File publicKeyFile) throws IOException, GeneralSecurityException
{    String publicKey = new String(Files.readAllBytes(publicKeyFile.toPath()), US_ASCII);    return loadPublicKey(publicKey);}
5bcc0730dfce6973fe3c8d84e4095da8007a07c75bb03daa25a62ce95fdf9265
loadPublicKey
public static PublicKey loadPublicKey(String publicKey) throws GeneralSecurityException
{    Matcher matcher = PUBLIC_KEY_PATTERN.matcher(publicKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a public key");    }    String data = matcher.group(1);    byte[] encodedKey = base64Decode(data);    X509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(encodedKey);    try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePublic(encodedKeySpec);}
1ac6cb69a6ef4e0c21dfcba94c3d906727b12df86824e572f4433f0f9383fbfe
base64Decode
private static byte[] base64Decode(String base64)
{    return getMimeDecoder().decode(base64.getBytes(US_ASCII));}
19518eb3fddbb4224e78fcfede1fdbbeb725bb71bcb8fdd0700ff4267a1fff79
createSaslClient
public static SaslClient createSaslClient(final Subject subject, final String servicePrincipal, final String protocol, final String serverName, final Logger LOG, final String entity) throws SaslException
{    SaslClient saslClient;        if (subject.getPrincipals().isEmpty()) {                        LOG.info("{} will use DIGEST-MD5 as SASL mechanism.", entity);        String[] mechs = { "DIGEST-MD5" };        String username = (String) (subject.getPublicCredentials().toArray()[0]);        String password = (String) (subject.getPrivateCredentials().toArray()[0]);                saslClient = Sasl.createSaslClient(mechs, username, protocol, serverName, null, new SaslClientCallbackHandler(password, entity));        return saslClient;    } else {                final Object[] principals = subject.getPrincipals().toArray();                final Principal clientPrincipal = (Principal) principals[0];        boolean usingNativeJgss = Boolean.getBoolean("sun.security.jgss.native");        if (usingNativeJgss) {                        try {                GSSManager manager = GSSManager.getInstance();                Oid krb5Mechanism = new Oid("1.2.840.113554.1.2.2");                GSSCredential cred = manager.createCredential(null, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.INITIATE_ONLY);                subject.getPrivateCredentials().add(cred);                LOG.debug("Added private credential to {} principal name: '{}'", entity, clientPrincipal);            } catch (GSSException ex) {                LOG.warn("Cannot add private credential to subject; authentication at the server may fail", ex);            }        }        final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());                                String serverRealm = System.getProperty("zookeeper.server.realm", clientKerberosName.getRealm());        KerberosName serviceKerberosName = new KerberosName(servicePrincipal + "@" + serverRealm);        final String serviceName = serviceKerberosName.getServiceName();        final String serviceHostname = serviceKerberosName.getHostName();        final String clientPrincipalName = clientKerberosName.toString();        try {            saslClient = Subject.doAs(subject, new PrivilegedExceptionAction<SaslClient>() {                public SaslClient run() throws SaslException {                    LOG.info("{} will use GSSAPI as SASL mechanism.", entity);                    String[] mechs = { "GSSAPI" };                    LOG.debug("creating sasl client: {}={};service={};serviceHostname={}", entity, clientPrincipalName, serviceName, serviceHostname);                    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));                    return saslClient;                }            });            return saslClient;        } catch (Exception e) {            LOG.error("Exception while trying to create SASL client", e);            return null;        }    }}
3c464f6b7107361766f27c3db96775d505aebf73165def1dd65c20ac766d2a2a
run
public SaslClient run() throws SaslException
{    LOG.info("{} will use GSSAPI as SASL mechanism.", entity);    String[] mechs = { "GSSAPI" };    LOG.debug("creating sasl client: {}={};service={};serviceHostname={}", entity, clientPrincipalName, serviceName, serviceHostname);    SaslClient saslClient = Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null, new SaslClientCallbackHandler(null, entity));    return saslClient;}
2a99fe2c2c0c9fecb7dcaf2b7662a1431600b1de11d13dc30be591dab2a5ecda
createSaslServer
public static SaslServer createSaslServer(final Subject subject, final String protocol, final String serverName, final CallbackHandler callbackHandler, final Logger LOG)
{    if (subject != null) {                if (subject.getPrincipals().size() > 0) {            try {                final Object[] principals = subject.getPrincipals().toArray();                final Principal servicePrincipal = (Principal) principals[0];                                                final String servicePrincipalNameAndHostname = servicePrincipal.getName();                int indexOf = servicePrincipalNameAndHostname.indexOf("/");                                final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);                                                final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1);                indexOf = serviceHostnameAndKerbDomain.indexOf("@");                                final String serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOf);                                                final String mech = "GSSAPI";                LOG.debug("serviceHostname is '{}'", serviceHostname);                LOG.debug("servicePrincipalName is '{}'", servicePrincipalName);                LOG.debug("SASL mechanism(mech) is '{}'", mech);                boolean usingNativeJgss = Boolean.getBoolean("sun.security.jgss.native");                if (usingNativeJgss) {                                        try {                        GSSManager manager = GSSManager.getInstance();                        Oid krb5Mechanism = new Oid("1.2.840.113554.1.2.2");                        GSSName gssName = manager.createName(servicePrincipalName + "@" + serviceHostname, GSSName.NT_HOSTBASED_SERVICE);                        GSSCredential cred = manager.createCredential(gssName, GSSContext.DEFAULT_LIFETIME, krb5Mechanism, GSSCredential.ACCEPT_ONLY);                        subject.getPrivateCredentials().add(cred);                        LOG.debug("Added private credential to service principal name: '{}'," + " GSSCredential name: {}", servicePrincipalName, cred.getName());                    } catch (GSSException ex) {                        LOG.warn("Cannot add private credential to subject; clients authentication may fail", ex);                    }                }                try {                    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {                        public SaslServer run() {                            try {                                SaslServer saslServer;                                saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);                                return saslServer;                            } catch (SaslException e) {                                LOG.error("Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: ", e);                                return null;                            }                        }                    });                } catch (PrivilegedActionException e) {                                        LOG.error("Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context:", e);                }            } catch (IndexOutOfBoundsException e) {                LOG.error("server principal name/hostname determination error: ", e);            }        } else {                        try {                SaslServer saslServer = Sasl.createSaslServer("DIGEST-MD5", protocol, serverName, null, callbackHandler);                return saslServer;            } catch (SaslException e) {                LOG.error("Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation", e);            }        }    }    return null;}
15f8873f243cb22ba64575fda2f81041f23dbfc17a87b2287431f6cd9e5cc469
run
public SaslServer run()
{    try {        SaslServer saslServer;        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);        return saslServer;    } catch (SaslException e) {        LOG.error("Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: ", e);        return null;    }}
b1dcffec715f826e78978f36fad46f385edc72dc453a500f2ff5add160c49c08
getServerPrincipal
public static String getServerPrincipal(String principalConfig, String hostname)
{    String[] components = getComponents(principalConfig);    if (components == null || components.length != 2 || !components[1].equals(QUORUM_HOSTNAME_PATTERN)) {        return principalConfig;    } else {        return replacePattern(components, hostname);    }}
b15b13de156ad556b3265b81df9a86a9af9dd2bef2d5e02d6c6a4144d5040902
getComponents
private static String[] getComponents(String principalConfig)
{    if (principalConfig == null) {        return null;    }    return principalConfig.split("[/]");}
5b817dda24cde8ab16c620b5c0c03ce1aabc308c53c0b5e376431c23360d9d51
replacePattern
private static String replacePattern(String[] components, String hostname)
{    return components[0] + "/" + hostname.toLowerCase();}
8e29584f151dc80a8ba21f7b5b273050efae239cf9263a6e82a701b3dd60529b
printUsage
 static void printUsage()
{    System.out.print("Usage:\tjava  -cp <classpath> org.apache.zookeeper." + "version.util.VerGen maj.min.micro[-qualifier] rev buildDate outputDirectory");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
2dd0e29781cbf48e17dee9920cc9617b17ad857dd474f918abe6741bed285835
parseVersionString
public static Version parseVersionString(String input)
{    Version result = new Version();    Pattern p = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)((\\.\\d+)*)(-(.+))?$");    Matcher m = p.matcher(input);    if (!m.matches()) {        return null;    }    result.maj = Integer.parseInt(m.group(1));    result.min = Integer.parseInt(m.group(2));    result.micro = Integer.parseInt(m.group(3));    if (m.groupCount() == 7) {        result.qualifier = m.group(7);    } else {        result.qualifier = null;    }    return result;}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length != 4) {        printUsage();    }    try {        Version version = parseVersionString(args[0]);        if (version == null) {            System.err.println("Invalid version number format, must be \"x.y.z(-.*)?\"");            System.exit(ExitCode.UNEXPECTED_ERROR.getValue());        }        String rev = args[1];        if (rev == null || rev.trim().isEmpty()) {            rev = "-1";        } else {            rev = rev.trim();        }        generateFile(new File(args[3]), version, rev, args[2]);    } catch (NumberFormatException e) {        System.err.println("All version-related parameters must be valid integers!");        throw e;    }}
b37a8b4be28c58aa754618548e7c804ce495d7fdddccbdae8a82819de2550758
getRevisionHash
public static String getRevisionHash()
{    return REVISION_HASH;}
8ba788e795f782132234a9e85f3b78050b56e201c1f751c765c6dd040cd0f5e3
getBuildDate
public static String getBuildDate()
{    return BUILD_DATE;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return MAJOR + "." + MINOR + "." + MICRO + (QUALIFIER == null ? "" : "-" + QUALIFIER);}
572d3222cb72753d354c323e9c5ce31cf28ea03e72c7cc8009a93c021ead7eb8
getVersionRevision
public static String getVersionRevision()
{    return getVersion() + "-" + getRevisionHash();}
ef2cbcaec08e15fbaf275d9a909a6af60f554959629a593b392853f6ff3b1d71
getFullVersion
public static String getFullVersion()
{    return getVersionRevision() + ", built on " + getBuildDate();}
5bd7cde0f316de1cacc1db662c03a9ac91a5481ba738ff77f581e37e32be3e05
printUsage
public static void printUsage()
{    System.out.print("Usage:\tjava -cp ... org.apache.zookeeper.Version " + "[--full | --short | --revision],\n\tPrints --full version " + "info if no arg specified.");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length > 1) {        printUsage();    }    if (args.length == 0 || (args.length == 1 && args[0].equals("--full"))) {        System.out.println(getFullVersion());        System.exit(ExitCode.EXECUTION_FINISHED.getValue());    }    if (args[0].equals("--short")) {        System.out.println(getVersion());    } else if (args[0].equals("--revision")) {        System.out.println(getVersionRevision());    } else {        printUsage();    }    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
85bd00e57cc67f83fc4ed8f9f16d9138f2810ec1f137f69231b94b093cd46ffa
unregister
public Map<EventType, Set<Watcher>> unregister(int rc) throws KeeperException
{    return zkManager.removeWatcher(clientPath, watcher, watcherType, local, rc);}
38e39da68b3ca060770b5f5329c2246757123cea1afc95fdd6c5c6b253a7f23d
getClientPath
public String getClientPath()
{    return clientPath;}
7f58583ebbba9491f36c626217644ef7a7eb6c142fd5213bfe1f0c8c676778ca
getState
public KeeperState getState()
{    return keeperState;}
7a080c6be310604b769adfad665291ec2b11994ee67993dac1738c1b193fd2ea
getType
public EventType getType()
{    return eventType;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "WatchedEvent state:" + keeperState + " type:" + eventType + " path:" + path;}
31a98ffd2b386d6d3a1ababc3c64797ce5c4d7a92945f3401df7f80ee29b932d
getWrapper
public WatcherEvent getWrapper()
{    return new WatcherEvent(eventType.getIntValue(), keeperState.getIntValue(), path);}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return intValue;}
5c1463c9ee521bf601808b7dba331254c9076589c0bb205520374d3d635afd8d
fromInt
public static KeeperState fromInt(int intValue)
{    switch(intValue) {        case -1:            return KeeperState.Unknown;        case 0:            return KeeperState.Disconnected;        case 1:            return KeeperState.NoSyncConnected;        case 3:            return KeeperState.SyncConnected;        case 4:            return KeeperState.AuthFailed;        case 5:            return KeeperState.ConnectedReadOnly;        case 6:            return KeeperState.SaslAuthenticated;        case -112:            return KeeperState.Expired;        case 7:            return KeeperState.Closed;        default:            throw new RuntimeException("Invalid integer value for conversion to KeeperState");    }}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return intValue;}
87c2017656f599eee5782adb1c4c11ac2064e394ce96e37e67d92a893d3523e9
fromInt
public static EventType fromInt(int intValue)
{    switch(intValue) {        case -1:            return EventType.None;        case 1:            return EventType.NodeCreated;        case 2:            return EventType.NodeDeleted;        case 3:            return EventType.NodeDataChanged;        case 4:            return EventType.NodeChildrenChanged;        case 5:            return EventType.DataWatchRemoved;        case 6:            return EventType.ChildWatchRemoved;        default:            throw new RuntimeException("Invalid integer value for conversion to EventType");    }}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return intValue;}
271d3b810d12bd89457ae4604c021b54a89ef25f88ed0c2b6e8a180f41e28874
fromInt
public static WatcherType fromInt(int intValue)
{    switch(intValue) {        case 1:            return WatcherType.Children;        case 2:            return WatcherType.Data;        case 3:            return WatcherType.Any;        default:            throw new RuntimeException("Invalid integer value for conversion to WatcherType");    }}
ef2c7671c53d0f648b5650dd375f31de4b42bb57295c49b25fea2c1494f9a7af
deleteRecursive
public static boolean deleteRecursive(ZooKeeper zk, final String pathRoot, final int batchSize) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);    LOG.debug("Deleting tree: {}", tree);    return deleteInBatch(zk, tree, batchSize);}
f62aebc585961ba0bb2b9d85868ab28d1874e5045c16a885c38f0f37d9a755f8
deleteInBatch
private static boolean deleteInBatch(ZooKeeper zk, List<String> tree, int batchSize) throws InterruptedException
{    int rateLimit = 10;    List<Op> ops = new ArrayList<>();    BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit);    MultiCallback cb = (rc, path, ctx, opResults) -> {        ((BatchedDeleteCbContext) ctx).sem.release();        if (rc != Code.OK.intValue()) {            ((BatchedDeleteCbContext) ctx).success.set(false);        }    };        for (int i = tree.size() - 1; i >= 0; --i) {                ops.add(Op.delete(tree.get(i), -1));        if (ops.size() == batchSize || i == 0) {            if (!context.success.get()) {                                break;            }            context.sem.acquire();            zk.multi(ops, cb, context);            ops = new ArrayList<>();        }    }        context.sem.acquire(rateLimit);    return context.success.get();}
401ad2974704bdd3240abb3e68ff8abcb3f37bcda2dd28a95f55541dd5027eef
deleteRecursive
public static void deleteRecursive(ZooKeeper zk, final String pathRoot, VoidCallback cb, Object ctx) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);    LOG.debug("Deleting tree: {}", tree);    for (int i = tree.size() - 1; i >= 0; --i) {                        zk.delete(tree.get(i), -1, cb, ctx);    }}
c65cf7a740a73a59dc494b29b9d23da67826c7d91bff7d6d7c7fd83840249ae5
validateFileInput
public static String validateFileInput(String filePath)
{    File file = new File(filePath);    if (!file.exists()) {        return "File '" + file.getAbsolutePath() + "' does not exist.";    }    if (!file.canRead()) {        return "Read permission is denied on the file '" + file.getAbsolutePath() + "'";    }    if (file.isDirectory()) {        return "'" + file.getAbsolutePath() + "' is a direcory. it must be a file.";    }    return null;}
00bf8a79db7c67bd5294069306f318a99309be3f7da4703f2c0455dd8dfaf916
listSubTreeBFS
public static List<String> listSubTreeBFS(ZooKeeper zk, final String pathRoot) throws KeeperException, InterruptedException
{    Queue<String> queue = new ArrayDeque<>();    List<String> tree = new ArrayList<String>();    queue.add(pathRoot);    tree.add(pathRoot);    while (!queue.isEmpty()) {        String node = queue.poll();        List<String> children = zk.getChildren(node, false);        for (final String child : children) {            final String childPath = node + "/" + child;            queue.add(childPath);            tree.add(childPath);        }    }    return tree;}
33b7b9196eb27aeeb6a5fa3372beae0fd55a6483bd0729c2ecc158a4c9af4a67
visitSubTreeDFS
public static void visitSubTreeDFS(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{    PathUtils.validatePath(path);    zk.getData(path, watch, null);    cb.processResult(Code.OK.intValue(), path, null, path);    visitSubTreeDFSHelper(zk, path, watch, cb);}
ee57303d3d2376b80dfed0d376e9dd16fbdb646a4ace2ba0453f0fa7fd76c7b1
visitSubTreeDFSHelper
private static void visitSubTreeDFSHelper(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{        final boolean isRoot = path.length() == 1;    try {        List<String> children = zk.getChildren(path, watch, null);        Collections.sort(children);        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            cb.processResult(Code.OK.intValue(), childPath, null, child);        }        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            visitSubTreeDFSHelper(zk, childPath, watch, cb);        }    } catch (KeeperException.NoNodeException e) {                return;    }}
871f40ee6761d6e981d0b3211f28d2890c5afaf895df203f6bb9a2c7a7c5fd16
updateServerList
public void updateServerList(String connectString) throws IOException
{    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);    Collection<InetSocketAddress> serverAddresses = connectStringParser.getServerAddresses();    ClientCnxnSocket clientCnxnSocket = cnxn.sendThread.getClientCnxnSocket();    InetSocketAddress currentHost = (InetSocketAddress) clientCnxnSocket.getRemoteSocketAddress();    boolean reconfigMode = hostProvider.updateServerList(serverAddresses, currentHost);        if (reconfigMode) {        clientCnxnSocket.testableCloseSocket();    }}
263a623710314f7c06d26ebbbada7bed12a494a6aa09ccfa952958e441d44e86
getSaslClient
public ZooKeeperSaslClient getSaslClient()
{    return cnxn.zooKeeperSaslClient;}
645be4e67d0bd969ae26015680eb978eba745b870410e3698dde58d74a971802
getClientConfig
public ZKClientConfig getClientConfig()
{    return clientConfig;}
76eb4a1e42d80024284d0b31a2c7320692d511fd9acf3ebeb3a6e524ff964e46
getDataWatches
protected List<String> getDataWatches()
{    synchronized (watchManager.dataWatches) {        List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());        return rc;    }}
bb4b8b09be7b27ef02b8c87579f60e0a484714411cfd453f6642fdf5cb1cc940
getExistWatches
protected List<String> getExistWatches()
{    synchronized (watchManager.existWatches) {        List<String> rc = new ArrayList<String>(watchManager.existWatches.keySet());        return rc;    }}
7bf4d41254f4d406b9e1ee1d178de9f77a7ee1ba9e1441865eea1c94a34dfe1a
getChildWatches
protected List<String> getChildWatches()
{    synchronized (watchManager.childWatches) {        List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());        return rc;    }}
2175bc9bbbe425efef49fc57470cc2b811a337e0512d5d7ab8bae3f70415020e
addTo
private void addTo(Set<Watcher> from, Set<Watcher> to)
{    if (from != null) {        to.addAll(from);    }}
4b5751602aa6137df9d40d3cfb6ed49bfb9a5d4e6d7bf8849f1c54f48c0dfbf4
removeWatcher
public Map<EventType, Set<Watcher>> removeWatcher(String clientPath, Watcher watcher, WatcherType watcherType, boolean local, int rc) throws KeeperException
{            containsWatcher(clientPath, watcher, watcherType);    Map<EventType, Set<Watcher>> removedWatchers = new HashMap<>();    HashSet<Watcher> childWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.ChildWatchRemoved, childWatchersToRem);    HashSet<Watcher> dataWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.DataWatchRemoved, dataWatchersToRem);    boolean removedWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    removedWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                break;            }        case Any:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                synchronized (dataWatches) {                    boolean removedDataWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }            }    }        if (!removedWatcher) {        throw new KeeperException.NoWatcherException(clientPath);    }    return removedWatchers;}
d4043102a518aa63f590bf38368d736c48fcc3e12f78c8b7c82f504fb5f5a4d9
contains
private boolean contains(String path, Watcher watcherObj, Map<String, Set<Watcher>> pathVsWatchers)
{    boolean watcherExists = true;    if (pathVsWatchers == null || pathVsWatchers.size() == 0) {        watcherExists = false;    } else {        Set<Watcher> watchers = pathVsWatchers.get(path);        if (watchers == null) {            watcherExists = false;        } else if (watcherObj == null) {            watcherExists = watchers.size() > 0;        } else {            watcherExists = watchers.contains(watcherObj);        }    }    return watcherExists;}
1834da3422066075b329743bd061288bd366855c027bac2935f9205b998b6a03
containsWatcher
 void containsWatcher(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{    boolean containsWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    containsWatcher = contains(path, watcher, dataWatches);                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }                break;            }        case Any:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                synchronized (dataWatches) {                    boolean contains_temp = contains(path, watcher, dataWatches);                    containsWatcher |= contains_temp;                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }            }    }        if (!containsWatcher) {        throw new KeeperException.NoWatcherException(path);    }}
9c66cda96acbd45cf15a1a36872dc9053b706fd45a78c29d0e820ceb4be50f78
removeWatches
protected boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    if (!local && rc != Code.OK.intValue()) {        throw KeeperException.create(KeeperException.Code.get(rc), path);    }    boolean success = false;        if (rc == Code.OK.intValue() || (local && rc != Code.OK.intValue())) {                if (watcher == null) {            Set<Watcher> pathWatchers = pathVsWatcher.remove(path);            if (pathWatchers != null) {                                removedWatchers.addAll(pathWatchers);                success = true;            }        } else {            Set<Watcher> watchers = pathVsWatcher.get(path);            if (watchers != null) {                if (watchers.remove(watcher)) {                                        removedWatchers.add(watcher);                                        if (watchers.size() <= 0) {                        pathVsWatcher.remove(path);                    }                    success = true;                }            }        }    }    return success;}
7e8e23fcc6d4760d574078da256f996abe45a53356034a5c8f7db072841de800
materialize
public Set<Watcher> materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath)
{    Set<Watcher> result = new HashSet<Watcher>();    switch(type) {        case None:            result.add(defaultWatcher);            boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected;            synchronized (dataWatches) {                for (Set<Watcher> ws : dataWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    dataWatches.clear();                }            }            synchronized (existWatches) {                for (Set<Watcher> ws : existWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    existWatches.clear();                }            }            synchronized (childWatches) {                for (Set<Watcher> ws : childWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    childWatches.clear();                }            }            return result;        case NodeDataChanged:        case NodeCreated:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }            synchronized (existWatches) {                addTo(existWatches.remove(clientPath), result);            }            break;        case NodeChildrenChanged:            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        case NodeDeleted:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }                        synchronized (existWatches) {                Set<Watcher> list = existWatches.remove(clientPath);                if (list != null) {                    addTo(list, result);                    LOG.warn("We are triggering an exists watch for delete! Shouldn't happen!");                }            }            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        default:            String msg = "Unhandled watch event type " + type + " with state " + state + " on path " + clientPath;            LOG.error(msg);            throw new RuntimeException(msg);    }    return result;}
e7c6aed1038727f0303a02dc7ff9e6a9003772e562f24095c8fb22311bbc0053
register
public void register(int rc)
{    if (shouldAddWatch(rc)) {        Map<String, Set<Watcher>> watches = getWatches(rc);        synchronized (watches) {            Set<Watcher> watchers = watches.get(clientPath);            if (watchers == null) {                watchers = new HashSet<Watcher>();                watches.put(clientPath, watchers);            }            watchers.add(watcher);        }    }}
7e1a2f3dfb82e6f95574af4a12ddc359b98dfc891368f524d2db6dee7fc22bde
shouldAddWatch
protected boolean shouldAddWatch(int rc)
{    return rc == 0;}
109be519642d743bc79c0e9eeb5e38afb3d3aa7954e80c544ec73cfeb2a8f404
getWatches
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return rc == 0 ? watchManager.dataWatches : watchManager.existWatches;}
7e1a2f3dfb82e6f95574af4a12ddc359b98dfc891368f524d2db6dee7fc22bde
shouldAddWatch
protected boolean shouldAddWatch(int rc)
{    return rc == 0 || rc == KeeperException.Code.NONODE.intValue();}
109be519642d743bc79c0e9eeb5e38afb3d3aa7954e80c544ec73cfeb2a8f404
getWatches
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return watchManager.dataWatches;}
109be519642d743bc79c0e9eeb5e38afb3d3aa7954e80c544ec73cfeb2a8f404
getWatches
protected Map<String, Set<Watcher>> getWatches(int rc)
{    return watchManager.childWatches;}
60197635298ccb91f8d31ad041ff050b33a738f730a72b1ee2ddf49ee0d11ce3
isAlive
public boolean isAlive()
{    return this != CLOSED && this != AUTH_FAILED;}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return this == CONNECTED || this == CONNECTEDREADONLY;}
0da12011de919fb00b90d3ea1da8079b870e716885cdde554abc38004b6045c7
createConnection
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new ClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watchManager, clientCnxnSocket, canBeReadOnly);}
466e48e132fcaa276984cc0c2bb111ddd0dc1611bc5b97cc8514e0f9c6dba009
createDefaultHostProvider
private static HostProvider createDefaultHostProvider(String connectString)
{    return new StaticHostProvider(new ConnectStringParser(connectString).getServerAddresses());}
00745d0499f147fad2a4fe59fd0f87e1da9c59eeedee44362d631d7cf7c612f2
getTestable
public Testable getTestable()
{    return new ZooKeeperTestable(cnxn);}
bda02a3ea0e0ab53be6e5b77665e95118f57af03867550ad7569e3efbbe81f3c
defaultWatchManager
protected ZKWatchManager defaultWatchManager()
{    return new ZKWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return cnxn.getSessionId();}
f35819e64c2a1cfd4033576f52f4fbb8d80247066288cdac11e1bda4ed1f744f
getSessionPasswd
public byte[] getSessionPasswd()
{    return cnxn.getSessionPasswd();}
2436723c695636833e0ebfc52d684cb9ae4da078ffa3153b560d8213802ad011
getSessionTimeout
public int getSessionTimeout()
{    return cnxn.getSessionTimeout();}
1d08df4181b86f11812fd75c46b00e31a77c03804d14cfd9fae13865e8302bad
addAuthInfo
public void addAuthInfo(String scheme, byte[] auth)
{    cnxn.addAuthInfo(scheme, auth);}
658d0f983b7fdb24376685566f5f4af5f23f02e95c67ebaa65849214761f5fae
register
public synchronized void register(Watcher watcher)
{    watchManager.defaultWatcher = watcher;}
3cc59dbf86e75b9868827b28362533d64c83a39c2f84caf36843b9026a5d4bcf
close
public synchronized void close() throws InterruptedException
{    if (!cnxn.getState().isAlive()) {        LOG.debug("Close called on already closed client");        return;    }    if (LOG.isDebugEnabled()) {        LOG.debug("Closing session: 0x" + Long.toHexString(getSessionId()));    }    try {        cnxn.close();    } catch (IOException e) {        LOG.debug("Ignoring unexpected exception during close", e);    }    LOG.info("Session: 0x" + Long.toHexString(getSessionId()) + " closed");}
d6246bc2641676ec01115cfdb896356efcda150d7296cee7e24a187a5a0418d0
close
public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException
{    close();    return testableWaitForShutdown(waitForShutdownTimeoutMs);}
c3d530f230eeee1aa1d20b8a82eab884694b21a7245881e33d1380f9136a8d07
prependChroot
private String prependChroot(String clientPath)
{    if (cnxn.chrootPath != null) {                if (clientPath.length() == 1) {            return cnxn.chrootPath;        }        return cnxn.chrootPath + clientPath;    } else {        return clientPath;    }}
9e798c03dab401699521d1398b74951dae26853cc55f5f92d4fd0117c61dba80
create
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
67e82583851f8488a065a02f69628f96ade61e4fcebfc5e4f12c10f9e291aa97
create
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat) throws KeeperException, InterruptedException
{    return create(path, data, acl, createMode, stat, -1);}
ed0fbc18d69613d072497f1fa11846179d4c5eb72b9c41c6cae4ab8990088d29
create
public String create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat, long ttl) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    ReplyHeader r = cnxn.submitRequest(h, record, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
30b034fbce6ee4285a2c473d5aedc0f7034c5b3e69fd6a8494a3716763a5d62e
setCreateHeader
private void setCreateHeader(CreateMode createMode, RequestHeader h)
{    if (createMode.isTTL()) {        h.setType(ZooDefs.OpCode.createTTL);    } else {        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create2);    }}
8d38ba4effa7c353bd889618bd11435240659661eee0cbc99c0f4a00fbab985a
makeCreateRecord
private Record makeCreateRecord(CreateMode createMode, String serverPath, byte[] data, List<ACL> acl, long ttl)
{    Record record;    if (createMode.isTTL()) {        CreateTTLRequest request = new CreateTTLRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        request.setTtl(ttl);        record = request;    } else {        CreateRequest request = new CreateRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        record = request;    }    return record;}
fe71c6421573c3048d8f7f19b6c05f2038069a80dce78c7df8d052a3834ce002
create
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, StringCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    ReplyHeader r = new ReplyHeader();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, null);}
586bb627744195eda8453ad57e244f3204aca78f35c705b021a12aa7c5d3f10e
create
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx)
{    create(path, data, acl, createMode, cb, ctx, -1);}
c7724227c95e0d3afbe1b351ffcf79b6654c5d865423162682d824efec89dd42
create
public void create(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx, long ttl)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    ReplyHeader r = new ReplyHeader();    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    cnxn.queuePacket(h, r, record, response, cb, clientPath, serverPath, ctx, null);}
236b60f10d7bb6d4850976d86df0fb9883b1437974084e04b089497446639ff6
delete
public void delete(final String path, int version) throws InterruptedException, KeeperException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    ReplyHeader r = cnxn.submitRequest(h, request, null, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
633ef8821d96060d3bf60e3f115f59708c0f7c5c550bc01404d4a5f74809bb4d
multi
public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException
{    for (Op op : ops) {        op.validate();    }    return multiInternal(generateMultiTransaction(ops));}
90b02fe910541932965bbca7f53cf03a32b4964ff6012c0afaebc3c3e9b2ceff
multi
public void multi(Iterable<Op> ops, MultiCallback cb, Object ctx)
{    List<OpResult> results = validatePath(ops);    if (results.size() > 0) {        cb.processResult(KeeperException.Code.BADARGUMENTS.intValue(), null, ctx, results);        return;    }    multiInternal(generateMultiTransaction(ops), cb, ctx);}
a2a228785f8c4cbb645d282bd090e0749188a3b6455e8b5ccb633044582e734a
validatePath
private List<OpResult> validatePath(Iterable<Op> ops)
{    List<OpResult> results = new ArrayList<OpResult>();    boolean error = false;    for (Op op : ops) {        try {            op.validate();        } catch (IllegalArgumentException iae) {            LOG.error("IllegalArgumentException: " + iae.getMessage());            ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());            results.add(err);            error = true;            continue;        } catch (KeeperException ke) {            LOG.error("KeeperException: " + ke.getMessage());            ErrorResult err = new ErrorResult(ke.code().intValue());            results.add(err);            error = true;            continue;        }        ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        results.add(err);    }    if (!error) {        results.clear();    }    return results;}
ca4fa25744471935f758a981d9e1c784cc5def43e5e7b5dde2c51490805b6fe7
generateMultiTransaction
private MultiOperationRecord generateMultiTransaction(Iterable<Op> ops)
{        List<Op> transaction = new ArrayList<Op>();    for (Op op : ops) {        transaction.add(withRootPrefix(op));    }    return new MultiOperationRecord(transaction);}
327030c2d392294fd1c01bfb08431717f4cf14bb7b16f68698c64eed1809bae8
withRootPrefix
private Op withRootPrefix(Op op)
{    if (null != op.getPath()) {        final String serverPath = prependChroot(op.getPath());        if (!op.getPath().equals(serverPath)) {            return op.withChroot(serverPath);        }    }    return op;}
a331b68550c6ba23bbda69f2e6f163179a8fcdc88a56d68a23587e8fea77beeb
multiInternal
protected void multiInternal(MultiOperationRecord request, MultiCallback cb, Object ctx) throws IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
874d9e4bc4ee6e7ccd32dbd3a171050912316b1997beb215b1bc064b5eb9314f
multiInternal
protected List<OpResult> multiInternal(MultiOperationRecord request) throws InterruptedException, KeeperException, IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    List<OpResult> results = response.getResultList();        if (request.getOpKind() == Op.OpKind.READ) {        return results;    }    ErrorResult fatalError = null;    for (OpResult result : results) {        if (result instanceof ErrorResult && ((ErrorResult) result).getErr() != KeeperException.Code.OK.intValue()) {            fatalError = (ErrorResult) result;            break;        }    }    if (fatalError != null) {        KeeperException ex = KeeperException.create(KeeperException.Code.get(fatalError.getErr()));        ex.setMultiResults(results);        throw ex;    }    return results;}
9b3c268d06e83e1f0e3b89247375bf747ceb19667d2ce5938da74ad8e7f066d3
transaction
public Transaction transaction()
{    return new Transaction(this);}
09e52f9e966dba13e0b41b32112e1428cc7025f44f43df347591529528374cea
delete
public void delete(final String path, int version, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null);}
597d789d07e0af324ea7607e4b7f4e0150bb74a48985d12627aad9461a74f114
exists
public Stat exists(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        if (r.getErr() == KeeperException.Code.NONODE.intValue()) {            return null;        }        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat().getCzxid() == -1 ? null : response.getStat();}
868dfd77a484670f74667abdbd12580f640119fb3dacec3d2de458e97d1ffb22
exists
public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException
{    return exists(path, watch ? watchManager.defaultWatcher : null);}
451e2b98f041835db612836b9dce1e40d122afbfc7e798739dcce1adf644b948
exists
public void exists(final String path, Watcher watcher, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
855d5870ba020062a563480a2a76ae82df286094cc4c86e6788c9195eedabc86
exists
public void exists(String path, boolean watch, StatCallback cb, Object ctx)
{    exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
430706ebcf4f9380c4c16c8bc40b38df585781689b515dfe5d18e2ceabccc58a
getData
public byte[] getData(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
a95f6f0f6b4145780a00b91222b7c85c01b88f45de2e4edd3a1ddefbd85a2ed8
getData
public byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getData(path, watch ? watchManager.defaultWatcher : null, stat);}
63bcc7b1c44d7c55b593c1a5c2da11ccee3fe6b1b8f28618c714786cb8c57059
getData
public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
b076bbdb1bd635ea92e22683f3052614b964afb9cf14472d66f51df8bb8dd30e
getData
public void getData(String path, boolean watch, DataCallback cb, Object ctx)
{    getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
f55a1129761fd304e26fd2f4efa86ad45887899d66fbdb0860de793d7f1427b6
getConfig
public byte[] getConfig(Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), configZnode);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
3c64c2f2197bff698b80cce0b2f543ae3671b596b9cada73a76d0711af727756
getConfig
public void getConfig(Watcher watcher, DataCallback cb, Object ctx)
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, configZnode, configZnode, ctx, wcb);}
4f22ea1021a37b032eb75ab0b4b0d92dceaf3fa744bda247436d8da85a40a593
getConfig
public byte[] getConfig(boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getConfig(watch ? watchManager.defaultWatcher : null, stat);}
75425dd33ac4fd3c9da6153d42e77193173eadc034e76fffdc27e489c09c4a88
getConfig
public void getConfig(boolean watch, DataCallback cb, Object ctx)
{    getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);}
e1e86dff446c8750aef35d86e0e95f65d8fa117cf818700c894d193b1c39d334
setData
public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
9cedaebc3f0a286e369943e7363db541e22cdeb157f952b5844703ef4a80ec89
setData
public void setData(final String path, byte[] data, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
ad1c63ceddd660edb0fd13dd5b4d65673dc7b350385c4b12a5cc37dd1ab290b0
getACL
public List<ACL> getACL(final String path, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getAcl();}
f9c1a856f81d57495161e13848fe55ac692b660e86faa597d6c5efae5ae63266
getACL
public void getACL(final String path, Stat stat, ACLCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
c7183ecc94b4c605189c56f44942bf262cefb61ce74b98887d3f190efbcb9976
setACL
public Stat setACL(final String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(aclVersion);    SetACLResponse response = new SetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
4eccfef0699592df07be5b4eb48e89e10edbed54860954d8defeb5df52329f3c
setACL
public void setACL(final String path, List<ACL> acl, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(version);    SetACLResponse response = new SetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
411c6c2be72132329eb0fae4f9a0ab96000d83bbd0768c9167d1b61363ff7359
getChildren
public List<String> getChildren(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getChildren();}
f7b02a66840853537bb3bc54bd93b5234760ce66ca22c1a3c53335e12359a660
getChildren
public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null);}
a8988f31407cc6fc7e99d15e39c40270629c47a9af1574d59401dd698e6b4cf4
getChildren
public void getChildren(final String path, Watcher watcher, ChildrenCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
769086facad294a4e28f77a49c85edf52cfbff9742a8ed47c378c29e0ef460f7
getChildren
public void getChildren(String path, boolean watch, ChildrenCallback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
7913a4224d02c22a6d2e2ad64f968768bfdad1308cc64a6bf266d02803085e2b
getChildren
public List<String> getChildren(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getChildren();}
a3133f392a7647727e3a528e3543115327a7147ee32592cdad4f34fce3e9045a
getChildren
public List<String> getChildren(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null, stat);}
95e0ced1a652e6b870f2cd80c4e8a68224524f7ba2125babd73bf42aca0904c5
getChildren
public void getChildren(final String path, Watcher watcher, Children2Callback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
a8680b1b0aeb514fb6141321c9cdf4fcffaee91f5326de8cc4fe53e19721f693
getChildren
public void getChildren(String path, boolean watch, Children2Callback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
3f1a0e79223026cec23f5da789f078135a5bcb02ff04459d4b6053f0944fb280
getAllChildrenNumber
public int getAllChildrenNumber(final String path) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getTotalNumber();}
38744de2458c78b7cf5933d90f844c27311bc25450a943345a1578a3a5d900e0
getAllChildrenNumber
public void getAllChildrenNumber(final String path, AsyncCallback.AllChildrenNumberCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
c380b9a9a0db7a63dcbeab68046ce2140a1eef86260baecfd4d7124e02b8bc59
getEphemerals
public List<String> getEphemerals() throws KeeperException, InterruptedException
{    return getEphemerals("/");}
5a2762d840b060b878ee91fb13e0878b64bd91ce033b181b6129cb2383df3e7e
getEphemerals
public List<String> getEphemerals(String prefixPath) throws KeeperException, InterruptedException
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    return response.getEphemerals();}
0f19a11a334cfad04ba360bc04414ebb17122c7cdc741517dfbe08509f770f55
getEphemerals
public void getEphemerals(String prefixPath, AsyncCallback.EphemeralsCallback cb, Object ctx)
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
e233aae2304336a19786ede7459ea85c29e559c0c574c83f640b30c4d6900d27
getEphemerals
public void getEphemerals(AsyncCallback.EphemeralsCallback cb, Object ctx)
{    getEphemerals("/", cb, ctx);}
44d026abea0c4f93bb4edfaa7a80f7ba1750893ad56a7ba7b86424ea486fbed7
sync
public void sync(final String path, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.sync);    SyncRequest request = new SyncRequest();    SyncResponse response = new SyncResponse();    request.setPath(serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
f0279b879a3ff8ecc27d9e0a809c18a23ba8f258eeac2cb956a52bcc1a56f611
removeWatches
public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local);}
6fad8683026bd62ca548197eb2f271f89303bf7b87038e2e8d39b1be6e21a8e9
removeWatches
public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local, cb, ctx);}
87dd036ffe7ab97a65a6d5ac395bc43526783b4677c7a340fb542a3b127fa2a8
removeAllWatches
public void removeAllWatches(String path, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local);}
744061b2ea0c98ed7ceae00c9e8de6035138868273574f2060de49492c4756fb
removeAllWatches
public void removeAllWatches(String path, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);}
80b07d81f1f21f14e3168e1b91e9c6973aa4ed4931041cade20e4462b2c8e165
validateWatcher
private void validateWatcher(Watcher watcher)
{    if (watcher == null) {        throw new IllegalArgumentException("Invalid Watcher, shouldn't be null!");    }}
0af1babceb26d83b6fdb29e337a94455a8b43650bb10ff4a3d7f7a5bcce8c847
removeWatches
private void removeWatches(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    ReplyHeader r = cnxn.submitRequest(h, request, null, null, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
a2e03e0f8ad3a53b0ed5ebdba1f76ea2b01b0ba4dc8a7093120877bbc2df89c8
removeWatches
private void removeWatches(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null, wcb);}
11ab1bc2379e831b2ff36abb84ef9e0d6ff96d663d67e881ee89616acfe86541
getRemoveWatchesRequest
private Record getRemoveWatchesRequest(int opCode, WatcherType watcherType, final String serverPath)
{    Record request = null;    switch(opCode) {        case ZooDefs.OpCode.checkWatches:            CheckWatchesRequest chkReq = new CheckWatchesRequest();            chkReq.setPath(serverPath);            chkReq.setType(watcherType.getIntValue());            request = chkReq;            break;        case ZooDefs.OpCode.removeWatches:            RemoveWatchesRequest rmReq = new RemoveWatchesRequest();            rmReq.setPath(serverPath);            rmReq.setType(watcherType.getIntValue());            request = rmReq;            break;        default:            LOG.warn("unknown type " + opCode);            break;    }    return request;}
c82413bc27877bae9f778d70abb7bf19131f9bcab78a0d4343dc2d4aa1af993a
getState
public States getState()
{    return cnxn.getState();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    States state = getState();    return ("State:" + state.toString() + (state.isConnected() ? " Timeout:" + getSessionTimeout() + " " : " ") + cnxn);}
fac35191dfc85a76947633eb9787aafa45c2b11ae113699fda8b12f3400483b1
testableWaitForShutdown
protected boolean testableWaitForShutdown(int wait) throws InterruptedException
{    cnxn.sendThread.join(wait);    if (cnxn.sendThread.isAlive()) {        return false;    }    cnxn.eventThread.join(wait);    return !cnxn.eventThread.isAlive();}
803d76803a2fdc646ca982a9eca577c0440e737c8a9e6c2232fbbf4ac12119c5
testableRemoteSocketAddress
protected SocketAddress testableRemoteSocketAddress()
{    return cnxn.sendThread.getClientCnxnSocket().getRemoteSocketAddress();}
b460cbaaba6f7a4a1ce759e67e58453ce8186dfc6dbd4a89b25835ad96263ec9
testableLocalSocketAddress
protected SocketAddress testableLocalSocketAddress()
{    return cnxn.sendThread.getClientCnxnSocket().getLocalSocketAddress();}
4fedea22ed3a3474fdd92ef194093972ed92e6ca985a1478d346510c7c387045
getClientCnxnSocket
private ClientCnxnSocket getClientCnxnSocket() throws IOException
{    String clientCnxnSocketName = getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    if (clientCnxnSocketName == null) {        clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();    }    try {        Constructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);        ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());        return clientCxnSocket;    } catch (Exception e) {        throw new IOException("Couldn't instantiate " + clientCnxnSocketName, e);    }}
6eeab06519d29048ada2e45530635306a4c8289fe12e91d4b588b61a9b4fa036
validateACL
private void validateACL(List<ACL> acl) throws KeeperException.InvalidACLException
{    if (acl == null || acl.isEmpty() || acl.contains(null)) {        throw new KeeperException.InvalidACLException();    }}
f7e10cabc5298de5dbcb3f093f0203954319d365f588bb2fff466759b4b86114
printBanner
public static void printBanner(Logger log)
{    for (String line : BANNER) {        log.info(line);    }}
9df0b799aea9f699b6b37d2c1ff1088aee83f57f66bb4bf3241dc8825a27dc08
getPrintWatches
public boolean getPrintWatches()
{    return printWatches;}
2decb07d9795ec26b2ced86e5678b5043e1cf95cfe1cd244cdd8bb3e77257917
usage
 static void usage()
{    System.err.println("ZooKeeper -server host:port cmd args");    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    for (String cmd : cmdList) {        System.err.println("\t" + cmd + " " + commandMap.get(cmd));    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (getPrintWatches()) {        ZooKeeperMain.printMessage("WATCHER::");        ZooKeeperMain.printMessage(event.toString());    }}
19c1b70477f14675f888b701d37544d9ff8a49883c217acd061992ff75db2bc9
getOption
public String getOption(String opt)
{    return options.get(opt);}
1ff8ab376c470e3ba8b2811633435b5556ac959d0795e9752c296a86c8405913
getCommand
public String getCommand()
{    return command;}
cfd5d1b7e11f6ae6b888b0a5e25190ec999cd31530bd6b79cc2cef57357d3062
getCmdArgument
public String getCmdArgument(int index)
{    return cmdArgs.get(index);}
07eead9af3a524e27434a8d77ee9132e63dfc01b8c183b0268b698dc323b9398
getNumArguments
public int getNumArguments()
{    return cmdArgs.size();}
c8f455e86ceef1829de28d6dbf09acd567afd2302c76de8de40fcbbdf49a53c6
getArgArray
public String[] getArgArray()
{    return cmdArgs.toArray(new String[0]);}
2f8ce42be1d43d8ed0e3db7d546de29c03f5f7e435629e5ee1b8e2efc9e2936e
parseOptions
public boolean parseOptions(String[] args)
{    List<String> argList = Arrays.asList(args);    Iterator<String> it = argList.iterator();    while (it.hasNext()) {        String opt = it.next();        try {            if (opt.equals("-server")) {                options.put("server", it.next());            } else if (opt.equals("-timeout")) {                options.put("timeout", it.next());            } else if (opt.equals("-r")) {                options.put("readonly", "true");            }        } catch (NoSuchElementException e) {            System.err.println("Error: no argument found for option " + opt);            return false;        }        if (!opt.startsWith("-")) {            command = opt;            cmdArgs = new ArrayList<String>();            cmdArgs.add(command);            while (it.hasNext()) {                cmdArgs.add(it.next());            }            return true;        }    }    return true;}
e3376b8918b13e5f02fdf163369e79a5bef8dc46c1106b7cabe0d73b24f0acbc
parseCommand
public boolean parseCommand(String cmdstring)
{    Matcher matcher = ARGS_PATTERN.matcher(cmdstring);    List<String> args = new LinkedList<String>();    while (matcher.find()) {        String value = matcher.group(1);        if (QUOTED_PATTERN.matcher(value).matches()) {                        value = value.substring(1, value.length() - 1);        }        args.add(value);    }    if (args.isEmpty()) {        return false;    }    command = args.get(0);    cmdArgs = args;    return true;}
b9e8fffa69c25db04433dac55dc97b3f7b22be05a38aa0697f1c963117b21ddd
addToHistory
protected void addToHistory(int i, String cmd)
{    history.put(i, cmd);}
aeb791ecc6fcf44b754a47fc6bb4eaffc6bd8c20c33a26509b414aaa807418d1
getCommands
public static List<String> getCommands()
{    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    return cmdList;}
04d70940cd5a4c5fb7ad05e3ff425cb5baf6e08995a76393a3ec147f1207151a
getPrompt
protected String getPrompt()
{    return "[zk: " + host + "(" + zk.getState() + ")" + " " + commandCount + "] ";}
efa8fd1973ff694301fdba4b7ab755a538d1a420317bb9ad27e586c4873e22d1
printMessage
public static void printMessage(String msg)
{    System.out.println("\n" + msg);}
7c44f1ff949d69b4e35a9dfa37204311405381eb41a19c54b7ede142f0e33226
connectToZK
protected void connectToZK(String newHost) throws InterruptedException, IOException
{    if (zk != null && zk.getState().isAlive()) {        zk.close();    }    host = newHost;    boolean readOnly = cl.getOption("readonly") != null;    if (cl.getOption("secure") != null) {        System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");        System.out.println("Secure connection is enabled");    }    zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption("timeout")), new MyWatcher(), readOnly);}
11efb6db5f4202b7bc1ce8ea453ba63ff3ebf86291c67f2b47713a5aa808d121
main
public static void main(String[] args) throws CliException, IOException, InterruptedException
{    ZooKeeperMain main = new ZooKeeperMain(args);    main.run();}
82f69de5192aae08daa3e290085be4bb0acf3df892494d1097e5a6148ad52b0e
run
 void run() throws CliException, IOException, InterruptedException
{    if (cl.getCommand() == null) {        System.out.println("Welcome to ZooKeeper!");        boolean jlinemissing = false;                try {            Class<?> consoleC = Class.forName("jline.console.ConsoleReader");            Class<?> completorC = Class.forName("org.apache.zookeeper.JLineZNodeCompleter");            System.out.println("JLine support is enabled");            Object console = consoleC.getConstructor().newInstance();            Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);            Method addCompletor = consoleC.getMethod("addCompleter", Class.forName("jline.console.completer.Completer"));            addCompletor.invoke(console, completor);            String line;            Method readLine = consoleC.getMethod("readLine", String.class);            while ((line = (String) readLine.invoke(console, getPrompt())) != null) {                executeLine(line);            }        } catch (ClassNotFoundException e) {            LOG.debug("Unable to start jline", e);            jlinemissing = true;        } catch (NoSuchMethodException e) {            LOG.debug("Unable to start jline", e);            jlinemissing = true;        } catch (InvocationTargetException e) {            LOG.debug("Unable to start jline", e);            jlinemissing = true;        } catch (IllegalAccessException e) {            LOG.debug("Unable to start jline", e);            jlinemissing = true;        } catch (InstantiationException e) {            LOG.debug("Unable to start jline", e);            jlinemissing = true;        }        if (jlinemissing) {            System.out.println("JLine support is disabled");            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = br.readLine()) != null) {                executeLine(line);            }        }    } else {                processCmd(cl);    }    System.exit(exitCode);}
a9741455d94c24bb443b6bfb1afb22cbbddf4ea6d24458dd07157d4e48bf9347
executeLine
public void executeLine(String line) throws CliException, InterruptedException, IOException
{    if (!line.equals("")) {        cl.parseCommand(line);        addToHistory(commandCount, line);        processCmd(cl);        commandCount++;    }}
1b6e400cedbe68a3c424aea4d513c71ff1b50d5e9b38bfa6365e265cb77fc48a
processCmd
protected boolean processCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException
{    boolean watch = false;    try {        watch = processZKCmd(co);        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    } catch (CliException ex) {        exitCode = ex.getExitCode();        System.err.println(ex.getMessage());    }    return watch;}
80167c21e7a7e768556c391a63402bca43d90eabe48d69360cce94667dfbf7cd
processZKCmd
protected boolean processZKCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException
{    String[] args = co.getArgArray();    String cmd = co.getCommand();    if (args.length < 1) {        usage();        throw new MalformedCommandException("No command entered");    }    if (!commandMap.containsKey(cmd)) {        usage();        throw new CommandNotFoundException("Command not found " + cmd);    }    boolean watch = false;    LOG.debug("Processing {}", cmd);    if (cmd.equals("quit")) {        zk.close();        System.exit(exitCode);    } else if (cmd.equals("redo") && args.length >= 2) {        Integer i = Integer.decode(args[1]);        if (commandCount <= i || i < 0) {                        throw new MalformedCommandException("Command index out of range");        }        cl.parseCommand(history.get(i));        if (cl.getCommand().equals("redo")) {            throw new MalformedCommandException("No redoing redos");        }        history.put(commandCount, history.get(i));        processCmd(cl);    } else if (cmd.equals("history")) {        for (int i = commandCount - 10; i <= commandCount; ++i) {            if (i < 0) {                continue;            }            System.out.println(i + " - " + history.get(i));        }    } else if (cmd.equals("printwatches")) {        if (args.length == 1) {            System.out.println("printwatches is " + (printWatches ? "on" : "off"));        } else {            printWatches = args[1].equals("on");        }    } else if (cmd.equals("connect")) {        if (args.length >= 2) {            connectToZK(args[1]);        } else {            connectToZK(host);        }    }        if (zk == null || !zk.getState().isAlive()) {        System.out.println("Not connected");        return false;    }        CliCommand cliCmd = commandMapCli.get(cmd);    if (cliCmd != null) {        cliCmd.setZk(zk);        watch = cliCmd.parse(args).exec();    } else if (!commandMap.containsKey(cmd)) {        usage();    }    return watch;}
da23c54ba5babff9616baac853c12b3775dd0fcaf778d78e6bf95930621a9771
injectSessionExpiration
public void injectSessionExpiration()
{    LOG.info("injectSessionExpiration() called");    clientCnxn.eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));    clientCnxn.eventThread.queueEventOfDeath();    clientCnxn.state = ZooKeeper.States.CLOSED;    clientCnxn.sendThread.getClientCnxnSocket().onClosing();}
d1d01001b337460f34ac848edff9ab3b1e3bcf7c3c70ff8144a93cdf6549a48c
queueEvent
public void queueEvent(WatchedEvent event)
{    LOG.info("queueEvent() called: {}", event);    clientCnxn.eventThread.queueEvent(event);}
7c1203297d6f00c7339a0f8eb5c3970de980476fea8d1f9ae49f44e151af83f4
init
public static void init()
{    if (!testData.exists()) {        testData.mkdirs();    }}
77040b7d0dea6b9b19cd8337776c8af80378b5f9d1f56881d665ae6ba0e8faea
testDefaultConfiguration
public void testDefaultConfiguration()
{    Map<String, String> properties = new HashMap<>();    properties.put(ZK_SASL_CLIENT_USERNAME, "zookeeper1");    properties.put(LOGIN_CONTEXT_NAME_KEY, "Client1");    properties.put(ENABLE_CLIENT_SASL_KEY, "true");    properties.put(ZOOKEEPER_SERVER_REALM, "zookeeper/hadoop.hadoop.com");    properties.put(DISABLE_AUTO_WATCH_RESET, "true");    properties.put(ZOOKEEPER_CLIENT_CNXN_SOCKET, "ClientCnxnSocketNetty");    properties.put(SECURE_CLIENT, "true");    for (Map.Entry<String, String> e : properties.entrySet()) {        System.setProperty(e.getKey(), e.getValue());    }    /**     * ZKClientConfig should get initialized with system properties     */    ZKClientConfig conf = new ZKClientConfig();    for (Map.Entry<String, String> e : properties.entrySet()) {        assertEquals(e.getValue(), conf.getProperty(e.getKey()));    }    /**     * clear properties     */    for (Map.Entry<String, String> e : properties.entrySet()) {        System.clearProperty(e.getKey());    }    conf = new ZKClientConfig();    /**     * test that all the properties are null     */    for (Map.Entry<String, String> e : properties.entrySet()) {        String result = conf.getProperty(e.getKey());        assertNull(result);    }}
78152aacae3b88c9f9cc0536f8553bd30beb6032eed4a4434d3952bfde00385b
testSystemPropertyValue
public void testSystemPropertyValue()
{    String clientName = "zookeeper1";    System.setProperty(ZK_SASL_CLIENT_USERNAME, clientName);    ZKClientConfig conf = new ZKClientConfig();    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), clientName);    String newClientName = "zookeeper2";    conf.setProperty(ZK_SASL_CLIENT_USERNAME, newClientName);    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), newClientName);}
7005c579a65ee7581991f8ac3a0a1ac095076063d3ac9ac1775fc805f7dea2fe
testReadConfigurationFile
public void testReadConfigurationFile() throws IOException, ConfigException
{    File file = File.createTempFile("clientConfig", ".conf", testData);    file.deleteOnExit();    Properties clientConfProp = new Properties();    clientConfProp.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    clientConfProp.setProperty(ZK_SASL_CLIENT_USERNAME, "ZK");    clientConfProp.setProperty(LOGIN_CONTEXT_NAME_KEY, "MyClient");    clientConfProp.setProperty(ZOOKEEPER_SERVER_REALM, "HADOOP.COM");    clientConfProp.setProperty("dummyProperty", "dummyValue");    OutputStream io = new FileOutputStream(file);    try {        clientConfProp.store(io, "Client Configurations");    } finally {        io.close();    }    ZKClientConfig conf = new ZKClientConfig();    conf.addConfiguration(file.getAbsolutePath());    assertEquals(conf.getProperty(ENABLE_CLIENT_SASL_KEY), "true");    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), "ZK");    assertEquals(conf.getProperty(LOGIN_CONTEXT_NAME_KEY), "MyClient");    assertEquals(conf.getProperty(ZOOKEEPER_SERVER_REALM), "HADOOP.COM");    assertEquals(conf.getProperty("dummyProperty"), "dummyValue");            file.delete();}
3c62db47f816e9b64da1faf75bef571af74aa787bd5b7bbe4199937d4a4a8341
testSetConfiguration
public void testSetConfiguration()
{    ZKClientConfig conf = new ZKClientConfig();    String defaultValue = conf.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT);    if (defaultValue.equals("true")) {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "false");    } else {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    }    assertTrue(conf.getProperty(ENABLE_CLIENT_SASL_KEY) != defaultValue);}
8a7ff3dbfa5cf55bc5ddfe0c8ed8f89480c7e53dac396072807e07031f0de0d0
testIntegerRetrievalFromProperty
public void testIntegerRetrievalFromProperty()
{    ZKClientConfig conf = new ZKClientConfig();    String prop = "UnSetProperty" + System.currentTimeMillis();    int defaultValue = 100;        int result = conf.getInt(prop, defaultValue);    assertEquals(defaultValue, result);            conf.setProperty(ZKConfig.JUTE_MAXBUFFER, "InvlaidIntValue123");    try {        result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);        fail("NumberFormatException is expected");    } catch (NumberFormatException exception) {        }    assertEquals(defaultValue, result);        int value = ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, Integer.toString(value));    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);        value = 12345;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, " " + value + " ");    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);}
88d29a5a4d70eca8e23dfbd5e68d9d30a1af4cc330c163c9ced155d2cc419c43
testClientCanonicalization
public void testClientCanonicalization() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does not appear to have been canonicalized", "zookeeper/zk1.apache.org", principal);}
be2c3a329ebf11c652500e351dccbcdb7685d56581abd1458636810e9f9292e4
testClientNoCanonicalization
public void testClientNoCanonicalization() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    conf.setProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, "false");    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appears to have been canonicalized incorrectly", "zookeeper/zookeeper.apache.org", principal);}
45064a6d1be8c414b892595759a85bca2830180da95134200cf3472640d1045c
testClientCanonicalizationToIp
public void testClientCanonicalizationToIp() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("127.0.0.1");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appear to have falled back to the original host name", "zookeeper/zookeeper.apache.org", principal);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    ClientCnxnSocketNetty.setTestAllocator(TestByteBufAllocator.getInstance());}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    ClientCnxnSocketNetty.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
ffbb3227dd824c690e91c013c3cc1a45140f107240eae330ddc82d59f12b9b2b
testWhenInvalidJuteMaxBufferIsConfiguredIOExceptionIsThrown
public void testWhenInvalidJuteMaxBufferIsConfiguredIOExceptionIsThrown()
{    ZKClientConfig clientConfig = new ZKClientConfig();    String value = "SomeInvalidInt";    clientConfig.setProperty(ZKConfig.JUTE_MAXBUFFER, value);        try {        new ClientCnxnSocketNIO(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }        try {        new ClientCnxnSocketNetty(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }}
c18347905b35d655641536eb82070d5136fcca62a1ee97dbb30a27d0db56d569
registerAndConnect
 void registerAndConnect(SocketChannel sock, InetSocketAddress addr) throws IOException
{    countDownLatch.countDown();    throw new IOException("failed to register");}
e9dba6426466e1b146d3e1f5b69f0b7784dff79d179cb6c470adc5fc73da1c44
createSock
 SocketChannel createSock()
{    return sc;}
2eb84ebea7d74ac4ee8601e11e77032e123fb350e5c12eb881e84fceff6c2ba0
testClientReconnect
public void testClientReconnect() throws IOException, InterruptedException
{    HostProvider hostProvider = mock(HostProvider.class);    when(hostProvider.size()).thenReturn(1);    InetSocketAddress inaddr = new InetSocketAddress("127.0.0.1", 1111);    when(hostProvider.next(anyLong())).thenReturn(inaddr);    ZooKeeper zk = mock(ZooKeeper.class);    when(zk.getClientConfig()).thenReturn(new ZKClientConfig());    sc = SocketChannel.open();    ClientCnxnSocketNIO nioCnxn = new MockCnxn();    ClientWatchManager watcher = mock(ClientWatchManager.class);    ClientCnxn clientCnxn = new ClientCnxn("tmp", hostProvider, 5000, zk, watcher, nioCnxn, false);    clientCnxn.start();    countDownLatch.await(5000, TimeUnit.MILLISECONDS);    assertTrue(countDownLatch.getCount() == 0);    clientCnxn.close();}
63a26bd58da3c96d7b5d72078d2670f2c8d106155f6f51bb3771eb5e5cb2e39c
testClientRequestTimeout
public void testClientRequestTimeout() throws Exception
{    int requestTimeOut = 15000;    System.setProperty("zookeeper.request.timeout", Integer.toString(requestTimeOut));    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch1 = new CountdownWatcher();    CustomZooKeeper zk = new CustomZooKeeper(getCxnString(clientPorts), ClientBase.CONNECTION_TIMEOUT, watch1);    watch1.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";        zk.create("/clientHang1", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        dropPacket = true;    dropPacketType = ZooDefs.OpCode.create;        try {        zk.create("/clientHang2", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("KeeperException is expected.");    } catch (KeeperException exception) {        assertEquals(KeeperException.Code.REQUESTTIMEOUT.intValue(), exception.code().intValue());    }        zk.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
dcbb4744dd8e7376568bac44135dbc1b0f1ef1009fed08c3b5b97c75e4ca82c8
getCxnString
private String getCxnString(int[] clientPorts)
{    StringBuffer hostPortBuffer = new StringBuffer();    for (int i = 0; i < clientPorts.length; i++) {        hostPortBuffer.append("127.0.0.1:");        hostPortBuffer.append(clientPorts[i]);        if (i != (clientPorts.length - 1)) {            hostPortBuffer.append(',');        }    }    return hostPortBuffer.toString();}
631bdb585bb824b2ea3cff6a2a37a5d163f364f63e8e65a196804cde20fae86a
finishPacket
public void finishPacket(Packet p)
{    if (dropPacket && p.requestHeader.getType() == dropPacketType) {                return;    }    super.finishPacket(p);}
0da12011de919fb00b90d3ea1da8079b870e716885cdde554abc38004b6045c7
createConnection
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new CustomClientCnxn(chrootPath, hostProvider, sessionTimeout, zooKeeper, watcher, clientCnxnSocket, canBeReadOnly);}
6fd7c0c9bb823f2c03ede1ac2744cf4aa97f36ce76cb0baae53b14e12fac5794
createTmpDir
public static void createTmpDir()
{    tmpdir = new File("build/test/tmp");    tmpdir.mkdirs();}
b8cb4afa4a2bc7d219cdb2ab1137b2643907e9784fcb7dd5ba7e0b6fbca78ecc
testOutputStreamSuccess
public void testOutputStreamSuccess() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
14f88375183130c79d7b9e248d7b4d8b23e9b2ea07d9baf6fa83f2985079e7b8
testWriterSuccess
public void testWriterSuccess() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
206629207a4c7246e8eb0be68de1dc842c844d1233a8500415364766755620cf
testOutputStreamFailure
public void testOutputStreamFailure() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
731b41fc197af180965426623e5361ea43410bda792b375a618243577986dfb4
testWriterFailure
public void testWriterFailure() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
f084cc35b272484afd1c5d6f850f4d7bfd43667440e3ed7a492faa5c3c7a2292
testOutputStreamFailureIOException
public void testOutputStreamFailureIOException() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
9b89ab905c52673b6b79aabc80983d342514d89dd0b5bdb457787c8e9bb1b3b9
testWriterFailureIOException
public void testWriterFailureIOException() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
2c8a8e6c8c9fc49814aa6c8c42f5c994cf97bccfe01891261d37678d262db6a0
testOutputStreamFailureError
public void testOutputStreamFailureError() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
db247b39ee8406de3024bc3972b4134edb790abd68ff9bcecc236174559ec9f2
testWriterFailureError
public void testWriterFailureError() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
142867891bc717c88d09314e797feb0c978e97302733dd861289547467e95d83
testOutputStreamSuccessNE
public void testOutputStreamSuccessNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });        assertEquals("after", getContent(target));    target.delete();}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
30ca4310c438fdc826841f3c0dec1a3a0c42f3ec5a82e49895bbd6ff18954ec1
testWriterSuccessNE
public void testWriterSuccessNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
d3fe26e705ad3bb3d8f737230c21b473b4ce7b32cd2e1daf634b3b4d2df3a0dc
testOutputStreamFailureNE
public void testOutputStreamFailureNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
19cdc39bb72835d86d5b210f8ac1650161d9fca1831a2b8ef6a75c0c19b04fe6
write
public void write(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
1faaf9a4aa0f8a4a3ff53c39acbac2ef018796fc89b2cf3e69f825be4d9258b7
testWriterFailureNE
public void testWriterFailureNE() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
900c1013cf4fbfd475d470d56fad49db0b34e9b370d6ff7d66c38f28c7875262
write
public void write(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
692817dd582d629f0c0f7e5898fba4021bf4ca5191f0f07e7ef9e6c1878ba354
getContent
private String getContent(File file, String encoding) throws IOException
{    StringBuilder result = new StringBuilder();    FileInputStream fis = new FileInputStream(file);    byte[] b = new byte[20];    int nb;    while ((nb = fis.read(b)) != -1) {        result.append(new String(b, 0, nb, encoding));    }    fis.close();    return result.toString();}
2cd320042d3556d38a43e2026d8d00245ca10efdf91b34b62bafa69ea2cef372
getContent
private String getContent(File file) throws IOException
{    return getContent(file, "ASCII");}
a3741e18e4168d8ba79937587f2213a732471cceeb65bc116564071b95157e1f
createFile
private void createFile(File file, String content) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    fos.write(content.getBytes(StandardCharsets.US_ASCII));    fos.close();}
911203bc28c697809e21ef84dcb14ccc699acbb58e5503c7b303d6042d08d06b
defaultParams
public static Collection<Object[]> defaultParams()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (String keyPassword : new String[] { "", "pa$$w0rd" }) {                result.add(new Object[] { caKeyType, certKeyType, keyPassword, paramIndex++ });            }        }    }    return result;}
5228cea0c9d6b2534394b5f4c7672a137701f906f736471df1f93b132b8b8c40
setUpBaseClass
public static void setUpBaseClass() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    cachedTestContexts = new HashMap<>();    tempDir = ClientBase.createEmptyTestDir();}
aae69aa3bf26fadc680d735d30b52a564a46fd602f26c8194c81876d2263d799
cleanUpBaseClass
public static void cleanUpBaseClass()
{    Security.removeProvider("BC");    cachedTestContexts.clear();    cachedTestContexts = null;    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
ffa0fa53c9075e7377657c5e12571035aad18ac55cfd85df2bb0aac370b7d6df
createTempFile
public static void createTempFile() throws IOException
{    tempDir = ClientBase.createEmptyTestDir();    tempFile = File.createTempFile("zk_test_", "", tempDir);    tempFile.deleteOnExit();}
d526981c11d90b244584b50d14da18824fb64837136585c9ff0134be3c9f8fc5
cleanupTempDir
public static void cleanupTempDir()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
8848c0d504c2efd9882e76b5e98fb945f8c04979014bd5b80e8fcca96b1aad14
testCallbackWorksOnFileChanges
public void testCallbackWorksOnFileChanges() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {            LOG.info("Got an update: " + event.kind() + " " + event.context());                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        for (int i = 0; i < 3; i++) {            LOG.info("Modifying file, attempt " + (i + 1));            FileUtils.writeStringToFile(tempFile, "Hello world " + i + "\n", StandardCharsets.UTF_8, true);            synchronized (events) {                if (events.size() < i + 1) {                    events.wait(3000L);                }                assertEquals("Wrong number of events", i + 1, events.size());                WatchEvent<?> event = events.get(i);                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());                assertEquals(tempFile.getName(), event.context().toString());            }        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
bd1c7e665e8d139307592197f7015201a72feddf26b790b519c008e6ed6a5a3f
testCallbackWorksOnFileTouched
public void testCallbackWorksOnFileTouched() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {            LOG.info("Got an update: " + event.kind() + " " + event.context());                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        LOG.info("Touching file");        FileUtils.touch(tempFile);        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
815705a1bb823c6d06437f50e12e01f24caff7dc723de9d02219e6c3d46522da
testCallbackWorksOnFileAdded
public void testCallbackWorksOnFileAdded() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {            LOG.info("Got an update: " + event.kind() + " " + event.context());            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        File tempFile2 = File.createTempFile("zk_test_", "", tempDir);        tempFile2.deleteOnExit();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());            assertEquals(tempFile2.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
751eba15e2ef6c2ef9e8e32a46fade4b303f8cf69eb518e35d34662adf15a727
testCallbackWorksOnFileDeleted
public void testCallbackWorksOnFileDeleted() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {            LOG.info("Got an update: " + event.kind() + " " + event.context());                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        tempFile.delete();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
7e149f2c41f3db06a0593e888d5ea3c183da2295868ef28cba1789ec9edff29c
testCallbackErrorDoesNotCrashWatcherThread
public void testCallbackErrorDoesNotCrashWatcherThread() throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final AtomicInteger callCount = new AtomicInteger(0);        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {            LOG.info("Got an update: " + event.kind() + " " + event.context());            int oldValue;            synchronized (callCount) {                oldValue = callCount.getAndIncrement();                callCount.notifyAll();            }            if (oldValue == 0) {                throw new RuntimeException("This error should not crash the watcher thread");            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        LOG.info("Modifying file");        FileUtils.writeStringToFile(tempFile, "Hello world\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            while (callCount.get() == 0) {                callCount.wait(3000L);            }        }        LOG.info("Modifying file again");        FileUtils.writeStringToFile(tempFile, "Hello world again\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            if (callCount.get() == 1) {                callCount.wait(3000L);            }        }                        assertTrue(callCount.get() > 1);    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
d16f9a7ec3049128561443505337af6fa1a61cf1c7c4a3c2a86f9d32a4cbfe57
testGetBuilderForJKSFileType
public void testGetBuilderForJKSFileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.JKS);    assertTrue(builder instanceof JKSFileLoader.Builder);}
692cfd3eca2831f8f02928963e7c7d875685a390a65d9920184ebcd1763361a5
testGetBuilderForPEMFileType
public void testGetBuilderForPEMFileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PEM);    assertTrue(builder instanceof PEMFileLoader.Builder);}
12c9d3ec6c6051a495b134bcb0c2e24faf842d29c345fea7a3f95679ef950abb
testGetBuilderForPKCS12FileType
public void testGetBuilderForPKCS12FileType()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PKCS12);    assertTrue(builder instanceof PKCS12FileLoader.Builder);}
207a75c5b99c495349658322dab7ed94177e22a93e9d969f47c3f68bfd283283
testGetBuilderForNullFileType
public void testGetBuilderForNullFileType()
{    FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(null);}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
03b079c945fcab9858c3481eb6f523528a972065cf567268eb02c75275ca465f
testLoadKeyStore
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ks = new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
1cc940ca05718ff728f94ba25a2d711abd7f8e08b49241d358f2d5feffd35630
testLoadKeyStoreWithWrongPassword
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
4cf936259add6712040aab74c81e24f552c0129f6aaa594eadf2ff87c537a7a6
testLoadKeyStoreWithWrongFilePath
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
4b7883b83a6ba80d3863834ad19bed1df7cc565280fc2ad759ee6035d17cc3f0
testLoadKeyStoreWithNullFilePath
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new JKSFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
55918b57b1fb921d647891dc7e65e50e2d6db1674058289f9339ab29539e7b95
testLoadKeyStoreWithWrongFileType
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
d79105e4d869a2c219c0e45640ac8f1ff1217c8c302edd17994d604f82c13332
testLoadTrustStore
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
03a002fca594ad67b563908dde58ce82b424db5e99bf54f7e50148a706f3eb4d
testLoadTrustStoreWithWrongPassword
public void testLoadTrustStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
9f2adf6f72b8bdc6ac66423711637cf1c6b1b1016e53edf4836e78b163789a02
testLoadTrustStoreWithWrongFilePath
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a73f9b2ad3b3afaffef4974a2039e783b069ad1977b9e7ddce2d56b2a74d6469
testLoadTrustStoreWithNullFilePath
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new JKSFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a0e08bd296d4fe8d42ac776f33e7d07fd3bc34c8e6c6cca3cfee1ac2d195d702
testLoadTrustStoreWithWrongFileType
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
98d149b2e4f2aa5e96af9c8a9cbc2f04051e92f5166be2dbc0962366ee211295
testGetPropertyValue
public void testGetPropertyValue()
{    assertEquals("PEM", KeyStoreFileType.PEM.getPropertyValue());    assertEquals("JKS", KeyStoreFileType.JKS.getPropertyValue());    assertEquals("PKCS12", KeyStoreFileType.PKCS12.getPropertyValue());}
74b8bb4f434f8ecd265d01d26b1e5bbb9cb529e2a7e7d7752c3762349d8a2f2e
testFromPropertyValue
public void testFromPropertyValue()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("PEM"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("JKS"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("PKCS12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
9cb34c3b663c163294c7eed2a5f85a1e8240af7bd0ef64c3dc80452d282681e8
testFromPropertyValueIgnoresCase
public void testFromPropertyValueIgnoresCase()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("pem"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("jks"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("pkcs12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
d61ff1ef53b70a8692ec2ba05b7f5e82631920b82409fadf19331533e345354e
testFromPropertyValueThrowsOnBadPropertyValue
public void testFromPropertyValueThrowsOnBadPropertyValue()
{    KeyStoreFileType.fromPropertyValue("foobar");}
8ef9372b23c945a649455cf1bbd9a46f87303c56d321052d107b88eba9c0fe99
testFromFilename
public void testFromFilename()
{    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("mykey.jks"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.jks"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("mykey.pem"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.pem"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("mykey.p12"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.p12"));}
fc6b3041ab390e1a7fcb2e5a3e764b326c1a81e139dfd89d21e454a2fe58fe1a
testFromFilenameThrowsOnBadFileExtension
public void testFromFilenameThrowsOnBadFileExtension()
{    KeyStoreFileType.fromFilename("prod.key");}
8d667f2dd6fa573467d0369ebfe2a5dbf37a0020bea94726f1dc278cf1cf7a5b
testFromPropertyValueOrFileName
public void testFromPropertyValueOrFileName()
{        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("JKS", "prod.key"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValueOrFileName("PEM", "prod.key"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValueOrFileName("PKCS12", "prod.key"));        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("", "prod.jks"));}
084a51bf82099435dec4531e5f74af3f37bef5234ca52e728173b78a29e1122f
testFromPropertyValueOrFileNameThrowsOnBadPropertyValue
public void testFromPropertyValueOrFileNameThrowsOnBadPropertyValue()
{    KeyStoreFileType.fromPropertyValueOrFileName("foobar", "prod.jks");}
7987e42c435e03fda8c0f98076b2c9c8bc409e14e913f1e57db007e82cdccf9f
testFromPropertyValueOrFileNameThrowsOnBadFileExtension
public void testFromPropertyValueOrFileNameThrowsOnBadFileExtension()
{    KeyStoreFileType.fromPropertyValueOrFileName("", "prod.key");}
73dc2da29f96fc95fd0e878ef79445407b070857e2b2af6a6c320efdc1cfeb7e
testFormatInetAddrGoodIpv4
public void testFormatInetAddrGoodIpv4()
{    InetSocketAddress isa = new InetSocketAddress(v4addr, port);    assertEquals("127.0.0.1:1234", NetUtils.formatInetAddr(isa));}
36d929b7d467278241b0c2cbd664e2264f9a5f0649cdf5fab03b90853add6a5f
testFormatInetAddrGoodIpv6Local
public void testFormatInetAddrGoodIpv6Local()
{        InetSocketAddress isa = new InetSocketAddress("::1", port);    assertEquals(v6local, NetUtils.formatInetAddr(isa));}
367948a155464c7de36c1c51569b1b023150d3d2e78c9a8ec5488e7423e51949
testFormatInetAddrGoodIpv6Ext
public void testFormatInetAddrGoodIpv6Ext()
{        InetSocketAddress isa = new InetSocketAddress("2600::", port);    assertEquals(v6ext, NetUtils.formatInetAddr(isa));}
eaebe90fc4e3e1eba2009a056567a6da5da2254699b646051945e51d3f62695b
testFormatInetAddrGoodHostname
public void testFormatInetAddrGoodHostname()
{    InetSocketAddress isa = new InetSocketAddress("localhost", 1234);    assertThat(NetUtils.formatInetAddr(isa), anyOf(equalTo(v4local), equalTo(v6local)));}
ade3692d4b9de33d7eac1dbd91ba2d5457d1f69db1ab680215e4f0b07c1c4aa4
testFormatAddrUnresolved
public void testFormatAddrUnresolved()
{    InetSocketAddress isa = InetSocketAddress.createUnresolved("doesnt.exist.com", 1234);    assertEquals("doesnt.exist.com:1234", NetUtils.formatInetAddr(isa));}
a137d67cbf4a7af20aa93177e840bb9f03d5c275b44a5cc3e10dbc09459dad4d
before
public void before()
{    this.pathTrie = new PathTrie();}
baa31d30ecbaad91d3683867e8eed3f753014c6a37d81af143fd145df85a112b
addNullPath
public void addNullPath()
{    this.pathTrie.addPath(null);}
6566e6f04ca5b698383bf86011250548c89fed818d84ce9888ed85acb1257385
addIllegalPath
public void addIllegalPath()
{    this.pathTrie.addPath("");}
feb0f59707b1037f6e5a6eff2179fb18d9881e253fa214e3aff0ee3f313343b2
addPathToRoot
public void addPathToRoot()
{    this.pathTrie.addPath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));}
36b00a0917fae4c3e938ae5a0a3d72be88ce04cd7c80ae63da061bf325427bcb
addPathToRootLeaves
public void addPathToRootLeaves()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
30965064be711c0731b799208e63b4abc52e17a367d63beead52e31bd48375e2
deleteNullPath
public void deleteNullPath()
{    this.pathTrie.deletePath(null);}
664a3b1b73671b97ae146bd3ea197d7053ba9367a5a90185ac36d4d697f808fe
deleteIllegalPath
public void deleteIllegalPath()
{    this.pathTrie.deletePath("");}
8f7c8800759eb86d65d5c8a68ec10caea85480fe7443344f70fdc564441614a4
deletePathFromRoot
public void deletePathFromRoot()
{    this.pathTrie.addPath("node1");    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
e327a14dfded56e2fb05043eb78231608694d700befaad16dbc0976690d922fb
deletePathFromRootLeaves
public void deletePathFromRootLeaves()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertFalse(this.pathTrie.existsNode("/node1/node3"));    this.pathTrie.deletePath("node1/node2");    assertTrue(this.pathTrie.existsNode("/node1"));    assertFalse(this.pathTrie.existsNode("/node1/node2"));    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
117294c306eb8e608ab7077d9e6e4950bae76bbeb096a9e2a84f4d56804f6808
deletePathDoesNotExist
public void deletePathDoesNotExist()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));}
a46e56eceaf2787d370ad53986c9af69395000d1b826026b280b6048cc0f8b3f
deleteRootPath
public void deleteRootPath()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");        this.pathTrie.deletePath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
401ad1cfc58946b906817851f0b97a5cfbb0c6063ff0613d694dfdd3b0c35bba
findMaxPrefixNullPath
public void findMaxPrefixNullPath()
{    this.pathTrie.findMaxPrefix(null);}
84bc9194e5a2a41b2995ae38679bd8bf4b630972c82b5f69ee6027de543e3ea7
findMaxPrefixRootPath
public void findMaxPrefixRootPath()
{    assertEquals("/", this.pathTrie.findMaxPrefix("/"));}
78bbc985a0b489a613f50fcf7c02dd01999c38fc5bdaa73f72c1e245007e8717
findMaxPrefixChildren
public void findMaxPrefixChildren()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1"));    assertEquals("/node1/node2", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1/node3", this.pathTrie.findMaxPrefix("/node1/node3"));}
76e05d80664833508e67119625ebf46db5f3f8fbc5977bda0be33130c3a18273
findMaxPrefixChildrenPrefix
public void findMaxPrefixChildrenPrefix()
{    this.pathTrie.addPath("node1");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node3"));}
df009d9fdb153932af1577e96fa6849e5cca524c46d678a9ef55efdfd9ead9c3
testValidatePath_ValidPath
public void testValidatePath_ValidPath()
{    PathUtils.validatePath("/this is / a valid/path");}
a290c7e0888c62694613661b94a3148f73a6a45dbdfb9221642570ad6f829df4
testValidatePath_Null
public void testValidatePath_Null()
{    PathUtils.validatePath(null);}
838bce9960dbca4d8c68ac46a2963d0dbc8f5882129cd6bf747557a8b92c7a2d
testValidatePath_EmptyString
public void testValidatePath_EmptyString()
{    PathUtils.validatePath("");}
8444a80a2e119586a08d7a23e325619d507af0643c6ec00b21d8911378cc270b
testValidatePath_NotAbsolutePath
public void testValidatePath_NotAbsolutePath()
{    PathUtils.validatePath("not/valid");}
19b5237d3a4769d53fb250e842e2f0b79f3bd537375c13b7ef97c6c69051169d
testValidatePath_EndsWithSlash
public void testValidatePath_EndsWithSlash()
{    PathUtils.validatePath("/ends/with/slash/");}
12743567ae05944c6d1bd071d2058ebc0450dc56a535f11bbff1f53b564a3a4b
testValidatePath_ContainsNullCharacter
public void testValidatePath_ContainsNullCharacter()
{    PathUtils.validatePath("/test\u0000");}
6f73c2eb7921f5cdba108355527959427772900d77e808e5809a4d853ee2662f
testValidatePath_DoubleSlash
public void testValidatePath_DoubleSlash()
{    PathUtils.validatePath("/double//slash");}
094515fcbc11e0a02e665b116be276c8da0530695fec20827598f5fe416e7503
testValidatePath_SinglePeriod
public void testValidatePath_SinglePeriod()
{    PathUtils.validatePath("/single/./period");}
688358f60182e1302bd5b5153c759c11647078bb5a4144a977bf754f3f25cb29
testValidatePath_DoublePeriod
public void testValidatePath_DoublePeriod()
{    PathUtils.validatePath("/double/../period");}
d87010f128c4056e2460c36074bbd4a847e577dbf808019c621cfe89f4299cc7
testValidatePath_NameContainingPeriod
public void testValidatePath_NameContainingPeriod()
{        PathUtils.validatePath("/name/with.period.");}
24d9a990e549766dbad6f4b178abddff345bff554f10ce0556333f3d767b4502
testValidatePath_0x01
public void testValidatePath_0x01()
{    PathUtils.validatePath("/test\u0001");}
24c6e101f5144e2ac63eafcbd079eb5793866776a36ef0334521b246facd2403
testValidatePath_0x1F
public void testValidatePath_0x1F()
{    PathUtils.validatePath("/test\u001F");}
55ad253496b73612a355ba8074bec86be83b41f7ce0b112a0ef2bdba4b6f2cf5
testValidatePath_0x20
public void testValidatePath_0x20()
{    PathUtils.validatePath("/test\u0020");}
9f589b9104847adcbe8d06944ed97ed13808ddce91c350f3368651de97aac1c0
testValidatePath_0x7e
public void testValidatePath_0x7e()
{        PathUtils.validatePath("/test\u007e");}
ba7a2a2c9e1616583a8582f06de3686ac507c5e1440f70026788d062fcce05e9
testValidatePath_0x7f
public void testValidatePath_0x7f()
{    PathUtils.validatePath("/test\u007f");}
4f2a3c3e9f42746211c7039e17a897dd1597178e76a9164c554bc9bb4f3ee5d9
testValidatePath_0x9f
public void testValidatePath_0x9f()
{    PathUtils.validatePath("/test\u009f");}
41c8a06c44d71df8326ecdb29d38c4ae4445b4d75548e79d027548d65ca6344d
testValidatePath_ud800
public void testValidatePath_ud800()
{    PathUtils.validatePath("/test\ud800");}
60455af175fbc88f9dc9123fd7163f680290c95d0689e866244322ae3b967544
testValidatePath_uf8ff
public void testValidatePath_uf8ff()
{    PathUtils.validatePath("/test\uf8ff");}
30848ff5783cf4ed37158ec8e1078c4ac8db47c37354ec3336e1c3f9e8f08652
testValidatePath_HighestAllowableChar
public void testValidatePath_HighestAllowableChar()
{    PathUtils.validatePath("/test\uffef");}
934b9abe2cc183e34009efdbc8ef3ee839e5499aca5fc3a54ca61cc7000df2d7
testValidatePath_SupplementaryChar
public void testValidatePath_SupplementaryChar()
{    PathUtils.validatePath("/test\ufff0");}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
03b079c945fcab9858c3481eb6f523528a972065cf567268eb02c75275ca465f
testLoadKeyStore
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ks = new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
1cc940ca05718ff728f94ba25a2d711abd7f8e08b49241d358f2d5feffd35630
testLoadKeyStoreWithWrongPassword
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
4cf936259add6712040aab74c81e24f552c0129f6aaa594eadf2ff87c537a7a6
testLoadKeyStoreWithWrongFilePath
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
4b7883b83a6ba80d3863834ad19bed1df7cc565280fc2ad759ee6035d17cc3f0
testLoadKeyStoreWithNullFilePath
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new PEMFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
55918b57b1fb921d647891dc7e65e50e2d6db1674058289f9339ab29539e7b95
testLoadKeyStoreWithWrongFileType
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
d79105e4d869a2c219c0e45640ac8f1ff1217c8c302edd17994d604f82c13332
testLoadTrustStore
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
9f2adf6f72b8bdc6ac66423711637cf1c6b1b1016e53edf4836e78b163789a02
testLoadTrustStoreWithWrongFilePath
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a73f9b2ad3b3afaffef4974a2039e783b069ad1977b9e7ddce2d56b2a74d6469
testLoadTrustStoreWithNullFilePath
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new PEMFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a0e08bd296d4fe8d42ac776f33e7d07fd3bc34c8e6c6cca3cfee1ac2d195d702
testLoadTrustStoreWithWrongFileType
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(0, ts.size());}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
03b079c945fcab9858c3481eb6f523528a972065cf567268eb02c75275ca465f
testLoadKeyStore
public void testLoadKeyStore() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ks = new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
1cc940ca05718ff728f94ba25a2d711abd7f8e08b49241d358f2d5feffd35630
testLoadKeyStoreWithWrongPassword
public void testLoadKeyStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
4cf936259add6712040aab74c81e24f552c0129f6aaa594eadf2ff87c537a7a6
testLoadKeyStoreWithWrongFilePath
public void testLoadKeyStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
4b7883b83a6ba80d3863834ad19bed1df7cc565280fc2ad759ee6035d17cc3f0
testLoadKeyStoreWithNullFilePath
public void testLoadKeyStoreWithNullFilePath() throws Exception
{    new PKCS12FileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
55918b57b1fb921d647891dc7e65e50e2d6db1674058289f9339ab29539e7b95
testLoadKeyStoreWithWrongFileType
public void testLoadKeyStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
d79105e4d869a2c219c0e45640ac8f1ff1217c8c302edd17994d604f82c13332
testLoadTrustStore
public void testLoadTrustStore() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ts = new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
03a002fca594ad67b563908dde58ce82b424db5e99bf54f7e50148a706f3eb4d
testLoadTrustStoreWithWrongPassword
public void testLoadTrustStoreWithWrongPassword() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
9f2adf6f72b8bdc6ac66423711637cf1c6b1b1016e53edf4836e78b163789a02
testLoadTrustStoreWithWrongFilePath
public void testLoadTrustStoreWithWrongFilePath() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a73f9b2ad3b3afaffef4974a2039e783b069ad1977b9e7ddce2d56b2a74d6469
testLoadTrustStoreWithNullFilePath
public void testLoadTrustStoreWithNullFilePath() throws Exception
{    new PKCS12FileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
a0e08bd296d4fe8d42ac776f33e7d07fd3bc34c8e6c6cca3cfee1ac2d195d702
testLoadTrustStoreWithWrongFileType
public void testLoadTrustStoreWithWrongFileType() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    System.out.print("Starting\n");    final TimeTest test = new TimeTest();    System.out.print("After construct\n");    test.setUp();    ZooKeeper zk = test.createClient();    zk.create("/ephemeral", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    while (Time.currentElapsedTime() - nt0 < 100000) {        System.out.printf("%d\t%s\n", discrepancy(), zk.exists("/ephemeral", watchCount.get() == 0 ? createWatcher() : null) != null);        waitByYielding(500);    }}
d0b146cb0e75b6598089518adb101865713e7c4d8bdb3138d821db78e1fe2080
createWatcher
private static Watcher createWatcher()
{    watchCount.incrementAndGet();    return event -> {        watchCount.decrementAndGet();        System.out.printf("%d event = %s\n", discrepancy(), event);    };}
ab287e62d692b03c4f18f7a28e64a8d92e71262e94c2e10e2d842617018877be
waitByYielding
private static void waitByYielding(long delay)
{    long t0 = Time.currentElapsedTime();    while (Time.currentElapsedTime() < t0 + delay) {        Thread.yield();    }}
a08285b92d317080b16d2658ce435e641bd647e91ca452d9772217681a94b818
discrepancy
private static long discrepancy()
{    return (System.currentTimeMillis() - mt0) - (Time.currentElapsedTime() - nt0);}
4377e8339d69ba72324a2d032d6c61ff0255abe3c83de09430e224c2643664ee
testElapsedTimeToDate
public void testElapsedTimeToDate() throws Exception
{    long walltime = Time.currentWallTime();    long elapsedTime = Time.currentElapsedTime();    Thread.sleep(200);    Calendar cal = Calendar.getInstance();    cal.setTime(Time.elapsedTimeToDate(elapsedTime));    int calculatedDate = cal.get(Calendar.HOUR_OF_DAY);    cal.setTime(new Date(walltime));    int realDate = cal.get(Calendar.HOUR_OF_DAY);    assertEquals(calculatedDate, realDate);}
4c094d38b449138b19492c54cdd266b079c3e38f8120377c1ee24d847dc0e25d
keyPairToType
private X509KeyType keyPairToType(KeyPair keyPair)
{    if (keyPair.getPrivate().getAlgorithm().contains("RSA")) {        return X509KeyType.RSA;    } else {        return X509KeyType.EC;    }}
131d6efe46e337b9d8523257c3661acf79faca910eea9cd7d1984b4f323239de
getTempDir
public File getTempDir()
{    return tempDir;}
4cfe896bb44a89d033b7e42ea2a2dbe579950aacf887be788cca0648b2798886
getTrustStoreKeyType
public X509KeyType getTrustStoreKeyType()
{    return trustStoreKeyType;}
11ca6f9b0c2f3b2b6928a2d96b7042af02b16c9884fa0de11f1a5e0f4a723d67
getTrustStoreKeyPair
public KeyPair getTrustStoreKeyPair()
{    return trustStoreKeyPair;}
f375693f160292b376a9ebf471cb0081d4d2b48a550765341e885ce2549f3a22
getTrustStoreCertExpirationMillis
public long getTrustStoreCertExpirationMillis()
{    return trustStoreCertExpirationMillis;}
caec3fb9885d08f456663cfbde53b9dc816b2bad89e61f9a7e5c8edc52f76444
getTrustStoreCertificate
public X509Certificate getTrustStoreCertificate()
{    return trustStoreCertificate;}
6c3b9f5e3f41a027db4b1f3b5959d83161562942e912f26bbb67a509f96296d7
getTrustStorePassword
public String getTrustStorePassword()
{    return trustStorePassword;}
4f600c4aee136a01af30688ca66b59771ed02cb4c08e00a6a31dad2889cbc940
getTrustStoreFile
public File getTrustStoreFile(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getTrustStoreJksFile();        case PEM:            return getTrustStorePemFile();        case PKCS12:            return getTrustStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid trust store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
47ad35fbce89f274ab2243e47b28cef46d1701fb7ce19c65981ca4919dc9a378
getTrustStoreJksFile
private File getTrustStoreJksFile() throws IOException
{    if (trustStoreJksFile == null) {        File trustStoreJksFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        trustStoreJksFile.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStoreJksFile)) {            byte[] bytes = X509TestHelpers.certToJavaTrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStoreJksFile = trustStoreJksFile;    }    return trustStoreJksFile;}
e5b8b1b7c4979e44aebcdd32cb79b0f0db0698684f5fbb01cd67c82bb8378b9d
getTrustStorePemFile
private File getTrustStorePemFile() throws IOException
{    if (trustStorePemFile == null) {        File trustStorePemFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);        trustStorePemFile.deleteOnExit();        FileUtils.writeStringToFile(trustStorePemFile, X509TestHelpers.pemEncodeX509Certificate(trustStoreCertificate), StandardCharsets.US_ASCII, false);        this.trustStorePemFile = trustStorePemFile;    }    return trustStorePemFile;}
9d6c85b2077bdf086242ee2dd3e3a6411d67caa52901b8cc5d371ae439ade7f8
getTrustStorePkcs12File
private File getTrustStorePkcs12File() throws IOException
{    if (trustStorePkcs12File == null) {        File trustStorePkcs12File = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        trustStorePkcs12File.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certToPKCS12TrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStorePkcs12File = trustStorePkcs12File;    }    return trustStorePkcs12File;}
68eb136c89a118bf69ad70cfea0465d43dc0f052db4b5c2943c33ca5764c7a26
getKeyStoreKeyType
public X509KeyType getKeyStoreKeyType()
{    return keyStoreKeyType;}
0115003391eeeb0c252a003e80cb7e81dc19003bb85798636400671ab3fb37fb
getKeyStoreKeyPair
public KeyPair getKeyStoreKeyPair()
{    return keyStoreKeyPair;}
1ec3447ef48dbc223a529950f6c28a46820585051d559d32cadfd6d9243c3c57
getKeyStoreCertExpirationMillis
public long getKeyStoreCertExpirationMillis()
{    return keyStoreCertExpirationMillis;}
898715360369d45f107b31dfd0f0ade4b8c335bc8dc697b0ad56a79353d90b10
getKeyStoreCertificate
public X509Certificate getKeyStoreCertificate()
{    return keyStoreCertificate;}
3e2531ff0022fb65b34f2c64f2d26c5cfbc79fa21545f04f644027dbcceb315e
getKeyStorePassword
public String getKeyStorePassword()
{    return keyStorePassword;}
1c0c37df327738f4e2491c74ea934d664dcea4291f667d0310ba6f0366d33097
isKeyStoreEncrypted
public boolean isKeyStoreEncrypted()
{    return keyStorePassword.length() > 0;}
b762ed1918e96ca2c7e08378a2b412c8c981919e269f5bd27db4395940d657ec
getKeyStoreFile
public File getKeyStoreFile(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getKeyStoreJksFile();        case PEM:            return getKeyStorePemFile();        case PKCS12:            return getKeyStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid key store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
cdb6c581ba8094b5fb68508698f5cb8fefc9483efd77552e96cf8a81c3fc6c59
getKeyStoreJksFile
private File getKeyStoreJksFile() throws IOException
{    if (keyStoreJksFile == null) {        File keyStoreJksFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        keyStoreJksFile.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStoreJksFile)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToJavaKeyStoreBytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStoreJksFile = keyStoreJksFile;    }    return keyStoreJksFile;}
64f9f44e992cb9464f2d0d74a8905d905ee956fe573e97eeb26fdb1795a83d97
getKeyStorePemFile
private File getKeyStorePemFile() throws IOException
{    if (keyStorePemFile == null) {        try {            File keyStorePemFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);            keyStorePemFile.deleteOnExit();            FileUtils.writeStringToFile(keyStorePemFile, X509TestHelpers.pemEncodeCertAndPrivateKey(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword), StandardCharsets.US_ASCII, false);            this.keyStorePemFile = keyStorePemFile;        } catch (OperatorCreationException e) {            throw new IOException(e);        }    }    return keyStorePemFile;}
40335626abddc3bf15e4e50660f6d611a2d5cb27ad942a774bb6fef41d5da55e
getKeyStorePkcs12File
private File getKeyStorePkcs12File() throws IOException
{    if (keyStorePkcs12File == null) {        File keyStorePkcs12File = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        keyStorePkcs12File.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToPKCS12Bytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStorePkcs12File = keyStorePkcs12File;    }    return keyStorePkcs12File;}
ec1dc9d1b153e6bb659c0dcb127e5bb7cf2ae28d965f87ae09ec1c2dcbaefadc
setSystemProperties
public void setSystemProperties(X509Util x509Util, KeyStoreFileType keyStoreFileType, KeyStoreFileType trustStoreFileType) throws IOException
{    System.setProperty(x509Util.getSslKeystoreLocationProperty(), this.getKeyStoreFile(keyStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslKeystorePasswdProperty(), this.getKeyStorePassword());    System.setProperty(x509Util.getSslKeystoreTypeProperty(), keyStoreFileType.getPropertyValue());    System.setProperty(x509Util.getSslTruststoreLocationProperty(), this.getTrustStoreFile(trustStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslTruststorePasswdProperty(), this.getTrustStorePassword());    System.setProperty(x509Util.getSslTruststoreTypeProperty(), trustStoreFileType.getPropertyValue());    if (hostnameVerification != null) {        System.setProperty(x509Util.getSslHostnameVerificationEnabledProperty(), hostnameVerification.toString());    } else {        System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());    }}
ac8e2a911732c2c391d3fc3996c8738160a6305d931329e7535a1ac7aac73b40
clearSystemProperties
public void clearSystemProperties(X509Util x509Util)
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    System.clearProperty(x509Util.getSslKeystoreTypeProperty());    System.clearProperty(x509Util.getSslTruststoreLocationProperty());    System.clearProperty(x509Util.getSslTruststorePasswdProperty());    System.clearProperty(x509Util.getSslTruststoreTypeProperty());    System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());}
3c44b0d6a0f59d494fa0a3f2e2998472439843829598350d8b9ee59f432f4243
build
public X509TestContext build() throws IOException, GeneralSecurityException, OperatorCreationException
{    KeyPair trustStoreKeyPair = X509TestHelpers.generateKeyPair(trustStoreKeyType);    KeyPair keyStoreKeyPair = X509TestHelpers.generateKeyPair(keyStoreKeyType);    return new X509TestContext(tempDir, trustStoreKeyPair, trustStoreCertExpirationMillis, trustStorePassword, keyStoreKeyPair, keyStoreCertExpirationMillis, keyStorePassword, hostnameVerification);}
288f34fdeef45b4327a95845871f5c3c66598f0df6a68e5e16776006e0a1a4e0
setTempDir
public Builder setTempDir(File tempDir)
{    this.tempDir = tempDir;    return this;}
76cf16195937e1535fb8585c74528e7d734c26bce8381fe78296c640a71063d6
setTrustStoreKeyType
public Builder setTrustStoreKeyType(X509KeyType keyType)
{    trustStoreKeyType = keyType;    return this;}
046f1654ae152e542be6fcc682178a93f343e85bc91ecd01503f6f11a2f69ec2
setTrustStorePassword
public Builder setTrustStorePassword(String password)
{    trustStorePassword = password;    return this;}
cb6ac2bb5209b28ef4089221e2a98f3816177e5f35088e8bb746dcfba32a5cdb
setTrustStoreCertExpirationMillis
public Builder setTrustStoreCertExpirationMillis(long expirationMillis)
{    trustStoreCertExpirationMillis = expirationMillis;    return this;}
856d0008df6ae179779e5400b4d4933f3c17e6856c433c26b8a8bd687f0a2e07
setKeyStoreKeyType
public Builder setKeyStoreKeyType(X509KeyType keyType)
{    keyStoreKeyType = keyType;    return this;}
f5d9df2295d7ab0441f4d94a8de76851b750078bb86861eb392f0640fc145788
setKeyStorePassword
public Builder setKeyStorePassword(String password)
{    keyStorePassword = password;    return this;}
6ab7e13c175b6725a3f8db498338520a6f48f03ac3509b2e3a3321e08de3211e
setKeyStoreCertExpirationMillis
public Builder setKeyStoreCertExpirationMillis(long expirationMillis)
{    keyStoreCertExpirationMillis = expirationMillis;    return this;}
724cb05c1dfd3f04893661ec96a070778826f0526c72c0fd5bca0a4a849f531b
setHostnameVerification
public Builder setHostnameVerification(Boolean hostnameVerification)
{    this.hostnameVerification = hostnameVerification;    return this;}
e32f866eb7533a232fadc4ef42bb022716435f415dc4a0f7ed4fff845f45ead0
newBuilder
public static Builder newBuilder()
{    return new Builder();}
ad713f70538085c7af5dcf28487101508a8136311fdd80d03dc8288450175e2c
newSelfSignedCACert
public static X509Certificate newSelfSignedCACert(X500Name subject, KeyPair keyPair, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(    subject, now, new Date(now.getTime() + expirationMillis), subject, keyPair.getPublic());        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(true));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return buildAndSignCertificate(keyPair.getPrivate(), builder);}
d1bcf4d1b4d29b7b564fea856b49d386cdf7951501b218263bf83d8ae59baa89
newCert
public static X509Certificate newCert(X509Certificate caCert, KeyPair caKeyPair, X500Name certSubject, PublicKey certPublicKey, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    if (!caKeyPair.getPublic().equals(caCert.getPublicKey())) {        throw new IllegalArgumentException("CA private key does not match the public key in the CA cert");    }    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(new X500Name(caCert.getIssuerDN().getName()), now, new Date(now.getTime() + expirationMillis), certSubject, certPublicKey);        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(false));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    builder.addExtension(Extension.extendedKeyUsage, true, new ExtendedKeyUsage(new KeyPurposeId[] { KeyPurposeId.id_kp_serverAuth, KeyPurposeId.id_kp_clientAuth }));    builder.addExtension(Extension.subjectAlternativeName, false, getLocalhostSubjectAltNames());    return buildAndSignCertificate(caKeyPair.getPrivate(), builder);}
f1c0393ea0a4f2152f17846119e04a0e0098cb2dedcfc97c4ea8420cb8186f78
getLocalhostSubjectAltNames
private static GeneralNames getLocalhostSubjectAltNames() throws UnknownHostException
{    InetAddress[] localAddresses = InetAddress.getAllByName("localhost");    GeneralName[] generalNames = new GeneralName[localAddresses.length + 1];    for (int i = 0; i < localAddresses.length; i++) {        generalNames[i] = new GeneralName(GeneralName.iPAddress, new DEROctetString(localAddresses[i].getAddress()));    }    generalNames[generalNames.length - 1] = new GeneralName(GeneralName.dNSName, new DERIA5String("localhost"));    return new GeneralNames(generalNames);}
933b3a992ed7e04510326db314a12763996df4d952c97c3028056279c87f8187
initCertBuilder
private static X509v3CertificateBuilder initCertBuilder(X500Name issuer, Date notBefore, Date notAfter, X500Name subject, PublicKey subjectPublicKey)
{    return new X509v3CertificateBuilder(issuer, new BigInteger(SERIAL_NUMBER_MAX_BITS, PRNG), notBefore, notAfter, subject, SubjectPublicKeyInfo.getInstance(subjectPublicKey.getEncoded()));}
02ece0ee8ac0de4e2c23e438c362bd14d78858fc80c558f224d158ec35e628a9
buildAndSignCertificate
private static X509Certificate buildAndSignCertificate(PrivateKey privateKey, X509v3CertificateBuilder builder) throws IOException, OperatorCreationException, CertificateException
{    BcContentSignerBuilder signerBuilder;    if (privateKey.getAlgorithm().contains("RSA")) {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256WithRSAEncryption");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    } else {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256withECDSA");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcECContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    }    AsymmetricKeyParameter privateKeyParam = PrivateKeyFactory.createKey(privateKey.getEncoded());    ContentSigner signer = signerBuilder.build(privateKeyParam);    return toX509Cert(builder.build(signer));}
794e66e3108e13d3097121ca84c85f268a4c1733624abfafc1a25a3dc42d8579
generateKeyPair
public static KeyPair generateKeyPair(X509KeyType keyType) throws GeneralSecurityException
{    switch(keyType) {        case RSA:            return generateRSAKeyPair();        case EC:            return generateECKeyPair();        default:            throw new IllegalArgumentException("Invalid X509KeyType");    }}
419f1a73727e352f4c9b381aba44c255a94779bbdf9c275fc5dca34951755301
generateRSAKeyPair
public static KeyPair generateRSAKeyPair() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");    RSAKeyGenParameterSpec keyGenSpec = new RSAKeyGenParameterSpec(DEFAULT_RSA_KEY_SIZE_BITS, DEFAULT_RSA_PUB_EXPONENT);    keyGen.initialize(keyGenSpec, PRNG);    return keyGen.generateKeyPair();}
678a27e88bcbcd1160388b4fcdf7c4c9f23329b5f4a729d1e2a30349e8fa7a12
generateECKeyPair
public static KeyPair generateECKeyPair() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");    keyGen.initialize(new ECGenParameterSpec(DEFAULT_ELLIPTIC_CURVE_NAME), PRNG);    return keyGen.generateKeyPair();}
d30b43d9a9619b0d649904c3afc6de3a56ea5c64d3b4d0f5f50fe374e38a3e83
pemEncodeCertAndPrivateKey
public static String pemEncodeCertAndPrivateKey(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, OperatorCreationException
{    return pemEncodeX509Certificate(cert) + "\n" + pemEncodePrivateKey(privateKey, keyPassword);}
1724e19abc47334f10b6b414177f228941bb0e1449f48f3b3e17f6c023b6915a
pemEncodePrivateKey
public static String pemEncodePrivateKey(PrivateKey key, String password) throws IOException, OperatorCreationException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    OutputEncryptor encryptor = null;    if (password != null && password.length() > 0) {        encryptor = new JceOpenSSLPKCS8EncryptorBuilder(PKCSObjectIdentifiers.pbeWithSHAAnd3_KeyTripleDES_CBC).setProvider(BouncyCastleProvider.PROVIDER_NAME).setRandom(PRNG).setPasssword(password.toCharArray()).build();    }    pemWriter.writeObject(new JcaPKCS8Generator(key, encryptor));    pemWriter.close();    return stringWriter.toString();}
cce67a2dd0fbc0ebe326183b52dc5d981734e28ea8f723e27ea9028fd7a962ac
pemEncodeX509Certificate
public static String pemEncodeX509Certificate(X509Certificate cert) throws IOException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    pemWriter.writeObject(cert);    pemWriter.close();    return stringWriter.toString();}
d603e8d2fe0af636cdd3b63eac0a3efde18c7901e2b54a35cd969acadb988294
certToJavaTrustStoreBytes
public static byte[] certToJavaTrustStoreBytes(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
f3208e1626660cae377d9395df9a75cecd3541a9f0540b904d5e45fed2bd3bf8
certToPKCS12TrustStoreBytes
public static byte[] certToPKCS12TrustStoreBytes(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance("PKCS12");    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
1f7673fdeb0b265db6995341e2d8b075495213c45e44f2fa981a2ed2fa1334f1
certToTrustStoreBytes
private static byte[] certToTrustStoreBytes(X509Certificate cert, String keyPassword, KeyStore trustStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    trustStore.load(null, keyPasswordChars);    trustStore.setCertificateEntry(cert.getSubjectDN().toString(), cert);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    trustStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
319c1c663548f098fce02f379bfcda10ba86d30682beb2796a6dc6fd9135c0e8
certAndPrivateKeyToJavaKeyStoreBytes
public static byte[] certAndPrivateKeyToJavaKeyStoreBytes(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
e910557ad93a34d1a5f14ffac49f18ba689f9b7bc54e2c6d3ce438fd0cc95816
certAndPrivateKeyToPKCS12Bytes
public static byte[] certAndPrivateKeyToPKCS12Bytes(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("PKCS12");    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
9c5a7d633f3c9d3520911456b25d0b6bdf2bcfa1331be0c37d5e5b94f8709d12
certAndPrivateKeyToPKCS12Bytes
private static byte[] certAndPrivateKeyToPKCS12Bytes(X509Certificate cert, PrivateKey privateKey, String keyPassword, KeyStore keyStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    keyStore.load(null, keyPasswordChars);    keyStore.setKeyEntry("key", privateKey, keyPasswordChars, new Certificate[] { cert });    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    keyStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
a158b57d8d901af43ab70df2440c35775e9425d68b81b90daea178bc572dba9c
toX509Cert
public static X509Certificate toX509Cert(X509CertificateHolder certHolder) throws CertificateException
{    return new JcaX509CertificateConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME).getCertificate(certHolder);}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    try (X509Util x509util = new ClientX509Util()) {        x509TestContext.setSystemProperties(x509util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    }    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    x509Util = new ClientX509Util();}
8d9ec964cb2b1702f35510b65dc80717f83aa9b6d06f2d7caf8545c5d3f9a1d1
cleanUp
public void cleanUp()
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslOcspEnabledProperty());    System.clearProperty(x509Util.getSslCrlEnabledProperty());    System.clearProperty(x509Util.getCipherSuitesProperty());    System.clearProperty(x509Util.getSslProtocolProperty());    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    System.clearProperty("com.sun.net.ssl.checkRevocation");    System.clearProperty("com.sun.security.enableCRLDP");    Security.setProperty("ocsp.enable", Boolean.FALSE.toString());    Security.setProperty("com.sun.security.enableCRLDP", Boolean.FALSE.toString());    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    x509Util.close();}
376e30a287916ec8dea2cd45cb168516d55e02505afb193c987f032544110adb
testCreateSSLContextWithoutCustomProtocol
public void testCreateSSLContextWithoutCustomProtocol() throws Exception
{    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(X509Util.DEFAULT_PROTOCOL, sslContext.getProtocol());}
7fdd287303d4a25ae6b03bbb04d69625e66a125620eb2584e04f93f25416fc4b
testCreateSSLContextWithCustomProtocol
public void testCreateSSLContextWithCustomProtocol() throws Exception
{    final String protocol = "TLSv1.1";    System.setProperty(x509Util.getSslProtocolProperty(), protocol);    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(protocol, sslContext.getProtocol());}
3ae4c90dbd6c9caacfee1d47a79d07b5b2a5f1e516a4654262203f7a7321335a
testCreateSSLContextWithoutKeyStoreLocation
public void testCreateSSLContextWithoutKeyStoreLocation() throws Exception
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    x509Util.getDefaultSSLContext();}
c1eeaa82ff36e2a5f48e45a355dd0057dc6fb9efad2188ad6c3f4bd66184946d
testCreateSSLContextWithoutKeyStorePassword
public void testCreateSSLContextWithoutKeyStorePassword() throws Exception
{    if (!x509TestContext.isKeyStoreEncrypted()) {        throw new X509Exception.SSLContextException("");    }    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    x509Util.getDefaultSSLContext();}
696b2c17a62d664b6294cc5ff1a9e8c22b326aa9597ad771fc6b1bd591e6593b
testCreateSSLContextWithCustomCipherSuites
public void testCreateSSLContextWithCustomCipherSuites() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
8d034b979653effe5444aecd81315fbaf9334671c04cb0f9731bb88d211f94ce
testCRLEnabled
public void testCRLEnabled() throws Exception
{    System.setProperty(x509Util.getSslCrlEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
3bb558d4ee5de1f2927d97e0ae11b5ce6fd8f45efed810dc196e883f4f76c190
testCRLDisabled
public void testCRLDisabled() throws Exception
{    x509Util.getDefaultSSLContext();    assertFalse(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertFalse(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
b9ae171d5c956fa8d59ff336b337fdd43e948736430ead7fc905c594e6859303
testOCSPEnabled
public void testOCSPEnabled() throws Exception
{    System.setProperty(x509Util.getSslOcspEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertTrue(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
dfac0d51b559ccc8c827d1b208521bb7694182c4c41babc2f60412b27f53b7c5
testCreateSSLSocket
public void testCreateSSLSocket() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
3422437a8aa0801cfd99c2f82f08df54a49180a83fe013939d42fa2a4194478b
testCreateSSLServerSocketWithoutPort
public void testCreateSSLServerSocketWithoutPort() throws Exception
{    setCustomCipherSuites();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket();    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
53600c246b50af64b462d36fa99761e3741536f18d9281af830b9e920d563225
testCreateSSLServerSocketWithPort
public void testCreateSSLServerSocketWithPort() throws Exception
{    setCustomCipherSuites();    int port = PortAssignment.unique();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket(port);    assertEquals(sslServerSocket.getLocalPort(), port);    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
4dff2dabdc0124912dbbad2f88f7ac471895bb643d65b6e390e3754bc6983358
testLoadPEMKeyStore
public void testLoadPEMKeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PEM.getPropertyValue());}
24284baa6de0bc96f67712cae07ca3c0a52488b1aa7fb99b5f64802d8778acfb
testLoadPEMKeyStoreNullPassword
public void testLoadPEMKeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue());}
763b73d618acade8675319ab559d57fae58bb0f0b1fc0c983b1b83c920ccf228
testLoadPEMKeyStoreAutodetectStoreFileType
public void testLoadPEMKeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
5d6d8d3af7a1faceb554e388a5d900cc2764048400db1a3b203ce4a9453d6a94
testLoadPEMKeyStoreWithWrongPassword
public void testLoadPEMKeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(),     "wrong password", KeyStoreFileType.PEM.getPropertyValue());}
163dad3601529aee7aa680034a9cf3dc821cc6f3de4bee11a9b4338e047408a2
testLoadPEMTrustStore
public void testLoadPEMTrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
3d3d20187c867b99b6d57981c400ca7e861199371f6e8175a073de5b03b929db
testLoadPEMTrustStoreNullPassword
public void testLoadPEMTrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
5922185db2f69f2d465c4ae6f2f66c3d24bd2bf8d5b384ba5c3d00b5a9cfb1c3
testLoadPEMTrustStoreAutodetectStoreFileType
public void testLoadPEMTrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, false, false, true, true);}
bd127fc71026adce5b1702584beae35063ac479bd5878319a47a08cfc7d42860
testLoadJKSKeyStore
public void testLoadJKSKeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.JKS.getPropertyValue());}
54cb71056352fe51c6e99df793f6b900a4d01aa5403ccbee51b0e8f169f7a18d
testLoadJKSKeyStoreNullPassword
public void testLoadJKSKeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue());}
f1e9b1cc7bbd10b748bbb07e5b9b936b52c061c6e2bf54b6adb11b3b47a74292
testLoadJKSKeyStoreAutodetectStoreFileType
public void testLoadJKSKeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
3b5173c904c7a59aa811ba8fecf4a12ce9f7553ec89f31bcc6ff4d24649c5b85
testLoadJKSKeyStoreWithWrongPassword
public void testLoadJKSKeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue());}
a361aaece16dc1372945b4f8cdb4d513ff859985b872c4c91084642f41ac5099
testLoadJKSTrustStore
public void testLoadJKSTrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
57e23116f43604e981a9df1775229b67e814b873b130e7322c6616da00df05a2
testLoadJKSTrustStoreNullPassword
public void testLoadJKSTrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue(), false, false, true, true);}
90fcedd47813c2b476925896a8820152f305d1fbea23a3a674bc436c4fc40031
testLoadJKSTrustStoreAutodetectStoreFileType
public void testLoadJKSTrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
471ab15520e24d67a42bb11c9a5da71065420af5f07e46e6296be39b50a04d6a
testLoadJKSTrustStoreWithWrongPassword
public void testLoadJKSTrustStoreWithWrongPassword() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
eb4711d8e673a239393a729ebd52a8cf06ea48d7e7d202e858c034bb66b32058
testLoadPKCS12KeyStore
public void testLoadPKCS12KeyStore() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue());}
33f4aee11037cabd31993f80a1f0308ebdff0f32c60d25bdbeaedb9a3aeedf63
testLoadPKCS12KeyStoreNullPassword
public void testLoadPKCS12KeyStoreNullPassword() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue());}
de382c6bb0b83120b8e8ad14f205550d319499cb50268f6e4ccbd56c1c9fd3cf
testLoadPKCS12KeyStoreAutodetectStoreFileType
public void testLoadPKCS12KeyStoreAutodetectStoreFileType() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
9f3f699614bb2642047d1cb405cb125d9eb8e4e4c2680db093516365b07b3e68
testLoadPKCS12KeyStoreWithWrongPassword
public void testLoadPKCS12KeyStoreWithWrongPassword() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue());}
eda1766f0e936c293121a45f2c5ce4e31f954ebab09450750a688f73f68c126f
testLoadPKCS12TrustStore
public void testLoadPKCS12TrustStore() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
1594a4c6e52b517a7c59d290f93a89067b60ea28eb190a1effe225a97728aca0
testLoadPKCS12TrustStoreNullPassword
public void testLoadPKCS12TrustStoreNullPassword() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue(), false, false, true, true);}
0ad275f9d4a42689b888f82181f937c0ccf45394c9de7970931a475898c66f11
testLoadPKCS12TrustStoreAutodetectStoreFileType
public void testLoadPKCS12TrustStoreAutodetectStoreFileType() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
3a3530496be5b7171d2b42d829711b04ce3d6494613251042e37ce99206a3201
testLoadPKCS12TrustStoreWithWrongPassword
public void testLoadPKCS12TrustStoreWithWrongPassword() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
9cf72622a6ca0dcd49d5f785e23ec8efddadaaad358c08af0dd65e8805b1676d
testGetSslHandshakeDetectionTimeoutMillisProperty
public void testGetSslHandshakeDetectionTimeoutMillisProperty()
{    assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, x509Util.getSslHandshakeTimeoutMillis());        String newPropertyString = Integer.toString(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), newPropertyString);    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "0");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "-1");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }}
42f8829881e190f71b0084ff87a4aad8ca6e153b3a8da0b3382015ac54a6c8a1
testCreateSSLContext_invalidCustomSSLContextClass
public void testCreateSSLContext_invalidCustomSSLContextClass() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), String.class.getCanonicalName());    clientX509Util.createSSLContext(zkConfig);}
7aace874ca1435138599b1406919713a7eedc8a5b8cbd63deccd5420e7d3703d
testCreateSSLContext_validCustomSSLContextClass
public void testCreateSSLContext_validCustomSSLContextClass() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), SslContextSupplier.class.getName());    final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);    assertEquals(SSLContext.getDefault(), sslContext);}
a7dd7579d4a4fe815703c75891bed388694a8ae571b5c76e548be5ecbc84b2e7
forceClose
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
ddf6e9cdfc4ff839e4398b8f57b17d172d5a96d77b676b57bf9ff0e335a66845
forceClose
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
d9dbacc216fa6022d7df67a2be9ee08d2a608032238687669f77853d0ef8be68
testClientRenegotiationFails
public void testClientRenegotiationFails() throws Throwable
{    int port = PortAssignment.unique();    ExecutorService workerPool = Executors.newCachedThreadPool();    final SSLServerSocket listeningSocket = x509Util.createSSLServerSocket();    SSLSocket clientSocket = null;    SSLSocket serverSocket = null;    final AtomicInteger handshakesCompleted = new AtomicInteger(0);    final CountDownLatch handshakeCompleted = new CountDownLatch(1);    try {        InetSocketAddress localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);        listeningSocket.bind(localServerAddress);        Future<SSLSocket> acceptFuture;        acceptFuture = workerPool.submit(new Callable<SSLSocket>() {            @Override            public SSLSocket call() throws Exception {                SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                    @Override                    public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                        handshakesCompleted.getAndIncrement();                        handshakeCompleted.countDown();                    }                });                assertEquals(1, sslSocket.getInputStream().read());                try {                                        sslSocket.getInputStream().read();                    return sslSocket;                } catch (Exception e) {                    forceClose(sslSocket);                    throw e;                }            }        });        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(1);                clientSocket.startHandshake();        clientSocket.getOutputStream().write(1);                try {            serverSocket = acceptFuture.get();        } catch (ExecutionException e) {            throw e.getCause();        }    } finally {        forceClose(serverSocket);        forceClose(clientSocket);        forceClose(listeningSocket);        workerPool.shutdown();                        handshakeCompleted.await(5, TimeUnit.SECONDS);        assertEquals(1, handshakesCompleted.get());    }}
b1878c0596e7dd84b942a5529a37786aeacf8f0da7ff470fed5e672ff38e8de3
call
public SSLSocket call() throws Exception
{    SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();    sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {        @Override        public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {            handshakesCompleted.getAndIncrement();            handshakeCompleted.countDown();        }    });    assertEquals(1, sslSocket.getInputStream().read());    try {                sslSocket.getInputStream().read();        return sslSocket;    } catch (Exception e) {        forceClose(sslSocket);        throw e;    }}
4b255c4df0a58c20223e5a169af885f5c8ad586a78e36e68f2d3f3803706a583
handshakeCompleted
public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent)
{    handshakesCompleted.getAndIncrement();    handshakeCompleted.countDown();}
941df5c0ea1db2ad4cf9779aa35e3ea15676ad3ae40987bca54633cf7e7f571e
testGetDefaultCipherSuitesJava8
public void testGetDefaultCipherSuitesJava8()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("1.8");        assertTrue(cipherSuites[0].contains("CBC"));}
51b091152d5115dea5a60430e367b09637a836869121456d11704708897e4d66
testGetDefaultCipherSuitesJava9
public void testGetDefaultCipherSuitesJava9()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("9");        assertTrue(cipherSuites[0].contains("GCM"));}
26b818a025d886cef44ab1f1409cdb7a35a93ed7c18667fbb0d8558a627eb967
testGetDefaultCipherSuitesJava10
public void testGetDefaultCipherSuitesJava10()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("10");        assertTrue(cipherSuites[0].contains("GCM"));}
0888a3288b6781d38b0b40c64f4fb58b33688cc6aba4badfcb602e4318208702
testGetDefaultCipherSuitesJava11
public void testGetDefaultCipherSuitesJava11()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("11");        assertTrue(cipherSuites[0].contains("GCM"));}
a1451013bc7b2cbe5aea50566afef72885666e24ec998c6d6a516bbc7eafb91d
testGetDefaultCipherSuitesUnknownVersion
public void testGetDefaultCipherSuitesUnknownVersion()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("notaversion");        assertTrue(cipherSuites[0].contains("CBC"));}
fcdfc58cb52a6b7dd285f6bfbc7ec3a2beb8500982d09790b0c0afd1b5cc5979
testGetDefaultCipherSuitesNullVersion
public void testGetDefaultCipherSuitesNullVersion()
{    X509Util.getDefaultCipherSuitesForJavaVersion(null);}
2679bc51d366afc224413d213d8b8c8e93f8e65ea82ed8089641adca0776cc51
setCustomCipherSuites
private void setCustomCipherSuites()
{    System.setProperty(x509Util.getCipherSuitesProperty(), customCipherSuites[0] + "," + customCipherSuites[1]);        x509Util.close();    x509Util = new ClientX509Util();}
a788e2d0ca1ef09ce624e2c1892ea682cca511763825a2e9136c3aaca396e2c1
get
public SSLContext get()
{    try {        return SSLContext.getDefault();    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
b6b11143be6f7573045e747dfae416aecea2c28a057b9e3f8bb421bedcc04208
createKeyPair
public static void createKeyPair() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    keyPair = keyPairGenerator.genKeyPair();}
ae3503762e1c7e61fc9866b54c916354e0a56d2320c76cdb474c8469419de69f
removeBouncyCastleProvider
public static void removeBouncyCastleProvider() throws Exception
{    Security.removeProvider("BC");}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    mockX509ExtendedTrustManager = mock(X509ExtendedTrustManager.class);    mockInetAddress = mock(InetAddress.class);    when(mockInetAddress.getHostAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return IP_ADDRESS;        }    });    when(mockInetAddress.getHostName()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return HOSTNAME;        }    });    mockSocket = mock(Socket.class);    when(mockSocket.getInetAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return mockInetAddress;        }    });}
645426bef033115220fbd360a1bd8874a2fb8fde8b21444f231786f17c641cb5
answer
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return IP_ADDRESS;}
645426bef033115220fbd360a1bd8874a2fb8fde8b21444f231786f17c641cb5
answer
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return HOSTNAME;}
645426bef033115220fbd360a1bd8874a2fb8fde8b21444f231786f17c641cb5
answer
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    return mockInetAddress;}
59b6c27be0c2e67e12ade65b4044b35e05375cd8c52887897aa171bf2a2255b3
createSelfSignedCertifcateChain
private X509Certificate[] createSelfSignedCertifcateChain(String ipAddress, String hostname) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, "NOT_LOCALHOST");    Date notBefore = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(notBefore);    cal.add(Calendar.YEAR, 1);    Date notAfter = cal.getTime();    BigInteger serialNumber = new BigInteger(128, new Random());    X509v3CertificateBuilder certificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, notBefore, notAfter, nameBuilder.build(), keyPair.getPublic()).addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    List<GeneralName> generalNames = new ArrayList<>();    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(keyPair.getPrivate());    return new X509Certificate[] { new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner)) };}
1ebb25b7d7aae0a35375211407a7d5a9452664033a1e72a0a1f4a287d3245e8b
testServerHostnameVerificationWithHostnameVerificationDisabled
public void testServerHostnameVerificationWithHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
5275d71812993abbe6a6ac5030d2cf364c4b71ec9c80de8a811d0f599275550d
testServerHostnameVerificationWithHostnameVerificationDisabledAndClientHostnameVerificationEnabled
public void testServerHostnameVerificationWithHostnameVerificationDisabledAndClientHostnameVerificationEnabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
e47a2af3523bfe99b4e9ea19cbc41119814b089d9862f82ed5699de77eb1ffff
testServerHostnameVerificationWithIPAddress
public void testServerHostnameVerificationWithIPAddress() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
8bcec7fb445162ad45e25c1fe4856e87451fd1a41799b14c3b0bdd0865b2420b
testServerHostnameVerificationWithHostname
public void testServerHostnameVerificationWithHostname() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
d0c3264f678cda9b4999e332a28939677705fe00e1e38cc93627ebc92032764a
testClientHostnameVerificationWithHostnameVerificationDisabled
public void testClientHostnameVerificationWithHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
b8912a6fa8cd14b3fc1fbcacc042f065f8e9a7d8d851f01141a7201570be39a1
testClientHostnameVerificationWithClientHostnameVerificationDisabled
public void testClientHostnameVerificationWithClientHostnameVerificationDisabled() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
b05ab44edd506406c40d00f6f5a5486af27127d14c856c16f2822eed335ea56c
testClientHostnameVerificationWithIPAddress
public void testClientHostnameVerificationWithIPAddress() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
33d68653d8fcf4d83a5c2206e21fd91954c6bdde855fb0f2a904c3faa877b625
testClientHostnameVerificationWithHostname
public void testClientHostnameVerificationWithHostname() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 1;}
c9541b1679326fe5747ee15703657217204a99e71b02ed734b5b8338e2dbf914
next
public InetSocketAddress next(long spinDelay)
{    return new InetSocketAddress("127.0.0.1", 2181);}
64600557351d3b7f57b85f6e15c785fbf1a79e303c7e3c5263e83b9b48a4275e
onConnected
public void onConnected()
{}
2ddb301ab65ae4914a769f9bb45834c371cd9b2cef53b4df575878968f1e66c2
updateServerList
public boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    counter.decrementAndGet();    return false;}
a23a5601708618b37b7440c88f9396caa03f68e1a3c95e75f31375f29d248c80
testZooKeeperWithCustomHostProvider
public void testZooKeeperWithCustomHostProvider() throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    final HostProvider specialHostProvider = new SpecialHostProvider();    int expectedCounter = 3;    counter.set(expectedCounter);    ZooKeeper zkDefaults = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false);    ZooKeeper zkSpecial = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false, specialHostProvider);    assertTrue(counter.get() == expectedCounter);    zkDefaults.updateServerList("127.0.0.1:" + PortAssignment.unique());    assertTrue(counter.get() == expectedCounter);    zkSpecial.updateServerList("127.0.0.1:" + PortAssignment.unique());    expectedCounter--;    assertTrue(counter.get() == expectedCounter);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
1c4c5c00c6672f7908437de26fb9106213680cd596088394e4aa02b416dd842c
testGetAllChildrenNumberSync
public void testGetAllChildrenNumberSync() throws KeeperException, InterruptedException
{        try {        zk.getAllChildrenNumber(null);        fail("the path for getAllChildrenNumber must not be null.");    } catch (IllegalArgumentException e) {        }    assertEquals(EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE + "/0"));    assertEquals(0, zk.getAllChildrenNumber(BASE + "/0/ephem0"));    assertEquals(0, zk.getAllChildrenNumber(BASE_EXT));    assertEquals(PERSISTENT_CNT + PERSISTENT_CNT * EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE));        assertEquals(13, zk.getAllChildrenNumber("/"));}
a07dc47326892dd41861954736bb2c3bfacad683e8487db17f807b6f87017279
testGetAllChildrenNumberAsync
public void testGetAllChildrenNumberAsync() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    zk.getAllChildrenNumber("/", new AsyncCallback.AllChildrenNumberCallback() {        @Override        public void processResult(int rc, String path, Object ctx, int number) {            if (path == null) {                fail((String.format("the path of getAllChildrenNumber was null.")));            }            assertEquals(13, number);            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getAllChildrenNumber didn't callback within %d seconds", waitForCallbackSecs));    }}
9b8c8d72695f60ab1a22d9330f921f1a9396090326e15f72c22323529054cefb
processResult
public void processResult(int rc, String path, Object ctx, int number)
{    if (path == null) {        fail((String.format("the path of getAllChildrenNumber was null.")));    }    assertEquals(13, number);    doneProcessing.countDown();}
1e02b5cfb9b427b299a7eb21d4c8f810ab04e5fea3a7c5cf95a8347041c5a076
generatePaths
private void generatePaths(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    zk.create(BASE, BASE.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create(BASE_EXT, BASE_EXT.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + "/" + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    expected = generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
e9a4cc7e89dff701faef4207358e3dad509b6c53432965ecb8e5794709cdfe13
testGetEphemeralsSync
public void testGetEphemeralsSync() throws KeeperException, InterruptedException
{    List<String> actual = zk.getEphemerals();    assertEquals("Expected ephemeral count for allPaths", actual.size(), expected.length);    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in get All Ephemerals list ", path), actual.contains(path));    }}
93fe77433114187aed4c496e52fbb22497b3c8b04d334c7ea8a8a5e4c22a6776
testGetEphemeralsSyncByPath
public void testGetEphemeralsSyncByPath() throws KeeperException, InterruptedException
{    final String prefixPath = BASE + 0;    List<String> actual = zk.getEphemerals(prefixPath);    assertEquals("Expected ephemeral count for allPaths", actual.size(), EPHEMERAL_CNT);    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in getEphemerals(%s) list ", path, prefixPath), actual.contains(path));    }}
1d86b30add5db813c99024d83b6bde12917d7e6c17fc5fddc36bddc2363865ca
testGetEphemerals
public void testGetEphemerals() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));            } else if (paths.size() != expected.length) {                unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));            }            for (int i = 0; i < expected.length; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals didn't callback within %d seconds", waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
dfba899bfdc764cb3803667ed6c221d5f91ae12f3a015f1145a9d4d167da78b7
processResult
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));    } else if (paths.size() != expected.length) {        unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));    }    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));        }    }    doneProcessing.countDown();}
05a085900871aafccb78d0b121761853268b2c9716424ba1c2aac6386a3d1bf7
testGetEphemeralsByPath
public void testGetEphemeralsByPath() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = BASE + "0";    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));            } else if (paths.size() != EPHEMERAL_CNT) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));            }            for (int i = 0; i < EPHEMERAL_CNT; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
dfba899bfdc764cb3803667ed6c221d5f91ae12f3a015f1145a9d4d167da78b7
processResult
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));    } else if (paths.size() != EPHEMERAL_CNT) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));    }    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));        }    }    doneProcessing.countDown();}
aeab3c122be7476c0a16923bf1d09d7890f6a3c11ce322364f7dbf4b8d36f9fb
testGetEphemeralsEmpty
public void testGetEphemeralsEmpty() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = "/unknownPath";    final int expectedSize = 0;    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));            } else if (paths.size() != expectedSize) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
dfba899bfdc764cb3803667ed6c221d5f91ae12f3a015f1145a9d4d167da78b7
processResult
public void processResult(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));    } else if (paths.size() != expectedSize) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));    }    doneProcessing.countDown();}
078d12cc42a2d1502873c90f8d0a191f7d83dc2019e6a6a6078c1aaba6f9be62
testGetEphemeralsErrors
public void testGetEphemeralsErrors() throws KeeperException
{    try {        zk.getEphemerals(null, null, null);        fail("Should have thrown a IllegalArgumentException for a null prefixPath");    } catch (IllegalArgumentException e) {        }    try {        zk.getEphemerals("no leading slash", null, null);        fail("Should have thrown a IllegalArgumentException " + "for a prefix with no leading slash");    } catch (IllegalArgumentException e) {        }}
bdf6f0e2b1b554bd8c6dcafe222a3bfd553767903844f1fa038cbcfdb7540a7c
generatePaths
private String[] generatePaths(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    final String[] expected = new String[persistantCnt * ephemeralCnt];    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            expected[p * ephemeralCnt + e] = ephem;        }    }    return expected;}
333370c4badab3db13e3c61d913dc57c277f785d2581fff69ae865eb29d27aba
checkForUnexpectedBehavior
private void checkForUnexpectedBehavior(List<String> unexpectedBehavior)
{    if (unexpectedBehavior.size() > 0) {        StringBuilder b = new StringBuilder("The test failed for the following reasons:");        b.append(NEWLINE);        for (String error : unexpectedBehavior) {            b.append("ERROR: ").append(error).append(NEWLINE);        }        fail(b.toString());    }}
44180f2b6a8b107ef4326b0a01b2cbc7f0fbce68bd66ad5008355b29ff28ac5d
addSection
public void addSection(String name, String loginModuleName, String... args)
{    Map<String, String> conf = new HashMap<String, String>();        for (int i = 0; i < args.length - 1; i += 2) {        conf.put(args[i], args[i + 1]);    }    addSection(name, loginModuleName, conf);}
6475ef3b84d4bcf17be91fda5532613398b05de6572ad3349654e6a88a8a1ff9
addSection
public void addSection(String name, String loginModuleName, final Map<String, String> conf)
{    AppConfigurationEntry[] entries = new AppConfigurationEntry[1];    entries[0] = new AppConfigurationEntry(loginModuleName, LoginModuleControlFlag.REQUIRED, conf);    this.sections.put(name, entries);}
b330e3393d04077310ce342057087dc37fb6295714c1555ce248f76281af836f
getAppConfigurationEntry
public AppConfigurationEntry[] getAppConfigurationEntry(String appName)
{    return sections.get(appName);}
e98dc990321650d9b962c68474cb8e9475a66a256db0695fa2dea2bf270f0c69
computeTestMethodsForClass
public static List<FrameworkMethod> computeTestMethodsForClass(final Class klass, final List<FrameworkMethod> defaultMethods)
{    List<FrameworkMethod> list = defaultMethods;    String methodName = System.getProperty("test.method");    if (methodName == null) {        LOG.info("No test.method specified. using default methods.");    } else {        LOG.info("Picked up test.method={}", methodName);        try {            list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));        } catch (NoSuchMethodException nsme) {            LOG.warn("{} does not have test.method={}. failing to default methods.", klass.getName(), methodName);        }    }    return list;}
d4c504851dde1789d115d59c710ab958554d54076aa2bfaab3c8f10299f9759a
computeTestMethods
protected List<FrameworkMethod> computeTestMethods()
{    return computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
e5a9b399ac7efe244a90464c7bac3dd8fa9cfdb68a93eb7929f52386e3e5bf70
evaluate
public void evaluate() throws Throwable
{    LOG.info("RUNNING TEST METHOD {}", name);    try {        super.evaluate();        Runtime rt = Runtime.getRuntime();        long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;        LOG.info("Memory used {}", usedKB);        ThreadGroup tg = Thread.currentThread().getThreadGroup();        while (tg.getParent() != null) {            tg = tg.getParent();        }        LOG.info("Number of threads {}", tg.activeCount());    } catch (Throwable t) {                                Test annotation = this.method.getAnnotation(Test.class);        if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {            LOG.info("TEST METHOD {} THREW EXPECTED EXCEPTION {}", name, annotation.expected());        } else {            LOG.info("TEST METHOD FAILED {}", name, t);        }        throw t;    }    LOG.info("FINISHED TEST METHOD {}", name);}
976cb6e2792c5eb10ff14b9aad32588e259743c0039bed43778458fdc19a7b02
methodInvoker
protected Statement methodInvoker(FrameworkMethod method, Object test)
{    return new LoggedInvokeMethod(method, test);}
196f20ed34d3bfe7290f99157039d34e764775c8f719bb38d7bd49315fe31b7e
configure
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{}
aa23481d8bd90f78e49a5e500dec98490654ae5479cc9426a36d2ccccada8dcd
getRootContext
public MetricsContext getRootContext()
{    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{}
340d939336a8d9d074f5b17fbef7be8130c1d436e0bd0ce104c85ee060ef513a
dump
public void dump(BiConsumer<String, Object> sink)
{}
45422fa668d7c89937d4e2e3d11a6b1d2aa4f0b27b1259483c201037b224b7bd
resetAllValues
public void resetAllValues()
{}
8b14883896e9dbd16e433d8992a7e3362db19048b3a1baf1298796fbe5db7f6d
reset
public static void reset()
{    configureCalled.set(false);    startCalled.set(false);    stopCalled.set(false);    getRootContextCalled.set(false);}
196f20ed34d3bfe7290f99157039d34e764775c8f719bb38d7bd49315fe31b7e
configure
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    if (!configureCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{    if (!startCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
aa23481d8bd90f78e49a5e500dec98490654ae5479cc9426a36d2ccccada8dcd
getRootContext
public MetricsContext getRootContext()
{    getRootContextCalled.set(true);    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    if (!stopCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
c7e1fb9613f9d6f6b5e1ab7b07ea26f37be1ea72f3deac47d86c6eaf3ef4304e
start
public void start() throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
196f20ed34d3bfe7290f99157039d34e764775c8f719bb38d7bd49315fe31b7e
configure
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
196f20ed34d3bfe7290f99157039d34e764775c8f719bb38d7bd49315fe31b7e
configure
public void configure(Properties prprts) throws MetricsProviderLifeCycleException
{    httpPort.set(Integer.parseInt(prprts.getProperty("httpPort")));}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    stopCalled.set(true);    throw new RuntimeException();}
d71b7e0e4b0a0511ec78174d4da0c535305713c525a8796250fa78e21329bffa
collect
public static Map<String, Object> collect(MetricsProvider metricsProvider)
{    Map<String, Object> res = new HashMap<>();    metricsProvider.dump(res::put);    return res;}
dbb6d431b1c9026fa92f30477dc7271f4c9ddcadb644127ae9e99a6f450fff02
currentServerMetrics
public static Map<String, Object> currentServerMetrics()
{    return collect(ServerMetrics.getMetrics().getMetricsProvider());}
5e6a8f24c549759e14316987ae3716f10c3d891b813a810dd4bf5bcc04c628ea
createAndReturnBB
public ByteBuffer createAndReturnBB()
{    createBB();    return this.bb;}
96606b1d5f4492ef3596754f86f9ed3b1dbb11fc5ec486b8d51c8db7b8c3073e
testRoundTrip
public void testRoundTrip() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    request.add(Op.check("check", 1));    request.add(Op.create("create", "create data".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, ZooDefs.Perms.ALL));    request.add(Op.delete("delete", 17));    request.add(Op.setData("setData", "set data".getBytes(), 19));    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
1c5aa52cb87613737532a6726d763e8bf4f7d305e5b9cf99df2e74c23cda34e3
testEmptyRoundTrip
public void testEmptyRoundTrip() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
27fc2f186fe4852d410a4478c68f2c7d02d112fa76042c444c6cf5d8f2675e46
codeDecode
private MultiOperationRecord codeDecode(MultiOperationRecord request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "request");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiOperationRecord decodedRequest = new MultiOperationRecord();    decodedRequest.deserialize(bia, "request");    return decodedRequest;}
96606b1d5f4492ef3596754f86f9ed3b1dbb11fc5ec486b8d51c8db7b8c3073e
testRoundTrip
public void testRoundTrip() throws IOException
{    MultiResponse response = new MultiResponse();    response.add(new OpResult.CheckResult());    response.add(new OpResult.CreateResult("foo-bar"));    response.add(new OpResult.DeleteResult());    Stat s = new Stat();    s.setCzxid(546);    response.add(new OpResult.SetDataResult(s));    MultiResponse decodedResponse = codeDecode(response);    assertEquals(response, decodedResponse);    assertEquals(response.hashCode(), decodedResponse.hashCode());}
1c5aa52cb87613737532a6726d763e8bf4f7d305e5b9cf99df2e74c23cda34e3
testEmptyRoundTrip
public void testEmptyRoundTrip() throws IOException
{    MultiResponse result = new MultiResponse();    MultiResponse decodedResult = codeDecode(result);    assertEquals(result, decodedResult);    assertEquals(result.hashCode(), decodedResult.hashCode());}
1db8697605a9c8743bbd3876b33675a2d94f387fae82e3d18116a1d4937782ea
codeDecode
private MultiResponse codeDecode(MultiResponse request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "result");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiResponse decodedRequest = new MultiResponse();    decodedRequest.deserialize(bia, "result");    return decodedRequest;}
a473acf06ad103fb79db2d5a8b7450e183c918b932e99be3d15320d049949935
unique
public static synchronized int unique()
{    if (portRange == null) {        Integer threadId = Integer.getInteger("zookeeper.junit.threadid");        portRange = setupPortRange(System.getProperty("test.junit.threads"), threadId != null ? "threadid=" + threadId : System.getProperty("sun.java.command"));        nextPort = portRange.getMinimum();    }    int candidatePort = nextPort;    for (; ; ) {        ++candidatePort;        if (candidatePort > portRange.getMaximum()) {            candidatePort = portRange.getMinimum();        }        if (candidatePort == nextPort) {            throw new IllegalStateException(String.format("Could not assign port from range %s.  The entire range has been exhausted.", portRange));        }        try {            ServerSocket s = new ServerSocket(candidatePort);            s.close();            nextPort = candidatePort;            LOG.info("Assigned port {} from range {}.", nextPort, portRange);            return nextPort;        } catch (IOException e) {            LOG.debug("Could not bind to port {} from range {}.  Attempting next port.", candidatePort, portRange, e);        }    }}
a633a02c8807aa074e7c804666cebb341bb0387179e9dc9b555bcdf10a769f9f
setupPortRange
 static PortRange setupPortRange(String strProcessCount, String cmdLine)
{    Integer processCount = null;    if (strProcessCount != null && !strProcessCount.isEmpty()) {        try {            processCount = Integer.valueOf(strProcessCount);        } catch (NumberFormatException e) {            LOG.warn("Error parsing test.junit.threads = {}.", strProcessCount, e);        }    }    Integer threadId = null;    if (processCount != null) {        if (cmdLine != null && !cmdLine.isEmpty()) {            Matcher m = Pattern.compile("threadid=(\\d+)").matcher(cmdLine);            if (m.find()) {                try {                    threadId = Integer.valueOf(m.group(1));                } catch (NumberFormatException e) {                    LOG.warn("Error parsing threadid from {}.", cmdLine, e);                }            }        }    }    final PortRange newPortRange;    if (processCount != null && processCount > 1 && threadId != null) {                                        int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;        int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);        int maxPort = minPort + portRangeSize - 1;        newPortRange = new PortRange(minPort, maxPort);        LOG.info("Test process {}/{} using ports from {}.", threadId, processCount, newPortRange);    } else {                        newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);        LOG.info("Single test process using ports from {}.", newPortRange);    }    return newPortRange;}
61f501944907ff5138ec6b3e26850fb40691ae660e0040c8fbc678e88b320116
getMaximum
 int getMaximum()
{    return maximum;}
bff13b48ea4ec0f5c3536d4ef61bb685ba461431db461f969555af756e89fd5d
getMinimum
 int getMinimum()
{    return minimum;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("%d - %d", minimum, maximum);}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[] { "8", "threadid=1", 11221, 13913 }, new Object[] { "8", "threadid=2", 13914, 16606 }, new Object[] { "8", "threadid=3", 16607, 19299 }, new Object[] { "8", "threadid=4", 19300, 21992 }, new Object[] { "8", "threadid=5", 21993, 24685 }, new Object[] { "8", "threadid=6", 24686, 27378 }, new Object[] { "8", "threadid=7", 27379, 30071 }, new Object[] { "8", "threadid=8", 30072, 32764 }, new Object[] { "1", "threadid=1", 11221, 32767 }, new Object[] { "2", "threadid=1", 11221, 21993 }, new Object[] { "2", "threadid=2", 21994, 32766 }, new Object[] { null, null, 11221, 32767 }, new Object[] { "", "", 11221, 32767 });}
850556822be6d677850523e42762c812ff3a450f144cc309017d3326c2844363
testSetupPortRange
public void testSetupPortRange()
{    PortAssignment.PortRange portRange = PortAssignment.setupPortRange(strProcessCount, cmdLine);    assertEquals(buildAssertionMessage("minimum"), expectedMinimumPort, portRange.getMinimum());    assertEquals(buildAssertionMessage("maximum"), expectedMaximumPort, portRange.getMaximum());}
03c8da2e0bae588dd812034ec59d778820d23b28b477a603baab81f2230c7465
buildAssertionMessage
private String buildAssertionMessage(String checkType)
{    return String.format("strProcessCount = %s, cmdLine = %s, checking %s", strProcessCount, cmdLine, checkType);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    zkMain = new ZooKeeperMain(zk);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (zk != null) {        zk.close();    }    super.tearDown();}
c14f8ab86b743b9386c9c85d6a6385b86c7a60c7e3aa3e4ef774e35480bcec1b
testRemoveWatchesWithNoPassedOptions
public void testRemoveWatchesWithNoPassedOptions() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 2);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    LOG.info("Adding childwatcher to /testnode1 and /testnode2");    zk.getChildren("/testnode1", myWatcher);    zk.getChildren("/testnode2", myWatcher);    LOG.info("Adding datawatcher to /testnode1 and /testnode2");    zk.getData("/testnode1", myWatcher, null);    zk.getData("/testnode2", myWatcher, null);    String cmdstring = "removewatches /testnode1";    LOG.info("Remove watchers using shell command : {}", cmdstring);    zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));    LOG.info("Waiting for the DataWatchRemoved event");    myWatcher.matches();        assertTrue("Failed to find child watches for the path testnode2", zk.getChildWatches().contains("/testnode2"));    assertTrue("Failed to find data watches for the path testnode2", zk.getDataWatches().contains("/testnode2"));}
4102c6429d9f09f24559c6bc608a45c53cea292699ed5f6f2a226b7a4e2fbc68
testRemoveNodeDataChangedWatches
public void testRemoveNodeDataChangedWatches() throws Exception
{    LOG.info("Adding data watcher using getData()");    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getData("/testnode1", myWatcher, null);    String cmdstring = "removewatches /testnode1 -d";    LOG.info("Remove watchers using shell command : {}", cmdstring);    zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));    LOG.info("Waiting for the DataWatchRemoved event");    myWatcher.matches();        assertEquals("Data watches are not removed : " + zk.getDataWatches(), 0, zk.getDataWatches().size());}
755e89135848bca550c706ce0e40f2dc8ef2a8db1bdae44206cf83a20c297af0
testRemoveNodeCreatedWatches
public void testRemoveNodeCreatedWatches() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher1 = new MyWatcher("/testnode1", expectedEvents, 1);    MyWatcher myWatcher2 = new MyWatcher("/testnode1/testnode2", expectedEvents, 1);        LOG.info("Adding NodeCreated watcher");    zk.exists("/testnode1", myWatcher1);    zk.exists("/testnode1/testnode2", myWatcher2);    String cmdstring1 = "removewatches /testnode1 -d";    LOG.info("Remove watchers using shell command : {}", cmdstring1);    zkMain.cl.parseCommand(cmdstring1);    assertTrue("Removewatches cmd fails to remove pre-create watches", zkMain.processZKCmd(zkMain.cl));    myWatcher1.matches();    assertEquals("Failed to remove pre-create watches :" + zk.getExistWatches(), 1, zk.getExistWatches().size());    assertTrue("Failed to remove pre-create watches :" + zk.getExistWatches(), zk.getExistWatches().contains("/testnode1/testnode2"));    String cmdstring2 = "removewatches /testnode1/testnode2 -d";    LOG.info("Remove watchers using shell command : {}", cmdstring2);    zkMain.cl.parseCommand(cmdstring2);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));    myWatcher2.matches();    assertEquals("Failed to remove pre-create watches : " + zk.getExistWatches(), 0, zk.getExistWatches().size());}
48721afee9429f8b3c990465c5257ba8549d9ceb42bee917e486b4280d1ab3ee
testRemoveNodeChildrenChangedWatches
public void testRemoveNodeChildrenChangedWatches() throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    LOG.info("Adding child changed watcher");    zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";    LOG.info("Remove watchers using shell command : {}", cmdstring);    zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));    myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 0, zk.getChildWatches().size());}
27477b28dc84be6cfa4046cfbaa35bf65f509677df68e43c85e555d208466ec9
testRemoveNodeDeletedWatches
public void testRemoveNodeDeletedWatches() throws Exception
{    LOG.info("Adding NodeDeleted watcher");    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.NodeDeleted);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode1/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1/testnode2", myWatcher);    zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";    LOG.info("Remove watchers using shell command : {}", cmdstring);    zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));    LOG.info("Waiting for the ChildWatchRemoved event");    myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 1, zk.getChildWatches().size());    assertTrue("Failed to remove child watches :" + zk.getChildWatches(), zk.getChildWatches().contains("/testnode1/testnode2"));        zk.delete("/testnode1/testnode2", -1);    myWatcher.matches();}
aeb6c437696fc4cf52168f5eb9a3545b1a1e74e32ca1d33a0e0dc238f85a9b9c
testRemoveAnyWatches
public void testRemoveAnyWatches() throws Exception
{    verifyRemoveAnyWatches(false);}
41a2472e9bb0822ccbe0687297944d42c414cb0326a1d543db0cf905f04ce319
testRemoveWatchesLocallyWhenNoServerConnection
public void testRemoveWatchesLocallyWhenNoServerConnection() throws Exception
{    verifyRemoveAnyWatches(true);}
ce5fe69a4acbc25d0fc90049f460334b7f0a09eba80e1c7c1b44b9f01f83c413
verifyRemoveAnyWatches
private void verifyRemoveAnyWatches(boolean local) throws Exception
{    final Map<String, List<EventType>> pathVsEvent = new HashMap<>();    LOG.info("Adding NodeChildrenChanged, NodeDataChanged watchers");    final CountDownLatch watcherLatch = new CountDownLatch(2);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            switch(event.getType()) {                case ChildWatchRemoved:                case DataWatchRemoved:                    addWatchNotifications(pathVsEvent, event);                    watcherLatch.countDown();                    break;                case NodeChildrenChanged:                case NodeDataChanged:                    addWatchNotifications(pathVsEvent, event);                    break;            }        }        private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event) {            pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());        }    };    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1", watcher);    zk.getData("/testnode1", watcher, null);    String cmdstring = "removewatches /testnode1 -a";    if (local) {        LOG.info("Stopping ZK server to verify deletion of watches locally");        stopServer();        cmdstring = "removewatches /testnode1 -a -l";    }    LOG.info("Remove watchers using shell command : {}", cmdstring);    zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child/data watches", zkMain.processZKCmd(zkMain.cl));    LOG.info("Waiting for the WatchRemoved events");    watcherLatch.await(10, TimeUnit.SECONDS);    assertEquals("Didn't receives WatchRemoved events!", 1, pathVsEvent.size());    assertTrue("Didn't receives DataWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.DataWatchRemoved));    assertTrue("Didn't receives ChildWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.ChildWatchRemoved));}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    switch(event.getType()) {        case ChildWatchRemoved:        case DataWatchRemoved:            addWatchNotifications(pathVsEvent, event);            watcherLatch.countDown();            break;        case NodeChildrenChanged:        case NodeDataChanged:            addWatchNotifications(pathVsEvent, event);            break;    }}
0f8a651d27994a0e47dc51ca4ce1b57d09583769c4bcd5a7e157a24ba0d401fe
addWatchNotifications
private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event)
{    pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.debug("Event path : {}, eventPath : {}", path, event.getPath());    this.eventPath = event.getPath();    if (expectedEvents.contains(event.getType())) {        latch.countDown();    }}
212abc1023e759f707d743f99616a04854a0e6e6eacd63552724dfb947ceef04
matches
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS)) {        LOG.error("Failed to get watch notifications!");        return false;    }    LOG.debug("Client path : {} eventPath : {}", path, eventPath);    return path.equals(eventPath);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk1 = createClient();    zk2 = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }    super.tearDown();}
a7e0cbe38199f9da3827a95ddb09627bc1388241b04e73e76cb8d38509652c45
configs
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
822835a845cc1c88e2218e46452244c0ca556062cf0b24074487450f064af9aa
removeWatches
private void removeWatches(ZooKeeper zk, String path, Watcher watcher, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{    LOG.info("Sending removeWatches req using zk {} path: {} type: {} watcher: {} ", zk, path, watcherType, watcher);    if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeWatches(path, watcher, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeWatches(path, watcher, watcherType, local);    }}
912d93466b6400f8e080ca909bd56ecd8a5ca1af7d9827ea3e4e0253c810fcea
removeAllWatches
private void removeAllWatches(ZooKeeper zk, String path, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{    LOG.info("Sending removeWatches req using zk {} path: {} type: {} ", zk, path, watcherType);    if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeAllWatches(path, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeAllWatches(path, watcherType, local);    }}
b767ec9adcd7977e0c307954748ee9903e68d474c7eab6201e2f558cfda4c685
testRemoveSingleWatcher
public void testRemoveSingleWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk1.create("/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node2", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node2", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node2", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node2", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w1.getEventsAfterWatchRemoval();    assertFalse("Shouldn't get NodeDeletedEvent after watch removal", events.contains(EventType.NodeDeleted));    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
d32024459b58b12c8dd077ba9992745db2cbd80109f0a3ab6dcf51ae5166d5ad
testMultipleDataWatchers
public void testMultipleDataWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node1", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
cf74458af6ff2a2bc2ae58216f85bed1520c3a33abc3c8568938b74c07607ff2
testMultipleChildWatchers
public void testMultipleChildWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());        zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        int count = 30;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(100);    }        List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeChildrenChanged event", 0, events.size());}
f3221362ed44596212e5e595f7d561595132c2b9b51805c28a7c665f107b990b
testRemoveAllWatchers
public void testRemoveAllWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());}
570060263285a949baa8a3a925d28adaea63f8e1f849613d1b4afc94d8da8860
testRemoveAllDataWatchers
public void testRemoveAllDataWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove data watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));}
9b3b30d07b6fc611fdd3ab72d602ae1d876f462df10acba3099a1b90eb581c35
testRemoveAllChildWatchers
public void testRemoveAllChildWatchers() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    zk1.setData("/node1", "test".getBytes(), -1);    assertTrue("Didn't remove child watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));}
72e3da69fe1bb6fe9706a0ba4cb8baa42b92094b0e1db2eddd33cc41efee29d1
testNoWatcherException
public void testNoWatcherException() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNull("Didn't set data watches", zk2.exists("/node2", w2));    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);        MyWatcher w3 = new MyWatcher("/node1", 2);    try {        removeWatches(zk2, "/node1", w3, WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Children, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/nonexists", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
33a48e88397d61e7e11f5d3015ab8a9dd121fe6b7bc1a505f90188ecfbffe30f
testRemoveAnyDataWatcher
public void testRemoveAnyDataWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 2);        LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
bb7c5e7dbdb30ea31d2a09fac085b7c0e66947c6c4119cb86f8a280be20fb67a
testRemoveAnyChildWatcher
public void testRemoveAnyChildWatcher() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w2);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove watchers", w1.matches());}
8dae22053c57b685f1aff9aeed683fad43df3654d79262ff66d3adbbc0459f8a
testRemoveWatcherWhenNoConnection
public void testRemoveWatcherWhenNoConnection() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w1);    LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w2);    stopServer();    removeWatches(zk2, "/node1", w2, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertFalse("Shouldn't remove data watcher", w1.matches());    try {        removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.CONNECTIONLOSS);        fail("Should throw exception as last watch removal requires server connection");    } catch (KeeperException.ConnectionLossException nwe) {        }    assertFalse("Shouldn't remove data watcher", w1.matches());            removeWatches(zk2, "/node1", w1, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());}
4115a9670b6380c15472a155e8f3fbcf99cdc79e29b7e13c94fbc30c9b760120
testManyPreNodeWatchers
public void testManyPreNodeWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        final String nodePath = path + i;        w = new MyWatcher(nodePath, 1);        wList.add(w);        LOG.info("Adding pre node watcher {} on path {}", new Object[] { w, nodePath });        zk1.exists(nodePath, w);    }    assertEquals("Failed to add watchers!", count, zk1.getExistWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getExistWatches().size());}
b907f3c054794c4cd1694d4af3ba2862087e18c15e48d15a664f41fbdd507ce6
testManyChildWatchers
public void testManyChildWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);        LOG.info("Adding child watcher {} on path {}", new Object[] { w, nodePath });        zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Children, false, Code.OK);        assertTrue("Didn't remove child watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());}
9c78d7bb2fb35dc690d4b7973e70c4e649f0f8d61fa3cb1431d5774bc9dac918
testManyDataWatchers
public void testManyDataWatchers() throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        LOG.info("Adding data watcher {} on path {}", new Object[] { w, nodePath });        zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
eac739125cdf283a77345bdf1c64b8d4fcad63d6509ed8af031a839ca8e7daef
testManyWatchersWhenNoConnection
public void testManyWatchersWhenNoConnection() throws Exception
{    int count = 3;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 2);        wList.add(w);        LOG.info("Adding child watcher {} on path {}", new Object[] { w, nodePath });        zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = wList.get(i);        LOG.info("Adding data watcher {} on path {}", new Object[] { w, nodePath });        zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    stopServer();    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Any, true, Code.OK);        assertTrue("Didn't remove watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
7a75c75a924a0a7fe7c45c43dd4bafecd586a8310ba87b967854460fb22eed28
testChRootRemoveWatcher
public void testChRootRemoveWatcher() throws Exception
{        String chRoot = "/appsX";    zk1.create("/appsX", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }        zk1 = createClient(this.hostPort + chRoot);    zk2 = createClient(this.hostPort + chRoot);    LOG.info("Creating child znode /node1 using chRoot client");    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);    LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    zk2.getChildren("/node1", w2);    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
63ef68e53aaf1c4ca03be697e17f3f2fdc4da70b7d5df3629d3e2dffe14fbd53
testNoWatcherServerException
public void testNoWatcherServerException() throws InterruptedException, IOException, TimeoutException
{    CountdownWatcher watcher = new CountdownWatcher();    MyZooKeeper zk = new MyZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    boolean nw = false;    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        zk.removeWatches("/nowatchhere", watcher, WatcherType.Data, false);    } catch (KeeperException nwe) {        if (nwe.code().intValue() == Code.NOWATCHER.intValue()) {            nw = true;        }    }    assertTrue("Server didn't return NOWATCHER", zk.getRemoveWatchesRC() == Code.NOWATCHER.intValue());    assertTrue("NoWatcherException didn't happen", nw);}
0b41dc44ed753f10fa404f2157147704f7f57cfc0a92f19571628f168373d0fc
testRemoveAllNoWatcherException
public void testRemoveAllNoWatcherException() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
da8a3207e080de342a52bf24ca2a7c5fcfa2ad14c1e0acf94d186b7a05dda6dd
testNullWatcherReference
public void testNullWatcherReference() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        if (useAsync) {            zk1.removeWatches("/node1", null, WatcherType.Data, false, null, null);        } else {            zk1.removeWatches("/node1", null, WatcherType.Data, false);        }        fail("Must throw IllegalArgumentException as watcher is null!");    } catch (IllegalArgumentException iae) {        }}
b60e8a3a0735a61baa49436cef03c547be75e57c7a0b102f7d9888217d14b068
testRemoveWhenMultipleDataWatchesOnAPath
public void testRemoveWhenMultipleDataWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dataWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.DataWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeDataChanged) {            dataWatchCount.countDown();        }    };        LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.setData("/node1", "test".getBytes(), -1);    LOG.info("Waiting for data watchers to be notified");    assertTrue("Didn't get data watch notification!", dataWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
db07d6db2fa47ff7c0a050a2bfcd2b020c8a815a929ed619a0a922c7a2a5180e
testRemoveWhenMultipleChildWatchesOnAPath
public void testRemoveWhenMultipleChildWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch childWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.ChildWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeChildrenChanged) {            childWatchCount.countDown();        }    };        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    LOG.info("Waiting for child watchers to be notified");    assertTrue("Didn't get child watch notification!", childWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
b3bf7a082ec4564afc6f76031545db3df9ba20d7ca953d903d522a247ae1386d
testRemoveAllDataWatchesOnAPath
public void testRemoveAllDataWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };        LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));}
d030d685c0c13bc151f883064de9b34e914282bf21b5b9261ca95d63a3ed444d
testRemoveAllChildWatchesOnAPath
public void testRemoveAllChildWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch cWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));    removeAllWatches(zk2, "/node1", WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));}
e6993a1869d0ef84b8064acd6ad32bb05961ae7816fff66669befe01298ef5f8
testRemoveAllWatchesOnAPath
public void testRemoveAllWatchesOnAPath() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch watchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(4);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };        LOG.info("Adding child watcher {} on path {}", new Object[] { w1, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());    LOG.info("Adding child watcher {} on path {}", new Object[] { w2, "/node1" });    assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());        LOG.info("Adding data watcher {} on path {}", new Object[] { w1, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    LOG.info("Adding data watcher {} on path {}", new Object[] { w2, "/node1" });    assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    assertEquals("Received watch notification after removal!", 2, watchCount.getCount());}
1834da3422066075b329743bd061288bd366855c027bac2935f9205b998b6a03
containsWatcher
 void containsWatcher(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{}
9c66cda96acbd45cf15a1a36872dc9053b706fd45a78c29d0e820ceb4be50f78
removeWatches
protected boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    lastrc = rc;    return false;}
bda02a3ea0e0ab53be6e5b77665e95118f57af03867550ad7569e3efbbe81f3c
defaultWatchManager
protected ZKWatchManager defaultWatchManager()
{    myWatchManager = new MyWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));    return myWatchManager;}
263ca9a72edef8312f6ab1ad264435d842eed974eba5293e86d4ea44ff980090
getRemoveWatchesRC
public int getRemoveWatchesRC()
{    return myWatchManager.lastrc;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.debug("Event path : {}, eventPath : {}" + new Object[] { path, event.getPath() });    this.eventPath = event.getPath();        if (latch.getCount() == 0) {        if (event.getType() != EventType.None) {            eventsAfterWatchRemoval.add(event.getType());        }    }    if (event.getType() == EventType.ChildWatchRemoved || event.getType() == EventType.DataWatchRemoved) {        latch.countDown();    }}
212abc1023e759f707d743f99616a04854a0e6e6eacd63552724dfb947ceef04
matches
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {        LOG.error("Failed waiting to remove the watches");        return false;    }    LOG.debug("Client path : {} eventPath : {}", new Object[] { path, eventPath });    return path.equals(eventPath);}
a8c341c609cd8ea061a8852c08bc288d0a2dee3bd12530c0d72c44cdba87a9e6
getEventsAfterWatchRemoval
public List<EventType> getEventsAfterWatchRemoval()
{    return eventsAfterWatchRemoval;}
942129a1541cd112b0d5ba5f43262b8943f03e1b3af4bcfae1de42e41728fa3a
processResult
public void processResult(int rc, String eventPath, Object ctx)
{    System.out.println("latch:" + path + " " + eventPath);    this.eventPath = eventPath;    this.eventRc = rc;    this.latch.countDown();}
212abc1023e759f707d743f99616a04854a0e6e6eacd63552724dfb947ceef04
matches
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {        return false;    }    return path.equals(eventPath) && rc == eventRc;}
793bfc2880f7f18db26220764a5cc3037d3d2843ac741eb642ca76304c8f9b7a
isServerSessionWatcher
private boolean isServerSessionWatcher(long sessionId, String path, WatcherType type)
{    Set<ServerCnxn> cnxns = new HashSet<>();    CollectionUtils.addAll(cnxns, serverFactory.getConnections().iterator());    for (ServerCnxn cnxn : cnxns) {        if (cnxn.getSessionId() == sessionId) {            return serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().containsWatcher(path, type, cnxn);        }    }    return false;}
7c1203297d6f00c7339a0f8eb5c3970de980476fea8d1f9ae49f44e151af83f4
init
public static void init()
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    try {        File tmpDir = createTmpDir();        File saslConfFile = new File(tmpDir, "jaas.conf");        String jaasContent = getJaasFileContent();        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasContent);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException e) {            }}
71a0c1ee6925b056ac6ec599322b052b8345d836f86fd9a4fbb4d9ff69291f71
getJaasFileContent
private static String getJaasFileContent()
{    StringBuilder jaasContent = new StringBuilder();    String newLine = System.getProperty("line.separator");    jaasContent.append("Server {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("user_super=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    jaasContent.append("Client {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("username=\"super\"");    jaasContent.append(newLine);    jaasContent.append("password=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    return jaasContent.toString();}
5e3df87e932b0099e69bfa2a9bbc670f3bfed18dd36a6ed64f8fdbd876b813ca
clean
public static void clean()
{    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty("java.security.auth.login.config");}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } finally {        zk.close();    }}
60479928385aaecd6e7a2a32deb4e931877553a0e1d8e04d8d5dc0858a74f8a9
testValidSaslIds
public void testValidSaslIds() throws Exception
{    ZooKeeper zk = createClient();    List<String> validIds = new ArrayList<String>();    validIds.add("user");    validIds.add("service/host.name.com");    validIds.add("user@KERB.REALM");    validIds.add("service/host.name.com@KERB.REALM");    int i = 0;    for (String validId : validIds) {        List<ACL> aclList = new ArrayList<ACL>();        ACL acl = new ACL(0, new Id("sasl", validId));        aclList.add(acl);        zk.create("/valid" + i, null, aclList, CreateMode.PERSISTENT);        i++;    }}
4ac8dd1d8940d3074072e88c13251ed2a5ee91ba355e3d78e88d1559ce07d1e0
testInvalidSaslIds
public void testInvalidSaslIds() throws Exception
{    ZooKeeper zk = createClient();    List<String> invalidIds = new ArrayList<String>();    invalidIds.add("user@KERB.REALM/server.com");    invalidIds.add("user@KERB.REALM1@KERB.REALM2");    int i = 0;    for (String invalidId : invalidIds) {        List<ACL> aclList = new ArrayList<ACL>();        try {            ACL acl = new ACL(0, new Id("sasl", invalidId));            aclList.add(acl);            zk.create("/invalid" + i, null, aclList, CreateMode.PERSISTENT);            fail("SASLAuthenticationProvider.isValid() failed to catch invalid Id.");        } catch (KeeperException.InvalidACLException e) {                } finally {            i++;        }    }}
325a9365757d9cbc026486372f771690f44d47c369f242d5ccb52c0d7e3df7a2
testZKOperationsAfterClientSaslAuthFailure
public void testZKOperationsAfterClientSaslAuthFailure() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        setSaslFailureFlag(zk);                int totalTry = 10;        int tryCount = 0;        boolean success = false;        while (!success && tryCount++ <= totalTry) {            try {                zk.create("/saslAuthFail", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);                success = true;            } catch (KeeperException.ConnectionLossException e) {                Thread.sleep(1000);                        }        }        assertTrue("ZNode creation is failing continuously after Sasl auth failure.", success);    } finally {        zk.close();    }}
1dfc24f50aeb7746d6488e2a69900ef3d33d687807fde10c2b9e1295f8072064
setSaslFailureFlag
private void setSaslFailureFlag(ZooKeeper zk) throws Exception
{    Field cnxnField = zk.getClass().getDeclaredField("cnxn");    cnxnField.setAccessible(true);    ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);    Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");    sendThreadField.setAccessible(true);    SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);    Field saslLoginFailedField = sendThread.getClass().getDeclaredField("saslLoginFailed");    saslLoginFailedField.setAccessible(true);    saslLoginFailedField.setBoolean(sendThread, true);}
43d5dbe10ceea578073ca76e47cd87b668ee352054477a377537ae8ff3e0cebf
testThreadsShutdownOnAuthFailed
public void testThreadsShutdownOnAuthFailed() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = null;    try {        zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        try {            zk.addAuthInfo("FOO", "BAR".getBytes());            zk.getData("/path1", false, null);            fail("Should get auth state error");        } catch (KeeperException.AuthFailedException e) {            if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {                fail("Should have called my watcher");            }        }        Field cnxnField = zk.getClass().getDeclaredField("cnxn");        cnxnField.setAccessible(true);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);        Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");        sendThreadField.setAccessible(true);        SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);        Field eventThreadField = clientCnxn.getClass().getDeclaredField("eventThread");        eventThreadField.setAccessible(true);        EventThread eventThread = (EventThread) eventThreadField.get(clientCnxn);        sendThread.join(CONNECTION_TIMEOUT);        eventThread.join(CONNECTION_TIMEOUT);        assertFalse("SendThread did not shutdown after authFail", sendThread.isAlive());        assertFalse("EventThread did not shutdown after authFail", eventThread.isAlive());    } finally {        if (zk != null) {            zk.close();        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    r = new CommandResponse("makemeasandwich", "makeityourself");}
68a7c6f72a1a96ed85b6b3515ce8af88c9fce8476a6de3f60d85a392f4b4f5b4
testGetters
public void testGetters()
{    assertEquals("makemeasandwich", r.getCommand());    assertEquals("makeityourself", r.getError());}
2711789c51604791e3f1d9e60fd013245613e5695ae4ad755db102d34cdf3cb8
testMap
public void testMap()
{    r.put("missing", "sudo");    Map<String, Object> m = new HashMap<String, Object>();    m.put("origin", "xkcd");    m.put("url", "http://xkcd.com/149/");    r.putAll(m);    Map<String, Object> rmap = r.toMap();    assertEquals(5, rmap.size());    assertEquals("makemeasandwich", rmap.get(CommandResponse.KEY_COMMAND));    assertEquals("makeityourself", rmap.get(CommandResponse.KEY_ERROR));    assertEquals("sudo", rmap.get("missing"));    assertEquals("xkcd", rmap.get("origin"));    assertEquals("http://xkcd.com/149/", rmap.get("url"));}
d4bebff4ab4b29b6bd617cf956f574f33e1245d51dfb630a801b3d8dcd08f55e
testCommand
public void testCommand(String cmdName, Map<String, String> kwargs, Field... fields) throws IOException, InterruptedException
{    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    Map<String, Object> result = Commands.runCommand(cmdName, zks, kwargs).toMap();    assertTrue(result.containsKey("command"));        assertEquals(cmdName, result.remove("command"));    assertTrue(result.containsKey("error"));    assertNull("error: " + result.get("error"), result.remove("error"));    for (Field field : fields) {        String k = field.key;        assertTrue("Result from command " + cmdName + " missing field \"" + k + "\"" + "\n" + result, result.containsKey(k));        Class<?> t = field.type;        Object v = result.remove(k);        assertTrue("\"" + k + "\" field from command " + cmdName + " should be of type " + t + ", is actually of type " + v.getClass(), t.isAssignableFrom(v.getClass()));    }    assertTrue("Result from command " + cmdName + " contains extra fields: " + result, result.isEmpty());}
0948910a4ba58fbabb96c4686f6487037ddfb5a19c3f3967e9a76e95e17c9e08
testCommand
public void testCommand(String cmdName, Field... fields) throws IOException, InterruptedException
{    testCommand(cmdName, new HashMap<String, String>(), fields);}
8f17bc9515b03f299146f1e5395ec465e8ab729ce96f5101f8de54885061c9da
testConfiguration
public void testConfiguration() throws IOException, InterruptedException
{    testCommand("configuration", new Field("client_port", Integer.class), new Field("data_dir", String.class), new Field("data_log_dir", String.class), new Field("tick_time", Integer.class), new Field("max_client_cnxns", Integer.class), new Field("min_session_timeout", Integer.class), new Field("max_session_timeout", Integer.class), new Field("server_id", Long.class), new Field("client_port_listen_backlog", Integer.class));}
60b70b92a6bbb092ec73df649dc6ec53833023a958603e1acdedcbb949f9666a
testConnections
public void testConnections() throws IOException, InterruptedException
{    testCommand("connections", new Field("connections", Iterable.class), new Field("secure_connections", Iterable.class));}
670861b2f474165384a81268c868707ce7967dad997e01cd7e7783907d54d42a
testObservers
public void testObservers() throws IOException, InterruptedException
{    testCommand("observers", new Field("synced_observers", Integer.class), new Field("observers", Iterable.class));}
aa5bd275ca66ac8ca800b4d989ab49181eb8915f6dcf883a601e7b52f278afa5
testObserverConnectionStatReset
public void testObserverConnectionStatReset() throws IOException, InterruptedException
{    testCommand("observer_connection_stat_reset");}
4fc6c8664f94fc88d25867891c19072c16e281067c2502362a8adad6a4a18508
testConnectionStatReset
public void testConnectionStatReset() throws IOException, InterruptedException
{    testCommand("connection_stat_reset");}
e105c93b67f7c7900ea0dca62e185cb3411f93f9661b0979bbf0c7bdf251f0b4
testDump
public void testDump() throws IOException, InterruptedException
{    testCommand("dump", new Field("expiry_time_to_session_ids", Map.class), new Field("session_id_to_ephemeral_paths", Map.class));}
508d31b84ad31a9cf171d7b5299b72c37c3d128110adb189cc57d3abce45732d
testEnvironment
public void testEnvironment() throws IOException, InterruptedException
{    testCommand("environment", new Field("zookeeper.version", String.class), new Field("host.name", String.class), new Field("java.version", String.class), new Field("java.vendor", String.class), new Field("java.home", String.class), new Field("java.class.path", String.class), new Field("java.library.path", String.class), new Field("java.io.tmpdir", String.class), new Field("java.compiler", String.class), new Field("os.name", String.class), new Field("os.arch", String.class), new Field("os.version", String.class), new Field("user.name", String.class), new Field("user.home", String.class), new Field("user.dir", String.class), new Field("os.memory.free", String.class), new Field("os.memory.max", String.class), new Field("os.memory.total", String.class));}
8651fb5908b25a39fa22ff65518f677edee477c2bf82d4c8df3f0eeaa3ae6e7c
testGetTraceMask
public void testGetTraceMask() throws IOException, InterruptedException
{    testCommand("get_trace_mask", new Field("tracemask", Long.class));}
c54586eb516851f3745b6653e8871463ae9aa6f71cbb43bf7d136dadaf9d6a3a
testIsReadOnly
public void testIsReadOnly() throws IOException, InterruptedException
{    testCommand("is_read_only", new Field("read_only", Boolean.class));}
44126b967e86bb6daf379c22e67a8d26a0fc0470b15cf4113185089b32a7fb72
testLastSnapshot
public void testLastSnapshot() throws IOException, InterruptedException
{    testCommand("last_snapshot", new Field("zxid", String.class), new Field("timestamp", Long.class));}
b3e39965738959e66858d0b608322c2b90d205e6ef22192cd8281e8301382318
testMonitor
public void testMonitor() throws IOException, InterruptedException
{    ArrayList<Field> fields = new ArrayList<>(Arrays.asList(new Field("version", String.class), new Field("avg_latency", Double.class), new Field("max_latency", Long.class), new Field("min_latency", Long.class), new Field("packets_received", Long.class), new Field("packets_sent", Long.class), new Field("num_alive_connections", Integer.class), new Field("outstanding_requests", Long.class), new Field("server_state", String.class), new Field("znode_count", Integer.class), new Field("watch_count", Integer.class), new Field("ephemerals_count", Integer.class), new Field("approximate_data_size", Long.class), new Field("open_file_descriptor_count", Long.class), new Field("max_file_descriptor_count", Long.class), new Field("last_client_response_size", Integer.class), new Field("max_client_response_size", Integer.class), new Field("min_client_response_size", Integer.class), new Field("uptime", Long.class), new Field("global_sessions", Long.class), new Field("local_sessions", Long.class), new Field("connection_drop_probability", Double.class)));    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    for (String metric : metrics.keySet()) {        boolean alreadyDefined = fields.stream().anyMatch(f -> {            return f.key.equals(metric);        });        if (alreadyDefined) {                        continue;        }        if (metric.startsWith("avg_")) {            fields.add(new Field(metric, Double.class));        } else {            fields.add(new Field(metric, Long.class));        }    }    Field[] fieldsArray = fields.toArray(new Field[0]);    testCommand("monitor", fieldsArray);}
a01c59dd99dae27a8bd98f73d059a6319ca0cb36bd8b855ab61cdd2ab5c99647
testRuok
public void testRuok() throws IOException, InterruptedException
{    testCommand("ruok");}
df667ead642a61253fd885e08ccc0ad93ae6125014962df5345530cd64735de9
testServerStats
public void testServerStats() throws IOException, InterruptedException
{    testCommand("server_stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("client_response", BufferStats.class));}
d6e7b5f99b932d537b1d776cc8b49aae24a72ac69f0a64252d03e3ec84a0eb05
testSetTraceMask
public void testSetTraceMask() throws IOException, InterruptedException
{    Map<String, String> kwargs = new HashMap<String, String>();    kwargs.put("traceMask", "1");    testCommand("set_trace_mask", kwargs, new Field("tracemask", Long.class));}
31ceed8f6dfa37836812bb3dc467690ef25f524f86b728d9d6393d26e3510f33
testStat
public void testStat() throws IOException, InterruptedException
{    testCommand("stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("connections", Iterable.class), new Field("client_response", BufferStats.class));}
62bff076282f3765bff64f51cf433b9ec74a4046ab1391c8868529f80b3b4178
testStatReset
public void testStatReset() throws IOException, InterruptedException
{    testCommand("stat_reset");}
8ae5c27f1bf1c4a71c66ac11291ff1fb01ec1cb91ff78fa8779655e99c2975a7
testWatches
public void testWatches() throws IOException, InterruptedException
{    testCommand("watches", new Field("session_id_to_watched_paths", Map.class));}
4571b0965fbc9fb440fcf5dedfa6be25145c65242dd58d286d5d8ed5df4148c9
testWatchesByPath
public void testWatchesByPath() throws IOException, InterruptedException
{    testCommand("watches_by_path", new Field("path_to_session_ids", Map.class));}
6b0c50c97cc23befb870a2f78ca0e40aef038fb4585a3ba4d70140a5b9b57642
testWatchSummary
public void testWatchSummary() throws IOException, InterruptedException
{    testCommand("watch_summary", new Field("num_connections", Integer.class), new Field("num_paths", Integer.class), new Field("num_total_watches", Integer.class));}
8401c6f426636a4d3761a2116f8cd88f85dac5a88b82e17651b528ed7f37a7c3
testConsCommandSecureOnly
public void testConsCommandSecureOnly()
{        Commands.ConsCommand cmd = new Commands.ConsCommand();    ZooKeeperServer zkServer = mock(ZooKeeperServer.class);    ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);    when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);        CommandResponse response = cmd.run(zkServer, null);        assertThat(response.toMap().containsKey("connections"), is(true));    assertThat(response.toMap().containsKey("secure_connections"), is(true));}
87e0641fbc4f0163b107cbf4ee15f6607bda6f515012e1c0e7d98d372072d0c2
enableServer
public void enableServer()
{        System.setProperty("zookeeper.admin.enableServer", "true");    System.setProperty("zookeeper.admin.serverPort", "" + jettyAdminPort);}
842859ed25ac1fea320b12a5b792d83cc9d52a7887bd0cb27237fda8b5392cbd
setupEncryption
public void setupEncryption()
{    Security.addProvider(new BouncyCastleProvider());    File tmpDir = null;    X509TestContext x509TestContext = null;    try {        tmpDir = ClientBase.createEmptyTestDir();        x509TestContext = X509TestContext.newBuilder().setTempDir(tmpDir).setKeyStorePassword("").setKeyStoreKeyType(X509KeyType.EC).setTrustStorePassword("").setTrustStoreKeyType(X509KeyType.EC).build();        System.setProperty("zookeeper.ssl.quorum.keyStore.location", x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath());        System.setProperty("zookeeper.ssl.quorum.trustStore.location", x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath());    } catch (Exception e) {        LOG.info("Problems encountered while setting up encryption for Jetty admin server test: " + e);    }    System.setProperty("zookeeper.ssl.quorum.keyStore.password", "");    System.setProperty("zookeeper.ssl.quorum.keyStore.type", "PEM");    System.setProperty("zookeeper.ssl.quorum.trustStore.password", "");    System.setProperty("zookeeper.ssl.quorum.trustStore.type", "PEM");    System.setProperty("zookeeper.admin.portUnification", "true");        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {        public java.security.cert.X509Certificate[] getAcceptedIssuers() {            return null;        }        public void checkClientTrusted(X509Certificate[] certs, String authType) {        }        public void checkServerTrusted(X509Certificate[] certs, String authType) {        }    } };        SSLContext sc = null;    try {        sc = SSLContext.getInstance("SSL");        sc.init(null, trustAllCerts, new java.security.SecureRandom());    } catch (Exception e) {        LOG.error("Failed to customize encryption for HTTPS: e");    }        HostnameVerifier allValid = new HostnameVerifier() {        public boolean verify(String hostname, SSLSession session) {            return true;        }    };            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());    HttpsURLConnection.setDefaultHostnameVerifier(allValid);}
a35f7a0798c73280978ccb8b2dbe5ee78ce3a0ff346555b49e87a5da2164e76c
getAcceptedIssuers
public java.security.cert.X509Certificate[] getAcceptedIssuers()
{    return null;}
1ecb61118ee65022847ef32fe5f19791fb40a811079fb2687911f5464e1b8e8e
checkClientTrusted
public void checkClientTrusted(X509Certificate[] certs, String authType)
{}
cc068be72ea28a69e964022f205206b1ec41e87d4352047196df9d5615b9bf97
checkServerTrusted
public void checkServerTrusted(X509Certificate[] certs, String authType)
{}
7ecdfe98cb7bd25b1097720a3f8e6a90e27872837da934a865afa884d714f2b6
verify
public boolean verify(String hostname, SSLSession session)
{    return true;}
8d9ec964cb2b1702f35510b65dc80717f83aa9b6d06f2d7caf8545c5d3f9a1d1
cleanUp
public void cleanUp()
{    Security.removeProvider("BC");    System.clearProperty("zookeeper.admin.enableServer");    System.clearProperty("zookeeper.admin.serverPort");    System.clearProperty("zookeeper.ssl.quorum.keyStore.location");    System.clearProperty("zookeeper.ssl.quorum.keyStore.password");    System.clearProperty("zookeeper.ssl.quorum.keyStore.type");    System.clearProperty("zookeeper.ssl.quorum.trustStore.location");    System.clearProperty("zookeeper.ssl.quorum.trustStore.password");    System.clearProperty("zookeeper.ssl.quorum.trustStore.type");    System.clearProperty("zookeeper.admin.portUnification");}
0be33835eca211925ca90c86a9a49cfc95a8c9b9bcfdf37b95cab6bbecaa9e4f
testJettyAdminServer
public void testJettyAdminServer() throws AdminServerException, IOException, SSLContextException, GeneralSecurityException
{    JettyAdminServer server = new JettyAdminServer();    try {        server.start();        queryAdminServer(jettyAdminPort);    } finally {        server.shutdown();    }}
e90c8a95aa7890dacce7054bc4fc8cbef0a4379bde7a1d3847ad7e30540f887b
testStandalone
public void testStandalone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServerMainTest.MainThread main = new ZooKeeperServerMainTest.MainThread(CLIENT_PORT, false, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(jettyAdminPort);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
3e5505cd6817549e2b94f2289f232edc7b8f36ae9544fc7bcf8da796bb4ea7b1
testQuorum
public void testQuorum() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    final int ADMIN_SERVER_PORT1 = PortAssignment.unique();    final int ADMIN_SERVER_PORT2 = PortAssignment.unique();    String quorumCfgSection = String.format("server.1=127.0.0.1:%d:%d;%d\nserver.2=127.0.0.1:%d:%d;%d", PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    QuorumPeerTestBase.MainThread q1 = new QuorumPeerTestBase.MainThread(1, CLIENT_PORT_QP1, ADMIN_SERVER_PORT1, quorumCfgSection, null);    q1.start();                Thread.sleep(500);    QuorumPeerTestBase.MainThread q2 = new QuorumPeerTestBase.MainThread(2, CLIENT_PORT_QP2, ADMIN_SERVER_PORT2, quorumCfgSection, null);    q2.start();    Thread.sleep(500);    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(ADMIN_SERVER_PORT1);    queryAdminServer(ADMIN_SERVER_PORT2);    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
3cfd9f338cad0a649fa23c62ea513c625a6b94c2c57f031357f506cfb19957cb
queryAdminServer
private void queryAdminServer(int port) throws IOException, SSLContextException
{    queryAdminServer(String.format(URL_FORMAT, port), false);    queryAdminServer(String.format(HTTPS_URL_FORMAT, port), true);}
754be30eb843a2bc5e18a403f70e6b0ae78046193211864ad2f614f8a270974b
queryAdminServer
private void queryAdminServer(String urlStr, boolean encrypted) throws IOException, SSLContextException
{    URL url = new URL(urlStr);    BufferedReader dis;    if (!encrypted) {        dis = new BufferedReader(new InputStreamReader((url.openStream())));    } else {        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();        dis = new BufferedReader(new InputStreamReader(conn.getInputStream()));    }    String line = dis.readLine();    assertTrue(line.length() > 0);}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    if (throttle.getDropChance() > 0) {        flag = 1 - flag;        return flag;    } else {        return 1;    }}
c7194f6e4b34758c095103e4b14c6ceffb7ed2e9ad7bd42e8196ae3441e7ce6a
testThrottleDisabled
public void testThrottleDisabled()
{    BlueThrottle throttler = new BlueThrottle();    assertTrue("Throttle should be disabled by default", throttler.checkLimit(1));}
0867461142ec3d5267bf49718c5553dcdf4e5f367d75f8a22eb6d0203a555e67
testThrottleWithoutRefill
public void testThrottleWithoutRefill()
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(2000);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));}
c3719642227a1eb1b29b1eb6646bd635509cac87f4b49c12744de340043d8b9e
testThrottleWithRefill
public void testThrottleWithRefill() throws InterruptedException
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(500);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));        Thread.sleep(750);    assertTrue("Third request should be allowed since we've got a new token", throttler.checkLimit(1));}
dc9528639adcaf0e8f685f10867a639c2d3463bd392b957f2cb1c5396e2b791f
testThrottleWithoutRandomDropping
public void testThrottleWithoutRandomDropping() throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(110);    throttler.checkLimit(1);    assertFalse("Dropping probability should still be zero", throttler.getDropChance() > 0);        Thread.sleep(1500);    for (int i = 0; i < maxTokens; i++) {        assertTrue("The first " + maxTokens + " requests should be allowed", throttler.checkLimit(1));    }    for (int i = 0; i < maxTokens; i++) {        assertFalse("The latter " + maxTokens + " requests should be denied", throttler.checkLimit(1));    }}
1639cb244a3cb7bd0888e17a1eb938b02c3e6c1fe8948c0acdeeb7c7adf1805f
testThrottleWithRandomDropping
public void testThrottleWithRandomDropping() throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    throttler.setFreezeTime(100);    throttler.setDropIncrease(0.5);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(120);        throttler.checkLimit(1);    assertTrue("Dropping probability should be increased", throttler.getDropChance() > 0);    LOG.info("Dropping probability is {}", throttler.getDropChance());        Thread.sleep(1100);    LOG.info("Bucket is refilled with {} tokens.", maxTokens);    int accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }    LOG.info("Send {} requests, {} are accepted", maxTokens, accepted);    assertTrue("The dropping should be distributed", accepted < maxTokens);    accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }    LOG.info("Send another {} requests, {} are accepted", maxTokens, accepted);    assertTrue("Later requests should have a chance", accepted > 0);}
4a7cd368760bbf812b13fba04b639bfd73067b5c0d2f96635d9208f1848a6558
connect
private int connect(int n) throws Exception
{    String connStr = quorumUtil.getConnectionStringForServer(1);    int connected = 0;    zks = new ZooKeeper[n];    watchers = new ClientBase.CountdownWatcher[n];    for (int i = 0; i < n; i++) {        watchers[i] = new ClientBase.CountdownWatcher();        zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            connected++;        } catch (TimeoutException e) {            LOG.info("Connection denied by the throttler due to insufficient tokens");            break;        }    }    return connected;}
becd1c08f736f7d767927b21a3bbd3f2681e743d5b2d4d267565fa02c91f4d3a
shutdownQuorum
private void shutdownQuorum() throws Exception
{    for (ZooKeeper zk : zks) {        if (zk != null) {            zk.close();        }    }    quorumUtil.shutdownAll();}
c73be6bdad3da36770a287577845377fb9fb55f6bb006e333b023dc95d10fbd6
testNoThrottling
public void testNoThrottling() throws Exception
{    quorumUtil.startAll();        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(0);    int connected = connect(10);    Assert.assertEquals(10, connected);    shutdownQuorum();}
ebf3aa5fa353698bb7c08dbb2972ddba29489ff67d5ac0f49097ccaa297ca301
testThrottling
public void testThrottling() throws Exception
{    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();}
e90f7f2cd677de3530e7684f5de7a225c6b401a57bd8d14f4f2fa8c7859aca1d
testWeighedThrottling
public void testWeighedThrottling() throws Exception
{            BlueThrottle.setConnectionWeightEnabled(true);    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        int connected = connect(11);    Assert.assertEquals(10, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        connected = connect(11);    Assert.assertEquals(3, connected);    shutdownQuorum();    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(2);    Assert.assertEquals(2, connected);    quorumUtil.shutdown(1);    watchers[0].waitForDisconnected(RAPID_TIMEOUT);    watchers[1].waitForDisconnected(RAPID_TIMEOUT);    quorumUtil.restart(1);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(3);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int reconnected = 0;    for (int i = 0; i < 2; i++) {        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            reconnected++;        } catch (TimeoutException e) {            LOG.info("One reconnect fails due to insufficient tokens");        }    }        LOG.info("reconnected {}", reconnected);    Assert.assertEquals(1, reconnected);    shutdownQuorum();}
a80321659a99b352c8cc43cf7a4af27cfb9d2bc91b4f60096aee3b259fe65fe6
setUpClass
public static void setUpClass()
{    int len = DATA_BYTES_0.length + 2;    DATA_BYTES = new byte[len];    System.arraycopy(DATA_BYTES_0, 0, DATA_BYTES, 0, DATA_BYTES_0.length);    DATA_BYTES[len - 2] = (byte) 0x0;    DATA_BYTES[len - 1] = (byte) 0xff;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    bb = ByteBuffer.wrap(DATA_BYTES);    in = new ByteBufferInputStream(bb);    bs = new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4 };}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        int b = in.read();        assertEquals(DATA_BYTES[i], (byte) b);    }    assertEquals(-1, in.read());}
774f17b6662058b73d3c351a992d543800716496836d2dd92519f069427b5238
testReadArrayOffsetLength
public void testReadArrayOffsetLength() throws Exception
{    assertEquals(1, in.read(bs, 2, 1));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[0], (byte) 4 };    assertArrayEquals(expected, bs);}
1c05d82129c01630ed3823c3f577a8cce4e9f272b45e97e844323be51f661abb
testReadArrayOffsetLength_LengthTooLarge
public void testReadArrayOffsetLength_LengthTooLarge() throws Exception
{    in.read(bs, 2, 3);}
3931594050b81ffd30987033605719ab54d9ec93d7cade149aa061e5168acba1
testReadArrayOffsetLength_HitEndOfStream
public void testReadArrayOffsetLength_HitEndOfStream() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1, in.read(bs, 2, 2));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[DATA_BYTES.length - 1], (byte) 4 };    assertArrayEquals(expected, bs);}
4a26b30c9ae2512d2e848ee222f21abe346317a1b3d7798272676e9047ba7948
testReadArrayOffsetLength_AtEndOfStream
public void testReadArrayOffsetLength_AtEndOfStream() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(-1, in.read(bs, 2, 2));    assertArrayEquals(expected, bs);}
bb91c9338e820280c461ee15b40c23069ca1959ff9e55763afe18c2e5184ac5a
testReadArrayOffsetLength_0Length
public void testReadArrayOffsetLength_0Length() throws Exception
{    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(0, in.read(bs, 2, 0));    assertArrayEquals(expected, bs);}
ad24e6bb13684d07dddef5d73614ab895c2719d42b9266893610046094e204ef
testReadArray
public void testReadArray() throws Exception
{    byte[] expected = Arrays.copyOf(DATA_BYTES, 4);    assertEquals(4, in.read(bs));    assertArrayEquals(expected, bs);}
015b2b6b16b8c27ce77fd9133f4b8e8ee01136e1798169674fcdcb010616e4ec
testSkip
public void testSkip() throws Exception
{    in.read();    assertEquals(2L, in.skip(2L));    assertEquals(DATA_BYTES[3], in.read());    assertEquals(DATA_BYTES[4], in.read());}
d5301b4fdbb229a182a66fa963858fc3bc9f2b5c9c04b8186eee74c88e9b202e
testSkip2
public void testSkip2() throws Exception
{    for (int i = 0; i < DATA_BYTES.length / 2; i++) {        in.read();    }    long skipAmount = DATA_BYTES.length / 4;    assertEquals(skipAmount, in.skip(skipAmount));    int idx = DATA_BYTES.length / 2 + (int) skipAmount;    assertEquals(DATA_BYTES[idx++], in.read());    assertEquals(DATA_BYTES[idx++], in.read());}
e65b6696071738379b2b5165cfef07c25947e3be47d0d8a7a074e665e41be643
testNegativeSkip
public void testNegativeSkip() throws Exception
{    in.read();    assertEquals(0L, in.skip(-2L));    assertEquals(DATA_BYTES[1], in.read());    assertEquals(DATA_BYTES[2], in.read());}
b0db74046468b595d73ae69959b79d27e5fe093dd1e459ba72dffa547c6b4cdb
testSkip_HitEnd
public void testSkip_HitEnd() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1L, in.skip(2L));    assertEquals(-1, in.read());}
99984e49e2851eb28ff92acd0d66fe8e8feb332ea217f011f390174a6dd33f4e
testSkip_AtEnd
public void testSkip_AtEnd() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    assertEquals(0L, in.skip(2L));    assertEquals(-1, in.read());}
24767ffbdad0700f422546df1ad708c5adb83dc199ea6593d420cbd03cc69b96
testAvailable
public void testAvailable() throws Exception
{    for (int i = DATA_BYTES.length; i > 0; i--) {        assertEquals(i, in.available());        in.read();    }    assertEquals(0, in.available());}
5d2e2fbdcabe0b41229c521984d2a053cc4ccc85db32802eb31d1b8880c8489f
testRevalidateCount
public void testRevalidateCount() throws Exception
{    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);        util.enableLocalSession(false);    util.startAll();    int follower1 = (int) util.getFollowerQuorumPeers().get(0).getId();    int follower2 = (int) util.getFollowerQuorumPeers().get(1).getId();    LOG.info("connecting to server: {}", follower1);    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();        ZooKeeper zk = new ZooKeeper(util.getConnectionStringForServer(follower1), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    LOG.info("connected");        zk.updateServerList(util.getConnectionStringForServer(follower2));        util.shutdown(follower1);    watcher.waitForDisconnected(ClientBase.CONNECTION_TIMEOUT);    LOG.info("disconnected");        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    LOG.info("reconnected");    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_revalidate_count"));    assertEquals(1L, values.get("revalidate_count"));    zk.close();    util.shutdownAll();}
d54692b66f45bd8a566793607b11103ecff3235302b7408ccb21f4d2a90da732
isSocketOpen
protected boolean isSocketOpen()
{    return true;}
a74f102fbbaf2b6806d935d5603da5e711c66912831aa6fca5c95f6b1ee2bf29
channel
public SelectableChannel channel()
{    return null;}
0162442a7c5ed590e02d246b93a12a29d94a2c310f448f7925440b6c1a0a05ee
selector
public Selector selector()
{    return mock(Selector.class);}
5d7e7426cc3979089b19a726ac0ddfcf063e2e361e313de81396724c2e017b02
isValid
public boolean isValid()
{    return true;}
8e2e15bc239297e41c6ca1c3353f9e41484d08a5a299d452ddf9c1e60e2a0217
cancel
public void cancel()
{}
5dc36929be26bd58e4706569ecbfc0593243b20be54ba273cff47613b9933147
interestOps
public int interestOps()
{    return ops;}
57bf4050b18aba7bb4c2048164fecbfe40939165886d0c45e5e27f537fa30f39
interestOps
public SelectionKey interestOps(int ops)
{    this.ops = ops;    return this;}
9c34c93a5787cb7721b80768d5735d29f9ec5b8a937ca27be2e33fd6e4791562
readyOps
public int readyOps()
{    return ops;}
d9b022d2947f096438a33ba43116f918c1983f9f30823f50d57eceacf5df1007
createMockNIOCnxn
private NIOServerCnxn createMockNIOCnxn() throws IOException
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddr);    SocketChannel sock = mock(SocketChannel.class);    when(sock.socket()).thenReturn(socket);    when(sock.read(any(ByteBuffer.class))).thenReturn(-1);    return new MockNIOServerCnxn(mock(ZooKeeperServer.class), sock, null, mock(NIOServerCnxnFactory.class), null);}
2c46aef7f41ce9b42f4b20c701e9afd8de1a329fee92f00bf988f55b5d9d68e3
testNIOConnectionDropCount
public void testNIOConnectionDropCount() throws Exception
{    ServerMetrics.getMetrics().resetAll();    NIOServerCnxn cnxn = createMockNIOCnxn();    cnxn.doIO(new FakeSK());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
7c6edbd8b34d591c9929146c3aecfc8fb721bff85942901d6a81fa35ee15d13c
testNettyConnectionDropCount
public void testNettyConnectionDropCount() throws Exception
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Channel channel = mock(Channel.class);    when(channel.isOpen()).thenReturn(false);    when(channel.remoteAddress()).thenReturn(socketAddr);    EventLoop eventLoop = mock(EventLoop.class);    when(channel.eventLoop()).thenReturn(eventLoop);    ServerMetrics.getMetrics().resetAll();    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    NettyServerCnxn cnxn = new NettyServerCnxn(channel, mock(ZooKeeperServer.class), factory);        factory.cnxns.add(cnxn);    cnxn.close();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
5ac72fa14f0e9a1b5c16be05222c6d6f710c84fcfab256b82a43b6f1774b7cd2
testSessionlessConnectionsExpired
public void testSessionlessConnectionsExpired() throws Exception
{    ServerCnxnFactory factory = new NIOServerCnxnFactory();    factory.configure(new InetSocketAddress(PortAssignment.unique()), 1000);    factory.start();    int timeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);    ServerMetrics.getMetrics().resetAll();        ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("sessionless_connections_expired") == null || sleptTime < 2 * timeout) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("sessionless_connections_expired"));    factory.shutdown();}
62e303af5c386d167b3f3a373d988d872f18e236a51336a34476bc9c9b8646e2
testStaleSessionsExpired
public void testStaleSessionsExpired() throws Exception
{    int tickTime = 1000;    SessionTrackerImpl tracker = new SessionTrackerImpl(mock(ZooKeeperServer.class), new ConcurrentHashMap<>(), tickTime, 1L, null);    tracker.sessionsById.put(1L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.sessionsById.put(2L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.touchSession(1L, tickTime);    tracker.touchSession(2L, tickTime);    ServerMetrics.getMetrics().resetAll();    tracker.start();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("stale_sessions_expired") == null || sleptTime < 2 * tickTime) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("stale_sessions_expired"));    tracker.shutdown();}
887884fbe90d414ebd7fb99ac3684fda3d63b09ea3899c3cd1c847ea8c532b1f
corruptFile
private void corruptFile(File file) throws IOException
{        RandomAccessFile raf = new RandomAccessFile(file, "rw");    byte[] b = "mahadev".getBytes();    long writeLen = 500L;    raf.seek(writeLen);        raf.write(b);    raf.close();}
b8f315658dd584af62aec6517f3ffc2f045193cc4a2f21a3bde2066482627b33
getCheckSum
private boolean getCheckSum(FileSnap snap, File snapFile) throws IOException
{    DataTree dt = new DataTree();    Map<Long, Integer> sessions = new ConcurrentHashMap<Long, Integer>();    InputStream snapIS = new BufferedInputStream(new FileInputStream(snapFile));    CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());    InputArchive ia = BinaryInputArchive.getArchive(crcIn);    try {        snap.deserialize(dt, sessions, ia);    } catch (IOException ie) {                                        snapIS.close();        crcIn.close();        throw ie;    }    long checksum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");    snapIS.close();    crcIn.close();    return (val != checksum);}
7c689944aeb0f4c306ea35b493aca59dc646acd94c9f37826eb2a119e4766e80
testChecksums
public void testChecksums() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(150);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    LOG.info("starting up the zookeeper server .. waiting");    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/crctest- " + i, ("/crctest- " + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    File versionDir = new File(tmpDir, "version-2");    File[] list = versionDir.listFiles();            File snapFile = null;    File logFile = null;    for (File file : list) {        LOG.info("file is " + file);        if (file.getName().startsWith("log")) {            logFile = file;            corruptFile(logFile);        }    }    FileTxnLog flog = new FileTxnLog(versionDir);    TxnIterator itr = flog.read(1);        try {        while (itr.next()) {        }        assertTrue(false);    } catch (IOException ie) {        LOG.info("crc corruption", ie);    }    itr.close();        FileSnap snap = new FileSnap(versionDir);    List<File> snapFiles = snap.findNRecentSnapshots(2);    snapFile = snapFiles.get(0);    corruptFile(snapFile);    boolean cfile = false;    try {        cfile = getCheckSum(snap, snapFile);    } catch (IOException ie) {                                snapFile = snapFiles.get(1);        corruptFile(snapFile);        cfile = getCheckSum(snap, snapFile);    }    assertTrue(cfile);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
7949b79e4c5f479f2ef75f89e00d8a9c56cf58349c13f3b90c56c70b2d6b254d
testCreate
public void testCreate() throws KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
bbb142b2efa82111da3f3138e748796860e36abcab3019ee3144fe171c57861d
testCreateWithStat
public void testCreateWithStat() throws KeeperException, InterruptedException
{    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
3279aebf016752bbcd19216e9137fdccaf62d84f77b364e6db7bdd5f820a41a5
testCreateWithNullStat
public void testCreateWithNullStat() throws KeeperException, InterruptedException
{    final String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            zk.create(name, name.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
9796d0f7333fe206ea5ac08d369e612871679a1528cef3d05d96214b4bb67120
testSimpleDeletion
public void testSimpleDeletion() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
a1b004b78533acbba3eb2fc611eaea12d8660da1e4eb9713df45752ebd44a606
testMultiWithContainerSimple
public void testMultiWithContainerSimple() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.multi(Collections.singletonList(createContainer));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);}
2e4e6ad742c67d491734d4135693a5c91d4d3c1c014e5e5fc18feb731f8d2c4e
testMultiWithContainer
public void testMultiWithContainer() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    Op createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.multi(Arrays.asList(createContainer, createChild));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));    createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Op deleteChild = Op.delete("/foo/bar", -1);    zk.multi(Arrays.asList(createContainer, createChild, deleteChild));    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
25f6a114c61251e051e1f93c52a6a8f52376c1efb738c026abf0004cdbf76a6d
testSimpleDeletionAsync
public void testSimpleDeletionAsync() throws KeeperException, InterruptedException
{    final CountDownLatch latch = new CountDownLatch(1);    AsyncCallback.Create2Callback cb = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            assertEquals(ctx, "context");            latch.countDown();        }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, cb, "context");    assertTrue(latch.await(5, TimeUnit.SECONDS));    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    assertEquals(ctx, "context");    latch.countDown();}
f3ac3b9b8997df8ec220dcef495100280b58cee9b646bf1e53be83703a042803
testCascadingDeletion
public void testCascadingDeletion() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar/one", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar/one", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo/bar", false));    assertNull("Container should have been deleted", zk.exists("/foo", false));}
9ed7afd25a42721bb794af0a3148805616c30a9fc3e28298404138d165502b35
testFalseEmpty
public void testFalseEmpty() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected Collection<String> getCandidates() {            return Collections.singletonList("/foo");        }    };    containerManager.checkContainers();    Thread.sleep(1000);    assertNotNull("Container should have not been deleted", zk.exists("/foo", false));}
fa5f65d432b0249fcaf3a885515c4009820a958c58f853d4716e178bcbecd25d
getCandidates
protected Collection<String> getCandidates()
{    return Collections.singletonList("/foo");}
d23bda45762b255eef2429beecb8a31fdf8864412dcb35210ac646cbdf3bd566
testMaxPerMinute
public void testMaxPerMinute() throws InterruptedException
{    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();    RequestProcessor processor = new RequestProcessor() {        @Override        public void processRequest(Request request) {            queue.add(new String(request.request.array()));        }        @Override        public void shutdown() {        }    };    final ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), processor, 1, 2) {        @Override        protected long getMinIntervalMs() {            return 1000;        }        @Override        protected Collection<String> getCandidates() {            return Arrays.asList("/one", "/two", "/three", "/four");        }    };    Executors.newSingleThreadExecutor().submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            containerManager.checkContainers();            return null;        }    });    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/one");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/two");    assertEquals(queue.size(), 0);    Thread.sleep(500);    assertEquals(queue.size(), 0);    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/three");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/four");}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    queue.add(new String(request.request.array()));}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
7095b403948791f77ecbfe171636dd8e3f711b896f50e09f593cf0ce77515f29
getMinIntervalMs
protected long getMinIntervalMs()
{    return 1000;}
fa5f65d432b0249fcaf3a885515c4009820a958c58f853d4716e178bcbecd25d
getCandidates
protected Collection<String> getCandidates()
{    return Arrays.asList("/one", "/two", "/three", "/four");}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    containerManager.checkContainers();    return null;}
7e01a8adad071c037f5ecd25f11aad18d9635cfe123c5c93e85dd738a280ebb1
createNoStatVerifyResult
private void createNoStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
c9102d3dbfc4aa99b28b1adf8ecad5a7829d64131dd0761030dc3cd0c80dad77
createWithStatVerifyResult
private Stat createWithStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
670038e36942d806b6e6719a334d91775146711dca7a3693a41bed41de3a0fea
validateCreateStat
private void validateCreateStat(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, disabledTests.contains(getTestName()) ? "false" : "true");    super.setUpWithServerId(254);    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    super.tearDown();    zk.close();}
7949b79e4c5f479f2ef75f89e00d8a9c56cf58349c13f3b90c56c70b2d6b254d
testCreate
public void testCreate() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
91d971dd228e95d41f39b4ed8bea1bd258ef229af27d48eca3b20f3b4e10642e
testBadTTLs
public void testBadTTLs() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), -100);    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));    request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue() + 1);    response = new CreateResponse();    r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));}
c4c41c493380381bb56d2a1d4cb5a0ff3558f6561a707398a8092471c0370123
testMaxTTLs
public void testMaxTTLs() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue());    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("EphemeralType.getMaxTTL() should succeed", r.getErr(), Code.OK.intValue());    assertNotNull("Node should exist", zk.exists(path, false));}
84164775126fc83ad9a99e4b7d3e69bfaa0a85ff53ce0f4d2402e8b59e0ed711
testCreateSequential
public void testCreateSequential() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    String path = zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists(path, false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists(path, false));}
4dc783628e14ded20355198b07b6abcf6ded349a5618975cce45d58cf59ab0fb
testCreateAsync
public void testCreateAsync() throws KeeperException, InterruptedException
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, callback, null, 100);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{}
66431f65a4a9a03eef882f806c475ffffd75ea871645d3c28cb4bf94e031748c
testModifying
public void testModifying() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    for (int i = 0; i < 10; ++i) {        fakeElapsed.set(50);        zk.setData("/foo", new byte[i + 1], -1);        containerManager.checkContainers();        assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    }    fakeElapsed.set(200);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
e8864f725af58dd834b719e755a64d70cbe2c0290b5093921beb791f3a3b0e2c
testMulti
public void testMulti() throws KeeperException, InterruptedException
{    Op createTtl = Op.create("/a", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 100);    Op createTtlSequential = Op.create("/b", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 200);    Op createNonTtl = Op.create("/c", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> results = zk.multi(Arrays.asList(createTtl, createTtlSequential, createNonTtl));    String sequentialPath = ((OpResult.CreateResult) results.get(1)).getPath();    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("node should not have been deleted yet", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(110);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(210);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNull("node should have been deleted", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));}
96a6cd7d7e63eb568509715c330cc8400f867b131ef8a41fde0869174e23587a
testBadUsage
public void testBadUsage() throws KeeperException, InterruptedException
{    for (CreateMode createMode : CreateMode.values()) {        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, new Stat(), createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    for (CreateMode createMode : CreateMode.values()) {        AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                        }        };        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, callback, null, createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{}
dbf30f34769e408255125eeaeeeb525541e7d4971d77d453b1edd092b29d6128
testDisabled
public void testDisabled() throws KeeperException, InterruptedException
{        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 100);}
5795df3145549b26a29e3154fd10f12fa70dcc9870a2bf807774fbbba67d98c9
newContainerManager
private ContainerManager newContainerManager(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
a64f21e43dcfb0ced769bec047f96296979557f90ccf011b11a525cf58c7f64b
getElapsed
protected long getElapsed(DataNode node)
{    return fakeElapsed.get();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    File dataDir = ClientBase.createTmpDir();    snapDir = dataDir;    dataLogDir = dataDir;}
0d0044294924ac0624a293c03be21167ba3ec6022158cf40aa8d0e5156f20bf1
testPurgeTask
public void testPurgeTask() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 1);    purgeMgr.start();    assertEquals("Data log directory is not set as configured", dataLogDir, purgeMgr.getDataLogDir());    assertEquals("Snapshot directory is not set as configured", snapDir, purgeMgr.getSnapDir());    assertEquals("Snapshot retain count is not set as configured", 3, purgeMgr.getSnapRetainCount());    assertEquals("Purge task is not started", STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is still running after shutdown", COMPLETED, purgeMgr.getPurgeTaskStatus());}
ecf29b762afdefa040902995a21cbe56d12bec4c035a621869a8b28cc0f469a1
testWithZeroPurgeInterval
public void testWithZeroPurgeInterval() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 0);    purgeMgr.start();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
4ce1f04f807ba6441ffdf595d9c44f9349098fcda492caacf10c6a8a04ae9149
testWithNegativePurgeInterval
public void testWithNegativePurgeInterval() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, -1);    purgeMgr.start();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (purgeMgr != null) {        purgeMgr.shutdown();    }}
309b7b8fbe037dbc41df09cd84dcb957d2b59f5948991e6b57c4da33ebdd7ebe
testGetChildrenShouldReturnEmptySetWhenThereAreNoChidren
public void testGetChildrenShouldReturnEmptySetWhenThereAreNoChidren()
{        DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        String child = "child";    dataNode.addChild(child);    dataNode.removeChild(child);    children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
51536758015b51e9108d755b3f584e8c6d86999aa845fb74c9745b26c59f9b1d
testGetChildrenReturnsImmutableEmptySet
public void testGetChildrenReturnsImmutableEmptySet()
{    DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
e0548316ee75d313ce92a34880b3494d2556c0415de51bfc5871b323d4807329
testDumpEphemerals
public void testDumpEphemerals() throws Exception
{    int count = 1000;    long session = 1000;    long zxid = 2000;    final DataTree dataTree = new DataTree();    LOG.info("Create {} zkclient sessions and its ephemeral nodes", count);    createEphemeralNode(session, dataTree, count);    final AtomicBoolean exceptionDuringDumpEphemerals = new AtomicBoolean(false);    final AtomicBoolean running = new AtomicBoolean(true);    Thread thread = new Thread() {        public void run() {            PrintWriter pwriter = new PrintWriter(new StringWriter());            try {                while (running.get()) {                    dataTree.dumpEphemerals(pwriter);                }            } catch (Exception e) {                LOG.error("Received exception while dumpEphemerals!", e);                exceptionDuringDumpEphemerals.set(true);            }        }    };    thread.start();    LOG.debug("Killing {} zkclient sessions and its ephemeral nodes", count);    killZkClientSession(session, zxid, dataTree, count);    running.set(false);    thread.join();    assertFalse("Should have got exception while dumpEphemerals!", exceptionDuringDumpEphemerals.get());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    PrintWriter pwriter = new PrintWriter(new StringWriter());    try {        while (running.get()) {            dataTree.dumpEphemerals(pwriter);        }    } catch (Exception e) {        LOG.error("Received exception while dumpEphemerals!", e);        exceptionDuringDumpEphemerals.set(true);    }}
5b287c10313c48e1eed5e17ebe8a61838ce68e85d5246cd4c8cea62a7fee0b2f
killZkClientSession
private void killZkClientSession(long session, long zxid, final DataTree dataTree, int count)
{    for (int i = 0; i < count; i++) {        dataTree.killSession(session + i, zxid);    }}
d44ee7c95af530c00436260f2665dec33855598e57e6d410c458d0a9e37cbed4
createEphemeralNode
private void createEphemeralNode(long session, final DataTree dataTree, int count) throws NoNodeException, NodeExistsException
{    for (int i = 0; i < count; i++) {        dataTree.createNode("/test" + i, new byte[0], null, session + i, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    }}
f25c55f1607df43ba4ce8743c740bd24fce5b36872036ce3f91213dba8adfd00
testRootWatchTriggered
public void testRootWatchTriggered() throws Exception
{    DataTree dt = new DataTree();    CompletableFuture<Void> fire = new CompletableFuture<>();        dt.getChildren("/", new Stat(), event -> {        if (event.getPath().equals("/")) {            fire.complete(null);        }    });        dt.createNode("/xyz", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);    assertTrue("Root node watch not triggered", fire.isDone());}
3b24199d6a73b75d06a64466ceb6714876f160a5a84f9c14f5defa9e6924b9f9
testIncrementCversion
public void testIncrementCversion() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);        DataNode zk = dt.getNode("/test");        int prevCversion = zk.stat.getCversion();        long prevPzxid = zk.stat.getPzxid();        long digestBefore = dt.getTreeDigest();        dt.setCversionPzxid("/test/", prevCversion + 1, prevPzxid + 1);        int newCversion = zk.stat.getCversion();        long newPzxid = zk.stat.getPzxid();        assertTrue("<cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));        assertNotEquals(digestBefore, dt.getTreeDigest());    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
764320b5b0b6d3b8dd33ed7bab5d35c6cf66a2603253e4fa671da71133eae95b
testNoCversionRevert
public void testNoCversionRevert() throws Exception
{    DataTree dt = new DataTree();    DataNode parent = dt.getNode("/");    dt.createNode("/test", new byte[0], null, 0, parent.stat.getCversion() + 1, 1, 1);    int currentCversion = parent.stat.getCversion();    long currentPzxid = parent.stat.getPzxid();    dt.createNode("/test1", new byte[0], null, 0, currentCversion - 1, 1, 1);    parent = dt.getNode("/");    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    assertTrue("<cversion, pzxid> verification failed. Expected: <" + currentCversion + ", " + currentPzxid + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion >= currentCversion && newPzxid >= currentPzxid));}
4bccf8175df6a93dc678aa3fb422726dba36a38bb16c4a75d7e5147dacd85d7e
testPzxidUpdatedWhenDeletingNonExistNode
public void testPzxidUpdatedWhenDeletingNonExistNode() throws Exception
{    DataTree dt = new DataTree();    DataNode root = dt.getNode("/");    long currentPzxid = root.stat.getPzxid();        long zxid = currentPzxid + 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, zxid);        long prevPzxid = currentPzxid;    zxid = prevPzxid - 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, prevPzxid);}
d51b207fd17e4206ca5a8d5e57a7cf0f5ad9141e11d822e67f20d2ff0ffc64c3
testDigestUpdatedWhenReplayCreateTxnForExistNode
public void testDigestUpdatedWhenReplayCreateTxnForExistNode()
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                                dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 2));                assertEquals(dt.getTreeDigest(), dt.getLastProcessedZxidDigest().digest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
69a3adde9c5f5888800c57aeefb9b75dbf3e0420ee87e5420e987216668fd3b2
testPathTrieClearOnDeserialize
public void testPathTrieClearOnDeserialize() throws Exception
{        DataTree dserTree = new DataTree();    dserTree.createNode("/bug", new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaZookeeper + "/bug", null, null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaPath("/bug"), new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.statPath("/bug"), new byte[20], null, -1, 1, 1, 1);        DataTree tree = new DataTree();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    dserTree.deserialize(ia, "test");    Field pfield = DataTree.class.getDeclaredField("pTrie");    pfield.setAccessible(true);    PathTrie pTrie = (PathTrie) pfield.get(dserTree);        assertEquals("/bug is still in pTrie", "/", pTrie.findMaxPrefix("/bug"));}
704ca69f7c3e77454251bcc2edfd9fb282f941250d35538c60262357939c3905
testSerializeDoesntLockDataNodeWhileWriting
public void testSerializeDoesntLockDataNodeWhileWriting() throws Exception
{    DataTree tree = new DataTree();    tree.createNode("/marker", new byte[] { 42 }, null, -1, 1, 1, 1);    final DataNode markerNode = tree.getNode("/marker");    final AtomicBoolean ranTestCase = new AtomicBoolean();    DataOutputStream out = new DataOutputStream(new ByteArrayOutputStream());    BinaryOutputArchive oa = new BinaryOutputArchive(out) {        @Override        public void writeRecord(Record r, String tag) throws IOException {                        if (r instanceof DataNode) {                DataNode node = (DataNode) r;                if (node.data.length == 1 && node.data[0] == 42) {                    final Semaphore semaphore = new Semaphore(0);                    new Thread(new Runnable() {                        @Override                        public void run() {                            synchronized (markerNode) {                                                                semaphore.release();                            }                        }                    }).start();                    try {                        boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                                        assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);                    } catch (InterruptedException e1) {                        throw new RuntimeException(e1);                    }                    ranTestCase.set(true);                }            }            super.writeRecord(r, tag);        }    };    tree.serialize(oa, "test");        assertTrue("Didn't find the expected node", ranTestCase.get());}
64bb611dbb27873489157fc69e6392c0bf17411ba942997ac2a5c7ab8ab33ad5
writeRecord
public void writeRecord(Record r, String tag) throws IOException
{        if (r instanceof DataNode) {        DataNode node = (DataNode) r;        if (node.data.length == 1 && node.data[0] == 42) {            final Semaphore semaphore = new Semaphore(0);            new Thread(new Runnable() {                @Override                public void run() {                    synchronized (markerNode) {                                                semaphore.release();                    }                }            }).start();            try {                boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);            } catch (InterruptedException e1) {                throw new RuntimeException(e1);            }            ranTestCase.set(true);        }    }    super.writeRecord(r, tag);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    synchronized (markerNode) {                semaphore.release();    }}
5e76a12180159fcfb69cf440b37ad630fa603471ce85b9d99c84aec142841b74
testReconfigACLClearOnDeserialize
public void testReconfigACLClearOnDeserialize() throws Exception
{    DataTree tree = new DataTree();            tree.deleteNode(ZooDefs.CONFIG_NODE, 1);    tree.getReferenceCountedAclCache().aclIndex = 0;    assertEquals("expected to have 1 acl in acl cache map", 0, tree.aclCacheSize());        tree.createNode("/bug", new byte[20], ZooDefs.Ids.OPEN_ACL_UNSAFE, -1, 1, 1, 1);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    tree.deserialize(ia, "test");    assertEquals("expected to have 1 acl in acl cache map", 1, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));            tree.addConfigNode();    assertEquals("expected to have 2 acl in acl cache map", 2, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));}
e6296f8d0b146a500948c44ca019f3a010379c9524d7f39c6ad0702b7479dde3
testCachedApproximateDataSize
public void testCachedApproximateDataSize() throws Exception
{    DataTree dt = new DataTree();    long initialSize = dt.approximateDataSize();    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.createNode("/testApproximateDataSize", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/testApproximateDataSize1", new byte[20], null, -1, 1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.setData("/testApproximateDataSize1", new byte[32], -1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.deleteNode("/testApproximateDataSize", -1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());}
275d716eaa5eb38b90c00d9e0f035be36e429c26f2e09b5b49035b5c06da75b5
testGetAllChildrenNumber
public void testGetAllChildrenNumber() throws Exception
{    DataTree dt = new DataTree();        dt.createNode("/all_children_test", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node1", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node2", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node3", new byte[20], null, -1, 1, 1, 1);    assertEquals(4, dt.getAllChildrenNumber("/all_children_test"));    assertEquals(3, dt.getAllChildrenNumber("/all_children_test/nodes"));    assertEquals(0, dt.getAllChildrenNumber("/all_children_test/nodes/node1"));        assertEquals(8, dt.getAllChildrenNumber("/"));}
228f624987ea7e69f3aa70427ab8ab12056febe16cba97a8ab56299a58fd4c25
testDataTreeMetrics
public void testDataTreeMetrics() throws Exception
{    ServerMetrics.getMetrics().resetAll();    long readBytes1 = 0;    long readBytes2 = 0;    long writeBytes1 = 0;    long writeBytes2 = 0;    final String TOP1 = "top1";    final String TOP2 = "ttop2";    final String TOP1PATH = "/" + TOP1;    final String TOP2PATH = "/" + TOP2;    final String CHILD1 = "child1";    final String CHILD2 = "springishere";    final String CHILD1PATH = TOP1PATH + "/" + CHILD1;    final String CHILD2PATH = TOP1PATH + "/" + CHILD2;    final int TOP2_LEN = 50;    final int CHILD1_LEN = 100;    final int CHILD2_LEN = 250;    DataTree dt = new DataTree();    dt.createNode(TOP1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += TOP1PATH.length();    dt.createNode(TOP2PATH, new byte[TOP2_LEN], null, -1, 1, 1, 1);    writeBytes2 += TOP2PATH.length() + TOP2_LEN;    dt.createNode(CHILD1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += CHILD1PATH.length();    dt.setData(CHILD1PATH, new byte[CHILD1_LEN], 1, -1, 1);    writeBytes1 += CHILD1PATH.length() + CHILD1_LEN;    dt.createNode(CHILD2PATH, new byte[CHILD2_LEN], null, -1, 1, 1, 1);    writeBytes1 += CHILD2PATH.length() + CHILD2_LEN;    dt.getData(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getData(TOP2PATH, new Stat(), null);    readBytes2 += TOP2PATH.length() + TOP2_LEN + DataTree.STAT_OVERHEAD_BYTES;    dt.statNode(CHILD2PATH, null);    readBytes1 += CHILD2PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getChildren(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + CHILD1.length() + CHILD2.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.deleteNode(TOP1PATH, 1);    writeBytes1 += TOP1PATH.length();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    System.out.println("values:" + values);    assertEquals(writeBytes1, values.get("sum_" + TOP1 + "_write_per_namespace"));    assertEquals(5L, values.get("cnt_" + TOP1 + "_write_per_namespace"));    assertEquals(writeBytes2, values.get("sum_" + TOP2 + "_write_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_write_per_namespace"));    assertEquals(readBytes1, values.get("sum_" + TOP1 + "_read_per_namespace"));    assertEquals(3L, values.get("cnt_" + TOP1 + "_read_per_namespace"));    assertEquals(readBytes2, values.get("sum_" + TOP2 + "_read_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_read_per_namespace"));}
5c56a87c8999941df41392c833b4b94ae530622b0046919fd24d4b149345e1fc
testDigest
public void testDigest() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();                long previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest", new byte[0], null, -1, 1, 1, 1);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        try {            dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        } catch (NodeExistsException e) {        /* ignore */        }        assertEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.setData("/digesttest/1", "2".getBytes(), 3, 3, 3);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.deleteNode("/digesttest/1", 5);        assertNotEquals(dt.getTreeDigest(), previousDigest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
f8e0d2f850a2f0d84cc72954c4e85d68b17dcbc2db024fba9a41f5f12bc16180
deserializeTree
private static void deserializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    BinaryInputArchive ia;    int count;    {        DataTree tree = new DataTree();        SerializationPerfTest.createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);        count = tree.getNodeCount();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        tree.serialize(oa, "test");        baos.flush();        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ia = BinaryInputArchive.getArchive(bais);    }    DataTree dserTree = new DataTree();    System.gc();    long start = System.nanoTime();    dserTree.deserialize(ia, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    assertEquals(count, dserTree.getNodeCount());    LOG.info("Deserialized " + count + " nodes in " + durationms + " ms (" + pernodeus + "us/node), depth=" + depth + " width=" + width + " datalen=" + len);}
5c7fa3a4fda94976bce8a2d4d981644ce57eec2e68f846169e7c52e6c3324ccf
testSingleDeserialize
public void testSingleDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(1, 0, 20);}
e2de0a79be138f385d22d3757fa05ac02ed5cd99a5b5880969a32d5120de176d
testWideDeserialize
public void testWideDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(2, 10000, 20);}
60fd1c370d782f9edc801d0c024784e814ad95f77c9d6b4b5200e7e615b48250
testDeepDeserialize
public void testDeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(400, 1, 20);}
0a5c2980199eb4274a737cbc7223070fd4051b031306a3fb7bd6b56019c0f45d
test10Wide5DeepDeserialize
public void test10Wide5DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 10, 20);}
b85532cebabc7d095d46a59f6a728fd82dc4b21c9a3367875dd8a10b0a31d814
test15Wide5DeepDeserialize
public void test15Wide5DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 15, 20);}
07d605b6420715c754491c45fabb5b09906e469c77265f9c44429db459f7d6b2
test25Wide4DeepDeserialize
public void test25Wide4DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 25, 20);}
ac892a9c818b4772a0d9ab031dd856371a38c010f8f3b49b8ba188152ae4197b
test40Wide4DeepDeserialize
public void test40Wide4DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 40, 20);}
7b40f1cbd79fcbccde1fb6b6ce803a73d1f81ac3780b95d00c0ce2d8301caaf2
test300Wide3DeepDeserialize
public void test300Wide3DeepDeserialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(3, 300, 20);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");    System.setProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY, "true");    super.setUp();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    System.clearProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY);    super.tearDown();    zk.close();}
7949b79e4c5f479f2ef75f89e00d8a9c56cf58349c13f3b90c56c70b2d6b254d
testCreate
public void testCreate() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
a2c88cbd808c7a94c92711cd1b12fbfff9d90be01d1864822a2ce0ede702c537
test353TTL
public void test353TTL() throws KeeperException, InterruptedException
{    DataTree dataTree = serverFactory.zkServer.getZKDatabase().dataTree;    long ephemeralOwner = EphemeralTypeEmulate353.ttlToEphemeralOwner(100);    dataTree.createNode("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, ephemeralOwner, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
cbf564b8204401034a50ff62a0dd005c300d212bd8134ecc68d4e80039307f0d
testEphemeralOwner_emulationTTL
public void testEphemeralOwner_emulationTTL()
{    assertThat(EphemeralType.get(-1), equalTo(EphemeralType.TTL));}
9387de776182d3359025d5e1ce6591abcaa5e29b8b4cd5aff6b1e691df4d0b37
testEphemeralOwner_emulationContainer
public void testEphemeralOwner_emulationContainer()
{    assertThat(EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER), equalTo(EphemeralType.CONTAINER));}
5795df3145549b26a29e3154fd10f12fa70dcc9870a2bf807774fbbba67d98c9
newContainerManager
private ContainerManager newContainerManager(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
a64f21e43dcfb0ced769bec047f96296979557f90ccf011b11a525cf58c7f64b
getElapsed
protected long getElapsed(DataNode node)
{    return fakeElapsed.get();}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);}
b40920ebac573e548a762f642860615945a7397c2ef2c2e3cf37e452f7bf448c
testTtls
public void testTtls()
{    long[] ttls = { 100, 1, EphemeralType.TTL.maxValue() };    for (long ttl : ttls) {        long ephemeralOwner = EphemeralType.TTL.toEphemeralOwner(ttl);        assertEquals(EphemeralType.TTL, EphemeralType.get(ephemeralOwner));        assertEquals(ttl, EphemeralType.TTL.getValue(ephemeralOwner));    }    EphemeralType.validateTTL(CreateMode.PERSISTENT_WITH_TTL, 100);    EphemeralType.validateTTL(CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 100);    try {        EphemeralType.validateTTL(CreateMode.EPHEMERAL, 100);        fail("Should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
bdabcabc256451cca6cbe14e67cfa7b39c846d8cd9fdf57a79b8c1c44a9394ad
testContainerValue
public void testContainerValue()
{    assertEquals(Long.MIN_VALUE, EphemeralType.CONTAINER_EPHEMERAL_OWNER);    assertEquals(EphemeralType.CONTAINER, EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER));}
8e9cfb7fc245c7d45a365404d8644ec494cff542c694c88a021d9dc744eccf1b
testNonSpecial
public void testNonSpecial()
{    assertEquals(EphemeralType.VOID, EphemeralType.get(0));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(1));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(Long.MAX_VALUE));}
b99efbf86128ca388e4e71187101b18c6eb43484296cfabc1f5550b5152d354a
testServerIds
public void testServerIds()
{    for (int i = 0; i <= EphemeralType.MAX_EXTENDED_SERVER_ID; ++i) {        EphemeralType.validateServerId(i);    }    try {        EphemeralType.validateServerId(EphemeralType.MAX_EXTENDED_SERVER_ID + 1);        fail("Should have thrown RuntimeException");    } catch (RuntimeException e) {        }}
17bdbe4e82144e4c511567a3d211392c3476d68fd195c58a2167198b54017475
testEphemeralOwner_extendedFeature_TTL
public void testEphemeralOwner_extendedFeature_TTL()
{            assertThat(EphemeralType.get(0xff00000000000000L), equalTo(EphemeralType.TTL));}
9a4ecf271681aea51a4643444efe6a3d90f7a969ce7efa24ff234b990c89acb8
testEphemeralOwner_extendedFeature_extendedTypeUnsupported
public void testEphemeralOwner_extendedFeature_extendedTypeUnsupported()
{            EphemeralType.get(0xff00010000000000L);}
91603c2840bef83ee4521fedbe2515b3024f1c556f9380549c8cd671b84a4a65
setUp
public void setUp() throws KeeperException.NoNodeException, IOException
{    testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.ALL, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret")), new ACL(ZooDefs.Perms.READ, new Id("world", "anyone"))));    ZooKeeperServer zks = new ZooKeeperServer();    ZKDatabase db = mock(ZKDatabase.class);    String testPath = "/testPath";    when(db.getNode(eq(testPath))).thenReturn(new DataNode());    when(db.getACL(eq(testPath), any(Stat.class))).thenReturn(testACLs);    when(db.aclForNode(any(DataNode.class))).thenReturn(testACLs);    zks.setZKDatabase(db);    processor = new FinalRequestProcessor(zks);    cnxn = mock(ServerCnxn.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) {            replyHeaders[0] = invocationOnMock.getArgument(0);            responseRecord[0] = invocationOnMock.getArgument(1);            return null;        }    }).when(cnxn).sendResponse(any(), any(), anyString());    GetACLRequest getACLRequest = new GetACLRequest();    getACLRequest.setPath(testPath);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    getACLRequest.serialize(boa, "request");    baos.close();    bb = ByteBuffer.wrap(baos.toByteArray());}
43a7e88cc18b915ce5314f2a85bc4c75e7407a6a3069ef883f04c952419c60f7
answer
public Object answer(InvocationOnMock invocationOnMock)
{    replyHeaders[0] = invocationOnMock.getArgument(0);    responseRecord[0] = invocationOnMock.getArgument(1);    return null;}
a89126a0ef71afc7b6654a5196e6b60d08e44591dc15a722d90c6d3c3e70bbac
testACLDigestHashHiding_NoAuth_WorldCanRead
public void testACLDigestHashHiding_NoAuth_WorldCanRead()
{            Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertMasked(true);}
d3a8af3b633aeabfbee862494e82a91261456426cbfb5a86d7f37b615b4a2f2d
testACLDigestHashHiding_NoAuth_NoWorld
public void testACLDigestHashHiding_NoAuth_NoWorld()
{        testACLs.remove(2);        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertThat(KeeperException.Code.get(replyHeaders[0].getErr()), equalTo(KeeperException.Code.NOAUTH));}
52b063e6cc8511ecd5f5f818e03e97bc4ecdc70febab2954d06557f83319cdf9
testACLDigestHashHiding_UserCanRead
public void testACLDigestHashHiding_UserCanRead()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "otheruser:somesecrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(true);}
50d515860d622ba937e5bfcb92e394bd02263496e2cb514df1fa7433af4f73ef
testACLDigestHashHiding_UserCanAll
public void testACLDigestHashHiding_UserCanAll()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "user:secrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
014a65cf79bce4afde044461c3761ef8ac12b92edfe1c198eaf2ed8c76fc6c85
testACLDigestHashHiding_AdminUser
public void testACLDigestHashHiding_AdminUser()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
d4c5c435c9aec07a64009884a8eb304ac6ac70725c492365490505aab38ac760
testACLDigestHashHiding_OnlyAdmin
public void testACLDigestHashHiding_OnlyAdmin()
{        testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret"))));    List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(2));        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));}
242b1fb07588f2eb605fce8af2338ecc354f3afb28a40b2ff31715011d0ef007
assertMasked
private void assertMasked(boolean masked)
{    assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(3));        assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getScheme(), equalTo("world"));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getId(), equalTo("anyone"));        assertThat("Original ACL list has been modified", testACLs.get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Original ACL list has been modified", testACLs.get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getId(), equalTo("adminuser:adminsecret"));    assertThat("Original ACL list has been modified", testACLs.get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getScheme(), equalTo("world"));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getId(), equalTo("anyone"));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                LOG.error("unexpected exception in run", e);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    main.shutdown();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    super.shutdown();}
19752a899249f94422dcae33f80a1aa3e8e536d64a0677df7c6e39b098730eed
testInvalidSnapCount
public void testInvalidSnapCount() throws Exception
{    final int CLIENT_PORT = 3181;    MainThread main = new MainThread(CLIENT_PORT);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    assertEquals(SyncRequestProcessor.getSnapCount(), 2);    main.shutdown();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
310f77d2d07e00f6f5dc13d2776bb10d4caeb305166fb0402d9b63ac8a9c98f3
testInvalidSnapshot
public void testInvalidSnapshot() throws Exception
{    ZooKeeper zk = createClient();    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    NIOServerCnxnFactory factory = (NIOServerCnxnFactory) serverFactory;    stopServer();        File snapFile = factory.zkServer.getTxnLogFactory().findMostRecentSnapshot();    LOG.info("Corrupting " + snapFile);    RandomAccessFile raf = new RandomAccessFile(snapFile, "rws");    raf.setLength(3);    raf.close();        startServer();        zk = createClient();    try {        assertTrue("the node should exist", (zk.exists("/invalidsnap-1999", false) != null));    } finally {        zk.close();    }}
cf158965f3af52c686e1c9c1c9018553018692f8089240d8019c3340d3ba465d
initCounter
public void initCounter()
{    testCounterSet = new AvgMinMaxCounterSet("test");}
36054b23661969bff94450c84adeaea24eab381359ac9b7768071f1bef11f40e
addDataPoints
private void addDataPoints()
{    testCounterSet.add("key1", 0);    testCounterSet.add("key1", 1);    testCounterSet.add("key2", 2);    testCounterSet.add("key2", 3);    testCounterSet.add("key2", 4);    testCounterSet.add("key2", 5);}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));}
3f5ece75eb7b59fe0748408c1200fb1e591f804de9dcc7d9e33265c5a96b4897
testValues
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0.5", 0.5D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =1", 1L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =2", 2L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =1", 1L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =3.5", 3.5, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 2L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 5L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 4L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 14L, values.get("sum_key2_test"));}
cf158965f3af52c686e1c9c1c9018553018692f8089240d8019c3340d3ba465d
initCounter
public void initCounter()
{    testCounterSet = new AvgMinMaxPercentileCounterSet("test");}
36054b23661969bff94450c84adeaea24eab381359ac9b7768071f1bef11f40e
addDataPoints
private void addDataPoints()
{    for (int i = 0; i < 1000; i++) {        testCounterSet.add("key1", i);    }    for (int i = 1000; i < 2000; i++) {        testCounterSet.add("key2", i);    }}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=0", 0L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=0", 0L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=0", 0L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=0", 0L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=0", 0L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=0", 0L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=0", 0L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=0", 0L, values.get("p999_key2_test"));}
3f5ece75eb7b59fe0748408c1200fb1e591f804de9dcc7d9e33265c5a96b4897
testValues
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 18 values in the set", 18, values.size());    assertEquals("avg_key1_test should =499.5", 999D / 2, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =999", 999L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =1000", 1000L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =999*500", 999 * 500L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=500", 500L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=950", 950L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=990", 990L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=999", 999L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =3.5", 1000 + 999D / 2, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 1000L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 1999L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 1000L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 2999 * 500L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=1500", 1500L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=1950", 1950L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=1990", 1990L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=1999", 1999L, values.get("p999_key2_test"));}
cf158965f3af52c686e1c9c1c9018553018692f8089240d8019c3340d3ba465d
initCounter
public void initCounter()
{    testCounter = new AvgMinMaxPercentileCounter("test");}
36054b23661969bff94450c84adeaea24eab381359ac9b7768071f1bef11f40e
addDataPoints
private void addDataPoints()
{    for (int i = 0; i < 1000; i++) {        testCounter.add(i);    }}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{    addDataPoints();    testCounter.reset();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=0", 0D, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=0", 0L, values.get("max_test"));    assertEquals("should have cnt=0", 0L, values.get("cnt_test"));    assertEquals("should have sum=0", 0L, values.get("sum_test"));    assertEquals("should have p50=0", 0L, values.get("p50_test"));    assertEquals("should have p95=0", 0L, values.get("p95_test"));    assertEquals("should have p99=0", 0L, values.get("p99_test"));    assertEquals("should have p999=0", 0L, values.get("p999_test"));}
3f5ece75eb7b59fe0748408c1200fb1e591f804de9dcc7d9e33265c5a96b4897
testValues
public void testValues()
{    addDataPoints();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=499.5", 999D / 2, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=999", 999L, values.get("max_test"));    assertEquals("should have cnt=1000", 1000L, values.get("cnt_test"));    assertEquals("should have sum=999*500", 999 * 500L, values.get("sum_test"));    assertEquals("should have p50=500", 500L, values.get("p50_test"));    assertEquals("should have p95=950", 950L, values.get("p95_test"));    assertEquals("should have p99=990", 990L, values.get("p99_test"));    assertEquals("should have p999=999", 999L, values.get("p999_test"));}
ea2b9176ea5cc09af955f63a035740000437fa30b9ba58e35fc4dec258a473c8
doIO
public void doIO(SelectionKey k) throws InterruptedException
{    super.doIO(k);}
d54692b66f45bd8a566793607b11103ecff3235302b7408ccb21f4d2a90da732
isSocketOpen
protected boolean isSocketOpen()
{    return true;}
8ec66b82ff962ee9497f62aae0398c741b98c72c6606bab56e0066c3f1653f4f
addInterestOpsUpdateRequest
public boolean addInterestOpsUpdateRequest(SelectionKey sk)
{    return super.addInterestOpsUpdateRequest(sk);}
d013dcb84977c811f89e0afbcfa0c2ffd22226ff8f2df083bf362d3529f7f50d
getSessionTimeout
 int getSessionTimeout()
{    return 0;}
1c9432fa2ab8f03d0e6084f264bde3395a658c6eae5d9f77ab6731b061727623
close
public void close(DisconnectReason reason)
{}
db6402a377fb9b7dff7dcb0769cd3009531d0793c8ee73f3aff6a977cfab07e6
sendResponse
public void sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
83bedad6a94f8012a02f99fd25948c531ae8b56f5c41205e172df54952becfda
sendCloseSession
public void sendCloseSession()
{}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return 0;}
4caad7677e3c8669c49a7cf1a26239722e0cdff3b855e1e74d91e9ac9126f8d7
setSessionId
 void setSessionId(long sessionId)
{}
c6a8b35027b486f9efda96936274975b221803473bdc28c586ea3371f63c78bd
isSecure
public boolean isSecure()
{    return secure;}
31723976639143740a59331b89e7d277a06f3d1c59275eadebaa8b8c1e08a73d
getClientCertificateChain
public Certificate[] getClientCertificateChain()
{    return clientChain;}
3c4125d7fc81566a8a507cd911ec199b7df322e075d329f458f8ea707600fb9d
setClientCertificateChain
public void setClientCertificateChain(Certificate[] chain)
{    clientChain = chain;}
516f988d90d82fb15c8b4f84f8242702b22918ce02a776f8de79dd601eebe350
sendBuffer
 void sendBuffer(ByteBuffer... closeConn)
{}
58e68b4c85468ffa08c7f42ace5739cd939eca225af3ce7aafe5e31dd2a6513d
enableRecv
 void enableRecv()
{}
fe7a18ded4731107a3305283fa7ce03cf99850740564c8b731ad3853edf00003
disableRecv
 void disableRecv(boolean waitDisableRecv)
{}
1d4de09a3a2a487e449f81cf7918ae28d7fa8da97b1e4305eda9f1ad5d70eaac
setSessionTimeout
 void setSessionTimeout(int sessionTimeout)
{}
907231e17b9059060ce5f7ec8aed9ef0cfaf0f263ebbdb7958c25318ca9b292f
serverStats
protected ServerStats serverStats()
{    return null;}
d3b0f75705514add2fe204d1cc16ca3c07407ba28db0d46ed84b3b71a0fb5012
getOutstandingRequests
public long getOutstandingRequests()
{    return 0;}
76a476412aec6ec4444db04281072f7ce0f60422f623a495c0cad0291582361e
getRemoteSocketAddress
public InetSocketAddress getRemoteSocketAddress()
{    return null;}
86eb23327d1db1d9d92af99641864e1a6bd00027abe7be9d5631d6288afd997b
getInterestOps
public int getInterestOps()
{    return 0;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    localSessionsEnabled = true;    localSessionsUpgradingEnabled = true;    super.setUp();}
06a2a54a5404a06405107b56773c6e3c6edd0c5357c8fed2d815f0a1a7d6ceba
ephemeralCreateMultiOpTest
public void ephemeralCreateMultiOpTest() throws KeeperException, InterruptedException, IOException
{    final ZooKeeper zk = createClient();    String data = "test";    String path = "/ephemeralcreatemultiop";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    UpgradeableSessionTracker sessionTracker = (UpgradeableSessionTracker) server.getSessionTracker();    assertFalse("session already global", sessionTracker.isGlobalSession(zk.getSessionId()));    List<OpResult> multi = null;    try {        multi = zk.multi(Arrays.asList(Op.setData(path, data.getBytes(), 0), Op.create(path + "/e", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL), Op.create(path + "/p", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(path + "/q", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));    } catch (KeeperException.SessionExpiredException e) {                fail("received session expired for a session promotion in a multi-op");    }    assertNotNull(multi);    assertEquals(4, multi.size());    assertEquals(data, new String(zk.getData(path + "/e", false, null)));    assertEquals(data, new String(zk.getData(path + "/p", false, null)));    assertEquals(data, new String(zk.getData(path + "/q", false, null)));    assertTrue("session not promoted", sessionTracker.isGlobalSession(zk.getSessionId()));}
8aeb4ecc95ff32f06b2326a391189b03d1120c044a471fce2ad2d8e2e357a2aa
directCheckUpgradeSessionTest
public void directCheckUpgradeSessionTest() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    String path = "/directcheckupgradesession";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    Request readRequest = makeGetDataRequest(path, zk.getSessionId());    Request createRequest = makeCreateRequest(path + "/e", zk.getSessionId());    assertNull("tried to upgrade on a read", server.checkUpgradeSession(readRequest));    assertNotNull("failed to upgrade on a create", server.checkUpgradeSession(createRequest));    assertNull("tried to upgrade after successful promotion", server.checkUpgradeSession(createRequest));}
085dd030b8b764f09e2c928a16baa9476bb30c56477b894fadef53580bc55cb5
makeGetDataRequest
private Request makeGetDataRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest(path, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.getData, bb, new ArrayList<Id>());}
8cb833f21a976d721e436147d1581b6d3c8c232b4b283fb1097ab06752aad9af
makeCreateRequest
private Request makeCreateRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
d356bfc951e69bdc4766012b261153f2079d7c55af217f08d4ce640f7c4c41e9
getConnectedServer
private QuorumZooKeeperServer getConnectedServer(long sessionId)
{    for (QuorumPeer peer : getPeerList()) {        if (peer.getActiveServer().getSessionTracker().isTrackingSession(sessionId)) {            return (QuorumZooKeeperServer) peer.getActiveServer();        }    }    return null;}
5105cc15336f6e35c9587ea2b3d8648c15dd32d2be1cd88392a4344875362462
testRebind
public void testRebind() throws Exception
{    InetSocketAddress addr = new InetSocketAddress(PortAssignment.unique());    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(addr);        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
0a3087c70370a9ff96d622710cf410d2460eaf6f0f3ebf8e58d6540feb3e7012
testRebindIPv4IPv6
public void testRebindIPv4IPv6() throws Exception
{    int randomPort = PortAssignment.unique();    InetSocketAddress addr = new InetSocketAddress("0.0.0.0", randomPort);    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(new InetSocketAddress("[0:0:0:0:0:0:0:0]", randomPort));        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    NettyServerCnxnFactory.setTestAllocator(TestByteBufAllocator.getInstance());    super.maxCnxns = 1;    super.exceptionOnFailedConnect = true;    super.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    NettyServerCnxnFactory.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
88d3170c598ad2443bffaab6507420aad7411b9cfa921aa6c2c08650eb71c778
testSendCloseSession
public void testSendCloseSession() throws Exception
{    assertTrue("Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    final ZooKeeper zk = createClient();    final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();    final String path = "/a";    try {                zk.create(path, "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                assertNotNull("Didn't create znode:" + path, zk.exists(path, true));        assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());        Iterable<ServerCnxn> connections = serverFactory.getConnections();        assertEquals("Mismatch in number of live connections!", 1, serverFactory.getNumAliveConnections());        for (ServerCnxn serverCnxn : connections) {            serverCnxn.sendCloseSession();        }        LOG.info("Waiting for the channel disconnected event");        int timeout = 0;        while (serverFactory.getNumAliveConnections() != 0) {            Thread.sleep(1000);            timeout += 1000;            if (timeout > CONNECTION_TIMEOUT) {                fail("The number of live connections should be 0");            }        }                assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());    } finally {        zk.close();    }}
1185b1d2da666e9449cf56142c5304c8c00cf3cec271bb22e26f27d4f9f47e0a
testMaxConnectionPerIpSurpased
public void testMaxConnectionPerIpSurpased() throws Exception
{    assertTrue("Did not instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    try (final ZooKeeper zk1 = createClient();        final ZooKeeper zk2 = createClient()) {    }}
e4dcfba66916747803679db9135c5f20b6ef8fb58e9463affb4284cdaf43c358
testClientResponseStatsUpdate
public void testClientResponseStatsUpdate() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
9d28ea5fec6fc8b4845e086547362f682d90d34e25e7fb4a2c85ab32d6c83429
testServerSideThrottling
public void testServerSideThrottling() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.getChannel().read();                }            }, 1, TimeUnit.SECONDS);                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);                for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    nettyCnxn.getChannel().read();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    nettyCnxn.enableRecv();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    nettyCnxn.enableRecv();}
a750b1dfd4cbc7996d498808c7accca1a7eccdb7f0cdf0391832ea34212aec66
testEnableDisableThrottling_secure_random
public void testEnableDisableThrottling_secure_random() throws Exception
{    runEnableDisableThrottling(true, true);}
522b6bfb9bc779bdee231cff2aab9fe23a4bbe99e34e96ab712887c67ccdb749
testEnableDisableThrottling_secure_sequentially
public void testEnableDisableThrottling_secure_sequentially() throws Exception
{    runEnableDisableThrottling(true, false);}
993c45a6e39ebf3a3dd6b7649ceeb315b39171cb630aa8f81e75c6ed8cdd755c
testEnableDisableThrottling_nonSecure_random
public void testEnableDisableThrottling_nonSecure_random() throws Exception
{    runEnableDisableThrottling(false, true);}
ab57665a4a848995f2f8da5adc56b26eeaa355068e64623fee43ea2daa0510dc
testEnableDisableThrottling_nonSecure_sequentially
public void testEnableDisableThrottling_nonSecure_sequentially() throws Exception
{    runEnableDisableThrottling(false, false);}
a813d78064e45279173db52ecbd7821286f8eda40e624d91fec4114f29584d8b
runEnableDisableThrottling
private void runEnableDisableThrottling(boolean secure, boolean randomDisableEnable) throws Exception
{    ClientX509Util x509Util = null;    if (secure) {        x509Util = SSLAuthTest.setUpSecure();    }    try {        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;        factory.setAdvancedFlowControlEnabled(true);        if (secure) {            factory.setSecure(true);        }        final String path = "/testEnableDisableThrottling";        try (ZooKeeper zk = createClient()) {            zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                        AtomicBoolean stopped = new AtomicBoolean(false);            Random random = new Random();            Thread enableDisableThread = null;            if (randomDisableEnable) {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                boolean shouldDisableEnable = random.nextBoolean();                                if (shouldDisableEnable) {                                    cnxn.disableRecv();                                } else {                                    cnxn.enableRecv();                                }                            }                            try {                                Thread.sleep(10);                            } catch (InterruptedException e) {                            /* ignore */                            }                        }                                                for (final ServerCnxn cnxn : serverFactory.cnxns) {                            cnxn.enableRecv();                        }                    }                };            } else {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                try {                                    cnxn.disableRecv();                                    Thread.sleep(10);                                    cnxn.enableRecv();                                    Thread.sleep(10);                                } catch (InterruptedException e) {                                /* ignore */                                }                            }                        }                    }                };            }            enableDisableThread.start();            LOG.info("started thread to enable and disable recv");                        int totalRequestsNum = 100000;            AtomicInteger successResponse = new AtomicInteger();            CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);            Thread clientThread = new Thread() {                @Override                public void run() {                    int requestIssued = 0;                    while (requestIssued++ < totalRequestsNum) {                        zk.getData(path, null, new DataCallback() {                            @Override                            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                                if (rc == 0) {                                    successResponse.addAndGet(1);                                } else {                                    LOG.info("failed response is {}", rc);                                }                                responseReceivedLatch.countDown();                            }                        }, null);                    }                }            };            clientThread.start();            LOG.info("started thread to issue {} async requests", totalRequestsNum);                        assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));            LOG.info("received all {} responses", totalRequestsNum);            stopped.set(true);            enableDisableThread.join();            LOG.info("enable and disable recv thread exited");                        LOG.info("waiting another 1s for the requests to go through");            Thread.sleep(1000);            assertEquals(successResponse.get(), totalRequestsNum);        }    } finally {        if (secure) {            SSLAuthTest.clearSecureSetting(x509Util);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            boolean shouldDisableEnable = random.nextBoolean();            if (shouldDisableEnable) {                cnxn.disableRecv();            } else {                cnxn.enableRecv();            }        }        try {            Thread.sleep(10);        } catch (InterruptedException e) {        /* ignore */        }    }        for (final ServerCnxn cnxn : serverFactory.cnxns) {        cnxn.enableRecv();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            try {                cnxn.disableRecv();                Thread.sleep(10);                cnxn.enableRecv();                Thread.sleep(10);            } catch (InterruptedException e) {            /* ignore */            }        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    int requestIssued = 0;    while (requestIssued++ < totalRequestsNum) {        zk.getData(path, null, new DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                if (rc == 0) {                    successResponse.addAndGet(1);                } else {                    LOG.info("failed response is {}", rc);                }                responseReceivedLatch.countDown();            }        }, null);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        successResponse.addAndGet(1);    } else {        LOG.info("failed response is {}", rc);    }    responseReceivedLatch.countDown();}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    listenAddress = new InetSocketAddress(PortAssignment.unique());    factory = new NIOServerCnxnFactory();    factory.configure(listenAddress, 100);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    if (factory != null) {        factory.shutdown();    }}
9be3a7b6d130568898072f3bc867e4d3ddd51c35c8d0d5f43e4ef77216cb687e
testStartupWithoutStart_SocketAlreadyBound
public void testStartupWithoutStart_SocketAlreadyBound() throws IOException
{    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
d71d4eb193236892a9c6d877d35c2ba9e95bf072081efbc0788389d74c4ef0f2
testStartupWithStart_SocketAlreadyBound
public void testStartupWithStart_SocketAlreadyBound() throws IOException
{    factory.start();    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
7b26260d08a16ba5aeec46e8b027c625ea6d4be527253a93d902bcab2aafd2a9
testShutdownWithoutStart_SocketReleased
public void testShutdownWithoutStart_SocketReleased() throws IOException
{    factory.shutdown();    factory = null;    ServerSocket ss = new ServerSocket(listenAddress.getPort());    ss.close();}
b2e636a3dc6f00422053e6d76e8a488f0191e6f70b5cf774481a0887513557aa
testOperationsAfterCnxnClose
public void testOperationsAfterCnxnClose() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    final String path = "/a";    try {                zk.create(path, "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertNotNull("Didn't create znode:" + path, zk.exists(path, false));                        assertTrue("Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!", serverFactory instanceof NIOServerCnxnFactory);        Iterable<ServerCnxn> connections = serverFactory.getConnections();        for (ServerCnxn serverCnxn : connections) {            serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);            try {                serverCnxn.toString();            } catch (Exception e) {                LOG.error("Exception while getting connection details!", e);                fail("Shouldn't throw exception while " + "getting connection details!");            }        }    } finally {        zk.close();    }}
e4dcfba66916747803679db9135c5f20b6ef8fb58e9463affb4284cdaf43c358
testClientResponseStatsUpdate
public void testClientResponseStatsUpdate() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater then zero after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    ZooKeeperServer.setDigestEnabled(true);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    ZooKeeperServer.setDigestEnabled(false);}
883eb27accb5f5ee19f0d9ea7102e39f1aa83df9478e5cf4221e249b171b9f93
testOperations
public void testOperations()
{    NodeHashMapImpl nodes = new NodeHashMapImpl(new DigestCalculator());    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p1 = "p1";    DataNode n1 = new DataNode(p1.getBytes(), 0L, new StatPersisted());    nodes.put(p1, n1);    assertEquals(n1, nodes.get(p1));    assertNotEquals(0L, nodes.getDigest());    assertEquals(1, nodes.size());        String p2 = "p2";    nodes.put(p2, new DataNode(p2.getBytes(), 0L, new StatPersisted()));    Set<Map.Entry<String, DataNode>> entries = nodes.entrySet();    assertEquals(2, entries.size());        nodes.remove(p1);    assertEquals(1, nodes.size());    nodes.remove(p2);    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p3 = "p3";    DataNode n3 = new DataNode(p3.getBytes(), 0L, new StatPersisted());    nodes.put(p3, n3);    long preChangeDigest = nodes.getDigest();    assertNotEquals(0L, preChangeDigest);    nodes.preChange(p3, n3);    assertEquals(0L, nodes.getDigest());    n3.stat.setMzxid(1);    n3.stat.setMtime(1);    n3.stat.setVersion(1);    nodes.postChange(p3, n3);    long postChangeDigest = nodes.getDigest();    assertNotEquals(0, postChangeDigest);    assertNotEquals(preChangeDigest, postChangeDigest);}
fe8c702e197f7d93447c86f23f8c1ea75fcfd495762f9b83fdf6ba9efd3aa9bf
serialize
public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{        assertTrue(snapShot.createNewFile());    throw new IOException("Created empty snapshot file from " + "MockFileSnap::serialize()");}
d5b109ea9b49a4443a58d8025c8ea28a04c61083de4fa6b6b763961ffdd2048c
testNoEmptySnapshot
public void testNoEmptySnapshot() throws Exception
{    File tmpFile = File.createTempFile("empty-snapshot-test", ".junit", new File(System.getProperty("build.test.dir", "build")));    File tmpDataDir = new File(tmpFile + ".dir");    assertFalse(tmpDataDir.exists());    assertTrue(tmpDataDir.mkdirs());    FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDataDir, tmpDataDir);    snapLog.snapLog = new MockFileSnap(snapLog.dataDir);    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    DataTree tree = new DataTree();    tree.createNode("/empty-snapshot-test-1", "data".getBytes(), null, -1, -1, 1, 1);    try {        snapLog.save(tree, new ConcurrentHashMap<>(), false);        fail("Should have thrown an IOException");    } catch (IOException e) {        }    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    snapLog.snapLog = new FileSnap(snapLog.dataDir);    snapLog.save(tree, new ConcurrentHashMap<>(), false);    assertEquals(1, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());}
3a439fff7bb59d13e7fc0b43a37d43a871ed502ae448c0ae2937c3f0fa187f6f
testInvalidPreallocSize
public void testInvalidPreallocSize()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 0));    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, -1));}
240ff1be454f5963ff90f5241706437154c13d585ce65c725bc5203500b91ae2
testCalculateFileSizeWithPaddingWhenNotToCurrentSize
public void testCalculateFileSizeWithPaddingWhenNotToCurrentSize()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(5 * KB, 10 * KB, 10 * KB));}
cce371187e0a63685880b64a65080848171f4d4aa0a23bd9c9e47bbf2257e652
testCalculateFileSizeWithPaddingWhenCloseToCurrentSize
public void testCalculateFileSizeWithPaddingWhenCloseToCurrentSize()
{    assertEquals("file should be padded an additional 10 KB", 20 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 10 * KB));}
c1ab06ba29524be974241c9d4baab01c8a6901a97d536cf39fcf7a85dd64ac99
testFileSizeGreaterThanPosition
public void testFileSizeGreaterThanPosition()
{    assertEquals("file should be padded to 40 KB", 40 * KB, FilePadding.calculateFileSizeWithPadding(31 * KB, 10 * KB, 10 * KB));}
8daadad5d02484c9be260f3361bbcd0e06e603710031b592e1412a43e57901fb
testPreAllocSizeSmallerThanTxnData
public void testPreAllocSizeSmallerThanTxnData() throws IOException
{    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);        final int preAllocSize = 500 * KB;    FilePadding.setPreallocSize(preAllocSize);            byte[] data = new byte[2 * preAllocSize];    Arrays.fill(data, (byte) 0xff);            fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData1", data, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.append(new TxnHeader(1, 1, 2, 2, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData2", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.close();        FileTxnLog.FileTxnIterator fileTxnIterator = new FileTxnLog.FileTxnIterator(logDir, 0);        CreateTxn createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), data));        fileTxnIterator.next();    createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), new byte[] {}));}
d9d88f2e2338a58289fc912616d2f737ab6a983aa0f883df99c0b111ea203b4d
testSetPreallocSize
public void testSetPreallocSize()
{    long customPreallocSize = 10101;    FileTxnLog.setPreallocSize(customPreallocSize);    assertThat(FilePadding.getPreAllocSize(), is(equalTo(customPreallocSize)));}
401447d74c30cad08ba87b5c74c11bccff9061d5753ddb39a4b45b228d137306
testSyncThresholdExceedCount
public void testSyncThresholdExceedCount() throws IOException
{            java.lang.System.setProperty(FileTxnLog.ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY, "-1");    ServerStats.Provider providerMock = mock(ServerStats.Provider.class);    ServerStats serverStats = new ServerStats(providerMock);    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);    fileTxnLog.setServerStats(serverStats);        assertEquals(0L, serverStats.getFsyncThresholdExceedCount());        for (int i = 0; i < 50; i++) {        fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testFsyncThresholdCountIncreased", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));                fileTxnLog.commit();                assertEquals((long) i + 1, serverStats.getFsyncThresholdExceedCount());    }}
921850f5e96ea02ed38f8e982e89ad5bc73b193b5188bbc7ffa9678f7264e3ab
testGetCurrentLogSize
public void testGetCurrentLogSize() throws Exception
{    FileTxnLog.setTxnLogSizeLimit(-1);    File tmpDir = ClientBase.createTmpDir();    FileTxnLog log = new FileTxnLog(tmpDir);    FileTxnLog.setPreallocSize(PREALLOCATE);    CreateRequest record = new CreateRequest(null, new byte[NODE_SIZE], ZooDefs.Ids.OPEN_ACL_UNSAFE, 0);    int zxid = 1;    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);        LOG.debug("Current log size: " + log.getCurrentLogSize());    }    log.commit();    LOG.info("Current log size: " + log.getCurrentLogSize());    assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);        LOG.debug("Current log size: " + log.getCurrentLogSize());    }    log.commit();    LOG.info("Current log size: " + log.getCurrentLogSize());    assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);}
dae8cc7685537eec625529f5a15a732be969f5b7b04a76622be12d07b78614d5
testLogSizeLimit
public void testLogSizeLimit() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();                FileTxnLog.setPreallocSize(PREALLOCATE);    FileTxnLog.setTxnLogSizeLimit(LOG_SIZE_LIMIT);    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        HashSet<Long> zxids = new HashSet<>();    byte[] bytes = new byte[NODE_SIZE];    Random random = new Random();    random.nextBytes(bytes);        long txnCount = LOG_SIZE_LIMIT / NODE_SIZE / 2 * 5;    LOG.info("Creating " + txnCount + " txns");    try {        for (long i = 0; i < txnCount; i++) {            Stat stat = new Stat();            zk.create("/node-" + i, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/node-" + i, null, stat);            zxids.add(stat.getCzxid());        }    } finally {        zk.close();    }        f.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] txnLogs = FileTxnLog.getLogFiles(logDir.listFiles(), 0);    assertEquals("Unexpected number of logs", 3, txnLogs.length);        long threshold = LOG_SIZE_LIMIT + NODE_SIZE;    LOG.info(txnLogs[0].getAbsolutePath());    assertTrue("Exceed log size limit: " + txnLogs[0].length(), threshold > txnLogs[0].length());    LOG.info(txnLogs[1].getAbsolutePath());    assertTrue("Exceed log size limit " + txnLogs[1].length(), threshold > txnLogs[1].length());        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();    for (long i = 0; i < txnCount; i++) {        Stat stat = new Stat();        byte[] data = db.getData("/node-" + i, stat, null);        assertArrayEquals("Missmatch data", bytes, data);        assertTrue("Unknown zxid ", zxids.contains(stat.getMzxid()));    }}
33ef80059d7e7a7518d8573f1a5b03b2c696de96c32f61b1b2b1e2ffdcd0b9cd
process
public void process(WatchedEvent e)
{    LOG.info("all nodes created");    allCreatedLatch.countDown();}
f55e8107d97ea755bfc0c5a0546297a0020280545fd9738cefe64ae7da3742d2
testFileTxnSnapLogMetrics
public void testFileTxnSnapLogMetrics() throws Exception
{    SyncRequestProcessor.setSnapCount(100);    QuorumUtil util = new QuorumUtil(1);    util.startAll();    allCreatedLatch = new CountDownLatch(1);    byte[] data = new byte[500];        ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    for (int i = 0; i < 150; i++) {        zk.create("/path" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    if (null == zk.exists("/path149", new MockWatcher())) {        allCreatedLatch.await();    }    ServerMetrics.getMetrics().resetAll();    int leader = util.getLeaderServer();        util.shutdown(leader);    util.start(leader);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    LOG.info("txn loaded during start up {}", values.get("max_startup_txns_loaded"));    assertEquals(1L, values.get("cnt_startup_txns_loaded"));    assertThat((long) values.get("max_startup_txns_loaded"), greaterThan(0L));    assertEquals(1L, values.get("cnt_startup_txns_load_time"));    assertThat((long) values.get("max_startup_txns_load_time"), greaterThanOrEqualTo(0L));    assertEquals(1L, values.get("cnt_startup_snap_load_time"));    assertThat((long) values.get("max_startup_snap_load_time"), greaterThan(0L));    util.shutdownAll();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    tmpDir = ClientBase.createEmptyTestDir();    logDir = new File(tmpDir, "logdir");    snapDir = new File(tmpDir, "snapdir");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (tmpDir != null) {        TestUtils.deleteFileRecursively(tmpDir);    }    this.tmpDir = null;    this.logDir = null;    this.snapDir = null;    this.logVersionDir = null;    this.snapVersionDir = null;}
fe884aa3e688e6159c60454f2b99e61b2f767d4d54cfbeb9d8fbf13172e0277a
createVersionDir
private File createVersionDir(File parentDir)
{    File versionDir = new File(parentDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    versionDir.mkdirs();    return versionDir;}
6437585eac62c909dbec40b8426b7b99ac245db2ef979886c977dffe19716af0
createLogFile
private void createLogFile(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeLogName(zxid));    file.createNewFile();}
2de6a40b8f6ef81775292a89d5ad166e6aa24518d2c57386286851eb54ec8947
createSnapshotFile
private void createSnapshotFile(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeSnapshotName(zxid));    file.createNewFile();}
d9ad269c111e4dc9e6b1fcff87ed89cea0543bc7260e6f411b63b761cae3c26f
twoDirSetupWithCorrectFiles
private void twoDirSetupWithCorrectFiles() throws IOException
{    logVersionDir = createVersionDir(logDir);    snapVersionDir = createVersionDir(snapDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);        createSnapshotFile(snapVersionDir, 1);    createSnapshotFile(snapVersionDir, 2);}
584d81b2268abffdeb2a488fccc60af772c05b43daf79e1d3d5b2daf45aab29a
singleDirSetupWithCorrectFiles
private void singleDirSetupWithCorrectFiles() throws IOException
{    logVersionDir = createVersionDir(logDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);    createSnapshotFile(logVersionDir, 1);    createSnapshotFile(logVersionDir, 2);}
8aae0aece2d0d98bdb18260c9ec0c926f632efa07d4b534516b21a8552cb59b2
createFileTxnSnapLogWithNoAutoCreateDataDir
private FileTxnSnapLog createFileTxnSnapLogWithNoAutoCreateDataDir(File logDir, File snapDir) throws IOException
{    return createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");}
5c67dd813fa9906d5460ecff5f5d00839b8d2928cee11d9293cf9e3f099bea05
createFileTxnSnapLogWithAutoCreateDataDir
private FileTxnSnapLog createFileTxnSnapLogWithAutoCreateDataDir(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDirValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, priorAutocreateDirValue);        }    }    return fileTxnSnapLog;}
26a21fa0670be248d2eef6edbbaf18a07161a84f724bda46e1792691dab2c007
createFileTxnSnapLogWithAutoCreateDB
private FileTxnSnapLog createFileTxnSnapLogWithAutoCreateDB(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDBValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDBValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, priorAutocreateDBValue);        }    }    return fileTxnSnapLog;}
abde67569249d9cf47eb67cc375cd80722c5b81df6590ee0a513277926960116
testWithAutoCreateDataDir
public void testWithAutoCreateDataDir() throws IOException
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    assertTrue(logDir.exists());    assertTrue(snapDir.exists());    assertTrue(fileTxnSnapLog.getDataDir().exists());    assertTrue(fileTxnSnapLog.getSnapDir().exists());}
5115f1fe96b39bac078ebab1fc384af7429983b407834aa933cf6e1b09941fcf
testWithoutAutoCreateDataDir
public void testWithoutAutoCreateDataDir() throws Exception
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    try {        createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");    } catch (FileTxnSnapLog.DatadirException e) {        assertFalse(logDir.exists());        assertFalse(snapDir.exists());                throw e;    }    fail("Expected exception from FileTxnSnapLog");}
a23ed16195544bf8622927eb9d0d0fed6be2d2bbedb2a84a138cc17f343cb673
attemptAutoCreateDB
private void attemptAutoCreateDB(File dataDir, File snapDir, Map<Long, Integer> sessions, String autoCreateValue, long expectedValue) throws IOException
{    sessions.clear();    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDB(dataDir, snapDir, autoCreateValue);    long zxid = fileTxnSnapLog.restore(new DataTree(), sessions, new FileTxnSnapLog.PlayBackListener() {        @Override        public void onTxnLoaded(TxnHeader hdr, Record rec) {                }    });    assertEquals("unexpected zxid", expectedValue, zxid);}
71c5fcc644d3705f477a105f42e46593b88eb6c4c92da11d24c0df2c0b168495
onTxnLoaded
public void onTxnLoaded(TxnHeader hdr, Record rec)
{}
0600b144bc2a8f0afabe386db6dd3b54c5740344d5b6c2499c85b8bb48fdc837
testAutoCreateDB
public void testAutoCreateDB() throws IOException
{    assertTrue("cannot create log directory", logDir.mkdir());    assertTrue("cannot create snapshot directory", snapDir.mkdir());    File initFile = new File(logDir, "initialize");    assertFalse("initialize file already exists", initFile.exists());    Map<Long, Integer> sessions = new ConcurrentHashMap<>();    attemptAutoCreateDB(logDir, snapDir, sessions, "false", -1L);    attemptAutoCreateDB(logDir, snapDir, sessions, "true", 0L);    assertTrue("cannot create initialize file", initFile.createNewFile());    attemptAutoCreateDB(logDir, snapDir, sessions, "false", 0L);}
0d765b0c2d3d141f07c3434f07eef0fb096c6381605e200f792cfe88bdc72ec0
testGetTxnLogSyncElapsedTime
public void testGetTxnLogSyncElapsedTime() throws IOException
{    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        fileTxnSnapLog.append(req);        fileTxnSnapLog.commit();        long syncElapsedTime = fileTxnSnapLog.getTxnLogElapsedSyncTime();        assertNotEquals("Did not update syncElapsedTime!", -1L, syncElapsedTime);    } finally {        fileTxnSnapLog.close();    }}
956fbcecb2106dab30c52c21580f526e242e8439cc9b31a20fdfff1d63025ad8
testDirCheckWithCorrectFiles
public void testDirCheckWithCorrectFiles() throws IOException
{    twoDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
be3e04a3edcb605126f9d87c1a4933b1be4f84b675a04b7d529a711dbcb8454e
testDirCheckWithSingleDirSetup
public void testDirCheckWithSingleDirSetup() throws IOException
{    singleDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, logDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
391639a3283f23c0a3fd2d65f64ea065d4a3d0711d7fdedb64402878e2ad3c81
testDirCheckWithSnapFilesInLogDir
public void testDirCheckWithSnapFilesInLogDir() throws IOException
{    twoDirSetupWithCorrectFiles();        createSnapshotFile(logVersionDir, 3);    createSnapshotFile(logVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
1723ca76c64e0c462e604c2637d9b98be142f09fa6f616ee7eb177c1c6cf4000
testDirCheckWithLogFilesInSnapDir
public void testDirCheckWithLogFilesInSnapDir() throws IOException
{    twoDirSetupWithCorrectFiles();        createLogFile(snapVersionDir, 3);    createLogFile(snapVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
e9554b1cdf258736d8bf0660816a3b8477d91ad2519d41a32e7dd4bb3aa1fbf5
testACLCreatedDuringFuzzySnapshotSync
public void testACLCreatedDuringFuzzySnapshotSync() throws IOException
{    DataTree leaderDataTree = new DataTree();        File file = File.createTempFile("snapshot", "zk");    FileOutputStream os = new FileOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    leaderDataTree.serializeAcls(oa);        TxnHeader hdr1 = new TxnHeader(1, 2, 2, 2, ZooDefs.OpCode.create);    Record txn1 = new CreateTxn("/a1", "foo".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, false, -1);    leaderDataTree.processTxn(hdr1, txn1);        leaderDataTree.serializeNodes(oa);    os.close();        FileInputStream is = new FileInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    DataTree followerDataTree = new DataTree();    followerDataTree.deserialize(ia, "tree");    followerDataTree.processTxn(hdr1, txn1);    DataNode a1 = leaderDataTree.getNode("/a1");    assertNotNull(a1);    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, leaderDataTree.getACL(a1));    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, followerDataTree.getACL(a1));}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    System.clearProperty(SnapStream.ZOOKEEPER_SHAPSHOT_STREAM_MODE);    SnapStream.setStreamMode(StreamMode.DEFAULT_MODE);}
336ab420c1d1323c02fd8b9b64ef7715e69150a49899bbc650fb25ef1d8bd9eb
testStreamMode
public void testStreamMode()
{    assertEquals(StreamMode.CHECKED.getName(), "");    assertEquals(StreamMode.CHECKED.getFileExtension(), "");    assertEquals(StreamMode.CHECKED, StreamMode.fromString("name"));    assertEquals(StreamMode.GZIP.getName(), "gz");    assertEquals(StreamMode.GZIP.getFileExtension(), ".gz");    assertEquals(StreamMode.GZIP, StreamMode.fromString("gz"));    assertEquals(StreamMode.SNAPPY.getName(), "snappy");    assertEquals(StreamMode.SNAPPY.getFileExtension(), ".snappy");    assertEquals(StreamMode.SNAPPY, StreamMode.fromString("snappy"));}
7ad35d4d0f05c70b12e1606236fdf80ebd045e0149ed04a210a21ec9710877b3
testGetStreamMode
public void testGetStreamMode()
{    assertEquals("expected to return un-compressed stream", StreamMode.CHECKED, SnapStream.getStreamMode("snapshot.180000e3a2"));    assertEquals("expected to return snappy stream", StreamMode.SNAPPY, SnapStream.getStreamMode("snapshot.180000e3a2.snappy"));    assertEquals("expected to return gzip stream", StreamMode.GZIP, SnapStream.getStreamMode("snapshot.180000e3a2.gz"));}
7beb82b0bf484d443a145fd6ebaf821c2f09669f90f00740a5dcfe274a80287e
testSerializeDeserializeWithChecked
public void testSerializeDeserializeWithChecked() throws IOException
{    testSerializeDeserialize(StreamMode.CHECKED, "");}
3f180f2b97877a10148a08f7841f9ce1f87f8d5893a0e5076db6924a8bd2b02d
testSerializeDeserializeWithSNAPPY
public void testSerializeDeserializeWithSNAPPY() throws IOException
{    testSerializeDeserialize(StreamMode.SNAPPY, ".snappy");}
a471ab8135ed1ba12f00d25b8409cfcb37b2f1596fc714f04be7ec283eb7b57a
testSerializeDeserializeWithGZIP
public void testSerializeDeserializeWithGZIP() throws IOException
{    testSerializeDeserialize(StreamMode.GZIP, ".gz");}
7689951d05ff9a4ebac6e4f28a881b9b32b2b2fd9a78e7868f6466bd219cd648
testSerializeDeserialize
private void testSerializeDeserialize(StreamMode mode, String fileSuffix) throws IOException
{    SnapStream.setStreamMode(mode);        File tmpDir = createTmpDir();    File file = new File(tmpDir, "snapshot.180000e3a2" + fileSuffix);    CheckedOutputStream os = SnapStream.getOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    FileHeader header = new FileHeader(FileSnap.SNAP_MAGIC, 2, 1);    header.serialize(oa, "fileheader");    SnapStream.sealStream(os, oa);    os.flush();    os.close();    assertTrue(SnapStream.isValidSnapshot(file));        CheckedInputStream is = SnapStream.getInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    FileHeader restoredHeader = new FileHeader();    restoredHeader.deserialize(ia, "fileheader");    assertEquals("magic not the same", restoredHeader, header);    SnapStream.checkSealIntegrity(is, ia);}
b341385ea906da893fcfd9eb03e8e24b8f6e66a79a0e635f1eb761d3fb987962
checkInvalidSnapshot
private void checkInvalidSnapshot(String filename) throws IOException
{        SnapStream.setStreamMode(StreamMode.CHECKED);        File tmpDir = createTmpDir();    File file = new File(tmpDir, filename);    OutputStream os = SnapStream.getOutputStream(file);    os.write(1);    os.flush();    os.close();    assertFalse(SnapStream.isValidSnapshot(file));}
8f6284443e936e9484c97cc4b05315a827c07740e642ef7fd24b90ff1acc0662
testInvalidSnapshot
public void testInvalidSnapshot() throws IOException
{    assertFalse(SnapStream.isValidSnapshot(null));    checkInvalidSnapshot("snapshot.180000e3a2");    checkInvalidSnapshot("snapshot.180000e3a2.gz");    checkInvalidSnapshot("snapshot.180000e3a2.snappy");}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    System.setOut(new PrintStream(outContent));    System.setErr(new PrintStream(errContent));    File snapDir = new File(testData, "invalidsnap");    mySnapDir = ClientBase.createTmpDir();    FileUtils.copyDirectory(snapDir, mySnapDir);}
b15ec24534831cd8187de4c70ba4518879af91358fd307c4f306a42afcccad2c
tearDown
public void tearDown() throws IOException
{    System.setOut(System.out);    System.setErr(System.err);    mySnapDir.setWritable(true);    FileUtils.deleteDirectory(mySnapDir);}
a681fcddad5da8d8bd6952938fab957c0417687dd272c76460a1cec339b141b7
testDumpMode
public void testDumpMode() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);}
fe04a7fb16f35f1dffc5087024ed1a1ccc56f9267d2abb26d3cc367792e6a84b
testInitMissingFile
public void testInitMissingFile() throws FileNotFoundException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File("this_file_should_not_exists");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);}
914b774946d37612722b17ad7fc09600c2184a7360c9138b0873072a002c4d59
testInitWithRecoveryFileExists
public void testInitWithRecoveryFileExists() throws IOException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    File recoveryFile = new File(new File(mySnapDir, "version-2"), "log.274.fixed");    recoveryFile.createNewFile();    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);}
80882414c962c2476965c68be6e6a21b95e786055e02ddd2ca00a47026d1d7f5
testDumpWithCrcError
public void testDumpWithCrcError() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    Pattern p = Pattern.compile("^CRC ERROR.*session 0x8061fac5ddeb0000 cxid 0x0 zxid 0x8800000002 createSession 30000$", Pattern.MULTILINE);    Matcher m = p.matcher(output);    assertTrue("Output doesn't indicate CRC error for the broken session id: " + output, m.find());}
b96cf68289d7bea4113b2c3d7472cebe4be3828d0483a6ae8f5a1b5fe29eefdc
testRecoveryFixBrokenFile
public void testRecoveryFixBrokenFile() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    assertThat(output, containsString("CRC FIXED"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
5b82b138117e2f9c2618ce0e4523ac5fbcffe799956c5909ee09344fc3fe1d54
testRecoveryInteractiveMode
public void testRecoveryInteractiveMode() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), false);        lt.dump(new Scanner("y\n"));        String output = outContent.toString();    assertThat(output, containsString("CRC ERROR"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty(ZooKeeperServer.SKIP_ACL, "true");    zks = spy(new ZooKeeperServer());    zks.sessionTracker = mock(SessionTracker.class);    ZKDatabase db = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(db);    DataNode node = new DataNode(new byte[1], null, mock(StatPersisted.class));    when(db.getNode(anyString())).thenReturn(node);    Set<String> ephemerals = new HashSet<>();    ephemerals.add("/crystalmountain");    ephemerals.add("/stevenspass");    when(db.getEphemerals(anyLong())).thenReturn(ephemerals);    nextProcessor = mock(RequestProcessor.class);    ServerMetrics.getMetrics().resetAll();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(ZooKeeperServer.SKIP_ACL);}
0f987ec7c347db0f26fde3d3d2bf6789fe6d61de616d2b4cb0598d91cec8ef79
createRequest
private Request createRequest(Record record, int opCode) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();    return new Request(null, 1L, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), null);}
a0560a59f9f936a8c3c467a5f24031c0d0f2dae0a57e6926ba8f4477033e6ebd
createRequest
private Request createRequest(String path, int opCode) throws IOException
{    Record record;    switch(opCode) {        case ZooDefs.OpCode.setData:            record = new SetDataRequest(path, new byte[0], -1);            break;        case ZooDefs.OpCode.delete:            record = new DeleteRequest(path, -1);            break;        default:            record = new DeleteRequest(path, -1);            break;    }    return createRequest(record, opCode);}
cf48167502ccfe120c708138680f237e97d1967e98230700dac70bda158681ed
createRequest
private Request createRequest(long sessionId, int opCode)
{    return new Request(null, sessionId, 0, opCode, null, null);}
6aecbe161f54a9b0b6073cade34147bf02efb571637f79b9957acc07cf6ee005
testPrepRequestProcessorMetrics
public void testPrepRequestProcessorMetrics() throws Exception
{    CountDownLatch threeRequests = new CountDownLatch(3);    doAnswer(invocationOnMock -> {        threeRequests.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));    PrepRequestProcessor prepRequestProcessor = new PrepRequestProcessor(zks, nextProcessor);        prepRequestProcessor.processRequest(createRequest("/foo", ZooDefs.OpCode.setData));        prepRequestProcessor.processRequest(createRequest("/foo/bar", ZooDefs.OpCode.delete));        prepRequestProcessor.processRequest(createRequest(2, ZooDefs.OpCode.closeSession));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("prep_processor_request_queued"));        Thread.sleep(20);    prepRequestProcessor.start();    threeRequests.await(500, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_prep_processor_queue_size"));    assertThat((long) values.get("min_prep_processor_queue_time_ms"), greaterThan(20L));    assertEquals(3L, values.get("cnt_prep_processor_queue_time_ms"));    assertEquals(3L, values.get("cnt_prep_process_time"));    assertThat((long) values.get("max_prep_process_time"), greaterThan(0L));    assertEquals(1L, values.get("cnt_close_session_prep_time"));    assertThat((long) values.get("max_close_session_prep_time"), greaterThanOrEqualTo(0L));    assertEquals(5L, values.get("outstanding_changes_queued"));}
33ef80059d7e7a7518d8573f1a5b03b2c696de96c32f61b1b2b1e2ffdcd0b9cd
process
public void process(WatchedEvent e)
{    created.countDown();}
084c194d2212b2ea663d5ecebd84276652d9f86fa7fa562888224b14902bcea8
testOutstandingChangesRemoved
public void testOutstandingChangesRemoved() throws Exception
{        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ServerMetrics.getMetrics().resetAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    zk.create("/test", new byte[50], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    CountDownLatch created = new CountDownLatch(1);    zk.exists("/test", new SimpleWatcher(created));    created.await(200, TimeUnit.MILLISECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat((long) values.get("outstanding_changes_removed"), greaterThan(0L));    util.shutdownAll();}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    servcnxnf.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    zks.sessionTracker = new MySessionTracker();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }}
0540c1f58bda61a7d98ba239ef50610b079cc19b3f993f3af867822280b33404
testPRequest
public void testPRequest() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Request foo = new Request(null, 1L, 1, OpCode.create, ByteBuffer.allocate(3), null);    processor.pRequest(foo);    assertEquals("Request should have marshalling error", new ErrorTxn(KeeperException.Code.MARSHALLINGERROR.intValue()), outcome.getTxn());    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
0f987ec7c347db0f26fde3d3d2bf6789fe6d61de616d2b4cb0598d91cec8ef79
createRequest
private Request createRequest(Record record, int opCode) throws IOException
{    return createRequest(record, opCode, 1L);}
95f525f70af4ac67763e1eb437541d7f80f46b892ce2ac0724e2fe6ff61322c4
createRequest
private Request createRequest(Record record, int opCode, long sessionId) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();        List<Id> ids = Arrays.asList(Ids.ANYONE_ID_UNSAFE);    return new Request(null, sessionId, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), ids);}
61c9137ce1d6e6783dfcfcf8343a9224b518782a2a9b990f193dd09a5114f9b1
process
private void process(List<Op> ops) throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Record record = new MultiOperationRecord(ops);    Request req = createRequest(record, OpCode.multi);    processor.pRequest(req);    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
9d2066d193646f26854f947ba57f9c9e434427e799366b1874529c357e03c7fa
testMultiOutstandingChange
public void testMultiOutstandingChange() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));    process(Arrays.asList(Op.setData("/foo", new byte[0], -1)));    ChangeRecord cr = zks.outstandingChangesForPath.get("/foo");    assertNotNull("Change record wasn't set", cr);    assertEquals("Record zxid wasn't set correctly", 1, cr.zxid);    process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");    assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);        process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");        assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);}
9d88c9697d2d5511ed4928f29b0ebce9c73f6c8dba33684c485cf9f69beed1d5
testMultiRollbackNoLastChange
public void testMultiRollbackNoLastChange() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    zks.getZKDatabase().dataTree.createNode("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));                process(Arrays.asList(Op.setData("/foo", new byte[0], -1), Op.delete("/foo", -1)));        assertNull(zks.outstandingChangesForPath.get("/foo"));}
15311f3ee523b02237886502bea59614aaec2900d3f23e7aedb9d9b594ad2926
testCloseSessionTxn
public void testCloseSessionTxn() throws Exception
{    boolean before = ZooKeeperServer.isCloseSessionTxnEnabled();    ZooKeeperServer.setCloseSessionTxnEnabled(true);    try {                long ephemeralOwner = 1;        DataTree dt = zks.getZKDatabase().dataTree;        dt.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);        dt.createNode("/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);                RequestHeader header = new RequestHeader();        header.setType(OpCode.closeSession);        final FinalRequestProcessor frq = new FinalRequestProcessor(zks);        final CountDownLatch latch = new CountDownLatch(1);        processor = new PrepRequestProcessor(zks, new RequestProcessor() {            @Override            public void processRequest(Request request) {                frq.processRequest(request);                latch.countDown();            }            @Override            public void shutdown() {                        }        });        processor.pRequest(createRequest(header, OpCode.closeSession, ephemeralOwner));        assertTrue(latch.await(3, TimeUnit.SECONDS));                assertEquals(null, dt.getNode("/foo"));        assertEquals(null, dt.getNode("/bar"));    } finally {        ZooKeeperServer.setCloseSessionTxnEnabled(before);    }}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    frq.processRequest(request);    latch.countDown();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
778500633553cbb243e72737202ca9753665e95b6724d832790018e1336d62c7
testInvalidPath
public void testInvalidPath() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    SetDataRequest record = new SetDataRequest("", new byte[0], -1);    Request req = createRequest(record, OpCode.setData);    processor.pRequest(req);    pLatch.await();    assertEquals(outcome.getHdr().getType(), OpCode.error);    assertEquals(outcome.getException().code(), KeeperException.Code.BADARGUMENTS);}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{        outcome = request;    pLatch.countDown();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
ecf00caa00ca94c02425f977575a227d39a564fa35f3c0b44829ac7f62090e13
trackSession
public boolean trackSession(long id, int to)
{        return false;}
9bf2a2bac1cba8a987fc7c73364b879f0313d3fe6530074a4560ffa95365ba47
commitSession
public boolean commitSession(long id, int to)
{        return false;}
3731d03709a6efad73b79adc0407f37edbbe529903884633ff018141c9c77841
checkSession
public void checkSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
26a20a147958953e3c25a582180e937ad56ac181b2ec844d0de659c5027d7c8a
createSession
public long createSession(int sessionTimeout)
{        return 0;}
059bdb7fdfcd8a7cc5ac1afcbadf7c985185ac6be02df299e669a9effa7195ce
dumpSessions
public void dumpSessions(PrintWriter pwriter)
{}
6055190cbe55525602a491409aa248706ec1074de2c17a49b4594a9de615633e
removeSession
public void removeSession(long sessionId)
{}
ee39b918928f75ab701501f39ce8ea2815dc1a967b02e484cb9643c474e07e9f
upgradeSession
public int upgradeSession(long sessionId)
{        return 0;}
61aae510438cc5b982944248a3c671fdb5dd74bc403f25cd8a0753973b461d9d
setOwner
public void setOwner(long id, Object owner) throws SessionExpiredException
{}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
7e5a4e6298052c4653ec1b80ed2336b41d598fd29f3e851ef1b7c09116eecf28
touchSession
public boolean touchSession(long sessionId, int sessionTimeout)
{        return false;}
1183d8f3ef078b53b34ad1087fd0509544c0642f748a8d1e078c40dad3e6e92b
setSessionClosing
public void setSessionClosing(long sessionId)
{}
b73bf7e716f61557372d976521bc74ae2335362f0749028510f86154f816787c
isTrackingSession
public boolean isTrackingSession(long sessionId)
{        return false;}
cb073a7fdc6bdfbc54fe1d4b8a18afb6f4becf4998e9c934ff8df4077de87ae9
checkGlobalSession
public void checkGlobalSession(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
3af14c5b72bdfc3edf46603772a1f71ddd60055b7766802e1ca02228886adc63
getSessionExpiryMap
public Map<Long, Set<Long>> getSessionExpiryMap()
{    return new HashMap<Long, Set<Long>>();}
a4ad0e6cfe447eb5c45c50b13ef0390e9b8a8491f5fcba889908b4f506465171
getLocalSessionCount
public long getLocalSessionCount()
{    return 0;}
3b7c1330fc3efc999615334279ed2539d3495c17199f15a2cd557ca4c775c546
isLocalSessionsEnabled
public boolean isLocalSessionsEnabled()
{    return false;}
ec8b6259c87a96a7e78ab8ec13a826f2caf0d2a1c593d4aec011e181f3e17bbf
teardown
public void teardown()
{    if (null != tmpDir) {        ClientBase.recursiveDelete(tmpDir);    }}
eab78ce3e822affa54602c41f633469e8c8e5a4e78b38d8dddd9023c53a4c45a
testPurge
public void testPurge() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.getTxnLogFactory().close();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> listLogs = snaplog.findNRecentSnapshots(4);    int numSnaps = 0;    for (File ff : listLogs) {        if (ff.getName().startsWith("snapshot")) {            numSnaps++;        }    }    assertTrue("exactly 3 snapshots ", (numSnaps == 3));    snaplog.close();    zks.shutdown();}
f0152d704ca519af32eac7adcd10932694622a390cafe298b827dfc073734f60
testPurgeWhenLogRollingInProgress
public void testPurgeWhenLogRollingInProgress() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(30);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    final ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    final CountDownLatch doPurge = new CountDownLatch(1);    final CountDownLatch purgeFinished = new CountDownLatch(1);    final AtomicBoolean opFailed = new AtomicBoolean(false);    new Thread() {        public void run() {            try {                doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);                PurgeTxnLog.purge(tmpDir, tmpDir, 3);            } catch (IOException ioe) {                LOG.error("Exception when purge", ioe);                opFailed.set(true);            } catch (InterruptedException ie) {                LOG.error("Exception when purge", ie);                opFailed.set(true);            } finally {                purgeFinished.countDown();            }        }    }.start();    final int thCount = 3;    List<String> znodes = manyClientOps(zk, doPurge, thCount, "/invalidsnap");    assertTrue("Purging is not finished!", purgeFinished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    assertFalse("Purging failed!", opFailed.get());    for (String znode : znodes) {        try {            zk.getData(znode, false, null);        } catch (Exception ke) {            LOG.error("Unexpected exception when visiting znode!", ke);            fail("Unexpected exception when visiting znode!");        }    }    zk.close();    f.shutdown();    zks.shutdown();    zks.getTxnLogFactory().close();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    } catch (IOException ioe) {        LOG.error("Exception when purge", ioe);        opFailed.set(true);    } catch (InterruptedException ie) {        LOG.error("Exception when purge", ie);        opFailed.set(true);    } finally {        purgeFinished.countDown();    }}
bf7603e1ac719463d90ae203b23aa0c789299031d93c05c15405377f3343d2a0
testFindNRecentSnapshots
public void testFindNRecentSnapshots() throws Exception
{        int nRecentSnap = 4;    int nRecentCount = 30;    int offset = 0;    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());        FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> foundSnaps = txnLog.findNRecentSnapshots(1);    assertEquals(0, foundSnaps.size());    List<File> expectedNRecentSnapFiles = new ArrayList<File>();    int counter = offset + (2 * nRecentCount);    for (int i = 0; i < nRecentCount; i++) {                File logFile = new File(version2 + "/log." + Long.toHexString(--counter));        assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());                File snapFile = new File(version2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());                if (i < nRecentSnap) {            expectedNRecentSnapFiles.add(snapFile);        }    }            List<File> nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentSnap);    assertEquals("exactly 4 snapshots ", 4, nRecentSnapFiles.size());    expectedNRecentSnapFiles.removeAll(nRecentSnapFiles);    assertEquals("Didn't get the recent snap files", 0, expectedNRecentSnapFiles.size());            nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentCount + 5);    assertEquals(nRecentCount, nRecentSnapFiles.size());    for (File f : nRecentSnapFiles) {        assertTrue("findNRecentSnapshots() returned a non-snapshot: " + f.getPath(), (Util.getZxidFromName(f.getName(), "snapshot") != -1));    }    txnLog.close();}
9c35fbde5acaba2d0be6584c7177766af974ef60ac82600202fc35d8ba18e20f
testSnapFilesGreaterThanToRetain
public void testSnapFilesGreaterThanToRetain() throws Exception
{    int nRecentCount = 4;    int fileAboveRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    List<File> snapsAboveRecentFiles = new ArrayList<File>();    List<File> logsAboveRecentFiles = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    createDataDirFiles(offset, fileAboveRecentCount, false, version2, snapsAboveRecentFiles, logsAboveRecentFiles);    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);    verifyFilesAfterPurge(snapsAboveRecentFiles, true);    verifyFilesAfterPurge(logsAboveRecentFiles, true);}
ee11cb27c4db2f20a096deb50ffd8502a0e4111b50fd00c6d9d4f70d0576b7bd
testSnapFilesEqualsToRetain
public void testSnapFilesEqualsToRetain() throws Exception
{    internalTestSnapFilesEqualsToRetain(false);}
3bcf6e0590d2eab16a8ae7e04e3dbf05dabc94e7d069fabde339d2e083b5cd13
testSnapFilesEqualsToRetainWithPrecedingLog
public void testSnapFilesEqualsToRetainWithPrecedingLog() throws Exception
{    internalTestSnapFilesEqualsToRetain(true);}
414cfa31e38b0f03d10ffffd7dfdcb606b7a0882d227fb1220b182bac5074123
internalTestSnapFilesEqualsToRetain
public void internalTestSnapFilesEqualsToRetain(boolean testWithPrecedingLogFile) throws Exception
{    int nRecentCount = 3;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, nRecentCount, testWithPrecedingLogFile, version2, snaps, logs);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
789fc1139d651a526cf3562df13186b5173fb2115f44b0126f6f224d49647742
testSnapFilesLessThanToRetain
public void testSnapFilesLessThanToRetain() throws Exception
{    int nRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
98834b3a62f6c427d5b80600fafea5c679f69cdd9314e911f6b8f5eac498660d
testPurgeTxnLogWithDataDir
public void testPurgeTxnLogWithDataDir() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), dataDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep, dataDirVersion2.listFiles().length);        assertEquals(numberOfSnapFilesToKeep, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
d7876aa53a46dd96e098e771bf023d3bc4c64e449882510f0262b8a625c1c87d
testPurgeTxnLogWithoutDataDir
public void testPurgeTxnLogWithoutDataDir() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataLogDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep *     2, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
9af7cd25071e5140642d94ab872e64eefc11c0321a3f5e653274545f79bf186b
testPurgeDoesNotDeleteOverlappingLogFile
public void testPurgeDoesNotDeleteOverlappingLogFile() throws Exception
{        final int SNAP_RETAIN_COUNT = 3;        final int NUM_ZNODES_PER_SNAPSHOT = 100;    /**     * Set a sufficiently high snapCount to ensure that we don't rollover the log.  Normally,     * the default value (100K at time of this writing) would ensure this, but we make that     * dependence explicit here to make the test future-proof.  Not rolling over the log is     * important for this test since we are testing retention of the one and only log file which     * predates each retained snapshot.     */    SyncRequestProcessor.setSnapCount(SNAP_RETAIN_COUNT * NUM_ZNODES_PER_SNAPSHOT * 10);        tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        int unique = 0;    try {        /**         * Create some znodes and take a snapshot.  Repeat this until we have SNAP_RETAIN_COUNT         * snapshots.  Do not rollover the log.         */        for (int snapshotCount = 0; snapshotCount < SNAP_RETAIN_COUNT; snapshotCount++) {            for (int i = 0; i < 100; i++, unique++) {                zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            }            zks.takeSnapshot();        }                for (int i = 0; i < 100; i++, unique++) {            zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, SNAP_RETAIN_COUNT);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    zk = ClientBase.createZKClient(HOSTPORT);    /**     * Verify that the last znode that was created above exists.  This znode's creation was     * captured by the transaction log which was created before any of the above     * SNAP_RETAIN_COUNT snapshots were created, but it's not captured in any of these     * snapshots.  So for it it exist, the (only) existing log file should not have been purged.     */    final String lastZnode = "/snap-" + (unique - 1);    final Stat stat = zk.exists(lastZnode, false);    assertNotNull("Last znode does not exist: " + lastZnode, stat);        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();}
45dd54eb2f33792fdc133c85acb51f01847d9cb2d5df2cb2825ef50f979b95ac
createDataDirLogFile
private File createDataDirLogFile(File version_2, int Zxid) throws IOException
{    File logFile = new File(version_2 + "/log." + Long.toHexString(Zxid));    assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());    return logFile;}
ef3b6af4f1dd82df2b36f59f41ed8eb85c8b84dc8d2870b64f75eb585426279d
createDataDirFiles
private void createDataDirFiles(AtomicInteger offset, int limit, boolean createPrecedingLogFile, File version_2, List<File> snaps, List<File> logs) throws IOException
{    int counter = offset.get() + (2 * limit);    if (createPrecedingLogFile) {        counter++;    }    offset.set(counter);    for (int i = 0; i < limit; i++) {                logs.add(createDataDirLogFile(version_2, --counter));                File snapFile = new File(version_2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());        snaps.add(snapFile);    }    if (createPrecedingLogFile) {        logs.add(createDataDirLogFile(version_2, --counter));    }}
dc255ef65176e8ebcc0e5c957c3bee485370a0ebcd5bfadabb6ede19a3cf2cd0
verifyFilesAfterPurge
private void verifyFilesAfterPurge(List<File> logs, boolean exists)
{    for (File file : logs) {        assertEquals("After purging, file " + file, exists, file.exists());    }}
0dc06af530f4e41878554ad610510364f11b1e378917af20dadac617a4b1462c
manyClientOps
private List<String> manyClientOps(final ZooKeeper zk, final CountDownLatch doPurge, int thCount, final String prefix)
{    Thread[] ths = new Thread[thCount];    final List<String> znodes = Collections.synchronizedList(new ArrayList<String>());    final CountDownLatch finished = new CountDownLatch(thCount);    for (int indx = 0; indx < thCount; indx++) {        final String myprefix = prefix + "-" + indx;        Thread th = new Thread() {            public void run() {                for (int i = 0; i < 1000; i++) {                    try {                        String mynode = myprefix + "-" + i;                        znodes.add(mynode);                        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (Exception e) {                        LOG.error("Unexpected exception occurred!", e);                    }                    if (i == 200) {                        doPurge.countDown();                    }                }                finished.countDown();            }        };        ths[indx] = th;    }    for (Thread thread : ths) {        thread.start();    }    try {        assertTrue("ZkClient ops is not finished!", finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    } catch (InterruptedException ie) {        LOG.error("Unexpected exception occurred!", ie);        fail("Unexpected exception occurred!");    }    return znodes;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    for (int i = 0; i < 1000; i++) {        try {            String mynode = myprefix + "-" + i;            znodes.add(mynode);            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (Exception e) {            LOG.error("Unexpected exception occurred!", e);        }        if (i == 200) {            doPurge.countDown();        }    }    finished.countDown();}
605aa5389bba002c6abbab2ccc67dd5dd0d04080d8ba72825c0bdcde4bf8f47f
setUpSasl
public static void setUpSasl() throws Exception
{    startMiniKdc();}
26c5488f51a6d8c509e9fd214beb7d546a8dc10d5e6de1c6757ae2557c5c867f
tearDownSasl
public static void tearDownSasl() throws Exception
{    stopMiniKdc();    FileUtils.deleteQuietly(workDir);}
d89d570373cc3f1e47e89bd8e5ba6e68c9a05d25f832a6567174a4dcf6476c14
startMiniKdc
public static void startMiniKdc() throws Exception
{    createTestDir();    createMiniKdcConf();    kdc = new MiniKdc(conf, workDir);    kdc.start();}
4073798d4dc8cfca26f695a9c0777752a7426d6200b616e2a819da04e8eba589
createTestDir
public static void createTestDir() throws IOException
{    workDir = createTmpDir(new File(System.getProperty("build.test.dir", "build")));}
8d17e90ce1b94275bbd63538eb7569287d360ddf59e0b1536db84e9bb7a30326
createTmpDir
 static File createTmpDir(File parentDir) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());    return tmpDir;}
f23cb1eb840972e47e4490e700e3b33ec94c553c6b9aaee7c5a41276eed8dcde
createMiniKdcConf
public static void createMiniKdcConf()
{    conf = MiniKdc.createConf();}
9fc1da8ac56d93321965bcabaa15fcdaff1fb66dece61770035efba65bae6c40
stopMiniKdc
public static void stopMiniKdc()
{    if (kdc != null) {        kdc.stop();    }}
695c7cf3880fbcac40884489d762363b0e2e8aaf3a2dd3a04070d4d790e0b08d
getKdc
public static MiniKdc getKdc()
{    return kdc;}
ad58d42fb809a34c5dc6dafe49aca2f1d5af19df1a14c9bc4c1c7754a4121d2c
getWorkDir
public static File getWorkDir()
{    return workDir;}
519c33c30fa6dff2dea79dfaef373c8c7a588362d9be282bbe7c62081e7db12c
getConf
public static Properties getConf()
{    return conf;}
da1e8f5bca5d0509b4138dcb4e7bcc3b5d2ee43f51f11ac9473937a22144c1e2
getRealm
public static String getRealm()
{    return "EXAMPLE.COM";}
b04e5ecdfe80c119e806910068982a6036f9c715901176ce9c3ae6aba710ffdb
getLearnerPrincipal
public static String getLearnerPrincipal()
{    return "learner@EXAMPLE.COM";}
0869f89a22e6d7bd89f1c90caab28184816e4cf0c9847cbac90a6e92d7bd9555
getServerPrincipal
public static String getServerPrincipal()
{    return "zkquorum/localhost@EXAMPLE.COM";}
58c782d59ae56b50b5a99c6a8b90e35e8ba93492e06d7441a19ca5ddcaa2fd2e
getHostLearnerPrincipal
public static String getHostLearnerPrincipal()
{    return "learner/_HOST@EXAMPLE.COM";}
cc9aba89ee408e7f78027147c27191ab0caed1e6643053de01ba6ac7130e59fd
getHostServerPrincipal
public static String getHostServerPrincipal()
{    return "zkquorum/_HOST@EXAMPLE.COM";}
c28e694a4567072d8d9b59e648187c5b2b5ab428f1fc4de3e049181539a507e6
getHostNamedLearnerPrincipal
public static String getHostNamedLearnerPrincipal(String myHostname)
{    return "learner/" + myHostname + "@EXAMPLE.COM";}
13ffbdc9979b7e5d9b51270105ee28b75bb43a36ec70228590a00c5b5396e9b0
getKeytabFile
public static String getKeytabFile()
{    return keytabFile;}
45d16782b0c2b7c0a348ad47a6d57616da34c0eb079e891035f0ac4e3eb37737
replaceHostPattern
public static String replaceHostPattern(String principal)
{    String[] components = principal.split("[/@]");    if (components == null || components.length < 2 || !components[1].equals(SecurityUtils.QUORUM_HOSTNAME_PATTERN)) {        return principal;    } else {        return replacePattern(components, "localhost");    }}
d1c2d65ecf5a3c52620787a4641f0586bbe7419296c876854d64dad6e03ad4ea
replacePattern
public static String replacePattern(String[] components, String hostname)
{    if (components.length == 3) {        return components[0] + "/" + hostname.toLowerCase() + "@" + components[2];    } else {        return components[0] + "/" + hostname.toLowerCase();    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length < 4) {        System.out.println("Arguments: <WORKDIR> <MINIKDCPROPERTIES> " + "<KEYTABFILE> [<PRINCIPALS>]+");        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    File workDir = new File(args[0]);    if (!workDir.exists()) {        throw new RuntimeException("Specified work directory does not exists: " + workDir.getAbsolutePath());    }    Properties conf = createConf();    File file = new File(args[1]);    if (!file.exists()) {        throw new RuntimeException("Specified configuration does not exists: " + file.getAbsolutePath());    }    Properties userConf = new Properties();    InputStreamReader r = null;    try {        r = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);        userConf.load(r);    } finally {        if (r != null) {            r.close();        }    }    for (Map.Entry<?, ?> entry : userConf.entrySet()) {        conf.put(entry.getKey(), entry.getValue());    }    final MiniKdc miniKdc = new MiniKdc(conf, workDir);    miniKdc.start();    File krb5conf = new File(workDir, "krb5.conf");    if (miniKdc.getKrb5conf().renameTo(krb5conf)) {        File keytabFile = new File(args[2]).getAbsoluteFile();        String[] principals = new String[args.length - 3];        System.arraycopy(args, 3, principals, 0, args.length - 3);        miniKdc.createPrincipal(keytabFile, principals);        System.out.println();        System.out.println("Standalone MiniKdc Running");        System.out.println("---------------------------------------------------");        System.out.println("  Realm           : " + miniKdc.getRealm());        System.out.println("  Running at      : " + miniKdc.getHost() + ":" + miniKdc.getHost());        System.out.println("  krb5conf        : " + krb5conf);        System.out.println();        System.out.println("  created keytab  : " + keytabFile);        System.out.println("  with principals : " + Arrays.asList(principals));        System.out.println();        System.out.println(" Do <CTRL-C> or kill <PID> to stop it");        System.out.println("---------------------------------------------------");        System.out.println();        Runtime.getRuntime().addShutdownHook(new Thread() {            @Override            public void run() {                miniKdc.stop();            }        });    } else {        throw new RuntimeException("Cannot rename KDC's krb5conf to " + krb5conf.getAbsolutePath());    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    miniKdc.stop();}
c181df422bec8737e551f0943fcf2fe0ffa9817fcb9ada491d7229d1893c66f1
createConf
public static Properties createConf()
{    return (Properties) DEFAULT_CONFIG.clone();}
427f0d3a6984bdc5f7ece9fed8c2dc06a36209cd652beaf3f9e8d97d32eb1a0e
setTransport
public void setTransport(String transport)
{    this.transport = transport;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return port;}
165b1c9352ad3d309866d5286d1a7fd8eae4d022cb5ad661b1269ac75c218ebb
getHost
public String getHost()
{    return conf.getProperty(KDC_BIND_ADDRESS);}
f1c45a4c4f150639a8cd469fed7c91e49bb2bc490a1fc61a7036b915aae5e0b2
getRealm
public String getRealm()
{    return realm;}
951c469944ad73853a17c403f633a4b18c3ca2677e94295b528d8da4ac2e5004
getKrb5conf
public File getKrb5conf()
{    krb5conf = new File(System.getProperty(JAVA_SECURITY_KRB5_CONF));    return krb5conf;}
b8282fe6b8c2a709b928707be57714a533155137ab05ea28c4f859387aeff305
start
public synchronized void start() throws Exception
{    if (simpleKdc != null) {        throw new RuntimeException("Already started");    }    simpleKdc = new SimpleKdcServer();    prepareKdcServer();    simpleKdc.init();    resetDefaultRealm();    simpleKdc.start();    LOG.info("MiniKdc stated.");}
f377f7a4817485807dcc03b6de2742a858704b9b06b7ce3815c5262df592da0c
resetDefaultRealm
private void resetDefaultRealm() throws IOException
{    InputStream templateResource = new FileInputStream(getKrb5conf().getAbsolutePath());    String content = IOUtil.readInput(templateResource);    content = content.replaceAll("default_realm = .*\n", "default_realm = " + getRealm() + "\n");    IOUtil.writeFile(content, getKrb5conf());}
a59a6035bbb7072ed7e495d5da5958ca751f01324a3cc35b8084a7ff56a391ae
prepareKdcServer
private void prepareKdcServer() throws Exception
{        simpleKdc.setWorkDir(workDir);    simpleKdc.setKdcHost(getHost());    simpleKdc.setKdcRealm(realm);    if (transport == null) {        transport = conf.getProperty(TRANSPORT);    }    if (port == 0) {        port = NetworkUtil.getServerPort();    }    if (transport != null) {        if (transport.trim().equals("TCP")) {            simpleKdc.setKdcTcpPort(port);            simpleKdc.setAllowUdp(false);        } else if (transport.trim().equals("UDP")) {            simpleKdc.setKdcUdpPort(port);            simpleKdc.setAllowTcp(false);        } else {            throw new IllegalArgumentException("Invalid transport: " + transport);        }    } else {        throw new IllegalArgumentException("Need to set transport!");    }    simpleKdc.getKdcConfig().setString(KdcConfigKey.KDC_SERVICE_NAME, conf.getProperty(INSTANCE));    if (conf.getProperty(DEBUG) != null) {        krb5Debug = getAndSet(SUN_SECURITY_KRB5_DEBUG, conf.getProperty(DEBUG));    }}
06e1ddba8663c90da407ac517f29ed70555cfe57b0332c9a96e7c696e0255364
stop
public synchronized void stop()
{    if (simpleKdc != null) {        try {            simpleKdc.stop();        } catch (KrbException e) {            e.printStackTrace();        } finally {            if (conf.getProperty(DEBUG) != null) {                System.setProperty(SUN_SECURITY_KRB5_DEBUG, Boolean.toString(krb5Debug));            }        }    }    delete(workDir);    try {                Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    LOG.info("MiniKdc stopped.");}
e294d638095bcf4009c9d1ab0f0b2da15a72f205e486b6cefbc8f56654022e4a
delete
private void delete(File f)
{    if (f.isFile()) {        if (!f.delete()) {            LOG.warn("WARNING: cannot delete file " + f.getAbsolutePath());        }    } else {        for (File c : f.listFiles()) {            delete(c);        }        if (!f.delete()) {            LOG.warn("WARNING: cannot delete directory " + f.getAbsolutePath());        }    }}
94b20080ca9b4ec667bbec0797bce817189114405a80b355e54640e05623029c
createPrincipal
public synchronized void createPrincipal(String principal, String password) throws Exception
{    simpleKdc.createPrincipal(principal, password);}
cc2c93b5356b2f8fd16f5991918b2fd9d89608824a952ce6d1f556f124a40dc4
createPrincipal
public synchronized void createPrincipal(File keytabFile, String... principals) throws Exception
{    simpleKdc.createPrincipals(principals);    if (keytabFile.exists() && !keytabFile.delete()) {        LOG.error("Failed to delete keytab file: " + keytabFile);    }    for (String principal : principals) {        simpleKdc.getKadmin().exportKeytab(keytabFile, principal);    }}
89ad9d9d86f4d115a175811600a41d2c7b00a6b37c6a1346043e2f1bc730a149
getAndSet
private boolean getAndSet(String sysprop, String debug)
{    boolean old = Boolean.getBoolean(sysprop);    System.setProperty(sysprop, debug);    return old;}
41e865948c2f48614dac88e00f345818f09968ba02f19302c8354c9a76c3580a
testMiniKdcStart
public void testMiniKdcStart()
{    MiniKdc kdc = getKdc();    assertNotSame(0, kdc.getPort());}
a46f2cb697d8bd34e235533c0f4d011acb24a8dc39f84073829e83928388434d
testKeytabGen
public void testKeytabGen() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    kdc.createPrincipal(new File(workDir, "keytab"), "foo/bar", "bar/foo");    List<PrincipalName> principalNameList = Keytab.loadKeytab(new File(workDir, "keytab")).getPrincipals();    Set<String> principals = new HashSet<String>();    for (PrincipalName principalName : principalNameList) {        principals.add(principalName.getName());    }    assertEquals(new HashSet<>(Arrays.asList("foo/bar@" + kdc.getRealm(), "bar/foo@" + kdc.getRealm())), principals);}
314a5354a41c1981e6f4fcb9d51e281efdd922c6f6a195f6132b280ac7e8c8f8
createClientConfig
public static Configuration createClientConfig(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, true);}
de6a811e99b046a70c0b2a7389461f59ff8f811f0b70e3ee4ec42e4666e674bf
createServerConfig
public static Configuration createServerConfig(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, false);}
742a8d731579b1b615be5e2995275ee16b90a2b773fc075bd273f5be6f9b7bf8
getKrb5LoginModuleName
private static String getKrb5LoginModuleName()
{    return System.getProperty("java.vendor").contains("IBM") ? "com.ibm.security.auth.module.Krb5LoginModule" : "com.sun.security.auth.module.Krb5LoginModule";}
471dd820ad3f79f9f3de768ed55750966c77dd25a45826a2512bd4140efbd547
getAppConfigurationEntry
public AppConfigurationEntry[] getAppConfigurationEntry(String name)
{    Map<String, String> options = new HashMap<String, String>();    options.put("principal", principal);    options.put("refreshKrb5Config", "true");    if (IBM_JAVA) {        options.put("useKeytab", keytab);        options.put("credsType", "both");    } else {        options.put("keyTab", keytab);        options.put("useKeyTab", "true");        options.put("storeKey", "true");        options.put("doNotPrompt", "true");        options.put("useTicketCache", "true");        options.put("renewTGT", "true");        options.put("isInitiator", Boolean.toString(isInitiator));    }    String ticketCache = System.getenv("KRB5CCNAME");    if (ticketCache != null) {        options.put("ticketCache", ticketCache);    }    options.put("debug", "true");    return new AppConfigurationEntry[] { new AppConfigurationEntry(getKrb5LoginModuleName(), AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options) };}
2513fe536aac2947e78323b7a7ff1e84942b7b62b5b80ccec40c4a05cdc555c9
testKerberosLogin
public void testKerberosLogin() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    LoginContext loginContext = null;    try {        String principal = "foo";        File keytab = new File(workDir, "foo.keytab");        kdc.createPrincipal(keytab, principal);        Set<Principal> principals = new HashSet<Principal>();        principals.add(new KerberosPrincipal(principal));                Subject subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createClientConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();                subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createServerConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();    } finally {        if (loginContext != null && loginContext.getSubject() != null && !loginContext.getSubject().getPrincipals().isEmpty()) {            loginContext.logout();        }    }}
89a0f99fe4c00b9e3a1c0658c9cf4d68b4c5851f32a0c48b9f062a390ed0ab1d
setupJaasConfig
public static void setupJaasConfig(String jaasEntries)
{    try {        jaasConfigDir = ClientBase.createTmpDir();        File saslConfFile = new File(jaasConfigDir, "jaas.conf");        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasEntries);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException ioe) {        LOG.error("Failed to create tmp directory to hold JAAS conf file", ioe);            }}
e7d57a9a73a57c441ae5986b3d57d4075cf9b2ab630e7d80468710322f72d9fa
cleanupJaasConfig
public static void cleanupJaasConfig()
{    if (jaasConfigDir != null) {        FileUtils.deleteQuietly(jaasConfigDir);    }}
125548c749722732d25aa76d6df4e51ee75afef463b3061ff9f7e2426a442d0e
startQuorum
protected String startQuorum(final int serverCount, Map<String, String> authConfigs, int authServerCount) throws IOException
{    StringBuilder connectStr = new StringBuilder();    final int[] clientPorts = startQuorum(serverCount, connectStr, authConfigs, authServerCount);    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT));    }    return connectStr.toString();}
34efb7556bbc4c91e651239379f0b065c0bbf40d39a2e4e9e0356135e1fbe4d6
startQuorum
protected int[] startQuorum(final int serverCount, StringBuilder connectStr, Map<String, String> authConfigs, int authServerCount) throws IOException
{    final int[] clientPorts = new int[serverCount];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < serverCount; i++) {        clientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=localhost:%d:%d:participant", i, PortAssignment.unique(), PortAssignment.unique());        sb.append(server + "\n");        connectStr.append("127.0.0.1:" + clientPorts[i]);        if (i < serverCount - 1) {            connectStr.append(",");        }    }    String quorumCfg = sb.toString();        int i = 0;    for (; i < authServerCount; i++) {        startServer(authConfigs, clientPorts, quorumCfg, i);    }        for (int j = 0; j < serverCount - authServerCount; j++, i++) {        MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg);        mt.add(mthread);        mthread.start();    }    return clientPorts;}
6907f5dcf80c883dcbdf35f513482047254bedc3f5e6c3869f79379997442a4b
startServer
private void startServer(Map<String, String> authConfigs, final int[] clientPorts, String quorumCfg, int i) throws IOException
{    MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg, authConfigs);    mt.add(mthread);    mthread.start();}
4fd80105a9c4eda4028002b519aeda2c562eab23883471b834807ec5c3397b45
startServer
protected void startServer(MainThread restartPeer, Map<String, String> authConfigs) throws IOException
{    MainThread mthread = new MainThread(restartPeer.getMyid(), restartPeer.getClientPort(), restartPeer.getQuorumCfgSection(), authConfigs);    mt.add(mthread);    mthread.start();}
a6385d758c11ad859d665b5a86723d90c89dc8989038a8d2da0c895a47841375
shutdownAll
 void shutdownAll()
{    for (int i = 0; i < mt.size(); i++) {        shutdown(i);    }}
b6a3951185c5f2f66459324f49e27f44d650823f014cd194b53f33e7788e9ab2
shutdown
 MainThread shutdown(int index)
{    MainThread mainThread = mt.get(index);    try {        mainThread.shutdown();    } catch (InterruptedException e) {        } finally {        mt.remove(index);    }    mainThread.deleteBaseDir();    return mainThread;}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    shutdownAll();}
6a5ea8b0a96f10849d9ee4bf738dcf31f9bf401b5bf72e2586c3485ffaed0e38
cleanup
public static void cleanup()
{    cleanupJaasConfig();}
e84deb87336cb2f2d81236aa805344e3e88d6bfe3b3896294afe3ccafd4fa37c
testNullAuthLearnerServer
public void testNullAuthLearnerServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(2, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
8eb4a7172391ed7217f4ca52bfd2a77d773a37cefa74435a79ea893cd08ed710
testAuthLearnerAgainstNullAuthServer
public void testAuthLearnerAgainstNullAuthServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 1);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
46ccc85ec1a34b68841b86116746a7e90f0296c6b4e11363e2fd4fc70dc0f537
testAuthLearnerAgainstNoAuthRequiredServer
public void testAuthLearnerAgainstNoAuthRequiredServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
b46cff1df5671e3e9120fb01f3197eb8b513899b987edad1708fbadea2aaa7cc
testAuthLearnerServer
public void testAuthLearnerServer() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
1b20f43c01ddf96f1c1fbda89776851393d4c42d5a9eae11ccfd8e2e4759d39e
testRollingUpgrade
public void testRollingUpgrade() throws Exception
{                Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(3, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);                authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    MainThread m = shutdown(2);    startServer(m, authConfigs);    assertFalse("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), 5000));}
4de78cec7fedf3084659a104ce4252925c4704e6329618d2ee483335761fa23e
restartServer
private void restartServer(Map<String, String> authConfigs, int index, ZooKeeper zk, CountdownWatcher watcher) throws IOException, KeeperException, InterruptedException, TimeoutException
{    LOG.info("Restarting server myid=" + index);    MainThread m = shutdown(index);    startServer(m, authConfigs);    assertTrue("waiting for server" + index + "being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), ClientBase.CONNECTION_TIMEOUT));    watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
6a5ea8b0a96f10849d9ee4bf738dcf31f9bf401b5bf72e2586c3485ffaed0e38
cleanup
public static void cleanup()
{    cleanupJaasConfig();}
08fdd9259ec0afdf58e3b97194a8c6ec29e8c62aa168e99b82bc4ca7093bb9f6
testValidCredentials
public void testValidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
8291914908ee4d943a1a65b4a5db46a2daeac74b818c3df921e2ca09a817baba
testSaslNotRequiredWithInvalidCredentials
public void testSaslNotRequiredWithInvalidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
ae0496b2cc5010044e53c840c90a2bad8f93b6dfc3ae9db3d74742a34d3a8766
testSaslRequiredInvalidCredentials
public void testSaslRequiredInvalidCredentials() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    int serverCount = 2;    final int[] clientPorts = startQuorum(serverCount, new StringBuilder(), authConfigs, serverCount);    for (int i = 0; i < serverCount; i++) {        boolean waitForServerUp = ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], QuorumPeerTestBase.TIMEOUT);        assertFalse("Shouldn't start server with invalid credentials", waitForServerUp);    }}
ff0e1eb64b0ce5c08ec94b360c653c299375fd0fddaad0bfe9ed745a1c3c5e45
testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl
public void testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorumpeer learner is not enabled!");    } catch (ConfigException e) {        }}
537fbfb577f20995892ab3c09e14e5eb7e3bc2a47f46ae2429edd92b386d9d05
initializeAndRun
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
df7afa2b9f139c5fd2747cc9a100881bad702a13b263aa778732bc082d96e770
testEnableQuorumAuthenticationConfigurations
public void testEnableQuorumAuthenticationConfigurations() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }}
537fbfb577f20995892ab3c09e14e5eb7e3bc2a47f46ae2429edd92b386d9d05
initializeAndRun
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
537fbfb577f20995892ab3c09e14e5eb7e3bc2a47f46ae2429edd92b386d9d05
initializeAndRun
protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());    String learnerPrincipal = KerberosTestUtils.getLearnerPrincipal();    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    learnerPrincipal = learnerPrincipal.substring(0, learnerPrincipal.lastIndexOf("@"));    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, serverPrincipal);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
6a5ea8b0a96f10849d9ee4bf738dcf31f9bf401b5bf72e2586c3485ffaed0e38
cleanup
public static void cleanup()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
08fdd9259ec0afdf58e3b97194a8c6ec29e8c62aa168e99b82bc4ca7093bb9f6
testValidCredentials
public void testValidCredentials() throws Exception
{    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
17227ef744a353241d61ae67c8dcb272488c3585d6a8039cce4d5ec6cdf09657
setupJaasConfigEntries
private static void setupJaasConfigEntries(String hostServerPrincipal, String hostLearnerPrincipal, String hostNamedLearnerPrincipal)
{    String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);    String jaasEntries = "QuorumServer {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostServerPrincipal) + "\";\n" + "};\n" + "QuorumLearner {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostLearnerPrincipal) + "\";\n" + "};\n" + "QuorumLearnerMyHost {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + hostNamedLearnerPrincipal + "\";\n" + "};\n";    setupJaasConfig(jaasEntries);}
d471c3328e3ae0971417113aa4471685bb392547c42536a61bb7d27d34a796f1
setUp
public static void setUp() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());        String learnerPrincipal = hostLearnerPrincipal.substring(0, hostLearnerPrincipal.lastIndexOf("@"));    learnerPrincipal = KerberosTestUtils.replaceHostPattern(learnerPrincipal);    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    serverPrincipal = KerberosTestUtils.replaceHostPattern(serverPrincipal);        String learnerPrincipal2 = hostNamedLearnerPrincipal.substring(0, hostNamedLearnerPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, learnerPrincipal2, serverPrincipal);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
6a5ea8b0a96f10849d9ee4bf738dcf31f9bf401b5bf72e2586c3485ffaed0e38
cleanup
public static void cleanup()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
08fdd9259ec0afdf58e3b97194a8c6ec29e8c62aa168e99b82bc4ca7093bb9f6
testValidCredentials
public void testValidCredentials() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
71143e1bea1b90b38c6d722c3f2711351b46ca246ca13f4ca614d92528e382a2
testConnectBadServer
public void testConnectBadServer() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    String quorumCfgSection = mt.get(0).getQuorumCfgSection();    StringBuilder sb = new StringBuilder();    sb.append(quorumCfgSection);    int myid = mt.size() + 1;    final int clientPort = PortAssignment.unique();    String server = String.format("server.%d=localhost:%d:%d:participant", myid, PortAssignment.unique(), PortAssignment.unique());    sb.append(server + "\n");    quorumCfgSection = sb.toString();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerMyHost");    MainThread badServer = new MainThread(myid, clientPort, quorumCfgSection, authConfigs);    badServer.start();    watcher = new CountdownWatcher();    connectStr = "127.0.0.1:" + clientPort;    zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT / 3);        fail("Must throw exception as the myHost is not an authorized one!");    } catch (TimeoutException e) {        } finally {        zk.close();        badServer.shutdown();        badServer.deleteBaseDir();    }}
c658f71b27e832290286905fe24ed59ffe4f857302b5fcf9b409170803c11a47
testSetProposalSizeSetMinMax
public void testSetProposalSizeSetMinMax()
{    BufferStats stats = new BufferStats();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.setLastBufferSize(20);    assertEquals(20, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());    stats.setLastBufferSize(5);    assertEquals(5, stats.getLastBufferSize());    assertEquals(5, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{    BufferStats stats = new BufferStats();    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.reset();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());}
17eb444f65e6bf3c221b22ebbdeae28d56020a6227d4a2b7fe3ce7f13865ad70
testCloseSessionTxnCompatile
public void testCloseSessionTxnCompatile() throws Exception
{            testCloseSessionWithDifferentConfig(false, false);        testCloseSessionWithDifferentConfig(false, true);        testCloseSessionWithDifferentConfig(true, false);        testCloseSessionWithDifferentConfig(true, true);}
df7a59bd76aab5a1f741ad351acb02877c402edc94558bb1386a80c4a942dab4
testCloseSessionWithDifferentConfig
private void testCloseSessionWithDifferentConfig(boolean closeSessionEnabledOnLeader, boolean closeSessionEnabledOnFollower) throws Exception
{        final int numServers = 3;    servers = LaunchServers(numServers);    int leaderId = servers.findLeader();    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnLeader);                        int followerA = (leaderId + 1) % numServers;    servers.mt[followerA].shutdown();    waitForOne(servers.zk[followerA], States.CONNECTING);        String path = "/testCloseSessionTxnCompatile";    servers.zk[leaderId].create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        servers.restartClient(leaderId, this);    waitForOne(servers.zk[leaderId], States.CONNECTED);            System.setProperty("zookeeper.retainZKDatabase", "true");    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnFollower);        servers.mt[followerA].start();    waitForOne(servers.zk[followerA], States.CONNECTED);        for (int i = 0; i < numServers; i++) {        final CountDownLatch syncedLatch = new CountDownLatch(1);        servers.zk[i].sync(path, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                syncedLatch.countDown();            }        }, null);        Assert.assertTrue(syncedLatch.await(3, TimeUnit.SECONDS));        Assert.assertNull(servers.zk[i].exists(path, false));    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    syncedLatch.countDown();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    this.count = 3;    this.peers = new HashMap<Long, QuorumServer>(count);    peerTmpdir = new File[count];    peerQuorumPort = new int[count];    peerClientPort = new int[count];    for (int i = 0; i < count; i++) {        peerQuorumPort[i] = PortAssignment.unique();        peerClientPort[i] = PortAssignment.unique();        peers.put((long) i, new QuorumServer(i, new InetSocketAddress("127.0.0.1", peerQuorumPort[i]), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", peerClientPort[i])));        peerTmpdir[i] = ClientBase.createTmpDir();    }}
8e5f345a8be9b34d1f1127cdca46374354c2d6a48340252656254dd84d8e9ca4
createMsg
 ByteBuffer createMsg(int state, long leader, long zxid, long epoch)
{    byte[] requestBytes = new byte[28];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(epoch);    return requestBuffer;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);        QuorumCnxManager cnxManager = peer.createCnxnManager();        QuorumCnxManager.Listener listener = cnxManager.listener;        if (listener != null) {            listener.start();        } else {            LOG.error("Null listener when initializing cnx manager");        }        long sid = 1;        cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));        Message m = null;        int numRetries = 1;        while ((m == null) && (numRetries++ <= THRESHOLD)) {            m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (m == null) {                cnxManager.connectAll();            }        }        if (numRetries > THRESHOLD) {            failed = true;            return;        }        cnxManager.testInitiateConnection(sid);        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            failed = true;        }    } catch (Exception e) {        LOG.error("Exception while running mock thread", e);        fail("Unexpected exception");    }}
dfe7d4704340c9e89f4f54aa0020c1445c552e7078637db04137580d1c3dd58a
testCnxManager
public void testCnxManager() throws Exception
{    CnxManagerThread thread = new CnxManagerThread();    thread.start();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {        LOG.error("Null listener when initializing cnx manager");    }    cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    Message m = null;    int numRetries = 1;    while ((m == null) && (numRetries++ <= THRESHOLD)) {        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            cnxManager.connectAll();        }    }    assertTrue("Exceeded number of retries", numRetries <= THRESHOLD);    thread.join(5000);    if (thread.isAlive()) {        fail("Thread didn't join");    } else {        if (thread.failed) {            fail("Did not receive expected message");        }    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
1cf29c9938e371c2deeac562c30527abbbc1b7ad7267fcece83cc172f7b05616
testCnxManagerTimeout
public void testCnxManagerTimeout() throws Exception
{    Random rand = new Random();    byte b = (byte) rand.nextInt();    int deadPort = PortAssignment.unique();    String deadAddress = "10.1.1." + b;    LOG.info("This is the dead address I'm trying: " + deadAddress);    peers.put(2L, new QuorumServer(2, new InetSocketAddress(deadAddress, deadPort), new InetSocketAddress(deadAddress, PortAssignment.unique()), new InetSocketAddress(deadAddress, PortAssignment.unique())));    peerTmpdir[2] = ClientBase.createTmpDir();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {        LOG.error("Null listener when initializing cnx manager");    }    long begin = Time.currentElapsedTime();    cnxManager.toSend(2L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    long end = Time.currentElapsedTime();    if ((end - begin) > 6000) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
bfa0e80c67786328beec2a8eb731200f20f980feff0c23adacc033325a287cfa
testCnxManagerSpinLock
public void testCnxManagerSpinLock() throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {        LOG.error("Null listener when initializing cnx manager");    }    int port = peers.get(peer.getId()).electionAddr.getPort();    LOG.info("Election port: " + port);    Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    InetSocketAddress otherAddr = peers.get(Long.valueOf(2)).electionAddr;    DataOutputStream dout = new DataOutputStream(sc.socket().getOutputStream());    dout.writeLong(QuorumCnxManager.PROTOCOL_VERSION);    dout.writeLong(2);    String addr = otherAddr.getHostString() + ":" + otherAddr.getPort();    byte[] addr_bytes = addr.getBytes();    dout.writeInt(addr_bytes.length);    dout.write(addr_bytes);    dout.flush();    ByteBuffer msgBuffer = ByteBuffer.wrap(new byte[4]);    msgBuffer.putInt(-20);    msgBuffer.position(0);    sc.write(msgBuffer);    Thread.sleep(1000);    try {        /*             * Write a number of times until it             * detects that the socket is broken.             */        for (int i = 0; i < 100; i++) {            msgBuffer.position(0);            sc.write(msgBuffer);        }        fail("Socket has not been closed");    } catch (Exception e) {        LOG.info("Socket has been closed as expected");    }    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
08987e32f34874c2ed39bb669a09b8307082d2d3ab1ac9943e3d683be086a409
testCnxManagerListenerThreadConfigurableRetry
public void testCnxManagerListenerThreadConfigurableRetry() throws Exception
{    final Map<Long, QuorumServer> unresolvablePeers = new HashMap<>();    final long myid = 1L;    unresolvablePeers.put(myid, new QuorumServer(myid, "unresolvable-domain.org:2182:2183;2181"));    final QuorumPeer peer = new QuorumPeer(unresolvablePeers, ClientBase.createTmpDir(), ClientBase.createTmpDir(), 2181, 3, myid, 1000, 2, 2, 2);    final QuorumCnxManager cnxManager = peer.createCnxnManager();    final QuorumCnxManager.Listener listener = cnxManager.listener;    final AtomicBoolean errorHappend = new AtomicBoolean();    listener.setSocketBindErrorHandler(() -> errorHappend.set(true));    listener.start();                listener.join(15000);    assertFalse(listener.isAlive());    assertTrue(errorHappend.get());    assertFalse(QuorumPeer.class.getSimpleName() + " not stopped after " + "listener thread death", listener.isAlive());}
04ec829c83bc7361f570c5644d181756677bbf781d8a5b0b20700f98b2e0d96a
testCnxManagerNPE
public void testCnxManagerNPE() throws Exception
{        peers.get(2L).type = LearnerType.OBSERVER;    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {        LOG.error("Null listener when initializing cnx manager");    }    int port = peers.get(peer.getId()).electionAddr.getPort();    LOG.info("Election port: " + port);    Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    /*         * Write id (3.4.6 protocol). This previously caused a NPE in         * QuorumCnxManager.         */    byte[] msgBytes = new byte[8];    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);    msgBuffer.putLong(2L);    msgBuffer.position(0);    sc.write(msgBuffer);    msgBuffer = ByteBuffer.wrap(new byte[8]);        msgBuffer.putInt(4);        msgBuffer.putInt(5);    msgBuffer.position(0);    sc.write(msgBuffer);    Message m = cnxManager.pollRecvQueue(1000, TimeUnit.MILLISECONDS);    assertNotNull(m);    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
04c029b534173469d1f25de09e26fb49cb1c040c49b4463a7890eb7f7250fae0
testSocketTimeout
public void testSocketTimeout() throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {        LOG.error("Null listener when initializing cnx manager");    }    int port = peers.get(peer.getId()).electionAddr.getPort();    LOG.info("Election port: " + port);    Thread.sleep(1000);    Socket sock = new Socket();    sock.connect(peers.get(1L).electionAddr, 5000);    long begin = Time.currentElapsedTime();        cnxManager.receiveConnection(sock);    long end = Time.currentElapsedTime();    if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
0dc01380fa9bbc71e9dee21f2e14d3678e3174e3b53afeaabbe4df07f9144392
testSSLSocketClosedWhenHandshakeTimeout
public void testSSLSocketClosedWhenHandshakeTimeout() throws Exception
{    final CountDownLatch closeLatch = new CountDownLatch(1);    QuorumX509Util mockedX509Util = new QuorumX509Util() {        @Override        public SSLSocket createSSLSocket() {            return new SSLSocket() {                @Override                public void connect(SocketAddress endpoint, int timeout) {                }                @Override                public void startHandshake() throws IOException {                    throw new IOException();                }                @Override                public void close() {                    closeLatch.countDown();                }                public String[] getSupportedCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getSupportedProtocols() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledProtocols() {                    throw new UnsupportedOperationException();                }                public SSLSession getSession() {                    throw new UnsupportedOperationException();                }                public void setEnabledCipherSuites(String[] suites) {                }                public void setEnabledProtocols(String[] protocols) {                }                public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void setUseClientMode(boolean mode) {                }                public boolean getUseClientMode() {                    return true;                }                public void setNeedClientAuth(boolean need) {                }                public boolean getNeedClientAuth() {                    return true;                }                public void setWantClientAuth(boolean want) {                }                public boolean getWantClientAuth() {                    return true;                }                public void setEnableSessionCreation(boolean flag) {                }                public boolean getEnableSessionCreation() {                    return true;                }            };        }    };    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 2000, 2, 2, 2) {        @Override        public QuorumX509Util createX509Util() {            return mockedX509Util;        }    };    peer.setSslQuorum(true);    QuorumCnxManager cnxManager = peer.createCnxnManager();    cnxManager.connectOne(1, peers.get(1L).electionAddr);    assertTrue(closeLatch.await(1, TimeUnit.SECONDS));}
20847fc4f5138f47afcb5c08f99aa63c5d12f6d2a4208c5a9f35be9abbd2acfb
createSSLSocket
public SSLSocket createSSLSocket()
{    return new SSLSocket() {        @Override        public void connect(SocketAddress endpoint, int timeout) {        }        @Override        public void startHandshake() throws IOException {            throw new IOException();        }        @Override        public void close() {            closeLatch.countDown();        }        public String[] getSupportedCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getEnabledCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getSupportedProtocols() {            throw new UnsupportedOperationException();        }        public String[] getEnabledProtocols() {            throw new UnsupportedOperationException();        }        public SSLSession getSession() {            throw new UnsupportedOperationException();        }        public void setEnabledCipherSuites(String[] suites) {        }        public void setEnabledProtocols(String[] protocols) {        }        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void setUseClientMode(boolean mode) {        }        public boolean getUseClientMode() {            return true;        }        public void setNeedClientAuth(boolean need) {        }        public boolean getNeedClientAuth() {            return true;        }        public void setWantClientAuth(boolean want) {        }        public boolean getWantClientAuth() {            return true;        }        public void setEnableSessionCreation(boolean flag) {        }        public boolean getEnableSessionCreation() {            return true;        }    };}
1fc1f9766648b3ee445f3e08ae207311841f7e2277bed3669b73b3d7ad3aded9
connect
public void connect(SocketAddress endpoint, int timeout)
{}
32c9e37ea1018dfa11ef1d1a3de428fcf033c2657398ae383862f50da41806f3
startHandshake
public void startHandshake() throws IOException
{    throw new IOException();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    closeLatch.countDown();}
e6bd8d7c2ab9d07a58f015eb51ef1f39513045f1a602fc30b46d25a8a9608312
getSupportedCipherSuites
public String[] getSupportedCipherSuites()
{    throw new UnsupportedOperationException();}
56f69cbb22c4128a71569dc957096e717aa61d447b4f91b2ddfbe111c04915b2
getEnabledCipherSuites
public String[] getEnabledCipherSuites()
{    throw new UnsupportedOperationException();}
21cc57ef097d7e3e07321d041c33b84a6bde7df3c3363c16de62f126a077c32f
getSupportedProtocols
public String[] getSupportedProtocols()
{    throw new UnsupportedOperationException();}
96fdcf696ab41da64539a8e01bc32c233a882e4eaa78418db94ebe99e62f7355
getEnabledProtocols
public String[] getEnabledProtocols()
{    throw new UnsupportedOperationException();}
691ec82b1a296924affc2225fe866cbbf8a39b8191ef00511406794e0f6c04bb
getSession
public SSLSession getSession()
{    throw new UnsupportedOperationException();}
42f8a6d946d749ef0371a545289bb67f2d6a1e55730028969d0e816eda5cb1aa
setEnabledCipherSuites
public void setEnabledCipherSuites(String[] suites)
{}
d36071c93134040f762e9b01ea053ea71d177e5f038c3f889a54f1735855f996
setEnabledProtocols
public void setEnabledProtocols(String[] protocols)
{}
e14e2e4728b7d4bbd68fd2d5937436a917f0cc764b2e5b3137ae77d3ada7f3f9
addHandshakeCompletedListener
public void addHandshakeCompletedListener(HandshakeCompletedListener listener)
{}
3ce81ac2ea5c0819db02b9d1983e8c8cfbd83cc95f90f3bba74eec53c433b629
removeHandshakeCompletedListener
public void removeHandshakeCompletedListener(HandshakeCompletedListener listener)
{}
18802bf0b5293ee27f5774fd044d0f1a745435656f7758894d95cfec02759977
setUseClientMode
public void setUseClientMode(boolean mode)
{}
d14575242beb0a4d733eaa198622731161c0ebffad6a03f849bcae9e1e8c2e94
getUseClientMode
public boolean getUseClientMode()
{    return true;}
1fb892c25c701604304cf68b6bfdf478f7556cd5e7da42db6b445585352c75a2
setNeedClientAuth
public void setNeedClientAuth(boolean need)
{}
54cd1e8a177ebc7eb3f4179b792b48df4f4cd7602b948520fc655724c8d8cc0f
getNeedClientAuth
public boolean getNeedClientAuth()
{    return true;}
8e5fbeb1fca9dd3d01d2b08e9aaa042858ca1cb90f8f6df404341cae9d3d6da1
setWantClientAuth
public void setWantClientAuth(boolean want)
{}
c6900be25573d0552174424e7d8153f4ff4643aef0b93c59c0b79874bd50cd9a
getWantClientAuth
public boolean getWantClientAuth()
{    return true;}
f40f198b71672bc853e3fa2c7121b20ff451f2ef54486ed84f8e415e307fc9f3
setEnableSessionCreation
public void setEnableSessionCreation(boolean flag)
{}
1975116c0afc051e5a6c1ad3f4dc60227614f00587c48b50d7aa9197b6e9a744
getEnableSessionCreation
public boolean getEnableSessionCreation()
{    return true;}
33187cc5e475badabebc87e1ff15822d198fcbabb9075cc8b16494cfa3232032
createX509Util
public QuorumX509Util createX509Util()
{    return mockedX509Util;}
7c242213ffd58a2a76445c3ec2ff49f49b35a671eebe6307ad23a0dd85198a55
testWorkerThreads
public void testWorkerThreads() throws Exception
{    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    try {        for (int sid = 0; sid < 3; sid++) {            QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);            LOG.info("Starting peer {}", peer.getId());            peer.start();            peerList.add(sid, peer);        }        String failure = verifyThreadCount(peerList, 4);        assertNull(failure, failure);        for (int myid = 0; myid < 3; myid++) {            for (int i = 0; i < 5; i++) {                                QuorumPeer peer = peerList.get(myid);                LOG.info("Round {}, halting peer {}", i, peer.getId());                peer.shutdown();                peerList.remove(myid);                failure = verifyThreadCount(peerList, 2);                assertNull(failure, failure);                                peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);                LOG.info("Round {}, restarting peer {}", i, peer.getId());                peer.start();                peerList.add(myid, peer);                failure = verifyThreadCount(peerList, 4);                assertNull(failure, failure);            }        }    } finally {        for (QuorumPeer quorumPeer : peerList) {            quorumPeer.shutdown();        }    }}
1cd7437df50428b7da1741012db2dfe78a188c2c992d03ce797a23eb5409959b
verifyThreadCount
public String verifyThreadCount(ArrayList<QuorumPeer> peerList, long ecnt) throws InterruptedException
{    String failure = null;    for (int i = 0; i < 480; i++) {        Thread.sleep(500);        failure = _verifyThreadCount(peerList, ecnt);        if (failure == null) {            return null;        }    }    return failure;}
d40973729c1bd38677272e52d8ea5a72a8d04f8aa46aea99851569ad54baf217
_verifyThreadCount
public String _verifyThreadCount(ArrayList<QuorumPeer> peerList, long ecnt)
{    for (int myid = 0; myid < peerList.size(); myid++) {        QuorumPeer peer = peerList.get(myid);        QuorumCnxManager cnxManager = peer.getQuorumCnxManager();        long cnt = cnxManager.getThreadCount();        if (cnt != ecnt) {            return new Date() + " Incorrect number of Worker threads for sid=" + myid + " expected " + ecnt + " found " + cnt;        }    }    return null;}
83d80b351ed7f01443738c6d38338385a73207818f99172e23e18e2347cb802e
testInitialMessage
public void testInitialMessage() throws Exception
{    InitialMessage msg;    ByteArrayOutputStream bos;    DataInputStream din;    DataOutputStream dout;    String hostport;        try {                hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(-65530L, din);        fail("bad protocol version accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = createLongString(1048576);        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("long message accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "what's going on here?";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("bad hostport accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);    } catch (InitialMessage.InitialMessageException ex) {        fail(ex.toString());    }}
e5253a7b7e4ce1e7ed5f75bcec3b88122a6b5b285b1e8c7024d6cf640deae35a
createLongString
private String createLongString(int size)
{    StringBuilder sb = new StringBuilder(size);    for (int i = 0; i < size; i++) {        sb.append('x');    }    return sb.toString();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    processedRequests = new LinkedBlockingQueue<Request>();    processor = new MockCommitProcessor();    CommitProcessor.setMaxReadBatchSize(-1);    CommitProcessor.setMaxCommitBatchSize(1);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    processor.shutdown();}
32875e031f9f32d95cfd33f1f6c071edb49aafdc56322ee8aa6d53ad8b32bebd
poll
public Request poll()
{    readReqId++;    try {        return newRequest(new GetDataRequest("/", false), OpCode.getData, readReqId % 50, readReqId);    } catch (IOException e) {        e.printStackTrace();    }    return null;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 42;}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    processedRequests.offer(request);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
86a5aa4ac4769b71278202247d3869fd9ba4ba93bee8d1e096f2c859538d1064
notifyStopping
public void notifyStopping(String threadName, int errorCode)
{    fail("Commit processor crashed " + errorCode);}
3ca7a6c4fcfdee663f7af7fcde39000111351daced968bb113933339a15644e1
initThreads
public void initThreads(int poolSize)
{    this.stopped = false;    this.workerPool = new WorkerService("CommitProcWork", poolSize, true);}
62c2bf6da735df21de09d781002663a7b426542aa9aad445a375b764f572f79a
newRequest
private Request newRequest(Record rec, int type, int sessionId, int xid) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    rec.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, xid, type, bb, new ArrayList<Id>());}
d796dcbd408ca8547f5ee718dccbdd0c1455f5bd570ea6242b9d1eeedcab4eac
committedAndUncommittedOfTheSameSessionRaceTest
public void committedAndUncommittedOfTheSameSessionRaceTest() throws Exception
{    final String path = "/testCvsUCRace";    Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x0, 0);    Request writeReq = newRequest(new SetDataRequest(path, new byte[16], -1), OpCode.setData, 0x0, 1);    processor.committedRequests.add(writeReq);    processor.queuedRequests.add(readReq);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    processor.initThreads(1);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Request was not processed " + readReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(readReq));    processedRequests.poll();    assertTrue("Request was not processed " + writeReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(writeReq));}
7463dac952536a1740c3dc79624d8740c5382403053e014fd6cf5429cbaeb1b4
processAsMuchUncommittedRequestsAsPossibleTest
public void processAsMuchUncommittedRequestsAsPossibleTest() throws Exception
{    final String path = "/testAsMuchAsPossible";    List<Request> shouldBeProcessed = new LinkedList<Request>();    Set<Request> shouldNotBeProcessed = new HashSet<Request>();    for (int sessionId = 1; sessionId <= 5; ++sessionId) {        for (int readReqId = 1; readReqId <= sessionId; ++readReqId) {            Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, readReqId);            shouldBeProcessed.add(readReq);            processor.queuedRequests.add(readReq);        }        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionId, sessionId + 1);        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, sessionId + 2);        processor.queuedRequests.add(writeReq);        processor.queuedWriteRequests.add(writeReq);        processor.queuedRequests.add(readReq);        shouldNotBeProcessed.add(writeReq);        shouldNotBeProcessed.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    Thread.sleep(1000);    shouldBeProcessed.removeAll(processedRequests);    for (Request r : shouldBeProcessed) {        LOG.error("Did not process " + r);    }    assertTrue("Not all requests were processed", shouldBeProcessed.isEmpty());    assertFalse("Processed a wrong request", shouldNotBeProcessed.removeAll(processedRequests));}
4506e8b51908f435eb4e64e87a61012361697ba84dcbc42ac226951ca686c823
processAllFollowingUncommittedAfterFirstCommitTest
public void processAllFollowingUncommittedAfterFirstCommitTest() throws Exception
{    final String path = "/testUncommittedFollowingCommited";    Set<Request> shouldBeInPending = new HashSet<Request>();    Set<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    shouldBeInPending.add(writeReq);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        processor.queuedRequests.add(readReq);        shouldBeInPending.add(readReq);        shouldBeProcessedAfterPending.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    shouldBeInPending.removeAll(processor.pendingRequests.get(writeReq.sessionId));    for (Request r : shouldBeInPending) {        LOG.error("Should be in pending " + r);    }    assertTrue("Not all requests moved to pending from queuedRequests", shouldBeInPending.isEmpty());    processor.committedRequests.add(writeReq);    processor.stoppedMainLoop = true;    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
cd846f5508cfb5954b79813c55927b7516b5b73b26d02a81a987abb48f846ca5
processAllWritesMaxBatchSize
public void processAllWritesMaxBatchSize() throws Exception
{    final String path = "/processAllWritesMaxBatchSize";    HashSet<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path + "_1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    Request writeReq2 = newRequest(new CreateRequest(path + "_2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 1);    processor.queuedRequests.add(writeReq2);    processor.queuedWriteRequests.add(writeReq2);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        Request readReq2 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x2, readReqId);        processor.queuedRequests.add(readReq);        shouldBeProcessedAfterPending.add(readReq);        processor.queuedRequests.add(readReq2);        shouldBeProcessedAfterPending.add(readReq2);    }    Request writeReq3 = newRequest(new CreateRequest(path + "_3", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 6);    processor.queuedRequests.add(writeReq3);    processor.queuedWriteRequests.add(writeReq3);    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(2);    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    assertTrue("Missing session 1 in pending queue", processor.pendingRequests.containsKey(writeReq.sessionId));    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq2.sessionId));    processor.committedRequests.add(writeReq);    processor.committedRequests.add(writeReq2);    processor.committedRequests.add(writeReq3);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed committed request", !processor.committedRequests.isEmpty());    assertTrue("Removed commit for write req 3", processor.committedRequests.peek() == writeReq3);    assertTrue("Processed committed request", !processor.pendingRequests.isEmpty());    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq3.sessionId));    assertTrue("Missing write 3 in pending queue", processor.pendingRequests.get(writeReq3.sessionId).peek() == writeReq3);    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 3 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq3);    Request readReq3 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 7);    processor.queuedRequests.add(readReq3);    shouldBeProcessedAfterPending.add(readReq3);    Request writeReq4 = newRequest(new CreateRequest(path + "_4", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 7);    processor.queuedRequests.add(writeReq4);    processor.queuedWriteRequests.add(writeReq4);    processor.committedRequests.add(writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed unexpected committed request", !processor.committedRequests.isEmpty());    assertTrue("Unexpected pending request", processor.pendingRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 4 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
1e345be9cae630e9913117a549ebc5e26e8e49cd844a10b3da2e9494047cdf16
noStarvationOfNonLocalCommittedRequestsTest
public void noStarvationOfNonLocalCommittedRequestsTest() throws Exception
{    final String path = "/noStarvationOfCommittedRequests";    processor.queuedRequests = new MockRequestsQueue();    Set<Request> nonLocalCommits = new HashSet<Request>();    for (int i = 0; i < 10; i++) {        Request nonLocalCommitReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 51, i + 1);        processor.committedRequests.add(nonLocalCommitReq);        nonLocalCommits.add(nonLocalCommitReq);    }    for (int i = 0; i < 10; i++) {        processor.initThreads(defaultSizeOfThreadPool);        processor.stoppedMainLoop = true;        processor.run();    }    assertTrue("commit request was not processed", processedRequests.containsAll(nonLocalCommits));}
b08a9e75cc863f3c1b93487bda9f03688172a03bedcedd6edf33f0ea89ae1eae
noStarvationOfReadRequestsTest
public void noStarvationOfReadRequestsTest() throws Exception
{    final String path = "/noStarvationOfReadRequests";        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x3, 1);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    processor.committedRequests.add(firstCommittedReq);    Set<Request> allReads = new HashSet<Request>();        Request firstRead = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 0);    allReads.add(firstRead);    processor.queuedRequests.add(firstRead);        Request secondCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x99, 2);    processor.committedRequests.add(secondCommittedReq);    Set<Request> waitingCommittedRequests = new HashSet<Request>();        for (int writeReqId = 3; writeReqId < 102; ++writeReqId) {        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x8, writeReqId);        processor.committedRequests.add(writeReq);        waitingCommittedRequests.add(writeReq);    }        for (int readReqId = 1; readReqId <= 50; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x5, readReqId);        allReads.add(readReq);        processor.queuedRequests.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Did not process the first write request", processedRequests.contains(firstCommittedReq));    for (Request r : allReads) {        assertTrue("Processed read request", !processedRequests.contains(r));    }    processor.run();    assertTrue("did not processed all reads", processedRequests.containsAll(allReads));    assertTrue("Did not process the second write request", processedRequests.contains(secondCommittedReq));    for (Request r : waitingCommittedRequests) {        assertTrue("Processed additional committed request", !processedRequests.contains(r));    }}
0b6e9f716dc04f47d4dd9e261c2e306b46c67e44fc7d2479018d820e24b45d44
noCrashOnCommittedRequestsOfUnseenRequestTest
public void noCrashOnCommittedRequestsOfUnseenRequestTest() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnseenRequestTest";    final int numberofReads = 10;    final int sessionid = 0x123456;    final int firstCXid = 0x100;    int readReqId = firstCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, readReqId++);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    localRequests.add(firstCommittedReq);        for (; readReqId <= numberofReads + firstCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        assertTrue(processor.queuedRequests.containsAll(localRequests));    processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request preSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, firstCXid - 2);    processor.committedRequests.add(preSessionCommittedReq);    processor.committedRequests.add(firstCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.peek() == preSessionCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
aacb8e80c34dbc47e5e5bf982b83813abd6ab96cea7a213325cdaf6d3f1ca366
noCrashOnOutofOrderCommittedRequestTest
public void noCrashOnOutofOrderCommittedRequestTest() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnSeenRequestTest";    final int sessionid = 0x123456;    final int lastCXid = 0x100;    final int numberofReads = 10;    int readReqId = lastCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request orphanCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid);    processor.queuedRequests.add(orphanCommittedReq);    processor.queuedWriteRequests.add(orphanCommittedReq);    localRequests.add(orphanCommittedReq);        for (; readReqId <= numberofReads + lastCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request otherSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid + 10);    processor.committedRequests.add(otherSessionCommittedReq);    processor.committedRequests.add(orphanCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.size() == 1);    assertTrue(processedRequests.contains(otherSessionCommittedReq));    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    LOG.info("setup");    ServerMetrics.getMetrics().resetAll();        System.clearProperty("zookeeper.commitProcessor.maxReadBatchSize");    System.clearProperty("zookeeper.commitProcessor.maxCommitBatchSize");}
53c9018f4c076cc606afd32579f2ac1af1fbc7869f30e61da67866a14563bc35
setupProcessors
public void setupProcessors(int commitWorkers, int finalProcTime)
{    finalProcessor = new DummyFinalProcessor(finalProcTime);    commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);    commitProcessor.start();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("tearDown starting");    commitProcessor.shutdown();    commitProcessor.join();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    super.workerPool = new TestWorkerService(numWorkerThreads);    super.start();                                                        Thread.State state = super.getState();    while (state != State.WAITING) {        try {            Thread.sleep(50);        } catch (Exception e) {        }        state = super.getState();    }    LOG.info("numWorkerThreads in Test is {}", numWorkerThreads);}
f0ee54364cf015f7c6effae717a52184576477daf9c67a1b88cf3de288f43b19
endOfIteration
protected void endOfIteration()
{    if (requestProcessed != null) {        requestProcessed.countDown();    }}
bdaecb4de872c2fe5356b8050cf96897374b07f6f474c75d9a4facf747912154
waitForEmptyPool
protected void waitForEmptyPool() throws InterruptedException
{    if (commitSeen != null) {        commitSeen.countDown();    }    super.waitForEmptyPool();    if (poolEmpytied != null) {        poolEmpytied.countDown();    }}
dfe07bc1b05fd0bac7e895d43e8a56c88605051eb4648ef56026d05741021eb7
schedule
public void schedule(WorkRequest workRequest, long id)
{    super.schedule(workRequest, id);    if (requestScheduled != null) {        requestScheduled.countDown();    }}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{    if (processTime > 0) {        try {            if (commitSeen != null) {                commitSeen.await(5, TimeUnit.SECONDS);            }            Thread.sleep(processTime);        } catch (Exception e) {        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
fc605b7c27283dd4277f357196d647e7777e9010ecaa732bb850cfaf12b463f2
checkMetrics
private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals("expected min is " + min, min, values.get("min_" + metricName));    assertEquals("expected max is: " + max, max, values.get("max_" + metricName));    assertEquals("expected avg is: " + avg, avg, (Double) values.get("avg_" + metricName), 0.001);    assertEquals("expected cnt is: " + cnt, cnt, values.get("cnt_" + metricName));    assertEquals("expected sum is: " + sum, sum, values.get("sum_" + metricName));}
9431052279911ccde9a69a298135f97e5ccf728086ea4637dc3ecb842502886d
checkTimeMetric
private void checkTimeMetric(long actual, long lBoundrary, long hBoundrary)
{    assertThat(actual, greaterThanOrEqualTo(lBoundrary));    assertThat(actual, lessThanOrEqualTo(hBoundrary));}
eb4b1901d609ad7e2a6c06d6e9b2ca7dc22321cf1fe6aeadbdfb435e5a4df542
createReadRequest
private Request createReadRequest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.getData, ByteBuffer.wrap(new byte[10]), null);}
8789fe79c667da1d1d6c1364079192af2c4e0706f56e67203d9467ecc69edaa6
createWriteRequest
private Request createWriteRequest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
909c59c24cf592ed47c5fcdc1fa76017501c3ff8b2999ea5f977802c1cd19682
processRequestWithWait
private void processRequestWithWait(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.processRequest(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
247889905fb5494e218a12c797d72642ad8b4d90972502063bc00a569dc39376
commitWithWait
private void commitWithWait(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.commit(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
00beddea0231ff358ba1bc7dedd0d5d7a936284fad8f61bc816d14dea82acf01
testRequestsInSessionQueue
public void testRequestsInSessionQueue() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 1L, 1D, 1L, 1L);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    checkMetrics("requests_in_session_queue", 1L, 3L, 2D, 3L, 6);    commitWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 3L, 2.25D, 4L, 9);}
40486fd8ee4db59bb7ecdf61fa51e15b57a09f4e0901e4f17b88438177b56916
testWriteFinalProcTime
public void testWriteFinalProcTime() throws Exception
{    setupProcessors(0, 1000);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(0L, values.get("cnt_write_final_proc_time_ms"));    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_write_final_proc_time_ms"), 1000L, 2000L);}
c488f5a1504f2f001e55ee13faf5822c13b5b4db2700fda96594d545a96ce8fe
testReadFinalProcTime
public void testReadFinalProcTime() throws Exception
{    setupProcessors(0, 1000);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_read_final_proc_time_ms"), 1000L, 2000L);}
b2ef57ab828d02125be5e91b5046b6848af434854b6d155392abae285309ffcd
testCommitProcessTime
public void testCommitProcessTime() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_commit_process_time"));    checkTimeMetric((long) values.get("max_commit_process_time"), 0L, 1000L);}
98d5cd3395184d2a394065b53b0c1df62fde1369dac9bb278df7e9fafe12f1e8
testServerWriteCommittedTime
public void testServerWriteCommittedTime() throws Exception
{    setupProcessors(0, 0);        commitWithWait(createWriteRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_server_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_server_write_committed_time_ms"), 0L, 1000L);}
124f07f61c5aee5d916813245eae78e3c2665d83560402bd0984b002efe0fef8
testLocalWriteCommittedTime
public void testLocalWriteCommittedTime() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);}
51339180e5ed7e013f3c5dfff5c48ed20910232b2f9ac0e2cae0e392166ed574
testWriteCommitProcTime
public void testWriteCommitProcTime() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);        Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 1000L, 2000L);}
bc4add925a738b0f06778ece587e85ec6b8c3f29b78d1b5614be56a9b4852c5e
testReadCommitProcTime
public void testReadCommitProcTime() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 0L, 1000L);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    processRequestWithWait(createReadRequest(1L, 3));        Thread.sleep(1000);    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 1000L, 2000L);}
b8f3d46978e7e3a12aafd69acd4ab306fc9330b8d39de00b38b509d470cd4edb
testTimeWaitingEmptyPoolInCommitProcessorRead
public void testTimeWaitingEmptyPoolInCommitProcessorRead() throws Exception
{    setupProcessors(1, 1000);        requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(0L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(2L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);    long actual = (long) MetricsUtils.currentServerMetrics().get("max_time_waiting_empty_pool_in_commit_processor_read_ms");        checkTimeMetric(actual, 2500L, 3500L);}
d7477f3dc01cb5e2f4079dc61d5b25cabe18e3b325ef2a730018043a1e656a17
testConcurrentRequestProcessingInCommitProcessor
public void testConcurrentRequestProcessingInCommitProcessor() throws Exception
{    setupProcessors(3, 1000);        commitSeen = new CountDownLatch(1);    requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(1L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(1L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_concurrent_request_processing_in_commit_processor"));}
f0a98804a3e1f0f0c715c805218563214c60757f4a10797b61bc601a1d86d769
testReadsAfterWriteInSessionQueue
public void testReadsAfterWriteInSessionQueue() throws Exception
{    setupProcessors(0, 0);        processRequestWithWait(createReadRequest(1L, 1));        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    processRequestWithWait(createReadRequest(1L, 4));        commitWithWait(req1);    checkMetrics("reads_after_write_in_session_queue", 3L, 3L, 3d, 1, 3);}
eebb639393a9d97ae7a687f7d09e9819c93a4455e865db6dfe11d80253257d1b
testReadsQueuedInCommitProcessor
public void testReadsQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    processRequestWithWait(createReadRequest(1L, 2));        checkMetrics("read_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
3f41d0e5ecef2913dae3975999e2b1a7fb15c390dc901625a6b87f0381b19d9a
testWritesQueuedInCommitProcessor
public void testWritesQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req1);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.6667d, 3, 5);    commitWithWait(req2);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 4, 6);            processRequestWithWait(createReadRequest(1L, 1));    checkMetrics("write_commit_proc_req_queued", 0L, 2L, 1.2d, 5, 6);}
ab9e8f0e31d23fc9839faafc2ffa3ae68c6ad9af97cf6246a2b6d3859e2cfbf6
testCommitsQueuedInCommitProcessor
public void testCommitsQueuedInCommitProcessor() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));        checkMetrics("commit_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
b0126ec5854288068ca273949564c0b3ddf51870aad8c4df95ca64e16337def0
testCommitsQueued
public void testCommitsQueued() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) values.get("request_commit_queued"));}
894b8422990fcccb2c5247d4ce72b2bab1eb07fff349859bc60befeba0192960
testPendingSessionQueueSize
public void testPendingSessionQueueSize() throws Exception
{    setupProcessors(0, 0);        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        Request req2 = createWriteRequest(2L, 2);    processRequestWithWait(req2);    Request req3 = createWriteRequest(2L, 3);    processRequestWithWait(req3);    commitWithWait(req1);        checkMetrics("pending_session_queue_size", 2L, 2L, 2d, 1, 2);    commitWithWait(req2);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req3);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.333d, 3, 4);}
76ce576baaa3ec6f16902725029039e4a6379f6a9e15c3fde2615e90633812b9
setUp
public void setUp(int numCommitThreads, int numClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < numClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }}
6c74d8402782924de00862a8724e0c6777a4d95c83c77b314434067e19f5226d
setUp
public void setUp(int numCommitThreads, int numReadOnlyClientThreads, int mixWorkloadClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < mixWorkloadClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }    for (int i = 0; i < numReadOnlyClientThreads; ++i) {        TestClientThread client = new TestClientThread(0);        testClients.add(client);        client.start();    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("tearDown starting");    stopped = true;    zks.shutdown();    for (TestClientThread client : testClients) {        client.interrupt();        client.join();    }    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), ClientBase.recursiveDelete(tmpDir));    }    processedReadRequests.set(0);    processedWriteRequests.set(0);    testClients.clear();    commitProcessor.join();}
b26e78dd4e299ac11807b843e18ee0c5bafc241acb2033e3e545b8721442b781
sendWriteRequest
public void sendWriteRequest() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createReq = new CreateRequest("/session" + Long.toHexString(sessionId) + "-" + (++nodeId), new byte[0], Ids.OPEN_ACL_UNSAFE, 1);    createReq.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.create, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
922e381f3b46d2f70aea55121c72f8a29f958253ef6f72539d385879d2ca2a2a
sendReadRequest
public void sendReadRequest() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest("/session" + Long.toHexString(sessionId) + "-" + nodeId, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.getData, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Random rand = new Random(Thread.currentThread().getId());    try {        sendWriteRequest();        while (!stopped) {            if (rand.nextInt(100) < writePercent) {                sendWriteRequest();            } else {                sendReadRequest();            }            Thread.sleep(5 + rand.nextInt(95));        }    } catch (Exception e) {        LOG.error("Uncaught exception in test: ", e);    }}
bb2a65cd23713a61be3ccc8bf919e285ce2fc9ba357ca6803544e33fb7211c1f
testNoCommitWorkersReadOnlyWorkload
public void testNoCommitWorkersReadOnlyWorkload() throws Exception
{    int numClients = 10;    LOG.info("testNoCommitWorkersReadOnlyWorkload");    setUp(0, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
2db2010874a3bd94f81662ef29f05926358496dc5cef3e848fa282f218f46794
testNoCommitWorkersMixedWorkload
public void testNoCommitWorkersMixedWorkload() throws Exception
{    int numClients = 10;    LOG.info("testNoCommitWorkersMixedWorkload 25w/75r workload test");    setUp(0, numClients, 25);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
20c37f1889857c124b451b540d2c861785aa17184773b030e456faa9cf25d603
testOneCommitWorkerReadOnlyWorkload
public void testOneCommitWorkerReadOnlyWorkload() throws Exception
{    int numClients = 10;    LOG.info("testOneCommitWorkerReadOnlyWorkload");    setUp(1, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
6569496c5c86c5735764bff6069d0943c07b14ec7bf63be5510741052f9240c9
testOneCommitWorkerMixedWorkload
public void testOneCommitWorkerMixedWorkload() throws Exception
{    setUp(1, 10, 25);    LOG.info("testOneCommitWorkerMixedWorkload 25w/75r workload test");    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
6b076e4ce4d1c167421edcde093a854affe7d1b9e8a0a1fee4043b6678b30d31
testManyCommitWorkersReadOnly
public void testManyCommitWorkersReadOnly() throws Exception
{    int numClients = 10;    LOG.info("testManyCommitWorkersReadOnly");    setUp(10, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
b6801831d4dcacaed82f7ed8cf646968140b95b1fbd702414ff8086bd484ab00
testManyCommitWorkersMixedWorkload
public void testManyCommitWorkersMixedWorkload() throws Exception
{    setUp(16, 8, 8, 25);    LOG.info("testManyCommitWorkersMixedWorkload 8X0w/100r + 8X25w/75r workload test");    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
11528f38b46cb22362ba67228d1ef22de0fe92b86a8cd10d419f2b0e7aeb02af
checkProcessedRequest
private void checkProcessedRequest()
{    assertTrue("No read requests processed", processedReadRequests.get() > 0);    assertTrue("No write requests processed", processedWriteRequests.get() > 0);}
657528b7574cdc2a143833d76afb10f51045734f4e99b4eeb55d783b0a64b6a4
failTest
private synchronized void failTest(String reason)
{    fail = true;    notifyAll();    fail(reason);}
32707d392503f18691de84e802a31ab95ae8c30ea0843864322c902b03e69030
getFirstProcessor
public PrepRequestProcessor getFirstProcessor()
{    return (PrepRequestProcessor) firstProcessor;}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(zks);            ValidateProcessor validateProcessor = new ValidateProcessor(finalProcessor);    commitProcessor = new CommitProcessor(validateProcessor, "1", true, null);    validateProcessor.setCommitProcessor(commitProcessor);    commitProcessor.start();    MockProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(commitProcessor);    proposalProcessor.start();    firstProcessor = new PrepRequestProcessor(zks, proposalProcessor);    getFirstProcessor().start();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Random rand = new Random(Thread.currentThread().getId());    try {        while (true) {                        if (!proposals.isEmpty()) {                Request request = proposals.take();                Thread.sleep(5 + rand.nextInt(95));                commitProcessor.commit(request);            }        }    } catch (InterruptedException e) {        }}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    commitProcessor.processRequest(request);    if (request.getHdr() != null) {                proposals.add(request);    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("shutdown MockProposalRequestProcessor");    proposals.clear();    if (commitProcessor != null) {        commitProcessor.shutdown();    }}
19f289422912a2d1619764f41af5ea53adf7203664fd64624daaf86b05135567
setCommitProcessor
public void setCommitProcessor(CommitProcessor commitProcessor)
{    this.commitProcessor = commitProcessor;}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    if (stopped) {        return;    }    if (request.type == OpCode.closeSession) {        LOG.debug("ValidateProcessor got closeSession request=" + request);        nextProcessor.processRequest(request);        return;    }    boolean isWriteRequest = commitProcessor.needCommit(request);    if (isWriteRequest) {        outstandingWriteRequests.incrementAndGet();        validateWriteRequestVariant(request);        LOG.debug("Starting write request zxid={}", request.zxid);    } else {        LOG.debug("Starting read request cxid={} for session 0x{}", request.cxid, Long.toHexString(request.sessionId));        outstandingReadRequests.incrementAndGet();        validateReadRequestVariant(request);    }        try {        Thread.sleep(5 + rand.nextInt(25));    } catch (InterruptedException e) {        }    nextProcessor.processRequest(request);    /*             * The commit workers will have to execute this line before they             * wake up the commit processor. So this value is up-to-date when             * variant check is performed             */    if (isWriteRequest) {        outstandingWriteRequests.decrementAndGet();        LOG.debug("Done write request zxid={}", request.zxid);        processedWriteRequests.incrementAndGet();    } else {        outstandingReadRequests.decrementAndGet();        LOG.debug("Done read request cxid={} for session 0x{}", request.cxid, Long.toHexString(request.sessionId));        processedReadRequests.incrementAndGet();    }    validateRequest(request);}
713d76aa82eeac423fce1f9e96fd991d54d6cbaa7b83207d560ae56175721923
validateWriteRequestVariant
private void validateWriteRequestVariant(Request request)
{    if (stopped) {        return;    }    long zxid = request.getHdr().getZxid();    int readRequests = outstandingReadRequests.get();    if (readRequests != 0) {        failTest("There are " + readRequests + " outstanding" + " read requests while issuing a write request zxid=" + zxid);    }    int writeRequests = outstandingWriteRequests.get();    if (writeRequests > 1) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a write request zxid=" + zxid + " (expected one)");    }}
ecdba06eb91610a8abf6d52c7e9173fd7491b25ed6fb44fd9ec199b5b9d296de
validateReadRequestVariant
private void validateReadRequestVariant(Request request)
{    int writeRequests = outstandingWriteRequests.get();    if (writeRequests != 0) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a read request cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId));    }}
1241049b046134fbc677ac3216d6df35fe1af19a057e0980f7cdf764e51c9c17
validateRequest
private void validateRequest(Request request)
{    if (LOG.isDebugEnabled()) {        LOG.debug("Got request " + request);    }        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        if (!expectedZxid.compareAndSet(zxid, zxid + 1)) {            failTest("Write request, expected_zxid=" + expectedZxid.get() + "; req_zxid=" + zxid);        }    }        AtomicInteger sessionCxid = cxidMap.get(request.sessionId);    if (sessionCxid == null) {        sessionCxid = new AtomicInteger(request.cxid + 1);        AtomicInteger existingSessionCxid = cxidMap.putIfAbsent(request.sessionId, sessionCxid);        if (existingSessionCxid != null) {            failTest("Race condition adding cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId) + " with other_cxid=" + existingSessionCxid.get());        }    } else {        if (!sessionCxid.compareAndSet(request.cxid, request.cxid + 1)) {            failTest("Expected_cxid=" + sessionCxid.get() + "; req_cxid=" + request.cxid);        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    LOG.info("shutdown validateReadRequestVariant");    cxidMap.clear();    expectedZxid = new AtomicLong(1);    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{    if (blocking) {        incomingRequests.add(request);    } else {        next.processRequest(request);    }}
1f5238443b3acca33dbdd313e931e59b7ee4b140541a09bedd0a277acf25e15f
submitRequest
public void submitRequest(Request request) throws RequestProcessorException
{    next.processRequest(request);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
081d0f84a39d5bc2673b9c24e340c27d1aff75838dcccc129edc416645620a0e
unblockQueue
public void unblockQueue() throws RequestProcessorException
{    if (blocking) {        for (Request request : incomingRequests) {            next.processRequest(request);        }        blocking = false;    }}
db081eb4339aded1262e1b55c378787cd63a403390c8a8ec10ee2690362b93e5
injectDelayRequestProcessor
public static DelayRequestProcessor injectDelayRequestProcessor(FollowerZooKeeperServer zooKeeperServer)
{    RequestProcessor finalRequestProcessor = zooKeeperServer.commitProcessor.nextProcessor;    DelayRequestProcessor delayRequestProcessor = new DelayRequestProcessor(finalRequestProcessor);    zooKeeperServer.commitProcessor.nextProcessor = delayRequestProcessor;    return delayRequestProcessor;}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING, true }, { ServerState.LEADING, false }, { ServerState.FOLLOWING, true }, { ServerState.FOLLOWING, false }, { ServerState.OBSERVING, true }, { ServerState.OBSERVING, false } });}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    ensureCheck(checkEnabled);    CountdownWatcher clientWatch = new CountdownWatcher();    CountdownWatcher clientWatchB = new CountdownWatcher();    super.setUp(true);    String hostPort = getPeersMatching(serverState).split(",")[0];    int clientPort = Integer.parseInt(hostPort.split(":")[1]);    zkLeader = getPeerList().get(getLeaderIndex());    connectedServer = getPeerByClientPort(clientPort).getActiveServer();    zkClient = createClient(clientWatch, hostPort);    zkClientB = createClient(clientWatchB, hostPort);    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    zkClientB.addAuthInfo(AUTH_PROVIDER, AUTHB);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);    clientWatchB.waitForConnected(CONNECTION_TIMEOUT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (zkClient != null) {        zkClient.close();    }    if (zkClientB != null) {        zkClientB.close();    }    super.tearDown();}
8de3b69eaadb26d106c2756d783a787261e50fb9d4ce43f69f878b9a60685818
ensureCheck
private void ensureCheck(boolean enabled)
{    if (enabled) {        System.setProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK, "true");    } else {        System.clearProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK);    }}
03acb90f2e165a6c202e4d6372bab3725ddb0a739beabf51a7f71f38fedf5f6b
assertTransactionState
private void assertTransactionState(String condition, long lastxid)
{    String assertion = String.format("Server State: %s Check Enabled: %s %s", serverState, checkEnabled, condition);    if (checkEnabled) {        assertEquals(assertion, lastxid, zkLeader.getLastLoggedZxid());    } else {        assertNotSame(assertion, lastxid, zkLeader.getLastLoggedZxid());    }}
dc12d3ee487fb383351a582aa9151051b22a119e205d55c14b92e952ad9d4c74
testCreateOK
public void testCreateOK() throws Exception
{    ensureCheck(true);    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
2c625b6a20743d325697ee8e5eea68cfb3a263b46a1239ab64cb2ebf7cb7eb30
testCreate2OK
public void testCreate2OK() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
cb88df6af560114eb261f4b813037167f46aaaf25618cfb3528692cc7915f3b9
testCreateFail
public void testCreateFail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create", lastxid);}
be50a34836d8884439380adecfa516dd940fd08954c7514b93ea631195e187b8
testCreate2Fail
public void testCreate2Fail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create2", lastxid);}
1a9e6e40bae2d38f291e0bfce9a04318076198e96932c2f5e82828e4c38a2df7
testDeleteOK
public void testDeleteOK() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.delete(PARENT_PATH, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
03e39ba9f4abd96d08bcfe57b93ebe65e57163358cc86959ca74103ac32da478
testDeleteFail
public void testDeleteFail() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    zkClient.create(CHILD_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.delete(CHILD_PATH, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed delete", lastxid);}
07ebe608bbe743c48e89c4ca28988b55f1e71dd6989e07ecf1e0eef05dfc0bee
testSetDataOK
public void testSetDataOK() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setData(PARENT_PATH, DATA, -1);}
60e48f212e106b15aa9891f03b21aab63213be97dacfc64821a17fd2096c3a0a
testSetDataFail
public void testSetDataFail() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setData(PARENT_PATH, DATA, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setData", lastxid);}
bc428fd7ef3fdc17e4258517f3402fdfea95edecdff8bfae5f9731f6c14a68e9
testSetACLOK
public void testSetACLOK() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
499a9e096ddac1f4aef97f58582f652a572d3c80c5ecec31f58b574cd556a971
testSetACLFail
public void testSetACLFail() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setACL", lastxid);}
68cd3683dd33a55641079f07e155132a0744200660ade20cd4483f6b11816885
testBadACL
public void testBadACL() throws Exception
{    CountdownWatcher cw = new CountdownWatcher();    TestableZooKeeper zk = createClient(cw, getPeersMatching(serverState));    long lastxid;    cw.waitForConnected(CONNECTION_TIMEOUT);    lastxid = zkLeader.getLastLoggedZxid();    try {        zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have received an invalid acl error");    } catch (KeeperException.InvalidACLException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("zxid after invalid ACL", lastxid);}
2e3596cf9fccc93a3fe391897efc77165699f52733aa429bf0c1346f2ebff80a
testEphemeralNodeDeletion
public void testEphemeralNodeDeletion() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[1], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    /**     * now the problem scenario starts     */    Stat firstEphemeralNode = new Stat();        String nodePath = "/e1";    zk.create(nodePath, "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, firstEphemeralNode);    assertEquals("Current session and ephemeral owner should be same", zk.getSessionId(), firstEphemeralNode.getEphemeralOwner());        CustomQuorumPeer follower = (CustomQuorumPeer) getByServerState(mt, ServerState.FOLLOWING);    follower.setInjectError(true);        zk.close();        follower.setInjectError(false);    assertTrue("Faulted Follower should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + follower.getClientPort(), CONNECTION_TIMEOUT));    QuorumPeer leader = getByServerState(mt, ServerState.LEADING);    assertNotNull("Leader should not be null", leader);    assertTrue("Leader must be running", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    watch = new CountdownWatcher();    zk = new ZooKeeper("127.0.0.1:" + leader.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat exists = zk.exists(nodePath, false);    assertNull("Node must have been deleted from leader", exists);    CountdownWatcher followerWatch = new CountdownWatcher();    ZooKeeper followerZK = new ZooKeeper("127.0.0.1:" + follower.getClientPort(), ClientBase.CONNECTION_TIMEOUT, followerWatch);    followerWatch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat nodeAtFollower = followerZK.exists(nodePath, false);        assertNull("ephemeral node must not exist", nodeAtFollower);        Stat currentEphemeralNode = new Stat();    zk.create(nodePath, "2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, currentEphemeralNode);        zk.close();    SyncCallback cb = new SyncCallback();    followerZK.sync(nodePath, cb, null);    cb.sync.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    nodeAtFollower = followerZK.exists(nodePath, false);                assertNull("After session close ephemeral node must be deleted", nodeAtFollower);    followerZK.close();}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{        for (int i = 0; i < mt.length; i++) {        try {            mt[i].shutdown();        } catch (InterruptedException e) {            LOG.warn("Quorum Peer interrupted while shutting it down", e);        }    }}
8a9fab861b45297729dc895ac772bca4460834f9860f6af57b44f842c90f9d7b
getByServerState
private QuorumPeer getByServerState(MainThread[] mt, ServerState state)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && state == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void readPacket(QuorumPacket pp) throws IOException {            /**             * In real scenario got SocketTimeoutException while reading             * the packet from leader because of network problem, but             * here throwing SocketTimeoutException based on whether             * error is injected or not             */            super.readPacket(pp);            if (injectError && pp.getType() == Leader.PROPOSAL) {                String type = LearnerHandler.packetToString(pp);                throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);            }        }    };}
0b2d868df21f605241f9aa5bf7167efe13965fa9632ba25c4a53608aff82bf36
readPacket
 void readPacket(QuorumPacket pp) throws IOException
{    /**     * In real scenario got SocketTimeoutException while reading     * the packet from leader because of network problem, but     * here throwing SocketTimeoutException based on whether     * error is injected or not     */    super.readPacket(pp);    if (injectError && pp.getType() == Leader.PROPOSAL) {        String type = LearnerHandler.packetToString(pp);        throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);    }}
4c9ce1cac41cc7df0029a85108695c03adbf5872a4b9686d6e674b7e9ad5ec21
setInjectError
public void setInjectError(boolean injectError)
{    this.injectError = injectError;}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer();}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    sync.countDown();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];    cnxManagers = new QuorumCnxManager[count - 1];}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < (count - 1); i++) {        if (cnxManagers[i] != null) {            cnxManagers[i].halt();        }    }}
fdcefc85107630aed847da809b49058e88457917dc2826fcfd7f2579b8d8b47e
testBackwardElectionRound
public void testBackwardElectionRound() throws Exception
{    LOG.info("TestLE: {}, {}", getTestName(), count);    for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    ByteBuffer initialMsg0 = getMsg();    ByteBuffer initialMsg1 = getMsg();    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Start mock server 1         */    QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    cnxManagers[0] = mockPeer.createCnxnManager();    cnxManagers[0].listener.start();    cnxManagers[0].toSend(0L, initialMsg0);    /*         * Start mock server 2         */    mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2, 2);    cnxManagers[1] = mockPeer.createCnxnManager();    cnxManagers[1].listener.start();    cnxManagers[1].toSend(0L, initialMsg1);    /*         * Run another instance of leader election.         */    thread.join(5000);    thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Send the same messages, this time should not make 0 the leader.         */    cnxManagers[0].toSend(0L, initialMsg0);    cnxManagers[1].toSend(0L, initialMsg1);    thread.join(5000);    if (!thread.isAlive()) {        fail("Should not have joined");    }}
c15c852c65577e021695b6186ab55159ba280f67ddc8a3963aef967a3d7aabbb
getMsg
private ByteBuffer getMsg()
{    return FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 0, 0, 1);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    cnxManager.halt();}
f6f564c7fc03cf8bc2e97621cdadf6dabf5878de04cb8ef06cf3aa5d3de11ad9
testLostMessage
public void testLostMessage() throws Exception
{    LOG.info("TestLE: {}, {}", getTestName(), count);    for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 1);    thread.start();    /*         * Start mock server 1         */    mockServer();    thread.join(5000);    if (thread.isAlive()) {        fail("Threads didn't join");    }}
bdbd1dbe3975991e6e5fac0bdc2623f659ee9a31d35f0fe68e801a84419577ae
mockServer
 void mockServer() throws InterruptedException, IOException
{    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    cnxManager = peer.createCnxnManager();    cnxManager.listener.start();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.LOOKING.ordinal(), 0, 0, 0));    cnxManager.recvQueue.take();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 1, 0, 0));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    for (int i = 0; i < 5; i++) {        peers.put(Long.valueOf(i), new QuorumServer(Long.valueOf(i), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir, tmpdir, PortAssignment.unique(), 3, 3, 1000, 2, 2, 2);    fle = new FastLeaderElection(peer, peer.createCnxnManager());}
63b4fe5fc42148da0ad36e82e46d963c5ac0357493e778f82502361e341ed7a5
testIgnoringZxidElectionEpoch
public void testIgnoringZxidElectionEpoch()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 2, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 2), 1, 2, ServerState.FOLLOWING));    votes.put(3L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
0bda101bffacb0ab511a8afe7bb7e6d663be1becba6388453c889fdef9a2fe26
testElectionWIthDifferentVersion
public void testElectionWIthDifferentVersion()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
81ed73b12d1715e7003b12f5b4a39c03fd51dea68a192ec81a5149b9c41f084d
testLookingNormal
public void testLookingNormal()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING)).hasAllQuorums());}
a88e47b083c164a39305db8d728ad6eb2f9803f3eb2b45d21b96a4ec006feae6
testLookingDiffRounds
public void testLookingDiffRounds()
{    HashMap<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LEADING));    assertFalse(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING)).hasAllQuorums());}
59eaffc4fa6deea2dc94309f6e07ddcb9768df5512cdeb429e8d7b1d793750e4
testOutofElection
public void testOutofElection()
{    HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();    outofelection.put(1L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(2L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(4L, new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.FOLLOWING));    Vote vote = new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.LEADING);    outofelection.put(5L, vote);    Notification n = new Notification();    n.version = vote.getVersion();    n.leader = vote.getId();    n.zxid = vote.getZxid();    n.electionEpoch = vote.getElectionEpoch();    n.state = vote.getState();    n.peerEpoch = vote.getPeerEpoch();    n.sid = 5L;        fle.logicalclock.set(0x1);    assertTrue("Quorum check failed", fle.getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state)).hasAllQuorums());    assertTrue("Leader check failed", fle.checkLeader(outofelection, n.leader, n.electionEpoch));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Vote v = null;        peer.setPeerState(ServerState.LOOKING);        LOG.info("Going to call leader election: {}", i);        v = peer.getElectionAlg().lookForLeader();        if (v == null) {            fail("Thread " + i + " got a null vote");        }        /*                 * A real zookeeper would take care of setting the current vote. Here                 * we do it manually.                 */        peer.setCurrentVote(v);        LOG.info("Finished election: {}, {}", i, v.getId());        assertTrue("State is not leading.", peer.getPeerState() == ServerState.LEADING);    } catch (Exception e) {        e.printStackTrace();    }    LOG.info("Joining");}
060df0174368ca0f27d922045019a8ce1bafd0003993ab800888bd47ea2b4c74
createMsg
 static ByteBuffer createMsg(int state, long leader, long zxid, long epoch)
{    return FastLeaderElection.buildMsg(state, leader, zxid, 1, epoch);}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    LOG.info("Start up a 3 server quorum");    final int ENSEMBLE_SERVERS = 3;    clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        mt = new MainThread[ENSEMBLE_SERVERS];    zk = new ZooKeeper[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain();            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    QuorumPeerMainTest.waitForAll(zk, States.CONNECTED);    LOG.info("all servers started");    leaderId = -1;    followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (mt != null) {        for (MainThread t : mt) {            t.shutdown();        }    }    if (zk != null) {        for (ZooKeeper z : zk) {            z.close();        }    }}
0f80fe7db944fe5cb12392bdc3389a3dbab99d1915bd28932cd55f47d89d1e8b
testMultiOpConsistency
public void testMultiOpConsistency() throws Exception
{    LOG.info("Create a parent node");    final String path = "/testMultiOpConsistency";    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);    LOG.info("Hook to catch the 2nd sub create node txn in multi-op");    CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();    final ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    String node1 = path + "/1";    String node2 = path + "/2";    dt.addNodeCreateListener(node2, new NodeCreateListener() {        @Override        public void process(String path) {            LOG.info("Take a snapshot");            zkServer.takeSnapshot(true);        }    });    LOG.info("Issue a multi op to create 2 nodes");    zk[followerA].multi(Arrays.asList(Op.create(node1, node1.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(node2, node2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    LOG.info("Restart the server");    mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);    LOG.info("Make sure the node consistent with leader");    assertEquals(new String(zk[leaderId].getData(node2, null, null)), new String(zk[followerA].getData(node2, null, null)));}
da571ed922198072d7064ff4378bcb6fd441162af5344f362d9986e2f5c5ebda
process
public void process(String path)
{    LOG.info("Take a snapshot");    zkServer.takeSnapshot(true);}
13db25285ce6f9c82661a24f6ced7c7dbf00e5d6fb65eaffa9851973d5665970
testPZxidUpdatedDuringSnapSyncing
public void testPZxidUpdatedDuringSnapSyncing() throws Exception
{    LOG.info("Enable force snapshot sync");    System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");    final String parent = "/testPZxidUpdatedWhenDeletingNonExistNode";    final String child = parent + "/child";    createEmptyNode(zk[leaderId], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[leaderId], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);    LOG.info("shutdown follower {}", followerA);    mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    LOG.info("Set up ZKDatabase to catch the node serializing in DataTree");    addSerializeListener(leaderId, parent, child);    LOG.info("Restart follower A to trigger a SNAP sync with leader");    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);    LOG.info("Check and make sure the pzxid of the parent is the same " + "on leader and follower A");    compareStat(parent, leaderId, followerA);}
c04086c87c694a9f45e551c311cb033b22672fc9a640b5b8691bd123304128c6
testPZxidUpdatedWhenLoadingSnapshot
public void testPZxidUpdatedWhenLoadingSnapshot() throws Exception
{    final String parent = "/testPZxidUpdatedDuringTakingSnapshot";    final String child = parent + "/child";    createEmptyNode(zk[followerA], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[followerA], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);    LOG.info("Set up ZKDatabase to catch the node serializing in DataTree");    addSerializeListener(followerA, parent, child);    LOG.info("Take snapshot on follower A");    ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    zkServer.takeSnapshot(true);    LOG.info("Restarting follower A to load snapshot");    mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CLOSED);    mt[followerA].start();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);    LOG.info("Check and make sure the pzxid of the parent is the same " + "on leader and follower A");    compareStat(parent, leaderId, followerA);}
6af699d75068e8c82a7f31e25d825c7475431ccbfed1621b733b12e7aaf901ac
addSerializeListener
private void addSerializeListener(int sid, String parent, String child)
{    final ZooKeeper zkClient = zk[sid];    CustomDataTree dt = (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();    dt.addListener(parent, new NodeSerializeListener() {        @Override        public void nodeSerialized(String path) {            try {                zkClient.delete(child, -1);                zkClient.close();                LOG.info("Deleted the child node after the parent is serialized");            } catch (Exception e) {                LOG.error("Error when deleting node {}", e);            }        }    });}
de5c9a2d44aa220f4c4926dcac3ac6e6bea21acee69037a5986ae965fbf1c184
nodeSerialized
public void nodeSerialized(String path)
{    try {        zkClient.delete(child, -1);        zkClient.close();        LOG.info("Deleted the child node after the parent is serialized");    } catch (Exception e) {        LOG.error("Error when deleting node {}", e);    }}
d6b29f0607f4591627b189d950f363bfc0ffa6a75b68f66464f7b8e6808b64c2
compareStat
private void compareStat(String path, int sid, int compareWithSid) throws Exception
{    ZooKeeper[] compareZk = new ZooKeeper[2];    compareZk[0] = new ZooKeeper("127.0.0.1:" + clientPorts[sid], ClientBase.CONNECTION_TIMEOUT, this);    compareZk[1] = new ZooKeeper("127.0.0.1:" + clientPorts[compareWithSid], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForAll(compareZk, States.CONNECTED);    try {        Stat stat1 = new Stat();        compareZk[0].getData(path, null, stat1);        Stat stat2 = new Stat();        compareZk[1].getData(path, null, stat2);        assertEquals(stat1, stat2);    } finally {        for (ZooKeeper z : compareZk) {            z.close();        }    }}
622982282b05541683057c198317a650554ed99bac7c568be15f660a04e313bc
testGlobalSessionConsistency
public void testGlobalSessionConsistency() throws Exception
{    LOG.info("Hook to catch the commitSession event on followerA");    CustomizedQPMain followerAMain = (CustomizedQPMain) mt[followerA].main;    final ZooKeeperServer zkServer = followerAMain.quorumPeer.getActiveServer();        final AtomicBoolean shouldTakeSnapshot = new AtomicBoolean(true);    followerAMain.setCommitSessionListener(new CommitSessionListener() {        @Override        public void process(long sessionId) {            LOG.info("Take snapshot");            if (shouldTakeSnapshot.getAndSet(false)) {                zkServer.takeSnapshot(true);            }        }    });    LOG.info("Create a global session");    ZooKeeper globalClient = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(globalClient, States.CONNECTED);    LOG.info("Restart followerA to load the data from disk");    mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);    LOG.info("Make sure the global sessions are consistent with leader");    Map<Long, Integer> globalSessionsOnLeader = mt[leaderId].main.quorumPeer.getZkDb().getSessionWithTimeOuts();    Map<Long, Integer> globalSessionsOnFollowerA = mt[followerA].main.quorumPeer.getZkDb().getSessionWithTimeOuts();    LOG.info("sessions are {}, {}", globalSessionsOnLeader.keySet(), globalSessionsOnFollowerA.keySet());    assertTrue(globalSessionsOnFollowerA.keySet().containsAll(globalSessionsOnLeader.keySet()));}
1b8083115103a2f8d0cc25dec4e61f790338869438d5a2fdbd89f0eb39d44d50
process
public void process(long sessionId)
{    LOG.info("Take snapshot");    if (shouldTakeSnapshot.getAndSet(false)) {        zkServer.takeSnapshot(true);    }}
338729f8556899fec593478808a59d174ea72baa61241bb7d2417cbdd33e020e
createEmptyNode
private void createEmptyNode(ZooKeeper zk, String path, CreateMode mode) throws Exception
{    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, mode);}
3e59049fc4996bb2f40ee1c904e6df94d654a1a685d1f6f3b3d1dce8c860892c
serializeNodeData
public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException
{    super.serializeNodeData(oa, path, node);    NodeSerializeListener listener = listeners.get(path);    if (listener != null) {        listener.nodeSerialized(path);    }}
10d8d41b17f9ea07d01ba2bd041654171cc60caeb0e035742cd3992f21b54515
addListener
public void addListener(String path, NodeSerializeListener listener)
{    listeners.put(path, listener);}
56a2faeb7efd961f9736ca782fbce5361a61bcbc304fe7b8a4ec451e14e1873c
createNode
public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws NoNodeException, NodeExistsException
{    NodeCreateListener listener = nodeCreateListeners.get(path);    if (listener != null) {        listener.process(path);    }    super.createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, outputStat);}
e24e892e5654be4179d46a66fd91bbaf2a4189a89b2be46743243d93f7a3195a
addNodeCreateListener
public void addNodeCreateListener(String path, NodeCreateListener listener)
{    nodeCreateListeners.put(path, listener);}
484130af3406e5e0205dcb2f3e4150deca422e21087e47eea1976a0f333409f9
setCommitSessionListener
public void setCommitSessionListener(CommitSessionListener listener)
{    this.commitSessionListener = listener;}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer() {        @Override        public void setZKDatabase(ZKDatabase database) {            super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {                @Override                public DataTree createDataTree() {                    return new CustomDataTree();                }            });        }        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {                @Override                public void createSessionTracker() {                    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                            if (commitSessionListener != null) {                                commitSessionListener.process(sessionId);                            }                            return super.commitSession(sessionId, sessionTimeout);                        }                    };                }            });        }    };}
8c22206dd430d77e6a82ac25e03d18439a5c76c922f706b7cae422dfdf36b700
setZKDatabase
public void setZKDatabase(ZKDatabase database)
{    super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {        @Override        public DataTree createDataTree() {            return new CustomDataTree();        }    });}
5a4fd48b2f1deb12201b5af56a1f389e22c90dc44f61f7c6c2e57de7cf3d3b51
createDataTree
public DataTree createDataTree()
{    return new CustomDataTree();}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        public void createSessionTracker() {            sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                    if (commitSessionListener != null) {                        commitSessionListener.process(sessionId);                    }                    return super.commitSession(sessionId, sessionTimeout);                }            };        }    });}
a6fb3fd47d2002c10e5c5307384249f559df942b1ae57f305136a504c7f36ca4
createSessionTracker
public void createSessionTracker()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {            if (commitSessionListener != null) {                commitSessionListener.process(sessionId);            }            return super.commitSession(sessionId, sessionTimeout);        }    };}
4a19be9b5864bc17252345f8308f0f92216a0527e01bac5454ee28ac731700f8
commitSession
public synchronized boolean commitSession(long sessionId, int sessionTimeout)
{    if (commitSessionListener != null) {        commitSessionListener.process(sessionId);    }    return super.commitSession(sessionId, sessionTimeout);}
69cc8d7cafba245341e4862bc26869b0c43788efefad2d001c539589ef0e31c1
setUp
public void setUp() throws IOException, X509Exception
{    qp = new QuorumPeer();    long myId = qp.getId();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    quorumVerifierMock = mock(QuorumVerifier.class);    when(quorumVerifierMock.getAllMembers()).thenReturn(peersView);    qp.setQuorumVerifier(quorumVerifierMock, false);    File tmpDir = ClientBase.createEmptyTestDir();    fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZKDatabase zkDb = new ZKDatabase(fileTxnSnapLog);    zks = new LeaderZooKeeperServer(fileTxnSnapLog, qp, zkDb);    leader = new Leader(qp, zks);    leaderBean = new LeaderBean(leader, zks);}
b15ec24534831cd8187de4c70ba4518879af91358fd307c4f306a42afcccad2c
tearDown
public void tearDown() throws IOException
{    fileTxnSnapLog.close();}
dca02782fc3b49ba13aca6d743727930fb9cc1d2dd96252b8a57778e695a22db
testGetName
public void testGetName()
{    assertEquals("Leader", leaderBean.getName());}
00269b50e2245c3f6653167d3a4634181891d492393cebf813459eef8d10c24f
testGetCurrentZxid
public void testGetCurrentZxid()
{        zks.setZxid(1);        assertEquals("0x1", leaderBean.getCurrentZxid());}
a5c1fc95f5c9b583cdd5e0527620e1daf393ccd18c591c834f63bcce3dc415c5
testGetElectionTimeTaken
public void testGetElectionTimeTaken()
{        qp.setElectionTimeTaken(1);        assertEquals(1, leaderBean.getElectionTimeTaken());}
68799f8547402fa764fe0118500d3cb9d0df688ca3e1658908fb338c61451b69
testGetProposalSize
public void testGetProposalSize() throws IOException, Leader.XidRolloverException
{        Request req = createMockRequest();        leader.propose(req);        byte[] data = SerializeUtils.serializeRequest(req);    assertEquals(data.length, leaderBean.getLastProposalSize());    assertEquals(data.length, leaderBean.getMinProposalSize());    assertEquals(data.length, leaderBean.getMaxProposalSize());}
d4948e0607a5232323968d11b40e1fe2c6edcdb9523ddedc35e4cbf349d62633
testResetProposalStats
public void testResetProposalStats() throws IOException, Leader.XidRolloverException
{        int initialProposalSize = leaderBean.getLastProposalSize();    Request req = createMockRequest();        leader.propose(req);        assertNotEquals(initialProposalSize, leaderBean.getLastProposalSize());    leaderBean.resetProposalStatistics();    assertEquals(initialProposalSize, leaderBean.getLastProposalSize());    assertEquals(initialProposalSize, leaderBean.getMinProposalSize());    assertEquals(initialProposalSize, leaderBean.getMaxProposalSize());}
c428ad185796293aea5c4a0154871bbb86cc9f96815c6538ec150bf5d6a51e46
createMockRequest
private Request createMockRequest() throws IOException
{    TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    return new Request(1, 2, 3, header, txn, 4);}
ca2a9e4c867042d3d767960a38b0319d682d7859dce060976f7d87729e5d9387
answer
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
ca2a9e4c867042d3d767960a38b0319d682d7859dce060976f7d87729e5d9387
answer
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
8ef1510680bda24dec090eb239236405e06c50d8b8138295263216a7056a701a
testFollowerInfo
public void testFollowerInfo() throws IOException
{    Map<Long, QuorumServer> votingMembers = new HashMap<Long, QuorumServer>();    votingMembers.put(1L, null);    votingMembers.put(2L, null);    votingMembers.put(3L, null);    when(quorumVerifierMock.getVotingMembers()).thenReturn(votingMembers);    LearnerHandler follower = mock(LearnerHandler.class);    when(follower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(follower.toString()).thenReturn("1");    when(follower.getSid()).thenReturn(1L);    leader.addLearnerHandler(follower);    leader.addForwardingFollower(follower);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler observer = mock(LearnerHandler.class);    when(observer.getLearnerType()).thenReturn(LearnerType.OBSERVER);    when(observer.toString()).thenReturn("2");    leader.addLearnerHandler(observer);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler nonVotingFollower = mock(LearnerHandler.class);    when(nonVotingFollower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(nonVotingFollower.toString()).thenReturn("5");    when(nonVotingFollower.getSid()).thenReturn(5L);    leader.addLearnerHandler(nonVotingFollower);    leader.addForwardingFollower(nonVotingFollower);    String followerInfo = leaderBean.followerInfo();    assertTrue(followerInfo.contains("1"));    assertTrue(followerInfo.contains("5"));    assertEquals("5\n", leaderBean.nonVotingFollowerInfo());}
33ef80059d7e7a7518d8573f1a5b03b2c696de96c32f61b1b2b1e2ffdcd0b9cd
process
public void process(WatchedEvent e)
{    createdLatch.countDown();}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    oldLoggingFeq = Leader.getAckLoggingFrequency();}
ec8b6259c87a96a7e78ab8ec13a826f2caf0d2a1c593d4aec011e181f3e17bbf
teardown
public void teardown()
{    Leader.setAckLoggingFrequency(oldLoggingFeq);}
bebad465e5cfea249a59be69466368e7c57b4b92bb1ca9d15d854ab2c11d6c1e
testLeaderMetrics
public void testLeaderMetrics() throws Exception
{        Leader.setAckLoggingFrequency(1);    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    createdLatch = new CountDownLatch(1);    zk.exists("/test", new MyWatcher());    zk.create("/test", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    createdLatch.await();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("proposal_count"));        assertEquals(2L, values.get("cnt_quorum_ack_latency"));    assertThat((long) values.get("min_quorum_ack_latency"), greaterThan(0L));    int numberOfAckServers = 0;        for (int sid = 1; sid <= 3; sid++) {        String metricName = "min_" + sid + "_ack_latency";        if (values.get(metricName) != null) {            numberOfAckServers++;            assertThat((long) values.get("min_" + sid + "_ack_latency"), greaterThanOrEqualTo(0L));        }    }        assertThat(numberOfAckServers, greaterThanOrEqualTo(2));    zk.close();    util.shutdownAll();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    tmpDir = ClientBase.createTmpDir();    peer = createQuorumPeer(tmpDir);    participantId = 1;    Map<Long, QuorumPeer.QuorumServer> peers = peer.getQuorumVerifier().getAllMembers();    observerId = peers.size();    leader = createLeader(tmpDir, peer);    peer.leader = leader;    peers.put(observerId, new QuorumPeer.QuorumServer(observerId, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), QuorumPeer.LearnerType.OBSERVER));        peer.tickTime = 1;}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    leader.shutdown("end of test");    tmpDir.delete();}
f98068022bed1adc9c4bbbfa20996651dc2e142e11e904d4e2b29406c1c76ba3
testGetEpochToPropose
public void testGetEpochToPropose() throws Exception
{    long lastAcceptedEpoch = 5;    peer.setAcceptedEpoch(5);    assertEquals("Unexpected vote in connectingFollowers", 0, leader.connectingFollowers.size());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(peer.getId(), lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch until quorum of participants is in connectingFollowers", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                leader.getEpochToPropose(observerId, lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch after observer asks for epoch", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(participantId, lastAcceptedEpoch);    } catch (Exception e) {        fail("Timed out in getEpochToPropose");    }    assertEquals("Unexpected vote in connectingFollowers", 2, leader.connectingFollowers.size());    assertEquals("Leader should record next epoch", lastAcceptedEpoch + 1, peer.getAcceptedEpoch());    assertFalse(leader.waitingForNewEpoch);}
8cb3414b555337f5d916381805427034250cdff3707a792e6711cc969016cd4f
testWaitForEpochAck
public void testWaitForEpochAck() throws Exception
{        leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());    assertEquals("Unexpected vote in electingFollowers", 0, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(peer.getId(), new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(observerId, new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(participantId, new StateSummary(0, 0));        assertEquals("Unexpected vote in electingFollowers", 2, leader.electingFollowers.size());        assertTrue(leader.electionFinished);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
3489bfbd542aa3d9c114af7e36e044e3b5300458a4f602196259ee7f74c4ba68
testWaitForNewLeaderAck
public void testWaitForNewLeaderAck() throws Exception
{    long zxid = leader.zk.getZxid();        leader.newLeaderProposal.packet = new QuorumPacket(0, zxid, null, null);    leader.newLeaderProposal.addQuorumVerifier(peer.getQuorumVerifier());    Set<Long> ackSet = leader.newLeaderProposal.qvAcksetPairs.get(0).getAckset();    assertEquals("Unexpected vote in ackSet", 0, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(peer.getId(), zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(observerId, zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(participantId, zxid);        assertEquals("Unexpected vote in ackSet", 2, ackSet.size());        assertTrue(leader.quorumFormed);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
935d9dc08fe11323dcaaf5c6f96db76bb87fd0fc4b9fcc33e9eca9f620f5620c
setup
public void setup() throws IOException
{    Leader leader = mock(Leader.class);    when(leader.getQuorumAuthServer()).thenReturn(null);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(new InetSocketAddress(32));        BinaryOutputArchive oa = mock(BinaryOutputArchive.class);    doAnswer(invocationOnMock -> {        Thread.sleep(5);        return null;    }).when(oa).writeRecord(any(QuorumPacket.class), anyString());    BufferedOutputStream bos = mock(BufferedOutputStream.class);        doAnswer(invocationOnMock -> {        if (allSentLatch != null) {            allSentLatch.countDown();        }        return null;    }).when(bos).flush();    learnerHandler = new MockLearnerHandler(socket, leader);    learnerHandler.setOutputArchive(oa);    learnerHandler.setBufferedOutput(bos);    learnerHandler.sid = sid;}
9728b092959996c199c75897f7a5a61646bd750f1f16b19665cf47bd11e2d104
testMetrics
public void testMetrics() throws InterruptedException
{    ServerMetrics.getMetrics().resetAll();        for (int i = 0; i < 1001; i++) {        learnerHandler.queuePacket(new QuorumPacket());    }    allSentLatch = new CountDownLatch(1);    learnerHandler.startSendingPackets();    allSentLatch.await(8, TimeUnit.SECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    String sidStr = Long.toString(sid);        assertEquals(2L, values.get("cnt_" + sidStr + "_learner_handler_qp_time_ms"));            assertThat((long) values.get("max_" + sidStr + "_learner_handler_qp_time_ms"), greaterThan(5000L));        assertEquals(1003L, values.get("cnt_" + sidStr + "_learner_handler_qp_size"));        assertEquals(1002L, values.get("max_" + sidStr + "_learner_handler_qp_size"));        assertEquals(0L, values.get("min_" + sidStr + "_learner_handler_qp_size"));}
ede858cea5ab8c6f42dfd4f2ac5c9e0aea3a121fc9657ae9689cd3083268b6a0
startSendingPackets
protected void startSendingPackets()
{    threadStarted = true;}
fa04fd8f8a8413fce5f1c4abe90d0d1ffe481ea3643e1b7e562b4e8cfd2a665a
shouldSendMarkerPacketForLogging
protected boolean shouldSendMarkerPacketForLogging()
{    return false;}
abc7ead92ff84d7deb4f99d8d3bc1f70a065f72016e9451ddfc05553f7ad5814
getDataTreeLastProcessedZxid
public long getDataTreeLastProcessedZxid()
{    return lastProcessedZxid;}
56de2ca47f238ec0a6d8166ee0970a0283fbcc35c8fa7be2006d6613dd314565
getmaxCommittedLog
public long getmaxCommittedLog()
{    if (!committedLog.isEmpty()) {        return committedLog.getLast().packet.getZxid();    }    return 0;}
9a33bbd60fe73e14eb7b2eae4d40137a85f07077394e83cadb221f164f25965a
getminCommittedLog
public long getminCommittedLog()
{    if (!committedLog.isEmpty()) {        return committedLog.getFirst().packet.getZxid();    }    return 0;}
a65f494b82cafa5e97df900c5676dabd5b7ef2b6b58acf812a00774a2a328e92
getCommittedLog
public List<Proposal> getCommittedLog()
{    return committedLog;}
8cfa7c2ded13119c77114718a496189923a616c2b85f7320172e20febac5c66d
getLogLock
public ReentrantReadWriteLock getLogLock()
{    return lock;}
af098d2934c24e203706486305b8a1d36c6b2c0a17b3971663f808976dbdc5f3
getProposalsFromTxnLog
public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit)
{    if (peerZxid >= txnLog.peekFirst().packet.getZxid()) {        return txnLog.iterator();    } else {        return Collections.emptyIterator();    }}
98344d36b2ea1e152d0b9f4f04cec6ce8b32b389d0093d3abc5e8f31e36369cf
calculateTxnLogSizeLimit
public long calculateTxnLogSizeLimit()
{    return 1;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    db = new MockZKDatabase(null);    sock = mock(Socket.class);        leader = mock(Leader.class);    when(leader.startForwarding(ArgumentMatchers.any(LearnerHandler.class), ArgumentMatchers.anyLong())).thenAnswer(new Answer<Long>() {        public Long answer(InvocationOnMock invocation) {            currentZxid = invocation.getArgument(1);            return 0L;        }    });    when(leader.getZKDatabase()).thenReturn(db);    learnerHandler = new MockLearnerHandler(sock, leader);}
2777538039e46712ed1957cd142602b8343ecac27f22228fc51ac83c2d927892
answer
public Long answer(InvocationOnMock invocation)
{    currentZxid = invocation.getArgument(1);    return 0L;}
bbaa5091424af2c6e816a0cd06ecb09ebf27ff3548974bfbc23f0e182fc7e4e5
createProposal
 Proposal createProposal(long zxid)
{    Proposal p = new Proposal();    p.packet = new QuorumPacket();    p.packet.setZxid(zxid);    p.packet.setType(Leader.PROPOSAL);    return p;}
d1f1d462b4fdac80bcefe69a86f8777980377b522dd1350540921a359138247f
queuedPacketMatches
public void queuedPacketMatches(long[] zxids)
{    int index = 0;    for (QuorumPacket qp : learnerHandler.getQueuedPackets()) {        if (qp.getType() == Leader.PROPOSAL) {            assertZxidEquals(zxids[index++], qp.getZxid());        }    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    learnerHandler.getQueuedPackets().clear();    learnerHandler.threadStarted = false;    learnerHandler.setFirstPacket(true);}
1eb6554d40b1c27c3647874f31110ad40061bc71e9a010b2315c8d12885d730b
assertOpType
public void assertOpType(int type, long zxid, long currentZxid)
{    Queue<QuorumPacket> packets = learnerHandler.getQueuedPackets();    assertTrue(packets.size() > 0);    assertEquals(type, packets.peek().getType());    assertZxidEquals(zxid, packets.peek().getZxid());    assertZxidEquals(currentZxid, this.currentZxid);}
c68c38a9804b091af528d463476037635238331f3bbba83eb58ae0d3c8fd17d2
assertZxidEquals
 void assertZxidEquals(long expected, long value)
{    assertEquals("Expected 0x" + Long.toHexString(expected) + " but was 0x" + Long.toHexString(value), expected, value);}
ffe1536df7c1e2d010c04dc9a9cba27f3f0058f3e0bc27eebb3d1fd4205e9d9a
testEmptyCommittedLog
public void testEmptyCommittedLog() throws Exception
{    long peerZxid;        peerZxid = 3;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, db.lastProcessedZxid, db.lastProcessedZxid);    reset();        peerZxid = 1;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);    assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();            peerZxid = 0;    db.setSnapshotSizeFactor(-1);    db.lastProcessedZxid = 1;    db.committedLog.clear();        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
a74395cc4468cf6f2c62d81ddc1b772695d03d49fa26ffe8571a5fcb0a3a486b
testCommittedLog
public void testCommittedLog() throws Exception
{    long peerZxid;            db.lastProcessedZxid = 6;    db.committedLog.add(createProposal(2));    db.committedLog.add(createProposal(3));    db.committedLog.add(createProposal(5));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, 5);        assertEquals(3, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5 });    reset();        peerZxid = 1;    db.setSnapshotSizeFactor(-1);        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
cb6c8ca384e3e8214675cedeb90a9245ca19cb0f473dae3f7dbdaeff28aad560
testTxnLog
public void testTxnLog() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));    db.txnLog.add(createProposal(9));    db.lastProcessedZxid = 9;    db.committedLog.add(createProposal(6));    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();        peerZxid = 3;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();}
baf5cbae7b21676ce24b1bd45ac6ed02313ab33306b024e65b3b6d9593795d0d
testTxnLogProposalIteratorClosure
public void testTxnLogProposalIteratorClosure() throws Exception
{    long peerZxid;        db = new MockZKDatabase(null) {        @Override        public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit) {            return TxnLogProposalIterator.EMPTY_ITERATOR;        }    };    db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    when(leader.getZKDatabase()).thenReturn(db);        peerZxid = 4;    assertTrue("Couldn't identify snapshot transfer!", learnerHandler.syncFollower(peerZxid, leader));    reset();}
af098d2934c24e203706486305b8a1d36c6b2c0a17b3971663f808976dbdc5f3
getProposalsFromTxnLog
public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit)
{    return TxnLogProposalIterator.EMPTY_ITERATOR;}
89e77ed9fd20f44edc6f71270456479a0a13e455195857243c9d203463e2e3d6
testTxnLogOnly
public void testTxnLogOnly() throws Exception
{    long peerZxid;        db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));            assertOpType(Leader.TRUNC, 3, db.lastProcessedZxid);        assertEquals(7, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5, 6, 7 });    reset();        peerZxid = 1;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));        assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
b4dcf5779407e5461803b720e5c3f986ffa51c9baaa4c50e94ea6591d309a42f
getZxid
 long getZxid(long epoch, long counter)
{    return ZxidUtils.makeZxid(epoch, counter);}
dfd8db7ca458018b8cefc1599f64d50dd12adbe8ee9f553d9066aa3a4e797ff0
testTxnLogWithNegativeZxid
public void testTxnLogWithNegativeZxid() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0xf, 2)));    db.txnLog.add(createProposal(getZxid(0xf, 3)));    db.txnLog.add(createProposal(getZxid(0xf, 5)));    db.txnLog.add(createProposal(getZxid(0xf, 6)));    db.txnLog.add(createProposal(getZxid(0xf, 7)));    db.txnLog.add(createProposal(getZxid(0xf, 8)));    db.txnLog.add(createProposal(getZxid(0xf, 9)));    db.lastProcessedZxid = getZxid(0xf, 9);    db.committedLog.add(createProposal(getZxid(0xf, 6)));    db.committedLog.add(createProposal(getZxid(0xf, 7)));    db.committedLog.add(createProposal(getZxid(0xf, 8)));        peerZxid = getZxid(0xf, 4);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, getZxid(0xf, 3), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();        peerZxid = getZxid(0xf, 3);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();}
efc6a8a7f13ce7c84e743e44ff2c7db06f0cc3198528c9f591939a489c3c7203
testNewEpochZxid
public void testNewEpochZxid() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(0, 0);                assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();        peerZxid = getZxid(2, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(2, 0), getZxid(2, 0));        assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();}
5898de4799f34b39d2564f27053b78f5d45bc60bf474e3bcb0ef6e9800e11cb0
testDuplicatedTxn
public void testDuplicatedTxn() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();}
4d73b9194240fa6eab69930f57c5ecfecb8739322956c4d2b8aabd9d6a626dc7
testCrossEpochTrunc
public void testCrossEpochTrunc() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(2, 1)));    db.txnLog.add(createProposal(getZxid(2, 2)));    db.txnLog.add(createProposal(getZxid(4, 1)));        db.lastProcessedZxid = getZxid(6, 0);        peerZxid = getZxid(3, 1);    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
3e00448038e88cb12fa3a9c01e7ce75b38e46cef29cb5762e812313c9342f97e
testTxnLogGap
public void testTxnLogGap() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(4));    db.lastProcessedZxid = 8;    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 3;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    reset();}
edeba5e40e7cee36a44aaed8c15fd5ec951ec671dc4789928b5f0ac395872cfc
testLearnerMetricsTest
public void testLearnerMetricsTest() throws Exception
{    ServerMetrics.getMetrics().resetAll();    ClientBase.setupTestEnv();    final String path = "/zk-testLeanerMetrics";    final byte[] data = new byte[512];    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    int observer = 0;    clientPorts[observer] = PortAssignment.unique();    sb.append("server." + observer + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer\n");    for (int i = 1; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\n");    }        String quorumCfgSection = sb.toString();    for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();    }        Map<String, String> observerConfig = new HashMap<>();    observerConfig.put("peerType", "observer");    mt[observer] = new QuorumPeerTestBase.MainThread(observer, clientPorts[observer], quorumCfgSection, observerConfig);    mt[observer].start();            zk_client = new ZooKeeper("127.0.0.1:" + clientPorts[observer], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk_client, ZooKeeper.States.CONNECTED);        zk_client.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            waitForMetric("learner_proposal_received_count", is(4L));    waitForMetric("cnt_proposal_latency", is(4L));    waitForMetric("min_proposal_latency", greaterThanOrEqualTo(0L));        waitForMetric("cnt_proposal_ack_creation_latency", is(6L));    waitForMetric("min_proposal_ack_creation_latency", greaterThanOrEqualTo(0L));            waitForMetric("learner_commit_received_count", is(6L));    waitForMetric("cnt_commit_propagation_latency", is(6L));    waitForMetric("min_commit_propagation_latency", greaterThanOrEqualTo(0L));}
def1a5b2d250d5a405dd31fc0b6409319abe26a79c79664e0708ed1d6ddbe23c
waitForMetric
private void waitForMetric(final String metricKey, final Matcher<Long> matcher) throws InterruptedException
{    final String errorMessage = String.format("unable to match on metric: %s", metricKey);    waitFor(errorMessage, () -> {        long actual = (long) MetricsUtils.currentServerMetrics().get(metricKey);        if (!matcher.matches(actual)) {            LOG.info(String.format("match failed on %s, actual value: %d", metricKey, actual));            return false;        }        return true;    }, TIMEOUT_SECONDS);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    zk_client.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
0fe925b4667157a4eb692da848709047a02e4fdb8152ce63be2b4bf690c2daaa
syncTypes
public static Collection syncTypes()
{    return Arrays.asList(new Object[][] { { LearnerSyncThrottler.SyncType.DIFF }, { LearnerSyncThrottler.SyncType.SNAP } });}
ec68abe8a797dc70277086e4c8821365804e43cd771da0179f504aa0ffbcf5dd
testTooManySyncsNonessential
public void testTooManySyncsNonessential() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    for (int i = 0; i < 6; i++) {        throttler.beginSync(false);    }}
19bcf7e0cd067ee02b2fcab15c5501f8c40b55a8d75d085e672449c18db88f48
testTooManySyncsEssential
public void testTooManySyncsEssential() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    throttler.beginSync(false);}
34f4d7f4eea3d0ca9cc297b53752bbc00aa6ed5f5045d07ae77da4aeb1e5f69c
testNoThrottle
public void testNoThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    for (int i = 0; i < 5; i++) {        throttler.endSync();        throttler.beginSync(false);    }    assertTrue("should get here without exception", true);}
cc15674fe50fbef525b6af5ffd8de4296fc54d15e23ac7b24ab3cdd1a822feb7
testTryWithResourceNoThrottle
public void testTryWithResourceNoThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    for (int i = 0; i < 3; i++) {        throttler.beginSync(false);        try {            assertEquals(1, throttler.getSyncInProgress());        } finally {            throttler.endSync();        }    }}
7fb616d5ed1d20642b30f0649f51a2e256b02bbadbd1adf627723fa57d3d0a21
testTryWithResourceThrottle
public void testTryWithResourceThrottle() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    try {        throttler.beginSync(true);        try {            throttler.beginSync(false);            fail("shouldn't be able to have both syncs open");        } catch (SyncThrottleException e) {        }        throttler.endSync();    } catch (SyncThrottleException e) {        fail("First sync shouldn't be throttled");    }}
47c756c889034cc46acb1dd8da3827044dd3afcedbe4ccf03030882f26f49574
testParallelNoThrottle
public void testParallelNoThrottle()
{    final int numThreads = 50;    final LearnerSyncThrottler throttler = new LearnerSyncThrottler(numThreads, syncType);    ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);    final CountDownLatch threadStartLatch = new CountDownLatch(numThreads);    final CountDownLatch syncProgressLatch = new CountDownLatch(numThreads);    List<Future<Boolean>> results = new ArrayList<Future<Boolean>>(numThreads);    for (int i = 0; i < numThreads; i++) {        results.add(threadPool.submit(new Callable<Boolean>() {            @Override            public Boolean call() {                threadStartLatch.countDown();                try {                    threadStartLatch.await();                    throttler.beginSync(false);                    syncProgressLatch.countDown();                    syncProgressLatch.await();                    throttler.endSync();                } catch (Exception e) {                    return false;                }                return true;            }        }));    }    try {        for (Future<Boolean> result : results) {            assertTrue(result.get());        }    } catch (Exception e) {    } finally {        threadPool.shutdown();    }}
894028ab1b985b7c610b6cc77b571f6684a07704fe7e8c5799e2ccd76a62657a
call
public Boolean call()
{    threadStartLatch.countDown();    try {        threadStartLatch.await();        throttler.beginSync(false);        syncProgressLatch.countDown();        syncProgressLatch.await();        throttler.endSync();    } catch (Exception e) {        return false;    }    return true;}
d4d6215fb456119d106b5f717a681421488775b8c85a263aae42ba59890c4a09
getLearner
public Learner getLearner()
{    return learner;}
c01d012f3c8016e747f4621ba9bbb24b76950148136dcb07d289bb676ee9b5c0
setTimeMultiplier
public void setTimeMultiplier(long multiplier)
{    timeMultiplier = multiplier;}
8572a877a8f7f8568c39713e5fd9755e5ece77240c84f1136cfe15b033ce3c78
setPassConnectAttempt
public void setPassConnectAttempt(int num)
{    passSocketConnectOnAttempt = num;}
9fb77193c5f2f0d63c984bf98fb11c8d84c72c7561eb08080678332b977079d6
nanoTime
protected long nanoTime()
{    return socketConnectAttempt * timeMultiplier;}
b0828a8700cc40616838723004f42243a74157c87fda4a55bdb589806bc21df1
getSockConnectAttempt
protected int getSockConnectAttempt()
{    return socketConnectAttempt;}
d0ab9a59ba1231ed9d4a3000d9ac29e1f92d486bb793a271f620d3466e95e5fc
sockConnect
protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    if (++socketConnectAttempt < passSocketConnectOnAttempt) {        throw new IOException("Test injected Socket.connect() error.");    }}
677543cd51770fd0ae4eacfa9ac46a55dcab3c83e7ba4840500fed517d08b28a
connectionRetryTimeoutTest
public void connectionRetryTimeoutTest() throws Exception
{    Learner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.connectToLeader(addr, "");}
99d8e5f072331886bdb718ce2bab9f66b79a1ded8330e50f9391986eb640325d
connectionInitLimitTimeoutTest
public void connectionInitLimitTimeoutTest() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);        try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {                assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
0f6fcbc9dc9f28a306220bbc653dd2959bbf0ef34fbc880766373b3102569f1b
connectToLearnerMasterLimitTest
public void connectToLearnerMasterLimitTest() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(2);    learner.self.setSyncLimit(2);    learner.self.setConnectToLearnerMasterLimit(5);    InetSocketAddress addr = new InetSocketAddress(1111);    learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);    try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {        assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
26bd1c9d698239744e768e23fbbb47dd49161d55e856c7856934ed30f57358e2
syncTest
public void syncTest() throws Exception
{    File tmpFile = File.createTempFile("test", ".dir", testData);    tmpFile.delete();    try {        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpFile, tmpFile);        SimpleLearner sl = new SimpleLearner(ftsl);        long startZxid = sl.zk.getLastProcessedZxid();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        sl.leaderOs = BinaryOutputArchive.getArchive(new ByteArrayOutputStream());                sl.bufferedOutput = new BufferedOutputStream(System.out);        sl.sock = new Socket();                QuorumPacket qp = new QuorumPacket(Leader.SNAP, 0, null, null);        oa.writeRecord(qp, null);        sl.zk.getZKDatabase().serializeSnapshot(oa);        oa.writeString("BenWasHere", "signature");        TxnHeader hdr = new TxnHeader(0, 0, 0, 0, ZooDefs.OpCode.create);        CreateTxn txn = new CreateTxn("/foo", new byte[0], new ArrayList<ACL>(), false, sl.zk.getZKDatabase().getNode("/").stat.getCversion());        ByteArrayOutputStream tbaos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(tbaos);        hdr.serialize(boa, "hdr");        txn.serialize(boa, "txn");        tbaos.close();        qp = new QuorumPacket(Leader.PROPOSAL, 1, tbaos.toByteArray(), null);        oa.writeRecord(qp, null);                sl.leaderIs = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));        try {            sl.syncWithLeader(3);        } catch (EOFException e) {        }        sl.zk.shutdown();        sl = new SimpleLearner(ftsl);        assertEquals(startZxid, sl.zk.getLastProcessedZxid());    } finally {        TestUtils.deleteFileRecursively(tmpFile);    }}
ac4b8c62fe4a1bee0121d4ed8b42e0ed43d760b5a614b83bdc4d9afa99a29261
testClientAddress
public void testClientAddress() throws Exception
{    QuorumPeer quorumPeer = new QuorumPeer();    LocalPeerBean remotePeerBean = new LocalPeerBean(quorumPeer);    /**     * Case 1: When cnxnFactory is null     */    String result = remotePeerBean.getClientAddress();    assertNotNull(result);    assertEquals(0, result.length());    /**     * Case 2: When only client port is configured     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int clientPort = PortAssignment.unique();    InetSocketAddress address = new InetSocketAddress(clientPort);    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String ipv4 = "0.0.0.0:" + clientPort;    String ipv6 = "[0:0:0:0:0:0:0:0]:" + clientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();    /**     * Case 3: When both client port and client address is configured     */    clientPort = PortAssignment.unique();    InetAddress clientIP = InetAddress.getLoopbackAddress();    address = new InetSocketAddress(clientIP, clientPort);    cnxnFactory = ServerCnxnFactory.createFactory();    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String expectedResult = clientIP.getHostAddress() + ":" + clientPort;    assertEquals(expectedResult, result);        cnxnFactory.shutdown();}
3a45696feb3aa45e9f421542924154fd27fcc958d1607915064a3094015761b6
testLocalPeerIsLeader
public void testLocalPeerIsLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(true);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertTrue(localPeerBean.isLeader());}
db1102be06f504804fc5d6eca170de8a5d3fc8f8d6348fa778d3a7911e9046b3
testLocalPeerIsNotLeader
public void testLocalPeerIsNotLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(false);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertFalse(localPeerBean.isLeader());}
6abd6b590ae91a54269e4791fdead0d9bbf208571c159b69b56f316940af5177
testGetNameProperty
public void testGetNameProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    when(qpMock.getId()).thenReturn(1L);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("getName property should return Bean name in the right format", qb.getName(), equalTo("ReplicatedServer_id1"));}
938933aa9c264ac315aecf408bce8562a99ae6507fbb43790f7c374057a880d4
testIsHiddenProperty
public void testIsHiddenProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("isHidden should return false", qb.isHidden(), equalTo(false));}
cf2f90e7bdd4dfb8769530be14d3cfc2b660ea6f5603533ef228ab2e768e0229
testGetQuorumSizeProperty
public void testGetQuorumSizeProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.getQuorumSize()).thenReturn(5);    assertThat("getQuorumSize property should return value of peet.getQuorumSize()", qb.getQuorumSize(), equalTo(5));}
7c4fe58ab82f9fd15cb4eb41698d00b9d78cb5d4334b26bd706d8a70adcd3103
testSslQuorumProperty
public void testSslQuorumProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.isSslQuorum()).thenReturn(true);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(true));    when(qpMock.isSslQuorum()).thenReturn(false);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(false));}
ccb1540f731a6d98361323c0a9f6fdcfb42aae03f41f71b0589f3624b30f7aaf
testPortUnificationProperty
public void testPortUnificationProperty()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.shouldUsePortUnification()).thenReturn(true);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(true));    when(qpMock.shouldUsePortUnification()).thenReturn(false);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(false));}
1ef41f8615f8929e50fdff81adfd283873d929d3e50fddacd94c14026bfc1aad
testErrorMessageWhensecureClientPortNotSetButsecureClientPortAddressSet
public void testErrorMessageWhensecureClientPortNotSetButsecureClientPortAddressSet() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("secureClientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "secureClientPortAddress is set but secureClientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
fb4319328c6eeb2f95c84a8cfed81e01219b48660c5bebab4643a3b54e199094
testErrorMessageWhenclientPortNotSetButclientPortAddressSet
public void testErrorMessageWhenclientPortNotSetButclientPortAddressSet() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("clientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "clientPortAddress is set but clientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
0053d62ba85303fe201c6b5e88ed03687c9286fa2f537c2db13272938368dcd2
testConfigureSSLAuthGetsConfiguredIfSecurePortConfigured
public void testConfigureSSLAuthGetsConfiguredIfSecurePortConfigured() throws IOException, ConfigException
{    String sslAuthProp = "zookeeper.authProvider.x509";    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("secureClientPort", "12345");    quorumPeerConfig.parseProperties(zkProp);    String expected = "org.apache.zookeeper.server.auth.X509AuthenticationProvider";    String result = System.getProperty(sslAuthProp);    assertEquals(expected, result);}
a6d16649f32f96e1b111d5d21d859cb0c99dcaa38cf1e53df2eee77aa407921a
testCustomSSLAuth
public void testCustomSSLAuth() throws IOException
{    try (ClientX509Util x509Util = new ClientX509Util()) {        System.setProperty(x509Util.getSslAuthProviderProperty(), "y509");        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();        try {            Properties zkProp = getDefaultZKProperties();            zkProp.setProperty("secureClientPort", "12345");            quorumPeerConfig.parseProperties(zkProp);            fail("ConfigException is expected");        } catch (ConfigException e) {            assertNotNull(e.getMessage());        }    }}
e63347f94f7ed2f61ac3eaf9ba1668eec287014b5c5adc894be85af6de2ca34f
testSamePortConfiguredForClientAndElection
public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("server.1", "localhost:2888:2888");    quorumPeerConfig.parseProperties(zkProp);}
edf4442507cbff7948fac64b22720ab53a351ba83ef8f4e6c074daf38450de72
testClientAddrFromClientPort
public void testClientAddrFromClientPort() throws IOException, ConfigException
{    long serverId = 1;    QuorumPeerConfig quorumPeerConfig = new MockQuorumPeerConfig(serverId);    Properties zkProp = getDefaultZKProperties();    int clientPort = 12345;    zkProp.setProperty("clientPort", Integer.toString(clientPort));    zkProp.setProperty("server.1", "127.0.0.1:2889:3889:participant");    quorumPeerConfig.parseProperties(zkProp);    QuorumServer qs = quorumPeerConfig.getQuorumVerifier().getAllMembers().get(serverId);    InetSocketAddress expectedAddress = new InetSocketAddress("0.0.0.0", clientPort);    assertEquals(expectedAddress, quorumPeerConfig.getClientPortAddress());    assertEquals(quorumPeerConfig.getClientPortAddress(), qs.clientAddr);}
5e3bdc33748405a1cad74da70fd8d418ee5e23b256f2135cd5da8c9d77554d26
testJvmPauseMonitorConfigured
public void testJvmPauseMonitorConfigured() throws IOException, ConfigException
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    zkProp.setProperty("jvm.pause.monitor", "true");    zkProp.setProperty("jvm.pause.sleep.time.ms", sleepTime.toString());    zkProp.setProperty("jvm.pause.warn-threshold.ms", warnTH.toString());    zkProp.setProperty("jvm.pause.info-threshold.ms", infoTH.toString());    quorumPeerConfig.parseProperties(zkProp);    assertEquals(sleepTime, Long.valueOf(quorumPeerConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(quorumPeerConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(quorumPeerConfig.getJvmPauseInfoThresholdMs()));    assertTrue(quorumPeerConfig.isJvmPauseMonitorToRun());}
b571f114ea378713b03ce163a11e3a1d8742b55b123370bf1a60e1f208430861
getDefaultZKProperties
private Properties getDefaultZKProperties()
{    Properties zkProp = new Properties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    return zkProp;}
26cbeade24397dea2d299955f10e63445caf7431f0ea462f8e990cecc4c57b85
testQuorumInternal
public void testQuorumInternal(String addr) throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String server1 = String.format("server.1=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1);    String server2 = String.format("server.2=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    String quorumCfgSection = server1 + "\n" + server2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    int tickTime = quorumPeer.getTickTime();    assertEquals("Default value of minimumSessionTimeOut is not considered", tickTime * 2, quorumPeer.getMinSessionTimeout());    assertEquals("Default value of maximumSessionTimeOut is not considered", tickTime * 20, quorumPeer.getMaxSessionTimeout());    ZooKeeper zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q2", "foobar2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q2", null, null)), "foobar2");    zk.close();    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
3e5505cd6817549e2b94f2289f232edc7b8f36ae9544fc7bcf8da796bb4ea7b1
testQuorum
public void testQuorum() throws Exception
{    testQuorumInternal("127.0.0.1");}
7244668ec5a1320341f63a593b006a8406ffb4272c2864bb2eb2dd1c0c90c4f4
testQuorumV6
public void testQuorumV6() throws Exception
{    testQuorumInternal("[::1]");}
c89acc295ed7bc39f80435ec8b96080ee749e9131458275d88fa859b9d8f074d
testEarlyLeaderAbandonment
public void testEarlyLeaderAbandonment() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();                zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);            int leader = -1;    Map<Long, Proposal> outstanding = null;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader == null) {            mt[i].shutdown();        } else {            leader = i;            outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;        }    }    try {        zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }            assertTrue(outstanding.size() == 1);    assertTrue(outstanding.values().iterator().next().request.getHdr().getType() == OpCode.create);        Thread.sleep(1000);    mt[leader].shutdown();    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            mt[i].start();        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);            waitForOne(zk[i], States.CONNECTED);            zk[i].create("/zk" + i, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    mt[leader].start();    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        for (int j = 0; j < SERVER_COUNT; j++) {            if (i == leader) {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " should not have /zk" + i, zk[j].exists("/zk" + i, false) == null);            } else {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " does not have /zk" + i, zk[j].exists("/zk" + i, false) != null);            }        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
c9ee91db9f3ab61c59fad0e08cacd66436f44614bc1616c37d156ac9276a019a
testHighestZxidJoinLate
public void testHighestZxidJoinLate() throws Exception
{    numServers = 3;    servers = LaunchServers(numServers);    String path = "/hzxidtest";    int leader = servers.findLeader();        assertTrue("There should be a leader", leader >= 0);    int nonleader = (leader + 1) % numServers;    byte[] input = new byte[1];    input[0] = 1;    byte[] output;        servers.zk[leader].create(path + leader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    servers.zk[leader].create(path + nonleader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            output = servers.zk[leader].getData(path + nonleader, false, null);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }    input[0] = 2;        servers.zk[leader].setData(path + leader, input, -1, null, null);        Thread.sleep(500);        servers.mt[leader].shutdown();    System.gc();    waitForAll(servers.zk, States.CONNECTING);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        waitForOne(servers.zk[nonleader], States.CONNECTED);        output = servers.zk[nonleader].getData(path + leader, false, null);    assertEquals("Expecting old value 1 since 2 isn't committed yet", output[0], 1);            servers.zk[nonleader].setData(path + nonleader, input, -1);        servers.mt[leader].start();        waitForOne(servers.zk[leader], States.CONNECTED);        output = servers.zk[leader].getData(path + leader, false, null);    assertEquals("Validating that the deposed leader has rolled back that change it had written", output[0], 1);        output = servers.zk[leader].getData(path + nonleader, false, null);    assertEquals("Validating that the deposed leader caught up on changes it missed", output[0], 2);}
8674d5eb0fcf6e460c9882db4ebcc170cc6d9b93fab2e1f493c4182e9b0a9e26
testElectionFraud
public void testElectionFraud() throws IOException, InterruptedException
{        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger(QuorumPeer.class);    qlogger.addAppender(appender);    numServers = 3;        boolean foundLeading = false;    boolean foundLooking = false;    boolean foundFollowing = false;    try {                servers = LaunchServers(numServers, 500);                int trueLeader = servers.findLeader();        assertTrue("There should be a leader", trueLeader >= 0);                int falseLeader = (trueLeader + 1) % numServers;        assertTrue("All servers should join the quorum", servers.mt[falseLeader].main.quorumPeer.follower != null);                        servers.mt[falseLeader].main.quorumPeer.electionAlg.shutdown();        servers.mt[falseLeader].main.quorumPeer.follower.getSocket().close();                waitForOne(servers.zk[falseLeader], States.CONNECTING);                servers.mt[falseLeader].main.quorumPeer.setPeerState(QuorumPeer.ServerState.LEADING);                        Thread.sleep(2 * servers.mt[falseLeader].main.quorumPeer.initLimit * servers.mt[falseLeader].main.quorumPeer.tickTime);                servers.mt[falseLeader].main.quorumPeer.startLeaderElection();                servers.zk[falseLeader] = new ZooKeeper("127.0.0.1:" + servers.mt[falseLeader].getClientPort(), ClientBase.CONNECTION_TIMEOUT, this);                waitForOne(servers.zk[falseLeader], States.CONNECTED);                assertTrue(servers.mt[trueLeader].main.quorumPeer.leader != null);                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=" + falseLeader + ".*LEADING.*");        Pattern looking = Pattern.compile(".*myid=" + falseLeader + ".*LOOKING.*");        Pattern following = Pattern.compile(".*myid=" + falseLeader + ".*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null) {            if (!foundLeading) {                foundLeading = leading.matcher(line).matches();            } else if (!foundLooking) {                foundLooking = looking.matcher(line).matches();            } else if (following.matcher(line).matches()) {                foundFollowing = true;                break;            }        }    } finally {        qlogger.removeAppender(appender);    }    assertTrue("falseLeader never attempts to become leader", foundLeading);    assertTrue("falseLeader never gives up on leadership", foundLooking);    assertTrue("falseLeader never rejoins the quorum", foundFollowing);}
9a9f1044e4a18db8e55551bb95877b15b6e3aae04056addfc4970b9d2a865bfc
testBadPeerAddressInQuorum
public void testBadPeerAddressInQuorum() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=fee.fii.foo.fum:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Cannot open channel to .* at election address .*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about host", found);}
2229bc2b6caa88eb433d3777579504c58abb681b1e2a8d1b05f88dd3e6bac906
testInconsistentPeerType
public void testInconsistentPeerType() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);        try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        final int CLIENT_PORT_QP3 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer" + ";" + CLIENT_PORT_QP3;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgSection);        q1.start();        q2.start();        q3.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP3, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean warningPresent = false;    boolean defaultedToObserver = false;    Pattern pWarn = Pattern.compile(".*Peer type from servers list.* doesn't match peerType.*");    Pattern pObserve = Pattern.compile(".*OBSERVING.*");    while ((line = r.readLine()) != null) {        if (pWarn.matcher(line).matches()) {            warningPresent = true;        }        if (pObserve.matcher(line).matches()) {            defaultedToObserver = true;        }        if (warningPresent && defaultedToObserver) {            break;        }    }    assertTrue("Should warn about inconsistent peer type", warningPresent && defaultedToObserver);}
d55a8ba4b61a0119b1f0dc811648efa4fa80b3347c3cfda9f55759eee59cc967
testBadPackets
public void testBadPackets() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    int electionPort1 = PortAssignment.unique();    int electionPort2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort1 + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort2 + ";" + CLIENT_PORT_QP2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    byte[] b = new byte[4];    int length = 1024 * 1024 * 1024;    ByteBuffer buff = ByteBuffer.wrap(b);    buff.putInt(length);    buff.position(0);    SocketChannel s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort1));    s.write(buff);    s.close();    buff.position(0);    s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort2));    s.write(buff);    s.close();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    q1.shutdown();    q2.shutdown();}
bc869eae66044c834f349e2d588e68291a043d4fbcb02c523686927def7173c9
testQuorumDefaults
public void testQuorumDefaults() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    appender.setImmediateFlush(true);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        q1.start();        q2.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*FastLeaderElection.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("fastleaderelection used", found);}
1c964cb2e396e420d8874c2e67ccd368da8bebb858000bdb95ab5aa5827e8716
testQuorumPeerExitTime
public void testQuorumPeerExitTime() throws Exception
{    long maxwait = 3000;    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + PortAssignment.unique();    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();        Thread.sleep(30000);    long start = Time.currentElapsedTime();    q1.shutdown();    long end = Time.currentElapsedTime();    if ((end - start) > maxwait) {        fail("QuorumPeer took " + (end - start) + " to shutdown, expected " + maxwait);    }}
043572f7a083f155dc4ba1bb33b49f96644338f1369d13cc45eaaa167cb65dab
testMinMaxSessionTimeOut
public void testMinMaxSessionTimeOut() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 10000;    final int maxSessionTimeOut = 15000;    final String configs = "maxSessionTimeout=" + maxSessionTimeOut + "\n" + "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is not considered", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
5b46fa3221eecb9250f8e6206104957c5a2b16244056310f7312a9218f89bed5
testWithOnlyMinSessionTimeout
public void testWithOnlyMinSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 15000;    final String configs = "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    final int maxSessionTimeOut = quorumPeer.tickTime * 20;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is wrong", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
7c4216d9391fd70060d9437f27d154184265a365b2d1c12921c9430e7d8a8182
testFailedTxnAsPartOfQuorumLoss
public void testFailedTxnAsPartOfQuorumLoss() throws Exception
{    final int LEADER_TIMEOUT_MS = 10_000;        ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    servers = LaunchServers(SERVER_COUNT);    waitForAll(servers, States.CONNECTED);            servers.shutDownAllServers();    waitForAll(servers, States.CONNECTING);    servers.restartAllServersAndClients(this);    waitForAll(servers, States.CONNECTED);        int leader = servers.findLeader();    Map<Long, Proposal> outstanding = servers.mt[leader].main.quorumPeer.leader.outstandingProposals;        int previousTick = servers.mt[leader].main.quorumPeer.tickTime;    servers.mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;        Thread.sleep(previousTick);    LOG.warn("LEADER {}", leader);    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        servers.restartClient(i, this);            waitForOne(servers.zk[i], States.CONNECTED);        }    }        try {        servers.zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }                assertTrue(outstanding.size() > 0);    Proposal p = findProposalOfType(outstanding, OpCode.create);    LOG.info(String.format("Old leader id: %d. All proposals: %s", leader, outstanding));    assertNotNull("Old leader doesn't have 'create' proposal", p);        int sleepTime = 0;    Long longLeader = Long.valueOf(leader);    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {        if (sleepTime > 2000) {            fail("Transaction not synced to disk within 1 second " + p.qvAcksetPairs.get(0).getAckset() + " expected " + leader);        }        Thread.sleep(100);        sleepTime += 100;    }        LOG.info("Waiting for leader {} to timeout followers", leader);    sleepTime = 0;    Follower f = servers.mt[leader].main.quorumPeer.follower;    while (f == null || !f.isRunning()) {        if (sleepTime > LEADER_TIMEOUT_MS * 2) {            fail("Took too long for old leader to time out " + servers.mt[leader].main.quorumPeer.getPeerState());        }        Thread.sleep(100);        sleepTime += 100;        f = servers.mt[leader].main.quorumPeer.follower;    }    int newLeader = servers.findLeader();        assertNotEquals(leader, newLeader);        servers.mt[leader].shutdown();    servers.mt[leader].start();        servers.restartClient(leader, this);    waitForAll(servers, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        assertNull("server " + i + " should not have /zk" + leader, servers.zk[i].exists("/zk" + leader, false));    }}
91d1d47c06ce1db6b88413a88a2c017bff91b4e649a42f7e750ada3695a88b8f
testLeaderOutOfView
public void testLeaderOutOfView() throws Exception
{    ClientBase.setupTestEnv();    int numServers = 3;        boolean foundLeading = false;    boolean foundFollowing = false;        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.DEBUG);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        Servers svrs = new Servers();        svrs.clientPorts = new int[numServers];        for (int i = 0; i < numServers; i++) {            svrs.clientPorts[i] = PortAssignment.unique();        }        String quorumCfgIncomplete = getUniquePortCfgForId(1) + "\n" + getUniquePortCfgForId(2);        String quorumCfgComplete = quorumCfgIncomplete + "\n" + getUniquePortCfgForId(3);        svrs.mt = new MainThread[3];                svrs.mt[0] = new MainThread(1, svrs.clientPorts[0], quorumCfgIncomplete);        for (int i = 1; i < numServers; i++) {            svrs.mt[i] = new MainThread(i + 1, svrs.clientPorts[i], quorumCfgComplete);        }                svrs.mt[0].start();        QuorumPeer quorumPeer1 = waitForQuorumPeer(svrs.mt[0], CONNECTION_TIMEOUT);        assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);                int highestServerIndex = numServers - 1;        svrs.mt[highestServerIndex].start();        QuorumPeer quorumPeer3 = waitForQuorumPeer(svrs.mt[highestServerIndex], CONNECTION_TIMEOUT);        assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);                for (int i = 1; i < highestServerIndex; i++) {            svrs.mt[i].start();        }                for (int i = 1; i < numServers; i++) {            assertTrue("waiting for server to start", ClientBase.waitForServerUp("127.0.0.1:" + svrs.clientPorts[i], CONNECTION_TIMEOUT));        }        assertTrue(svrs.mt[0].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);        assertTrue(svrs.mt[highestServerIndex].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);        for (int i = 1; i < highestServerIndex; i++) {            assertTrue(svrs.mt[i].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);        }                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=1.*QuorumPeer.*LEADING.*");        Pattern following = Pattern.compile(".*myid=1.*QuorumPeer.*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null && !foundLeading && !foundFollowing) {            foundLeading = leading.matcher(line).matches();            foundFollowing = following.matcher(line).matches();        }    } finally {        qlogger.removeAppender(appender);    }    assertFalse("Corrupt peer should never become leader", foundLeading);    assertFalse("Corrupt peer should not attempt connection to out of view leader", foundFollowing);}
cf0f4ee2d82e916d9dfa4cc33c55b00500e19423e0cb2a62c63230bfb8a46b9e
testDataDirAndDataLogDir
public void testDataDirAndDataLogDir() throws Exception
{    File dataDir = createEmptyTestDir();    File dataLogDir = createEmptyTestDir();        try {        QuorumPeerConfig configMock = mock(QuorumPeerConfig.class);        when(configMock.getDataDir()).thenReturn(dataDir);        when(configMock.getDataLogDir()).thenReturn(dataLogDir);        when(configMock.getMetricsProviderClassName()).thenReturn(NullMetricsProvider.class.getName());        QuorumPeer qpMock = mock(QuorumPeer.class);        doCallRealMethod().when(qpMock).setTxnFactory(any(FileTxnSnapLog.class));        when(qpMock.getTxnFactory()).thenCallRealMethod();        InjectableQuorumPeerMain qpMain = new InjectableQuorumPeerMain(qpMock);                qpMain.runFromConfig(configMock);                FileTxnSnapLog txnFactory = qpMain.getQuorumPeer().getTxnFactory();        assertEquals(Paths.get(dataLogDir.getAbsolutePath(), "version-2").toString(), txnFactory.getDataDir().getAbsolutePath());        assertEquals(Paths.get(dataDir.getAbsolutePath(), "version-2").toString(), txnFactory.getSnapDir().getAbsolutePath());    } finally {        FileUtils.deleteDirectory(dataDir);        FileUtils.deleteDirectory(dataLogDir);    }}
83d4bd1aa48371e45ce79d6319a9e333e069a083ae1e20907090cddf63879d4a
getQuorumPeer
protected QuorumPeer getQuorumPeer()
{    return qp;}
051e3459965c6f67a10032170f751e3314960ec717e4cfcdb270b1cce21cd544
getConsoleAppender
private WriterAppender getConsoleAppender(ByteArrayOutputStream os, Level level)
{    String loggingPattern = ((PatternLayout) Logger.getRootLogger().getAppender("CONSOLE").getLayout()).getConversionPattern();    WriterAppender appender = new WriterAppender(new PatternLayout(loggingPattern), os);    appender.setThreshold(level);    return appender;}
6a18bc30446791b3fef005fee716f96a4443963efdca01bdbea18298014598ca
getUniquePortCfgForId
private String getUniquePortCfgForId(int id)
{    return String.format("server.%d=127.0.0.1:%d:%d", id, PortAssignment.unique(), PortAssignment.unique());}
c9b90144a407e6415b21d91b1491e0aa24e81fc604d94f7bc72e836802159d13
waitForQuorumPeer
private QuorumPeer waitForQuorumPeer(MainThread mainThread, int timeout) throws TimeoutException
{    long start = Time.currentElapsedTime();    while (true) {        QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;        if (quorumPeer != null) {            return quorumPeer;        }        if (Time.currentElapsedTime() > start + timeout) {            LOG.error("Timed out while waiting for QuorumPeer");            throw new TimeoutException();        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }}
ea6864f5ab4ee8940f8b495f743fc30138b8a7e6969b334c981386f88ac8081c
findProposalOfType
private Proposal findProposalOfType(Map<Long, Proposal> proposals, int type)
{    for (Proposal proposal : proposals.values()) {        if (proposal.request.getHdr().getType() == type) {            return proposal;        }    }    return null;}
5c4b9fc820da506ad80a4473ee9cad9c015b56a3a6adfb80bf64949b9a2f2204
testInconsistentDueToNewLeaderOrder
public void testInconsistentDueToNewLeaderOrder() throws Exception
{        final int ENSEMBLE_SERVERS = 3;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];    Context[] contexts = new Context[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        final Context context = new Context();        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);    LOG.info("all servers started");    String nodePath = "/testInconsistentDueToNewLeader";    int leaderId = -1;    int followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }    LOG.info("shutdown follower {}", followerA);    mt[followerA].shutdown();    waitForOne(zk[followerA], States.CONNECTING);    try {                LOG.info("force snapshot sync");        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");                String initialValue = "1";        final ZooKeeper leaderZk = zk[leaderId];        leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        LOG.info("created node {} with value {}", nodePath, initialValue);        CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;                                        leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {            @Override            public void start() {                if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {                    return;                }                final String value = "2";                LOG.info("start forwarding, set {} to {}", nodePath, value);                                try {                    leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {                        public void processResult(int rc, String path, Object ctx, Stat stat) {                        }                    }, null);                                        Thread.sleep(1000);                } catch (Exception e) {                    LOG.error("error when set {} to {}", nodePath, value, e);                }            }        });                                leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {            @Override            public void start() {                String value = "3";                LOG.info("before sending snapshot, set {} to {}", nodePath, value);                try {                    leaderZk.setData(nodePath, value.getBytes(), -1);                    LOG.info("successfully set {} to {}", nodePath, value);                } catch (Exception e) {                    LOG.error("error when set {} to {}, {}", nodePath, value, e);                }            }        });                CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);        LOG.info("set exit when ack new leader packet on {}", followerA);        contexts[followerA].exitWhenAckNewLeader = true;        CountDownLatch latch = new CountDownLatch(1);        final MainThread followerAMT = mt[followerA];        contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {            @Override            public void start() {                try {                    latch.countDown();                    followerAMT.shutdown();                } catch (Exception e) {                }            }        };                LOG.info("starting follower {}", followerA);        mt[followerA].start();        assertTrue(latch.await(30, TimeUnit.SECONDS));                LOG.info("disable exit when ack new leader packet on {}", followerA);        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "false");        contexts[followerA].exitWhenAckNewLeader = true;        contexts[followerA].newLeaderAckCallback = null;        LOG.info("restarting follower {}", followerA);        mt[followerA].start();        zk[followerA].close();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);                        waitForOne(zk[followerA], States.CONNECTED);        assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));    } finally {        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {            mt[i].shutdown();            zk[i].close();        }    }}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain(context);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {        return;    }    final String value = "2";    LOG.info("start forwarding, set {} to {}", nodePath, value);        try {        leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {            }        }, null);                Thread.sleep(1000);    } catch (Exception e) {        LOG.error("error when set {} to {}", nodePath, value, e);    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    String value = "3";    LOG.info("before sending snapshot, set {} to {}", nodePath, value);    try {        leaderZk.setData(nodePath, value.getBytes(), -1);        LOG.info("successfully set {} to {}", nodePath, value);    } catch (Exception e) {        LOG.error("error when set {} to {}, {}", nodePath, value, e);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    try {        latch.countDown();        followerAMT.shutdown();    } catch (Exception e) {    }}
2fb3c09078d2ebb408ee4ffd542579d571851acd30815b09ce38dbcbbab4e4e8
testLeaderElectionWithDisloyalVoter
public void testLeaderElectionWithDisloyalVoter() throws IOException
{    testLeaderElection(5, 3, 1000, 10000);}
895f9156179ad506dda2fd595fe6d65d51640cf5fab991de79c583ad0455476c
testLeaderElectionWithDisloyalVoter_stillHasMajority
public void testLeaderElectionWithDisloyalVoter_stillHasMajority() throws IOException
{    testLeaderElection(5, 5, 3000, 20000);}
361df5702b3c8b725d3f7f44cdaed775fd5ba4e958945a88cfb4eca256bc79af
testLeaderElection
 void testLeaderElection(int totalServers, int serversToStart, int maxTimeToWaitForEpoch, int maxTimeWaitForServerUp) throws IOException
{    Leader.setMaxTimeToWaitForEpoch(maxTimeToWaitForEpoch);        servers = new Servers();    int ENSEMBLE_SERVERS = totalServers;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        int SERVERS_TO_START = serversToStart;    MainThread[] mt = new MainThread[SERVERS_TO_START];    Context[] contexts = new Context[SERVERS_TO_START];    servers.mt = mt;    numServers = SERVERS_TO_START;    for (int i = 0; i < SERVERS_TO_START; i++) {                        final Context context = new Context();        if (i == 0) {            context.quitFollowing = true;        }        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();    }        for (int i = 0; i < SERVERS_TO_START; i++) {        assertTrue("Server " + i + " should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], maxTimeWaitForServerUp));    }}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new CustomizedQPMain(context);}
9b827bb2bbffe2046a98daf589477775ded5ca47f7e02f949cd41590c3e24a7b
testMetricsProviderLifecycle
public void testMetricsProviderLifecycle() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
44a9b9a7e14fe6e6233dd78123702a78303123a88f015018d97c933b3fca752e
testMetricsProviderConfiguration
public void testMetricsProviderConfiguration() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.set(0);        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertEquals(1234, BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.get());}
eafb29cd884aeba064b734e14bdbc55359044f7b75fa63f6d3cda7c823bb4f5b
testFaultyMetricsProviderOnStop
public void testFaultyMetricsProviderOnStop() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStop.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderWithErrorInStop.stopCalled.get());    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Error while stopping metrics.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
7cc8769be4f353e998e8bec17f021643400a11ddb7a8c0b6b28310d19b6351e6
testInvalidMetricsProvider
public void testInvalidMetricsProvider() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=BadClass\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*BadClass.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
ef951c1ede831ba57e981bbaf2022b912d5349d3bf3a340a1105c53c9822733f
testFaultyMetricsProviderOnStart
public void testFaultyMetricsProviderOnStart() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStart.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
1691628a49dece2ce9f3ff290ca6b8c1578aa105911cc3b9d7b585049fcd6cce
testFaultyMetricsProviderOnConfigure
public void testFaultyMetricsProviderOnConfigure() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInConfigure.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer(context);}
c07e1a5e7311208adcd2de1fb206cdebc343de0d1f543ba36ac5067cf37abc9e
setStartForwardingListener
public void setStartForwardingListener(StartForwardingListener startForwardingListener)
{    this.startForwardingListener = startForwardingListener;}
748ef28c42e304c64fa1c6a23aa594834f3f04fdfe7c97bfcd448cf6ade70941
setBeginSnapshotListener
public void setBeginSnapshotListener(BeginSnapshotListener beginSnapshotListener)
{    this.beginSnapshotListener = beginSnapshotListener;}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void followLeader() throws InterruptedException {            if (context.quitFollowing) {                                context.quitFollowing = false;                LOG.info("Quit following");                return;            } else {                super.followLeader();            }        }        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {                if (context.newLeaderAckCallback != null) {                    context.newLeaderAckCallback.start();                }            }            super.writePacket(pp, flush);        }    };}
71ec733f454a8062047c0e3774bca532ac3f4efbabb34898f72995f2722bf5ee
followLeader
 void followLeader() throws InterruptedException
{    if (context.quitFollowing) {                context.quitFollowing = false;        LOG.info("Quit following");        return;    } else {        super.followLeader();    }}
e0f349fa3e3119acd373bcc1eab40223a2138b1e3caae22f4e925347425c4127
writePacket
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {        if (context.newLeaderAckCallback != null) {            context.newLeaderAckCallback.start();        }    }    super.writePacket(pp, flush);}
9105ffbff8576ef0e9b7d69e245693472292266ab9ff7dec3ef6d54033fdb402
makeLeader
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        public long startForwarding(LearnerHandler handler, long lastSeenZxid) {            if (startForwardingListener != null) {                startForwardingListener.start();            }            return super.startForwarding(handler, lastSeenZxid);        }        @Override        public LearnerSyncThrottler getLearnerSnapSyncThrottler() {            if (throttler == null) {                throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {                    @Override                    public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                        if (beginSnapshotListener != null) {                            beginSnapshotListener.start();                        }                        super.beginSync(essential);                    }                };            }            return throttler;        }    };}
590c81d82501cec709409976d1525266c5601d18120183dd6baafb8f84ec7fc5
startForwarding
public long startForwarding(LearnerHandler handler, long lastSeenZxid)
{    if (startForwardingListener != null) {        startForwardingListener.start();    }    return super.startForwarding(handler, lastSeenZxid);}
f6833568ea6b3db84e35a7914da79ae7629ffc8227a8f36c8c1ceb12695af99a
getLearnerSnapSyncThrottler
public LearnerSyncThrottler getLearnerSnapSyncThrottler()
{    if (throttler == null) {        throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {            @Override            public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                if (beginSnapshotListener != null) {                    beginSnapshotListener.start();                }                super.beginSync(essential);            }        };    }    return throttler;}
1cafc26180e96a086decf6ca553a250f6e512fb040d445291979d6e3cd912995
beginSync
public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException
{    if (beginSnapshotListener != null) {        beginSnapshotListener.start();    }    super.beginSync(essential);}
d8a3ec01ffc44eb64a4da2ae5657078a635e3b79207eddc2546474b4939c5c2b
testQuorumPeerListendOnSpecifiedClientIP
public void testQuorumPeerListendOnSpecifiedClientIP() throws IOException
{    long myId = 1;    File dataDir = ClientBase.createTmpDir();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    /**     * QuorumPeer constructor without QuorumVerifier     */    QuorumPeer peer1 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString1 = peer1.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString1);        peer1.shutdown();    /**     * QuorumPeer constructor with QuorumVerifier     */    peersView.clear();    clientPort = PortAssignment.unique();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    QuorumPeer peer2 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString2 = peer2.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString2);        peer2.shutdown();}
3a45696feb3aa45e9f421542924154fd27fcc958d1607915064a3094015761b6
testLocalPeerIsLeader
public void testLocalPeerIsLeader() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsLeader = new Vote(localPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsLeader);    assertTrue(peer.isLeader(localPeerId));}
db1102be06f504804fc5d6eca170de8a5d3fc8f8d6348fa778d3a7911e9046b3
testLocalPeerIsNotLeader
public void testLocalPeerIsNotLeader() throws Exception
{    long localPeerId = 7;    long otherPeerId = 17;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsNotLeader = new Vote(otherPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsNotLeader);    assertFalse(peer.isLeader(localPeerId));}
f0dc022eb3154988362b5affb0392c836a597f9f1d59208317c41c7d0f732ff1
testIsNotLeaderBecauseNoVote
public void testIsNotLeaderBecauseNoVote() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    peer.setCurrentVote(null);    assertFalse(peer.isLeader(localPeerId));}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (servers == null || servers.mt == null) {        LOG.info("No servers to shutdown!");        return;    }    for (int i = 0; i < numServers; i++) {        if (i < servers.mt.length) {            servers.mt[i].shutdown();        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{        if (quorumPeer != null) {        QuorumBase.shutdown(quorumPeer);    }}
350a68f3b8106d3a779c9175e4944699a4ce4471734278be45e41ea91ba99c4a
createDynamicFile
private String createDynamicFile(String quorumCfgSection, String version) throws IOException
{    String filename = "zoo.cfg.dynamic";    if (version != null) {        filename = filename + "." + version;    }    File dynamicConfigFile = new File(tmpDir, filename);    String dynamicConfigFilename = PathUtils.normalizeFileSystemPath(dynamicConfigFile.toString());    FileWriter fDynamicConfigWriter = new FileWriter(dynamicConfigFile);    fDynamicConfigWriter.write(quorumCfgSection);    fDynamicConfigWriter.flush();    fDynamicConfigWriter.close();    return dynamicConfigFilename;}
064527627c0eaaabe4dfc259f62e3d97e10baedd5f3f6e21f1d4a6b9b0ced76a
getDynamicFiles
public File[] getDynamicFiles()
{    return getFilesWithPrefix("zoo.cfg.dynamic");}
f98d1b3ad4f79e66e524dde6185ce159fd4fc0b344f13c03bdb5bd7104dfd3ca
getFilesWithPrefix
public File[] getFilesWithPrefix(final String prefix)
{    return tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith(prefix);        }    });}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return name.startsWith(prefix);}
94d4d9d91d7a90c9c60026bdf10572327a2972c04aeefc2435d163fbe841fa00
getFileByName
public File getFileByName(String filename)
{    File f = new File(tmpDir.getPath(), filename);    return f.isFile() ? f : null;}
904bc6e160b573cf95fbb32d9c3d5f9103eb120ef714a8d1e949f53a46700dbf
writeTempDynamicConfigFile
public void writeTempDynamicConfigFile(String nextQuorumCfgSection, String version) throws IOException
{    File nextDynamicConfigFile = new File(tmpDir, "zoo.cfg" + QuorumPeerConfig.nextDynamicConfigFileSuffix);    FileWriter fwriter = new FileWriter(nextDynamicConfigFile);    fwriter.write(nextQuorumCfgSection + "\n" + "version=" + version);    fwriter.flush();    fwriter.close();}
5b05914888e421f26bff6f39231facdd35759f746a9af780ebac2cf5b2c81932
start
public synchronized void start()
{    main = getTestQPMain();    currentThread = new Thread(this);    currentThread.start();}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new TestQPMain();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                LOG.error("unexpected exception in run", e);    } finally {        currentThread = null;    }}
c135ac932f4d6c51055503a06aaba0b000a6e465c79f8ede96754d3ec24dc422
shutdown
public void shutdown() throws InterruptedException
{    Thread t = currentThread;    if (t != null && t.isAlive()) {        main.shutdown();        t.join(500);    }}
0674c692ac8a3504b7a352ff75144d7a1509521bb5b69ef1ec93bf63d163a99e
join
public void join(long timeout) throws InterruptedException
{    Thread t = currentThread;    if (t != null) {        t.join(timeout);    }}
60197635298ccb91f8d31ad041ff050b33a738f730a72b1ee2ddf49ee0d11ce3
isAlive
public boolean isAlive()
{    Thread t = currentThread;    return t != null && t.isAlive();}
4d2c8b392ca6f2409dab5572b619355353758035e76cc2b12a0fc9b2415e4924
reinitialize
public void reinitialize() throws IOException
{    File dataDir = main.quorumPeer.getTxnFactory().getDataDir();    ClientBase.recursiveDelete(dataDir);    ClientBase.createInitializeFile(dataDir.getParentFile());}
10467dff7b636d87717bb2a678880a6f1eb71adbe346e4b7fac19f9d21153f17
isQuorumPeerRunning
public boolean isQuorumPeerRunning()
{    return main.quorumPeer != null;}
10bc40769e7e2c4cabc57a7c974caec1db62e9895b8b07f3bc397cfca603826a
getPropFromStaticFile
public String getPropFromStaticFile(String key) throws IOException
{    Properties props = new Properties();    props.load(new FileReader(confFile));    return props.getProperty(key, "");}
bab3e52c6319455ddb7465a819a61e39c427c0edc37d5d62a9272023aa570be3
getQuorumPeer
public QuorumPeer getQuorumPeer()
{    return main.quorumPeer;}
3d78a2f78868ea426d80e5da9824fc343a1d951e26c7182cd36e869de7a0dd33
deleteBaseDir
public void deleteBaseDir()
{    ClientBase.recursiveDelete(baseDir);}
5a6b7d855266289f818e541117eb1ee07a1a4e2e20c6b3f1d7e53aac40416331
getMyid
public int getMyid()
{    return myid;}
d2c843315f9f9d41844653347865765b26cd16135f4af42c425b6d8b969322b1
getClientPort
public int getClientPort()
{    return clientPort;}
cd2f3e0da3de1fd7ec5953d3b4f5941120169a4703641ca749fcb0a2d5842f66
getQuorumCfgSection
public String getQuorumCfgSection()
{    return quorumCfgSection;}
1bd8f50bd1f8e50ee869735e479140a4a4449082d9fbf01c1ecd5c3db6674adc
getOtherConfigs
public Map<String, String> getOtherConfigs()
{    return otherConfigs;}
2a1a7f769911bb336355690316fc7baa0b2ac9da8dd8439320f392640c153b19
getConfFile
public File getConfFile()
{    return confFile;}
ab9abe27553b095a844cfd480fb6b31ae3dd3887db34dd4e7b5ed28bd02f65e0
shutDownAllServers
public void shutDownAllServers() throws InterruptedException
{    for (MainThread t : mt) {        t.shutdown();    }}
ffeb85ebfc90d7d4e24a62819b5f6e8bf9087688b7479c782363e3bb28fff381
restartAllServersAndClients
public void restartAllServersAndClients(Watcher watcher) throws IOException, InterruptedException
{    for (MainThread t : mt) {        if (!t.isAlive()) {            t.start();        }    }    for (int i = 0; i < zk.length; i++) {        restartClient(i, watcher);    }}
0af2fcfef5d781b7fe0118c6abac64014d1e56d4ac8ca2727630e4de7c0559d6
restartClient
public void restartClient(int clientIndex, Watcher watcher) throws IOException, InterruptedException
{    if (zk[clientIndex] != null) {        zk[clientIndex].close();    }    zk[clientIndex] = new ZooKeeper("127.0.0.1:" + clientPorts[clientIndex], ClientBase.CONNECTION_TIMEOUT, watcher);}
3bad202e143941f7ed79c94931f55da0376d23b73256490418bbce4c8f0a528d
findLeader
public int findLeader()
{    for (int i = 0; i < mt.length; i++) {        if (mt[i].main.quorumPeer.leader != null) {            return i;        }    }    return -1;}
7810caa9119f520f820dd43683e636954ccafb259dcb4ba1dc14533da3fd0e32
LaunchServers
protected Servers LaunchServers(int numServers) throws IOException, InterruptedException
{    return LaunchServers(numServers, null);}
6438196fab43ecdfe6e9350a392bc4740b9aff2e14ecc340bc78d3552081b24c
LaunchServers
protected Servers LaunchServers(int numServers, Integer tickTime) throws IOException, InterruptedException
{    int SERVER_COUNT = numServers;    QuorumPeerMainTest.Servers svrs = new QuorumPeerMainTest.Servers();    svrs.clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        svrs.clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + svrs.clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    svrs.mt = new MainThread[SERVER_COUNT];    svrs.zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (tickTime != null) {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection, new HashMap<String, String>(), tickTime);        } else {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection);        }        svrs.mt[i].start();        svrs.restartClient(i, this);    }    waitForAll(svrs, ZooKeeper.States.CONNECTED);    return svrs;}
1ab69708f17be5c7da5e8bf9bb665b7a59efcbec3635753447925123215605af
waitForOne
public static void waitForOne(ZooKeeper zk, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (zk.getState() != state) {        if (iterations-- == 0) {            throw new RuntimeException("Waiting too long " + zk.getState() + " != " + state);        }        Thread.sleep(500);    }}
3493de7b151ce926bf5ed8e16abc578cec4ccee28c9253eef11d0fc80a3a4ee3
waitForAll
protected void waitForAll(Servers servers, ZooKeeper.States state) throws InterruptedException
{    waitForAll(servers.zk, state);}
99de207e819421de7a13237c4e8ed7fdc35dfb99b63bca5712b137d43dcac707
waitForAll
public static void waitForAll(ZooKeeper[] zks, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 1000;    boolean someoneNotConnected = true;    while (someoneNotConnected) {        if (iterations-- == 0) {            logStates(zks);            ClientBase.logAllStackTraces();            throw new RuntimeException("Waiting too long");        }        someoneNotConnected = false;        for (ZooKeeper zk : zks) {            if (zk.getState() != state) {                someoneNotConnected = true;                break;            }        }        Thread.sleep(1000);    }}
3ac4b1a1e18f809af7d0b327fce429479ef73800a0f7af62aabe64aea38fa3f2
logStates
public static void logStates(ZooKeeper[] zks)
{    StringBuilder sbBuilder = new StringBuilder("Connection States: {");    for (int i = 0; i < zks.length; i++) {        sbBuilder.append(i + " : " + zks[i].getState() + ", ");    }    sbBuilder.append('}');    LOG.error(sbBuilder.toString());}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING }, { ServerState.FOLLOWING }, { ServerState.OBSERVING } });}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    CountdownWatcher clientWatch = new CountdownWatcher();    super.setUp(true);    zkClient = createClient(clientWatch, getPeersMatching(serverState));    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    zkClient.close();    super.tearDown();}
b3502584e070a98dc90e9a6ac8eb5a05dbda2c76cb83455e6b54e568892b35c9
create2EmptyNode
private Stat create2EmptyNode(TestableZooKeeper zkClient, String path) throws Exception
{    Stat stat = new Stat();    zkClient.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    return stat;}
a66dfa0a0dc44c8498730b66bb882e7c65e66f27e31ffe53ff36181d8fbb6615
testCreate
public void testCreate() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertArrayEquals(String.format("%s Node created (create) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
d725ce9a6cfc486179fe148eb5c5e2b91699f555b863405eacf368493514b6fb
testCreate2
public void testCreate2() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertArrayEquals(String.format("%s Node created (create2) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
d588d24d86f0ebbff2cd80210ca2cce069b8c9b5ef0b61e20fb792c431381f7f
testDelete
public void testDelete() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.delete(PARENT_PATH, -1);    assertNull(String.format("%s Node no longer exists", serverState), zkClient.exists(PARENT_PATH, false));}
a66c7b514e0cc7acf178878248fde23c7820d4057ff4d4b6ffbfe0da9250b526
testExists
public void testExists() throws Exception
{    Stat stat = create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Exists returns correct node stat", serverState), stat, zkClient.exists(PARENT_PATH, false));}
0102122b2c08caf6e8d13ecfa5631ef917057569589617e9e1fa19b1651ec05b
testSetAndGetData
public void testSetAndGetData() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.setData(PARENT_PATH, DATA, -1);    assertArrayEquals(String.format("%s Node updated with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
d10ab29916c97d12e18cb28fed8cd821bffee2b2e09fed0b28c0e3e0e8f1f14f
testSetAndGetACL
public void testSetAndGetACL() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Node has open ACL", serverState), Ids.OPEN_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));    zkClient.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals(String.format("%s Node has world read-only ACL", serverState), Ids.READ_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));}
8ec96cc5bc104c2c0a7a8b87a776a88a73e521a9d6dbed4ef83c0f9cd569b1ce
testSetAndGetChildren
public void testSetAndGetChildren() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false)));}
00180561fad50bd40243971d013b01b3d74641eb2f2268e05163dcef734aeb81
testSetAndGetChildren2
public void testSetAndGetChildren2() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false, null)));}
5662ea62c800aca7fb2a0e9f97d55ff62980971a589d1449838c92ba5eae18c8
testSync
public void testSync() throws Exception
{    complete = false;    create2EmptyNode(zkClient, PARENT_PATH);    VoidCallback onSync = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            complete = true;            callComplete.countDown();        }    };    zkClient.sync(PARENT_PATH, onSync, null);    callComplete.await(30, TimeUnit.SECONDS);    assertTrue(String.format("%s Sync completed", serverState), complete);}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    complete = true;    callComplete.countDown();}
7b19a8a01a00bdbc27d138aff7d4518cf4d3e9f94148937ffd129d117e41a4dc
testToString
public void testToString() throws ConfigException
{    String provided = ipv4config + ":participant;0.0.0.0:1237";    String expected = ipv4config + ":participant;0.0.0.0:1237";    QuorumServer qs = new QuorumServer(0, provided);    assertEquals("Use IP address", expected, qs.toString());    provided = ipv4config + ";0.0.0.0:1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Type unspecified", expected, qs.toString());    provided = ipv4config + ":observer;0.0.0.0:1237";    expected = ipv4config + ":observer;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Observer type", expected, qs.toString());    provided = ipv4config + ":participant;1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address unspecified", expected, qs.toString());    provided = ipv4config + ":participant;1.2.3.4:1237";    expected = ipv4config + ":participant;1.2.3.4:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address specified", expected, qs.toString());    provided = "example.com:1234:1236:participant;1237";    expected = "example.com:1234:1236:participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Use hostname", expected, qs.toString());}
99267799bb3a4c001fbb5739f2df76cc0c19c5c961ecc8a21fb6f63b6505d1a5
constructionUnderstandsIpv6LiteralsInServerConfig
public void constructionUnderstandsIpv6LiteralsInServerConfig() throws ConfigException
{    String config = "[::1]:1234:1236:participant";    QuorumServer qs = new QuorumServer(0, config);    assertEquals("[0:0:0:0:0:0:0:1]:1234:1236:participant", qs.toString());}
02d41fd609304991831fd330905f14d721b23fa611f55889dfadb12f6f11054f
constructionUnderstandsIpv6LiteralsInClientConfig
public void constructionUnderstandsIpv6LiteralsInClientConfig() throws ConfigException
{    String config = ipv4config + ":participant;[::1]:1237";    QuorumServer qs = new QuorumServer(0, config);    assertEquals(ipv4config + ":participant;[0:0:0:0:0:0:0:1]:1237", qs.toString());}
f8317cb5ff9ae29461cc963912ffb8f1ec892f9b5d6f92921eb33f908ad441ef
unbalancedIpv6LiteralsInServerConfigFailToBeParsed
public void unbalancedIpv6LiteralsInServerConfigFailToBeParsed() throws ConfigException
{    new QuorumServer(0, "[::1:1234:1236:participant");}
ce4bd078f0940acbf2e24e4eb6efce09a577e1e97ff9015336c1c4e53863cdc6
unbalancedIpv6LiteralsInClientConfigFailToBeParsed
public void unbalancedIpv6LiteralsInClientConfigFailToBeParsed() throws ConfigException
{    new QuorumServer(0, ipv4config + ":participant;[::1:1237");}
549227cf1179177d9ae515ca4bb18b4fe7a5eece7366facea0e35612375d28c5
testWildcard
public void testWildcard() throws KeeperException.BadArgumentsException
{    String[] addrs = new String[] { "127.0.0.1", "[0:0:0:0:0:0:0:1]", "0.0.0.0", "[::]" };    for (int i = 0; i < addrs.length; i++) {        for (int j = i; j < addrs.length; j++) {            QuorumPeer.QuorumServer server1 = new             QuorumPeer.QuorumServer(            1,             new InetSocketAddress(ipv6n1, 1234),             new InetSocketAddress(ipv6n1, 1236),             new InetSocketAddress(addrs[i], 1237));            QuorumPeer.QuorumServer server2 = new             QuorumPeer.QuorumServer(            2,             new InetSocketAddress(ipv6n2, 1234),             new InetSocketAddress(ipv6n2, 1236),             new InetSocketAddress(addrs[j], 1237));            server1.checkAddressDuplicate(server2);        }    }}
3b6d5fd3cc68d7f92e327e7ea30a3e507f3f814d89bdeab68b325943a72259da
testDuplicate
public void testDuplicate() throws KeeperException.BadArgumentsException
{    QuorumPeer.QuorumServer server1 = new     QuorumPeer.QuorumServer(    1,     new InetSocketAddress(ipv6n1, 1234),     new InetSocketAddress(ipv6n1, 1236),     new InetSocketAddress(ipv6n1, 1237));    QuorumPeer.QuorumServer server2 = new     QuorumPeer.QuorumServer(    2,     new InetSocketAddress(ipv6n2, 1234),     new InetSocketAddress(ipv6n2, 1236),     new InetSocketAddress(ipv6n1, 1237));    server1.checkAddressDuplicate(server2);}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    quorumX509Util = new QuorumX509Util();    ClientBase.setupTestEnv();    tmpDir = createTmpDir().getAbsolutePath();    clientPortQp1 = PortAssignment.unique();    clientPortQp2 = PortAssignment.unique();    clientPortQp3 = PortAssignment.unique();    validKeystorePath = tmpDir + "/valid.jks";    truststorePath = tmpDir + "/truststore.jks";    quorumConfiguration = generateQuorumConfiguration();    Security.addProvider(new BouncyCastleProvider());    certStartTime = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(certStartTime);    cal.add(Calendar.YEAR, 1);    certEndTime = cal.getTime();    rootKeyPair = createKeyPair();    contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(rootKeyPair.getPrivate());    rootCertificate = createSelfSignedCertifcate(rootKeyPair);        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    trustStore.load(null, PASSWORD);    trustStore.setCertificateEntry(rootCertificate.getSubjectDN().toString(), rootCertificate);    FileOutputStream outputStream = new FileOutputStream(truststorePath);    trustStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();    defaultKeyPair = createKeyPair();    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, "127.0.0.1", null, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    setSSLSystemProperties();}
386c114d698f64373a66c113eab30111fa50dbc06baebb77645bad334be12139
writeKeystore
private void writeKeystore(X509Certificate certificate, KeyPair entityKeyPair, String path) throws Exception
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    keyStore.load(null, PASSWORD);    keyStore.setKeyEntry("alias", entityKeyPair.getPrivate(), PASSWORD, new Certificate[] { certificate });    FileOutputStream outputStream = new FileOutputStream(path);    keyStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();}
31dd2b129c36dd59460c51796ed07af423b49f48ab1fa489b6575d23006fb974
handle
public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException
{    byte[] responseBytes;    try {        InputStream request = httpExchange.getRequestBody();        byte[] requestBytes = new byte[10000];        request.read(requestBytes);        OCSPReq ocspRequest = new OCSPReq(requestBytes);        Req[] requestList = ocspRequest.getRequestList();        DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);        BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);        for (Req req : requestList) {            CertificateID certId = req.getCertID();            CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());            CertificateStatus certificateStatus;            if (revokedCertId.equals(certId)) {                certificateStatus = new UnknownStatus();            } else {                certificateStatus = CertificateStatus.GOOD;            }            responseBuilder.addResponse(certId, certificateStatus, null);        }        X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };        ContentSigner signer = new JcaContentSignerBuilder("SHA1withRSA").setProvider("BC").build(rootKeyPair.getPrivate());        BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());        responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();    } catch (OperatorException | CertificateEncodingException | OCSPException exception) {        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();    }    Headers rh = httpExchange.getResponseHeaders();    rh.set("Content-Type", "application/ocsp-response");    httpExchange.sendResponseHeaders(200, responseBytes.length);    OutputStream os = httpExchange.getResponseBody();    os.write(responseBytes);    os.close();}
1f37c6d6caf6f755356f175fab1e5f2933a0c779c974678ed2872e46169e7c53
createSelfSignedCertifcate
private X509Certificate createSelfSignedCertifcate(KeyPair keyPair) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, HOSTNAME);    BigInteger serialNumber = new BigInteger(128, new Random());    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, certStartTime, certEndTime, nameBuilder.build(), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner));}
0eaaf7ffadd334dd996b93f6d98b71d48a9d8965f142e6acdc66bdd86b71c078
buildCRL
private void buildCRL(X509Certificate x509Certificate, String crlPath) throws Exception
{    X509v2CRLBuilder builder = new JcaX509v2CRLBuilder(x509Certificate.getIssuerX500Principal(), certStartTime);    builder.addCRLEntry(x509Certificate.getSerialNumber(), certStartTime, CRLReason.cACompromise);    builder.setNextUpdate(certEndTime);    builder.addExtension(Extension.authorityKeyIdentifier, false, new JcaX509ExtensionUtils().createAuthorityKeyIdentifier(rootCertificate));    builder.addExtension(Extension.cRLNumber, false, new CRLNumber(new BigInteger("1000")));    X509CRLHolder cRLHolder = builder.build(contentSigner);    PemWriter pemWriter = new PemWriter(new FileWriter(crlPath));    pemWriter.writeObject(new MiscPEMGenerator(cRLHolder));    pemWriter.flush();    pemWriter.close();}
2cfe4071238cf792c32b08249e95e4573596aa8ccfefd21a54a19f261df12627
buildEndEntityCert
public X509Certificate buildEndEntityCert(KeyPair keyPair, X509Certificate caCert, PrivateKey caPrivateKey, String hostname, String ipAddress, String crlPath, Integer ocspPort) throws Exception
{    X509CertificateHolder holder = new JcaX509CertificateHolder(caCert);    ContentSigner signer = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(caPrivateKey);    List<GeneralName> generalNames = new ArrayList<>();    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    SubjectPublicKeyInfo entityKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(PublicKeyFactory.createKey(keyPair.getPublic().getEncoded()));    X509ExtensionUtils extensionUtils = new BcX509ExtensionUtils();    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(holder.getSubject(), new BigInteger(128, new Random()), certStartTime, certEndTime, new X500Name("CN=Test End Entity Certificate"), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.authorityKeyIdentifier, false, extensionUtils.createAuthorityKeyIdentifier(holder)).addExtension(Extension.subjectKeyIdentifier, false, extensionUtils.createSubjectKeyIdentifier(entityKeyInfo)).addExtension(Extension.basicConstraints, true, new BasicConstraints(false)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    if (crlPath != null) {        DistributionPointName distPointOne = new DistributionPointName(new GeneralNames(new GeneralName(GeneralName.uniformResourceIdentifier, "file://" + crlPath)));        certificateBuilder.addExtension(Extension.cRLDistributionPoints, false, new CRLDistPoint(new DistributionPoint[] { new DistributionPoint(distPointOne, null, null) }));    }    if (ocspPort != null) {        certificateBuilder.addExtension(Extension.authorityInfoAccess, false, new AuthorityInformationAccess(X509ObjectIdentifiers.ocspAccessMethod, new GeneralName(GeneralName.uniformResourceIdentifier, "http://" + hostname + ":" + ocspPort)));    }    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(signer));}
12ad7bf6c7041aa42a219bf03a6c635db578a9c1d95e9b3437b2311ea08bb08c
createKeyPair
private KeyPair createKeyPair() throws NoSuchProviderException, NoSuchAlgorithmException
{    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    KeyPair keyPair = keyPairGenerator.genKeyPair();    return keyPair;}
ced0ecc6f0990fe65066e6555ae90b9ab00742fef67170921e1fb3eab5fb3c79
generateQuorumConfiguration
private String generateQuorumConfiguration()
{    int portQp1 = PortAssignment.unique();    int portQp2 = PortAssignment.unique();    int portQp3 = PortAssignment.unique();    int portLe1 = PortAssignment.unique();    int portLe2 = PortAssignment.unique();    int portLe3 = PortAssignment.unique();    return "server.1=127.0.0.1:" + (portQp1) + ":" + (portLe1) + ";" + clientPortQp1 + "\n" + "server.2=127.0.0.1:" + (portQp2) + ":" + (portLe2) + ";" + clientPortQp2 + "\n" + "server.3=127.0.0.1:" + (portQp3) + ":" + (portLe3) + ";" + clientPortQp3;}
1f58581dfc81310a7b349987f6fe5d5319376236ccceec486f7c02aff343640b
setSSLSystemProperties
public void setSSLSystemProperties()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), validKeystorePath);    System.setProperty(quorumX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(quorumX509Util.getSslTruststoreLocationProperty(), truststorePath);    System.setProperty(quorumX509Util.getSslTruststorePasswdProperty(), "testpass");}
9f9959a1e141c5bc3f8e05f7e22fae6e4e30756c2bcff07f4ba26555d5b423e1
cleanUp
public void cleanUp() throws Exception
{    clearSSLSystemProperties();    if (q1 != null) {        q1.shutdown();    }    if (q2 != null) {        q2.shutdown();    }    if (q3 != null) {        q3.shutdown();    }    Security.removeProvider("BC");    quorumX509Util.close();}
2a7ebf778c522691d36fbf3e2ed5fcd680daf0bf37270a77965f27b4d4d3ec46
clearSSLSystemProperties
private void clearSSLSystemProperties()
{    System.clearProperty(quorumX509Util.getSslKeystoreLocationProperty());    System.clearProperty(quorumX509Util.getSslKeystorePasswdProperty());    System.clearProperty(quorumX509Util.getSslTruststoreLocationProperty());    System.clearProperty(quorumX509Util.getSslTruststorePasswdProperty());    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    System.clearProperty(quorumX509Util.getSslOcspEnabledProperty());    System.clearProperty(quorumX509Util.getSslCrlEnabledProperty());    System.clearProperty(quorumX509Util.getCipherSuitesProperty());    System.clearProperty(quorumX509Util.getSslProtocolProperty());}
64e9e3f0c5dc1a083e98a52fd9b89c44df157a1fc2ab8705bfa7af99c7e0b5d8
testQuorumSSL
public void testQuorumSSL() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    clearSSLSystemProperties();        q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
1b20f43c01ddf96f1c1fbda89776851393d4c42d5a9eae11ccfd8e2e4759d39e
testRollingUpgrade
public void testRollingUpgrade() throws Exception
{        q1 = new MainThread(1, clientPortQp1, quorumConfiguration);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration);    q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    Map<Integer, MainThread> members = new HashMap<>();    members.put(clientPortQp1, q1);    members.put(clientPortQp2, q2);    members.put(clientPortQp3, q3);    for (MainThread member : members.values()) {        member.start();    }    for (int clientPort : members.keySet()) {        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }        setSSLSystemProperties();    stopAppendConfigRestartAll(members, PORT_UNIFICATION_ENABLED);    stopAppendConfigRestartAll(members, SSL_QUORUM_ENABLED);    stopAppendConfigRestartAll(members, PORT_UNIFICATION_DISABLED);}
6417199d79a662c8818b84465eedc212aab45fd27f455213100a03f771e0c789
stopAppendConfigRestartAll
private void stopAppendConfigRestartAll(Map<Integer, MainThread> members, String config) throws Exception
{    for (Map.Entry<Integer, MainThread> entry : members.entrySet()) {        int clientPort = entry.getKey();        MainThread member = entry.getValue();        member.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));        FileWriter fileWriter = new FileWriter(member.getConfFile(), true);        fileWriter.write(config);        fileWriter.flush();        fileWriter.close();        member.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }}
b846f653aabb658f08b1c99f4ccb0ff6390921d677adfce3a0b05ac13a156b51
testHostnameVerificationWithInvalidHostname
public void testHostnameVerificationWithInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", null, null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
3c8bd3d10d78eacbcea9f7643805bec9f4e842d1eda0636ffe73886d3b83662e
testHostnameVerificationWithInvalidIPAddress
public void testHostnameVerificationWithInvalidIPAddress() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), null, "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
aa0356302e77fdd7414f29118cdaa557ef2f6376a7602a0d7b4f09721bc838ba
testHostnameVerificationWithInvalidIpAddressAndInvalidHostname
public void testHostnameVerificationWithInvalidIpAddressAndInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
4f0a645f6ab87e79630912a2d50e1eabf4dcdeff99797a5d5de138f4e4cddadd
testHostnameVerificationWithInvalidIpAddressAndValidHostname
public void testHostnameVerificationWithInvalidIpAddressAndValidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "localhost", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
21889758ba9c9eef496f85d93a4749cb83bff2831936a9155a0ccdc4507b2173
testHostnameVerificationWithValidIpAddressAndInvalidHostname
public void testHostnameVerificationWithValidIpAddressAndInvalidHostname() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "127.0.0.1", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
b1c145109ce41f9e2e555232b8363c80b711c4f55b8bb347ce28b3553c554e8d
testHostnameVerification
private void testHostnameVerification(String keystorePath, boolean expectSuccess) throws Exception
{    System.setProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty(), "false");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);    q3.start();    assertEquals(expectSuccess, ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
85ae7c60f8acf9197e96dbb32733c5bda45070c03877e9908298f20b6f48bfff
testCertificateRevocationList
public void testCertificateRevocationList() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInCRLKeystorePath = tmpDir + "/crl_revoked.jks";    String crlPath = tmpDir + "/crl.pem";    X509Certificate revokedInCRLCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(revokedInCRLCert, defaultKeyPair, revokedInCRLKeystorePath);    buildCRL(revokedInCRLCert, crlPath);    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.setProperty(quorumX509Util.getSslCrlEnabledProperty(), "true");    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
33c02210640561ac34ae1484fa57ba08173fdb187be172aa4bed59f1136c2332
testOCSP
public void testOCSP() throws Exception
{    Integer ocspPort = PortAssignment.unique();    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInOCSPKeystorePath = tmpDir + "/ocsp_revoked.jks";    X509Certificate revokedInOCSPCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);    writeKeystore(revokedInOCSPCert, defaultKeyPair, revokedInOCSPKeystorePath);    HttpServer ocspServer = HttpServer.create(new InetSocketAddress(ocspPort), 0);    try {        ocspServer.createContext("/", new OCSPHandler(revokedInOCSPCert));        ocspServer.start();        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);                q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);        q3.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        setSSLSystemProperties();        System.setProperty(quorumX509Util.getSslOcspEnabledProperty(), "true");        X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);        writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);        q1.start();        q2.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);        q3.start();        assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    } finally {        ocspServer.stop(0);    }}
ee6e0e110ba6194c255a9ef213d450141c6f805a4fbd8cab567fd21a16f9b288
testCipherSuites
public void testCipherSuites() throws Exception
{        SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();    List<String> defaultCiphers = new ArrayList<String>();    for (String cipher : ssf.getDefaultCipherSuites()) {        if (!cipher.matches(".*EMPTY.*") && cipher.startsWith("TLS") && cipher.contains("RSA")) {            defaultCiphers.add(cipher);        }    }    if (defaultCiphers.size() < 2) {        fail("JDK has to support at least 2 valid (RSA) cipher suites for this test to run");    }        String suitesOfEnsemble = String.join(",", defaultCiphers.subList(1, defaultCiphers.size()));    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suitesOfEnsemble);    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        String suiteOfClient = defaultCiphers.get(0);    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suiteOfClient);            q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
5c220b6e15e7c46af26693e393a9cb695e5f95c7b8a75741d37683fb2dc716a4
testProtocolVersion
public void testProtocolVersion() throws Exception
{    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.2");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.1");        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
1eaf9b1e0a018b151b4a4069c54d4d25bf511f65db081af973b8750302eca735
testRaceConditionBetweenLeaderAndAckRequestProcessor
public void testRaceConditionBetweenLeaderAndAckRequestProcessor() throws Exception
{    mt = startQuorum();        QuorumPeer leader = getLeader(mt);    long oldLeaderCurrentEpoch = leader.getCurrentEpoch();    assertNotNull("Leader should not be null", leader);            shutdownFollowers(mt);    /**     * <pre>     * Verify that there is no deadlock in following ways:     * 1) If leader is in LOOKING or FOLLOWING, we are sure there is no deadlock.     * 2) If leader in in LEADING state then we have to check that this LEADING state is     * after the leader election, not the old LEADING state.     * </pre>     */    boolean leaderStateChanged = ClientBase.waitForServerState(leader, 15000, QuorumStats.Provider.LOOKING_STATE, QuorumStats.Provider.FOLLOWING_STATE);        assertTrue("Failed to bring up the old leader server", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    assertTrue("Leader failed to transition to new state. Current state is " + leader.getServerState(), leaderStateChanged || (leader.getCurrentEpoch() > oldLeaderCurrentEpoch));}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{        if (null != mt) {        for (int i = 0; i < SERVER_COUNT; i++) {            try {                                                mt[i].shutdown();            } catch (InterruptedException e) {                LOG.warn("Quorum Peer interrupted while shutting it down", e);            }        }    }}
d7b8021a35c1a13e08c8ffdeded304c2ced0a1e7dfd485f02c1dafdf704e53d0
startQuorum
private MainThread[] startQuorum() throws IOException
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    return mt;}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
722cf1b52430674055b47db206f6745a432af0d321931f0c333653c04493b4ee
getLeader
private QuorumPeer getLeader(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
fb6c6b63918c9076564a290e715d895905b54c64228ba106b6a7ee211f7681c0
shutdownFollowers
private void shutdownFollowers(MainThread[] mt)
{    for (int i = 0; i < mt.length; i++) {        CustomQuorumPeer quorumPeer = (CustomQuorumPeer) mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.FOLLOWING == quorumPeer.getPeerState()) {            quorumPeer.setStopPing(true);        }    }}
b1ada2b8c4027a4b13e52787ca776962b0cc9e214818bdb0a5bf9b8efc9258ef
setStopPing
public void setStopPing(boolean stopPing)
{    this.stopPing = stopPing;}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void processPacket(QuorumPacket qp) throws Exception {            if (stopPing && qp.getType() == Leader.PING) {                LOG.info("Follower skipped ping");                throw new SocketException("Socket time out while sending the ping response");            } else {                super.processPacket(qp);            }        }    };}
3c48129e174442c741c73efe4e75fb1b7199a7e9897b2a57fa106015e86974e4
processPacket
protected void processPacket(QuorumPacket qp) throws Exception
{    if (stopPing && qp.getType() == Leader.PING) {        LOG.info("Follower skipped ping");        throw new SocketException("Socket time out while sending the ping response");    } else {        super.processPacket(qp);    }}
9105ffbff8576ef0e9b7d69e245693472292266ab9ff7dec3ef6d54033fdb402
makeLeader
protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        protected void setupRequestProcessors() {            /**             * This method is overridden to make a place to inject             * MockSyncRequestProcessor             */            RequestProcessor finalProcessor = new FinalRequestProcessor(this);            RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());            commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());            commitProcessor.start();            ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);            proposalProcessor.initialize();            prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);            prepRequestProcessor.start();            firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);        }    };    return new Leader(this, zk);}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    /**     * This method is overridden to make a place to inject     * MockSyncRequestProcessor     */    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    /**     * Add a request so that something is there for SyncRequestProcessor     * to process, while we are in shutdown flow     */    Request request = new Request(null, 0, 0, ZooDefs.OpCode.delete, ByteBuffer.wrap("/deadLockIssue".getBytes()), null);    processRequest(request);    super.shutdown();}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new CustomQuorumPeer();}
b7061c53768e6ea23a63dd2cd1ee82f8e94d9b358f82b607d47f361bc43ee5ec
getVersionFromConfigStr
public static String getVersionFromConfigStr(String config) throws IOException
{    Properties props = new Properties();    props.load(new StringReader(config));    return props.getProperty("version", "");}
0fde1aa068302bf4190901593618cd19389054f000d04a19e98f38e711504f19
getFileContent
public static String getFileContent(File file) throws FileNotFoundException
{    Scanner sc = new Scanner(file);    StringBuilder sb = new StringBuilder();    while (sc.hasNextLine()) {        sb.append(sc.nextLine() + "\n");    }    return sb.toString();}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    ClientBase.setupTestEnv();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
f3a5b7d7d01476dbf4260db5e8e250f9f9b193d1bdbd008529ac006eaca16735
testBackupStatic
public void testBackupStatic() throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    String[] staticFileContent = new String[SERVER_COUNT];    String[] staticBackupContent = new String[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);                assertNull("static file backup shouldn't exist before bootup", mt[i].getFileByName("zoo.cfg.bak"));        staticFileContent[i] = getFileContent(mt[i].confFile);        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        File backupFile = mt[i].getFileByName("zoo.cfg.bak");        assertNotNull("static file backup should exist", backupFile);        staticBackupContent[i] = getFileContent(backupFile);        assertEquals(staticFileContent[i], staticBackupContent[i]);    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
8f96882b25dda013a50a3c7d5c5c1fa50dd52c05ea40c2f6f50de870d81aaa0f
testReconfigCreateNewVersionFile
public void testReconfigCreateNewVersionFile() throws Exception
{    final int SERVER_COUNT = 3;    final int NEW_SERVER_COUNT = 5;    final int[] clientPorts = new int[NEW_SERVER_COUNT];    final int[] quorumPorts = new int[NEW_SERVER_COUNT];    final int[] electionPorts = new int[NEW_SERVER_COUNT];    final String[] servers = new String[NEW_SERVER_COUNT];    StringBuilder sb = new StringBuilder();    ArrayList<String> oldServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < NEW_SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        servers[i] = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant;localhost:" + clientPorts[i];        newServers.add(servers[i]);        if (i >= SERVER_COUNT) {            continue;        }        oldServers.add(servers[i]);        sb.append(servers[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[NEW_SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[NEW_SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[NEW_SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, "reconfigEnabled=true\n");        mt[i].start();    }    String firstVersion = null, secondVersion = null;        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], oldServers, null);        String configVersion = getVersionFromConfigStr(configStr);                        assertEquals(version, configVersion);        if (i == 0) {            firstVersion = version;        } else {            assertEquals(firstVersion, version);        }    }    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection + servers[i]);        mt[i].start();    }        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);    }        for (int i = 0; i < NEW_SERVER_COUNT; i++) {        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], newServers, null);        String quorumVersion = getVersionFromConfigStr(configStr);        assertEquals(version, quorumVersion);        if (i == 0) {            secondVersion = version;            assertTrue(Long.parseLong(secondVersion, 16) > Long.parseLong(firstVersion, 16));        } else {            assertEquals(secondVersion, version);        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
55907a774029a187eabdeae6c8ab936a1c970dd38af3e85643d6b4f74fb985df
testVersionOfDynamicFilename
public void testVersionOfDynamicFilename() throws Exception
{    final int SERVER_COUNT = 5;    final int oldServerCount = 3;    final int lagOffServerId = 0;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    StringBuilder oldSb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        allServers.add(server);        if (i < oldServerCount) {                        oldSb.append(server + "\n");        }    }    String currentQuorumCfgSection = sb.toString();    String oldQuorumCfg = oldSb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (i == lagOffServerId) {            mt[i] = new MainThread(i, clientPorts[i], oldQuorumCfg, true, "100000000");        } else {            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "200000000");        }                if (i == lagOffServerId) {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.100000000"));            assertNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".100000000"));        } else {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));        }        mt[i].start();    }    String dynamicFileContent = null;    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);                        String configStr = ReconfigTest.testServerHasConfig(zk, allServers, null);        assertEquals("200000000", getVersionFromConfigStr(configStr));        List<String> configLines = Arrays.asList(configStr.split("\n"));        Collections.sort(configLines);        String sortedConfigStr = StringUtils.joinStrings(configLines, "\n");        File dynamicConfigFile = mt[i].getFileByName("zoo.cfg.dynamic.200000000");        assertNotNull(dynamicConfigFile);                if (i == 0) {            dynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(sortedConfigStr, dynamicFileContent + "version=200000000");        } else {            String otherDynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(dynamicFileContent, otherDynamicFileContent);        }        zk.close();    }            assertTrue(mt[lagOffServerId].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
b2565899adc3413782adc5be6436225202a02a7bc72c78f3aa8dc42d0f216c2c
testDuringLeaderSync
public void testDuringLeaderSync() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT + 1];    StringBuilder sb = new StringBuilder();    String[] serverConfig = new String[SERVER_COUNT + 1];    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        serverConfig[i] = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(serverConfig[i] + "\n");    }    String currentQuorumCfgSection = sb.toString();    mt = new MainThread[SERVER_COUNT + 1];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeperAdmin preReconfigClient = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watch);    preReconfigClient.addAuthInfo("digest", "super:test".getBytes());    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        int joinerId = SERVER_COUNT;    clientPorts[joinerId] = PortAssignment.unique();    serverConfig[joinerId] = "server." + joinerId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[joinerId];        int leaderId = -1;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;            break;        }    }    assertFalse(leaderId == -1);        sb = new StringBuilder();    sb.append(serverConfig[leaderId] + "\n").append(serverConfig[joinerId] + "\n");    /**     * This server will delay the response to a NEWLEADER message, and run     * reconfig command so that message at this processed in bellow order     *     * <pre>     * NEWLEADER     * reconfig's PROPOSAL     * reconfig's COMMITANDACTIVATE     * UPTODATE     * </pre>     */    mt[joinerId] = new MainThread(joinerId, clientPorts[joinerId], sb.toString(), false) {        @Override        public TestQPMain getTestQPMain() {            return new MockTestQPMain();        }    };    mt[joinerId].start();    CustomQuorumPeer qp = getCustomQuorumPeer(mt[joinerId]);        String nextDynamicConfigFilename = qp.getNextDynamicConfigFilename();    File nextDynaFile = new File(nextDynamicConfigFilename);    nextDynaFile.delete();        while (true) {        if (qp.isNewLeaderMessage()) {            preReconfigClient.reconfigure(serverConfig[joinerId], null, null, -1, null, null);            break;        } else {                        Thread.sleep(10);        }    }    watch = new CountdownWatcher();    ZooKeeper postReconfigClient = new ZooKeeper("127.0.0.1:" + clientPorts[joinerId], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        postReconfigClient.create("/reconfigIssue", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("zoo.cfg.dynamic.next is not deleted.", nextDynaFile.exists());        for (long j = 0; j <= SERVER_COUNT; j++) {        assertNotNull("server " + j + " is not present in the new quorum", qp.getQuorumVerifier().getVotingMembers().get(j));    }        preReconfigClient.close();    postReconfigClient.close();}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return new MockTestQPMain();}
f0b1442f082584099db2bff7355a27999bd0ed1e9e0f7f7a7b81cd7c371e76fd
getCustomQuorumPeer
private static CustomQuorumPeer getCustomQuorumPeer(MainThread mt)
{    while (true) {        QuorumPeer quorumPeer = mt.getQuorumPeer();        if (null != quorumPeer) {            return (CustomQuorumPeer) quorumPeer;        } else {            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{        if (null != mt) {        for (int i = 0; i < mt.length; i++) {            try {                mt[i].shutdown();            } catch (InterruptedException e) {                LOG.warn("Quorum Peer interrupted while shutting it down", e);            }        }    }}
0ed2900bdd9b2589d898125e69f468b30b00b73d9a5c0f554834e5078f299cae
isNewLeaderMessage
public boolean isNewLeaderMessage()
{    return newLeaderMessage;}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK) {                newLeaderMessage = true;                try {                    /**                     * Delaying the ACK message, a follower sends as                     * response to a NEWLEADER message, so that the                     * leader has a chance to send the reconfig and only                     * then the UPTODATE message.                     */                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            super.writePacket(pp, flush);        }    };}
e0f349fa3e3119acd373bcc1eab40223a2138b1e3caae22f4e925347425c4127
writePacket
 void writePacket(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK) {        newLeaderMessage = true;        try {            /**             * Delaying the ACK message, a follower sends as             * response to a NEWLEADER message, so that the             * leader has a chance to send the reconfig and only             * then the UPTODATE message.             */            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    super.writePacket(pp, flush);}
ba8f4a39ffacc86b5c20f0e8e0cc7fa78750a31035f05b9df13090ba10057be0
runFromConfig
public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException
{    quorumPeer = new CustomQuorumPeer(config.getQuorumVerifier().getAllMembers(), config.getDataDir(), config.getDataLogDir(), config.getClientPortAddress().getPort(), config.getElectionAlg(), config.getServerId(), config.getTickTime(), config.getInitLimit(), config.getSyncLimit(), config.getConnectToLearnerMasterLimit());    quorumPeer.setConfigFileName(config.getConfigFilename());    quorumPeer.start();    try {        quorumPeer.join();    } catch (InterruptedException e) {        LOG.warn("Quorum Peer interrupted", e);    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (qu != null) {        qu.tearDown();    }}
2f1e11801acbf7f2d76fb6d71c9434f51ece2177c94b31e891c218a92bd5ed23
testIncrementalReconfigInvokedOnHiearchicalQS
public void testIncrementalReconfigInvokedOnHiearchicalQS() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    ArrayList<String> members = new ArrayList<String>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }        ReconfigTest.reconfig(zkAdminArr[1], null, null, members, -1);    ReconfigTest.testNormalOperation(zkArr[1], zkArr[2]);        List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config isn't Majority QS");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
c9a15c18b8e03f4b072a5ce755ffbdfdc2148148036ce1c62aae7810df6d0cca
testTooFewRemainingPariticipants
public void testTooFewRemainingPariticipants() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("2");    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
e2efbc23849efc1057189ab99783d0e359875c4817b034a9ebd6c12b2e47ffbf
testReconfigVersionConditionFails
public void testReconfigVersionConditionFails() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, 8, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadVersionException e) {        } catch (Exception e) {        fail("Should have been BadVersionException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
4ae53308fa5fae1c74093a75b2e2e7f5763c7b739fa6d44fd5bd5dc6b91ca104
testObserverToParticipantConversionFails
public void testObserverToParticipantConversionFails() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = ReconfigRecoveryTest.generatePorts(SERVER_COUNT);        Set<Integer> observers = new HashSet<Integer>();    observers.add(3);    StringBuilder sb = ReconfigRecoveryTest.generateConfig(SERVER_COUNT, ports, observers);    String currentQuorumCfgSection = sb.toString();    String nextQuorumCfgSection = currentQuorumCfgSection.replace("observer", "participant");    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfgSection, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());    }    for (int i = 1; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }    try {        zkAdmin[1].reconfigure("", "", nextQuorumCfgSection, -1, new Stat());        fail("Reconfig should have failed with NewConfigNoQuorum");    } catch (NewConfigNoQuorum e) {            } catch (Exception e) {        fail("Reconfig should have failed with NewConfigNoQuorum");    }        ArrayList<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    ReconfigTest.reconfig(zkAdmin[1], null, leavingServers, null, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    ReconfigTest.testServerHasConfig(zk[3], null, leavingServers);        List<String> newMembers = Arrays.asList(nextQuorumCfgSection.split("\n"));    ReconfigTest.reconfig(zkAdmin[1], null, null, newMembers, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    for (int i = 1; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newMembers, null);    }    for (int i = 1; i < SERVER_COUNT; i++) {        zk[i].close();        zkAdmin[i].close();        mt[i].shutdown();    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
4f0153ad9839390743c0af0db4ed603cfc74fac885f08f0fbd424f9d1d2a0f6d
testConfigFileBackwardCompatibility
public void testConfigFileBackwardCompatibility() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, "participant", false);                assertEquals(mt[i].getDynamicFiles().length, 0);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        File[] dynamicFiles = mt[i].getDynamicFiles();        assertTrue(dynamicFiles.length == 1);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);                                Properties cfg = readPropertiesFromFile(mt[i].confFile);        for (int j = 0; j < SERVER_COUNT; j++) {            assertFalse(cfg.containsKey("server." + j));        }        assertFalse(cfg.containsKey("peerType"));        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertFalse(cfg.containsKey("clientPort"));                cfg = readPropertiesFromFile(dynamicFiles[0]);        for (int j = 0; j < SERVER_COUNT; j++) {            String serverLine = cfg.getProperty("server." + j, "");            assertEquals(allServers.get(j), "server." + j + "=" + serverLine);        }        assertFalse(cfg.containsKey("dynamicConfigFile"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
50bbe23e6c6b49c59cc9614df40f9ea215075c6a16ed11813ef559e05934b4f6
testReconfigRemoveClientFromStatic
public void testReconfigRemoveClientFromStatic() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    final int[] quorumPorts = new int[SERVER_COUNT];    final int[] electionPorts = new int[SERVER_COUNT];    final int changedServerId = 0;    final int newClientPort = PortAssignment.unique();    StringBuilder sb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant";        allServers.add(server);        sb.append(server + "\n");        if (i == changedServerId) {            newServers.add(server + ";0.0.0.0:" + newClientPort);        } else {            newServers.add(server);        }    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        ReconfigTest.testServerHasConfig(zk[i], allServers, null);        Properties cfg = readPropertiesFromFile(mt[i].confFile);        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertTrue(cfg.containsKey("clientPort"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);    ReconfigTest.testNormalOperation(zk[0], zk[1]);        Thread.sleep(1000);    for (int i = 0; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newServers, null);        Properties staticCfg = readPropertiesFromFile(mt[i].confFile);        if (i == changedServerId) {            assertFalse(staticCfg.containsKey("clientPort"));        } else {            assertTrue(staticCfg.containsKey("clientPort"));        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
85d1917373b43991ddd0be23d902f4833d015dc329b2c3c4ad6d296b06e1dbfc
readPropertiesFromFile
public static Properties readPropertiesFromFile(File file) throws IOException
{    Properties cfg = new Properties();    FileInputStream in = new FileInputStream(file);    try {        cfg.load(in);    } finally {        in.close();    }    return cfg;}
436f70462d9afad228fbaa311fa02522241e0c83f1ee393df0867a9176964068
testRestartZooKeeperServer
public void testRestartZooKeeperServer() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    String zNodePath = "/serverRestartTest";    String data = "originalData";    zk.create(zNodePath, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    /**     * stop two servers out of three and again start them     */    mt[0].shutdown();    mt[1].shutdown();    mt[0].start();    mt[1].start();        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    byte[] dataBytes = zk.getData(zNodePath, null, null);    String receivedData = new String(dataBytes);    assertEquals(data, receivedData);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    QuorumPeerConfig.setReconfigEnabled(true);}
867c41b89dc580e5985c4133c8c9a68a0994a5f9a400c44db2873d4c701015cd
testNextConfigCompletion
public void testNextConfigCompletion() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();                MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT - 1; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    assertTrue("waiting for server 0 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], CONNECTION_TIMEOUT));    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[1], CONNECTION_TIMEOUT));    int leader = mt[0].main.quorumPeer.leader == null ? 1 : 0;        sb = new StringBuilder();    sb.append(allServers.get(leader) + "\n");    sb.append(allServers.get(2) + "\n");        String newServerInitialConfig = sb.toString();    mt[2] = new MainThread(2, clientPorts[2], newServerInitialConfig);    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + clientPorts[2], ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[2], CONNECTION_TIMEOUT));    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testServerHasConfig(zk[2], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[2], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
735d79b1c0bbf3ab6fe82c9d24f801f4dc2542117e2d44412f5b6e9622dcda45
testCurrentServersAreObserversInNextConfig
public void testCurrentServersAreObserversInNextConfig() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    final int[] oldClientPorts = new int[2];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfg, nextQuorumCfgSection;    ArrayList<String> allServersNext = new ArrayList<String>();    for (int i = 0; i < 2; i++) {        oldClientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + oldClientPorts[i];        sb.append(server + "\n");    }    currentQuorumCfg = sb.toString();    sb = new StringBuilder();    String role;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        if (i < 2) {            role = "observer";        } else {            role = "participant";        }        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + role + ";localhost:" + clientPorts[i];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, oldClientPorts[i], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + oldClientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < 2; i++) {        mt[i].shutdown();        zk[i].close();    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerDown("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    for (int i = 0; i < 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfg + allServersNext.get(i));        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
4161d01fe956efebdad5087eaf432436fddda9cd84a3430ef8be539b3d5b4d82
testNextConfigUnreachable
public void testNextConfigUnreachable() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    Thread.sleep(CONNECTION_TIMEOUT * 2);        for (int i = 0; i < 2; i++) {        assertFalse("server " + i + " is up but shouldn't be", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT / 10));    }    for (int i = 0; i < 2; i++) {        zk[i].close();        mt[i].shutdown();    }}
3585e4c5cf25720f257c1a396df1e2d981c33f8643fefb5ca95f1085b70e60cc
testNextConfigAlreadyActive
public void testNextConfigAlreadyActive() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], nextQuorumCfgSection, true, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ReconfigTest.testNormalOperation(zk[2], zk[3]);    long epoch = mt[2].main.quorumPeer.getAcceptedEpoch();        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));    }        assertEquals(epoch, mt[0].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[1].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[2].main.quorumPeer.getAcceptedEpoch());    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
5d2e8103e4ca65e4fa7cd6085ec8b0e6a94bd65fed4820b17d500b621d36bb25
testObserverConvertedToParticipantDuringFLE
public void testObserverConvertedToParticipantDuringFLE() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfgSection, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfgSection = sb.toString();        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        mt[2] = new MainThread(2, ports[2][2], currentQuorumCfgSection, true, "100000000");    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + ports[2][2], ClientBase.CONNECTION_TIMEOUT, this);        mt[3] = new MainThread(3, ports[3][2], nextQuorumCfgSection, true, "200000000");    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    ReconfigTest.testNormalOperation(zk[2], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[2]);    for (int i = 2; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
47961d72f51127f54de2649509bce62cbad3bf6acfbb86d8a97e10af7fbb252f
testCurrentObserverIsParticipantInNewConfig
public void testCurrentObserverIsParticipantInNewConfig() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfg, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfg = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i <= 2; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    for (int i = 0; i <= 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }        for (int i = 0; i <= 2; i++) {        mt[i].shutdown();        zk[i].close();    }        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();        for (int i = 0; i <= 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }            mt[3] = new MainThread(3, ports[3][2], currentQuorumCfg + allServersNext.get(1));    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 3));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[1]);    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
d2ed02ef73aa41066ac7683f40e12a0b8dae47ccc5297732e89813752670e158
generatePorts
public static int[][] generatePorts(int numServers)
{    int[][] ports = new int[numServers][];    for (int i = 0; i < numServers; i++) {        ports[i] = new int[3];        for (int j = 0; j < 3; j++) {            ports[i][j] = PortAssignment.unique();        }    }    return ports;}
5ce90d275739c64e06010ebf18f6190540df16cbf686febe9fa5d5b186ca650e
generateConfig
public static StringBuilder generateConfig(int numServers, int[][] ports, Set<Integer> observerIds)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < numServers; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":" + (observerIds.contains(i) ? "observer" : "participant") + ";localhost:" + ports[i][2];        sb.append(server + "\n");    }    return sb;}
a4f29cb86670cd7cd7e5eb6e050785a2653dacd14d65d11e8e19d8ba7df424c9
generateNewQuorumConfig
private String generateNewQuorumConfig(int serverCount)
{    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < serverCount; i++) {        clientPorts.put(i, PortAssignment.unique());        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(i);        serverAddress.put(i, server);        sb.append(server + "\n");    }    return sb.toString();}
69f561faebbcb9f8ae1a4ede1368fc3f113a631480a6d0f35c1e4f5d0f9be370
updateExistingQuorumConfig
private String updateExistingQuorumConfig(List<Integer> sidsToAdd, List<Integer> sidsToRemove)
{    StringBuilder sb = new StringBuilder();    for (Integer sid : sidsToAdd) {        clientPorts.put(sid, PortAssignment.unique());        serverAddress.put(sid, "server." + sid + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(sid));    }    for (Integer sid : sidsToRemove) {        clientPorts.remove(sid);        serverAddress.remove(sid);    }    for (String server : serverAddress.values()) {        sb.append(server + "\n");    }    return sb.toString();}
8ddeebf070e52275ffc3949a9c067a8012a3747ab3c02fab6072e0efcd0476d2
testNoLocalDynamicConfigAndBackupFiles
public void testNoLocalDynamicConfigAndBackupFiles() throws InterruptedException, IOException
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    String[] staticFileContent = new String[serverCount];    for (int i = 0; i < serverCount; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();    }    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        assertNull("static file backup (zoo.cfg.bak) shouldn't exist!", mt[i].getFileByName(ZOO_CFG_BAK_FILE));        assertNull("dynamic configuration file (zoo.cfg.dynamic.*) shouldn't exist!", mt[i].getFileByName(mt[i].getQuorumPeer().getNextDynamicConfigFilename()));        staticFileContent[i] = Files.readAllLines(mt[i].confFile.toPath(), StandardCharsets.UTF_8).toString();        assertTrue("static config file should contain server entry " + serverAddress.get(i), staticFileContent[i].contains(serverAddress.get(i)));    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
c5141710839f17a31ab67d8ce6d9c9c3c820bbf298782bc9a6228894b7472d2e
testRollingRestartWithoutMembershipChange
public void testRollingRestartWithoutMembershipChange() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    List<String> joiningServers = new ArrayList<>();    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();        mt[i].start();        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
69779deca89fc252b0e3ef8bf61dfd617d2a7773ca72d8aba736171403e1c0a1
testRollingRestartWithMembershipChange
public void testRollingRestartWithMembershipChange() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    List<String> joiningServers = new ArrayList<>();    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    Map<Integer, String> oldServerAddress = new HashMap<>(serverAddress);    List<String> newServers = new ArrayList<>(joiningServers);    config = updateExistingQuorumConfig(Arrays.asList(3, 4), new ArrayList<Integer>());    newServers.add(serverAddress.get(3));    newServers.add(serverAddress.get(4));    serverCount = serverAddress.size();    assertEquals("Server count should be 5 after config update.", serverCount, 5);                    mt = Arrays.copyOf(mt, mt.length + 2);    for (int i = 3; i < 5; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        verifyQuorumConfig(i, newServers, null);        verifyQuorumMembers(mt[i]);    }    Set<String> expectedConfigs = new HashSet<>();    for (String conf : oldServerAddress.values()) {                expectedConfigs.add(conf.substring(conf.indexOf('=') + 1));    }    for (int i = 0; i < 3; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i], expectedConfigs);    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();    }}
da8786b6ad2bf14b91a0a6f8e2bc026ac39986cd8a15b0cec9fd9369149b1275
verifyQuorumConfig
private void verifyQuorumConfig(int sid, List<String> joiningServers, List<String> leavingServers) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts.get(sid));    ReconfigTest.testNormalOperation(zk, zk);    ReconfigTest.testServerHasConfig(zk, joiningServers, leavingServers);    zk.close();}
09cb2b81d0f23ec28d581d30bed0ae573aa336ecf1fe29977501929fca83085a
verifyQuorumMembers
private void verifyQuorumMembers(QuorumPeerTestBase.MainThread mt)
{    Set<String> expectedConfigs = new HashSet<>();    for (String config : serverAddress.values()) {        expectedConfigs.add(config.substring(config.indexOf('=') + 1));    }    verifyQuorumMembers(mt, expectedConfigs);}
3246e3f0fe6909878b7bebc6cda0f33d1cbecae5b6d7ef7592ba9fecb501c15d
verifyQuorumMembers
private void verifyQuorumMembers(QuorumPeerTestBase.MainThread mt, Set<String> expectedConfigs)
{    Map<Long, QuorumPeer.QuorumServer> members = mt.getQuorumPeer().getQuorumVerifier().getAllMembers();    assertTrue("Quorum member should not change.", members.size() == expectedConfigs.size());    for (QuorumPeer.QuorumServer qs : members.values()) {        String actualConfig = qs.toString();        assertTrue("Unexpected config " + actualConfig + " found!", expectedConfigs.contains(actualConfig));    }}
c15b4aa426b36f8901984be8e55c685892c8b6fd6bc5a861f230d8e0e4e0ef21
testGetClientAddressShouldReturnEmptyStringWhenClientAddressIsNull
public void testGetClientAddressShouldReturnEmptyStringWhenClientAddressIsNull()
{    InetSocketAddress peerCommunicationAddress = null;        QuorumServer peer = new QuorumServer(1, peerCommunicationAddress);    RemotePeerBean remotePeerBean = new RemotePeerBean(null, peer);    String clientAddress = remotePeerBean.getClientAddress();    assertNotNull(clientAddress);    assertEquals(0, clientAddress.length());}
455390a55fdfcb1a280ac20a40b388a3a542d0b5450181153973c21e8d776a87
testIsLeader
public void testIsLeader()
{    long peerId = 7;    QuorumPeer.QuorumServer quorumServerMock = mock(QuorumPeer.QuorumServer.class);    when(quorumServerMock.getId()).thenReturn(peerId);    QuorumPeer peerMock = mock(QuorumPeer.class);    RemotePeerBean remotePeerBean = new RemotePeerBean(peerMock, quorumServerMock);    when(peerMock.isLeader(eq(peerId))).thenReturn(true);    assertTrue(remotePeerBean.isLeader());    when(peerMock.isLeader(eq(peerId))).thenReturn(false);    assertFalse(remotePeerBean.isLeader());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());        ClientBase.setupTestEnv();    mt = new MainThread[SERVER_COUNT];    clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server.").append(i).append("=127.0.0.1:").append(PortAssignment.unique()).append(":").append(PortAssignment.unique()).append("\n");    }    sb.append("localSessionsEnabled=true\n");    sb.append("localSessionsUpgradingEnabled=true\n");    String cfg = sb.toString();        qpMain = new TestQPMainDropSessionUpgrading[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();        qpMain[i] = qp;        mt[i] = new MainThread(i, clientPorts[i], cfg, false) {            @Override            public TestQPMain getTestQPMain() {                return qp;            }        };        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }}
1e9449239c56a37d13855b9150f0f1c854ac0c8b05e3831a971e0b1a4b2ad6ad
getTestQPMain
public TestQPMain getTestQPMain()
{    return qp;}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
32dc880095fdbbf367936f6ea93d81d9f5a98364bddba218b27e01782c130b3b
testLocalSessionUpgradeSnapshot
public void testLocalSessionUpgradeSnapshot() throws IOException, InterruptedException
{        int leader = -1;    int followerA = -1;    for (int i = SERVER_COUNT - 1; i >= 0; i--) {        if (mt[i].main.quorumPeer.leader != null) {            leader = i;        } else if (followerA == -1) {            followerA = i;        }    }    LOG.info("follower A is {}", followerA);    qpMain[followerA].setDropCreateSession(true);            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);        long sessionId = zk.getSessionId();        try {        zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("expect to failed to upgrade session due to the " + "TestQPMainDropSessionUpgrading is being used");    } catch (KeeperException e) {        LOG.info("KeeperException when create ephemeral node.", e);    }        qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);        Thread.sleep(500);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    ArrayList<States> waitStates = new ArrayList<States>();    waitStates.add(States.CONNECTING);    waitStates.add(States.CLOSED);    waitForOne(zk, waitStates);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        for (int i = 0; i < SERVER_COUNT; i++) {        ConcurrentHashMap<Long, Integer> sessions = mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();        assertFalse("server " + i + " should not have global " + "session " + sessionId, sessions.containsKey(sessionId));    }    zk.close();}
e271680296a0c57da97425898a5c7eb5440f515acefb252abdaed181d238a8ea
testOnlyUpgradeSessionOnce
public void testOnlyUpgradeSessionOnce() throws IOException, InterruptedException, KeeperException
{            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    long sessionId = zk.getSessionId();    QuorumZooKeeperServer server = (QuorumZooKeeperServer) mt[0].main.quorumPeer.getActiveServer();    Request create1 = createEphemeralRequest("/data-1", sessionId);    Request create2 = createEphemeralRequest("/data-2", sessionId);    assertNotNull("failed to upgrade on a ephemeral create", server.checkUpgradeSession(create1));    assertNull("tried to upgrade again", server.checkUpgradeSession(create2));        zk.close();}
66b9597372a275d670fccd3e0ac503b503af9ce256ed9e9157fc999261d9196a
setDropCreateSession
public void setDropCreateSession(boolean dropCreateSession)
{    shouldDrop = dropCreateSession;}
3d9f43411ceb7111ec52256ed4bdcfbc90495f56be5583fd15f5efe6c6266262
getQuorumPeer
protected QuorumPeer getQuorumPeer() throws SaslException
{    return new QuorumPeer() {        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {                @Override                protected void request(Request request) throws IOException {                    if (!shouldDrop) {                        super.request(request);                        return;                    }                    LOG.info("request is {}, cnxn {}", request.type, request.cnxn);                    if (request.type == ZooDefs.OpCode.createSession) {                        LOG.info("drop createSession request {}", request);                        return;                    }                    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                        CreateRequest createRequest = new CreateRequest();                        request.request.rewind();                        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                        request.request.rewind();                        try {                            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                            if (createMode.isEphemeral()) {                                request.cnxn.sendCloseSession();                            }                        } catch (KeeperException e) {                        }                        return;                    }                    super.request(request);                }            };        }    };}
5aa3c8258c5bd24642392434b19f5d7d0b095f648387fd6e7b8a46fa4b1613b7
makeFollower
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void request(Request request) throws IOException {            if (!shouldDrop) {                super.request(request);                return;            }            LOG.info("request is {}, cnxn {}", request.type, request.cnxn);            if (request.type == ZooDefs.OpCode.createSession) {                LOG.info("drop createSession request {}", request);                return;            }            if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                CreateRequest createRequest = new CreateRequest();                request.request.rewind();                ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                request.request.rewind();                try {                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                    if (createMode.isEphemeral()) {                        request.cnxn.sendCloseSession();                    }                } catch (KeeperException e) {                }                return;            }            super.request(request);        }    };}
20cde8f93a62a04934453627c2cf0fc6be704639c0ea932e4f4af05fabb28bab
request
protected void request(Request request) throws IOException
{    if (!shouldDrop) {        super.request(request);        return;    }    LOG.info("request is {}, cnxn {}", request.type, request.cnxn);    if (request.type == ZooDefs.OpCode.createSession) {        LOG.info("drop createSession request {}", request);        return;    }    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        try {            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());            if (createMode.isEphemeral()) {                request.cnxn.sendCloseSession();            }        } catch (KeeperException e) {        }        return;    }    super.request(request);}
e9ff5697f9e0f8212a5deefed26d5b71ca705f054b43a2faf097889a42a5825d
waitForOne
private void waitForOne(ZooKeeper zk, ArrayList<States> states) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (!states.contains(zk.getState())) {        if (iterations-- == 0) {            LOG.info("state is {}", zk.getState());            throw new RuntimeException("Waiting too long");        }        Thread.sleep(500);    }}
e3fc1eb238946d1a7305fe8be93dc30332f1dc99839ea508dd83797b3f4b952f
createEphemeralRequest
private Request createEphemeralRequest(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
e3962434adab236f1c1d141ffe38712fa3bf3192be567b7a118622edc200106b
startSingleServerTest
public void startSingleServerTest() throws Exception
{    setUpData();        startServer(leaderId, serverStrings.get(leaderId) + "\n");    ReconfigTest.testServerHasConfig(zkHandles[leaderId], null, null);    LOG.info("Initial Configuration:\n" + new String(zkHandles[leaderId].getConfig(this, new Stat())));        startFollowers();    testReconfig(leaderId, true, reconfigServers);    LOG.info("Configuration after adding 2 followers:\n" + new String(zkHandles[leaderId].getConfig(this, new Stat())));        shutDownServer(leaderId);    ReconfigTest.testNormalOperation(zkHandles[follower1], zkHandles[follower2]);            reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        ReconfigTest.reconfig(zkAdminHandles[follower1], null, reconfigServers, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }            reconfigServers.clear();    reconfigServers.add(Integer.toString(leaderId));    reconfigServers.add(Integer.toString(follower1));    testReconfig(follower2, false, reconfigServers);    LOG.info("Configuration after removing leader and follower 1:\n" + new String(zkHandles[follower2].getConfig(this, new Stat())));        shutDownServer(follower1);        reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        zkAdminHandles[follower2].reconfigure(null, reconfigServers, null, -1, new Stat());        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }            ArrayList<String> observerStrings = new ArrayList<String>();    startObservers(observerStrings);        testReconfig(follower2, true, reconfigServers);        testReconfig(follower2, true, observerStrings);    LOG.info("Configuration after adding two observers:\n" + new String(zkHandles[follower2].getConfig(this, new Stat())));    shutDownData();}
4c174830e8cd0b225fddcf39daa63e237e84b489c0bc043d77e660e72f1fa302
setUpData
private void setUpData() throws Exception
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setStandaloneEnabled(false);    QuorumPeerConfig.setReconfigEnabled(true);    peers = new MainThread[NUM_SERVERS];    zkHandles = new ZooKeeper[NUM_SERVERS];    zkAdminHandles = new ZooKeeperAdmin[NUM_SERVERS];    clientPorts = new int[NUM_SERVERS];    serverStrings = buildServerStrings();    reconfigServers = new ArrayList<String>();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
cc49608e93042c376dc40cd65c52130758e5236f352f780021056153347b885c
shutDownData
private void shutDownData() throws Exception
{    for (int i = 0; i < NUM_SERVERS; i++) {        zkHandles[i].close();        zkAdminHandles[i].close();    }    for (int i = 1; i < NUM_SERVERS; i++) {        peers[i].shutdown();    }}
0535b4b63302d4b9f9f208407af8e6dbaca17546cb99ca61fe4a728962ad769a
buildServerStrings
private ArrayList<String> buildServerStrings()
{    ArrayList<String> serverStrings = new ArrayList<String>();    for (int i = 0; i < NUM_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;" + "localhost:" + clientPorts[i];        serverStrings.add(server);    }    return serverStrings;}
dd0beb943f03a76d1b3e1388ded5baab62b6f839065e3549fba2df132714bf1b
startServer
private void startServer(int id, String config) throws Exception
{    peers[id] = new MainThread(id, clientPorts[id], config);    peers[id].start();    assertTrue("Server " + id + " is not up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT));    assertTrue("Error- Server started in Standalone Mode!", peers[id].isQuorumPeerRunning());    zkHandles[id] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[id]);    zkAdminHandles[id] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT, this);    zkAdminHandles[id].addAuthInfo("digest", "super:test".getBytes());    String statCommandOut = FourLetterWordMain.send4LetterWord("127.0.0.1", clientPorts[id], "stat");    LOG.info(String.format("Started server id %d with config:\n%s\nStat output:\n%s", id, config, statCommandOut));}
70f37e99b55a48c510beb56bcc065c4cb4386c7c9326039ecfadedfbb955542b
shutDownServer
private void shutDownServer(int id) throws Exception
{    peers[id].shutdown();    ClientBase.waitForServerDown("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT);    TimeUnit.SECONDS.sleep(25);}
f03b71747afaf849c0357fb16cf54cdd2a05cf7b4be0d0b1c233efce749cf0e2
startFollowers
private void startFollowers() throws Exception
{    reconfigServers.clear();    for (int i = 1; i <= 2; i++) {        String config = serverStrings.get(leaderId) + "\n" + serverStrings.get(i) + "\n" + serverStrings.get(i % 2 + 1) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));    }}
47395dbf85ddb9d1b32bb26b35995d20c77bf45681bb813034459b776c1517e8
startObservers
private void startObservers(ArrayList<String> observerStrings) throws Exception
{    reconfigServers.clear();    for (int i = observer1; i <= observer2; i++) {        String config = serverStrings.get(follower2) + "\n" + serverStrings.get(i) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));        observerStrings.add(serverStrings.get(i).replace("participant", "observer"));    }}
4b0cf1d408fa4c7ac39fa185a6f60aee0b05229e51de473ccfa8fb86c0becfde
testReconfig
private void testReconfig(int id, boolean adding, ArrayList<String> servers) throws Exception
{    if (adding) {        ReconfigTest.reconfig(zkAdminHandles[id], servers, null, null, -1);        for (String server : servers) {                        int id2 = Integer.parseInt(server.substring(7, 8));            ReconfigTest.testNormalOperation(zkHandles[id], zkHandles[id2]);        }        ReconfigTest.testServerHasConfig(zkHandles[id], servers, null);    } else {        ReconfigTest.reconfig(zkAdminHandles[id], null, servers, null, -1);        ReconfigTest.testServerHasConfig(zkHandles[id], null, servers);    }}
fccf54982413092940ecea1321c7c5bd60ac7275b7f15e2da350ba087528be14
startObserver
public void startObserver() throws Exception
{    int clientPort = PortAssignment.unique();    String config = "server." + observer1 + "=localhost:" + PortAssignment.unique() + ":" + clientPort + ":observer;" + "localhost:" + PortAssignment.unique();    MainThread observer = new MainThread(observer1, clientPort, config);    observer.start();    assertFalse("Observer was able to start by itself!", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    LeaderZooKeeperServer zks = mock(LeaderZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    providerMock = mock(ServerStats.Provider.class);    when(zks.serverStats()).thenReturn(new ServerStats(providerMock));    ZKDatabase zkDatabaseMock = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(zkDatabaseMock);    Leader leaderMock = mock(Leader.class);    when(leaderMock.getProposalStats()).thenReturn(new BufferStats());    when(zks.getLeader()).thenReturn(leaderMock);    ServerCnxnFactory serverCnxnFactory = mock(ServerCnxnFactory.class);    ServerCnxn serverCnxn = mock(ServerCnxn.class);    List<ServerCnxn> connections = new ArrayList<>();    connections.add(serverCnxn);    when(serverCnxnFactory.getConnections()).thenReturn(connections);    statCommand = new StatCommand(new PrintWriter(outputWriter), serverCnxnMock, FourLetterCommands.statCmd);    statCommand.setZkServer(zks);    statCommand.setFactory(serverCnxnFactory);}
a94fedcd1a9d5d65f0f96b1c6e8ca43b7e64546dc3afc8d1b7c490c6711a43f2
testLeaderStatCommand
public void testLeaderStatCommand()
{        when(providerMock.getState()).thenReturn("leader");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: leader"));    assertThat(output, containsString("Proposal sizes last/min/max:"));}
611a0b438af7137afe2e4510588edad5d68de471b54e1fef1c1825792404cc74
testFollowerStatCommand
public void testFollowerStatCommand()
{        when(providerMock.getState()).thenReturn("follower");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: follower"));}
acfb844e5d11642a38c9f372dd98820527471dc57004c70142815f4b495476bc
assertCommonStrings
private void assertCommonStrings(String output)
{    assertThat(output, containsString("Clients:"));    assertThat(output, containsString("Zookeeper version:"));    assertThat(output, containsString("Node count:"));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    zks = mock(ZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    serverStats = mock(ServerStats.class);    when(zks.serverStats()).thenReturn(serverStats);    statResetCommand = new StatResetCommand(new PrintWriter(outputWriter), serverCnxnMock);    statResetCommand.setZkServer(zks);}
87891ad83003d811ddd1d7de9d6812dccb43bc46b46e3a83d0929a227b1751f1
testStatResetWithZKNotRunning
public void testStatResetWithZKNotRunning()
{        when(zks.isRunning()).thenReturn(false);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals(ZK_NOT_SERVING + "\n", output);}
cc2d88f0c0b45a749a897245af3804d5345111b371180a0e2e3fdc707bdea813
testStatResetWithFollower
public void testStatResetWithFollower()
{        when(zks.isRunning()).thenReturn(true);    when(serverStats.getServerState()).thenReturn("follower");        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();}
ccf2a04777723a1554d6e905520d1080a2efcf2e028bcdeb5c8312ae35ff4dbf
testStatResetWithLeader
public void testStatResetWithLeader()
{        LeaderZooKeeperServer leaderZks = mock(LeaderZooKeeperServer.class);    when(leaderZks.isRunning()).thenReturn(true);    when(leaderZks.serverStats()).thenReturn(serverStats);    Leader leader = mock(Leader.class);    when(leaderZks.getLeader()).thenReturn(leader);    statResetCommand.setZkServer(leaderZks);    when(serverStats.getServerState()).thenReturn("leader");    BufferStats bufferStats = mock(BufferStats.class);    when(leader.getProposalStats()).thenReturn(bufferStats);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();    verify(bufferStats, times(1)).reset();}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    ZKDatabase db = mock(ZKDatabase.class);    when(db.append(any(Request.class))).thenReturn(true);    doAnswer(invocation -> {        Thread.sleep(100);        return null;    }).when(db).commit();    zks = mock(ZooKeeperServer.class);    when(zks.getZKDatabase()).thenReturn(db);    nextProcessor = mock(RequestProcessor.class);    doAnswer(invocationOnMock -> {        allRequestsFlushed.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));}
4ee89df568de6689accbf622ccb1832ffbf0630d9799805b9e47f9cb64e0edd4
createRquest
private Request createRquest(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
cc166e2df5e4d6bf1f6042f4668e8694efa057dfe9b2066316ce73638d820dd4
testSyncProcessorMetrics
public void testSyncProcessorMetrics() throws Exception
{    SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, nextProcessor);    for (int i = 0; i < 500; i++) {        syncProcessor.processRequest(createRquest(1, i));    }    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(500L, values.get("sync_processor_request_queued"));    allRequestsFlushed = new CountDownLatch(500);    syncProcessor.start();    allRequestsFlushed.await(5000, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(501L, values.get("cnt_sync_processor_queue_size"));    assertEquals(500L, values.get("max_sync_processor_queue_size"));    assertEquals(0L, values.get("min_sync_processor_queue_size"));    assertEquals(500L, values.get("cnt_sync_processor_queue_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_processor_queue_and_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_and_flush_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_process_time"));    assertThat((long) values.get("max_sync_process_time"), greaterThan(0L));    assertEquals(500L, values.get("max_sync_processor_batch_size"));    assertEquals(1L, values.get("cnt_sync_processor_queue_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_flush_time_ms"), greaterThanOrEqualTo(100L));    syncProcessor.shutdown();}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    ArrayList<Object[]> result = new ArrayList<>();    result.add(new Object[] { true });    result.add(new Object[] { false });    return result;}
7f0f73b325bcd37632c396c02bb87ddfe4bb9da1a35fac272192ae84740eb688
setUpClass
public static void setUpClass() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    tempDir = ClientBase.createEmptyTestDir();    x509TestContext = X509TestContext.newBuilder().setTempDir(tempDir).setKeyStoreKeyType(X509KeyType.EC).setTrustStoreKeyType(X509KeyType.EC).build();}
ece20925fce346cce8156286e6fb6c3527c97916e4c6ffa79543eac2f6cc7e6d
tearDownClass
public static void tearDownClass()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);}
a7dd7579d4a4fe815703c75891bed388694a8ae571b5c76e548be5ecbc84b2e7
forceClose
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
ddf6e9cdfc4ff839e4398b8f57b17d172d5a96d77b676b57bf9ff0e335a66845
forceClose
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "100");    workerPool = Executors.newCachedThreadPool();    port = PortAssignment.unique();    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);    listeningSocket = new UnifiedServerSocket(x509Util, true);    listeningSocket.bind(localServerAddress);    Future<UnifiedServerSocket.UnifiedSocket> acceptFuture;    acceptFuture = workerPool.submit(new Callable<UnifiedServerSocket.UnifiedSocket>() {        @Override        public UnifiedServerSocket.UnifiedSocket call() throws Exception {            try {                return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();            } catch (IOException e) {                LOG.error("Error in accept(): ", e);                throw e;            }        }    });    if (useSecureClient) {        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);    } else {        clientSocket = new Socket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(new byte[] { 1, 2, 3, 4, 5 });    }    serverSideSocket = acceptFuture.get();}
46d914c9f100db32629852e837c45eda7f1d34d98f114a8108f2df3c362e0c00
call
public UnifiedServerSocket.UnifiedSocket call() throws Exception
{    try {        return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();    } catch (IOException e) {        LOG.error("Error in accept(): ", e);        throw e;    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    forceClose(listeningSocket);    forceClose(serverSideSocket);    forceClose(clientSocket);    workerPool.shutdown();    workerPool.awaitTermination(1000, TimeUnit.MILLISECONDS);    x509Util.close();}
2c4c42e5f4e69ef77ac4191820600e56ad7c2128a8a99975014b32c7458396fb
testGetInetAddress
public void testGetInetAddress()
{    serverSideSocket.getInetAddress();    assertFalse(serverSideSocket.isModeKnown());}
7071dc2d27b369aab60cde167b10bccba51228e3fd68f14ebd7579141f3b2db3
testGetLocalAddress
public void testGetLocalAddress()
{    serverSideSocket.getLocalAddress();    assertFalse(serverSideSocket.isModeKnown());}
2954a2470ab13af0b7d35aa020c4193d0937fdf07b34f4ee1cbb1dee1bc309c4
testGetPort
public void testGetPort()
{    serverSideSocket.getPort();    assertFalse(serverSideSocket.isModeKnown());}
88b2f4d2ac0da6993a1b16b8710b330c17bf5e9917cdc097938727aabdd2cb8a
testGetLocalPort
public void testGetLocalPort()
{    serverSideSocket.getLocalPort();    assertFalse(serverSideSocket.isModeKnown());}
565f44ad56f2f5ff3a73471fe6c442757126c5f38629107d2f31c04a7533b47c
testGetRemoteSocketAddress
public void testGetRemoteSocketAddress()
{    serverSideSocket.getRemoteSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
71407f95e22c6689a63446ce7ed173fb717e7552298f9991f46ed9ae44bfc145
testGetLocalSocketAddress
public void testGetLocalSocketAddress()
{    serverSideSocket.getLocalSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
8159849d6fbde8b1816228bd60b806d3d94071b865091f05bc3788ceeb7b07f5
testGetInputStream
public void testGetInputStream() throws IOException
{    serverSideSocket.getInputStream();    assertFalse(serverSideSocket.isModeKnown());}
55b055d8aeada0acc176294c326d4ea2d50749d60b76eb1868fc3e42358ee2d9
testGetOutputStream
public void testGetOutputStream() throws IOException
{    serverSideSocket.getOutputStream();    assertFalse(serverSideSocket.isModeKnown());}
4f253579f551d95e6488e664d566b3783c288adc99834310512147004ffe99f0
testGetTcpNoDelay
public void testGetTcpNoDelay() throws IOException
{    serverSideSocket.getTcpNoDelay();    assertFalse(serverSideSocket.isModeKnown());}
1cc8faabcd95881394941b767ae2a2965074a736faac12f77aa833e8faf4924d
testSetTcpNoDelay
public void testSetTcpNoDelay() throws IOException
{    boolean tcpNoDelay = serverSideSocket.getTcpNoDelay();    tcpNoDelay = !tcpNoDelay;    serverSideSocket.setTcpNoDelay(tcpNoDelay);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(tcpNoDelay, serverSideSocket.getTcpNoDelay());}
9d643dd24223371041bd635f0a06d820c105911f0a704983daab9c312d956502
testGetSoLinger
public void testGetSoLinger() throws IOException
{    serverSideSocket.getSoLinger();    assertFalse(serverSideSocket.isModeKnown());}
7593728f51f236c066a7cc2ee911b0bb1310a9ac3d8d08af0c7bbc0085af2146
testSetSoLinger
public void testSetSoLinger() throws IOException
{    int soLinger = serverSideSocket.getSoLinger();    if (soLinger == -1) {                serverSideSocket.setSoLinger(true, 1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(1, serverSideSocket.getSoLinger());    } else {                serverSideSocket.setSoLinger(false, -1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(-1, serverSideSocket.getSoLinger());    }}
9b4de265d798321dbbd8c2e2ddd26d72cb0847485bcb8f365cc150f5e43efdcb
testGetSoTimeout
public void testGetSoTimeout() throws IOException
{    serverSideSocket.getSoTimeout();    assertFalse(serverSideSocket.isModeKnown());}
9ef91812aa6e1613192f7a656067d462dbbc16e0c475fdb867e1ea22b586cbf4
testSetSoTimeout
public void testSetSoTimeout() throws IOException
{    int timeout = serverSideSocket.getSoTimeout();    timeout = timeout + 10;    serverSideSocket.setSoTimeout(timeout);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(timeout, serverSideSocket.getSoTimeout());}
3d33b90163c6d654626b7d1f3b5cb3bf88651b24cc047cde20a7e8d50e2d9544
testGetSendBufferSize
public void testGetSendBufferSize() throws IOException
{    serverSideSocket.getSendBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
f43afbc4f8fbb0c62a57b9479b3b288fe1c568ba567450ba6ba80175b00b0a24
testSetSendBufferSize
public void testSetSendBufferSize() throws IOException
{    serverSideSocket.setSendBufferSize(serverSideSocket.getSendBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
7eba74b2687032d68d455f4b7d1d390fee925b54ea09927b6b81016626166937
testGetReceiveBufferSize
public void testGetReceiveBufferSize() throws IOException
{    serverSideSocket.getReceiveBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
d266a556622a7b91ae71de314ed69663d836d759346854713aa521c6792f4a4b
testSetReceiveBufferSize
public void testSetReceiveBufferSize() throws IOException
{    serverSideSocket.setReceiveBufferSize(serverSideSocket.getReceiveBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
014cd88c6312a232088c0906f9090d31155ffeaec46ebd95823b63ae9fedb934
testGetKeepAlive
public void testGetKeepAlive() throws IOException
{    serverSideSocket.getKeepAlive();    assertFalse(serverSideSocket.isModeKnown());}
928dd6abbfc5d6e953b03058a147867d61eb372d5728e8e5f37bc3c20951d043
testSetKeepAlive
public void testSetKeepAlive() throws IOException
{    boolean keepAlive = serverSideSocket.getKeepAlive();    keepAlive = !keepAlive;    serverSideSocket.setKeepAlive(keepAlive);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(keepAlive, serverSideSocket.getKeepAlive());}
72fe8a49f078c18ff91ca711d7a7cfaa901b3fc5706da3355aa581988176ee09
testGetTrafficClass
public void testGetTrafficClass() throws IOException
{    serverSideSocket.getTrafficClass();    assertFalse(serverSideSocket.isModeKnown());}
59e1efbaffc5a69c83a5f01e4c77dc7c8bb99937a07de76d13b9b4ea876af7a8
testSetTrafficClass
public void testSetTrafficClass() throws IOException
{    serverSideSocket.setTrafficClass(SocketOptions.IP_TOS);    assertFalse(serverSideSocket.isModeKnown());}
c39495c66f05acc816622356606e028fd740dc50c1a93a32ea5bf15eb01fa92a
testGetReuseAddress
public void testGetReuseAddress() throws IOException
{    serverSideSocket.getReuseAddress();    assertFalse(serverSideSocket.isModeKnown());}
8056433b5a2d6062790f3759ee813719ef07365e5480d39e7f3b2c609ed0682c
testSetReuseAddress
public void testSetReuseAddress() throws IOException
{    boolean reuseAddress = serverSideSocket.getReuseAddress();    reuseAddress = !reuseAddress;    serverSideSocket.setReuseAddress(reuseAddress);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(reuseAddress, serverSideSocket.getReuseAddress());}
e79aa27837fde0153d8b106c1b35f4f0f45a3fd44a2945feae0f2b645cc6643c
testClose
public void testClose() throws IOException
{    serverSideSocket.close();    assertFalse(serverSideSocket.isModeKnown());}
bd9030d7bce26414154c462f506c41d8b4df04339592f1dadbeb4f9e517283fb
testShutdownInput
public void testShutdownInput() throws IOException
{    serverSideSocket.shutdownInput();    assertFalse(serverSideSocket.isModeKnown());}
529894a23371505d51076c0d5b9600bb53ee78cd9302da0c41ab57bbe11069eb
testShutdownOutput
public void testShutdownOutput() throws IOException
{    serverSideSocket.shutdownOutput();    assertFalse(serverSideSocket.isModeKnown());}
77930ed517f84eea305c88db7ed2551be6aee725d70c33acabe88c9323095eeb
testIsConnected
public void testIsConnected()
{    serverSideSocket.isConnected();    assertFalse(serverSideSocket.isModeKnown());}
b8931316de1e7668a3c91d50a4d0ed49fcfe962d11361d4f3f5ad0dfc870c315
testIsBound
public void testIsBound()
{    serverSideSocket.isBound();    assertFalse(serverSideSocket.isModeKnown());}
0c4685c32ff4e7eed2d458bad44f904b89437cf9740f42c4319eca832a260d41
testIsClosed
public void testIsClosed()
{    serverSideSocket.isClosed();    assertFalse(serverSideSocket.isModeKnown());}
7a0403b0bdad1d50e8042138bfec55fd3f8e98be05889b58314eeedf6af6c32f
testIsInputShutdown
public void testIsInputShutdown() throws IOException
{    serverSideSocket.isInputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownInput();    assertTrue(serverSideSocket.isInputShutdown());}
d9d0db404e3f8763afdc9a41a211ba58be4bba7d57058a7de7d72746299a7818
testIsOutputShutdown
public void testIsOutputShutdown() throws IOException
{    serverSideSocket.isOutputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownOutput();    assertTrue(serverSideSocket.isOutputShutdown());}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (Boolean hostnameVerification : new Boolean[] { true, false }) {                result.add(new Object[] { caKeyType, certKeyType, hostnameVerification, paramIndex++ });            }        }    }    return result;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), PortAssignment.unique());    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    x509Util.close();}
a7dd7579d4a4fe815703c75891bed388694a8ae571b5c76e548be5ecbc84b2e7
forceClose
private static void forceClose(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
ddf6e9cdfc4ff839e4398b8f57b17d172d5a96d77b676b57bf9ff0e335a66845
forceClose
private static void forceClose(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Random rnd = new Random();        while (true) {            final Socket unifiedSocket = serverSocket.accept();            final boolean tcpNoDelay = rnd.nextBoolean();            unifiedSocket.setTcpNoDelay(tcpNoDelay);            unifiedSocket.setSoTimeout(TIMEOUT);            final boolean keepAlive = rnd.nextBoolean();            unifiedSocket.setKeepAlive(keepAlive);                        BufferedInputStream bis = new BufferedInputStream(unifiedSocket.getInputStream());            workerPool.submit(new Runnable() {                @Override                public void run() {                    try {                        byte[] buf = new byte[1024];                        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                                                                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());                        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());                        assertEquals(keepAlive, unifiedSocket.getKeepAlive());                        if (bytesRead > 0) {                            byte[] dataFromClient = new byte[bytesRead];                            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);                            synchronized (dataFromClients) {                                dataFromClients.add(dataFromClient);                            }                        }                        unifiedSocket.getOutputStream().write(dataToClient);                        unifiedSocket.getOutputStream().flush();                    } catch (IOException e) {                        throw new RuntimeException(e);                    } finally {                        forceClose(unifiedSocket);                    }                }            });        }    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(serverSocket);        workerPool.shutdown();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        byte[] buf = new byte[1024];        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());        assertEquals(keepAlive, unifiedSocket.getKeepAlive());        if (bytesRead > 0) {            byte[] dataFromClient = new byte[bytesRead];            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);            synchronized (dataFromClients) {                dataFromClients.add(dataFromClient);            }        }        unifiedSocket.getOutputStream().write(dataToClient);        unifiedSocket.getOutputStream().flush();    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(unifiedSocket);    }}
ce78f1a4c0aeef045f4778b684ad143b866e0c03613733fc9e03162a41d6b89c
shutdown
public void shutdown(long millis) throws InterruptedException
{        forceClose(serverSocket);    workerPool.awaitTermination(millis, TimeUnit.MILLISECONDS);    this.join(millis);}
eb4794e54de188968a7e696a3f241831f0af042efe358829eb11f6711fe45c7e
getDataFromClient
 synchronized byte[] getDataFromClient(int index)
{    return dataFromClients.get(index);}
fb05b8f30356796f97274b2e07b98d410c50014328782dba8901c977fe6697b2
receivedAnyDataFromClient
 synchronized boolean receivedAnyDataFromClient()
{    return !dataFromClients.isEmpty();}
aa67fdee8bbc4d899ad3790c146018a9fce80542f793c61d41c71c03275e24f0
connectWithSSL
private SSLSocket connectWithSSL() throws IOException, X509Exception, InterruptedException
{    SSLSocket sslSocket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            sslSocket = x509Util.createSSLSocket();            sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                @Override                public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                    synchronized (handshakeCompletedLock) {                        handshakeCompleted = true;                        handshakeCompletedLock.notifyAll();                    }                }            });            sslSocket.setSoTimeout(TIMEOUT);            sslSocket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(sslSocket);            sslSocket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server with SSL", sslSocket);    return sslSocket;}
4b255c4df0a58c20223e5a169af885f5c8ad586a78e36e68f2d3f3803706a583
handshakeCompleted
public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent)
{    synchronized (handshakeCompletedLock) {        handshakeCompleted = true;        handshakeCompletedLock.notifyAll();    }}
e41ca5147b3c40435dfcef668ff50f42bbbb45250f0b025ade8276e450d69ea6
connectWithoutSSL
private Socket connectWithoutSSL() throws IOException, InterruptedException
{    Socket socket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            socket = new Socket();            socket.setSoTimeout(TIMEOUT);            socket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(socket);            socket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server without SSL", socket);    return socket;}
c62be476d93c0618f2f4386f918f59df279088be20aa0bd7d0f576537f335166
testConnectWithSSLToNonStrictServer
public void testConnectWithSSLToNonStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
bbde3b2f8bddd1625e8ed80eb654db07012c6838f986eed7ba05bc5e40e6f301
testConnectWithSSLToStrictServer
public void testConnectWithSSLToStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
c7c57c33134b6257cf7b326298131ebb281c907f6c96d8a37e27167965e73602
testConnectWithoutSSLToNonStrictServer
public void testConnectWithoutSSLToNonStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {        socket.getOutputStream().write(DATA_FROM_CLIENT);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
7f72253bf8ef0d621d87a767ce13dd84184ffba1cead4ce7d96cce1bcb123d4a
testConnectWithoutSSLToNonStrictServerPartialWrite
public void testConnectWithoutSSLToNonStrictServerPartialWrite() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {                                socket.getOutputStream().write(DATA_FROM_CLIENT, 0, 2);        socket.getOutputStream().flush();        Thread.sleep(TIMEOUT / 2);        socket.getOutputStream().write(DATA_FROM_CLIENT, 2, DATA_FROM_CLIENT.length - 2);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
e6a133483ded5dc15531ac90ee1a1fd9d517e9ce04f78ad5f1913769208ba847
testConnectWithoutSSLToStrictServer
public void testConnectWithoutSSLToStrictServer() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    socket.getOutputStream().write(DATA_FROM_CLIENT);    socket.getOutputStream().flush();    byte[] buf = new byte[DATA_TO_CLIENT.length];    try {        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        if (bytesRead == -1) {                        return;        }    } catch (SocketException e) {                return;    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);                        assertFalse("The strict server accepted connection without SSL.", serverThread.receivedAnyDataFromClient());    }    fail("Expected server to hang up the connection. Read from server succeeded unexpectedly.");}
3971f430c4c6701288e6dfd697982ae641f1bf9dd7fe6b3df7744289c1b54c61
testTLSDetectionNonBlockingNonStrictServerIdleClient
public void testTLSDetectionNonBlockingNonStrictServerIdleClient() throws Exception
{    Socket badClientSocket = null;    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(badClientSocket);        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
c14a9766ffd7c90df4aaa882b5ea1ef3ae981e8c5fc451c728c1ca2d3025912d
testTLSDetectionNonBlockingStrictServerIdleClient
public void testTLSDetectionNonBlockingStrictServerIdleClient() throws Exception
{    Socket badClientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(badClientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
a4cf7bca505e9a2edb40e1e6b34192b8ce01572b94905332097664ddac299b93
testTLSDetectionNonBlockingNonStrictServerDisconnectedClient
public void testTLSDetectionNonBlockingNonStrictServerDisconnectedClient() throws Exception
{    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
8fed44c61601a16c93401192e3d0b35d45f2447d35f3bc66e9cb3ba72a11bea2
testTLSDetectionNonBlockingStrictServerDisconnectedClient
public void testTLSDetectionNonBlockingStrictServerDisconnectedClient() throws Exception
{    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
a7e0cbe38199f9da3827a95ddb09627bc1388241b04e73e76cb8d38509652c45
configs
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
78f47ad922ad3d10320b4a2dff5ca1b9ba5a42b38c956974f39f4f5c3aa33db5
testWatchesLeak
public void testWatchesLeak() throws Exception
{    NIOServerCnxnFactory serverCnxnFactory = mock(NIOServerCnxnFactory.class);    final SelectionKey sk = new FakeSK();    MockSelectorThread selectorThread = mock(MockSelectorThread.class);    when(selectorThread.addInterestOpsUpdateRequest(any(SelectionKey.class))).thenAnswer(new Answer<Boolean>() {        @Override        public Boolean answer(InvocationOnMock invocation) throws Throwable {            SelectionKey sk = (SelectionKey) invocation.getArguments()[0];            NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();            sk.interestOps(nioSrvCnx.getInterestOps());            return true;        }    });    ZKDatabase database = new ZKDatabase(null);    database.setlastProcessedZxid(2L);    QuorumPeer quorumPeer = mock(QuorumPeer.class);    FileTxnSnapLog logfactory = mock(FileTxnSnapLog.class);        when(logfactory.getDataDir()).thenReturn(new File(""));    when(logfactory.getSnapDir()).thenReturn(new File(""));    FollowerZooKeeperServer fzks = null;    try {                fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);        fzks.startup();        fzks.setServerCnxnFactory(serverCnxnFactory);        quorumPeer.follower = new MyFollower(quorumPeer, fzks);        LOG.info("Follower created");                final SocketChannel socketChannel = createClientSocketChannel();                final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);        sk.attach(nioCnxn);                nioCnxn.doIO(sk);        LOG.info("Client connection sent");                QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);        quorumPeer.follower.processPacket(qp);        LOG.info("Session validation sent");                        nioCnxn.doIO(sk);                Thread.sleep(1000L);        LOG.info("Watches processed");                int watchCount = database.getDataTree().getWatchCount();        if (sessionTimedout) {                        LOG.info("session is not valid, watches = {}", watchCount);            assertEquals("Session is not valid so there should be no watches", 0, watchCount);        } else {                        LOG.info("session is valid, watches = {}", watchCount);            assertEquals("Session is valid so the watch should be there", 1, watchCount);        }    } finally {        if (fzks != null) {            fzks.shutdown();        }    }}
336504b239a92f33ba2949bab36c8e029563b275a8846fa40d9843d48ff3b614
answer
public Boolean answer(InvocationOnMock invocation) throws Throwable
{    SelectionKey sk = (SelectionKey) invocation.getArguments()[0];    NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();    sk.interestOps(nioSrvCnx.getInterestOps());    return true;}
a74f102fbbaf2b6806d935d5603da5e711c66912831aa6fca5c95f6b1ee2bf29
channel
public SelectableChannel channel()
{    return null;}
0162442a7c5ed590e02d246b93a12a29d94a2c310f448f7925440b6c1a0a05ee
selector
public Selector selector()
{    return mock(Selector.class);}
5d7e7426cc3979089b19a726ac0ddfcf063e2e361e313de81396724c2e017b02
isValid
public boolean isValid()
{    return true;}
8e2e15bc239297e41c6ca1c3353f9e41484d08a5a299d452ddf9c1e60e2a0217
cancel
public void cancel()
{}
5dc36929be26bd58e4706569ecbfc0593243b20be54ba273cff47613b9933147
interestOps
public int interestOps()
{    return ops;}
57bf4050b18aba7bb4c2048164fecbfe40939165886d0c45e5e27f537fa30f39
interestOps
public SelectionKey interestOps(int ops)
{    this.ops = ops;    return this;}
9c34c93a5787cb7721b80768d5735d29f9ec5b8a937ca27be2e33fd6e4791562
readyOps
public int readyOps()
{    boolean reading = (ops & OP_READ) != 0;    boolean writing = (ops & OP_WRITE) != 0;    if (reading && writing) {        LOG.info("Channel is ready for reading and writing");    } else if (reading) {        LOG.info("Channel is ready for reading only");    } else if (writing) {        LOG.info("Channel is ready for writing only");    }    return ops;}
f6adbce10409e11fe72a6e175a1860a6c19fbf8a8d2a0c5a7ed3665045b2be5e
createWatchesMessage
private ByteBuffer createWatchesMessage()
{    List<String> dataWatches = new ArrayList<String>(1);    dataWatches.add("/");    List<String> existWatches = Collections.emptyList();    List<String> childWatches = Collections.emptyList();    SetWatches sw = new SetWatches(1L, dataWatches, existWatches, childWatches);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setWatches);    h.setXid(-8);    MockPacket p = new MockPacket(h, new ReplyHeader(), sw, null, null);    return p.createAndReturnBB();}
f1661eb332734d0e36795173643ceb999f73274ba07a2c13852a196662dd47d2
createConnRequest
private ByteBuffer createConnRequest()
{    Random r = new Random(SESSION_ID ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    ConnectRequest conReq = new ConnectRequest(0, 1L, 30000, SESSION_ID, p);    MockPacket packet = new MockPacket(null, null, conReq, null, null, false);    return packet.createAndReturnBB();}
a4e82c5da151484a2cb660ab4d14aa1e02a78c5f167dbb5544d8ed45bca68832
createClientSocketChannel
private SocketChannel createClientSocketChannel() throws IOException
{    SocketChannel socketChannel = mock(SocketChannel.class);    Socket socket = mock(Socket.class);    InetSocketAddress socketAddress = new InetSocketAddress(1234);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddress);    when(socketChannel.socket()).thenReturn(socket);        final ByteBuffer connRequest = createConnRequest();    final ByteBuffer watchesMessage = createWatchesMessage();    final ByteBuffer request = ByteBuffer.allocate(connRequest.limit() + watchesMessage.limit());    request.put(connRequest);    request.put(watchesMessage);    Answer<Integer> answer = new Answer<Integer>() {        int i = 0;        @Override        public Integer answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            ByteBuffer bb = (ByteBuffer) args[0];            for (int k = 0; k < bb.limit(); k++) {                bb.put(request.get(i));                i = i + 1;            }            return bb.limit();        }    };    when(socketChannel.read(any(ByteBuffer.class))).thenAnswer(answer);    return socketChannel;}
085b33efd03f68ce42cbf20f76ea3958df86d9dcf37cfdfc086289ccf503efcb
answer
public Integer answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    ByteBuffer bb = (ByteBuffer) args[0];    for (int k = 0; k < bb.limit(); k++) {        bb.put(request.get(i));        i = i + 1;    }    return bb.limit();}
25e01419f5abd483f896d97bf724df005e06984b9204c68c3cdf0e5e4316d761
createValidateSessionPacketResponse
private QuorumPacket createValidateSessionPacketResponse(boolean valid) throws Exception
{    QuorumPacket qp = createValidateSessionPacket();    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);        dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    return qp;}
a7e660e1bb208fa25ad6580c20a083bf5ce1c1f055a0682d75877f12e8e622b5
createValidateSessionPacket
private QuorumPacket createValidateSessionPacket() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(SESSION_ID);    dos.writeInt(3000);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    return qp;}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        leader.lead();    } catch (InterruptedException e) {        LOG.info("Leader thread interrupted", e);    } catch (Exception e) {        LOG.warn("Unexpected exception in leader thread", e);    } finally {        leader.shutdown("lead ended");    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    if (onlyGetEpochToPropose) {        try {            epoch = leader.getEpochToPropose(followerSid, 0);        } catch (Exception e) {        }    } else {        try {            leader.waitForEpochAck(followerSid, new StateSummary(0, 0));            msg = "FollowerMockThread (id = " + followerSid + ")  returned from waitForEpochAck";        } catch (Exception e) {        }    }}
0b5ae867803ec2e29ca7baa0eb8ae73c7c961d6e60593fbac2f16b3bf320b79a
testLeaderInConnectingFollowers
public void testLeaderInConnectingFollowers() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        FollowerMockThread f1 = new FollowerMockThread(1, leader, true);        FollowerMockThread f2 = new FollowerMockThread(2, leader, true);        f1.start();        f2.start();                                f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                try {            long epoch = leader.getEpochToPropose(leader.self.getId(), leader.self.getAcceptedEpoch());            assertEquals("leader got wrong epoch from getEpochToPropose", 6, epoch);        } catch (Exception e) {            fail("leader timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
7d1bad98afced3332bf8a80fff07be9e868eab514cca0ccdc5c6cc2500f3b031
testLastAcceptedEpoch
public void testLastAcceptedEpoch() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    LeadThread leadThread = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createMockLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        leadThread = new LeadThread(leader);        leadThread.start();        while (((MockLeader) leader).getCurrentEpochToPropose() != 6) {            Thread.sleep(20);        }        try {            long epoch = leader.getEpochToPropose(1, 6);            assertEquals("New proposed epoch is wrong", 7, epoch);        } catch (Exception e) {            fail("Timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
aae1f098d7d4f2db041f39638b6b6cec6383a979783dfa55c7c2fd27ff920318
testLeaderInElectingFollowers
public void testLeaderInElectingFollowers() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        FollowerMockThread f1 = new FollowerMockThread(1, leader, false);        FollowerMockThread f2 = new FollowerMockThread(2, leader, false);                leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());        f1.start();        f2.start();                        f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                assertTrue(f1.msg + " without waiting for leader", f1.msg == null);        assertTrue(f2.msg + " without waiting for leader", f2.msg == null);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
f540f28838d376042385be700184a5bd3a92161da4db7d6b6c2528d9a2923d7b
getSocketPair
 static Socket[] getSocketPair() throws IOException
{    ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));    InetSocketAddress endPoint = (InetSocketAddress) ss.getLocalSocketAddress();    Socket s = new Socket(endPoint.getAddress(), endPoint.getPort());    return new Socket[] { s, ss.accept() };}
bd018a071e467de10792f8988fc272333a1694f16184c3873da181d3648b6cca
readPacketSkippingPing
 static void readPacketSkippingPing(InputArchive ia, QuorumPacket qp) throws IOException
{    while (true) {        ia.readRecord(qp, null);        if (qp.getType() != Leader.PING) {            return;        }    }}
c99d7264ffe9d888f7f29b2b54416b43da9934ce99caedb8173a19425fa1cbec
testLeaderConversation
public void testLeaderConversation(LeaderConversation conversation) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
d83724fd568b1fc0b64dff7e5e033e2c87aedabc55d338e1610990f60a273939
testPopulatedLeaderConversation
public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversation, int ops) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {                FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);        ZKDatabase zkDb = new ZKDatabase(snapLog);        assertTrue(ops >= 1);        long zxid = ZxidUtils.makeZxid(1, 0);        for (int i = 1; i <= ops; i++) {            zxid = ZxidUtils.makeZxid(1, i);            String path = "/foo-" + i;            zkDb.processTxn(new TxnHeader(13, 1000 + i, zxid, 30 + i, ZooDefs.OpCode.create), new CreateTxn(path, "fpjwasalsohere".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));            Stat stat = new Stat();            assertEquals("fpjwasalsohere", new String(zkDb.getData(path, stat, null)));        }        assertTrue(zxid > ZxidUtils.makeZxid(1, 0));                snapLog.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), false);        snapLog.close();        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;                peer.setAcceptedEpoch(1);        peer.setCurrentEpoch(1);        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader, zxid);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
6a0d52b1422ce89a3eb3ac62820add247656806450ba82d3d415e7af2f0bc924
testFollowerConversation
public void testFollowerConversation(FollowerConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread followerThread = null;    ConversableFollower follower = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        follower = createFollower(tmpDir, peer);        peer.follower = follower;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        follower.setLeaderQuorumServer(leaderQS);        final Follower followerForThread = follower;        followerThread = new Thread() {            public void run() {                try {                    followerForThread.followLeader();                } catch (InterruptedException e) {                    LOG.info("Follower thread interrupted", e);                } catch (Exception e) {                    LOG.warn("Unexpected exception in follower thread", e);                }            }        };        followerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithFollower(ia, oa, follower);    } finally {        if (follower != null) {            follower.shutdown();        }        if (followerThread != null) {            followerThread.interrupt();            followerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        followerForThread.followLeader();    } catch (InterruptedException e) {        LOG.info("Follower thread interrupted", e);    } catch (Exception e) {        LOG.warn("Unexpected exception in follower thread", e);    }}
31ac524b971edd4ed732a2be9f9bbf7b1943335ac51c2353725292ebb890088c
testObserverConversation
public void testObserverConversation(ObserverConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread observerThread = null;    ConversableObserver observer = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        peer.setSyncEnabled(true);        observer = createObserver(tmpDir, peer);        peer.observer = observer;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        observer.setLeaderQuorumServer(leaderQS);        final Observer observerForThread = observer;        observerThread = new Thread() {            public void run() {                try {                    observerForThread.observeLeader();                } catch (Exception e) {                    e.printStackTrace();                }            }        };        observerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithObserver(ia, oa, observer);    } finally {        if (observer != null) {            observer.shutdown();        }        if (observerThread != null) {            observerThread.interrupt();            observerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        observerForThread.observeLeader();    } catch (Exception e) {        e.printStackTrace();    }}
08720e15083e1eb85c6c22ec38d0804a86b70ad0edac81c9026c531bfb320ee4
testUnnecessarySnap
public void testUnnecessarySnap() throws Exception
{    testPopulatedLeaderConversation(new PopulatedLeaderConversation() {        @Override        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception {            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(2, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            byte[] epochBytes = new byte[4];            final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);            wrappedEpochBytes.putInt(1);            qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());        }    }, 2);}
34acee433fc319942cfe687bc398eb11991c883a791c9f98b8b4fd22a64ca520
converseWithLeader
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception
{    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(2, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    byte[] epochBytes = new byte[4];    final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);    wrappedEpochBytes.putInt(1);    qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());}
eb53fa50beba6c02b0573930cc6b623fdec0a78d5bdbf3d3c10d38c7b7909c6f
waitForChange
 synchronized void waitForChange() throws InterruptedException
{    while (!changed) {        wait();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        synchronized (this) {            changed = true;            notifyAll();        }    }}
f3453f6d4e9390cfaeac7d6757c40142a9470783eff5be7177681b4842255333
changed
public synchronized boolean changed()
{    return changed;}
7189df85803ebce23aee83153171df4c9fe0c7a5d77cb9185ddc739670e3b21b
testNormalFollowerRun
public void testNormalFollowerRun() throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                                Thread.sleep(10);                                verify(f.zk, never()).takeSnapshot();                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                verify(f.zk).takeSnapshot(true);                assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(firstZxid, lastZxid);                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                TrackerWatcher watcher = new TrackerWatcher();                                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(proposalZxid, qp.getZxid());                watcher.waitForChange();                assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(proposalZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
012a984f9ba44d15b36345507dcf2053b3742cb751765d3f03c06832d8c9490c
converseWithFollower
public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);                Thread.sleep(10);                verify(f.zk, never()).takeSnapshot();        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                verify(f.zk).takeSnapshot(true);        assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(firstZxid, lastZxid);                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, proposalZxid, "data2", 2);        oa.writeRecord(qp, null);        TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(proposalZxid, qp.getZxid());        watcher.waitForChange();        assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(proposalZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
6d12b4a8660eb88e222fd1dd1c5234fd5d771fa171123a1589d11e002e821832
proposeSetData
private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
fe4292cad34b56044e233ed9adf954a8ee3aae39c85bdfef09bc561e461e0742
testNormalFollowerRunWithDiff
public void testNormalFollowerRunWithDiff() throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.DIFF);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                final long createSessionZxid = ZxidUtils.makeZxid(1, 2);                proposeNewSession(qp, createSessionZxid, 0x333);                oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);                qp.setZxid(createSessionZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                qp.setData(null);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                                long start = System.currentTimeMillis();                while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                }                assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                start = System.currentTimeMillis();                zkDb2.loadDataBase();                while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                    zkDb2.loadDataBase();                }                LOG.info("zkdb2 sessions:" + zkDb2.getSessions());                LOG.info("zkdb2 with timeouts:" + zkDb2.getSessionWithTimeOuts());                assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                                verify(f.zk, never()).takeSnapshot();            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);            CreateSessionTxn cst = new CreateSessionTxn(30000);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(cst, null);            qp.setData(baos.toByteArray());        }    });}
012a984f9ba44d15b36345507dcf2053b3742cb751765d3f03c06832d8c9490c
converseWithFollower
public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.DIFF);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        final long createSessionZxid = ZxidUtils.makeZxid(1, 2);        proposeNewSession(qp, createSessionZxid, 0x333);        oa.writeRecord(qp, null);        qp.setType(Leader.COMMIT);        qp.setZxid(createSessionZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        qp.setData(null);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                        long start = System.currentTimeMillis();        while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);        }        assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        start = System.currentTimeMillis();        zkDb2.loadDataBase();        while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);            zkDb2.loadDataBase();        }        LOG.info("zkdb2 sessions:" + zkDb2.getSessions());        LOG.info("zkdb2 with timeouts:" + zkDb2.getSessionWithTimeOuts());        assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                verify(f.zk, never()).takeSnapshot();    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
d86a482d39c99b0addf9beff1ae60af17c656a622da9831172be13948245b16c
proposeNewSession
private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);    CreateSessionTxn cst = new CreateSessionTxn(30000);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(cst, null);    qp.setData(baos.toByteArray());}
eedeb8d7e29cc0292f7eafc7be17d14f5ba9d7b31512456f3b5d0d77665b8c84
testNormalRun
public void testNormalRun() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
67da013e7536157d8ebfcbe2fd61d9105786396a6c1d52938d4cecac3f2cb58e
converseWithLeader
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
88122c9548d87962b3e273d3517795f141221de63012b66f23a4235ad9a62bab
testTxnTimeout
public void testTxnTimeout() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());            long zxid = l.zk.getZxid();            l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));            readPacketSkippingPing(ia, qp);            assertEquals(Leader.PROPOSAL, qp.getType());            LOG.info("Proposal sent.");            for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {                try {                    ia.readRecord(qp, null);                    LOG.info("Ping received: " + i);                    qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);                    oa.writeRecord(qp, null);                } catch (EOFException e) {                    return;                }            }            fail("Connection hasn't been closed by leader after transaction times out.");        }    });}
ef357e6b4b09296ca9bfa9c99d3f7e37379f99e36fb91caa919178ca077b100e
converseWithLeader
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());    long zxid = l.zk.getZxid();    l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));    readPacketSkippingPing(ia, qp);    assertEquals(Leader.PROPOSAL, qp.getType());    LOG.info("Proposal sent.");    for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {        try {            ia.readRecord(qp, null);            LOG.info("Ping received: " + i);            qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);            oa.writeRecord(qp, null);        } catch (EOFException e) {            return;        }    }    fail("Connection hasn't been closed by leader after transaction times out.");}
14c0bc515bac810300c33828170b88422100a2aee7b7aeabe3cd933a456ed799
deserializeSnapshot
private void deserializeSnapshot(InputArchive ia) throws IOException
{    ZKDatabase zkdb = new ZKDatabase(null);    zkdb.deserializeSnapshot(ia);    String signature = ia.readString("signature");    assertEquals("BenWasHere", signature);}
56b4a380d77297e0fa9a43e0faa99ce8995feb8b862c493b7f1d998b306a4c73
testNormalObserverRun
public void testNormalObserverRun() throws Exception
{    testObserverConversation(new ObserverConversation() {        @Override        public void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();            try {                assertEquals(0, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long foo1Zxid = ZxidUtils.makeZxid(1, 1);                final long foo2Zxid = ZxidUtils.makeZxid(1, 2);                zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));                assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.OBSERVERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(1, o.self.getCurrentEpoch());                assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals(foo2Zxid, lastZxid);                                TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                                long informZxid = ZxidUtils.makeZxid(1, 1001);                proposeSetData(qp, "/foo2", informZxid, "data2", 2);                qp.setType(Leader.INFORM);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                watcher.waitForChange();                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                                                o.zk.shutdown();                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));                assertEquals(informZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
3dfe6b6d0c641294c25d7a7c0ad3504fd7733d53d73c538a42aa1d74a4e5b589
converseWithObserver
public void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();    try {        assertEquals(0, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long foo1Zxid = ZxidUtils.makeZxid(1, 1);        final long foo2Zxid = ZxidUtils.makeZxid(1, 2);        zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));        assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.OBSERVERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(1, o.self.getCurrentEpoch());        assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals(foo2Zxid, lastZxid);                TrackerWatcher watcher = new TrackerWatcher();        assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);        oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);                long informZxid = ZxidUtils.makeZxid(1, 1001);        proposeSetData(qp, "/foo2", informZxid, "data2", 2);        qp.setType(Leader.INFORM);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                watcher.waitForChange();        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                        o.zk.shutdown();        zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));        assertEquals(informZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
368b647dc6bec601012e68519e7cadb1d0c36e5e2f3899c1c05cacc9a3b4b2d9
proposeSetData
private void proposeSetData(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
183d3c7fb4746d34df0c4660458ecbcef4664fd904a2c8b43aaf9e5aaaec591d
testLeaderBehind
public void testLeaderBehind() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            /* we are going to say we last acked epoch 20 */            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
67da013e7536157d8ebfcbe2fd61d9105786396a6c1d52938d4cecac3f2cb58e
converseWithLeader
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    /* we are going to say we last acked epoch 20 */    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
56cb0492ec42039209f728b2973bf4dda9df117ae05ff0a30568c48839727b66
testAbandonBeforeACKEpoch
public void testAbandonBeforeACKEpoch() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);                        assertEquals(0, l.self.getCurrentEpoch());        }    });}
cab9ffa3393269b4e4c5331eb5fdc5ddd71cf9394fa64aa65a89ace13a8556de
converseWithLeader
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);        assertEquals(0, l.self.getCurrentEpoch());}
edea8e3a030ad16c75f0a328f350c6076bd32dd6d525a3927772080c3a800e54
setLeaderQuorumServer
public void setLeaderQuorumServer(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
79070af7db730b6aaaa9b66c0f393c36123c405d6dcf30fbb73f94c323ce5069
findLeader
protected QuorumServer findLeader()
{    return leaderQuorumServer;}
4f2ad45e99e8b9c0c39aa1b56d4ab8db739078a7ad4c4764725fd7205d7118a0
createFollower
private ConversableFollower createFollower(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    FollowerZooKeeperServer zk = new FollowerZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableFollower(peer, zk);}
edea8e3a030ad16c75f0a328f350c6076bd32dd6d525a3927772080c3a800e54
setLeaderQuorumServer
public void setLeaderQuorumServer(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
79070af7db730b6aaaa9b66c0f393c36123c405d6dcf30fbb73f94c323ce5069
findLeader
protected QuorumServer findLeader()
{    return leaderQuorumServer;}
0c3fb32b351c08fd503d774dd0a50fc72a552745b0e73dc26743fedd82eef562
createObserver
private ConversableObserver createObserver(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    ObserverZooKeeperServer zk = new ObserverZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableObserver(peer, zk);}
83c454dd0698527ddeffc7de34815e7650ec712fb8fd42fd566ca1df99f5aaf0
readContentsOfFile
private String readContentsOfFile(File f) throws IOException
{    return new BufferedReader(new FileReader(f)).readLine();}
1110f4cd80e452165ec8bded65c212095c248a3493db229c5bf24ebf3c554c82
testInitialAcceptedCurrent
public void testInitialAcceptedCurrent() throws Exception
{    File tmpDir = File.createTempFile("test", ".dir", testData);    tmpDir.delete();    tmpDir.mkdir();    try {        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);        File version2 = new File(tmpDir, "version-2");        version2.mkdir();        logFactory.save(new DataTree(), new ConcurrentHashMap<Long, Integer>(), false);        long zxid = ZxidUtils.makeZxid(3, 3);        logFactory.append(new Request(1, 1, ZooDefs.OpCode.error, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.error), new ErrorTxn(1), zxid));        logFactory.commit();        ZKDatabase zkDb = new ZKDatabase(logFactory);        QuorumPeer peer = QuorumPeer.testingQuorumPeer();        peer.setZKDatabase(zkDb);        peer.setTxnFactory(logFactory);        peer.getLastLoggedZxid();        assertEquals(3, peer.getAcceptedEpoch());        assertEquals(3, peer.getCurrentEpoch());        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.CURRENT_EPOCH_FILENAME))));        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.ACCEPTED_EPOCH_FILENAME))));    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
3c656cc3b8f3763426bb08c6598d8af32cce9a97cab36a04ccecefcdb96b26d8
createQuorumPeer
public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException
{    HashMap<Long, QuorumPeer.QuorumServer> peers = new HashMap<Long, QuorumPeer.QuorumServer>();    QuorumPeer peer = QuorumPeer.testingQuorumPeer();    peer.syncLimit = SYNC_LIMIT;    peer.initLimit = 2;    peer.tickTime = 2000;    peers.put(0L, new QuorumPeer.QuorumServer(0, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(1L, new QuorumPeer.QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(2L, new QuorumPeer.QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peer.setQuorumVerifier(new QuorumMaj(peers), false);    peer.setCnxnFactory(new NullServerCnxnFactory());    File version2 = new File(tmpDir, "version-2");    version2.mkdir();    ClientBase.createInitializeFile(tmpDir);    FileOutputStream fos = new FileOutputStream(new File(version2, "currentEpoch"));    fos.write("0\n".getBytes());    fos.close();    fos = new FileOutputStream(new File(version2, "acceptedEpoch"));    fos.write("0\n".getBytes());    fos.close();    return peer;}
142f259127b64a78bf8689a5fbbdd67ec777b04b40c942ab1293a59df4fcf18a
createLeader
public static Leader createLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new Leader(peer, zk);}
778269d63c37c39be432160ec0d99a56f62a838918c89117b325da29595c4e2a
createMockLeader
public static Leader createMockLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new MockLeader(peer, zk);}
c2d6f5e2dfeabd8f65fa4474eadfea5bb7269c63be34be390c5aaee975c44b24
prepareLeader
private static LeaderZooKeeperServer prepareLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, peer, zkDb);    return zk;}
4be4852a32569fd08a6471cc46b0cf8607c84e60ada28860bca9a2fb670c46d4
startup
public void startup(ZooKeeperServer zkServer, boolean startServer) throws IOException, InterruptedException
{}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
78da50d2f121d55b38d4ba46ed3b47334752ed03e7f4016471440b07a443e60b
setMaxClientCnxnsPerHost
public void setMaxClientCnxnsPerHost(int max)
{}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{}
c2f6e9114cdf78a13f287dea0bd0be7b979ab11c289ce88f5a34a884eb1eb2f6
getMaxClientCnxnsPerHost
public int getMaxClientCnxnsPerHost()
{    return 0;}
8f86d51876296c7eed1e83dbd0f52004e0f019bff357df5cd0c681d950856f3c
getSocketListenBacklog
public int getSocketListenBacklog()
{    return -1;}
0f9342907a55818619d2e2cfa5fa813892dc2783be692f8ecc0da9029bc998d0
getLocalPort
public int getLocalPort()
{    return 0;}
932c7deb6f166bae646eeeb2a602d70f876a6d84fb955006b41c6e45c5b97bab
getLocalAddress
public InetSocketAddress getLocalAddress()
{    return null;}
6de8cf9ab3f727cc2ed14c5955c80e7d8b809af8d0c2ac4fb0074e3d877e2074
getConnections
public Iterable<ServerCnxn> getConnections()
{    return null;}
3997cfc4efd12b81db5c333e2a6423dc3c2141a834fb69924cde2dcf34a39c0d
configure
public void configure(InetSocketAddress addr, int maxcc, int listenBacklog, boolean secure) throws IOException
{}
f1e0156c1cca147486a7bbac7507dbeb5c0ebcd5299c0b712c2e22976e17c82b
closeSession
public boolean closeSession(long sessionId, ServerCnxn.DisconnectReason reason)
{    return false;}
9618e3575be04e74d82d1804fa8dc911f0a105f5bb4a5a1eb9ce97317fd27e96
closeAll
public void closeAll(ServerCnxn.DisconnectReason reason)
{}
80f15d79a8f066a4ef679f0cbd2626c8f556717c0fc8117787226cdc8dc2a46b
getNumAliveConnections
public int getNumAliveConnections()
{    return 0;}
7b331c2708882f50d8f4b87c307968343a5187ab2acae4292c7fa54232b64442
reconfigure
public void reconfigure(InetSocketAddress addr)
{}
615cf9dcbd18f11125b7fd2bc66c45596616007a5dbab858acd99aa19935522f
resetAllConnectionStats
public void resetAllConnectionStats()
{}
3c74c863c15ec83c7164e0cfae9f6a1820b2694bcac1e903f279dea9d9e9bdfd
getAllConnectionInfo
public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief)
{    return null;}
f4c409d783614ada2be8bf4f65da90e5a964c33f8400328b0220e1ea6ed19dac
getCurrentEpochToPropose
public long getCurrentEpochToPropose()
{    return epoch;}
ef31b950bef5ae880ced803c41e8251f0443b9402c8a71a9ca17f54bffd20608
testSameACLGivesSameID
public void testSameACLGivesSameID()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));}
0c9824ea1e24ab1e6d58ab9c457b6e2463c70b9b109b63155369fa9206172eca
testWhetherOrderingMatters
public void testWhetherOrderingMatters()
{    List<ACL> testACL = new ArrayList<ACL>();    testACL.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    testACL.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = new ArrayList<ACL>();    testACL2.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    testACL2.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    assertFalse(aclId.equals(cache.convertAcls(testACL2)));}
6968b6ee6ae12d8dd1865438a1b1c5184b5ec4af232f1d910bb21ae21c4f339b
testBidirectionality
public void testBidirectionality()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(testACL, cache.convertLong(aclId));}
6a4078f6c2a0e2007329224028b72b23de80cf2a3ee786ba218489e5ed75e7c6
testCacheSize
public void testCacheSize()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));    assertEquals(1, cache.size());    List<ACL> testACL3 = createACL("differentId");    Long aclId3 = cache.convertAcls(testACL3);    assertFalse(aclId3.equals(aclId));    assertEquals(2, cache.size());}
ebfcc21d21bbf66b68215f6c3869cfdd3f8a2b062ef3d22aedae69ac85701aa3
testAddThenRemove
public void testAddThenRemove()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
4cf1365dbc4e6555d950a165be6bcb65981a2e8e935fcf50c5d7a49c28f4aa06
testMultipleAddsAndRemove
public void testMultipleAddsAndRemove()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("anotherId");    cache.convertAcls(testACL2);    cache.removeUsage(aclId);    assertEquals(2, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    Long newId = cache.convertAcls(testACL);    assertFalse(aclId.equals(newId));}
957b1a99c6b383424fe47a79d5df90f890281e5d97dbed66648e25161808951c
testAddUsage
public void testAddUsage()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.addUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
d8a723a780d0b2b16ae7e027105ff22fec64fbfaa7995ee26246e14b464af511
testAddNonExistentUsage
public void testAddNonExistentUsage()
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    cache.addUsage(1L);    assertEquals(0, cache.size());/*        On startup, it's possible that we'll try calling addUsage of an ID not in the cache.  This is safe to ignore        as it'll be added later when we traverse the tranlog.  See discussion here:        http://mail-archives.apache.org/mod_mbox/zookeeper-user/201507.mbox/%3CCAB5oV2_ujhvBA1sEkCG2WRakPjCy%2BNR10620WK2G1GGgmEO44g%40mail.gmail.com%3E        This test makes sure that we don't add the ID to the cache in this case as that would result in dupes later        and consequently incorrect counts and entries that will never be cleaned out.         */}
4c5f6dbf94991c60babdc94bb603e1f7d2e4b15f995618b318d8b343a2b66409
testSerializeDeserialize
public void testSerializeDeserialize() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    callAddUsageNTimes(deserializedCache, aclId3, 3);    callAddUsageNTimes(deserializedCache, aclId4, 4);    callAddUsageNTimes(deserializedCache, aclId5, 5);    assertCachesEqual(cache, deserializedCache);}
93e13fafadf198b33c2000c8c68b968f8c8f45f31d8cb2da1b8c060c4550c15a
testNPEInDeserialize
public void testNPEInDeserialize() throws IOException
{    ReferenceCountedACLCache serializeCache = new ReferenceCountedACLCache() {        @Override        public synchronized void serialize(OutputArchive oa) throws IOException {            oa.writeInt(1, "map");            oa.writeLong(1, "long");            oa.startVector(null, "acls");            oa.endVector(null, "acls");        }    };    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    serializeCache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    try {        deserializedCache.deserialize(inArchive);    } catch (NullPointerException e) {        fail("should not throw NPE while do deserialized");    } catch (RuntimeException e) {        }}
7d27302df89a8ecd04da7f48ebedf864b377e433d8a743b6b1f831de92d62b13
serialize
public synchronized void serialize(OutputArchive oa) throws IOException
{    oa.writeInt(1, "map");    oa.writeLong(1, "long");    oa.startVector(null, "acls");    oa.endVector(null, "acls");}
a47c85393ef4a6402acf7dcfcd7c5e8c09f41840e2684828e30f9690af2241c0
assertCachesEqual
private void assertCachesEqual(ReferenceCountedACLCache expected, ReferenceCountedACLCache actual)
{    assertEquals(expected.aclIndex, actual.aclIndex);    assertEquals(expected.aclKeyMap, actual.aclKeyMap);    assertEquals(expected.longKeyMap, actual.longKeyMap);    assertEquals(expected.referenceCounter, actual.referenceCounter);}
803d5693e70655ad5083bd3b223db5fec2c08afdca969c6c7ea68255c313ced9
testPurgeUnused
public void testPurgeUnused() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    deserializedCache.purgeUnused();    assertEquals(2, deserializedCache.size());    assertEquals(aclId1, deserializedCache.convertAcls(acl1));    assertEquals(aclId2, deserializedCache.convertAcls(acl2));    assertFalse(acl3.equals(deserializedCache.convertAcls(acl3)));    assertFalse(acl4.equals(deserializedCache.convertAcls(acl4)));    assertFalse(acl5.equals(deserializedCache.convertAcls(acl5)));}
f65dcf26f109cd975eb39a0f6230691dedd9929d8d2a36f018101879916c455f
callAddUsageNTimes
private void callAddUsageNTimes(ReferenceCountedACLCache deserializedCache, Long aclId, int num)
{    for (int i = 0; i < num; i++) {        deserializedCache.addUsage(aclId);    }}
febed317c20fd9e2714724cf9c13ddbcaf1b1788a845048a957af3f045ea75a4
convertACLsNTimes
private Long convertACLsNTimes(ReferenceCountedACLCache cache, List<ACL> acl, int num)
{    if (num <= 0) {        return -1L;    }    for (int i = 0; i < num - 1; i++) {        cache.convertAcls(acl);    }    return cache.convertAcls(acl);}
0198524396896451ce78f94e489fd65c0f5a48fab6c9c88edecaef9d90c7c764
createACL
private List<ACL> createACL(String id)
{    List<ACL> acl1 = new ArrayList<ACL>();    acl1.add(new ACL(ZooDefs.Perms.ADMIN, new Id("scheme", id)));    return acl1;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{        File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    LOG.info("starting up the zookeeper server .. waiting");    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    resumeProcess = null;    submitted = null;    zk = ClientBase.createZKClient(HOSTPORT);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{        if (null != zk) {        zk.close();    }    if (null != f) {        f.shutdown();    }    if (null != zks) {        zks.shutdown();    }}
106db5961d4061bcf6d1b6c3ad4e05fed83456947bb24ab7f84c1895155674fe
setupRequestProcessors
protected void setupRequestProcessors()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new TestPrepRequestProcessor(this, syncProcessor);    ((TestPrepRequestProcessor) firstProcessor).start();}
05c91e8f4b123110aab2a85a840c8de16dd95b0bf4d4b293177674c9c960a81d
submitRequest
public void submitRequest(Request si)
{    if (null != submitted) {        submitted.countDown();    }    super.submitRequest(si);}
fd1df31d2223e16cc97a8f3063c8d3d103aabc9ee7d6e6d5f324a3a5d77f246b
requestFinished
public void requestFinished(Request request)
{    if (null != finished) {        finished.countDown();    }    super.requestFinished(request);}
762e31dafa1e930d00aebf3a62ab329278c4aea280ead326f65623461273196b
pRequest
protected void pRequest(Request request) throws RequestProcessorException
{        if (resumeProcess != null) {        try {            resumeProcess.await(20, TimeUnit.SECONDS);        } catch (Exception e) {        }    }    if (entered != null) {        entered.countDown();    }    super.pRequest(request);}
7741bd4eccec19f72999000e22a4098288f0a2dfe1ac54f73bc161c1f866105a
testRequestThrottler
public void testRequestThrottler() throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(false);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);    entered = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));            resumeProcess.countDown();    entered.await(STALL_TIME, TimeUnit.MILLISECONDS);    metrics = MetricsUtils.currentServerMetrics();    assertEquals(TOTAL_REQUESTS, (long) metrics.get("prep_processor_request_queued"));}
9ecb6903293ac3662e45f8e762b4d0cfdb77d2c4dec503749c92cd5d815b9dcd
testDropStaleRequests
public void testDropStaleRequests() throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(true);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));    for (ServerCnxn cnxn : f.cnxns) {        cnxn.setStale();    }    zk = null;    resumeProcess.countDown();    LOG.info("raise the latch");    while (zks.getInflight() > 0) {        Thread.sleep(50);    }            metrics = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1, (long) metrics.get("stale_requests_dropped"));}
171928399573b8fb427932ecb908a6671108b38e4b5fa19d79359e527fdc4214
testLargeRequestThrottling
public void testLargeRequestThrottling() throws Exception
{    ServerMetrics.getMetrics().resetAll();    AsyncCallback.StringCallback createCallback = (rc, path, ctx, name) -> {        if (KeeperException.Code.get(rc) == KeeperException.Code.CONNECTIONLOSS) {            disconnected.countDown();            connectionLossCount++;        }    };        RequestThrottler.setMaxRequests(5);        zks.setLargeRequestThreshold(150);    zks.setLargeRequestMaxBytes(400);        resumeProcess = new CountDownLatch(1);            disconnected = new CountDownLatch(TOTAL_REQUESTS);        byte[] data = new byte[100];        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createCallback, null);    }        disconnected.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();            Assert.assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    Assert.assertEquals(1L, (long) metrics.get("large_requests_rejected"));    Assert.assertEquals(5, connectionLossCount);    finished = new CountDownLatch(2);        resumeProcess.countDown();    finished.await(5, TimeUnit.SECONDS);        metrics = MetricsUtils.currentServerMetrics();    Assert.assertEquals(2, (long) metrics.get("stale_replies"));}
25b35cf2ca566b5b4b14451f4ded1a3f4e745f0a14883c16b91d1495a5574ab6
write
public void write(int b)
{}
ca16e57aa72838c44c9396d3812a229a48fb6eb4617530b101f46e7db5c69812
createNodes
 static int createNodes(DataTree tree, String path, int depth, int childcount, int parentCVersion, byte[] data) throws KeeperException.NodeExistsException, KeeperException.NoNodeException
{    path += "node" + depth;    tree.createNode(path, data, null, -1, ++parentCVersion, 1, 1);    if (--depth == 0) {        return 1;    }    path += "/";    int count = 1;    for (int i = 0; i < childcount; i++) {        count += createNodes(tree, path + i, depth, childcount, 1, data);    }    return count;}
28367965a2e6fd76762c3a46c7a1373d86a9050f6b8ca306f7ee38603b845024
serializeTree
private static void serializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    DataTree tree = new DataTree();    createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);    int count = tree.getNodeCount();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream());    System.gc();    long start = System.nanoTime();    tree.serialize(oa, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    LOG.info("Serialized " + count + " nodes in " + durationms + " ms (" + pernodeus + "us/node), depth=" + depth + " width=" + width + " datalen=" + len);}
4b45fa4126aa89a8aebeabd706cc2315051d2b7a0e8143c87ea3362bcd5ca085
testSingleSerialize
public void testSingleSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(1, 0, 20);}
3ac606609c19dd37ba00815be34de26ea5f402a7c8d78c71562d890ef71a487c
testWideSerialize
public void testWideSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(2, 10000, 20);}
ab4b685867ee25d5f1ef05c80d99cc77227ad6e410c21f4baf3bcdd6e82c0634
testDeepSerialize
public void testDeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(400, 1, 20);}
62b10a9567270e649ee658cde3897d057f93df76108cb85ce59258e5857b6a0f
test10Wide5DeepSerialize
public void test10Wide5DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 10, 20);}
9c6dd72b2432a20a5b8b9ca015665fb9665734de0681b409e2fe21c329561350
test15Wide5DeepSerialize
public void test15Wide5DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 15, 20);}
de32daaac94f2f05cd5ec0674e01aae72d5cb99638fad19bcbe951597add22bf
test25Wide4DeepSerialize
public void test25Wide4DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 25, 20);}
36f61cbfdfae691c1007521ee65372db3c8ff93f3f40ad2f092d57b07f533ca9
test40Wide4DeepSerialize
public void test40Wide4DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 40, 20);}
1f818d22f3133f3a916c49464f88ae79a40805c21539752371395c24f1ea7679
test300Wide3DeepSerialize
public void test300Wide3DeepSerialize() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(3, 300, 20);}
5ce9e4b5135c3e8068000ffe2c4ec1f99d09ecbfa4e063040be7b494f947dd2f
data
public static List<TestType> data()
{    List<TestType> testTypes = new ArrayList<>();    for (boolean ttlsEnabled : new boolean[] { true, false }) {        for (int serverId = 0; serverId <= 255; ++serverId) {            testTypes.add(new TestType(ttlsEnabled, serverId));        }    }    return testTypes;}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.extendedTypesEnabled");}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty("zookeeper.extendedTypesEnabled", Boolean.toString(testType.ttlsEnabled));    LOG.info("ttlsEnabled: {} - ServerId: {}", testType.ttlsEnabled, testType.serverId);    try {        super.setUpWithServerId(testType.serverId);    } catch (RuntimeException e) {        if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {                        return;        }        throw e;    }}
a977434e538d9b77b183f84389d35d59a803114e6d624eb32656ff70e382b73b
doTest
public void doTest() throws Exception
{    if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {        return;    }    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo", -1);        if (testType.ttlsEnabled) {                        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);        } else {            try {                zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);                fail("Should have thrown KeeperException.UnimplementedException");            } catch (KeeperException.UnimplementedException e) {                        }        }    } finally {        if (zk != null) {            zk.close();        }    }}
221a8be69f88dd1338c4167eea16cc38f436008b104e83bdf235bfd15de8d0f0
generateRandomValues
private long[] generateRandomValues(int size)
{        final long[] values = new long[size];    if (size == 0) {        return values;    }    final long rangeMin = Long.MIN_VALUE / size;    final long rangeMax = Long.MAX_VALUE / size;    for (int i = 0; i < size; ++i) {        values[i] = ThreadLocalRandom.current().nextLong(rangeMin, rangeMax);    }    return values;}
b2e5d7172ac292d1dcf10fc69558c5cda0bbdc01422b45cf58fed12aaf96edf5
testAvgMinMaxCounter
public void testAvgMinMaxCounter()
{    final AvgMinMaxCounter metric = new AvgMinMaxCounter("test");    testAvgMinMaxCounter(metric, 0);    testAvgMinMaxCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testAvgMinMaxCounter(metric, RANDOM_SIZE);    }}
b4ba259d33fd43fbe1bcf620ae9718451c4e43b3c48e114388528e3b3ee14945
testAvgMinMaxCounter
private void testAvgMinMaxCounter(AvgMinMaxCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedMin = Arrays.stream(values).min().orElse(0);    long expectedMax = Arrays.stream(values).max().orElse(0);    long expectedSum = Arrays.stream(values).sum();    long expectedCnt = values.length;    double expectedAvg = expectedSum / Math.max(1, expectedCnt);    assertEquals(expectedAvg, metric.getAvg(), 200);    assertEquals(expectedMin, metric.getMin());    assertEquals(expectedMax, metric.getMax());    assertEquals(expectedCnt, metric.getCount());    assertEquals(expectedSum, metric.getTotal());    final Map<String, Object> results = metric.values();    assertEquals(expectedMax, (long) results.get("max_test"));    assertEquals(expectedMin, (long) results.get("min_test"));    assertEquals(expectedCnt, (long) results.get("cnt_test"));    assertEquals(expectedAvg, (double) results.get("avg_test"), 200);    metric.reset();}
e89304cf54f55f6d2dc42fbe5d537c60083b30d195934a7041186872ebbe9117
testSimpleCounter
public void testSimpleCounter()
{    SimpleCounter metric = new SimpleCounter("test");    testSimpleCounter(metric, 0);    testSimpleCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testSimpleCounter(metric, RANDOM_SIZE);    }}
c44d0c2d5c3740c905da17bc739f419a76884203df4132ce9e5cad4db822b308
testSimpleCounter
private void testSimpleCounter(SimpleCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedCount = Arrays.stream(values).sum();    assertEquals(expectedCount, metric.get());    final Map<String, Object> results = metric.values();    assertEquals(expectedCount, (long) results.get("test"));    metric.reset();}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    providerMock = mock(ServerStats.Provider.class);}
64c38943ced7faa937dcf214bea1ce793ac8ccc4a944fec9e06123b77a703e01
testPacketsMetrics
public void testPacketsMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 20;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementPacketsSent();        serverStats.incrementPacketsReceived();        serverStats.incrementPacketsReceived();    }        assertEquals(incrementCount, serverStats.getPacketsSent());    assertEquals(incrementCount * 2, serverStats.getPacketsReceived());        serverStats.resetRequestCounters();        assertAllPacketsZero(serverStats);}
fb05f05a0f523969a2499e7fe1c74e14de883ee5cd52033a3441d04117d95914
testLatencyMetrics
public void testLatencyMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 2000);        assertThat("Max latency check", 2000L, lessThanOrEqualTo(serverStats.getMaxLatency()));    assertThat("Min latency check", 1000L, lessThanOrEqualTo(serverStats.getMinLatency()));    assertEquals(1500, serverStats.getAvgLatency(), 200);        serverStats.resetLatency();        assertAllLatencyZero(serverStats);}
7ee5ef0d15123fd97d875ad19666d48908304bb719aca6651f1fb0521acf575b
testFsyncThresholdExceedMetrics
public void testFsyncThresholdExceedMetrics()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 30;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementFsyncThresholdExceedCount();    }        assertEquals(incrementCount, serverStats.getFsyncThresholdExceedCount());        serverStats.resetFsyncThresholdExceedCount();        assertFsyncThresholdExceedCountZero(serverStats);}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{        ServerStats serverStats = new ServerStats(providerMock);    assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.incrementPacketsSent();    serverStats.incrementPacketsReceived();    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.reset();        assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);}
ada1a0d56494033675ecf83f0aacd276f39fd09a4baf7a6e974d4476b1888179
assertAllPacketsZero
private void assertAllPacketsZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getPacketsSent());    assertEquals(0L, serverStats.getPacketsReceived());}
509a7ecd8df128167d742b5348f6144514cbd73b18e8a66b4bc5e5ce718970fd
assertAllLatencyZero
private void assertAllLatencyZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getMaxLatency());    assertEquals(0L, serverStats.getMinLatency());    assertEquals(0, serverStats.getAvgLatency(), 0.00001);}
e1eb99fcf49ce323dbc1651866be906fc39c0c085469f4e584ae9716b7ec40c1
assertFsyncThresholdExceedCountZero
private void assertFsyncThresholdExceedCountZero(ServerStats serverStats)
{    assertEquals(0L, serverStats.getFsyncThresholdExceedCount());}
89f92a7829c7e4c9634ed7a58112d746b889f1be33be8989099302d0dfa705e1
testAddSessionAfterSessionExpiry
public void testAddSessionAfterSessionExpiry() throws Exception
{    RequestThrottler.setMaxRequests(0);    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);                sessionTrackerImpl.trackSession(sessionId, sessionTimeout);    try {        sessionTrackerImpl.checkSession(sessionId, sessionOwner);        fail("Should throw session expiry exception " + "as the session has expired and closed");    } catch (KeeperException.SessionExpiredException e) {        }    assertTrue("Session didn't expired", sessionImpl.isClosing());    assertFalse("Session didn't expired", sessionTrackerImpl.touchSession(sessionId, sessionTimeout));    assertEquals("Duplicate session expiry request has been generated", 1, firstProcessor.getCountOfCloseSessionReq());}
e6073eea7b7bbfd9c619b6ff0c3d4f98027563b47c4f1413c9707cdb10f79eae
testCloseSessionRequestAfterSessionExpiry
public void testCloseSessionRequestAfterSessionExpiry() throws Exception
{    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);            sessionTrackerImpl.removeSession(sessionId);    SessionImpl actualSession = sessionTrackerImpl.sessionsById.get(sessionId);    assertNull("Session:" + sessionId + " still exists after removal", actualSession);}
6d5d8ebda323f681b08608adf0be4cd1d092f3b94a2fa1a215855977620f4f28
setupSessionTracker
private ZooKeeperServer setupSessionTracker() throws IOException
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.setupRequestProcessors();    firstProcessor = new FirstProcessor(zks, null);    zks.firstProcessor = firstProcessor;        zks.createSessionTracker();    zks.startSessionTracker();    zks.startRequestThrottler();    return zks;}
bb13a9966e7ae4e6921a17ad9c5888ceb6a24f7f4bc3b39eed7b92f18e79dd13
processRequest
public void processRequest(Request request)
{        if (request.type == OpCode.closeSession) {        countOfCloseSessionReq++;        latch.countDown();    }}
ad745569ff51d17118cad6ba2787f5f4c37952e83f34a749e211ba277fd63f67
getCountOfCloseSessionReq
 int getCountOfCloseSessionReq()
{    return countOfCloseSessionReq;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    server = serverFactory.getZooKeeperServer();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{        super.tearDown();    if (zk != null) {        zk.close();    }}
8e7d011dbd391446f826236511dd82494783338c6d29f82827db8c4673fde37b
setupCustomizedEnv
public void setupCustomizedEnv()
{    ZooKeeperServer.setDigestEnabled(true);    System.setProperty(ZooKeeperServer.SNAP_COUNT, "100");}
bb8cac3c573e774c541ef7bce7db2b9d466fa1f083ec04a3e6772ab95656d8d4
cleanUpCustomizedEnv
public void cleanUpCustomizedEnv()
{    ZooKeeperServer.setDigestEnabled(false);    System.clearProperty(ZooKeeperServer.SNAP_COUNT);}
f62184b4f150d7e53181a4268b81b13cd764f6cb74bd8f1c98a20080803377ef
testSnapshotDigest
public void testSnapshotDigest() throws Exception
{            server.takeSnapshot();    reloadSnapshotAndCheckDigest();        String pathPrefix = "/testSnapshotDigest";    for (int i = 0; i < 1000; i++) {        String path = pathPrefix + i;        zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        String firstNode = pathPrefix + 0;    zk.setData(firstNode, "new_setdata".getBytes(), -1);        zk.delete(firstNode, -1);        List<Op> subTxns = new ArrayList<Op>();    for (int i = 0; i < 3; i++) {        String path = pathPrefix + "-m" + i;        subTxns.add(Op.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    }    zk.multi(subTxns);    reloadSnapshotAndCheckDigest();        server = serverFactory.getZooKeeperServer();    server.takeSnapshot();    reloadSnapshotAndCheckDigest();}
624c526578729d2cd0f2d8f763b58821c768bf0c3b73de6bd3a10d1069cc5a9f
testDifferentDigestVersion
public void testDifferentDigestVersion() throws Exception
{        int currentVersion = new DigestCalculator().getDigestVersion();        String path = "/testDifferentDigestVersion";    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();        int newVersion = currentVersion + 1;    DigestCalculator newVersionDigestCalculator = Mockito.spy(DigestCalculator.class);    Mockito.when(newVersionDigestCalculator.getDigestVersion()).thenReturn(newVersion);    assertEquals(newVersion, newVersionDigestCalculator.getDigestVersion());            FileTxnSnapLog txnSnapLog = new FileTxnSnapLog(tmpDir, tmpDir);    DataTree dataTree = Mockito.spy(new DataTree(newVersionDigestCalculator));    Mockito.when(dataTree.getTreeDigest()).thenReturn(0L);    txnSnapLog.restore(dataTree, new ConcurrentHashMap<>(), Mockito.mock(FileTxnSnapLog.PlayBackListener.class));        Mockito.verify(dataTree, Mockito.never()).reportDigestMismatch(Mockito.anyLong());}
fc6bb5110fc6d755ca4439e8d04e8b9fe0147d37504633898ac153ba92ff84c8
testBackwardCompatible
public void testBackwardCompatible() throws Exception
{    testCompatibleHelper(false, true);    testCompatibleHelper(true, false);}
de04bda079e87619bac50fe79238b7fece94feb417f87ebd1196531708433b35
testCompatibleHelper
private void testCompatibleHelper(Boolean enabledBefore, Boolean enabledAfter) throws Exception
{    ZooKeeperServer.setDigestEnabled(enabledBefore);        reloadSnapshotAndCheckDigest();        String path = "/testCompatible" + "-" + enabledBefore + "-" + enabledAfter;    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();    ZooKeeperServer.setDigestEnabled(enabledAfter);    reloadSnapshotAndCheckDigest();    assertEquals(path, new String(zk.getData(path, false, null)));}
84a20aac92c379dc97a0c1b9f92db432aa95db5e998fc652c80d670af9a9a4ec
reloadSnapshotAndCheckDigest
private void reloadSnapshotAndCheckDigest() throws Exception
{    stopServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTING);    ((SimpleCounter) ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT).reset();    startServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTED);        assertEquals(0L, ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.get());        assertNull(server.getZKDatabase().getDataTree().getDigestFromLoadedSnapshot());}
3d40b59ba02a0d20810b284fa6d90eb3ec9cdf625c0100f8f92582d6606568ba
testJuteToString
public void testJuteToString()
{    SetDataRequest req = new SetDataRequest(null, null, 0);    assertNotSame("ERROR", req.toString());}
e6fb3dad2d0d76d590fbcaed001731108eb8bfecaa3465e7942e134d2b41bea9
generateRandomHashes
private static List<Long> generateRandomHashes(int count)
{    ArrayList<Long> list = new ArrayList<>(count);    for (int i = 0; i < count; i++) {        list.add(rand.nextLong());    }    return list;}
191b5139bcbd91eeab5647ccbd54d8173fbbe0521f883b2b46dbae293dcf8219
addListOfDigests
private static void addListOfDigests(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.addDigest(b);    }}
bf4ad785b9bc68c3abb2c0de97b6c6049353c33a6a823245b478e83f2218cd14
removeListOfDigests
private static void removeListOfDigests(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.removeDigest(b);    }}
c267464d636f39f53938b121b3b12119b024d85328e9aad0a3586eb74f6ef285
testAdHash
public void testAdHash() throws Exception
{    List<Long> bucket1 = generateRandomHashes(50);    List<Long> bucket2 = generateRandomHashes(3);    List<Long> bucket3 = generateRandomHashes(30);    List<Long> bucket4 = generateRandomHashes(10);    List<Long> bucket5 = generateRandomHashes(5);        AdHash hash12 = new AdHash();    addListOfDigests(hash12, bucket1);    addListOfDigests(hash12, bucket2);    AdHash hash21 = new AdHash();    addListOfDigests(hash21, bucket2);    addListOfDigests(hash21, bucket1);    assertEquals(hash12, hash21);    AdHash hashall = new AdHash();    addListOfDigests(hashall, bucket1);    addListOfDigests(hashall, bucket2);    addListOfDigests(hashall, bucket3);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertFalse("digest of different set not different", hashall.equals(hash21));    removeListOfDigests(hashall, bucket4);    removeListOfDigests(hashall, bucket5);    addListOfDigests(hash21, bucket3);    assertEquals("hashall with 4 & 5 removed should match hash21 with 3 added", hashall, hash21);    removeListOfDigests(hashall, bucket3);    removeListOfDigests(hashall, bucket2);    removeListOfDigests(hashall, bucket1);    assertEquals("empty hashall's digest should be 0", hashall.toHexString(), "0");    AdHash hash45 = new AdHash();    addListOfDigests(hash45, bucket4);    addListOfDigests(hash45, bucket5);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertEquals("empty hashall + 4&5 should equal hash45", hashall, hash45);}
c87ca0d795602922753fbd9f542fa403a72fea4156630588ae3605f1962b0b51
testAddWatchBit
public void testAddWatchBit()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    assertTrue(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1 }, actualBits.toArray(new Integer[actualBits.size()]));        assertFalse(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());        assertTrue(ws.add(2));    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    assertTrue(ws.contains(1));    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1, 2 }, actualBits.toArray(new Integer[actualBits.size()]));}
b55a25a47416356f1761559ee741865d95f64336a114da2fa489546b31c69703
testRemoveWatchBit
public void testRemoveWatchBit()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    ws.add(1);    ws.add(2);    assertTrue(ws.contains(1));    assertTrue(ws.contains(2));    ws.remove(1);    assertFalse(ws.contains(1));    assertEquals(1, ws.size());    assertEquals(0, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.add(3);    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2, 3 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.remove(2);    ws.remove(3);    assertEquals(0, ws.size());    assertEquals(0, ws.cachedSize());}
4fd4694fc4719aec9f604afcad2a66194966f26c6dae11c94fa2df99810d72bd
testAddAndRemove
public void testAddAndRemove()
{    BitMap<String> bitMap = new BitMap<String>();    String v1 = "v1";    Integer bit = bitMap.add(v1);    assertEquals(1, bitMap.size());    assertTrue(bit >= 0);    assertEquals(v1, bitMap.get(bit));    assertEquals(bit, bitMap.getBit(v1));        Integer newBit = bitMap.add(v1);    assertEquals(bit, newBit);    assertEquals(1, bitMap.size());    String v2 = "v2";    Integer v2Bit = bitMap.add(v2);    assertEquals(2, bitMap.size());    assertNotEquals(v2Bit, bit);        bitMap.remove(v1);    assertEquals(1, bitMap.size());    assertNull(bitMap.get(bit));    assertNull(bitMap.getBit(v1));        bitMap.remove(v2Bit);    assertEquals(0, bitMap.size());    assertNull(bitMap.get(v2Bit));    assertNull(bitMap.getBit(v2));}
23b667b6a0269af9e181b1b23e4dddeb1051aca48a9e27b34a7e9741876d9a28
testBitReuse
public void testBitReuse()
{    BitMap<String> bitMap = new BitMap<String>();    int v1Bit = bitMap.add("v1");    int v2Bit = bitMap.add("v2");    int v3Bit = bitMap.add("v3");    bitMap.remove(v2Bit);    int v4Bit = bitMap.add("v4");    assertEquals(v4Bit, v2Bit);}
7445375b8560c1f7ad2fddf76b93eccf97ca26c1e5f68594eb2fd80d6c85f82a
testCircularBuffer
public void testCircularBuffer()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("C");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("A", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("B", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("C", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("1");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("2");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("3");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("4");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("2", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("3", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("4", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("a");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("b");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("c");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("d");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("e");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("f");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("g");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("e", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("f", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("g", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
d0e19f55037c0c32e6464268ca00a077b3d81a3d850e7c28fbcf8fc303336661
testCircularBufferWithCapacity1
public void testCircularBufferWithCapacity1()
{    final int capacity = 1;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("B", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
7a47e02c76ab9a8095fb7cfc39d5e416d30c097246db2c8f6edd8a9ef58cebbe
testCircularBufferReset
public void testCircularBufferReset()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(1, buffer.size());    Assert.assertEquals("A", buffer.peek());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(2, buffer.size());    Assert.assertEquals("A", buffer.peek());        buffer.reset();    Assert.assertNull(buffer.peek());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(0, buffer.size());}
24b4c444629f8f6b5ad7a8c9a1bfdced8c73e607bfc2e73678c4d0e9c7eaeffb
testCircularBufferIllegalCapacity
public void testCircularBufferIllegalCapacity()
{    try {        CircularBuffer<String> buffer = new CircularBuffer<>(String.class, 0);        Assert.fail();    } catch (IllegalArgumentException e) {        Assert.assertEquals("CircularBuffer capacity should be greater than 0", e.getMessage());    }}
2dd9753dc2160e75cd86c13c62c01994cb9eb526228bc30b7ea3efec0c897a10
testGetHostAndPortWithIPv6
public void testGetHostAndPortWithIPv6() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443");    assertEquals(nsa[0], "2001:db8:85a3:8d3:1319:8a2e:370:7348");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:2888:3888");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
598cf0cb53d768e856d9c9fd63531382aad7e0a715f3b275afa9329476a2592c
testGetHostAndPortWithIPv4
public void testGetHostAndPortWithIPv4() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1:443");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("127.0.0.1:2888:3888");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
8a0e9f7ee10cfb9d8801f5410ebcdc361fd0151e798310adf6a5311c974bf24b
testGetHostAndPortWithoutBracket
public void testGetHostAndPortWithoutBracket() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348");}
2783266cd66f237b85102cd261d0bc983d39709f4ebd46b089f9d3ae5c52873a
testGetHostAndPortWithoutPortAfterColon
public void testGetHostAndPortWithoutPortAfterColon() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:");}
81350e112884d8c762a47e3f8241dcd5eb40ec49acc7c640407d862b867250e4
testGetHostAndPortWithoutPort
public void testGetHostAndPortWithoutPort() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa.length, 1);    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa.length, 1);}
28d9178a1e28cb81e2605216f89d22367f13c99d6b27cfd603273805e4385789
testJvmPauseMonitorExceedInfoThreshold
public void testJvmPauseMonitorExceedInfoThreshold() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));    while (pauseMonitor.getNumGcInfoThresholdExceeded() == 0) {        Thread.sleep(200);    }}
50ca7f197cf384f13269a711d4f1b633c789688544030844d8650df270bb35ee
testJvmPauseMonitorExceedWarnThreshold
public void testJvmPauseMonitorExceedWarnThreshold() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));    while (pauseMonitor.getNumGcWarnThresholdExceeded() == 0) {        Thread.sleep(200);    }}
ec8b6259c87a96a7e78ab8ec13a826f2caf0d2a1c593d4aec011e181f3e17bbf
teardown
public void teardown()
{    pauseMonitor.serviceStop();}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty(MessageTracker.MESSAGE_TRACKER_ENABLED, "true");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(MessageTracker.MESSAGE_TRACKER_ENABLED);}
2ee8bf5d3465f116d90aac72db290b0f3dc3383143513353bd1857e3f661887d
testTrackSend
public void testTrackSend() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackSent(timestamp2);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);}
100e9485a80c9b5f6dadf7afcd9db24930763a3bc3bb758ad6f4c4ffe97d52d0
testTrackReceived
public void testTrackReceived() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackReceived(timestamp2);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);}
c49281af025f6624d431de05dd912c64e14676bf25b90142f59fef44b2ddf2f8
testMessageTrackerFull
public void testMessageTrackerFull() throws InterruptedException
{    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        long timestampSent = 0;    long timestampReceived = 0;    for (int i = 0; i <= BUFFERED_MESSAGE_SIZE; i++) {        if (i == 1) {            timestampSent = System.currentTimeMillis();            messageTracker.trackSent(timestampSent);            Thread.sleep(2);            timestampReceived = System.currentTimeMillis();            messageTracker.trackReceived(timestampReceived);        } else {            messageTracker.trackSent(System.currentTimeMillis());            messageTracker.trackReceived(System.currentTimeMillis());        }        Thread.sleep(1);    }    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestampSent);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestampReceived);}
0ee576946ce878fbf8672fdbd5504a8af534a982ad7ddac993ecd2081f52039b
testDumpToLog
public void testDumpToLog()
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);    String sid = "127.0.0.1";        messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertNull(messageTracker.peekReceived());    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    Thread.currentThread().setName(toClose.toString() + "-->" + toClose2.toString());    byte[] buf = new byte[1024];    try {        while (true) {            try {                int read = this.in.read(buf);                if (read > 0) {                    try {                        this.out.write(buf, 0, read);                    } catch (IOException e) {                        LOG.warn("exception during write", e);                        break;                    }                } else if (read < 0) {                    throw new IOException("read " + read);                }            } catch (SocketTimeoutException e) {                LOG.error("socket timeout", e);            }        }        Thread.sleep(1);    } catch (InterruptedException e) {        LOG.warn("Interrupted", e);    } catch (SocketException e) {        if (!"Socket closed".equals(e.getMessage())) {            LOG.error("Unexpected exception", e);        }    } catch (IOException e) {        LOG.error("Unexpected exception", e);    } finally {        shutdown();    }    LOG.info("Shutting down forward for " + toClose);    isFinished = true;}
9f593ea5e0347a28841bb2a24231f86ce879e276fa61257f0e13e2790f329974
waitForShutdown
 boolean waitForShutdown(long timeoutMs) throws InterruptedException
{    synchronized (this) {        if (!isFinished) {            this.wait(timeoutMs);        }    }    return isFinished;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    try {        toClose.close();    } catch (IOException ex) {        }    try {        toClose2.close();    } catch (IOException ex) {        }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        while (!stopped) {            Socket sock = null;            try {                LOG.info("accepting socket local:" + serverSocket.getLocalPort() + " to:" + to);                sock = serverSocket.accept();                LOG.info("accepted: local:" + sock.getLocalPort() + " from:" + sock.getPort() + " to:" + to);                Socket target = null;                int retry = 10;                while (sock.isConnected()) {                    try {                        target = new Socket("localhost", to);                        break;                    } catch (IOException e) {                        if (retry == 0) {                            throw e;                        }                        LOG.warn("connection failed, retrying(" + retry + "): local:" + sock.getLocalPort() + " from:" + sock.getPort() + " to:" + to, e);                    }                    Thread.sleep(TimeUnit.SECONDS.toMillis(1));                    retry--;                }                LOG.info("connected: local:" + sock.getLocalPort() + " from:" + sock.getPort() + " to:" + to);                sock.setSoTimeout(30000);                target.setSoTimeout(30000);                workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));                workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));                for (PortForwardWorker worker : workers) {                    workerExecutor.submit(worker);                }            } catch (SocketTimeoutException e) {                LOG.warn("socket timed out", e);            } catch (ConnectException e) {                LOG.warn("connection exception local:" + sock.getLocalPort() + " from:" + sock.getPort() + " to:" + to, e);                sock.close();            } catch (IOException e) {                if (!"Socket closed".equals(e.getMessage())) {                    LOG.warn("unexpected exception local:" + sock.getLocalPort() + " from:" + sock.getPort() + " to:" + to, e);                    throw e;                }            }        }    } catch (IOException e) {        LOG.error("Unexpected exception to:" + to, e);    } catch (InterruptedException e) {        LOG.error("Interrupted to:" + to, e);    }}
05584a94e26733f067c8429ee7e0e3e90657e320fbdfa1bc96eaddc1cf11c7fe
shutdown
public void shutdown() throws Exception
{    this.stopped = true;    this.serverSocket.close();    this.join();    this.workerExecutor.shutdownNow();    for (PortForwardWorker worker : workers) {        worker.shutdown();    }    for (PortForwardWorker worker : workers) {        if (!worker.waitForShutdown(5000)) {            throw new Exception("Failed to stop forwarding within 5 seconds");        }    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    System.setProperty("zookeeper.pathStats.enabled", "true");    System.setProperty("zookeeper.pathStats.slotCapacity", "60");    System.setProperty("zookeeper.pathStats.slotDuration", "1");    System.setProperty("zookeeper.pathStats.maxDepth", "6");    System.setProperty("zookeeper.pathStats.sampleRate", "1.0");}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    System.clearProperty("zookeeper.pathStats.enabled");    System.clearProperty("zookeeper.pathStats.slotCapacity");    System.clearProperty("zookeeper.pathStats.slotDuration");    System.clearProperty("zookeeper.pathStats.maxDepth");    System.clearProperty("zookeeper.pathStats.sampleRate");}
5ba5a0b8ac2e667e0203b7825ac1e578c8d54ceaf9208bcfe4a4a8a118ccc120
testTrimPath
public void testTrimPath()
{        String trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 1);    assertTrue(trimedPath.equalsIgnoreCase("/p1"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 4);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));        trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 6);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));}
1915c847efe26c05f23ee3688d1e5701cc9456dec0a00dd4130814ecc76fcb03
testQueueMapReduce
public void testQueueMapReduce() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(create2);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 1000000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i);        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 1; i < 100000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i);        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1);    assertTrue(newSlot.get("/path1").compareTo(1111111) == 0);        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 12);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2").compareTo(1111100) == 0);        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 112);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2/path3").compareTo(1111000) == 0);        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1112);    assertTrue(newSlot.get("/path1/path2/path3/path4").compareTo(1110000) == 0);        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 11112);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5").compareTo(1100000) == 0);        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 111111);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5/path6").compareTo(1000001) == 0);        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1111111);}
fbbbeae777c42322d6dfe3a2bf792f1e547032e39c2fe0c1b77ce5db1062e8fe
testCollectEmptyStats
public void testCollectEmptyStats() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    Thread.sleep(5000);    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.isEmpty());    pathStatsQueue.start();    Thread.sleep(15000);    newSlot = pathStatsQueue.collectStats(1);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(2);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(5);    assertTrue(newSlot.size() == 0);}
f0acd14554fede30de1293c35e7470c41196f72e968aae6ffb58cae55d678c51
testCollectStats
public void testCollectStats() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    pathStatsQueue.start();    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(500);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.collectStats(1);    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1").intValue(), 1111112);        newSlot = pathStatsQueue.collectStats(2);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = pathStatsQueue.collectStats(3);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = pathStatsQueue.collectStats(4);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = pathStatsQueue.collectStats(5);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = pathStatsQueue.collectStats(6);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);}
108aa6cf4e237858114b81cb7f6cb493d9c9e3b96aec7cabf0d29a53f6766c61
testAggregate
public void testAggregate() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(2, queue -> true);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> true);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(5, queue -> true);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = requestPathMetricsCollector.aggregatePaths(6, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);        newSlot = requestPathMetricsCollector.aggregatePaths(7, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);            newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> !queue.isWriteOperation());    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 1111);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1000);}
54548832ead95b85279b890eed3c66596b4ea4e990e56069303360340d222ad0
testTopPath
public void testTopPath() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    StringBuilder sb1 = new StringBuilder();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb1.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb1.toString().startsWith("/path1/path2/path3 : 1000"));    StringBuilder sb2 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> !queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb2.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb2.toString().startsWith("/path1/path2/path3 : 1110001"));    StringBuilder sb3 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb3.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb3.toString().startsWith("/path1/path2/path3/path4 : 1110001"));}
2b93b0d708226defe794f3bd98142e0b073ebaf59b8bca450e0ca621b6010ed1
testMultiThreadPerf
public void testMultiThreadPerf() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    Random rand = new Random(System.currentTimeMillis());    Long startTime = System.currentTimeMillis();    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();        for (int i = 0; i < 100000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(create2, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 40000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path" + rand.nextInt(10))));    }    executor.shutdown();        executor.awaitTermination(10, TimeUnit.MILLISECONDS);    assertTrue(executor.isTerminated());    Long endTime = System.currentTimeMillis();        assertTrue(TimeUnit.MILLISECONDS.toSeconds(endTime - startTime) < 3);}
4b88a9c15d6a31911b572445ad5e025229f46c867ec110c92384a8b2f9808a5f
testSerializeRequestRequestIsNull
public void testSerializeRequestRequestIsNull()
{    byte[] data = SerializeUtils.serializeRequest(null);    assertNull(data);}
8b948b4ec580635a2c6cd36b9591f2bc01fc631c9da69b8956beb57cbb843353
testSerializeRequestRequestHeaderIsNull
public void testSerializeRequestRequestHeaderIsNull()
{    Request request = new Request(0, 0, 0, null, null, 0);    byte[] data = SerializeUtils.serializeRequest(request);    assertNull(data);}
0657e7e8850ea2ff5c97b4972eced7e02920236f6044e2bca3430a75bc876245
testSerializeRequestWithoutTxn
public void testSerializeRequestWithoutTxn() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, null, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    verify(header).serialize(any(OutputArchive.class), eq("hdr"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
ca2a9e4c867042d3d767960a38b0319d682d7859dce060976f7d87729e5d9387
answer
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
1c41111723c0e6a08ce4c4226b540b14304cabd9994438325f066df192b57425
testSerializeRequestWithTxn
public void testSerializeRequestWithTxn() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, txn, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    InOrder inOrder = inOrder(header, txn);    inOrder.verify(header).serialize(any(OutputArchive.class), eq("hdr"));    inOrder.verify(txn).serialize(any(OutputArchive.class), eq("txn"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    boa.writeString("record", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
ca2a9e4c867042d3d767960a38b0319d682d7859dce060976f7d87729e5d9387
answer
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
ca2a9e4c867042d3d767960a38b0319d682d7859dce060976f7d87729e5d9387
answer
public Object answer(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    log = LoggerFactory.getLogger("TODO: Mock Logging");}
81ba16b1bde46ecd35de445365f8402044fff5cf835007b715de843a7fd84a6c
testForWarningOnRelativePath
public void testForWarningOnRelativePath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("a/relative/path");}
95620fed55ba03c665591089cdcd4092187def6bf806d5479becc9a0b4f4ce39
testForNoWarningOnIntendedRelativePath
public void testForNoWarningOnIntendedRelativePath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("./an/intended/relative/path");}
1008875a373a0a0c9f96a145c31648891253a0fd71760a3b91fbbe7416718443
testForFailForNonExistingPath
public void testForFailForNonExistingPath()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).failForNonExistingPath().build();    vff.create("/I/H0p3/this/path/d035/n0t/ex15t");}
41ef276b8fcce26b705ae2660773b5d5b741a91d34f05d94f2710d200353e88d
testFileHasCorrectPath
public void testFileHasCorrectPath()
{    File file = new File("/some/path");    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).build();    assertEquals(file, vff.create(file.getPath()));}
57dc6614d6033a9ebaa02d45d3c45312368689c40d67a114a12ddecd6d8928b3
setCountDownLatch
public void setCountDownLatch(CountDownLatch latch)
{    this.latch = latch;}
294ebdd50b95e011cf9af91a22703ce6aaea00ffc76a9cf2f41a49ee428d9fdf
setDelayMs
public void setDelayMs(int delayMs)
{    this.delayMs = delayMs;}
eb53518159a8e716cececc97c414a337c4508262cfd0428268e4cb60e8375cbd
processDeadWatchers
public void processDeadWatchers(Set<Integer> deadWatchers)
{    if (delayMs > 0) {        try {            Thread.sleep(delayMs);        } catch (InterruptedException e) {        }    }    this.deadWatchers.clear();    this.deadWatchers.addAll(deadWatchers);    latch.countDown();}
0c3fda8b34fcb3f5dc95a2632e16353b7691225982eeb95077d00664fbb75a07
getDeadWatchers
public Set<Integer> getDeadWatchers()
{    return deadWatchers;}
8bc4a68ab7b9eef5d2979eef0c967f163cb2f2f25a93396527b270bb48db24ec
wait
public boolean wait(int maxWaitMs)
{    try {        return latch.await(maxWaitMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {    }    return false;}
902f3384f439dc04447dd99b766ab5660b4854e99990aae02ec8b73e7fc8a464
testProcessDeadWatchersBasedOnThreshold
public void testProcessDeadWatchersBasedOnThreshold()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int threshold = 3;    WatcherCleaner cleaner = new WatcherCleaner(listener, threshold, 60, 1, 10);    cleaner.start();    int i = 0;    while (i++ < threshold - 1) {        cleaner.addDeadWatcher(i);    }        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));        cleaner.addDeadWatcher(i);    assertTrue(listener.wait(1000));    assertEquals(threshold, listener.getDeadWatchers().size());}
fecf328d54420822abc6403c23124924ae733616d222375dcf77e955146c0fe3
testProcessDeadWatchersBasedOnTime
public void testProcessDeadWatchersBasedOnTime()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 10, 1, 1, 10);    cleaner.start();    cleaner.addDeadWatcher(1);        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));    assertTrue(listener.wait(2000));    assertEquals(1, listener.getDeadWatchers().size());        listener.setCountDownLatch(new CountDownLatch(1));    assertFalse(listener.wait(2000));}
83529310682f01b15c4ad9b9f9f70ea54457e1ed3bedd69e20f4008169bdf37a
testMaxInProcessingDeadWatchers
public void testMaxInProcessingDeadWatchers()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int delayMs = 1000;    listener.setDelayMs(delayMs);    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 60, 1, 1);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(2));    long startTime = Time.currentElapsedTime();    cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    long time = Time.currentElapsedTime() - startTime;    System.out.println("time used " + time);    assertTrue(Time.currentElapsedTime() - startTime >= delayMs);    assertTrue(listener.wait(5000));}
0b32a26225104a6e6f874321347c808cd728d438320a21a60ddd4d7906596704
testDeadWatcherMetrics
public void testDeadWatcherMetrics()
{    ServerMetrics.getMetrics().resetAll();    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 1, 1, 1);    listener.setDelayMs(20);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(3));            cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    cleaner.addDeadWatcher(3);    assertTrue(listener.wait(5000));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat("Adding dead watcher should be stalled twice", (Long) values.get("add_dead_watcher_stall_time"), greaterThan(0L));    assertEquals("Total dead watchers added to the queue should be 3", 3L, values.get("dead_watchers_queued"));    assertEquals("Total dead watchers cleared should be 3", 3L, values.get("dead_watchers_cleared"));    assertEquals(3L, values.get("cnt_dead_watchers_cleaner_latency"));        assertEquals(20D, (Double) values.get("avg_dead_watchers_cleaner_latency"), 5);    assertEquals(20D, ((Long) values.get("min_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("max_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p50_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p95_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p99_dead_watchers_cleaner_latency")).doubleValue(), 5);}
5b072f37298d7626f3bbe9a7c2d0a51107e5bfe5acfc0f3fe393a943ff66b712
testWatcherSet
public void testWatcherSet()
{    Set<Watcher> wset = new HashSet<Watcher>();    WatcherOrBitSet hashSet = new WatcherOrBitSet(wset);    assertEquals(0, hashSet.size());    DumbWatcher w1 = new DumbWatcher();    assertFalse(hashSet.contains(w1));    wset.add(w1);    assertTrue(hashSet.contains(w1));    assertEquals(1, hashSet.size());    assertFalse(hashSet.contains(1));}
35bdd8abe027f2eda9740833a174e485c596f3738324e10236cbf69658efd2ae
testBitSet
public void testBitSet()
{    BitHashSet bset = new BitHashSet(0);    WatcherOrBitSet bitSet = new WatcherOrBitSet(bset);    assertEquals(0, bitSet.size());    Integer bit = 1;    assertFalse(bitSet.contains(1));    assertFalse(bitSet.contains(bit));    bset.add(bit);    assertTrue(bitSet.contains(1));    assertTrue(bitSet.contains(bit));    assertEquals(1, bitSet.size());}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    m = new HashMap<String, Set<Long>>();    Set<Long> s = new HashSet<Long>();    s.add(101L);    s.add(102L);    m.put("path1", s);    s = new HashSet<Long>();    s.add(201L);    m.put("path2", s);    r = new WatchesPathReport(m);}
8de3f4744d10c21e510544bfaabf5174c607af24fb7f8aff568aa4d4a925ff08
testHasSessions
public void testHasSessions()
{    assertTrue(r.hasSessions("path1"));    assertTrue(r.hasSessions("path2"));    assertFalse(r.hasSessions("path3"));}
b2819265ed98fdf55afcadcd4082a4a519731919df6d93efd3c704e8c87ab434
testGetSessions
public void testGetSessions()
{    Set<Long> s = r.getSessions("path1");    assertEquals(2, s.size());    assertTrue(s.contains(101L));    assertTrue(s.contains(102L));    s = r.getSessions("path2");    assertEquals(1, s.size());    assertTrue(s.contains(201L));    assertNull(r.getSessions("path3"));}
c573c69b58bc875a9dce4437076b8f597d00fed4904a7a07d0f6473620f36e2a
testToMap
public void testToMap()
{    assertEquals(m, r.toMap());}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    m = new HashMap<Long, Set<String>>();    Set<String> s = new HashSet<String>();    s.add("path1a");    s.add("path1b");    m.put(1L, s);    s = new HashSet<String>();    s.add("path2a");    m.put(2L, s);    r = new WatchesReport(m);}
93e1997384419628fdbec7476a726eb660409421efbf5ece5a17338a011034f5
testHasPaths
public void testHasPaths()
{    assertTrue(r.hasPaths(1L));    assertTrue(r.hasPaths(2L));    assertFalse(r.hasPaths(3L));}
847d06de446842ee8505f81d0ad3421defbfe08b09ca5b75952d1efcef426e5d
testGetPaths
public void testGetPaths()
{    Set<String> s = r.getPaths(1L);    assertEquals(2, s.size());    assertTrue(s.contains("path1a"));    assertTrue(s.contains("path1b"));    s = r.getPaths(2L);    assertEquals(1, s.size());    assertTrue(s.contains("path2a"));    assertNull(r.getPaths(3L));}
c573c69b58bc875a9dce4437076b8f597d00fed4904a7a07d0f6473620f36e2a
testToMap
public void testToMap()
{    assertEquals(m, r.toMap());}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    s = new WatchesSummary(1, 2, 3);}
68a7c6f72a1a96ed85b6b3515ce8af88c9fce8476a6de3f60d85a392f4b4f5b4
testGetters
public void testGetters()
{    assertEquals(1, s.getNumConnections());    assertEquals(2, s.getNumPaths());    assertEquals(3, s.getTotalWatches());}
c573c69b58bc875a9dce4437076b8f597d00fed4904a7a07d0f6473620f36e2a
testToMap
public void testToMap()
{    Map<String, Object> m = s.toMap();    assertEquals(3, m.size());    assertEquals(Integer.valueOf(1), m.get(WatchesSummary.KEY_NUM_CONNECTIONS));    assertEquals(Integer.valueOf(2), m.get(WatchesSummary.KEY_NUM_PATHS));    assertEquals(Integer.valueOf(3), m.get(WatchesSummary.KEY_NUM_TOTAL_WATCHES));}
530ee67749d6f2eff038a16df2c40b771781f68f89687d55f9dec83e341d4cb1
data
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { WatchManager.class.getName() }, { WatchManagerOptimized.class.getName() } });}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    ServerMetrics.getMetrics().resetAll();    watchers = new ConcurrentHashMap<Integer, DumbWatcher>();    r = new Random(System.nanoTime());}
3bfb564a8649b078cfb71893948f0dc6d3cc57719b224c4f0d039ddc52c74694
getWatchManager
public IWatchManager getWatchManager() throws IOException
{    System.setProperty(WatchManagerFactory.ZOOKEEPER_WATCH_MANAGER_NAME, className);    return WatchManagerFactory.createWatchManager();}
e5882b2a0c4049a4bdb7db3fbc7bd9802f55f659141e259f3c491b04ab55505e
createOrGetWatcher
public DumbWatcher createOrGetWatcher(int watcherId)
{    if (!watchers.containsKey(watcherId)) {        DumbWatcher watcher = new DumbWatcher(watcherId);        watchers.putIfAbsent(watcherId, watcher);    }    return watchers.get(watcherId);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.addWatch(path, watcher)) {            watchesAdded.addAndGet(1);        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stopped = true;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        WatcherOrBitSet s = manager.triggerWatch(path, EventType.NodeDeleted);        if (s != null) {            triggeredCount.addAndGet(s.size());        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stopped = true;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.removeWatcher(path, watcher)) {            watchesRemoved.addAndGet(1);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stopped = true;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!stopped) {        DumbWatcher watcher = createOrGetWatcher(r.nextInt(watchers));        watcher.setStale();        manager.removeWatcher(watcher);        synchronized (removedWatchers) {            removedWatchers.add(watcher);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    stopped = true;}
d0aa9eece5d432019e7fe2e1b8e377ab31a9c5767e4ce8425129cc93687ec22d
testAddAndTriggerWatcher
public void testAddAndTriggerWatcher() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 10000;            AtomicInteger watchTriggered = new AtomicInteger();    List<WatcherTriggerWorker> triggerWorkers = new ArrayList<WatcherTriggerWorker>();    for (int i = 0; i < 5; i++) {        WatcherTriggerWorker worker = new WatcherTriggerWorker(manager, paths, watchTriggered);        triggerWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        for (WatcherTriggerWorker worker : triggerWorkers) {        worker.shutdown();    }        assertTrue(watchesAdded.get() > 0);    assertEquals(watchesAdded.get(), watchTriggered.get());}
ce72bee5254d3f8402afc570a40126aea2aa05c6c02464e9be011e4402e97542
testRemoveWatcherOnPath
public void testRemoveWatcherOnPath() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 10;    int watchers = 10000;            AtomicInteger watchesRemoved = new AtomicInteger();    List<RemoveWatcherWorker> removeWorkers = new ArrayList<RemoveWatcherWorker>();    for (int i = 0; i < 5; i++) {        RemoveWatcherWorker worker = new RemoveWatcherWorker(manager, paths, watchers, watchesRemoved);        removeWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (RemoveWatcherWorker worker : removeWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        assertTrue(watchesAdded.get() > 0);    assertTrue(watchesRemoved.get() > 0);    assertTrue(manager.size() > 0);    assertEquals(watchesAdded.get(), watchesRemoved.get() + manager.size());}
791a7a1f2a92a95b9d1e898efedad9c02b77c18f635880de350010e5c2a4c8b2
testDeadWatchers
public void testDeadWatchers() throws IOException
{    System.setProperty("zookeeper.watcherCleanThreshold", "10");    System.setProperty("zookeeper.watcherCleanIntervalInSeconds", "1");    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 100000;            Set<Watcher> deadWatchers = new HashSet<Watcher>();    List<CreateDeadWatchersWorker> deadWorkers = new ArrayList<CreateDeadWatchersWorker>();    for (int i = 0; i < 5; i++) {        CreateDeadWatchersWorker worker = new CreateDeadWatchersWorker(manager, watchers, deadWatchers);        deadWorkers.add(worker);        worker.start();    }        AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 50000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (CreateDeadWatchersWorker worker : deadWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(2000);    } catch (InterruptedException e) {    }        WatchesReport existingWatchers = manager.getWatches();    for (Watcher w : deadWatchers) {        assertFalse(existingWatchers.hasPaths(((ServerCnxn) w).getSessionId()));    }}
fc605b7c27283dd4277f357196d647e7777e9010ecaa732bb850cfaf12b463f2
checkMetrics
private void checkMetrics(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(min, values.get("min_" + metricName));    assertEquals(max, values.get("max_" + metricName));    assertEquals(avg, (Double) values.get("avg_" + metricName), 0.000001);    assertEquals(cnt, values.get("cnt_" + metricName));    assertEquals(sum, values.get("sum_" + metricName));}
92acfeeccfdcfb45d2acd2149db3ad4cb36b777c5b10580ce4f7658a00f798c3
testWatcherMetrics
public void testWatcherMetrics() throws IOException
{    IWatchManager manager = getWatchManager();    ServerMetrics.getMetrics().resetAll();    DumbWatcher watcher1 = new DumbWatcher(1);    DumbWatcher watcher2 = new DumbWatcher(2);    final String path1 = "/path1";    final String path2 = "/path2";    final String path3 = "/path3";        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path3, EventType.NodeCreated);        checkMetrics("node_created_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.triggerWatch(path1, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 2L, 2L, 2D, 1L, 2L);        manager.triggerWatch(path2, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);        manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 2L, 2L, 2D, 1L, 2L);    manager.triggerWatch(path2, EventType.NodeDeleted);    checkMetrics("node_deleted_watch_count", 1L, 1L, 1D, 1L, 1L);        checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);}
b212a947e72a1dda3e79ee74ecb22989b52b2ea591c5b552c67e60f06d890ea4
processRequest
public void processRequest(Request request) throws RequestProcessorException
{        throw new RequestProcessorException("test", new Exception());}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    super.run();    processed.countDown();}
8e5d6bf005bf167991f05aa419e11e73b4d56df6087cc3304b7503351bd12aa6
testUnrecoverableErrorCountFromRequestProcessor
public void testUnrecoverableErrorCountFromRequestProcessor() throws Exception
{    ServerMetrics.getMetrics().resetAll();    processed = new CountDownLatch(1);    PrepRequestProcessor processor = new MyPrepRequestProcessor();    processor.start();    processor.processRequest(new Request(null, 1L, 1, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null));    processed.await();    processor.shutdown();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
6667260e0cc55668b26bb3f336ac99f2bc26a2bc6ff23c9c848a1159b206a5cc
testUnrecoverableErrorCount
public void testUnrecoverableErrorCount()
{    ServerMetrics.getMetrics().resetAll();    ZooKeeperServer zks = new ZooKeeperServer();    ZooKeeperCriticalThread thread = new ZooKeeperCriticalThread("test", zks.getZooKeeperServerListener());    thread.handleException("test", new Exception());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
3449c13a009a8353a2c1dcd698c51ee9487bc291d089f9d66f643970ae3d986c
testTxnLogElapsedSyncTime
public void testTxnLogElapsedSyncTime() throws IOException
{    File tmpDir = ClientBase.createEmptyTestDir();    FileTxnSnapLog fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZooKeeperServer zks = new ZooKeeperServer();    zks.setTxnLogFactory(fileTxnSnapLog);    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    long elapsedTime = serverBean.getTxnLogElapsedSyncTime();    assertEquals(-1, elapsedTime);    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        zks.getTxnLogFactory().append(req);        zks.getTxnLogFactory().commit();        elapsedTime = serverBean.getTxnLogElapsedSyncTime();        assertNotEquals(-1, elapsedTime);        assertEquals(elapsedTime, serverBean.getTxnLogElapsedSyncTime());    } finally {        fileTxnSnapLog.close();    }}
10b34c636cf26439429d192047b0a00d5da78dae111966f4765f3bed17d0b1c9
testGetSecureClientPort
public void testGetSecureClientPort() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured GetSecureClientPort     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured GetSecureClientPort should     * return configured port     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientPort();    assertEquals(Integer.toString(secureClientPort), result);        cnxnFactory.shutdown();}
7af0f25b9173f4bea877e68f374adff8429960a956518120938bd924ab3674ff
testGetSecureClientAddress
public void testGetSecureClientAddress() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured getSecureClientAddress     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured getSecureClientAddress     * should return configured SecureClientAddress     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientAddress();    String ipv4 = "0.0.0.0:" + secureClientPort;    String ipv6 = "0:0:0:0:0:0:0:0:" + secureClientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    c = new ZooKeeperServerConf(1, "a", "b", 2, 3, 4, 5, 6L, 7);}
68a7c6f72a1a96ed85b6b3515ce8af88c9fce8476a6de3f60d85a392f4b4f5b4
testGetters
public void testGetters()
{    assertEquals(1, c.getClientPort());    assertEquals("a", c.getDataDir());    assertEquals("b", c.getDataLogDir());    assertEquals(2, c.getTickTime());    assertEquals(3, c.getMaxClientCnxnsPerHost());    assertEquals(4, c.getMinSessionTimeout());    assertEquals(5, c.getMaxSessionTimeout());    assertEquals(6L, c.getServerId());    assertEquals(7, c.getClientPortListenBacklog());}
c573c69b58bc875a9dce4437076b8f597d00fed4904a7a07d0f6473620f36e2a
testToMap
public void testToMap()
{    Map<String, Object> m = c.toMap();    assertEquals(9, m.size());    assertEquals(Integer.valueOf(1), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT));    assertEquals("a", m.get(ZooKeeperServerConf.KEY_DATA_DIR));    assertEquals("b", m.get(ZooKeeperServerConf.KEY_DATA_LOG_DIR));    assertEquals(Integer.valueOf(2), m.get(ZooKeeperServerConf.KEY_TICK_TIME));    assertEquals(Integer.valueOf(3), m.get(ZooKeeperServerConf.KEY_MAX_CLIENT_CNXNS));    assertEquals(Integer.valueOf(4), m.get(ZooKeeperServerConf.KEY_MIN_SESSION_TIMEOUT));    assertEquals(Integer.valueOf(5), m.get(ZooKeeperServerConf.KEY_MAX_SESSION_TIMEOUT));    assertEquals(Long.valueOf(6L), m.get(ZooKeeperServerConf.KEY_SERVER_ID));    assertEquals(Integer.valueOf(7), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT_LISTEN_BACKLOG));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                LOG.error("unexpected exception in run", e);    }}
e74af4a7cb5b28ebe66bbe52c874e3f7bcec0509b3799b0483a43d7c9465c227
shutdown
public void shutdown() throws IOException
{    main.shutdown();}
9a9b5363f8053b4d369291466a1fd97f541043b6938af299cf1157fb22d12c69
deleteDirs
 void deleteDirs() throws IOException
{    delete(tmpDir);}
a7b66b8790805fd82ca8c838da854cd04df07af5ae0aad0f47be601c1e65872e
delete
 void delete(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            delete(c);        }    }    if (!f.delete()) {                if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
034b1c3b47a9c067bf023cbaecaf6dea7932d969ef1661edd7d103df9b3782fc
getCnxnFactory
 ServerCnxnFactory getCnxnFactory()
{    return main.getCnxnFactory();}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    super.shutdown();}
f8e16826a9121de8ab44ea1ce57bf088b622471815993a547525a28d36227c2e
testNonRecoverableError
public void testNonRecoverableError() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/foo1", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo1", null, null)), "foobar");        ZooKeeperServer zooKeeperServer = main.getCnxnFactory().getZooKeeperServer();    FileTxnSnapLog snapLog = zooKeeperServer.getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    zooKeeperServer.setZKDatabase(newDB);    try {                zk.create("/foo2", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected as error is injected in transaction log commit funtionality");    } catch (Exception e) {        }    zk.close();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    fileTxnSnapLogWithError.close();    main.shutdown();    main.deleteDirs();}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    throw new IOException("Input/output error");}
036909ffb6f7a1a78db7a3f80265d259ba00a790c144e447cbb4dec83b0ddbd1
testReadOnlySnapshotDir
public void testReadOnlySnapshotDir() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File snapDir = new File(main.dataDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    snapDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    snapDir.setWritable(true);    main.deleteDirs();}
07d679d2db098344c3a606a9999c3520cfc97e4cd4a43a5a77b0602eebc3cdfe
testReadOnlyTxnLogDir
public void testReadOnlyTxnLogDir() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File logDir = new File(main.logDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    logDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    logDir.setWritable(true);    main.deleteDirs();}
e90c8a95aa7890dacce7054bc4fc8cbef0a4379bde7a1d3847ad7e30540f887b
testStandalone
public void testStandalone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
b8609a550bcec106f75c768226087f31a92f754f842001c6ac17f0eb6d43f525
testWithMinSessionTimeoutGreaterThanMaxSessionTimeout
public void testWithMinSessionTimeoutGreaterThanMaxSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;        final int minSessionTimeout = 20 * tickTime + 1000;        final int maxSessionTimeout = tickTime * 2 - 100;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as " + "minsessiontimeout > maxsessiontimeout");    } catch (ConfigException iae) {        }}
7cc8769be4f353e998e8bec17f021643400a11ddb7a8c0b6b28310d19b6351e6
testInvalidMetricsProvider
public void testInvalidMetricsProvider() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=BadClass\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is not " + "well configured");    } catch (ConfigException iae) {        }}
ef951c1ede831ba57e981bbaf2022b912d5349d3bf3a340a1105c53c9822733f
testFaultyMetricsProviderOnStart
public void testFaultyMetricsProviderOnStart() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStart.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider cannot boot");    } catch (IOException iae) {        }}
1691628a49dece2ce9f3ff290ca6b8c1578aa105911cc3b9d7b585049fcd6cce
testFaultyMetricsProviderOnConfigure
public void testFaultyMetricsProviderOnConfigure() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInConfigure.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is cannot boot");    } catch (IOException iae) {        }}
eafb29cd884aeba064b734e14bdbc55359044f7b75fa63f6d3cda7c823bb4f5b
testFaultyMetricsProviderOnStop
public void testFaultyMetricsProviderOnStop() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithErrorInStop.stopCalled.set(false);    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStop.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue(MetricsProviderWithErrorInStop.stopCalled.get());}
44a9b9a7e14fe6e6233dd78123702a78303123a88f015018d97c933b3fca752e
testMetricsProviderConfiguration
public void testMetricsProviderConfiguration() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithConfiguration.httpPort.set(0);    final String configs = "metricsProvider.className=" + MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertEquals(1234, MetricsProviderWithConfiguration.httpPort.get());}
9b827bb2bbffe2046a98daf589477775ded5ca47f7e02f949cd41590c3e24a7b
testMetricsProviderLifecycle
public void testMetricsProviderLifecycle() throws Exception
{    ClientBase.setupTestEnv();    MetricsProviderCapturingLifecycle.reset();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderCapturingLifecycle.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
5b46fa3221eecb9250f8e6206104957c5a2b16244056310f7312a9218f89bed5
testWithOnlyMinSessionTimeout
public void testWithOnlyMinSessionTimeout() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    int maxSessionTimeout = 20 * tickTime;    final String configs = "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
043572f7a083f155dc4ba1bb33b49f96644338f1369d13cc45eaaa167cb65dab
testMinMaxSessionTimeOut
public void testMinMaxSessionTimeOut() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    final int maxSessionTimeout = 20 * tickTime + 1000;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
2200b108ce713dffb7afa2b17efc6774dcc9bc216936fd561723436315e59007
verifySessionTimeOut
private void verifySessionTimeOut(int sessionTimeout, int expectedSessionTimeout, String HOSTPORT) throws IOException, KeeperException, InterruptedException
{    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper(HOSTPORT, sessionTimeout, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(sessionTimeout, TimeUnit.MILLISECONDS));    assertEquals("Not able to configure the sessionTimeout values", expectedSessionTimeout, zk.getSessionTimeout());    zk.close();}
04f2ce203d55fad1778a69ee07a1349d70cf1663dced1473406e7ddd2cba9a1d
testJMXRegistrationWithNIO
public void testJMXRegistrationWithNIO() throws Exception
{    ClientBase.setupTestEnv();    File tmpDir_1 = ClientBase.createTmpDir();    ServerCnxnFactory server_1 = startServer(tmpDir_1);    File tmpDir_2 = ClientBase.createTmpDir();    ServerCnxnFactory server_2 = startServer(tmpDir_2);    server_1.shutdown();    server_2.shutdown();    deleteFile(tmpDir_1);    deleteFile(tmpDir_2);}
6b0393659c309ad2c134271e16672004d60a188cf0015cf14b60f8cdd8dec023
testJMXRegistrationWithNetty
public void testJMXRegistrationWithNetty() throws Exception
{    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    try {        ClientBase.setupTestEnv();        File tmpDir_1 = ClientBase.createTmpDir();        ServerCnxnFactory server_1 = startServer(tmpDir_1);        File tmpDir_2 = ClientBase.createTmpDir();        ServerCnxnFactory server_2 = startServer(tmpDir_2);        server_1.shutdown();        server_2.shutdown();        deleteFile(tmpDir_1);        deleteFile(tmpDir_2);    } finally {                if (originalServerCnxnFactory == null || originalServerCnxnFactory.isEmpty()) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);        } else {            System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);        }    }}
4c8f7406234b8f49bbd876babed49c0fe4f9c8d6b8a15d0e42ee352872b45c56
deleteFile
private void deleteFile(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            deleteFile(c);        }    }    if (!f.delete()) {        if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
2b349b07aefc6d209d98097f7962fc8b594dd78fea7e7c840118fc0a8dcaffd1
startServer
private ServerCnxnFactory startServer(File tmpDir) throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertNotNull("JMX initialization failed!", zks.jmxServerBean);    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    return f;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{            startupDelayLatch.countDown();    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }    if (zks.getZKDatabase() != null) {        zks.getZKDatabase().close();    }    ClientBase.recursiveDelete(tmpDir);}
4811b0656b68298866ef79556516e0bcbda6a4893abc673e1993a79b31d73eb5
testClientConnectionRequestDuringStartupWithNIOServerCnxn
public void testClientConnectionRequestDuringStartupWithNIOServerCnxn() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    startSimpleZKServer(startupDelayLatch);    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;    assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);    assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));    LOG.info("Decrements the count of the latch, so that server will proceed with startup");    startupDelayLatch.countDown();    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zkClient.close();}
89e4edc4deff832c061062150430f91c2b0ee88e5877321ba417c4684d797e5f
testClientConnectionRequestDuringStartupWithNettyServerCnxn
public void testClientConnectionRequestDuringStartupWithNettyServerCnxn() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    try {        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());        startSimpleZKServer(startupDelayLatch);        SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;        assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);        assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));        LOG.info("Decrements the count of the latch, so that server will proceed with startup");        startupDelayLatch.countDown();        assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        zkClient.close();    } finally {                if (originalServerCnxnFactory == null) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);            return;        }        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);    }}
0210c2ff6004c3d94ed295c37a428761f5cb1aee3d96337897c27d67b73ec9be
testFourLetterWords
public void testFourLetterWords() throws Exception
{    startSimpleZKServer(startupDelayLatch);    verify("conf", ZK_NOT_SERVING);    verify("crst", ZK_NOT_SERVING);    verify("cons", ZK_NOT_SERVING);    verify("dirs", ZK_NOT_SERVING);    verify("dump", ZK_NOT_SERVING);    verify("mntr", ZK_NOT_SERVING);    verify("stat", ZK_NOT_SERVING);    verify("srst", ZK_NOT_SERVING);    verify("wchp", ZK_NOT_SERVING);    verify("wchc", ZK_NOT_SERVING);    verify("wchs", ZK_NOT_SERVING);    verify("isro", "null");}
21766e24fcb24270fae79108cde29a773e57a417a91be0e809d44e5dc739cf25
verify
private void verify(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);    LOG.info("cmd " + cmd + " expected " + expected + " got " + resp);    assertTrue("Unexpected response", resp.contains(expected));}
fd986a12962576bf19f16f5d5ddbf757d9e1026d5413571a0d08a552cd1a5cc7
sendRequest
private String sendRequest(String cmd) throws IOException, SSLContextException
{    return send4LetterWord(HOST, PORT, cmd);}
1d4aa3b672ead2d73134bf0fa1ff93e486a35d293b1c731370c052f4bf965fc5
startSimpleZKServer
private void startSimpleZKServer(CountDownLatch startupDelayLatch) throws IOException
{    zks = new SimpleZooKeeperServer(tmpDir, tmpDir, 3000, startupDelayLatch);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    Thread startupThread = new Thread() {        public void run() {            try {                servcnxnf.startup(zks);            } catch (IOException e) {                LOG.error("Unexcepted exception during server startup", e);                                    } catch (InterruptedException e) {                LOG.error("Unexcepted exception during server startup", e);                                    }        }    };    LOG.info("Starting zk server {}", HOSTPORT);    startupThread.start();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        servcnxnf.startup(zks);    } catch (IOException e) {        LOG.error("Unexcepted exception during server startup", e);            } catch (InterruptedException e) {        LOG.error("Unexcepted exception during server startup", e);            }}
da36f3b9d36ac447eb82095d5bedab6921b56e31fcb45bf35d22208f35f9d226
startup
public synchronized void startup()
{    try {        startupInvokedLatch.countDown();                                                        startupDelayLatch.await();    } catch (InterruptedException e) {        fail("Unexpected InterruptedException while startinng up!");    }    super.startup();}
1e439d9803aa4412bcfb6e3c1ea47ae1fa0edc42a0916432a74e585c0af1dc30
createSession
 long createSession(ServerCnxn cnxn, byte[] passwd, int timeout)
{    createSessionInvokedLatch.countDown();    return super.createSession(cnxn, passwd, timeout);}
59f1e2e6ac2e10ada2d0d6b6cc8a970849a3f8266a7ca6d2face910fa2d65071
waitForStartupInvocation
 boolean waitForStartupInvocation(long timeout) throws InterruptedException
{    return startupInvokedLatch.await(timeout, TimeUnit.SECONDS);}
5d4b0979171802eb759767da22316fe6dd07a599cee2c60574c38eaf08f08c19
waitForSessionCreation
 boolean waitForSessionCreation(long timeout) throws InterruptedException
{    return createSessionInvokedLatch.await(timeout, TimeUnit.SECONDS);}
b7e4794011c1e9cc7ae121cf583cc14f19170d9af0c323628d5adb910b68c947
testSortDataDirAscending
public void testSortDataDirAscending()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", true);    assertEquals(orig[2], filelist.get(0));    assertEquals(orig[3], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[1], filelist.get(3));    assertEquals(orig[4], filelist.get(4));}
945e3f3f9f83ea27aa2664d4486a2f133d57274b6b8f4dff7173d064e780d8f3
testSortDataDirDescending
public void testSortDataDirDescending()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", false);    assertEquals(orig[4], filelist.get(0));    assertEquals(orig[1], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[3], filelist.get(3));    assertEquals(orig[2], filelist.get(4));}
1da86c625a6d64deb5287003e7aec05fc4195e77a440167be8db04162e96df07
testGetLogFiles
public void testGetLogFiles()
{    File[] files = new File[5];    files[0] = new File("log.10027c6de");    files[1] = new File("log.10027c6df");    files[2] = new File("snapshot.10027c6dd");    files[3] = new File("log.10027c6dc");    files[4] = new File("log.20027c6dc");    File[] orig = files.clone();    File[] filelist = FileTxnLog.getLogFiles(files, Long.parseLong("10027c6de", 16));    assertEquals(3, filelist.length);    assertEquals(orig[0], filelist[0]);    assertEquals(orig[1], filelist[1]);    assertEquals(orig[4], filelist[2]);}
7a22e810f424bf6d379634bb67ef93b80aac0f8f82794457b894abf93285e0c1
testForceSyncDefaultEnabled
public void testForceSyncDefaultEnabled()
{    File file = new File("foo.10027c6de");    FileTxnLog log = new FileTxnLog(file);    assertTrue(log.isForceSync());}
ffa410c5754570b355fb34a5a6db8a1b54d099a89428b978ac5d514e0bec0936
testForceSyncDefaultDisabled
public void testForceSyncDefaultDisabled()
{    try {        File file = new File("foo.10027c6de");        System.setProperty("zookeeper.forceSync", "no");        FileTxnLog log = new FileTxnLog(file);        assertFalse(log.isForceSync());    } finally {                System.setProperty("zookeeper.forceSync", "yes");    }}
76fb1c86c49d6ecacafdb444a51454d598d4ad498dac37770b5c8d6ee3e98da3
testInvalidSnapshot
public void testInvalidSnapshot()
{    File f = null;    File tmpFileDir = null;    try {        tmpFileDir = ClientBase.createTmpDir();        f = new File(tmpFileDir, "snapshot.0");        if (!f.exists()) {            f.createNewFile();        }        assertFalse("Snapshot file size is greater than 9 bytes", SnapStream.isValidSnapshot(f));        assertTrue("Can't delete file", f.delete());    } catch (IOException e) {    } finally {        if (null != tmpFileDir) {            ClientBase.recursiveDelete(tmpFileDir);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    throw new Error();}
8477e27bf2041a51b5bf41aca4a9fdcab86719dd3dad230f1581d2bda0e4b693
handleException
protected void handleException(String thName, Throwable e)
{    runningLatch.countDown();}
47dfe60a6d6e257fb163ff2f92f9774287c21c2f50032840c53a7072a6df0a3d
notifyStopping
public void notifyStopping(String threadName, int erroCode)
{}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    throw new Error();}
8477e27bf2041a51b5bf41aca4a9fdcab86719dd3dad230f1581d2bda0e4b693
handleException
protected void handleException(String thName, Throwable e)
{    runningLatch.countDown();}
962919b40a340caec66c5334b9747f962a2cb137aca15fc96c58cae6ac5a900f
testUncaughtException
public void testUncaughtException() throws Exception
{    MyThread t1 = new MyThread("Test-Thread");    t1.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));    runningLatch = new CountDownLatch(1);    MyCriticalThread t2 = new MyCriticalThread("Test-Critical-Thread");    t2.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));}
31d90dbeb567e1b3d7e5e8e24775668fe3e8f0dde9d48fa33c07b60bb1d60b25
getClient
private ZooKeeper getClient(int idx)
{    return zkClients[idx - 1];}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty("zookeeper.admin.enableServer", "false");            SyncRequestProcessor.setSnapCount(7);    qu = new QuorumUtil(1);    startAll();    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i] = new CountdownWatcher();        PeerStruct peer = qu.getPeer(i + 1);        zkClients[i] = new ZooKeeper("127.0.0.1:" + peer.clientPort, ClientTest.CONNECTION_TIMEOUT, zkClientWatchers[i]);    }    waitForClientsConnected();}
b0a36f4dc33d53995b750189a1ff0b1fa83238338f7b1ec0a73da6091a7bd31c
waitForClientsConnected
private void waitForClientsConnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i].waitForConnected(ClientTest.CONNECTION_TIMEOUT);        zkClientWatchers[i].reset();    }}
5d61bc9fd32dc6df3daf5bf0b20e5daac94de29ea44cbb8b3e6b389766277787
checkClientsConnected
private void checkClientsConnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientConnected(i + 1);    }}
5a045506b2dd6cc7755d3139452b0cc5cc81c6845455fe2f492d7121c6902c0b
checkClientConnected
private void checkClientConnected(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-connected", false));    } catch (ConnectionLossException e) {                                                                        PeerStruct peer = qu.getPeer(idx);        assertTrue("Waiting for server down", ClientBase.waitForServerUp("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        assertNull(zk.exists("/foofoofoo-connected", false));    }}
f4bdd497bde2afdde2500e3e2c19ddef9671bcc6398e0d2ed582c5f0c0a3c911
checkClientsDisconnected
private void checkClientsDisconnected() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientDisconnected(i + 1);    }}
70942fb9761cbf9f33625587da4afd0571d1bc17c0f866eb3e591aa3802d7483
checkClientDisconnected
private void checkClientDisconnected(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-disconnected", false));        fail("expected client to be disconnected");    } catch (KeeperException e) {        }}
ca7ab878a126bc59cde9b559cc8707fac8545c99ec2b944dbe1187014a55de28
startAll
private void startAll() throws Exception
{    qu.startAll();    checkLeader();        checkClientsConnected();}
1ed1aa4781434d0bc022dfdb2d403b860a611a186406692e2b8fe66f64bb6cd9
start
private void start(int idx) throws Exception
{    qu.start(idx);    for (String hp : qu.getConnString().split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientTest.CONNECTION_TIMEOUT));    }    checkLeader();        checkClientsConnected();}
39038c4ffa2f49adcd934d2449f6882616eced76ab4f284be197264490a6196d
checkLeader
private void checkLeader()
{    idxLeader = 1;    while (qu.getPeer(idxLeader).peer.leader == null) {        idxLeader++;    }    idxFollower = (idxLeader == 1 ? 2 : 1);    zksLeader = qu.getPeer(idxLeader).peer.getActiveServer();}
2d81d6018b22a529cf7568291c2a698c5544558400cff3555887b4ec62f613c8
shutdownAll
private void shutdownAll() throws Exception
{    qu.shutdownAll();        checkClientsDisconnected();}
b79521709a19c33da8c5eb052028f0bdf70591bf3f6c5beaeffb3292ae307a20
shutdown
private void shutdown(int idx) throws Exception
{    qu.shutdown(idx);        PeerStruct peer = qu.getPeer(idx);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        if (idx == idxLeader) {        checkClientDisconnected(idx);        try {            checkClientsDisconnected();        } catch (AssertionError e) {                        }    } else {        checkClientDisconnected(idx);    }}
f574e96c39ec3fcb5d91fbf0ca64c449e9e319f9ce967e05450aad07cd901118
adjustEpochNearEnd
private void adjustEpochNearEnd()
{    zksLeader.setZxid((zksLeader.getZxid() & 0xffffffff00000000L) | 0xfffffffcL);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("tearDown starting");    for (int i = 0; i < zkClients.length; i++) {        zkClients[i].close();    }    qu.shutdownAll();}
11354e563f89c6a990fe57dbf18de006c5f45af2d51814a4db27c6d8f1555189
createNodes
private int createNodes(ZooKeeper zk, int start, int count) throws Exception
{    LOG.info("Creating nodes {} thru {}", start, (start + count));    int j = 0;    try {        for (int i = start; i < start + count; i++) {            zk.create("/foo" + i, new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.EPHEMERAL);            j++;        }    } catch (ConnectionLossException e) {                waitForClientsConnected();    }    return j;}
a4945cfa0b68ae26e662fc283aeb82de94a6a3172795deb745c7a2a1147366e1
checkNodes
private void checkNodes(ZooKeeper zk, int start, int count) throws Exception
{    LOG.info("Validating nodes {} thru {}", start, (start + count));    for (int i = start; i < start + count; i++) {        assertNotNull(zk.exists("/foo" + i, false));        LOG.error("Exists zxid:{}", Long.toHexString(zk.exists("/foo" + i, false).getCzxid()));    }    assertNull(zk.exists("/foo" + (start + count), false));}
27de3f4d2cb006c69825ec07cec7cd35edf488d13c1ca53e768cba60c9158fd5
testSimpleRolloverFollower
public void testSimpleRolloverFollower() throws Exception
{    adjustEpochNearEnd();    ZooKeeper zk = getClient((idxLeader == 1 ? 2 : 1));    int countCreated = createNodes(zk, 0, 10);    checkNodes(zk, 0, countCreated);}
84517fa498a3c040e0597b70e31ca60a159e4215fa43fd6cbd1b08087a41213d
testRolloverThenRestart
public void testRolloverThenRestart() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
14bcb20576b1f666f2785ce33f52b876a4313579edf613cb26638bbe6fd7302f
testRolloverThenFollowerRestart
public void testRolloverThenFollowerRestart() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
05cc5173b3ac94b4456a0c8998e2bc8a9b36c7456c4a87b751885ba3b7ac7a7e
testRolloverThenLeaderRestart
public void testRolloverThenLeaderRestart() throws Exception
{    ZooKeeper zk = getClient(idxLeader);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 50);}
481696df00f77a56f9381861c713386d7d331ce3f3b4f42a9e67ecda3bedf800
testMultipleRollover
public void testMultipleRollover() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 70);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    serverConfig = new ServerConfig();}
6d6244aa40bffb1af44acfd14222f27915c210760fe4330bb1c00c5920c2183a
testFewArguments
public void testFewArguments()
{    String[] args = { "2181" };    serverConfig.parse(args);}
a1bca09f2d9fb1e2a5af599554c536136467ebf28b29487416116a7dc4b88ba8
testValidArguments
public void testValidArguments()
{    String[] args = { "2181", "/data/dir", "60000", "10000" };    serverConfig.parse(args);    assertEquals(2181, serverConfig.getClientPortAddress().getPort());    assertTrue(checkEquality("/data/dir", serverConfig.getDataDir()));    assertEquals(60000, serverConfig.getTickTime());    assertEquals(10000, serverConfig.getMaxClientCnxns());}
bafc3bd89d65fc05aa59e1de27247d13fafe58632130e86bd3cddf887dabf8e9
testTooManyArguments
public void testTooManyArguments()
{    String[] args = { "2181", "/data/dir", "60000", "10000", "9999" };    serverConfig.parse(args);}
a38f2d4187debf632e20b8c2fef55d5121a12636b4e372f51c34c415b94ef777
testJvmPauseMonitorConfigured
public void testJvmPauseMonitorConfigured()
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.isJvmPauseMonitorToRun()).thenReturn(true);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    serverConfig.readFrom(qpConfig);    assertEquals(sleepTime, Long.valueOf(serverConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(serverConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(serverConfig.getJvmPauseInfoThresholdMs()));    assertTrue(serverConfig.isJvmPauseMonitorToRun());}
d270c27f8f4f9e7d1ee4eac4601bfbc0d0b498738b5486de30193583f97e5531
checkEquality
 boolean checkEquality(String a, String b)
{    assertNotNull(a);    assertNotNull(b);    return a.equals(b);}
c5d9f6b37ba6846a01b0322e13bb0ba5df9f9a2c1455a106c7deb441b45d4b26
checkEquality
 boolean checkEquality(String a, File b)
{    assertNotNull(a);    assertNotNull(b);    return new File(a).equals(b);}
51dfbaae3e937a9debc1e8ea5d66ca90635ecd6dfe30ba4f32762b0b0fce3912
testAclCount
public void testAclCount() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    final ArrayList<ACL> CREATOR_ALL_AND_WORLD_READABLE = new ArrayList<ACL>() {        {            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));        }    };    try {        LOG.info("starting up the zookeeper server .. waiting");        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        String path = "/path";        try {            assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());        } catch (Exception e) {            LOG.error("Something is fundamentally wrong with ArrayList's add() method. add()ing four times to an empty ArrayList should result in an ArrayList with 4 members.");            throw e;        }        zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL("/path", new Stat());        assertEquals(2, acls.size());    } catch (Exception e) {                assertTrue(false);    }    f.shutdown();    zks.shutdown();}
299f3e31d5e15d7545e1b39c5203f9311492e7a80228c7b4aea8af7b22b12de5
testRootAcl
public void testRootAcl() throws Exception
{    ZooKeeper zk = createClient();    try {                zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getData("/", false, null);        zk.close();                zk = createClient();        try {            zk.getData("/", false, null);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.addAuthInfo("digest", "world:anyone".getBytes());        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.getData("/", false, null);        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.delete("/apps", -1);                zk.setACL("/", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/", false, null);        zk.create("/apps", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.delete("/apps", -1);        zk.addAuthInfo("digest", "world:anyone".getBytes());        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.delete("/apps", -1);    } finally {        zk.close();    }}
013e2b77bb9cd3fd3d08cbb19e48998f339d8c975b5742e58eed094803aff5fd
testIPAuthenticationIsValidCIDR
public void testIPAuthenticationIsValidCIDR() throws Exception
{    IPAuthenticationProvider prov = new IPAuthenticationProvider();    assertTrue("testing no netmask", prov.isValid("127.0.0.1"));    assertTrue("testing single ip netmask", prov.isValid("127.0.0.1/32"));    assertTrue("testing lowest netmask possible", prov.isValid("127.0.0.1/0"));    assertFalse("testing netmask too high", prov.isValid("127.0.0.1/33"));    assertFalse("testing netmask too low", prov.isValid("10.0.0.1/-1"));}
3a2f63e78309fe08a02461a3a6a4714cbcd33ea6d662d341a63ffaf662ecc083
testNettyIpAuthDefault
public void testNettyIpAuthDefault() throws Exception
{    String HOSTPORT = "127.0.0.1:" + PortAssignment.unique();    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    ClientBase.setupTestEnv();    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {        LOG.info("starting up the zookeeper server .. waiting");        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ClientBase.createZKClient(HOSTPORT);        for (ServerCnxn cnxn : f.getConnections()) {            boolean foundID = false;            for (Id id : cnxn.getAuthInfo()) {                if (id.getScheme().equals("ip")) {                    foundID = true;                    break;                }            }            assertTrue(foundID);        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    }}
f66be66d4eab8211dc3405befa0510b802a23e341441afaffa9606cf736ebd6b
testDisconnectedAddAuth
public void testDisconnectedAddAuth() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {        LOG.info("starting up the zookeeper server .. waiting");        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        try {            zk.addAuthInfo("digest", "pat:test".getBytes());            zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        } finally {            zk.close();        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
70b5481290efb41ed17fafe1353f8bf14dad1d920f27fa665f47c109f1c134f9
testAcls
public void testAcls() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    String path;    try {        LOG.info("starting up the zookeeper server .. waiting");        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        LOG.info("starting creating acls");        for (int i = 0; i < 100; i++) {            path = "/" + i;            zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        int size = zks.getZKDatabase().getAclSize();        assertTrue("size of the acl map ", (2 == zks.getZKDatabase().getAclSize()));        for (int j = 100; j < 200; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            List<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("size of the acl map ", (102 == zks.getZKDatabase().getAclSize()));    } finally {                f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        assertTrue("acl map ", (102 == zks.getZKDatabase().getAclSize()));        for (int j = 200; j < 205; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            ArrayList<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("acl map ", (107 == zks.getZKDatabase().getAclSize()));        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.info("Event:" + event.getState() + " " + event.getType() + " " + event.getPath());    if (event.getState() == KeeperState.SyncConnected) {        if (startSignal != null && startSignal.getCount() > 0) {            LOG.info("startsignal.countDown()");            startSignal.countDown();        } else {            LOG.warn("startsignal " + startSignal);        }    }}
e3c8163922c08db87924f097cecd0a0ef859bdfe23540c1d36227158b6b28ad2
testNullACL
public void testNullACL() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", null, 0);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
ef00e07603dc35c95aeb1c9dcb3ee2850059c4eacfa979abc9da801ea82afcce
testNullValueACL
public void testNullValueACL() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        List<ACL> acls = new ArrayList<ACL>();        acls.add(null);                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", acls, -1);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
1df0b8e5c24b1c2afbef8e71482e6f2ed9439c3b6ee5df1395ae03c08db166ab
setUp
public void setUp(boolean withObservers) throws Exception
{    qb.setUp(withObservers);}
3d38343bceaef67af5cde5300f7d2b13d5e42eca377fd4b47adb549c73465139
restart
protected void restart() throws Exception
{    LOG.info("RESTARTING " + getTestName());    qb.tearDown();        JMXEnv.setUp();    qb.startServers();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("Test clients shutting down");    qb.tearDown();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        CountdownWatcher watcher = new CountdownWatcher();        zk = new TestableZooKeeper(qb.hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        while (bang) {                        incOutstanding();            zk.create("/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, this, null);        }    } catch (InterruptedException e) {        if (bang) {                        LOG.error("sanity check failed!!!");            return;        }    } catch (Exception e) {        LOG.error("Client create operation failed", e);        return;    } finally {        if (zk != null) {            try {                if (!zk.close(CONNECTION_TIMEOUT)) {                    failed = true;                    LOG.error("Client did not shutdown");                }            } catch (InterruptedException e) {                LOG.info("Interrupted", e);            }        }    }}
3dd8d3a8cf054fa70e13f26f2a05a74aeefa16c535fbb77f7b940b42a781a7ab
incOutstanding
private synchronized void incOutstanding() throws InterruptedException
{    outstanding++;    while (outstanding > MAX_OUTSTANDING) {        wait();    }}
60d5f4683d61655333db86b5b4eafdf4fd37e0fd7413742339a3dc0512fe897d
decOutstanding
private synchronized void decOutstanding()
{    outstanding--;    assertTrue("outstanding >= 0", outstanding >= 0);    notifyAll();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;            LOG.error("Create failed for 0x" + Long.toHexString(zk.getSessionId()) + "with rc:" + rc + " path:" + path);        }        decOutstanding();        return;    }    try {        decOutstanding();        zk.delete(name, -1, this, null);    } catch (Exception e) {        if (bang) {            failed = true;            LOG.error("Client delete failed", e);        }    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;            LOG.error("Delete failed for 0x" + Long.toHexString(zk.getSessionId()) + "with rc:" + rc + " path:" + path);        }    }}
c9126d11aecc0abc42e64afa0c1ac3a9b7494f41d80768a56a86cde8d8eaa07f
testHammer
public void testHammer() throws Exception
{    setUp(false);    bang = true;    LOG.info("Starting hammers");    HammerThread[] hammers = new HammerThread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }    LOG.info("Started hammers");        Thread.sleep(5000);    bang = false;    LOG.info("Stopping hammers");    for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);        assertFalse(hammers[i].failed);    }        LOG.info("Hammers stopped, verifying consistency");    qb.verifyRootOfAllServersMatch(qb.hostPort);    restart();        LOG.info("Verifying hammers 2");    qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
3bc3d3654c354c850070e7b66252f179ce0e7cfbe598d16bfe1a7ec553ccfdf1
testObserversHammer
public void testObserversHammer() throws Exception
{    setUp(true);    bang = true;    Thread[] hammers = new Thread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }        Thread.sleep(5000);    bang = false;    for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);    }        qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
c04170bc4059ff36c18a992fdd75bd10452cc1961c55a6027b2269fac910143d
setRC
public void setRC(Code rc)
{    this.rc = rc;}
de663c4293dc7b4649bc9588c013d3f165ef1bdb800ee63172ba8730f7b71d91
setPath
public void setPath(String path)
{    this.path = path;}
7ac4c3a00188e1a62120362d141848bad2977f6dc75b58feb55789f8ede5c5bd
processResult
public void processResult(Code rc, String path, Object ctx)
{    this.rc = rc;    this.path = path;    this.expected = (String) ctx;    latch.countDown();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return rc + ":" + path + ":";}
18f7f935ec02442db766cbbe197206129564c5f4c3714e5265c09a7f6b33de93
verify
protected void verify()
{    try {        latch.await(defaultTimeoutMillis, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }        assertSame(0L, latch.getCount());    String actual = toString();    assertEquals(expected, actual);}
de663c4293dc7b4649bc9588c013d3f165ef1bdb800ee63172ba8730f7b71d91
setPath
public void setPath(String path)
{    super.setPath(path);    this.name = path;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return path.substring(path.lastIndexOf('/') + 1);}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    this.name = name;    super.processResult(Code.get(rc), path, ctx);}
e11c3c828d341c401463dc419059b6e0d6882f8c7da1dc8d5b1a8ea0d482041f
create
public AsyncCB create()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
3b7f878508f6bf69e1e1c0c52b6e7d7857dc6f956e2654aae1970930d934e774
createEphemeral
public AsyncCB createEphemeral()
{    zk.create(path, data, acl, CreateMode.EPHEMERAL, this, toString());    return this;}
aab98835a5ae4fec2ee1dd72014e1b5ce6b940561d34a88204ddbc79868bff81
verifyCreate
public void verifyCreate()
{    create();    verify();}
e0c5735a0b93527b8b093779696d18a90a88719a812cb09422df206e6cc7a8aa
verifyCreateEphemeral
public void verifyCreateEphemeral()
{    createEphemeral();    verify();}
68fbc5c1951ab5ce3141968e92db12251dcfe1cba0d3d6cb184a0eb9010b4c1a
verifyCreateFailure_NodeExists
public void verifyCreateFailure_NodeExists()
{    new StringCB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
088feee80886c00b575c6c5badc1612252a2a8d4d2df0e2ef88ea55f4666bdfe
verifyCreateFailure_NoNode
public void verifyCreateFailure_NoNode()
{    rc = Code.NONODE;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
b7c9014f37a6e716d21b1b1c8ddbda07f7f25e792a0be115018676123e315987
verifyCreateFailure_NoChildForEphemeral
public void verifyCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + name;}
27073a7a1f5835008d568700878dde38b58464d03c0db9bcb437594a85c5af85
processResult
public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    this.acl = acl;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
af8c12fb6af56e9c33611e2a22922a767032c98528509b0015d8d1ed1b5496b6
verifyGetACL
public void verifyGetACL()
{    new StringCB(zk).verifyCreate();    zk.getACL(path, stat, this, toString());    verify();}
8f3c5de44065d19b86d4600062bb3f474add9f30b3b3c7c4be72bb7d6482dc0a
verifyGetACLFailure_NoNode
public void verifyGetACLFailure_NoNode()
{    rc = Code.NONODE;    stat = null;    acl = null;    zk.getACL(path, stat, this, toString());    verify();}
d747d9270a1f06488005a841f61ea4045a60924f47e4fe47988192da7e0a0127
toString
public String toString(List<ACL> acls)
{    if (acls == null) {        return "";    }    StringBuilder result = new StringBuilder();    for (ACL acl : acls) {        result.append(acl.getPerms()).append("::");    }    return result.toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + toString(acl) + ":" + ":" + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
cac92b0fb5d66d21de711286665096128f53536b61b7812df3b744288e72f8f6
processResult
public void processResult(int rc, String path, Object ctx, List<String> children)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
d5b45fdcc5358cfa4c4a424fca3acfe69fc0bb1ea7ed47ddf1ef1354668a901e
createNode
public StringCB createNode()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
c14cfc6632163e229f7e7645575a463a122b93209bfb3915ea6e943ae76f28b1
createNode
public StringCB createNode(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
2ef6022de5903e76ed9a3d32901ea2978f6b26c77a4d7842278ce82c681eb998
createNode
public StringCB createNode(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
483a09c071d5f75c1f45fba6ce8681c0b3963b4494b2d2881ed9c1ed38377c39
verifyGetChildrenEmpty
public void verifyGetChildrenEmpty()
{    StringCB parent = createNode();    path = parent.path;    verify();}
e39ecdb3e15cbf7d392f3c2f2c4e60a871aec85b2840f3ae08813fa295a28480
verifyGetChildrenSingle
public void verifyGetChildrenSingle()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
e33213cd2250dc29caaaf256641baebe6e652dcb0ce857b1ebc2bdfe69cb0b8c
verifyGetChildrenTwo
public void verifyGetChildrenTwo()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
c6bddcef8609953d393bf78a46a9bbf63317d12314fb98b84f4d94ca5800c7cb
verifyGetChildrenFailure_NoNode
public void verifyGetChildrenFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    verify();}
4b54c907b385b8dea0ebb8a81cdcdfc1fd1abcaf577588e6151c92ce03e954ef
verify
public void verify()
{    zk.getChildren(path, false, this, toString());    super.verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + children.toString();}
26a1e47e79f0560cc9d3e572e4a3a7d137ac4dd55fe236182253f5aa5bd7b897
processResult
public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
d5b45fdcc5358cfa4c4a424fca3acfe69fc0bb1ea7ed47ddf1ef1354668a901e
createNode
public StringCB createNode()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
c14cfc6632163e229f7e7645575a463a122b93209bfb3915ea6e943ae76f28b1
createNode
public StringCB createNode(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
2ef6022de5903e76ed9a3d32901ea2978f6b26c77a4d7842278ce82c681eb998
createNode
public StringCB createNode(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
483a09c071d5f75c1f45fba6ce8681c0b3963b4494b2d2881ed9c1ed38377c39
verifyGetChildrenEmpty
public void verifyGetChildrenEmpty()
{    StringCB parent = createNode();    path = parent.path;    verify();}
e39ecdb3e15cbf7d392f3c2f2c4e60a871aec85b2840f3ae08813fa295a28480
verifyGetChildrenSingle
public void verifyGetChildrenSingle()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
e33213cd2250dc29caaaf256641baebe6e652dcb0ce857b1ebc2bdfe69cb0b8c
verifyGetChildrenTwo
public void verifyGetChildrenTwo()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
c6bddcef8609953d393bf78a46a9bbf63317d12314fb98b84f4d94ca5800c7cb
verifyGetChildrenFailure_NoNode
public void verifyGetChildrenFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    verify();}
4b54c907b385b8dea0ebb8a81cdcdfc1fd1abcaf577588e6151c92ce03e954ef
verify
public void verify()
{    zk.getChildren(path, false, this, toString());    super.verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + children.toString();}
de663c4293dc7b4649bc9588c013d3f165ef1bdb800ee63172ba8730f7b71d91
setPath
public void setPath(String path)
{    super.setPath(path);    this.name = path;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return path.substring(path.lastIndexOf('/') + 1);}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    this.name = name;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
e11c3c828d341c401463dc419059b6e0d6882f8c7da1dc8d5b1a8ea0d482041f
create
public AsyncCB create()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
aab98835a5ae4fec2ee1dd72014e1b5ce6b940561d34a88204ddbc79868bff81
verifyCreate
public void verifyCreate()
{    create();    verify();}
68fbc5c1951ab5ce3141968e92db12251dcfe1cba0d3d6cb184a0eb9010b4c1a
verifyCreateFailure_NodeExists
public void verifyCreateFailure_NodeExists()
{    new Create2CB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    stat = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
088feee80886c00b575c6c5badc1612252a2a8d4d2df0e2ef88ea55f4666bdfe
verifyCreateFailure_NoNode
public void verifyCreateFailure_NoNode()
{    rc = Code.NONODE;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
b7c9014f37a6e716d21b1b1c8ddbda07f7f25e792a0be115018676123e315987
verifyCreateFailure_NoChildForEphemeral
public void verifyCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + name + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    this.data = data;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
bec29e1abf70ec77da6a2c877b0a7e8967178c853f68984ecb5ebf4e5a4d8ba5
verifyGetData
public void verifyGetData()
{    new StringCB(zk).verifyCreate();    zk.getData(path, false, this, toString());    verify();}
083fcf4e7993db79916825ebec9d2d92300e0a196fd7b86ba525ab3790eb4b61
verifyGetDataFailure_NoNode
public void verifyGetDataFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    data = null;    stat = null;    zk.getData(path, false, this, toString());    verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + ":" + (data == null ? "null" : new String(data)) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
a6b8b47abff87c96d6d230cc2eaa8ac4307863db9b188d04cbf9438f2ad8700e
verifySetACL
public void verifySetACL()
{    stat.setAversion(1);    new StringCB(zk).verifyCreate();    zk.setACL(path, acl, version, this, toString());    verify();}
eb1fcee2ea885bc4311685177796999de890484d9b2bee1a51fe7386c4774294
verifySetACLFailure_NoNode
public void verifySetACLFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setACL(path, acl, version, this, toString());    verify();}
d8e7d69f6b67811170268ca2e3c96b68def15250a27926d1f4b5b8464a982f07
verifySetACLFailure_BadVersion
public void verifySetACLFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setACL(path, acl, version + 1, this, toString());    verify();}
1ea5576cc582cd0642f55f30ec367c891ea8198fec043b32384af90b45c2694b
setData
public void setData()
{    zk.setData(path, data, version, this, toString());}
1dcded5579b34d8e99b140ce19cb8d74b297ec18f8ef2a249d076538c88bf367
verifySetData
public void verifySetData()
{    stat.setVersion(1);    new StringCB(zk).verifyCreate();    setData();    verify();}
a0ec19e784284f290f3f059b06cb81736ce91cd9ac245f7e197398858bb68cae
verifySetDataFailure_NoNode
public void verifySetDataFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setData(path, data, version, this, toString());    verify();}
5348f8f8387e9d3d76a51f6c7268d495617ccc9f7cbe1e396e05c4b373b69bf2
verifySetDataFailure_BadVersion
public void verifySetDataFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setData(path, data, version + 1, this, toString());    verify();}
8b62e7066765eb7ca8e206607fc048ba1a030805166f38837688fbedb30a256f
verifyExists
public void verifyExists()
{    new StringCB(zk).verifyCreate();    zk.exists(path, false, this, toString());    verify();}
d617cfddb22175970e5d60ce89051bfcc6d2902e3397c873ab9be4e3299155ab
verifyExistsFailure_NoNode
public void verifyExistsFailure_NoNode()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.exists(path, false, this, toString());    verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    super.processResult(Code.get(rc), path, ctx);}
eb887f5aeee41011fe0e0d5bfd4d10129eb000c9ede7af93e10911c45b58fbc1
delete
public void delete()
{    zk.delete(path, version, this, toString());}
0b713bb7caeeb05cf254e828a5dbece6947f899c3addc71cc95d42b2f69953ef
verifyDelete
public void verifyDelete()
{    new StringCB(zk).verifyCreate();    delete();    verify();}
f3aaad0d1a41b509ec8a2d570c0034f53cd1ff0c9767a144b7bd021e5cd833ae
verifyDeleteFailure_NoNode
public void verifyDeleteFailure_NoNode()
{    rc = Code.NONODE;    zk.delete(path, version, this, toString());    verify();}
36d9709d1c1ff76bd37846f880f4b758b659814e639bae401ae92c39ed4182d8
verifyDeleteFailure_BadVersion
public void verifyDeleteFailure_BadVersion()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    zk.delete(path, version + 1, this, toString());    verify();}
248aa4ce4d2ab6a72c9d3886ecc63303efac29ea2f84237926511845cc5a8bd6
verifyDeleteFailure_NotEmpty
public void verifyDeleteFailure_NotEmpty()
{    StringCB scb = new StringCB(zk);    scb.create();    scb.setPath(path + "/bar");    scb.create();    rc = Code.NOTEMPTY;    zk.delete(path, version, this, toString());    verify();}
54847c2a6e4d541da85f6849fcd0fd5532f6691ae30cd231087f45a3fad5dbe6
sync
public void sync()
{    zk.sync(path, this, toString());}
a4ede826fdab1533319774f812011e4e86a7c74e91655e6ba3c4fa5338bf7f34
verifySync
public void verifySync()
{    sync();    verify();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return super.toString() + version;}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    this.rc = rc;    this.opResults = opResults;    latch.countDown();}
768e883f7bac9c687a758aa7658cd1442badecdb5ca5fa7f788f3b137f3ce4c9
latch_await
 void latch_await()
{    try {        latch.await(10000, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }    assertSame(0L, latch.getCount());}
46aa9133b7418a37f1b02573d0dfbfa2c2a19bf3b843eba2bc93ef97d2623c8f
verifyMulti
public void verifyMulti()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", -1));    zk.multi(ops, this, null);    latch_await();    assertEquals(this.rc, KeeperException.Code.OK.intValue());    assertTrue(this.opResults.get(0) instanceof OpResult.CreateResult);    assertTrue(this.opResults.get(1) instanceof OpResult.DeleteResult);}
16bbeea334fa7f1d627797a272167daef296e6a901b3832efb807fa0f552436f
verifyMultiFailure_AllErrorResult
public void verifyMultiFailure_AllErrorResult()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1), Op.setData("/multi", "test".getBytes(), -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(1) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(2) instanceof OpResult.ErrorResult);}
2b4a22e009fe90e6071c4b9a7c7138aa83c042d64341521bb446aafde58d97b0
verifyMultiFailure_NoSideEffect
public void verifyMultiFailure_NoSideEffect() throws KeeperException, InterruptedException
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertNull(zk.exists("/multi", false));}
2daf8629090f81dc7dc30d1e309ad8b4a0041266712509e6c03d9690a48ece76
verifyMultiSequential_NoSideEffect
public void verifyMultiSequential_NoSideEffect() throws Exception
{    StringCB scb = new StringCB(zk);    scb.verifyCreate();    String path = scb.path + "-";    String seqPath = path + "0000000002";    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(path + "0000000001", false));    List<Op> ops = Arrays.asList(Op.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.delete("/nonexist", -1));    zk.multi(ops, this, null);    latch_await();    assertNull(zk.exists(seqPath, false));    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(seqPath, false));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    LOG.info("Creating client " + getTestName());    zk = createClient();    zk.addAuthInfo("digest", "ben:passwd".getBytes());}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    zk.close();    super.tearDown();    LOG.info("Test clients shutting down");}
48efce556abc66e6d3367b9f023d5e839f9f042b0c8985864974702e9838b0f4
testAsyncCreate
public void testAsyncCreate()
{    new StringCB(zk).verifyCreate();}
cc23b06f66e589805faed835868d78415836da37dd6cc2c92a8283c3db8171ed
testAsyncCreate2
public void testAsyncCreate2()
{    new Create2CB(zk).verifyCreate();}
87f4b5499038ccbaba6a95b819b2d3174329800ced1d0ab9faac4cc54a12d599
testAsyncCreateThree
public void testAsyncCreateThree()
{    CountDownLatch latch = new CountDownLatch(3);    StringCB op1 = new StringCB(zk, latch);    op1.setPath("/op1");    StringCB op2 = new StringCB(zk, latch);    op2.setPath("/op2");    StringCB op3 = new StringCB(zk, latch);    op3.setPath("/op3");    op1.create();    op2.create();    op3.create();    op1.verify();    op2.verify();    op3.verify();}
855eaa28160704adc7e902d20c6b2ccc07766c971b08ca6379c6dcb3f12aca1f
testAsyncCreateFailure_NodeExists
public void testAsyncCreateFailure_NodeExists()
{    new StringCB(zk).verifyCreateFailure_NodeExists();}
32735cddac3c9db447172f74ad26ddae3ba32812dceb16e5aec543953734d8ed
testAsyncCreateFailure_NoNode
public void testAsyncCreateFailure_NoNode()
{    new StringCB(zk).verifyCreateFailure_NoNode();}
444217cf325ceb9cca8d4ff8f47aaa2ff76334bf911deeb9546dd7f506f2409e
testAsyncCreateFailure_NoChildForEphemeral
public void testAsyncCreateFailure_NoChildForEphemeral()
{    new StringCB(zk).verifyCreateFailure_NoChildForEphemeral();}
3857e7068c1a8c4d16d20a6ad54c9323a3746c112481279de6741e397ee7fc9d
testAsyncCreate2Failure_NodeExists
public void testAsyncCreate2Failure_NodeExists()
{    new Create2CB(zk).verifyCreateFailure_NodeExists();}
bfafcc2f7032cd9f814ae884598de7489ecb1afa4adad56e48bfb135e540db2d
testAsyncCreate2Failure_NoNode
public void testAsyncCreate2Failure_NoNode()
{    new Create2CB(zk).verifyCreateFailure_NoNode();}
4417342ad78c7b7353a7f05f7bb00f93893d2cf259b1f35be2e6eb64de759e2d
testAsyncCreate2Failure_NoChildForEphemeral
public void testAsyncCreate2Failure_NoChildForEphemeral()
{    new Create2CB(zk).verifyCreateFailure_NoChildForEphemeral();}
0fde7a5607f65583e95dfd0afdcae40178a9db37ee95cbd1de0dca7bd3ea1eea
testAsyncDelete
public void testAsyncDelete()
{    new VoidCB(zk).verifyDelete();}
0170f0a5145bb2615df85d1fc21f80039f240cd56ed7fea8d088ffbe70699bf3
testAsyncDeleteFailure_NoNode
public void testAsyncDeleteFailure_NoNode()
{    new VoidCB(zk).verifyDeleteFailure_NoNode();}
6027fb0c47d359abde96f5760e2f9de4998159de10b98d66188d2e2020427ded
testAsyncDeleteFailure_BadVersion
public void testAsyncDeleteFailure_BadVersion()
{    new VoidCB(zk).verifyDeleteFailure_BadVersion();}
d3ee361c636bfaa74019dd9ca09166126c87b5c693374dd49a5301c26ee72322
testAsyncDeleteFailure_NotEmpty
public void testAsyncDeleteFailure_NotEmpty()
{    new VoidCB(zk).verifyDeleteFailure_NotEmpty();}
c677b290a3467be9eeb3e3a687c69f227afdf6abb5d7a32bc070442ecfc516ba
testAsyncSync
public void testAsyncSync()
{    new VoidCB(zk).verifySync();}
25dd18133dec7c3c7f0448b087d5cac062a3f13cbac1aa70634fc3672a028e89
testAsyncSetACL
public void testAsyncSetACL()
{    new StatCB(zk).verifySetACL();}
dfb4c7297c9e524921c26303ab4805161677788e5216fc81030731a537793b99
testAsyncSetACLFailure_NoNode
public void testAsyncSetACLFailure_NoNode()
{    new StatCB(zk).verifySetACLFailure_NoNode();}
4158602e5dbe5dfbdb827bdd133ef646bb7eceaca28ec23250c2a148a2fa9427
testAsyncSetACLFailure_BadVersion
public void testAsyncSetACLFailure_BadVersion()
{    new StatCB(zk).verifySetACLFailure_BadVersion();}
5590f0133a4e9560e17ad298492293c02c691a7151f00c9a892435cb7d23ba32
testAsyncSetData
public void testAsyncSetData()
{    new StatCB(zk).verifySetData();}
fa7bf734ecfd0c96bdeda2330b2c6726e3e3da58fcb023b18c1d3ca74f685215
testAsyncSetDataFailure_NoNode
public void testAsyncSetDataFailure_NoNode()
{    new StatCB(zk).verifySetDataFailure_NoNode();}
a8ba23e64a9099f33ed56cbf961f225d003f0bec54bd7489ad72d5e788a5c255
testAsyncSetDataFailure_BadVersion
public void testAsyncSetDataFailure_BadVersion()
{    new StatCB(zk).verifySetDataFailure_BadVersion();}
e6143b8ca608419f516881ba4fbd8ad067ea60671a7a6672a40364b81b1a8207
testAsyncExists
public void testAsyncExists()
{    new StatCB(zk).verifyExists();}
a5708f99848a4c0384b80552afecb8522216a6356c2bd4da1dd100b524e6b451
testAsyncExistsFailure_NoNode
public void testAsyncExistsFailure_NoNode()
{    new StatCB(zk).verifyExistsFailure_NoNode();}
82d2d6fb5ec6dfba099fd18686fe96725897a1e8b3b548f1f1bf6f33d311424d
testAsyncGetACL
public void testAsyncGetACL()
{    new ACLCB(zk).verifyGetACL();}
bc5d9aab39e35d5038f712c32252182cc661f2ae5b038df9d71492f0d56b571b
testAsyncGetACLFailure_NoNode
public void testAsyncGetACLFailure_NoNode()
{    new ACLCB(zk).verifyGetACLFailure_NoNode();}
b425ab1e16d161782b4109230db9833a1656a1b379fa7b4862f457cecef392a8
testAsyncGetChildrenEmpty
public void testAsyncGetChildrenEmpty()
{    new ChildrenCB(zk).verifyGetChildrenEmpty();}
b20b09f8a8265afb9071dc82c33fc01a5c97f182b5c86028dbc9af8ae07b2b63
testAsyncGetChildrenSingle
public void testAsyncGetChildrenSingle()
{    new ChildrenCB(zk).verifyGetChildrenSingle();}
f9c271720183ce7744c45c24e52c7700ac546951edca02c273aa4044b5b4fa2e
testAsyncGetChildrenTwo
public void testAsyncGetChildrenTwo()
{    new ChildrenCB(zk).verifyGetChildrenTwo();}
075a8f36c051630d184e3096168170959276dbfe47bf805dfc52240ae1d65c63
testAsyncGetChildrenFailure_NoNode
public void testAsyncGetChildrenFailure_NoNode()
{    new ChildrenCB(zk).verifyGetChildrenFailure_NoNode();}
f225603fa1614bd597287c5e8fe2dcb7d17af3e50f766a4a2e9b057469b92225
testAsyncGetChildren2Empty
public void testAsyncGetChildren2Empty()
{    new Children2CB(zk).verifyGetChildrenEmpty();}
85b463afb7cb224b233f34ffc65b1f391f456aafb23034afc633a55978f9e47c
testAsyncGetChildren2Single
public void testAsyncGetChildren2Single()
{    new Children2CB(zk).verifyGetChildrenSingle();}
6e447e85daab61bda29e6f8027f14c620b0e3a0c7ee0670aa5fae234b3c3b5a8
testAsyncGetChildren2Two
public void testAsyncGetChildren2Two()
{    new Children2CB(zk).verifyGetChildrenTwo();}
66412b9ffc0fbbb442f6b4e5767e6027d2ed4d20c2e63229e9b5612455d2e6c0
testAsyncGetChildren2Failure_NoNode
public void testAsyncGetChildren2Failure_NoNode()
{    new Children2CB(zk).verifyGetChildrenFailure_NoNode();}
fcf0c5bbbaa8c15b626f56b9bded31cdfcc9fff8e8a9049a9f31cd286ee16929
testAsyncGetData
public void testAsyncGetData()
{    new DataCB(zk).verifyGetData();}
fbad812b228722996a6eafd3d3a459e43cecf97221b48db17fe75019d6fa8312
testAsyncGetDataFailure_NoNode
public void testAsyncGetDataFailure_NoNode()
{    new DataCB(zk).verifyGetDataFailure_NoNode();}
9411d29c0e680bd28ead772adb37e1f90ca4aa9a67eb2964db18a50cbc7d570d
testAsyncMulti
public void testAsyncMulti()
{    new MultiCB(zk).verifyMulti();}
bea3d8c5482e0600b81d70e5b6f894506dc877d829a51dfb5da78af83245a7fa
testAsyncMultiFailure_AllErrorResult
public void testAsyncMultiFailure_AllErrorResult()
{    new MultiCB(zk).verifyMultiFailure_AllErrorResult();}
1d858f6296a6c138f0fea15add2b5f1dd246365eec57572b481f2a0750427dca
testAsyncMultiFailure_NoSideEffect
public void testAsyncMultiFailure_NoSideEffect() throws Exception
{    new MultiCB(zk).verifyMultiFailure_NoSideEffect();}
43088a964a3ae3cbe1457eb06648beb2da9af1b55fe59764265eb9ce1cd5581f
testAsyncMultiSequential_NoSideEffect
public void testAsyncMultiSequential_NoSideEffect() throws Exception
{    new MultiCB(zk).verifyMultiSequential_NoSideEffect();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qb.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("Test clients shutting down");    qb.tearDown();}
a84a0536acc4b80a3c557ae8ea08918a2292d34e833a17dd7616c3f4f5778281
createClient
private ZooKeeper createClient() throws Exception
{    return createClient(qb.hostPort);}
e207be72c0a12354c7210dd39623357b6e2e1e979cda57219c183024c2a7b98e
createClient
private ZooKeeper createClient(String hp) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient(hp);    return zk;}
7e53672ae0608a7481ae8dc56f5f1ae27979a9d728e2e43788c0f1b6734de6aa
testAsync
public void testAsync() throws Exception
{    ZooKeeper zk = null;    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.create("/ben", new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT, this, results);        zk.create("/ben/2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.delete("/ben", -1, this, results);        zk.create("/ben2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.getData("/ben2", false, this, results);        synchronized (results) {            while (results.size() < 5) {                results.wait();            }        }        assertEquals(0, (int) results.get(0));        assertEquals(Code.NOAUTH, Code.get(results.get(1)));        assertEquals(0, (int) results.get(2));        assertEquals(0, (int) results.get(3));        assertEquals(0, (int) results.get(4));    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        try {            zk.getData("/ben2", false, new Stat());            fail("Should have received a permission error");        } catch (KeeperException e) {            assertEquals(Code.NOAUTH, e.code());        }    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/ben2", false, new Stat());    } finally {        zk.close();    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
6606537107a7764032a5cb457dd13a4acb882a9a87245385009132554249246b
setupTestDir
public void setupTestDir() throws IOException
{    testDir = ClientBase.createEmptyTestDir();    dstFile = new File(testDir, "test.txt");}
59a712c44981dfcfaa298e225cf9a9cafdaa47131dfa3b7ddd6ad9c59bc5c103
cleanupTestDir
public void cleanupTestDir() throws IOException
{    ClientBase.recursiveDelete(testDir);}
ef149f575be26ff95e52e7a2f305b8b81c04d3ddeec08595d92b36d399dbb9c8
testWriteNewFile
public void testWriteNewFile() throws IOException
{    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertFalse(dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();    assertFalse(dstFile.exists());    fos.close();    assertTrue(dstFile.exists());    String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
f84fa6fbbdc197663c2344aabf6dd51e2f70b62fcf0ae505292ab89d336292b2
testOverwriteFile
public void testOverwriteFile() throws IOException
{    assertTrue("Creating empty dst file", dstFile.createNewFile());    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertTrue("Empty file still exists", dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();        assertEquals("", ClientBase.readFile(dstFile));    fos.close();        String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
d0dc2c0b83432160aa05cf3d327251d05cabd1be3772d9ebbc3840994ae18b0d
testFailToFlush
public void testFailToFlush() throws IOException
{        FileOutputStream fos = new FileOutputStream(dstFile);    fos.write(TEST_STRING_2.getBytes());    fos.close();    OutputStream failingStream = createFailingStream();    failingStream.write(TEST_STRING.getBytes());    try {        failingStream.close();        fail("Close didn't throw exception");    } catch (IOException ioe) {        }        assertEquals(TEST_STRING_2, ClientBase.readFile(dstFile));    assertEquals("Temporary file should have been cleaned up", dstFile.getName(), ClientBase.join(",", testDir.list()));}
6df5e926f667ea20cb48e2d1d6c728275a6ee21a6754b66840d2ca87794dd737
createFailingStream
private OutputStream createFailingStream() throws FileNotFoundException
{    return new AtomicFileOutputStream(dstFile) {        @Override        public void flush() throws IOException {            throw new IOException("injected failure");        }    };}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    throw new IOException("injected failure");}
4c6fed6cd5e555b2cacaf5157921b6ef122e1364e8bbfc01f30f75eb1fab1324
testAbortNewFile
public void testAbortNewFile() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.abort();    assertEquals(0, testDir.list().length);}
080a3f25d36305644868580d9c5267672ce9e353542e2b5a30ba2e7726c73a8a
testAbortNewFileAfterFlush
public void testAbortNewFileAfterFlush() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.write(TEST_STRING.getBytes());    fos.flush();    fos.abort();    assertEquals(0, testDir.list().length);}
b89a80e1b34cf8fa8a55c96dc6bfe3f7a2c04c137a5128f62e35217d07ce2fa1
testAbortExistingFile
public void testAbortExistingFile() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
9503bf0f2e49c217deec38ff2edf234bb98d790293b54a662d01c08bdd65aeeb
testAbortExistingFileAfterFlush
public void testAbortExistingFileAfterFlush() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.write(TEST_STRING_2.getBytes());    fos2.flush();    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
cd4ee431c2e8dee5daa9f68cb16ee5dd1bdea27ab4fcef404480ecaa75a8cf8b
testBadAuthNotifiesWatch
public void testBadAuthNotifiesWatch() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("FOO", "BAR".getBytes());        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
30cf55ebc39cfb97d0da6c797d7097d7d0fccbfd26df5911c53c5d2758726314
testBadAuthThenSendOtherCommands
public void testBadAuthThenSendOtherCommands() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("INVALID", "BAR".getBytes());        zk.exists("/foobar", false);        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
ba3c21de3a2d46c8b9e09173b1519fc31d791cda5c3eac15da10bb987eeeb01b
testSuper
public void testSuper() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:pass2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);    } finally {        zk.close();    }}
f19f91bf0455271ce9464aaf5463facc2f02ffa0c66deced3bb36f68086f7d8e
testSuperACL
public void testSuperACL() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);        zk.setACL("/path1", Ids.READ_ACL_UNSAFE, -1);        zk.create("/path1/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setACL("/path1", Ids.OPEN_ACL_UNSAFE, -1);    } finally {        zk.close();    }}
41f079f4a1c2c84361a839404a7dfac3b87c20900c90ee38a1fb51f52f8ca42f
setMaxBuffer
public void setMaxBuffer() throws IOException, InterruptedException
{    System.setProperty("jute.maxbuffer", "" + TEST_MAXBUFFER);    assertEquals("Can't set jute.maxbuffer!", TEST_MAXBUFFER, BinaryInputArchive.maxBuffer);    zk = createClient();}
8df56fec8efb85bffe53fc6517d5c4ea4df4318d5bc7b845ad7da5c6fad13e48
testCreatesReqs
public void testCreatesReqs() throws Exception
{    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    });}
c5503524ffb25f4cce577b13025cd1d492b16297afdba7eaceb7c367a7a6a27a
execute
public void execute(byte[] data) throws Exception
{    zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
0949628db5ce9ea2b2e44f7b2eb2f383fc38f2fac0509c5ea82b6ee1727dbf78
testSetReqs
public void testSetReqs() throws Exception
{    final String path = "/set_test";    zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.setData(path, data, -1);        }    });}
c5503524ffb25f4cce577b13025cd1d492b16297afdba7eaceb7c367a7a6a27a
execute
public void execute(byte[] data) throws Exception
{    zk.setData(path, data, -1);}
4c4ef7b3665d6170af280e4f51b7896818d8615a75986dae5b4a644702fe6e2c
testRequests
private void testRequests(ClientOp clientOp) throws Exception
{    clientOp.execute(new byte[TEST_MAXBUFFER - 60]);    try {                clientOp.execute(new byte[TEST_MAXBUFFER]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }    try {        clientOp.execute(new byte[TEST_MAXBUFFER + 10]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }}
123186140ffceb4440599456274a5bbf61d872f6cc13a45cf521df3c3a718295
testStartup
public void testStartup() throws Exception
{    final String path = "/test_node";    zk.create(path, new byte[TEST_MAXBUFFER - 60], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.setData(path, new byte[TEST_MAXBUFFER - 50], -1);    stopServer();    startServer();}
1472dc2672384f43500ad54d0ae329409eed6c38f56c2677e70797612f9fc622
testStartupFailureCreate
public void testStartupFailureCreate() throws Exception
{        testStartupFailure(new File(TEST_DATA, "create"), "Server started despite create exceeding jute.maxbuffer!");}
98a6507e699e96594bc271dd55670adbcb32b57de184fd1312629ce74e07ed20
testStartupFailureSet
public void testStartupFailureSet() throws Exception
{        testStartupFailure(new File(TEST_DATA, "set"), "Server started despite set exceeding jute.maxbuffer!");}
5a08e4d5a892afc4c051828c93a3030418df5dd9aa1af8ad02d7a1768e6e67bd
testStartupFailureSnapshot
public void testStartupFailureSnapshot() throws Exception
{        testStartupFailure(new File(TEST_DATA, "snapshot"), "Server started despite znode exceeding jute.maxbuffer!");}
b249692d026f0c3793439da4c9e989748e14f76a956d454c227e8fad6f53e2c0
testStartupFailure
private void testStartupFailure(File testDir, String failureMsg) throws Exception
{    stopServer();        File oldTmpDir = tmpDir;    tmpDir = testDir;    try {        startServer();        fail(failureMsg);    } catch (IOException e) {        LOG.info("Successfully caught IOException: " + e);    } finally {        tmpDir = oldTmpDir;    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootasynctest";    super.setUp();    LOG.info("Creating client " + getTestName());    ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootasynctest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootclienttest";    System.out.println(hostPort);    super.setUp();    LOG.info("STARTING " + getTestName());    ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootclienttest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
5ee85b93d3b1559356fdc23406dc8e9078b44c9ef2227f4a90d6f64bf4b41e15
testPing
public void testPing() throws Exception
{}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    System.out.println("latch:" + path + " " + event.getPath());    this.eventPath = event.getPath();    latch.countDown();}
212abc1023e759f707d743f99616a04854a0e6e6eacd63552724dfb947ceef04
matches
public boolean matches() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("No watch received within timeout period " + path);    }    return path.equals(eventPath);}
160367b9838935292635eade57b5cd50bc596ef39a08feb1a3d013741fccd1ef
testChrootSynchronous
public void testChrootSynchronous() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = createClient();    try {        zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk1 != null) {            zk1.close();        }    }    ZooKeeper zk2 = createClient(hostPort + "/ch1");    try {        assertEquals("/ch2", zk2.create("/ch2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    } finally {        if (zk2 != null) {            zk2.close();        }    }    zk1 = createClient();    zk2 = createClient(hostPort + "/ch1");    try {                MyWatcher w1 = new MyWatcher("/ch1");        assertNotNull(zk1.exists("/ch1", w1));        MyWatcher w2 = new MyWatcher("/ch1/ch2");        assertNotNull(zk1.exists("/ch1/ch2", w2));        MyWatcher w3 = new MyWatcher("/ch2");        assertNotNull(zk2.exists("/ch2", w3));                MyWatcher w4 = new MyWatcher("/ch1");        zk1.getChildren("/ch1", w4);        MyWatcher w5 = new MyWatcher("/");        zk2.getChildren("/", w5);                zk1.setData("/ch1", "1".getBytes(), -1);        zk2.setData("/ch2", "2".getBytes(), -1);                assertTrue(w1.matches());        assertTrue(w2.matches());        assertTrue(w3.matches());                try {            zk2.setData("/ch3", "3".getBytes(), -1);        } catch (KeeperException.NoNodeException e) {            assertEquals("/ch3", e.getPath());        }        assertTrue(Arrays.equals("1".getBytes(), zk1.getData("/ch1", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk1.getData("/ch1/ch2", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk2.getData("/ch2", false, null)));                zk2.delete("/ch2", -1);        assertTrue(w4.matches());        assertTrue(w5.matches());        zk1.delete("/ch1", -1);        assertNull(zk1.exists("/ch1", false));        assertNull(zk1.exists("/ch1/ch2", false));        assertNull(zk2.exists("/ch2", false));    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    clientConnected = new CountDownLatch(1);    connected = false;    syncConnected = false;    readOnlyConnected = false;}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    KeeperState state = event.getState();    if (state == KeeperState.SyncConnected) {        connected = true;        syncConnected = true;        readOnlyConnected = false;    } else if (state == KeeperState.ConnectedReadOnly) {        connected = true;        syncConnected = false;        readOnlyConnected = true;    } else {        connected = false;        syncConnected = false;        readOnlyConnected = false;    }    notifyAll();    if (connected) {        clientConnected.countDown();    }}
b290187fc9d7bf1681b2363abe66e3d374cb0ed4adac841a9976c10900e43cf8
isConnected
public synchronized boolean isConnected()
{    return connected;}
94b844f504c7ab8ba1c556ac744493e0fa13b21530ff4f19ac40707c52dee488
waitForConnected
public synchronized void waitForConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!connected) {        throw new TimeoutException("Failed to connect to ZooKeeper server.");    }}
db0185f4e64349e5356608baf7a44b4c39196fc61cd0edcc038ee2178fe3c0f8
waitForSyncConnected
public synchronized void waitForSyncConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!syncConnected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!syncConnected) {        throw new TimeoutException("Failed to connect to read-write ZooKeeper server.");    }}
68964c21d4887ebfa8cf0c5e88c2d431d8a3dce50576a7bbb48d498e5ce933e7
waitForReadOnlyConnected
public synchronized void waitForReadOnlyConnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = System.currentTimeMillis() + timeout;    long left = timeout;    while (!readOnlyConnected && left > 0) {        wait(left);        left = expire - System.currentTimeMillis();    }    if (!readOnlyConnected) {        throw new TimeoutException("Failed to connect in read-only mode to ZooKeeper server.");    }}
79c411fc08f66545199f6da47c1409d27cad8b76344b506c6c48bc4062675200
waitForDisconnected
public synchronized void waitForDisconnected(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (connected) {        throw new TimeoutException("Did not disconnect");    }}
e020061391c4c99e64b2a900513ff8c46b803dc4c97eea1533ff800109075622
createClient
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
bd4e4ff5ae828a45ea9294d57e7f9d4e8aadd5b4b568ce81357e1bb6a0644103
createClient
protected TestableZooKeeper createClient(CountdownWatcher watcher) throws IOException, InterruptedException
{    return createClient(watcher, hostPort);}
21d592ab708145ff3ca51f4ffd3d1284b97280be8ef1ab18eeb27ee66e8e305e
createClient
protected TestableZooKeeper createClient(CountdownWatcher watcher, String hp) throws IOException, InterruptedException
{    return createClient(watcher, hp, CONNECTION_TIMEOUT);}
42704b0a2ced4ed1009aff58f7fb17a28851be5e373a342ffbdea93afb41e8ca
createClient
protected TestableZooKeeper createClient(CountdownWatcher watcher, String hp, int timeout) throws IOException, InterruptedException
{    watcher.reset();    TestableZooKeeper zk = new TestableZooKeeper(hp, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        if (exceptionOnFailedConnect) {            throw new ProtocolException("Unable to connect to server");        }        fail("Unable to connect to server");    }    synchronized (this) {        if (!allClientsSetup) {            LOG.error("allClients never setup");            fail("allClients never setup");        }        if (allClients != null) {            allClients.add(zk);            JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));        } else {                        zk.close();        }    }    return zk;}
aa6cbf932a56b3262837233761d78b27b7578dedf4c0ec01a4015ce3af3dd6d2
parseHostPortList
public static List<HostPort> parseHostPortList(String hplist)
{    ArrayList<HostPort> alist = new ArrayList<HostPort>();    for (String hp : hplist.split(",")) {        int idx = hp.lastIndexOf(':');        String host = hp.substring(0, idx);        int port;        try {            port = Integer.parseInt(hp.substring(idx + 1));        } catch (RuntimeException e) {            throw new RuntimeException("Problem parsing " + hp + e.toString());        }        alist.add(new HostPort(host, port));    }    return alist;}
c78e01ad35b4ed5952d71458bb1494e6caf62e9f5fd6ecddc273a56ebd913158
waitForServerUp
public static boolean waitForServerUp(String hp, long timeout)
{    return waitForServerUp(hp, timeout, false);}
62842923af23c701e2161d90602dbe7c4ed8d16bb1c65b86f877b941911f4e63
waitForServerUp
public static boolean waitForServerUp(String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {                        HostPort hpobj = parseHostPortList(hp).get(0);            String result = send4LetterWord(hpobj.host, hpobj.port, "stat", secure);            if (result.startsWith("Zookeeper version:") && !result.contains("READ-ONLY")) {                return true;            }        } catch (ConnectException e) {                        LOG.info("server {} not up: {}", hp, e.toString());        } catch (IOException e) {                        LOG.info("server {} not up", hp, e);        } catch (SSLContextException e) {            LOG.error("server {} not up", hp, e);        }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
2ebefa0c996c0e67627381a078158f9d3a200c0721cae59f9ee46911009c3248
waitForServerDown
public static boolean waitForServerDown(String hp, long timeout)
{    return waitForServerDown(hp, timeout, false);}
09887d9382f6783d78159445a871fafaafa093dee06e901ff1b98020a4473d6d
waitForServerDown
public static boolean waitForServerDown(String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {            HostPort hpobj = parseHostPortList(hp).get(0);            send4LetterWord(hpobj.host, hpobj.port, "stat", secure);        } catch (IOException e) {            return true;        } catch (SSLContextException e) {            return true;        }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
24ea3771ab8287047591213792daac579d60877bdd649c56f8dff1072206089d
waitForServerState
public static boolean waitForServerState(QuorumPeer qp, int timeout, String... serverStates)
{    long start = Time.currentElapsedTime();    while (true) {        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }        for (String state : serverStates) {            if (qp.getServerState().equals(state)) {                return true;            }        }        if (Time.currentElapsedTime() > start + timeout) {            return false;        }    }}
8f635dd1e5eeb990468e4fce104890e592ba00bd6637c4a7a69839196eede542
verifyThreadTerminated
 static void verifyThreadTerminated(Thread thread, long millis) throws InterruptedException
{    thread.join(millis);    if (thread.isAlive()) {        LOG.error("Thread " + thread.getName() + " : " + Arrays.toString(thread.getStackTrace()));        assertFalse("thread " + thread.getName() + " still alive after join", true);    }}
a08e460e450059392eb42ca24ec0579f58cef0a820ca00eab21df99d5bf095f9
createEmptyTestDir
public static File createEmptyTestDir() throws IOException
{    return createTmpDir(BASETEST, false);}
e2aef96e1569a6fefccb51f3ea1271f391256ce2da305e9b48f1223e100442dd
createTmpDir
public static File createTmpDir() throws IOException
{    return createTmpDir(BASETEST, true);}
e98da4c81e0b079b5e27e815c9450b3c9ff149163df76532c9272c2ee2266b3d
createTmpDir
 static File createTmpDir(File parentDir, boolean createInitFile) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());        if (createInitFile) {        createInitializeFile(tmpDir);    }    return tmpDir;}
867f0c4d81e5d60588309e9501cbf337253b645efa69da39f58ecec8f5ad3e3f
createInitializeFile
public static void createInitializeFile(File dir) throws IOException
{    File initFile = new File(dir, "initialize");    if (!initFile.exists()) {        assertTrue(initFile.createNewFile());    }}
4f500d4f2e952832b9402402cc9b0acf68218b6c0a541f5a0cf9aee680869280
getPort
private static int getPort(String hostPort)
{    String[] split = hostPort.split(":");    String portstr = split[split.length - 1];    String[] pc = portstr.split("/");    if (pc.length > 1) {        portstr = pc[0];    }    return Integer.parseInt(portstr);}
31f2b232b6b7e6e70a9546a804b090be871ada959c546717767a597d21aee5cd
startServerInstance
public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort, int serverId) throws IOException, InterruptedException
{    final int port = getPort(hostPort);    LOG.info("STARTING server instance 127.0.0.1:{}", port);    ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);    zks.setCreateSessionTrackerServerId(serverId);    factory.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure()));}
68ae8b4e60b6f9fd4e397dbf4cb195edfce742693ccd71b03e376fa352d1581c
createNewServerInstance
public static ServerCnxnFactory createNewServerInstance(ServerCnxnFactory factory, String hostPort, int maxCnxns) throws IOException, InterruptedException
{    final int port = getPort(hostPort);    LOG.info("CREATING server instance 127.0.0.1:{}", port);    if (factory == null) {        factory = ServerCnxnFactory.createFactory(port, maxCnxns);    }    return factory;}
19685c5b9bf632a43a1bb4913057b0bad21a29ba96cf807fab2175c4a2b2f670
shutdownServerInstance
 static void shutdownServerInstance(ServerCnxnFactory factory, String hostPort)
{    if (factory != null) {        ZKDatabase zkDb = null;        {            ZooKeeperServer zs = factory.getZooKeeperServer();            if (zs != null) {                zkDb = zs.getZKDatabase();            }        }        factory.shutdown();        try {            if (zkDb != null) {                zkDb.close();            }        } catch (IOException ie) {            LOG.warn("Error closing logs ", ie);        }        final int PORT = getPort(hostPort);        assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT, factory.isSecure()));    }}
9ab058ed329d12a685bb9ffec3a704800078b2a667201645313ab4f185496e3f
setupTestEnv
public static void setupTestEnv()
{                    System.setProperty("zookeeper.preAllocSize", "100");    FilePadding.setPreallocSize(100 * 1024);}
b98476f8f4646487d517128c64d94bc6e5136c677f6d581721d166b62e3896a9
setUpAll
protected void setUpAll() throws Exception
{    allClients = new LinkedList<ZooKeeper>();    allClientsSetup = true;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    setUpWithServerId(1);}
81ca3e6e4628b177e28503a66b1a1a48ef28831a90a6ba2504cbb748fd0a44fb
setUpWithServerId
protected void setUpWithServerId(int serverId) throws Exception
{    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        initialFdCount = osMbean.getOpenFileDescriptorCount();        LOG.info("Initial fdcount is: " + initialFdCount);    }    setupTestEnv();    setupCustomizedEnv();    JMXEnv.setUp();    setUpAll();    tmpDir = createTmpDir(BASETEST, true);    startServer(serverId);    LOG.info("Client test setup finished");}
55358ff3fbe2566a4a051c04c43bc1b61fefea873280be1b19d89f87c6852f32
startServer
protected void startServer() throws Exception
{    startServer(1);}
8e7d011dbd391446f826236511dd82494783338c6d29f82827db8c4673fde37b
setupCustomizedEnv
public void setupCustomizedEnv()
{/* do nothing by default */}
69c788405510947ebe3eb8df0b27b649d5ea68bdcd1a7d01dfbf9e41ad45bf60
startServer
private void startServer(int serverId) throws Exception
{    LOG.info("STARTING server");    serverFactory = createNewServerInstance(serverFactory, hostPort, maxCnxns);    startServerInstance(tmpDir, serverFactory, hostPort, serverId);        Set<ObjectName> children = JMXEnv.ensureParent("InMemoryDataTree", "StandaloneServer_port");                    verifyUnexpectedBeans(children);}
69012665c80f046ba04182c5334ae2c3fd0c6a79a385fab5edb09d6ae50ecb8e
verifyUnexpectedBeans
private void verifyUnexpectedBeans(Set<ObjectName> children)
{    if (allClients != null) {        for (ZooKeeper zkc : allClients) {            Iterator<ObjectName> childItr = children.iterator();            while (childItr.hasNext()) {                ObjectName clientBean = childItr.next();                if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {                    LOG.info("found name:" + zkc.getSessionId() + " client bean:" + clientBean.toString());                    childItr.remove();                }            }        }    }    for (ObjectName bean : children) {        LOG.info("unexpected:" + bean.toString());    }    assertEquals("Unexpected bean exists!", 0, children.size());}
23e3977a510a3df78c5508eee1c3578d9a9c3c3ea549862c3a722c6a29d51b85
getHexSessionId
protected static String getHexSessionId(long sessionId)
{    return "0x" + Long.toHexString(sessionId);}
7eb1b7836076ca89006625c41080964b0b02fa5bff18891775fbc802fa20794a
stopServer
protected void stopServer() throws Exception
{    LOG.info("STOPPING server");    shutdownServerInstance(serverFactory, hostPort);    serverFactory = null;        JMXEnv.ensureOnly();}
78a469ea5df3b27e69cd271cfa09cf6b3eacda1d1ef9a41884549bab26f1455c
tearDownAll
protected void tearDownAll() throws Exception
{    synchronized (this) {        if (allClients != null) {            for (ZooKeeper zk : allClients) {                try {                    if (zk != null) {                        zk.close();                    }                } catch (InterruptedException e) {                    LOG.warn("ignoring interrupt", e);                }            }        }        allClients = null;    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("tearDown starting");    tearDownAll();    stopServer();    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), recursiveDelete(tmpDir));    }        serverFactory = null;    JMXEnv.tearDown();    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        long fdCount = osMbean.getOpenFileDescriptorCount();        String message = "fdcount after test is: " + fdCount + " at start it was " + initialFdCount;        LOG.info(message);        if (fdCount > initialFdCount) {            LOG.info("sleeping for 20 secs");                        }    }    cleanUpCustomizedEnv();}
bb8cac3c573e774c541ef7bce7db2b9d466fa1f083ec04a3e6772ab95656d8d4
cleanUpCustomizedEnv
public void cleanUpCustomizedEnv()
{/* do nothing by default */}
64b385d7f00f68839ea439cc104eeaafd175ad0bed7db814425f5de61a2fade9
jmxConn
public static MBeanServerConnection jmxConn() throws IOException
{    return JMXEnv.conn();}
06796242f57d3b82346c4d89beb40a5575636af7a42ba5641f78250dd0c01126
recursiveDelete
public static boolean recursiveDelete(File d)
{    return TestUtils.deleteFileRecursively(d, true);}
d1e87203956da2f9a42bc2e7bb97eb78113d7ac0b008a94563374e1ecb4b8fa9
logAllStackTraces
public static void logAllStackTraces()
{    StringBuilder sb = new StringBuilder();    sb.append("Starting logAllStackTraces()\n");    Map<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();    for (Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {        sb.append("Thread " + e.getKey().getName() + "\n");        for (StackTraceElement elem : e.getValue()) {            sb.append("\tat " + elem + "\n");        }    }    sb.append("Ending logAllStackTraces()\n");    LOG.error(sb.toString());}
04ea04cb455ebc374d9e19dfd07a4cf6153578427b208b7c02153a756c80a960
verifyRootOfAllServersMatch
 void verifyRootOfAllServersMatch(String hostPort) throws InterruptedException, KeeperException, IOException
{    String[] parts = hostPort.split(",");            int[] counts = new int[parts.length];    int failed = 0;    for (int j = 0; j < 100; j++) {        int[] newcounts = new int[parts.length];        int i = 0;        for (String hp : parts) {            try {                ZooKeeper zk = createClient(hp);                try {                    newcounts[i++] = zk.getChildren("/", false).size();                } finally {                    zk.close();                }            } catch (Throwable t) {                failed++;                                                logAllStackTraces();            }        }        if (Arrays.equals(newcounts, counts)) {            LOG.info("Found match with array:" + Arrays.toString(newcounts));            counts = newcounts;            break;        } else {            counts = newcounts;            Thread.sleep(10000);        }                if (failed > 10) {            break;        }    }        String logmsg = "node count not consistent{} {}";    for (int i = 1; i < parts.length; i++) {        if (counts[i - 1] != counts[i]) {            LOG.error(logmsg, Integer.valueOf(counts[i - 1]), Integer.valueOf(counts[i]));        } else {            LOG.info(logmsg, Integer.valueOf(counts[i - 1]), Integer.valueOf(counts[i]));        }    }}
a66e473570f9b1ead86b00718d4919922efff1947c8e6205eb602af5705e3d5c
readFile
public static String readFile(File file) throws IOException
{    ByteArrayOutputStream os = new ByteArrayOutputStream();    BufferedInputStream is = new BufferedInputStream(new FileInputStream(file));    try {        IOUtils.copyBytes(is, os, 1024, true);    } finally {        is.close();    }    return os.toString();}
ec63a121943741b7d9cb7565be9b22c623afeb64e9e28a4428595247bada0896
join
public static String join(String separator, Object[] parts)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (Object part : parts) {        if (!first) {            sb.append(separator);            first = false;        }        sb.append(part);    }    return sb.toString();}
a396621fe46ec4ef3954d6a2cb3edba4b9c15da084a7b7786cb6393eb5275f96
createZKClient
public static ZooKeeper createZKClient(String cxnString) throws Exception
{    return createZKClient(cxnString, CONNECTION_TIMEOUT);}
ed9c6fa614783cb7fa495a8d0a1d0da8d66429a1944eb88194df6e9c7206ae45
createZKClient
public static ZooKeeper createZKClient(String cxnString, int sessionTimeout) throws IOException
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(cxnString, sessionTimeout, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper client can not connect to " + cxnString);    }    return zk;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {                        Thread.sleep(HAMMERTHREAD_LATENCY);            zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } catch (Throwable t) {        LOG.error("Client create operation failed", t);    } finally {        try {            zk.close();        } catch (InterruptedException e) {            LOG.warn("Unexpected", e);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {            ZooKeeper zk = parent.createClient();            try {                zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            } finally {                try {                    zk.close();                } catch (InterruptedException e) {                    LOG.warn("Unexpected", e);                }            }        }    } catch (Throwable t) {        LOG.error("Client create operation failed", t);    }}
932290a23a1b216cd9575cf86642443915c728311d4285af7b6d95c469d7e635
testHammerBasic
public void testHammerBasic() throws Throwable
{    runHammer(10, 1000);}
985c0d6d47afaa0372328f601e16af581b165dee215e5496d1a92c054c03c6c3
runHammer
public void runHammer(final int threadCount, final int childCount) throws Throwable
{    try {        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            ZooKeeper zk = createClient();            String prefix = "/test-" + i;            zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            prefix += "/";            HammerThread thread = new BasicHammerThread("BasicHammerThread-" + i, zk, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {        LOG.error("test failed", t);        throw t;    }}
d7d3b19e650dcda5dffc7b76132343ec9c61e8a54d173d2db521cb0e04519846
testHammerSuper
public void testHammerSuper() throws Throwable
{    try {        final int threadCount = 5;        final int childCount = 10;        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            String prefix = "/test-" + i;            {                ZooKeeper zk = createClient();                try {                    zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                } finally {                    zk.close();                }            }            prefix += "/";            HammerThread thread = new SuperHammerThread("SuperHammerThread-" + i, this, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {        LOG.error("test failed", t);        throw t;    }}
b2eb1476311d4e242a2c2680b55fca3f6720496b5f66d1be48626b2dc67129d6
verifyHammer
public void verifyHammer(long start, HammerThread[] threads, int childCount) throws IOException, InterruptedException, KeeperException
{        LOG.info("Starting check for completed hammers");    int workingCount = threads.length;    for (int i = 0; i < 120; i++) {        Thread.sleep(10000);        for (HammerThread h : threads) {            if (!h.isAlive() || h.current == h.count) {                workingCount--;            }        }        if (workingCount == 0) {            break;        }        workingCount = threads.length;    }    if (workingCount > 0) {        for (HammerThread h : threads) {            LOG.warn(h.getName() + " never finished creation, current:" + h.current);        }    } else {        LOG.info("Hammer threads completed creation operations");    }    for (HammerThread h : threads) {        final int safetyFactor = 3;        verifyThreadTerminated(h, (long) threads.length * (long) childCount * HAMMERTHREAD_LATENCY * (long) safetyFactor);    }    LOG.info(new Date() + " Total time " + (Time.currentElapsedTime() - start));    ZooKeeper zk = createClient();    try {        LOG.info("******************* Connected to ZooKeeper" + new Date());        for (int i = 0; i < threads.length; i++) {            LOG.info("Doing thread: " + i + " " + new Date());            List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }        for (int i = 0; i < threads.length; i++) {            List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }    } finally {        zk.close();    }}
ac5239098e16e08750071411dce9992cb7b60a16646ce8f8408eaeaf56a50b88
testBindByAddress
public void testBindByAddress() throws Exception
{    String bindAddress = null;    Enumeration<NetworkInterface> intfs = NetworkInterface.getNetworkInterfaces();        while (intfs.hasMoreElements()) {        NetworkInterface i = intfs.nextElement();        try {            if (i.isLoopback()) {                Enumeration<InetAddress> addrs = i.getInetAddresses();                while (addrs.hasMoreElements()) {                    InetAddress a = addrs.nextElement();                    if (a.isLoopbackAddress()) {                        bindAddress = a.getHostAddress();                        if (a instanceof Inet6Address) {                            bindAddress = "[" + bindAddress + "]";                        }                        break;                    }                }            }        } catch (SocketException se) {            LOG.warn("Couldn't find  loopback interface: " + se.getMessage());        }    }    if (bindAddress == null) {        LOG.warn("Unable to determine loop back address, skipping test");        return;    }    final int PORT = PortAssignment.unique();    LOG.info("Using " + bindAddress + " as the bind address");    final String HOSTPORT = bindAddress + ":" + PORT;    LOG.info("Using " + HOSTPORT + " as the host/port");    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(new InetSocketAddress(bindAddress, PORT), -1);    f.startup(zks);    LOG.info("starting up the the server, waiting");    assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    maxCnxns = 1;    super.setUp();}
ccb795f62537787b761435b90432dc60311740c52dcf624d2c02ea0f7cc7bd79
testClientRetry
public void testClientRetry() throws IOException, InterruptedException, TimeoutException
{    CountdownWatcher cdw1 = new CountdownWatcher();    CountdownWatcher cdw2 = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, cdw1);    try {        cdw1.waitForConnected(CONNECTION_TIMEOUT);        ZooKeeper zk2 = new ZooKeeper(hostPort, 10000, cdw2);        try {            States s1 = zk.getState();            States s2 = zk2.getState();            assertSame(s1, States.CONNECTED);            assertSame(s2, States.CONNECTING);            cdw1.reset();            zk.close();            cdw1.waitForDisconnected(CONNECTION_TIMEOUT);            cdw2.waitForConnected(CONNECTION_TIMEOUT);            assertSame(zk2.getState(), States.CONNECTED);        } finally {            zk2.close();        }    } finally {        zk.close();    }}
edcd42501c51dedc18d88eff9c80e0ae0152927a978139173c7118e6961b6e90
setup
public static void setup()
{    System.setProperty("zookeeper.skipACL", "yes");}
4203aaa745e098d336aa731322d301ec6e0e492fa3fbb66fd5b398b8681bccbe
teardown
public static void teardown()
{    System.clearProperty("zookeeper.skipACL");}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY, Boolean.TRUE.toString());    clientX509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(clientX509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(clientX509Util.getSslTruststorePasswdProperty(), "testpass");}
ec8b6259c87a96a7e78ab8ec13a826f2caf0d2a1c593d4aec011e181f3e17bbf
teardown
public void teardown()
{    System.clearProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY);    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    clientX509Util.close();}
030653b44c947e1b9930cee0ca0334e175d712027619cfff086154145fde421b
testClientServerUnifiedPort
public void testClientServerUnifiedPort() throws Exception
{    testClientServerSSL(false);}
dc6d22585465a3896463be7f3f4208cc3c27183cac3baa4f1b686c86acf9c21d
testClientServerSSL
public void testClientServerSSL() throws Exception
{    testClientServerSSL(true);}
c308a2cd1df5fa6cd25135ef07c5dfdc6bbca0e2a0cf6f7807508e142cebc431
testClientServerSSL
public void testClientServerSSL(boolean useSecurePort) throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    final Integer[] secureClientPorts = new Integer[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        secureClientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=127.0.0.1:%d:%d:participant;127.0.0.1:%d%n", i, PortAssignment.unique(), PortAssignment.unique(), clientPorts[i]);        sb.append(server);    }    String quorumCfg = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (useSecurePort) {            mt[i] = new MainThread(i, quorumCfg, secureClientPorts[i], true);        } else {            mt[i] = new MainThread(i, quorumCfg, true);        }        mt[i].start();    }            ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], 2 * TIMEOUT);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], TIMEOUT));        final int port = useSecurePort ? secureClientPorts[i] : clientPorts[i];        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + port, TIMEOUT);                zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/test", -1);        zk.close();    }    for (int i = 0; i < mt.length; i++) {        mt[i].shutdown();    }}
6e5f3de0e43ff452e499a6168cb3f7fc6dc372800e2138d6104055a2cb19e475
testSecureStandaloneServer
public void testSecureStandaloneServer() throws Exception
{    Integer secureClientPort = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, "", secureClientPort, false);    mt.start();    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + secureClientPort, TIMEOUT);    zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/test", -1);    zk.close();    mt.shutdown();}
5ee85b93d3b1559356fdc23406dc8e9078b44c9ef2227f4a90d6f64bf4b41e15
testPing
public void testPing() throws Exception
{    ZooKeeper zkIdle = null;    ZooKeeper zkWatchCreator = null;    try {        CountdownWatcher watcher = new CountdownWatcher();        zkIdle = createClient(watcher, hostPort, 10000);        zkWatchCreator = createClient();        for (int i = 0; i < 10; i++) {            zkWatchCreator.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        for (int i = 0; i < 10; i++) {            zkIdle.exists("/" + i, true);        }        for (int i = 0; i < 10; i++) {            Thread.sleep(1000);            zkWatchCreator.delete("/" + i, -1);        }                zkIdle.exists("/0", false);    } finally {        if (zkIdle != null) {            zkIdle.close();        }        if (zkWatchCreator != null) {            zkWatchCreator.close();        }    }}
463eb0e3351446d0de5f3393cdd4c9cbc1cf030b72a726f9dab669da0ae95288
testClientwithoutWatcherObj
public void testClientwithoutWatcherObj() throws IOException, InterruptedException, KeeperException
{    performClientTest(false);}
be1a1d5bbe6be668fac984e6224420544c8c82754ab059974d01b55dfd61e741
testClientWithWatcherObj
public void testClientWithWatcherObj() throws IOException, InterruptedException, KeeperException
{    performClientTest(true);}
0b365f6c4cf3ac5e44cbb8d485137fe809ae0db65c183442685e672fdd1bf661
testTestability
public void testTestability() throws Exception
{    TestableZooKeeper zk = createClient();    try {        LOG.info("{}", zk.testableLocalSocketAddress());        LOG.info("{}", zk.testableRemoteSocketAddress());        LOG.info("{}", zk.toString());    } finally {        zk.close(CONNECTION_TIMEOUT);        LOG.info("{}", zk.testableLocalSocketAddress());        LOG.info("{}", zk.testableRemoteSocketAddress());        LOG.info("{}", zk.toString());    }}
6a61f835063aafdf158d8c874fdfd302b777b0a1ff9fc63b4da5f55fa40ed383
testACLs
public void testACLs() throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        try {            zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {            LOG.info("Test successful, invalid acl received : " + e.getMessage());        }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id("ip", "127.0.0.1/8")));            zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {            LOG.info("Test successful, invalid acl received : " + e.getMessage());        }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));            zk.create("/nullidtest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {            LOG.info("Test successful, invalid acl received : " + e.getMessage());        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", "")));        testACL.add(new ACL(Perms.WRITE, new Id("ip", "127.0.0.1")));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);                acls = zk.getACL("/acltest", null);        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);        zk.close();    } finally {        if (zk != null) {            zk.close();        }    }}
14d75426af32905b5fafc5403a476db29f96ea16ca44c92d9e7729cfe68f3162
testNullAuthId
public void testNullAuthId() throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", null)));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);    } finally {        if (zk != null) {            zk.close();        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {            LOG.warn("ignoring interrupt during event.put");        }    }}
34713855b76a0322b32689af7993d8fb443238138e07cb91fc9b04ee213ef428
testMutipleWatcherObjs
public void testMutipleWatcherObjs() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = createClient(new CountdownWatcher(), hostPort);    try {        MyWatcher[] watchers = new MyWatcher[100];        MyWatcher[] watchers2 = new MyWatcher[watchers.length];        for (int i = 0; i < watchers.length; i++) {            watchers[i] = new MyWatcher();            watchers2[i] = new MyWatcher();            zk.create("/foo-" + i, ("foodata" + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        Stat stat = new Stat();                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));        }        for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata2-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata3-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata4-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata5-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers2[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata6-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata7-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());                        WatchedEvent event2 = watchers2[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event2.getPath());            assertEquals(EventType.NodeDataChanged, event2.getType());            assertEquals(KeeperState.SyncConnected, event2.getState());                                                assertEquals(0, watchers2[i].events.size());        }    } finally {        if (zk != null) {            zk.close();        }    }}
9dd02bc34a1b387397beab76224acc31b457d65427db3be99f462d74d2927439
performClientTest
private void performClientTest(boolean withWatcherObj) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);        LOG.info("Before create /benwashere");        zk.create("/benwashere", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        LOG.info("After create /benwashere");        try {            zk.setData("/benwashere", "hi".getBytes(), 57);            fail("Should have gotten BadVersion exception");        } catch (KeeperException.BadVersionException e) {                } catch (KeeperException e) {            fail("Should have gotten BadVersion exception");        }        LOG.info("Before delete /benwashere");        zk.delete("/benwashere", 0);        LOG.info("After delete /benwashere");        zk.close();                Thread.sleep(2000);        zk = createClient(watcher, hostPort);                LOG.info("Before delete /");        try {            zk.delete("/", -1);            fail("deleted root!");        } catch (KeeperException.BadArgumentsException e) {                }        Stat stat = new Stat();                zk.create("/pat", "Pat was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        LOG.info("Before create /ben");        zk.create("/pat/ben", "Ben was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        LOG.info("Before getChildren /pat");        List<String> children = zk.getChildren("/pat", false);        assertEquals(1, children.size());        assertEquals("ben", children.get(0));        List<String> children2 = zk.getChildren("/pat", false, null);        assertEquals(children, children2);        String value = new String(zk.getData("/pat/ben", false, stat));        assertEquals("Ben was here", value);        try {            if (withWatcherObj) {                assertEquals(null, zk.exists("/frog", watcher));            } else {                assertEquals(null, zk.exists("/frog", true));            }            LOG.info("Comment: asseting passed for frog setting /");        } catch (KeeperException.NoNodeException e) {                }        zk.create("/frog", "hi".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                LOG.info("Comment: checking for events length " + watcher.events.size());        WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/frog", event.getPath());        assertEquals(EventType.NodeCreated, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());                zk.getChildren("/pat/ben", true);        for (int i = 0; i < 10; i++) {            zk.create("/pat/ben/" + i + "-", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren("/pat/ben", false);        Collections.sort(children);        assertEquals(10, children.size());        for (int i = 0; i < 10; i++) {            final String name = children.get(i);            assertTrue("starts with -", name.startsWith(i + "-"));            byte[] b;            if (withWatcherObj) {                b = zk.getData("/pat/ben/" + name, watcher, stat);            } else {                b = zk.getData("/pat/ben/" + name, true, stat);            }            assertEquals(Integer.toString(i), new String(b));            zk.setData("/pat/ben/" + name, "new".getBytes(), stat.getVersion());            if (withWatcherObj) {                stat = zk.exists("/pat/ben/" + name, watcher);            } else {                stat = zk.exists("/pat/ben/" + name, true);            }            zk.delete("/pat/ben/" + name, stat.getVersion());        }        event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/pat/ben", event.getPath());        assertEquals(EventType.NodeChildrenChanged, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());        for (int i = 0; i < 10; i++) {            event = watcher.events.poll(10, TimeUnit.SECONDS);            final String name = children.get(i);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDeleted, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());        }        zk.create("/good\u0040path", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("duplicate create allowed");        } catch (KeeperException.NodeExistsException e) {                }    } finally {        if (zk != null) {            zk.close();        }    }}
679eaf5aa7d5a2ce15ce0ea9a72ec361c6b0eac49559ea53a5e6d9a6dd794087
testSequentialNodeNames
public void testSequentialNodeNames() throws IOException, InterruptedException, KeeperException
{    String path = "/SEQUENCE";    String file = "TEST";    String filepath = path + "/" + file;    ZooKeeper zk = null;    try {        zk = createClient();        zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(path, false);        assertEquals(1, children.size());        assertEquals(file + "0000000000", children.get(0));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(2, children.size());        assertTrue("contains child 1", children.contains(file + "0000000001"));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(3, children.size());        assertTrue("contains child 2", children.contains(file + "0000000002"));                for (int i = children.size(); i < 105; i++) {            zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren(path, false);        assertTrue("contains child 104", children.contains(file + "0000000104"));    } finally {        if (zk != null) {            zk.close();        }    }}
a28af86e4292c4b26eda6b15123f0fe0ff3dd69ca8c8bd7e1fc4115891f8888e
testSequentialNodeData
public void testSequentialNodeData() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/queue";    try {        zk = createClient();        zk.create(queue_handle, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(queue_handle + "/element", "0".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        zk.create(queue_handle + "/element", "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(queue_handle, true);        assertEquals(children.size(), 2);        String child1 = children.get(0);        String child2 = children.get(1);        int compareResult = child1.compareTo(child2);        assertNotSame(compareResult, 0);        if (compareResult < 0) {        } else {            String temp = child1;            child1 = child2;            child2 = temp;        }        String child1data = new String(zk.getData(queue_handle + "/" + child1, false, null));        String child2data = new String(zk.getData(queue_handle + "/" + child2, false, null));        assertEquals(child1data, "0");        assertEquals(child2data, "1");    } finally {        if (zk != null) {            zk.close();        }    }}
7605a2036469766ef73ba167be58f251877fcbe5235fac599951a4e30145d1bf
testLargeNodeData
public void testLargeNodeData() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/large";    try {        zk = createClient();        zk.create(queue_handle, new byte[500000], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk != null) {            zk.close();        }    }}
75e069f55b8c1c7c42c01ab3411a68e2e25ca75b677a784e1359a70aabffbb4a
verifyCreateFails
private void verifyCreateFails(String path, ZooKeeper zk) throws Exception
{    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (IllegalArgumentException e) {                return;    }    fail("bad path \"" + path + "\" not caught");}
c07443fd34bc0b3aa4fca1f216367ca9a05367fe4beeca24c955f99997d35b39
testPathValidation
public void testPathValidation() throws Exception
{    ZooKeeper zk = createClient();    verifyCreateFails(null, zk);    verifyCreateFails("", zk);    verifyCreateFails("//", zk);    verifyCreateFails("///", zk);    verifyCreateFails("////", zk);    verifyCreateFails("/.", zk);    verifyCreateFails("/..", zk);    verifyCreateFails("/./", zk);    verifyCreateFails("/../", zk);    verifyCreateFails("/foo/./", zk);    verifyCreateFails("/foo/../", zk);    verifyCreateFails("/foo/.", zk);    verifyCreateFails("/foo/..", zk);    verifyCreateFails("/./.", zk);    verifyCreateFails("/../..", zk);    verifyCreateFails("/\u0001foo", zk);    verifyCreateFails("/foo/bar/", zk);    verifyCreateFails("/foo//bar", zk);    verifyCreateFails("/foo/bar//", zk);    verifyCreateFails("foo", zk);    verifyCreateFails("a", zk);    zk.create("/createseqpar", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    try {        zk.create("/createseqpar//", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/./", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/../", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        PrepRequestProcessor.setFailCreate(true);    try {        zk.create("/m", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (KeeperException.BadArgumentsException be) {        }    PrepRequestProcessor.setFailCreate(false);    zk.create("/.foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/.f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f.c", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f\u0040f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f./f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
e496dc4cf0ca72f4e56323791ff91072eb9499035f84285dfaef361dc9f228f4
testDeleteWithChildren
public void testDeleteWithChildren() throws Exception
{    ZooKeeper zk = createClient();    zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/parent/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        zk.delete("/parent", -1);        fail("Should have received a not equals message");    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NOTEMPTY, e.code());    }    zk.delete("/parent/child", -1);    zk.delete("/parent", -1);    zk.close();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        for (; current < count; current++) {            TestableZooKeeper zk = createClient();                                                zk.close(CONNECTION_TIMEOUT);        }    } catch (Throwable t) {        LOG.error("test failed", t);    }}
7a6fc47f716ffd0da6076e11ad98e5129a8108729cfbf83c42bd7ca381554ccd
testClientCleanup
public void testClientCleanup() throws Throwable
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {        LOG.warn("skipping testClientCleanup, only available on Unix");        return;    }    final int threadCount = 3;    final int clientCount = 10;    /* Log the number of fds used before and after a test is run. Verifies         * we are freeing resources correctly. Unfortunately this only works         * on unix systems (the only place sun has implemented as part of the         * mgmt bean api).         */    long initialFdCount = osMbean.getOpenFileDescriptorCount();    VerifyClientCleanup[] threads = new VerifyClientCleanup[threadCount];    for (int i = 0; i < threads.length; i++) {        threads[i] = new VerifyClientCleanup("VCC" + i, clientCount);        threads[i].start();    }    for (int i = 0; i < threads.length; i++) {        threads[i].join(CONNECTION_TIMEOUT);        assertTrue(threads[i].current == threads[i].count);    }            long currentCount = osMbean.getOpenFileDescriptorCount();    final String logmsg = "open fds after test ({}) are not significantly higher than before ({})";    if (currentCount > initialFdCount + 10) {                LOG.error(logmsg, Long.valueOf(currentCount), Long.valueOf(initialFdCount));    } else {        LOG.info(logmsg, Long.valueOf(currentCount), Long.valueOf(initialFdCount));    }}
29ffc64795bc21b6570a57c03a989987f004cc7da1806c941599d1249b42f6c0
testNonExistingOpCode
public void testNonExistingOpCode() throws Exception
{    final CountDownLatch clientDisconnected = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public synchronized void process(WatchedEvent event) {            if (event.getState() == KeeperState.Disconnected) {                clientDisconnected.countDown();            }        }    };    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    final String path = "/m1";    RequestHeader h = new RequestHeader();        h.setType(888);    ExistsRequest request = new ExistsRequest();    request.setPath(path);    request.setWatch(false);    ExistsResponse response = new ExistsResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals(r.getErr(), Code.UNIMPLEMENTED.intValue());        assertTrue("failed to disconnect", clientDisconnected.await(5000, TimeUnit.MILLISECONDS));    zk.close();}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        clientDisconnected.countDown();    }}
e018b147b7b8b814ee9aa599f0a211d569c689483f2183753b05f90694019498
testTryWithResources
public void testTryWithResources() throws Exception
{    ZooKeeper zooKeeper;    try (ZooKeeper zk = createClient()) {        zooKeeper = zk;        assertTrue(zooKeeper.getState().isAlive());    }    assertFalse(zooKeeper.getState().isAlive());}
82296527c691175bf3c33d1c70de0e4a8af48e8d77cdad0e5292159e87b90eb0
testCXidRollover
public void testCXidRollover() throws Exception
{    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.setXid(Integer.MAX_VALUE - 10);        zk.create("/testnode", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < 20; ++i) {            final CountDownLatch latch = new CountDownLatch(1);            final AtomicInteger rc = new AtomicInteger(0);            zk.setData("/testnode", "".getBytes(), -1, new AsyncCallback.StatCallback() {                @Override                public void processResult(int retcode, String path, Object ctx, Stat stat) {                    rc.set(retcode);                    latch.countDown();                }            }, null);            assertTrue("setData should complete within 5s", latch.await(zk.getSessionTimeout(), TimeUnit.MILLISECONDS));            assertEquals("setData should have succeeded", Code.OK.intValue(), rc.get());        }        zk.delete("/testnode", -1);        assertTrue("xid should be positive", zk.checkXid() > 0);    } finally {        if (zk != null) {            zk.close();        }    }}
21595846352a90f56f0ae447ad046e8b141e555de088f915a73df57bb4b4862e
processResult
public void processResult(int retcode, String path, Object ctx, Stat stat)
{    rc.set(retcode);    latch.countDown();}
e995c5df0eacb5fed278d5099d4d315ecc515d7c379c6618a9212ae2d4629726
testSingleServerChrootPath
public void testSingleServerChrootPath()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
b3b3a973386dd989bdc396bfffdcb432eff777f6a1c87deed0d739d3cfc19fbc
testMultipleServersChrootPath
public void testMultipleServersChrootPath()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1,10.10.10.2";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]:2181,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
6ceb226b19fdb2b23f2785a6db22f423398b17753a130e88e1404ef8186f42cd
testParseServersWithoutPort
public void testParseServersWithoutPort()
{    String servers = "10.10.10.1,10.10.10.2";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2],[2001:db8:85a3:8d3:1319:8a2e:370:7348]";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());}
7d8cb1e5a22fc1dc6a7d2d0073b1fda5cb9a161d7a4a149f28ae934b18f7c755
testParseServersWithPort
public void testParseServersWithPort()
{    String servers = "10.10.10.1:112,10.10.10.2:110";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(112, parser.getServerAddresses().get(0).getPort());    assertEquals(110, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2]:1234,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(1234, parser.getServerAddresses().get(0).getPort());    assertEquals(5678, parser.getServerAddresses().get(1).getPort());}
c58fe001c674f8c8600c3f083bc7c9bb9e017e5c88614bec8b0aa0bbfddfe925
assertChrootPath
private void assertChrootPath(String expected, ConnectStringParser parser)
{    assertEquals(expected, parser.getChrootPath());}
1abe8fc1d97e0ce013a44ba973ee47a0f5cdcae5e3ae4f6ce4b8ebe05f9531d0
testBasicCreateMode
public void testBasicCreateMode()
{    CreateMode cm = CreateMode.PERSISTENT;    assertEquals(cm.toFlag(), 0);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL;    assertEquals(cm.toFlag(), 1);    assertTrue(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.PERSISTENT_SEQUENTIAL;    assertEquals(cm.toFlag(), 2);    assertFalse(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL_SEQUENTIAL;    assertEquals(cm.toFlag(), 3);    assertTrue(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.CONTAINER;    assertEquals(cm.toFlag(), 4);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertTrue(cm.isContainer());}
b30b2d8b1ef9f9c2fc444b30a8f6f881caa34976a95c80c15404bd93c23859eb
testFlagConversion
public void testFlagConversion() throws KeeperException
{        EnumSet<CreateMode> allModes = EnumSet.allOf(CreateMode.class);    for (CreateMode cm : allModes) {        assertEquals(cm, CreateMode.fromFlag(cm.toFlag()));    }}
40a758f9c7144d6239d8438479bc6e392278451ce5de5829123ada98aa68caa8
testInvalidFlagConversion
public void testInvalidFlagConversion() throws KeeperException
{    try {        CreateMode.fromFlag(99);        fail("Shouldn't be able to convert 99 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }    try {        CreateMode.fromFlag(-1);        fail("Shouldn't be able to convert -1 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
2e82f496ddafc025edb9b335894a67ca11273d6b25011e2ddfdbfe6583c7d03e
testCreate
public void testCreate() throws IOException, KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
859e5b5024abc7df5df9afcbc69abddb07058448bd50631cb71d1db203ca4392
testCreateWithStat
public void testCreateWithStat() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
6029fe9179a86e0830c4da50d39492ac18f015fbf8e3459a7380454a3755edbf
testCreateWithNullStat
public void testCreateWithNullStat() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            String path = zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
7e01a8adad071c037f5ecd25f11aad18d9635cfe123c5c93e85dd738a280ebb1
createNoStatVerifyResult
private void createNoStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(path, newName);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
c9102d3dbfc4aa99b28b1adf8ecad5a7829d64131dd0761030dc3cd0c80dad77
createWithStatVerifyResult
private Stat createWithStatVerifyResult(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertEquals(path, newName);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
670038e36942d806b6e6719a334d91775146711dca7a3693a41bed41de3a0fea
validateCreateStat
private void validateCreateStat(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
ad83df86878b89435dd0d09352a6dfd615244a996e6b34403f6d485c96147d19
disconnect
public void disconnect() throws IOException
{    cnxn.disconnect();}
32077c79be7164eb84480f8e2ae9ec1321436b9816b66b4f529d6952b09b4770
dontReconnect
public void dontReconnect() throws Exception
{    java.lang.reflect.Field f = cnxn.getClass().getDeclaredField("closing");    f.setAccessible(true);    f.setBoolean(cnxn, true);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {            LOG.warn("ignoring interrupt during event.put");        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    watcher1 = new CountdownWatcher();    zk1 = createClient(watcher1);    watcher2 = new MyWatcher();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (zk2 != null) {        zk2.close();    }    if (zk1 != null) {        zk1.close();    }    super.tearDown();}
5ef2bbee8182013b88825f168c169da93fdce78fccc9b9a55a7ff8315b15e232
testChildWatcherAutoResetWithChroot
public void testChildWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
abbb63794c7378cf1cbc77b20011e99e2c17a8b53aca9c776d0868004dca976b
testDefaultWatcherAutoResetWithChroot
public void testDefaultWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    zk2.getChildren("/", true);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
97bbfeaadc5c522ffc247d521e58a9aabaa8e505411b4371e89a5aff38f36542
testDeepChildWatcherAutoResetWithChroot
public void testDeepChildWatcherAutoResetWithChroot() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we/are", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1/here/we");    zk2.getChildren("/are", true);        zk1.create("/ch1/here/we/are/now", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/are", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/here/we/are/again", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());}
7dd5fa95b5fa7470b4e8683c1301ab1b5632b21200c01c91d93f983dfd23d42d
testManyChildWatchersAutoReset
public void testManyChildWatchersAutoReset() throws Exception
{    zk2 = createClient(watcher2);        String pathBase = "/long-path-000000000-111111111-222222222-333333333-444444444-" + "555555555-666666666-777777777-888888888-999999999";    zk1.create(pathBase, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            List<String> paths = new ArrayList<String>();    for (int i = 0; i < 10000; i++) {        String path = zk1.create(pathBase + "/ch-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        paths.add(path);    }    LOG.info("Created 10,000 nodes.");    MyWatcher childWatcher = new MyWatcher();        int i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk2.getChildren(path, childWatcher);        } else if (i % 3 == 1) {            zk2.exists(path + "/foo", childWatcher);        } else if (i % 3 == 2) {            zk2.getData(path, childWatcher, null);        }        i++;    }    stopServer();    watcher2.waitForDisconnected(30000);    startServer();    watcher2.waitForConnected(30000);    watcher1.waitForConnected(30000);        i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk1.create(path + "/ch", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeChildrenChanged, e.getType());            assertEquals(path, e.getPath());        } else if (i % 3 == 1) {            zk1.create(path + "/foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeCreated, e.getType());            assertEquals(path + "/foo", e.getPath());        } else if (i % 3 == 2) {            zk1.setData(path, new byte[] { 1, 2, 3 }, -1);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeDataChanged, e.getType());            assertEquals(path, e.getPath());        }        i++;    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());    qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());    qb.tearDown();}
e295fffa69fa8764b25f0b1aaba494b73b10e403b1add81f7d8a0eba19ae7fe4
testLocalSessionUpgradeOnFollower
public void testLocalSessionUpgradeOnFollower() throws Exception
{    testLocalSessionUpgrade(false);}
f924aaeb90616b86341c622bf225276c1cf5fc00e8d637eeac62c71bb03d0a50
testLocalSessionUpgradeOnLeader
public void testLocalSessionUpgradeOnLeader() throws Exception
{    testLocalSessionUpgrade(true);}
8781cd445a6edbc77796a2a59ff763b8d117aff35835fc0a64f5e70107a912f1
testLocalSessionUpgrade
private void testLocalSessionUpgrade(boolean testLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    final String firstPath = "/first";    final String secondPath = "/ephemeral";        zk.create(firstPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.create(secondPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat firstStat = zk.exists(firstPath, null);    assertNotNull(firstStat);    Stat secondStat = zk.exists(secondPath, null);    assertNotNull(secondStat);    long zxidDiff = secondStat.getCzxid() - firstStat.getCzxid();                assertEquals(2L, zxidDiff);}
568bb26cde0ebf08647f6a8f8c91183fbb6120ada5a4125bbb6946a815b6de98
runTest
public void runTest(boolean leaveEmptyFile, boolean trustEmptySnap) throws Exception
{    File tmpSnapDir = ClientBase.createTmpDir();    File tmpLogDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    SyncRequestProcessor.setSnapCount(SNAP_COUNT);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);    try {        for (int i = 0; i < N_TRANSACTIONS; i++) {            zk.create("/node-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    zks.startdata();    long zxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();    LOG.info("After clean restart, zxid = " + zxid);    assertTrue("zxid > 0", zxid > 0);    zks.shutdown();        FileTxnSnapLog txnLogFactory = zks.getTxnLogFactory();    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);    assertTrue("We have a snapshot to corrupt", snapshots.size() > 0);    for (File file : snapshots) {        if (leaveEmptyFile) {            new PrintWriter(file).close();        } else {            file.delete();        }    }    if (trustEmptySnap) {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, "true");    }        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    try {        zks.startdata();        zxid = zks.getZKDatabase().loadDataBase();        if (!trustEmptySnap) {            fail("Should have gotten exception for corrupted database");        }    } catch (IOException e) {                if (trustEmptySnap) {            fail("Should not get exception for empty database");        }    } finally {        if (trustEmptySnap) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);        }    }    zks.shutdown();}
f186e60eb66c94b7f1281c0ef5b17d06d9bc1dad2b4a7dd07979931f9336eab6
testRestoreWithEmptySnapFiles
public void testRestoreWithEmptySnapFiles() throws Exception
{    runTest(true, false);}
b216e74ffe1d0771b50475da27e2c4bb71c9596e3e5dd8f48b3164ac48e83b54
testRestoreWithNoSnapFiles
public void testRestoreWithNoSnapFiles() throws Exception
{    runTest(false, false);}
bb04819e7ebd9264581a2b857ee9a5793016b8ab049d1cd3fb98c1fd37b58942
testRestoreWithTrustedEmptySnapFiles
public void testRestoreWithTrustedEmptySnapFiles() throws Exception
{    runTest(false, true);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    super.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    ProviderRegistry.removeProvider("ensemble");}
ad6bc98518f9adf4b3ac21153895f12d32b707d00a104959fc9a98913559712b
noAuth
public void noAuth() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble(null);}
f6caba85b2ec4d0042e73a5646095c7ce4e46818de470baa3ee8bf00b5ed524e
emptyAuth
public void emptyAuth() throws Exception
{    resetEnsembleAuth(null, true);    connectToEnsemble("foo");}
3b87deea89dc6d64d868f1154d96f947a76db1829c592acf1f62713215db0b57
skipAuth
public void skipAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble(null);}
d6fbbbe3d50ad39e9f356b2ce458faf7f61115235235961ba8abc41322967e71
passAuth
public void passAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("woo");}
c3d6cb2335b9cf6ea8658a2293661d9a215f5d30fd6b04a0b69df3f2e7ebc505
passAuthCSV
public void passAuthCSV() throws Exception
{    resetEnsembleAuth(" foo,bar, baz ", true);    connectToEnsemble("foo");    connectToEnsemble("bar");    connectToEnsemble("baz");}
d751ccee858ee17f57bfae38e231c984f8f4a1a373f316505d2911cbdc8a56de
failAuth
public void failAuth() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("goo");}
24b0db6ffc4d2ca99e7caf796837a22b42c50e373d50f23a53061ba4bdcd0ea8
removeEnsembleAuthProvider
public void removeEnsembleAuthProvider() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble("goo");}
54382c328d92c50f9ddd4d7c3dd1cbe25706b1b1fc3aa465528000da71a7b69e
connectToEnsemble
private void connectToEnsemble(final String auth) throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {                if (auth != null) {            zk.addAuthInfo("ensemble", auth.getBytes());        }        zk.getData("/", false, null);    }}
c9fe5a916b47b623cebc366f0bd83ddfc17c832642aef89df578a97165a67ea9
resetEnsembleAuth
private void resetEnsembleAuth(final String auth, final boolean useAuth) throws Exception
{    stopServer();    if (auth == null) {        System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    } else {        System.setProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY, auth);    }    if (useAuth) {        System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    } else {        System.clearProperty("zookeeper.authProvider.1");    }    ProviderRegistry.removeProvider("ensemble");    ProviderRegistry.initialize();    startServer();}
04eebb24f1ddc363e13ea7ca878751a2966a9d1e8715a9a90280e68cd56f54e0
testIntConversion
public void testIntConversion()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    for (EventType et : allTypes) {        assertEquals(et, EventType.fromInt(et.getIntValue()));    }}
5c4c618aedd856345375abd77ed1da6831b5a277c65a4f22ba21e0c38c452ac7
testInvalidIntConversion
public void testInvalidIntConversion()
{    try {        EventType.fromInt(324242);        fail("Was able to create an invalid EventType via an integer");    } catch (RuntimeException re) {        }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    tmpdir = new File[count];    port = new int[count];    round = new int[3];    round[0] = 0;    round[1] = 0;    round[2] = 0;    start0 = new Semaphore(0);    finish0 = new Semaphore(0);    finish3 = new Semaphore(0);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        threads.get(i).peer.getElectionAlg().shutdown();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    boolean flag = true;    try {        while (flag) {            Vote v = null;            peer.setPeerState(ServerState.LOOKING);            LOG.info("Going to call leader election again: " + i);            v = peer.getElectionAlg().lookForLeader();            if (v == null) {                fail("Thread " + i + " got a null vote");            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);            LOG.info("Finished election: " + i + ", " + v.getId());            switch(i) {                case 0:                    LOG.info("First peer, do nothing, just join");                    if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {                                                LOG.info("Setting flag to false");                        flag = false;                    }                    break;                case 1:                    LOG.info("Second entering case");                    if (round[1] != 0) {                        finish0.release();                        flag = false;                    } else {                        finish3.acquire();                        start0.release();                    }                    LOG.info("Second is going to start second round");                    round[1]++;                    break;                case 2:                    LOG.info("Third peer, shutting it down");                    QuorumBase.shutdown(peer);                    flag = false;                    round[2] = 1;                    finish3.release();                    LOG.info("Third leaving");                    break;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
196f339203dffcd2be50eefaaf71fdd5f4ef62b183d5f284797cc9af3f6a6a29
testLENewEpoch
public void testLENewEpoch() throws Exception
{    LOG.info("TestLE: " + getTestName() + ", " + count);    for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 1; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }    if (!start0.tryAcquire(4000, java.util.concurrent.TimeUnit.MILLISECONDS)) {        fail("First leader election failed");    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    LEThread thread = new LEThread(peer, 0);    thread.start();    threads.add(thread);    LOG.info("Started threads " + getTestName());    for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(10000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
2d71b79b7f8ffeea4b5228f3f04bbd5b991008bbf84daa205f8a9bcefe622a56
predicate
 boolean predicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    return this.totalOrderPredicate(newId, newZxid, newEpoch, curId, curZxid, curEpoch);}
2d1b767ac76f3b21c102938fa80ec71ce4616682a8e50a014399520f5809abf2
testPredicate
public void testPredicate() throws IOException
{    peers = new HashMap<Long, QuorumServer>(3);    /*         * Creates list of peers.         */    for (int i = 0; i < 3; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    /*         * Creating peer.         */    try {        File tmpDir = ClientBase.createTmpDir();        QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir, PortAssignment.unique(), 3, 0, 1000, 2, 2, 2);        MockFLE mock = new MockFLE(peer);        mock.start();        /*             * Lower epoch must return false             */        assertFalse(mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));        /*             * Later epoch             */        assertTrue(mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));        /*             * Higher zxid             */        assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));        /*             * Higher id             */        assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));    } catch (IOException e) {        LOG.error("Exception while creating quorum peer", e);        fail("Exception while creating quorum peer");    }}
f98eef340bc53599f78e745b31fabd8914fb2dde94fabbc507056d651941e5e8
countVotes
 int countVotes(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    restartThreads = new ArrayList<FLERestartThread>(count);    tmpdir = new File[count];    port = new int[count];    finish = new Semaphore(0);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).peer.getElectionAlg().shutdown();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Vote v = null;        while (true) {            peer.setPeerState(ServerState.LOOKING);            LOG.info("Going to call leader election again.");            v = peer.getElectionAlg().lookForLeader();            if (v == null) {                LOG.info("Thread " + i + " got a null vote");                break;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);            LOG.info("Finished election: " + i + ", " + v.getId());            switch(i) {                case 0:                    if (peerRound == 0) {                        LOG.info("First peer, shutting it down");                        QuorumBase.shutdown(peer);                        restartThreads.get(i).peer.getElectionAlg().shutdown();                        peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);                        peer.startLeaderElection();                        peerRound++;                    } else {                        finish.release(2);                        return;                    }                    break;                case 1:                    LOG.info("Second entering case");                    finish.acquire();                                        LOG.info("Release");                    return;                case 2:                    LOG.info("First peer, do nothing, just join");                    finish.acquire();                                        LOG.info("Release");                    return;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
c91786bde05678c13a6dac1ce981da55e0eda0a2c90c53d302fb53adaf891977
testLERestart
public void testLERestart() throws Exception
{    LOG.info("TestLE: " + getTestName() + ", " + count);    for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        FLERestartThread thread = new FLERestartThread(peer, i);        thread.start();        restartThreads.add(thread);    }    LOG.info("Started threads " + getTestName());    for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).join(10000);        if (restartThreads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
f98eef340bc53599f78e745b31fabd8914fb2dde94fabbc507056d651941e5e8
countVotes
 int countVotes(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 7;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    voteMap = new HashMap<Integer, HashSet<TestVote>>();    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    successCount = 0;    joinedThreads = new HashSet<Long>();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        leThread = threads.get(i);        QuorumBase.shutdown(leThread.peer);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Vote v = null;        while (true) {            /*                     * Set the state of the peer to LOOKING and look for leader                     */            peer.setPeerState(ServerState.LOOKING);            LOG.info("Going to call leader election again.");            v = peer.getElectionAlg().lookForLeader();            if (v == null) {                LOG.info("Thread " + i + " got a null vote");                break;            }            /*                     * Done with the election round, so now we set the vote in                     * the peer. A real zookeeper would take care of setting the                     * current vote. Here we do it manually.                     */            peer.setCurrentVote(v);            LOG.info("Finished election: " + i + ", " + v.getId());            votes[i] = v;            /*                     * Get the current value of the logical clock for this peer                     * so that we know in which round this peer has executed.                     */            int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();            /*                     * The leader executes the following block, which essentially shuts down                     * the peer if it is not the last round.                     */            if (v.getId() == i) {                LOG.info("I'm the leader: " + i);                if (lc < this.totalRounds) {                    LOG.info("Leader " + i + " dying");                    FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();                    election.shutdown();                                        assertEquals(-1, election.getVote().getId());                    LOG.info("Leader " + i + " dead");                    break;                }            }            /*                     * If the peer has done enough rounds, then consider joining. The thread                     * will only join if it is part of a quorum supporting the current                     * leader. Otherwise it will try again.                     */            if (lc >= this.totalRounds) {                /*                         * quora keeps the supporters of a given leader, so                         * we first update it with the vote of this peer.                         */                if (quora.get(v.getId()) == null) {                    quora.put(v.getId(), new HashSet<Integer>());                }                quora.get(v.getId()).add(i);                /*                         * we now wait until a quorum supports the same leader.                         */                if (waitForQuorum(v.getId())) {                    synchronized (self) {                        /*                                 * Assert that the state of the thread is the one expected.                                 */                        if (v.getId() == i) {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.LEADING);                            leader = i;                        } else {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.FOLLOWING);                        }                        /*                                 * Global variable keeping track of                                 * how many peers have successfully                                 * joined.                                 */                        successCount++;                        joinedThreads.add((long) i);                        self.notify();                    }                    /*                             * I'm done so joining.                             */                    break;                } else {                    quora.get(v.getId()).remove(i);                }            }            /*                     * This sleep time represents the time a follower                     * would take to declare the leader dead and start                     * a new leader election.                     */            Thread.sleep(100);        }        LOG.debug("Thread " + i + " votes " + v);    } catch (InterruptedException e) {        fail(e.toString());    }}
7c9326def9dc5c18efbe44d4f2877f8dbc50c30041ebc47c217346d7f4d48ae4
waitForQuorum
 boolean waitForQuorum(long id) throws InterruptedException
{    int loopCounter = 0;    while ((quora.get(id).size() <= count / 2) && (loopCounter < MAX_LOOP_COUNTER)) {        Thread.sleep(100);        loopCounter++;    }    return (loopCounter < MAX_LOOP_COUNTER) || (quora.get(id).size() > count / 2);}
9fac2fa506d7a12f58babe6e3f4a4add0d8da876d0217f1850b7fff4c312e4b5
testSingleElection
public void testSingleElection() throws Exception
{    try {        runElection(1);    } catch (Exception e) {        fail(e.toString());    }}
df27fd0cdd049580c78fe252601f5086b092127250fc0c7f11020dec19b256b4
testDoubleElection
public void testDoubleElection() throws Exception
{    try {        runElection(2);    } catch (Exception e) {        fail(e.toString());    }}
6b586af3260b1fbb8be8f465b620d4a6cc43549286e1855e73372c091dab77b1
testTripleElection
public void testTripleElection() throws Exception
{    try {        runElection(3);    } catch (Exception e) {        fail(e.toString());    }}
82b6acb05ed27f2994c288a0f9c12c8351ebaf3112c91f2c8b5dba67fc514144
runElection
private void runElection(int rounds) throws Exception
{    ConcurrentHashMap<Long, HashSet<Integer>> quora = new ConcurrentHashMap<Long, HashSet<Integer>>();    LOG.info("TestLE: " + getTestName() + ", " + count);    /*         * Creates list of peers.         */    for (int i = 0; i < count; i++) {        port[i] = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[i])));        tmpdir[i] = ClientBase.createTmpDir();    }    /*         * Start one LEThread for each peer we want to run.         */    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(this, peer, i, rounds, quora);        thread.start();        threads.add(thread);    }    LOG.info("Started threads " + getTestName());    int waitCounter = 0;    synchronized (this) {        while (((successCount <= count / 2) || (leader == -1)) && (waitCounter < MAX_LOOP_COUNTER)) {            this.wait(200);            waitCounter++;        }    }    LOG.info("Success count: " + successCount);    /*         * Lists what threads haven't joined. A thread doesn't join if         * it hasn't decided upon a leader yet. It can happen that a         * peer is slow or disconnected, and it can take longer to         * nominate and connect to the current leader.         */    for (int i = 0; i < threads.size(); i++) {        if (threads.get(i).isAlive()) {            LOG.info("Threads didn't join: " + i);        }    }    /*         * If we have a majority, then we are good to go.         */    if (successCount <= count / 2) {        fail("Fewer than a a majority has joined");    }    /*         * I'm done so joining.         */    if (!joinedThreads.contains(leader)) {        fail("Leader hasn't joined: " + leader);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    setName("VerifyState-" + peer.getId());    while (true) {        if (peer.getPeerState() == ServerState.FOLLOWING) {            LOG.info("I am following");            success = true;            break;        } else if (peer.getPeerState() == ServerState.LEADING) {            LOG.info("I am leading");            success = false;            break;        }        try {            Thread.sleep(250);        } catch (Exception e) {            LOG.warn("Sleep failed ", e);        }    }}
612931c72bde28f1dce5cd75713a8d061fc0015a7653f03c77fdbe463c352c87
isSuccess
public boolean isSuccess()
{    return success;}
eaa8dd0f7f3cc52ece091e68ee908f81cc28e2678dbc074fd4c662bd9dd77850
testJoin
public void testJoin() throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        port[sid] = PortAssignment.unique();        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[sid])));        tmpdir[sid] = ClientBase.createTmpDir();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);        LOG.info("Starting peer " + peer.getId());        peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);    LOG.info("Starting peer " + peer.getId());    peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    } else if (!v1.isSuccess()) {        fail("Incorrect LEADING state for peer " + peer.getId());    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
4fad721ff078376a6d7a6f06a9404f0626c1a0a9bdfb76396b6b3e17f8a6c763
testJoinInconsistentEnsemble
public void testJoinInconsistentEnsemble() throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[sid] = ClientBase.createTmpDir();        port[sid] = PortAssignment.unique();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);        LOG.info("Starting peer " + peer.getId());        peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        long leaderSid = peer.getCurrentVote().getId();    long zxid = peer.getCurrentVote().getZxid();    long electionEpoch = peer.getCurrentVote().getElectionEpoch();    ServerState state = peer.getCurrentVote().getState();    long peerEpoch = peer.getCurrentVote().getPeerEpoch();    Vote newVote = new Vote(leaderSid, zxid + 100, electionEpoch + 100, peerEpoch, state);    peer.setCurrentVote(newVote);        peer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 2000, 2, 2, 2);    LOG.info("Starting peer " + peer.getId());    peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
3bc02598434a0618c124d9785cf4aa1a63a18add662933304f53f09da3c52ce2
testElectionTimeUnit
public void testElectionTimeUnit() throws Exception
{    assertEquals("MS", QuorumPeer.FLE_TIME_UNIT);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    count = 9;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    String config = "group.1=0:1:2\n" + "group.2=3:4:5\n" + "group.3=6:7:8\n" + "weight.0=1\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=0\n" + "weight.4=0\n" + "weight.5=0\n" + "weight.6=0\n" + "weight.7=0\n" + "weight.8=0";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        LEThread leThread = threads.get(i);                                QuorumBase.shutdown(leThread.peer);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Vote v = null;        fail = false;        while (true) {                        peer.setPeerState(ServerState.LOOKING);            LOG.info("Going to call leader election.");            v = peer.getElectionAlg().lookForLeader();            if (v == null) {                LOG.info("Thread " + i + " got a null vote");                return;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);            LOG.info("Finished election: " + i + ", " + v.getId());            votes[i] = v;            if ((peer.getPeerState() == ServerState.LEADING) && (peer.getId() > 2)) {                fail = true;            }            if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {                break;            }        }        LOG.debug("Thread " + i + " votes " + v);    } catch (InterruptedException e) {        e.printStackTrace();    }}
70c5534cb8395e0b7550c51aef868368d841c1db5a58e9ab0428ab63de77255a
testZeroWeightQuorum
public void testZeroWeightQuorum() throws Exception
{    LOG.info("TestZeroWeightQuorum: " + getTestName() + ", " + count);    for (int i = 0; i < count; i++) {        InetSocketAddress addr1 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr2 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr3 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        port[i] = addr3.getPort();        qp.setProperty("server." + i, "127.0.0.1:" + addr1.getPort() + ":" + addr2.getPort() + ";" + port[i]);        peers.put(Long.valueOf(i), new QuorumServer(i, addr1, addr2, addr3));        tmpdir[i] = ClientBase.createTmpDir();    }    for (int i = 0; i < count; i++) {        QuorumHierarchical hq = new QuorumHierarchical(qp);        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2, hq);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }    LOG.info("Started threads " + getTestName());    for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(15000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        } else {            if (threads.get(i).fail) {                fail("Elected zero-weight server");            }        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    pending.set(0);    errors.set(0);    counter.set(0);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("Error count {}", errors.get());}
632d6aaffe0e4e639d37fa599257ef74e6f65a405d16617445539990aec05758
testLaggingFollowerResyncsUnderNewEpoch
public void testLaggingFollowerResyncsUnderNewEpoch() throws Exception
{    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    QuorumUtil qu = new QuorumUtil(1);    qu.shutdownAll();    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    ZooKeeper zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);    LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));    final String resyncPath = "/resyncundernewepoch";    zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.close();    qu.shutdown(1);    qu.shutdown(2);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(3);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT));    zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);    LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));    assertNotNull("zk1 has data", zk1.exists(resyncPath, false));    final ZooKeeper zk2 = createClient(qu.getPeer(2).peer.getClientPort(), watcher2);    LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));    assertNotNull("zk2 has data", zk2.exists(resyncPath, false));    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);    LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));    assertNotNull("zk3 has data", zk3.exists(resyncPath, false));    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
9077ce2f98218c7fc95465cc2bae4c96868e9195258479a795fad37cd5f16738
testResyncBySnapThenDiffAfterFollowerCrashes
public void testResyncBySnapThenDiffAfterFollowerCrashes() throws Throwable
{    followerResyncCrashTest(false);}
856eac31aff2ae0a92a8521121c6fb5c0527bb1b6aa3ae76af8860424294d855
testResyncByTxnlogThenDiffAfterFollowerCrashes
public void testResyncByTxnlogThenDiffAfterFollowerCrashes() throws Throwable
{    followerResyncCrashTest(true);}
cd1d0a8d68b1b5e347a63adeb9fdd0e5102fe79c4951b416c58f33827c6d2932
followerResyncCrashTest
public void followerResyncCrashTest(boolean useTxnLogResync) throws Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    if (useTxnLogResync) {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(1000);    } else {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(-1);    }    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;    LOG.info("Connecting to follower: {}", index);    qu.shutdown(index);    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);    LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));    zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    qu.restart(index);    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);    LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);    LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));    zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            for (int i = 0; i < 3000; i++) {                                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                    @Override                    public void processResult(int rc, String path, Object ctx, String name) {                        pending.decrementAndGet();                        counter.incrementAndGet();                        if (rc != 0) {                            errors.incrementAndGet();                        }                        if (counter.get() == 16200) {                            sem.release();                        }                    }                }, null);                pending.incrementAndGet();                if (i % 10 == 0) {                    try {                        Thread.sleep(100);                    } catch (Exception e) {                    }                }            }        }    });        for (int i = 0; i < 13000; i++) {                zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 5000) {            qu.shutdown(index);            LOG.info("Shutting down s1");        }        if (i == 12000) {                                                            mytestfooThread.start();            LOG.info("Restarting follower: {}", index);            qu.restart(index);            Thread.sleep(300);            LOG.info("Shutdown follower: {}", index);            qu.shutdown(index);            Thread.sleep(300);            LOG.info("Restarting follower: {}", index);            qu.restart(index);            LOG.info("Setting up server: {}", index);        }        if ((i % 1000) == 0) {            Thread.sleep(1000);        }        if (i % 50 == 0) {            zk2.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() == 16200) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        LOG.warn("Did not aquire semaphore fast enough");    }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {        LOG.error("mytestfooThread is still alive");    }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));    verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    for (int i = 0; i < 3000; i++) {                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i % 10 == 0) {            try {                Thread.sleep(100);            } catch (Exception e) {            }        }    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
0bee12faf60a42a1feb05cf9e2bb9e53e1c4f0def5d8d7fac150e267a71ff9e8
testResyncByDiffAfterFollowerCrashes
public void testResyncByDiffAfterFollowerCrashes() throws IOException, InterruptedException, KeeperException, Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;    LOG.info("Connecting to follower: {}", index);    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);    LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));    final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);    LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);    LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));    zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    final AtomicBoolean runNow = new AtomicBoolean(false);    Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            int inSyncCounter = 0;            while (inSyncCounter < 400) {                if (runNow.get()) {                    zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                        @Override                        public void processResult(int rc, String path, Object ctx, String name) {                            pending.decrementAndGet();                            counter.incrementAndGet();                            if (rc != 0) {                                errors.incrementAndGet();                            }                            if (counter.get() > 7300) {                                sem.release();                            }                        }                    }, null);                    pending.incrementAndGet();                    try {                        Thread.sleep(10);                    } catch (Exception e) {                    }                    inSyncCounter++;                } else {                    Thread.yield();                }            }        }    });    mytestfooThread.start();    for (int i = 0; i < 5000; i++) {        zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() > 7300) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 1000) {            qu.shutdown(index);            Thread.sleep(1100);            LOG.info("Shutting down s1");        }        if (i == 1100 || i == 1150 || i == 1200) {            Thread.sleep(1000);        }        if (i == 1200) {            qu.startThenShutdown(index);            runNow.set(true);            qu.restart(index);            LOG.info("Setting up server: {}", index);        }        if (i >= 1000 && i % 2 == 0) {            zk3.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }        if (i == 1050 || i == 1100 || i == 1150) {            Thread.sleep(1000);        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        LOG.warn("Did not aquire semaphore fast enough");    }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {        LOG.error("mytestfooThread is still alive");    }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));        verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    int inSyncCounter = 0;    while (inSyncCounter < 400) {        if (runNow.get()) {            zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();            try {                Thread.sleep(10);            } catch (Exception e) {            }            inSyncCounter++;        } else {            Thread.yield();        }    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
66cc2435450d2d24ea2a5717bfd53de4a7ba1c8a786d5c41cf6c28ad3e422401
createClient
private static DisconnectableZooKeeper createClient(int port, CountdownWatcher watcher) throws IOException, TimeoutException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper("127.0.0.1:" + port, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
de17d41b1569fe7d9d51ae0a04c3e60b68ea2bee9a4dd070f3ab24d075d8051f
waitForPendingRequests
private boolean waitForPendingRequests(int timeout) throws InterruptedException
{    LOG.info("Wait for pending requests: {}", pending.get());    for (int i = 0; i < timeout; ++i) {        Thread.sleep(1000);        if (pending.get() == 0) {            return true;        }    }    LOG.info("Timeout waiting for pending requests: {}", pending.get());    return false;}
a61ec8b5384683e5a343b7465d3337800bf831cf4f60964695ba3884de52d304
waitForSync
private boolean waitForSync(QuorumUtil qu, int index, int timeout) throws InterruptedException
{    LOG.info("Wait for server to sync");    int leaderIndex = (index == 1) ? 2 : 1;    ZKDatabase restartedDb = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase cleanDb = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase leadDb = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    long leadZxid = 0;    long cleanZxid = 0;    long restartedZxid = 0;    for (int i = 0; i < timeout; ++i) {        leadZxid = leadDb.getDataTreeLastProcessedZxid();        cleanZxid = cleanDb.getDataTreeLastProcessedZxid();        restartedZxid = restartedDb.getDataTreeLastProcessedZxid();        if (leadZxid == cleanZxid && leadZxid == restartedZxid) {            return true;        }        Thread.sleep(1000);    }    LOG.info("Timeout waiting for zxid to sync: leader 0x{}" + "clean 0x{}" + "restarted 0x{}", Long.toHexString(leadZxid), Long.toHexString(cleanZxid), Long.toHexString(restartedZxid));    return false;}
009ff10f2ffc6429c7a6040c0d8b63d0332e2d0708651aecfdddba2351cf6704
createTestableClient
private static TestableZooKeeper createTestableClient(String hp) throws IOException, TimeoutException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createTestableClient(watcher, hp);}
f410350073f2d7d43d2ac90c21fbb2886618c407bfd930536ed3609ad9014e0b
createTestableClient
private static TestableZooKeeper createTestableClient(CountdownWatcher watcher, String hp) throws IOException, TimeoutException, InterruptedException
{    TestableZooKeeper zk = new TestableZooKeeper(hp, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
dc32446f5aace8a9c4c434476406f1ece6634c21cd6cc3ed514d6d6de2bb304d
verifyState
private void verifyState(QuorumUtil qu, int index, Leader leader)
{    LOG.info("Verifying state");    assertTrue("Not following", qu.getPeer(index).peer.follower != null);    long epochF = (qu.getPeer(index).peer.getActiveServer().getZxid() >> 32L);    long epochL = (leader.getEpoch() >> 32L);    assertTrue("Zxid: " + qu.getPeer(index).peer.getActiveServer().getZKDatabase().getDataTreeLastProcessedZxid() + "Current epoch: " + epochF, epochF == epochL);    int leaderIndex = (index == 1) ? 2 : 1;    Collection<Long> sessionsRestarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase().getSessions();    Collection<Long> sessionsNotRestarted = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase().getSessions();    for (Long l : sessionsRestarted) {        assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));    }    assertEquals("Should have same number of sessions", sessionsNotRestarted.size(), sessionsRestarted.size());    ZKDatabase restarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase clean = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    for (Long l : sessionsRestarted) {        LOG.info("Validating ephemeral for session id 0x{}", Long.toHexString(l));        assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));        Set<String> ephemerals = restarted.getEphemerals(l);        Set<String> cleanEphemerals = clean.getEphemerals(l);        for (String o : cleanEphemerals) {            if (!ephemerals.contains(o)) {                LOG.info("Restarted follower doesn't contain ephemeral {} zxid 0x{}", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));            }        }        for (String o : ephemerals) {            if (!cleanEphemerals.contains(o)) {                LOG.info("Restarted follower has extra ephemeral {} zxid 0x{}", o, Long.toHexString(restarted.getDataTree().getNode(o).stat.getMzxid()));            }        }        Set<String> leadEphemerals = lead.getEphemerals(l);        for (String o : leadEphemerals) {            if (!cleanEphemerals.contains(o)) {                LOG.info("Follower doesn't contain ephemeral from leader {} zxid 0x{}", o, Long.toHexString(lead.getDataTree().getNode(o).stat.getMzxid()));            }        }        for (String o : cleanEphemerals) {            if (!leadEphemerals.contains(o)) {                LOG.info("Leader doesn't contain ephemeral from follower {} zxid 0x{}", o, Long.toHexString(clean.getDataTree().getNode(o).stat.getMzxid()));            }        }        assertEquals("Should have same number of ephemerals in both followers", ephemerals.size(), cleanEphemerals.size());        assertEquals("Leader should equal follower", lead.getEphemerals(l).size(), cleanEphemerals.size());    }}
668b9294f513421fceb244cb0bad688da8413b997c3fa5086d7bead2ae60a46a
testFollowerSendsLastZxid
public void testFollowerSendsLastZxid() throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }    LOG.info("Connecting to follower: {}", index);    TestableZooKeeper zk = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    assertEquals(0L, zk.testableLastZxid());    zk.exists("/", false);    long lzxid = zk.testableLastZxid();    assertTrue("lzxid:" + lzxid + " > 0", lzxid > 0);    zk.close();    qu.shutdownAll();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {            LOG.warn("ignoring interrupt during event.put");        }    }}
f1bc27f853587b7c0a3b8dfa1bfec7c9144fde8a2c896953a02aa3d869b3d0a3
testFollowerWatcherResync
public void testFollowerWatcherResync() throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }    LOG.info("Connecting to follower: {}", index);    TestableZooKeeper zk1 = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    zk1.create("/foo", "foo".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher watcher = new MyWatcher();    TestableZooKeeper zk2 = createTestableClient(watcher, "localhost:" + qu.getPeer(index).peer.getClientPort());    zk2.exists("/foo", true);    watcher.reset();    zk2.testableConnloss();    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    assertArrayEquals("foo".getBytes(), zk2.getData("/foo", false, null));    assertNull(watcher.events.poll(5, TimeUnit.SECONDS));    zk1.close();    zk2.close();    qu.shutdownAll();}
0210c2ff6004c3d94ed295c37a428761f5cb1aee3d96337897c27d67b73ec9be
testFourLetterWords
public void testFourLetterWords() throws Exception
{    String[] servers = hostPort.split(",");    for (String hp : servers) {        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watches");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        TestableZooKeeper zk = createClient(hp);        String sid = getHexSessionId(zk.getSessionId());        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "dirs", "size");        zk.getData("/", true, null);        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "wchs", "watching 1");        verify(hp, "wchp", sid);        verify(hp, "wchc", sid);        verify(hp, "dirs", "size");        zk.close();        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watch");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "dirs", "size");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "mntr", "zk_version\t");    }}
4f409461bebd12e07ea685b4a3a85ecd237fb5dfa1f80f73f4ef187d14d866e7
verify
private void verify(String hp, String cmd, String expected) throws IOException, SSLContextException
{    for (HostPort hpobj : parseHostPortList(hp)) {        String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);        LOG.info("cmd " + cmd + " expected " + expected + " got " + resp);        if (cmd.equals("dump")) {            assertTrue(resp.contains(expected) || resp.contains("Sessions with Ephemerals"));        } else {            assertTrue(resp.contains(expected));        }    }}
0210c2ff6004c3d94ed295c37a428761f5cb1aee3d96337897c27d67b73ec9be
testFourLetterWords
public void testFourLetterWords() throws Exception
{    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watches");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("gtmk", "306");    verify("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("dirs", "size");    zk.getData("/", true, null);    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("wchs", "watching 1");    verify("wchp", sid);    verify("wchc", sid);    verify("dirs", "size");    zk.close();    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watch");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("mntr", "zk_server_state\tstandalone");    verify("mntr", "num_alive_connections");    verify("stat", "Connections");    verify("srvr", "Connections");    verify("dirs", "size");}
fd986a12962576bf19f16f5d5ddbf757d9e1026d5413571a0d08a552cd1a5cc7
sendRequest
private String sendRequest(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
f6d4d0f3a6d929decac8f6ba046743f23f020f9e2984598b7281dd99126eeba1
sendRequest
private String sendRequest(String cmd, int timeout) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, false, timeout);}
21766e24fcb24270fae79108cde29a773e57a417a91be0e809d44e5dc739cf25
verify
private void verify(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);    LOG.info("cmd " + cmd + " expected " + expected + " got " + resp);    assertTrue(resp.contains(expected));}
50be626495e7a320a68c85959db5bfdffc0f704aa8c5d73e6cd257da71050ab0
testValidateStatOutput
public void testValidateStatOutput() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("stat");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;        line = in.readLine();    assertTrue(Pattern.matches("^.*\\s\\d+\\.\\d+\\.\\d+-.*$", line));    assertTrue(Pattern.matches("^Clients:$", in.readLine()));    int count = 0;    while ((line = in.readLine()).length() > 0) {        count++;        assertTrue(Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+\\)$", line));    }        assertTrue(count >= 2);    line = in.readLine();    assertTrue(Pattern.matches("^Latency min/avg/max: \\d+/-?[0-9]*.?[0-9]*/\\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Received: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Sent: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Connections: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Outstanding: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Zxid: 0x[\\da-fA-F]+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Mode: .*$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Node count: \\d+$", line));    zk1.close();    zk2.close();}
fbb4abe365be649d28aaa14d7297fee8d40fe363fc77816bb3d998494326c17e
testValidateConsOutput
public void testValidateConsOutput() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("cons");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;    int count = 0;    while ((line = in.readLine()) != null && line.length() > 0) {        count++;        assertTrue(line, Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+.*\\)$", line));    }        assertTrue(count >= 2);    zk1.close();    zk2.close();}
26cc167f8d87bca3b571175115d90f7b4dd62140f9bd987acd00524fa5727f6a
testValidateSocketTimeout
public void testValidateSocketTimeout() throws Exception
{    /**     * testing positive scenario that even with timeout parameter the     * functionality works fine     */    String resp = sendRequest("isro", 2000);    assertTrue(resp.contains("rw"));}
b235f2256712af1a22e99ee5312281998131e081cf11aefa4c8d9726c31dbb8b
testSetTraceMask
public void testSetTraceMask() throws Exception
{    String gtmkResp = sendRequest("gtmk");    assertNotNull(gtmkResp);    gtmkResp = gtmkResp.trim();    assertFalse(gtmkResp.isEmpty());    long formerMask = Long.valueOf(gtmkResp);    try {        verify(buildSetTraceMaskRequest(0), "0");        verify("gtmk", "0");    } finally {                sendRequest(buildSetTraceMaskRequest(formerMask));    }}
5e3fcdf45fbd3cdf4256c19cbde31d95a40397aedbda3ddc53fe83783d884137
buildSetTraceMaskRequest
private String buildSetTraceMaskRequest(long mask) throws IOException
{    ByteArrayOutputStream baos = null;    DataOutputStream dos = null;    try {        baos = new ByteArrayOutputStream();        dos = new DataOutputStream(baos);        dos.writeBytes("stmk");        dos.writeLong(mask);    } finally {        IOUtils.closeStream(dos);        IOUtils.closeStream(baos);    }    return new String(baos.toByteArray());}
78e22360f8ee64c1bbdaac24b765024bae14e3820b880fc441545b01475fe534
testFourLetterWordsAllDisabledByDefault
public void testFourLetterWordsAllDisabledByDefault() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    startServer();        verifyAllCommandsFail();    TestableZooKeeper zk = createClient();    verifyAllCommandsFail();    zk.getData("/", true, null);    verifyAllCommandsFail();    zk.close();    verifyFuzzyMatch("stat", "Outstanding");    verifyAllCommandsFail();}
036748bc05fadb18b088e7d13188db7caabcac25be7b2e585f7362bca0845216
testFourLetterWordsEnableSomeCommands
public void testFourLetterWordsEnableSomeCommands() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat, ruok, isro");    startServer();        verifyFuzzyMatch("stat", "Outstanding");    verifyExactMatch("ruok", "imok");    verifyExactMatch("isro", "rw");        verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));}
7ab24ea553691bcdfd1ee06c13a606b9853aebd48624f24b71716ab99ff8eb17
testISROEnabledWhenReadOnlyModeEnabled
public void testISROEnabledWhenReadOnlyModeEnabled() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    System.setProperty("readonlymode.enabled", "true");    startServer();    verifyExactMatch("isro", "rw");    System.clearProperty("readonlymode.enabled");}
22ffe22d7070745b9dd8ccff670cc00873141e26253fa5e803a39e87ed399296
testFourLetterWordsInvalidConfiguration
public void testFourLetterWordsInvalidConfiguration() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "foo bar" + " foo,,, " + "bar :.,@#$%^&*() , , , , bar, bar, stat,        ");    startServer();        verifyAllCommandsFail();        verifyFuzzyMatch("stat", "Outstanding");}
7958fc8e81695daa7032134640fa7a0ebe3eaf512ea37085d665795031869028
testFourLetterWordsEnableAllCommandsThroughAsterisk
public void testFourLetterWordsEnableAllCommandsThroughAsterisk() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "*");    startServer();    verifyAllCommandsSuccess();}
8b65b1f80d92319a2f784ed516debe2c481c6787c2ad831756c3190f0a9c030d
testFourLetterWordsEnableAllCommandsThroughExplicitList
public void testFourLetterWordsEnableAllCommandsThroughExplicitList() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "ruok, envi, conf, stat, srvr, cons, dump," + "wchs, wchp, wchc, srst, crst, " + "dirs, mntr, gtmk, isro, stmk");    startServer();    verifyAllCommandsSuccess();}
fbf54172b1e45f792528ec614572a3aab40f02beb6dd5f1ac72583c18935e825
verifyAllCommandsSuccess
private void verifyAllCommandsSuccess() throws Exception
{    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watches");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("gtmk", "306");    verifyFuzzyMatch("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("dirs", "size");    zk.getData("/", true, null);    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("wchs", "watching 1");    verifyFuzzyMatch("wchp", sid);    verifyFuzzyMatch("wchc", sid);    verifyFuzzyMatch("dirs", "size");    zk.close();    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watch");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("mntr", "zk_server_state\tstandalone");    verifyFuzzyMatch("mntr", "num_alive_connections");    verifyFuzzyMatch("stat", "Connections");    verifyFuzzyMatch("srvr", "Connections");    verifyFuzzyMatch("dirs", "size");}
c7d83603ff6de93f4de46b9a759418781e4cdf5789d804df776791a2baf0089a
verifyAllCommandsFail
private void verifyAllCommandsFail() throws Exception
{    verifyExactMatch("ruok", generateExpectedMessage("ruok"));    verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));    verifyExactMatch("isro", generateExpectedMessage("isro"));        verifyFuzzyMatch("srvr", "Outstanding");}
fd986a12962576bf19f16f5d5ddbf757d9e1026d5413571a0d08a552cd1a5cc7
sendRequest
private String sendRequest(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
d1ecbf53e2ad6c95fcd986bd5e1ac2fbd4106ac4ac8a3df2b076acee5345382a
verifyFuzzyMatch
private void verifyFuzzyMatch(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);    LOG.info("cmd " + cmd + " expected " + expected + " got " + resp);    assertTrue(resp.contains(expected));}
92f13f44f7807c0ad8b0dbab9cb9779f77da1c678179729c9776872a57dcbb62
generateExpectedMessage
private String generateExpectedMessage(String command)
{    return command + " is not executed because it is not in the whitelist.";}
6757fb1d0e3d002ee2ff817373cdef0e46d7f4425e365a208c6f7e180bc12ca1
verifyExactMatch
private void verifyExactMatch(String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);    LOG.info("cmd " + cmd + " expected an exact match of " + expected + "; got " + resp);    assertTrue(resp.trim().equals(expected));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
916e69309f1b9a89ed6588b3f9b82970aaf618696f6e2ceec53302471c9f15a5
testChild
public void testChild() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat = new Stat();    List<String> s = zk.getChildren(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());    s = zk.getChildren(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());}
382fa1f163b595ec4bde60dd82e880921f10473861e4b08f82023e630699094a
testChildren
public void testChildren() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = new ArrayList<String>();    List<String> children_s = new ArrayList<String>();    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        String childname_s = "bar" + i;        children.add(childname);        children_s.add(childname_s);    }    for (int i = 0; i < children.size(); i++) {        String childname = children.get(i);        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat = new Stat();        List<String> s = zk.getChildren(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());        assertEquals(s.size(), stat.getNumChildren());    }    List<String> p = zk.getChildren(name, false, null);    List<String> c_a = children_s;    List<String> c_b = p;    Collections.sort(c_a);    Collections.sort(c_b);    assertEquals(c_a.size(), 10);    assertEquals(c_a, c_b);}
f0ebd072f1375594d4e7068447fba65c308b7474a56478c6a6149d99f7d92fae
testGetProposalFromTxn
public void testGetProposalFromTxn() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        Long[] zxids = new Long[MSG_COUNT];    try {        String data = "data";        byte[] bytes = data.getBytes();        for (int i = 0; i < MSG_COUNT; i++) {            Stat stat = new Stat();            zk.create("/invalidsnap-" + i, bytes, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/invalidsnap-" + i, null, stat);            zxids[i] = stat.getCzxid();        }    } finally {        zk.close();    }        f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();            Iterator<Proposal> itr = db.getProposalsFromTxnLog(zxids[0], 10000000);    int createCount = 0;    ArrayList<Long> retrievedZxids = new ArrayList<Long>(MSG_COUNT);        while (itr.hasNext()) {        Proposal proposal = itr.next();        TxnHeader hdr = new TxnHeader();        Record rec = SerializeUtils.deserializeTxn(proposal.packet.getData(), hdr);        if (hdr.getType() == OpCode.create) {            retrievedZxids.add(hdr.getZxid());            createCount++;        }    }        assertTrue("Zxids missmatches", Arrays.equals(zxids, retrievedZxids.toArray(new Long[0])));        assertTrue("create proposal count == " + MSG_COUNT, (createCount == MSG_COUNT));            db.setSnapshotSizeFactor(0.33);    long sizeLimit = db.calculateTxnLogSizeLimit();    itr = db.getProposalsFromTxnLog(zxids[MSG_COUNT / 2], sizeLimit);    assertFalse("Expect empty proposal", (itr.hasNext()));    f.shutdown();    zks.shutdown();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    leport1 = PortAssignment.unique();    leport2 = PortAssignment.unique();    leport3 = PortAssignment.unique();    leport4 = PortAssignment.unique();    leport5 = PortAssignment.unique();    clientport1 = PortAssignment.unique();    clientport2 = PortAssignment.unique();    clientport3 = PortAssignment.unique();    clientport4 = PortAssignment.unique();    clientport5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + clientport1 + ",127.0.0.1:" + clientport2 + ",127.0.0.1:" + clientport3 + ",127.0.0.1:" + clientport4 + ",127.0.0.1:" + clientport5;    LOG.info("Ports are: " + hostPort);    s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    String config = "group.1=1:2:3\n" + "group.2=4:5\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=1\n" + "weight.4=0\n" + "weight.5=0\n" + "server.1=127.0.0.1:" + port1 + ":" + leport1 + ";" + clientport1 + "\n" + "server.2=127.0.0.1:" + port2 + ":" + leport2 + ";" + clientport2 + "\n" + "server.3=127.0.0.1:" + port3 + ":" + leport3 + ";" + clientport3 + "\n" + "server.4=127.0.0.1:" + port4 + ":" + leport4 + ";" + clientport4 + "\n" + "server.5=127.0.0.1:" + port5 + ":" + leport5 + ";" + clientport5 + "\n";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);    startServers();    cht.hostPort = hostPort;    cht.setUpAll();    LOG.info("Setup finished");}
55c7f912e3bdbbc650628d1dfae3f15ae36da080d2d4694288944ec060b28458
startServers
 void startServers() throws Exception
{    startServers(false);}
5e75faf7716ad05969c1b9f60fb5924ed7d85841e7404e22fa33899ccbdca2fd
startServers
 void startServers(boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    HashMap<Long, QuorumServer> peers = new HashMap<>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", port1), new InetSocketAddress("127.0.0.1", leport1), new InetSocketAddress("127.0.0.1", clientport1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", port2), new InetSocketAddress("127.0.0.1", leport2), new InetSocketAddress("127.0.0.1", clientport2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", port3), new InetSocketAddress("127.0.0.1", leport3), new InetSocketAddress("127.0.0.1", clientport3)));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress("127.0.0.1", port4), new InetSocketAddress("127.0.0.1", leport4), new InetSocketAddress("127.0.0.1", clientport4), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress("127.0.0.1", port5), new InetSocketAddress("127.0.0.1", leport5), new InetSocketAddress("127.0.0.1", clientport5), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));    LOG.info("creating QuorumPeer 1 port " + clientport1);    if (withObservers) {        qp.setProperty("server.4", "127.0.0.1:" + port4 + ":" + leport4 + ":observer" + ";" + clientport4);        qp.setProperty("server.5", "127.0.0.1:" + port5 + ":" + leport5 + ":observer" + ";" + clientport5);    }    QuorumHierarchical hq1 = new QuorumHierarchical(qp);    s1 = new QuorumPeer(peers, s1dir, s1dir, clientport1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq1);    assertEquals(clientport1, s1.getClientPort());    LOG.info("creating QuorumPeer 2 port " + clientport2);    QuorumHierarchical hq2 = new QuorumHierarchical(qp);    s2 = new QuorumPeer(peers, s2dir, s2dir, clientport2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq2);    assertEquals(clientport2, s2.getClientPort());    LOG.info("creating QuorumPeer 3 port " + clientport3);    QuorumHierarchical hq3 = new QuorumHierarchical(qp);    s3 = new QuorumPeer(peers, s3dir, s3dir, clientport3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq3);    assertEquals(clientport3, s3.getClientPort());    LOG.info("creating QuorumPeer 4 port " + clientport4);    QuorumHierarchical hq4 = new QuorumHierarchical(qp);    s4 = new QuorumPeer(peers, s4dir, s4dir, clientport4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq4);    if (withObservers) {        s4.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport4, s4.getClientPort());    LOG.info("creating QuorumPeer 5 port " + clientport5);    QuorumHierarchical hq5 = new QuorumHierarchical(qp);    s5 = new QuorumPeer(peers, s5dir, s5dir, clientport5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq5);    if (withObservers) {        s5.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport5, s5.getClientPort());    LOG.info("start QuorumPeer 1");    s1.start();    LOG.info("start QuorumPeer 2");    s2.start();    LOG.info("start QuorumPeer 3");    s3.start();    LOG.info("start QuorumPeer 4" + (withObservers ? "(observer)" : ""));    s4.start();    LOG.info("start QuorumPeer 5" + (withObservers ? "(observer)" : ""));    s5.start();    LOG.info("started QuorumPeer 5");    LOG.info("Closing ports " + hostPort);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));        LOG.info(hp + " is accepting client connections");    }    final int numberOfPeers = 5;        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    for (int i = 1; i <= numberOfPeers; i++) {                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + i;        JMXEnv.ensureBeanAttribute(bean, "ConfigVersion");        JMXEnv.ensureBeanAttribute(bean, "LearnerType");        JMXEnv.ensureBeanAttribute(bean, "ClientAddress");        JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");        JMXEnv.ensureBeanAttribute(bean, "QuorumSystemInfo");        JMXEnv.ensureBeanAttribute(bean, "Leader");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            if (j != i) {                                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + j;                JMXEnv.ensureBeanAttribute(bean, "Name");                JMXEnv.ensureBeanAttribute(bean, "LearnerType");                JMXEnv.ensureBeanAttribute(bean, "ClientAddress");                JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");                JMXEnv.ensureBeanAttribute(bean, "QuorumAddress");                JMXEnv.ensureBeanAttribute(bean, "Leader");            }        }    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("TearDown started");    cht.tearDownAll();    LOG.info("Shutting down server 1");    shutdown(s1);    LOG.info("Shutting down server 2");    shutdown(s2);    LOG.info("Shutting down server 3");    shutdown(s3);    LOG.info("Shutting down server 4");    shutdown(s4);    LOG.info("Shutting down server 5");    shutdown(s5);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));        LOG.info(hp + " is no longer accepting client connections");    }    JMXEnv.tearDown();}
76c66a305e01eb33fd2c753108fa5e8a472dfd822234742cf4a930105658a51d
shutdown
protected void shutdown(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
e020061391c4c99e64b2a900513ff8c46b803dc4c97eea1533ff800109075622
createClient
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
24ee8d734782b0ca6395d1096afd1ee3a151fae7453c4685632994a5f5360512
testHierarchicalQuorum
public void testHierarchicalQuorum() throws Throwable
{    cht.runHammer(5, 10);}
4d09f9291752a1d4aefa4047e8764e695eadd6b46409bef11e5f3e8253f549e8
incOutstanding
 synchronized void incOutstanding()
{    outstanding++;}
b182fa2e828adb57dbe5c5a626218c0d91aa7025d2ff698d44fdf6a4ab5a7194
decOutstanding
 synchronized void decOutstanding()
{    outstanding--;    notifyAll();}
76be0fbe0a0d02d369f2092ccefe1691d1fef09601bc567b724b7f1671964a16
waitOutstanding
 synchronized void waitOutstanding() throws InterruptedException
{    while (outstanding > 0) {        wait();    }}
1a9cd76d75b78dfe7a7ad6d20ac6691cf3137eae1747aa157b3b1d9f28689582
run
public void run() throws InterruptedException, KeeperException
{    try {        LOG.warn("Creating znodes for " + path);        doCreate();        LOG.warn("Staring the test loop for " + path);        while (true) {            LOG.warn("Staring write cycle for " + path);            doPopulate();            waitOutstanding();            LOG.warn("Staring read cycle for " + path);            readAll();            waitOutstanding();        }    } finally {        LOG.warn("Test loop terminated for " + path);    }}
5db3b4c1bca78eb118e39ea251cd3e9feb508e1b478e88570e21ef6ad743f094
readAll
 void readAll()
{    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.getData(cpath, false, this, null);        incOutstanding();    }}
bc2ccb84b9c57727010e8e1ef343938235cf6368f413d55322c81e24ae76073b
doCreate
 void doCreate() throws InterruptedException, KeeperException
{        try {        zk.create(path, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {        }    iteration++;    byte[] v = ("" + iteration).getBytes();        for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        try {            if (i % 10 == 0) {                LOG.warn("Creating znode " + cpath);            }            zk.create(cpath, v, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException e) {                }        lastValue.put(cpath, v);    }}
bc49d2837bc5ae59237fc93cdbcf83fd1dc5f8f9f79ec0fa35d67896650b7739
doPopulate
 void doPopulate()
{    iteration++;    byte[] v = ("" + iteration).getBytes();    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.setData(cpath, v, -1, this, v);        incOutstanding();    }}
3f50635f722f2337dd12c80953e82f9c75a16849030cc5f389ed6b7f8f7a9457
ensureConnected
 synchronized void ensureConnected()
{    while (zk.getState() != ZooKeeper.States.CONNECTED) {        try {            wait();        } catch (InterruptedException e) {            return;        }    }}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length < 3) {        System.err.println("USAGE: IntegrityCheck zookeeperHostPort znode #children");        return;    }    int childrenCount = 0;    try {        childrenCount = Integer.parseInt(args[2]);    } catch (NumberFormatException e) {        e.printStackTrace();        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    try {        final IntegrityCheck ctest = new IntegrityCheck(args[0], args[1], childrenCount);        Runtime.getRuntime().addShutdownHook(new Thread() {            public void run() {                System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);            }        });        while (true) {            try {                ctest.ensureConnected();                ctest.run();            } catch (Exception e) {                e.printStackTrace();            }        }    } catch (Exception e) {        e.printStackTrace();        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc == 0) {        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        String string = new String(data);        String lastString = null;        byte[] v = lastValue.get(path);        if (v != null) {            lastString = new String(v);        }        if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {            LOG.error("ERROR: Got " + string + " expected >= " + lastString);            errorCount++;        }        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
1a3dd30a2e78b25e4d5219f5b99b51c265b35ebd8b30750cb16db0f90a56a467
testLogFormatter
public void testLogFormatter() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File logfile = new File(new File(snapDir, "version-2"), "log.274");    String[] args = { logfile.getCanonicalFile().toString() };    org.apache.zookeeper.server.LogFormatter.main(args);}
f0df751b6ae60b04294d515b9ed123aed985f4e956234bf0276563f3f42c52f0
testSnapshotFormatter
public void testSnapshotFormatter() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.272");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
f83839040e4598ceaee82462f5c523b12e77e3aa48c1943e6e95ced17484208c
testSnapshotFormatterWithNull
public void testSnapshotFormatterWithNull() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.273");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
9f29134f03759f5a2e3901b59d0d1cfb933b9f084025a12ace762b799045497d
testSnapshot
public void testSnapshot() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    ZooKeeperServer zks = new ZooKeeperServer(snapDir, snapDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    LOG.info("starting up the zookeeper server .. waiting");    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                        assertTrue(zk.exists("/9/9/8", false) != null);    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
4f9a45dffba9f7f3b036b183dc55c61f3f6851cd143ff5e292ad0f559e695323
setUp
public static void setUp() throws IOException
{    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();    JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://127.0.0.1");    cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);    cs.start();    JMXServiceURL addr = cs.getAddress();    cc = JMXConnectorFactory.connect(addr);}
7bc01499962f9db4f29ce028fa1e575b4b5f7e9b37f763467d82ccb96ea15886
tearDown
public static void tearDown()
{    try {        if (cc != null) {            cc.close();        }    } catch (IOException e) {        LOG.warn("Unexpected, ignoring", e);    }    cc = null;    try {        if (cs != null) {            cs.stop();        }    } catch (IOException e) {        LOG.warn("Unexpected, ignoring", e);    }    cs = null;}
6e3709b2f741b4798275cbc9df9067787c895449dbe79ee992394ce7273c8241
conn
public static MBeanServerConnection conn() throws IOException
{    return cc.getMBeanServerConnection();}
99d8369be664d7db1232f0a3214df141dd522446ff1901a7a780edca6824df81
ensureAll
public static Set<ObjectName> ensureAll(String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    Set<ObjectName> found;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found = new HashSet<ObjectName>();        for (String name : expectedNames) {            LOG.info("expect:" + name);            for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                    LOG.info("found:" + name + " " + bean);                    found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while ((expectedNames.length != found.size()) && (nTry < 600));    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
d97605c2a09499debeea591a1899340f9821cfe18710385dcec46e92349f5dde
ensureOnly
public static Set<ObjectName> ensureOnly(String... expectedNames) throws IOException, InterruptedException
{    LOG.info("ensureOnly:" + Arrays.toString(expectedNames));    Set<ObjectName> beans = ensureAll(expectedNames);    for (ObjectName bean : beans) {        LOG.info("unexpected:" + bean.toString());    }    assertEquals(0, beans.size());    return beans;}
d3e4e3c460a1d5074f3e177be671b20ed1ffa95768ad4960d5e3714bdcd64881
ensureNone
public static void ensureNone(String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    int nTry = 0;    boolean foundUnexpected = false;    String unexpectedName = "";    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        foundUnexpected = false;        for (String name : expectedNames) {            for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                    LOG.info("didntexpect:" + name);                    foundUnexpected = true;                    unexpectedName = name + " " + bean.toString();                    break;                }            }            if (foundUnexpected) {                break;            }        }    } while ((foundUnexpected) && (nTry < 600));    if (foundUnexpected) {        LOG.info("List of all beans follows:");        for (ObjectName bean : beans) {            LOG.info("bean:" + bean.toString());        }        fail(unexpectedName);    }}
8c981fd02411ea053bca2db67feaa6fc1c492a77fca8e3e79bf6365729b43af4
dump
public static void dump() throws IOException
{    LOG.info("JMXEnv.dump() follows");    Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {        LOG.info("bean:" + bean.toString());    }}
d57b214ddeacc57dfa0aee30dfda6627c7e1c33bbca4abc7dd107872ea713445
ensureParent
public static Set<ObjectName> ensureParent(String... expectedNames) throws IOException, InterruptedException
{    LOG.info("ensureParent:" + Arrays.toString(expectedNames));    Set<ObjectName> beans;    int nTry = 0;    Set<ObjectName> found = new HashSet<ObjectName>();    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found.clear();        for (String name : expectedNames) {            LOG.info("expect:" + name);            for (ObjectName bean : beans) {                                if (compare(bean.toString(), name)) {                    LOG.info("found:" + name + " " + bean);                    found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while (expectedNames.length != found.size() && nTry < 120);    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
e6bcd3f3e595e9627e99aa8f5f042f526a6df2b095db974ee7d66fae397d965c
ensureBeanAttribute
public static Object ensureBeanAttribute(String expectedName, String expectedAttribute) throws Exception
{    String value = "";    LOG.info("ensure bean:{}, attribute:{}", new Object[] { expectedName, expectedAttribute });    Set<ObjectName> beans;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        LOG.info("expect:" + expectedName);        for (ObjectName bean : beans) {                        if (bean.toString().equals(expectedName)) {                LOG.info("found:{} {}", new Object[] { expectedName, bean });                return conn().getAttribute(bean, expectedAttribute);            }        }    } while (nTry < 120);    fail("Failed to find bean:" + expectedName + ", attribute:" + expectedAttribute);    return value;}
27e5a8029b52dcba1c543a1a8de0128d97c758678e7a34afaa7b3291e2e72840
compare
private static boolean compare(String bean, String name)
{    String[] names = bean.split("=");    return names.length > 0 && names[names.length - 1].contains(name);}
f95b3fb6e744f16f6d17403b8639740073e9014c8f0725c4f58b418e09ca5de7
getServerBeans
public static List<ObjectName> getServerBeans() throws IOException
{    ArrayList<ObjectName> serverBeans = new ArrayList<>();    Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {        String name = bean.toString();        LOG.info("bean:" + name);        for (Pattern pattern : beanPatterns) {            if (pattern.matcher(name).find()) {                serverBeans.add(bean);            }        }    }    return serverBeans;}
450ded39769d8168416039d9f66ac121939de4a308bb6d3f27faf495320cf6b3
getServerBean
public static ObjectName getServerBean() throws Exception
{    List<ObjectName> serverBeans = getServerBeans();    if (serverBeans.size() != 1) {        throw new RuntimeException("Unable to find one and only one server bean");    }    return serverBeans.get(0);}
04eebb24f1ddc363e13ea7ca878751a2966a9d1e8715a9a90280e68cd56f54e0
testIntConversion
public void testIntConversion()
{        EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    for (KeeperState as : allStates) {        assertEquals(as, KeeperState.fromInt(as.getIntValue()));    }}
5c4c618aedd856345375abd77ed1da6831b5a277c65a4f22ba21e0c38c452ac7
testInvalidIntConversion
public void testInvalidIntConversion()
{    try {        KeeperState.fromInt(324142);        fail("Was able to create an invalid KeeperState via an integer");    } catch (RuntimeException re) {        }}
f168d7f06ecbde4e5d35844b064378224695af87a528f2338b9daf9f94dbdb71
testDeprecatedCodeOkInSwitch
public void testDeprecatedCodeOkInSwitch()
{    int test = 1;    switch(test) {        case Code.Ok:            assertTrue(true);            break;    }}
b8b7f202657726a9b033fcfc5e6d4b2e3bc67faf89d59e86b83512c9ed58b765
testCodeOKInSwitch
public void testCodeOKInSwitch()
{    Code test = Code.OK;    switch(test) {        case OK:            assertTrue(true);            break;    }}
34d981974a6b9effb0f3a03d52530bfe2a0cb0e39b5249ed1bb93a98feeb630f
createNodePrintAcl
public void createNodePrintAcl(ZooKeeper zk, String path, String testName)
{    try {        LOG.debug("KeyAuthenticationProvider Creating Test Node:" + path + ".\n");        zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL(path, null);        LOG.debug("Node: " + path + " Test:" + testName + " ACLs:");        for (ACL acl : acls) {            LOG.debug("  " + acl.toString());        }    } catch (Exception e) {        LOG.debug("  EXCEPTION THROWN", e);    }}
05195f170ff9f13092953e49dcd52f49be6b267ddded1995365bb00fccb3a4f3
preAuth
public void preAuth() throws Exception
{    ZooKeeper zk = createClient();    zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/pre", "testPreAuth");        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getChildren("/", false);        zk.create("/abc", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/abc", "testData1".getBytes(), -1);        zk.create("/key", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/key", "5".getBytes(), -1);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
086756b1c4bc3b9469d37d73572f0576dcbdcacce402e3cfccc143778dcde87f
missingAuth
public void missingAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getData("/abc", false, null);        fail("Should not be able to get data");    } catch (KeeperException correct) {        }    try {        zk.setData("/abc", "testData2".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException correct) {        } finally {        zk.close();    }}
f09777897a91b9704d05104d43f216a426f5bde3d76757ceb7bd8e600ffae2fb
validAuth
public void validAuth() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/valid", "testValidAuth");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
d84a29ab4eab1b77b7df4ca7b9a46177c3adb679f63e0179cf8a89d24bdfd42e
validAuth2
public void validAuth2() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "125".getBytes());    try {        createNodePrintAcl(zk, "/valid2", "testValidAuth2");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{            preAuth();    missingAuth();    validAuth();    validAuth2();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qu = new QuorumUtil(1);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    qu.shutdownAll();}
ff1191e10c491dea71c4d4a234126e6ad6684411e1b735760116ff03d3d25feb
testExpiredSessionWithLocalSession
public void testExpiredSessionWithLocalSession() throws Exception
{    testCreateEphemeral(true);}
756175ea3cb612e7974bc6222b755a9441638e9af11199903c61d77ca9093c8e
testExpiredSessionWithoutLocalSession
public void testExpiredSessionWithoutLocalSession() throws Exception
{    testCreateEphemeral(false);}
b430b6aa806826ee1a68c19fa00ac658a4adbb130b2e1fa299a485c912834caa
testCreateEphemeral
public void testCreateEphemeral(boolean localSessionEnabled) throws Exception
{    if (localSessionEnabled) {        qu.enableLocalSession(true);    }    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/impossible", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long fakeSessionId = (sid << 56) + 1;    LOG.info("Fake session Id: " + Long.toHexString(fakeSessionId));    Request request = new Request(null, fakeSessionId, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/impossible", null);    assertEquals("Node from fake session get created", null, stat);}
1c3b2bd6da281f72758b9980d910b4ef8f97faaa037e09409c547ee02e8da977
testCreatePersistent
public void testCreatePersistent() throws Exception
{    qu.enableLocalSession(true);    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/success", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long locallSession = (sid << 56) + 1;    LOG.info("Local session Id: " + Long.toHexString(locallSession));    Request request = new Request(null, locallSession, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/success", null);    assertTrue("Request from local sesson failed", stat != null);}
eecffbed1bfb238c88adfcc5e28a0f2574088993c4352d6f7a004270198a6ba7
testTxnFailure
public void testTxnFailure() throws Exception
{    try {        ZooKeeperServer.setDigestEnabled(true);        long count = 1;        File tmpDir = ClientBase.createTmpDir();        FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, -1, 1, 1);        for (count = 1; count <= 3; count++) {            dt.createNode("/test/" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());        }        long digestBefore = dt.getTreeDigest();        DataNode zk = dt.getNode("/test");                LOG.info("Attempting to create " + "/test/" + (count - 1));        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());        LOG.info("Attempting to create " + "/test/" + (count - 1));        digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());        LOG.info("Attempting to create " + "/test/" + (count - 1));        digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());        LOG.info("Attempting to create " + "/test/" + (count - 1));        digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());                    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
31b72701576f16c24cd965ea32316c3978d91eab4780b22be50387b1bea8800a
doOp
private void doOp(FileTxnSnapLog logFile, int type, String path, DataTree dt, DataNode parent, int cversion) throws Exception
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    int prevCversion = parent.stat.getCversion();    long prevPzxid = parent.stat.getPzxid();    List<String> child = dt.getChildren(parentName, null, null);    StringBuilder childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }    LOG.info("Children: " + childStr + " for " + parentName);    LOG.info("(cverions, pzxid): " + prevCversion + ", " + prevPzxid);    Record txn = null;    TxnHeader txnHeader = null;    if (type == ZooDefs.OpCode.delete) {        txn = new DeleteTxn(path);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.delete);    } else if (type == ZooDefs.OpCode.create) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);    } else if (type == ZooDefs.OpCode.multi) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);        List<Txn> txnList = new ArrayList<Txn>();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        txn.serialize(boa, "request");        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        Txn txact = new Txn(ZooDefs.OpCode.create, bb.array());        txnList.add(txact);        txn = new MultiTxn(txnList);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.multi);    }    logFile.processTransaction(txnHeader, dt, null, txn);    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    child = dt.getChildren(parentName, null, null);    childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }    LOG.info("Children: " + childStr + " for " + parentName);    LOG.info("(cverions, pzxid): " + newCversion + ", " + newPzxid);    assertTrue(type + " <cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));}
d8cef5746b492b8c75337aec53437dbd3b45a78e25b2bcdc8db89c5411196d2d
testPad
public void testPad() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create);    Record txn = new CreateTxn("/Test", new byte[0], null, false, 1);    txnLog.append(txnHeader, txn);    FileInputStream in = new FileInputStream(tmpDir.getPath() + "/log." + Long.toHexString(txnHeader.getZxid()));    BinaryInputArchive ia = BinaryInputArchive.getArchive(in);    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    LOG.info("Received magic : " + header.getMagic() + " Expected : " + FileTxnLog.TXNLOG_MAGIC);    assertTrue("Missing magic number ", header.getMagic() == FileTxnLog.TXNLOG_MAGIC);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    SyncRequestProcessor.setSnapCount(50);    super.setUp();}
1377b88a53dbc34f338014730d3ff1233b6c47e9a5c6cf6d5ddfbd22210f02e6
testLoad
public void testLoad() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    stopServer();        File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(0);        FileTxnIterator fileItr = (FileTxnIterator) itr;    long storageSize = fileItr.getStorageSize();    LOG.info("Txnlog size: " + storageSize + " bytes");    assertTrue("Storage size is greater than zero ", (storageSize > 0));    long expectedZxid = 0;    long lastZxid = 0;    TxnHeader hdr;    do {        hdr = itr.getHeader();        expectedZxid++;        assertTrue("not the same transaction. lastZxid=" + lastZxid + ", zxid=" + hdr.getZxid(), lastZxid != hdr.getZxid());        assertTrue("excepting next transaction. expected=" + expectedZxid + ", retrieved=" + hdr.getZxid(), (hdr.getZxid() == expectedZxid));        lastZxid = hdr.getZxid();    } while (itr.next());    assertTrue("processed all transactions. " + expectedZxid + " == " + TOTAL_TRANSACTIONS, (expectedZxid == TOTAL_TRANSACTIONS));}
eb659e0243fa17d5bd0cc04231766e6246cf9f65198c1df8486dd1d1afc7eb00
testLoadFailure
public void testLoadFailure() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/data-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    stopServer();    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] logFiles = FileTxnLog.getLogFiles(logDir.listFiles(), 0);        assertTrue(logFiles.length > NUM_MESSAGES / 100);        assertTrue("delete the first log file", logFiles[0].delete());        long secondStartZxid = Util.getZxidFromName(logFiles[1].getName(), "log");    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(1, false);            assertEquals(secondStartZxid, itr.getHeader().getZxid());    itr = txnLog.read(secondStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());            long nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());            long thirdStartZxid = Util.getZxidFromName(logFiles[2].getName(), "log");    itr = txnLog.read(thirdStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());    nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());}
24176c576330916e836ae6234b91f1c42aa8c8bb6f8b26f8d3fff581e5b2afba
testRestore
public void testRestore() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    String lastPath = null;    try {        zk.create("/invalidsnap", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < NUM_MESSAGES; i++) {            lastPath = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    String[] tokens = lastPath.split("-");    String expectedPath = "/invalidsnap/test-" + String.format("%010d", (Integer.parseInt(tokens[1])) + 1);    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    long eZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);    LOG.info("Set lastProcessedZxid to " + zks.getZKDatabase().getDataTreeLastProcessedZxid());        zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();    zks = serverFactory.getZooKeeperServer();    long fZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        assertTrue("Restore failed expected zxid=" + eZxid + " found=" + fZxid, fZxid == eZxid);    zk = createZKClient(hostPort);            String[] children;    String path;    try {        children = zk.getChildren("/invalidsnap", false).toArray(new String[0]);        path = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    } finally {        zk.close();    }    LOG.info("Expected " + expectedPath + " found " + path);    assertTrue("Error in sequential znode creation expected " + expectedPath + " found " + path, path.equals(expectedPath));    assertTrue("Unexpected number of children " + children.length + " expected " + NUM_MESSAGES, (children.length == NUM_MESSAGES));}
8de43ab09677d039535a6d7ebe499ff2712d44c64088eb5b5efca8a4edd10558
testRestoreWithTransactionErrors
public void testRestoreWithTransactionErrors() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            try {                zk.create("/invaliddir/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            } catch (NoNodeException e) {                        }        }    } finally {        zk.close();    }        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);    LOG.info("Set lastProcessedZxid to " + zks.getZKDatabase().getDataTreeLastProcessedZxid());        zks.takeSnapshot();    zks.shutdown();    stopServer();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    startServer();}
71ee44f4671a13e8788934aad1d5df60a12fad7129e9a4f50c60d991812cdf92
testDatadirAutocreate
public void testDatadirAutocreate() throws Exception
{    stopServer();    try {                System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, "false");        tmpDir = createTmpDir();        startServer();        fail("Server should not have started without datadir");    } catch (IOException e) {        LOG.info("Server failed to start - correct behavior " + e);    } finally {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT);    }}
b14bd58bff04ccd642419f2794b418ddb7b9a4105793cd5695ad91df5fd3cd0e
testReloadSnapshotWithMissingParent
public void testReloadSnapshotWithMissingParent() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    zk.create("/a", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/a", false);    long createZxId = stat.getMzxid();    zk.create("/a/b", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/a/b", -1);    zk.delete("/a", -1);        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(createZxId);    LOG.info("Set lastProcessedZxid to {}", zks.getZKDatabase().getDataTreeLastProcessedZxid());        zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());    qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());    qb.tearDown();}
bf941a64c7b99ce1895ee9b51a0e95f5c0e7ae894befe9c74c09e8687c60c999
testLocalSessionsOnFollower
public void testLocalSessionsOnFollower() throws Exception
{    testOpenCloseSession(false);}
779c5c0b5096bed8f46751db893141199c0eabe6bbc964c0bf7aadfbafbb7a0a
testLocalSessionsOnLeader
public void testLocalSessionsOnLeader() throws Exception
{    testOpenCloseSession(true);}
2dbb8bb5849323855194fb5f8adb03013d0a514c9c952df213ff2a59a2076792
validateRequestLog
private void validateRequestLog(long sessionId, int peerId)
{    String session = Long.toHexString(sessionId);    LOG.info("Searching for txn of session 0x " + session + " on peer " + peerId);    String peerType = peerId == qb.getLeaderIndex() ? "leader" : "follower";    QuorumPeer peer = qb.getPeerList().get(peerId);    ZKDatabase db = peer.getActiveServer().getZKDatabase();    for (Proposal p : db.getCommittedLog()) {        assertFalse("Should not see " + Request.op2String(p.request.type) + " request from local session 0x" + session + " on the " + peerType, p.request.sessionId == sessionId);    }}
4ed200bdfb3900c1c4833bef4f5e7000e5697526496ddc33c4e715b8a956b68e
testOpenCloseSession
public void testOpenCloseSession(boolean onLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = onLeader ? leaderIdx : followerIdx;    int verifyPeerIdx = onLeader ? followerIdx : leaderIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper client = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId1 = client.getSessionId();            client.dontReconnect();    client.disconnect();    watcher.reset();        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId2 = zk.getSessionId();        zk.close();    watcher.reset();                    Thread.sleep(CONNECTION_TIMEOUT * 2);        validateRequestLog(localSessionId1, verifyPeerIdx);        validateRequestLog(localSessionId2, verifyPeerIdx);    qb.shutdownServers();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());    qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = false;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());    qb.tearDown();}
bf941a64c7b99ce1895ee9b51a0e95f5c0e7ae894befe9c74c09e8687c60c999
testLocalSessionsOnFollower
public void testLocalSessionsOnFollower() throws Exception
{    testLocalSessions(false);}
779c5c0b5096bed8f46751db893141199c0eabe6bbc964c0bf7aadfbafbb7a0a
testLocalSessionsOnLeader
public void testLocalSessionsOnLeader() throws Exception
{    testLocalSessions(true);}
fc06621402f6aaf3af071ba08bbec0454afd9cce76b0d6a1c077dbfe5afd6539
testLocalSessions
private void testLocalSessions(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId = zk.getSessionId();        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        try {        zk.create(nodePrefix + "ephemeral", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Ephemeral node creation should fail.");    } catch (KeeperException.EphemeralOnLocalSessionException e) {    }        zk.close();        Map<String, Integer> peers = new HashMap<String, Integer>();    peers.put("leader", leaderIdx);    peers.put("follower", followerIdx);    for (Entry<String, Integer> entry : peers.entrySet()) {        watcher.reset();                        zk = qb.createClient(watcher, hostPorts[entry.getValue()], CONNECTION_TIMEOUT);        watcher.waitForConnected(CONNECTION_TIMEOUT);        long newSessionId = zk.getSessionId();        assertFalse(newSessionId == localSessionId);        for (int i = 0; i < 5; i++) {            assertNotNull("Data not exists in " + entry.getKey(), zk.exists(nodePrefix + i, null));        }                assertNull("Data exists in " + entry.getKey(), zk.exists(nodePrefix + "ephemeral", null));        zk.close();    }    qb.shutdownServers();}
abaf7a8333cdc0c314a7270b7483010283040461391667673b17ae8a006ec9ed
getFirst
public V1 getFirst()
{    return v1;}
4cf14c17f7e67f2ad968914c6cab0dc665191c3b4fecdee70c63edcbc281685b
getSecond
public V2 getSecond()
{    return v2;}
ae8c4e547c62a826354dba1199f6305bcd6cca8d065c7a7a09a27ccc4b7ea323
rmr
 void rmr(File dir) throws IOException
{    Files.walkFileTree(dir.toPath(), new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {            Files.delete(dir);            return FileVisitResult.CONTINUE;        }    });}
bff0b45ab8e0bd5dc1b657ac99583a722c0153b86e2d6e63f0f2d3a20276bc44
visitFile
public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
c77f2e4966d31b682162feb8870c28dced3997154847ab395368fdb42a93ad71
postVisitDirectory
public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException
{    Files.delete(dir);    return FileVisitResult.CONTINUE;}
5fe0a4707c7db05982a3080d4affb0ca30c6af60821f0235829954a48f50663c
getFirstLastZxid
 Pair<Long, Long> getFirstLastZxid(File logFile) throws IOException
{    File tmp = createTmpDir();    Files.copy(logFile.toPath(), new File(tmp, "log.0").toPath());    FileTxnLog txnLog = new FileTxnLog(tmp);    TxnLog.TxnIterator it = txnLog.read(0);    long firstZxid = it.getHeader().getZxid();    long lastZxid = firstZxid;    while (it.next()) {        lastZxid = it.getHeader().getZxid();    }    txnLog.close();    rmr(tmp);    return new Pair<Long, Long>(firstZxid, lastZxid);}
6c8f53298670aad6681ff91d61c321c9fc129296621cfa168bff414f2504debd
testChopper
public void testChopper() throws IOException
{    long clientId = 17;    int cxid = 77;    long zxid = 1000;    long time = 1;    int type = ZooDefs.OpCode.delete;    DeleteTxn txn = new DeleteTxn("/foo");    File tmpDir = createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    for (int i = 0; i < 100; i++) {        TxnHeader hdr = new TxnHeader(clientId, cxid, ++zxid, ++time, type);        txnLog.append(hdr, txn);    }        TxnHeader hdr = new TxnHeader(clientId, cxid, zxid + 10, ++time, type);    txnLog.append(hdr, txn);    txnLog.commit();        final File logFile = new File(tmpDir, "log." + Integer.toHexString(1001));    Pair<Long, Long> firstLast = getFirstLastZxid(logFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1110, (long) firstLast.getSecond());    File choppedFile = new File(tmpDir, "chopped_failed");    assertFalse(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1107));    choppedFile = new File(tmpDir, "chopped");    assertTrue(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1017));    firstLast = getFirstLastZxid(choppedFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1017, (long) firstLast.getSecond());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    maxCnxns = numCnxns;    super.setUp();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    SocketChannel sChannel = null;    try {        /*                 * For future unwary socket programmers: although connect 'blocks' it                 * does not require an accept on the server side to return. Therefore                 * you can not assume that all the sockets are connected at the end of                 * this for loop.                 */        sChannel = SocketChannel.open();        sChannel.connect(new InetSocketAddress(host, port));                ConnectRequest conReq = new ConnectRequest(0, 0, 10000, 0, "password".getBytes());        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        boa.writeInt(-1, "len");        conReq.serialize(boa, "connect");        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.capacity() - 4);        bb.rewind();        /* Send a connect request. Any socket that has been closed (or at least                 * not added to the cnxn list on the server) will not have any bytes to                 * read and get an eof.                 *                 *  The trick here was finding a call that caused the server to put                 *  bytes in the input stream without closing the cnxn. None of                 *  the four letter commands do that, so we actually try to create                 *  a session which should send us something back, while maintaining                 *  the connection.                 */        int eof = sChannel.write(bb);                        sChannel.socket().setSoTimeout(10000);        if (!sChannel.socket().isClosed()) {            eof = sChannel.socket().getInputStream().read();            if (eof != -1) {                numConnected.incrementAndGet();            }        }    } catch (IOException io) {        } finally {        if (sChannel != null) {            try {                sChannel.close();            } catch (Exception e) {                        }        }    }}
d68bdd44d00e57b3a55a7b94784955daa5f0589ca70b361db12ce1370eb10686
testMaxCnxns
public void testMaxCnxns() throws IOException, InterruptedException
{    String[] split = hostPort.split(":");    host = split[0];    port = Integer.parseInt(split[1]);    int numThreads = numCnxns + 5;    CnxnThread[] threads = new CnxnThread[numThreads];    for (int i = 0; i < numCnxns; ++i) {        threads[i] = new CnxnThread(i);    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].start();    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].join();    }    assertSame(numCnxns, numConnected.get());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();    pendingOps.set(0);}
89ee7e48431032ec3becfc7a77e9aa82b60aea50ad998d5b646d0b374f56548d
finishPendingOps
private void finishPendingOps()
{    if (pendingOps.decrementAndGet() == 0) {        synchronized (pendingOps) {            pendingOps.notifyAll();        }    }}
4f7af31260dd9e642e082ea14a9bab7cb07a4a700b083b91b1579aa3913d1159
waitForPendingOps
private void waitForPendingOps(int timeout) throws Exception
{    synchronized (pendingOps) {        while (pendingOps.get() > 0) {            pendingOps.wait(timeout);        }    }}
3d6ae2528c6b6d1aa30669f988195435558ba46568ba306dcb3be9eae5e0a54e
testSequentialNodeCreateInAsyncMulti
public void testSequentialNodeCreateInAsyncMulti() throws Exception
{    final int iteration = 4;    final List<MultiResult> results = new ArrayList<MultiResult>();    pendingOps.set(iteration);    List<Op> ops = Arrays.asList(Op.create("/node-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.create("/dup", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    for (int i = 0; i < iteration; ++i) {        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                MultiResult result = new MultiResult();                result.results = opResults;                result.rc = rc;                results.add(result);                finishPendingOps();            }        }, null);    }    waitForPendingOps(CONNECTION_TIMEOUT);        assertEquals(KeeperException.Code.OK.intValue(), results.get(0).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(1).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(2).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(3).rc);        assertTrue(results.get(0).results.get(0) instanceof CreateResult);    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(1).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(2).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(3).results.get(0)).getErr());        assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(1).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(2).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(3).results.get(1)).getErr());}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    MultiResult result = new MultiResult();    result.results = opResults;    result.rc = rc;    results.add(result);    finishPendingOps();}
a7e0cbe38199f9da3827a95ddb09627bc1388241b04e73e76cb8d38509652c45
configs
public static Collection<Object[]> configs()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    SyncRequestProcessor.setSnapCount(150);    super.setUp();    zk = createClient();}
b6adb1e9552e2841bd8c279be8b6db9a51bb6e6feb1a8415f3e7f988fc11573c
multi
private List<OpResult> multi(ZooKeeper zk, Iterable<Op> ops) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }                if (KeeperException.Code.OK.intValue() != res.rc && ops.iterator().next().getKind() != Op.OpKind.READ) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return zk.multi(ops);    }}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
12e82e120400d266476b136ac8cdd965c917f7d5d9b84880d37e9052b03b3a99
multiHavingErrors
private void multiHavingErrors(ZooKeeper zk, Iterable<Op> ops, List<Integer> expectedResultCodes, String expectedErr) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        for (int i = 0; i < res.results.size(); i++) {            OpResult opResult = res.results.get(i);            assertTrue("Did't receive proper error response", opResult instanceof ErrorResult);            ErrorResult errRes = (ErrorResult) opResult;            assertEquals("Did't receive proper error code", expectedResultCodes.get(i).intValue(), errRes.getErr());        }    } else {        try {            zk.multi(ops);            fail("Shouldn't have validated in ZooKeeper client!");        } catch (KeeperException e) {            assertEquals("Wrong exception", expectedErr, e.code().name());        } catch (IllegalArgumentException e) {            assertEquals("Wrong exception", expectedErr, e.getMessage());        }    }}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
813333e00b48ca43efa1c5aa263f960172d3186ec90c7657fb7538c1e4e1a801
commit
private List<OpResult> commit(Transaction txn) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        txn.commit(new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        if (KeeperException.Code.OK.intValue() != res.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return txn.commit();    }}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
778500633553cbb243e72737202ca9753665e95b6724d832790018e1336d62c7
testInvalidPath
public void testInvalidPath() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL.toFlag()), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    expectedErr = "Path must start with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.check("/multi0", -1), Op.check("/multi1/", 100), Op.check("/multi2", 5));    expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete("/multi1/", 100), Op.delete("/multi2", 5));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        opList = Arrays.asList(Op.setData("/multi0", new byte[0], -1), Op.setData("/multi1/", new byte[0], -1), Op.setData("/multi2", new byte[0], -1), Op.setData("multi3", new byte[0], -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
e866609a80e7b77e10c93c6796f95086a4c61ec34f657fbe148dc6690e6548e3
testMultiRollback
public void testMultiRollback() throws Exception
{    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeper epheZk = createClient();    epheZk.create("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    List<Op> opList = Arrays.asList(Op.delete("/foo", -1));    try {        zk.multi(opList);        fail("multi delete should failed for not empty directory");    } catch (KeeperException.NotEmptyException e) {    }    final CountDownLatch latch = new CountDownLatch(1);    zk.exists("/foo/bar", event -> {        if (event.getType() == Watcher.Event.EventType.NodeDeleted) {            latch.countDown();        }    });    epheZk.close();    latch.await();    try {        zk.getData("/foo/bar", false, null);        fail("ephemeral node should have been deleted");    } catch (KeeperException.NoNodeException e) {    }    zk.multi(opList);    try {        zk.getData("/foo", false, null);        fail("persistent node should have been deleted after multi");    } catch (KeeperException.NoNodeException e) {    }}
b0b4ed323e514b461e63b4721f03628566437b9556cd068c6eed7d17aef47992
testBlankPath
public void testBlankPath() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        String expectedErr = "Path cannot be null";    List<Op> opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete(null, 100), Op.delete("/multi2", 5), Op.delete("", -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
c21c667a0c5aef4600f618a2871cc2e1962b125580cf3e49a5a84de184b18e4b
testInvalidCreateModeFlag
public void testInvalidCreateModeFlag() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    int createModeFlag = 6789;    List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, createModeFlag), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = KeeperException.Code.BADARGUMENTS.name();    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
090bdcbe0e6528956a5720a6305779aded6f8f6e0f3dd17a25adf6ff2594ce8a
testChRootCreateDelete
public void testChRootCreateDelete() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    Op createChild = Op.create("/myid", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk_chroot, Arrays.asList(createChild));    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists("/myid", false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists("/myid", false));        Op deleteChild = Op.delete("/myid", 0);    multi(zk_chroot, Arrays.asList(deleteChild));    assertNull("zNode exists under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNull("zNode exists under chroot:" + chRoot, zk_chroot.exists("/myid", false));}
160c52045f5d8dd415b97ce4612c08c12034853ca51a3dd208c63d85fdc623e4
testChRootSetData
public void testChRootSetData() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk_chroot, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals("zNode data not matching", names[i].getBytes(), zk_chroot.getData(names[i], false, null));    }}
2b319484d5fb554798c4bd4306fe6d16f6448e2cae5e271da27217acc448e691
testChRootCheck
public void testChRootCheck() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        zk.create(chRoot + names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    for (int i = 0; i < names.length; i++) {        ops.add(Op.check(names[i], 0));    }    multi(zk_chroot, ops);}
4b572405f7ca2061a4112ec083b713fa22408a6afedca2a659475c69049ae665
testChRootTransaction
public void testChRootTransaction() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String childPath = "/myid";    Transaction transaction = zk_chroot.transaction();    transaction.create(childPath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    transaction.check(childPath, 0);    transaction.setData(childPath, childPath.getBytes(), 0);    commit(transaction);    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + childPath, false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists(childPath, false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists(childPath, false));    assertArrayEquals("zNode data not matching", childPath.getBytes(), zk_chroot.getData(childPath, false, null));    transaction = zk_chroot.transaction();        transaction.delete(childPath, 1);    commit(transaction);    assertNull("chroot:" + chRoot + " exists after delete", zk.exists(chRoot + "/myid", false));    assertNull("chroot:" + chRoot + " exists after delete", zk_chroot.exists("/myid", false));}
b6481e738f46a9f41af82c367e11354dd1f73049245675527aceab0982b64af4
createNameSpace
private String createNameSpace() throws InterruptedException, KeeperException
{        String chRoot = "/appsX";    Op createChRoot = Op.create(chRoot, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk, Arrays.asList(createChRoot));    return chRoot;}
a66dfa0a0dc44c8498730b66bb882e7c65e66f27e31ffe53ff36181d8fbb6615
testCreate
public void testCreate() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);}
66b332fa6aec521e42453e829da7d0a6bbf4b339c5e01afb360954aac12ce9d9
testCreateDelete
public void testCreateDelete() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi", null));}
752595ad9835474feac57e5b2baec75a25fd8bf5d7386e1cf7c4509dc9bfd102
testInvalidVersion
public void testInvalidVersion() throws Exception
{    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 1)));        fail("delete /multi should have failed");    } catch (KeeperException e) {    /* PASS */    }}
541ad293bd9b1489b120d5aec4cb76e7ad1de2118db975f6a1c0332efba38ea7
testNestedCreate
public void testNestedCreate() throws Exception
{    multi(zk, Arrays.asList(/* Create */    Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a/1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), /* Delete */    Op.delete("/multi/a/1", 0), Op.delete("/multi/a", 0), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi/a/1", null));    assertNull(zk.exists("/multi/a", null));    assertNull(zk.exists("/multi", null));}
cd25e4c2d2b01bc45010c8ec6810d690e89e0778f3936e98d4a7344b326216d0
testSetData
public void testSetData() throws Exception
{    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals(names[i].getBytes(), zk.getData(names[i], false, null));    }}
841b1076fca0d982ca600f73943a85293a8e6369edd4e65639cb9c3683f06344
testUpdateConflict
public void testUpdateConflict() throws Exception
{    assertNull(zk.exists("/multi", null));    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("Should have thrown a KeeperException for invalid version");    } catch (KeeperException e) {                LOG.error("STACKTRACE: ", e);    }    assertNull(zk.exists("/multi", null));        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 1)));    assertArrayEquals(zk.getData("/multi", false, null), "Y".getBytes());}
61442e1adbdf7d0c6bcc50faa88ca451ce0590c09b50f40f87dbdf5e6566da98
testDeleteUpdateConflict
public void testDeleteUpdateConflict() throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("/multi should have been deleted so setData should have failed");    } catch (KeeperException e) {    /* PASS */    }        assertNull(zk.exists("/multi", null));}
004bc5d6caad27c461035a2a5d6d25aecdbdd985a0389d6a5277140dda8dcbc0
testGetResults
public void testGetResults() throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    Iterable<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0), Op.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    List<OpResult> results = null;    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        assertFalse("/multi should have been deleted so setData should have failed", KeeperException.Code.OK.intValue() == res.rc);        assertNull(zk.exists("/multi", null));        results = res.results;    } else {        try {            zk.multi(ops);            fail("/multi should have been deleted so setData should have failed");        } catch (KeeperException e) {                        assertNull(zk.exists("/multi", null));            results = e.getResults();        }    }    assertNotNull(results);    for (OpResult r : results) {        LOG.info("RESULT==> {}", r);        if (r instanceof ErrorResult) {            ErrorResult er = (ErrorResult) r;            LOG.info("ERROR RESULT: {} ERR=>{}", er, KeeperException.Code.get(er.getErr()));        }    }}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
bb91b6aa74a2e2640f333ba681c4960721213f47413937a639bddec4d59c1ae9
testOpResultEquals
public void testOpResultEquals()
{    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("nope"));    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("nope", new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo"));    opEquals(new CheckResult(), new CheckResult(), null);    opEquals(new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));    opEquals(new DeleteResult(), new DeleteResult(), null);    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));}
e6f15ed51b85fa364ae4fbcf1914aa00eaad70620345b683e4e85a37757eafb8
opEquals
private void opEquals(OpResult expected, OpResult value, OpResult near)
{    assertEquals(value, value);    assertFalse(value.equals(new Object()));    assertFalse(value.equals(near));    assertFalse(value.equals(value instanceof CreateResult ? new ErrorResult(1) : new CreateResult("nope2")));    assertTrue(value.equals(expected));}
6b71995b3a054bf1c4e4253817ac0b552ae81ac89693c2d0d826ad6c5690c585
testWatchesTriggered
public void testWatchesTriggered() throws KeeperException, InterruptedException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/t", -1)));    assertTrue(watcher.triggered.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
57c2910b8abe07fa052ce1f3ddcd6b8b85fb0c69d7d1224ee684caddede12fe9
testNoWatchesTriggeredForFailedMultiRequest
public void testNoWatchesTriggeredForFailedMultiRequest() throws InterruptedException, KeeperException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    try {        multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexisting", -1)));        fail("expected previous multi op to fail!");    } catch (KeeperException.NoNodeException e) {        }    SyncCallback cb = new SyncCallback();    zk.sync("/", cb, null);        cb.done.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(1, watcher.triggered.getCount());}
81f4a2fb0d21cedc50bf7a86fc68db83b6c49ae2835b02fb72726a0d85e496b7
testTransactionBuilder
public void testTransactionBuilder() throws Exception
{    List<OpResult> results = commit(zk.transaction().create("/t1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t1/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL));    assertEquals(3, results.size());    for (OpResult r : results) {        CreateResult c = (CreateResult) r;        assertTrue(c.getPath().startsWith("/t"));        assertNotNull(c.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNotNull(zk.exists("/t1/child", false));    assertNotNull(zk.exists("/t2", false));    results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    for (OpResult r : results) {        CheckResult c = (CheckResult) r;        assertNotNull(c.toString());    }    try {        results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 1));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 0).setData("/t1", new byte[0], 0));    assertEquals(2, results.size());    for (OpResult r : results) {        assertNotNull(r.toString());    }    try {        results = commit(zk.transaction().check("/t1", 1).setData("/t1", new byte[0], 2));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 1).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    results = commit(zk.transaction().delete("/t2", -1).delete("/t1/child", -1));    assertEquals(2, results.size());    for (OpResult r : results) {        DeleteResult d = (DeleteResult) r;        assertNotNull(d.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNull(zk.exists("/t1/child", false));    assertNull(zk.exists("/t2", false));}
c293d9f4e12a7f064825f2a99016609455042c9114e3cccfbeeed275a19338dc
testMultiGetChildren
public void testMultiGetChildren() throws Exception
{    List<String> topLevelNodes = new ArrayList<String>();    Map<String, List<String>> childrenNodes = new HashMap<String, List<String>>();        for (int i = 0; i < 10; i++) {        String name = "/foo" + i;        zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        topLevelNodes.add(name);        childrenNodes.put(name, new ArrayList<>());        for (int j = 0; j < 10; j++) {            String childname = name + "/bar" + i + j;            String childname_s = "bar" + i + j;            zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            childrenNodes.get(name).add(childname_s);        }    }        List<OpResult> multiChildrenList = multi(zk, topLevelNodes.stream().map(Op::getChildren).collect(Collectors.toList()));    for (int i = 0; i < topLevelNodes.size(); i++) {        String nodeName = topLevelNodes.get(i);        assertTrue(multiChildrenList.get(i) instanceof OpResult.GetChildrenResult);        List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(i)).getChildren();                assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(childrenNodes.get(nodeName)));        List<String> children = zk.getChildren(nodeName, false);        assertEquals(childrenList, children);    }}
a9d5e959f16f0e08a32de9a4914c447fe876af4017a1be02384fed86b7eac706
testMultiGetChildrenSameNode
public void testMultiGetChildrenSameNode() throws Exception
{    List<String> childrenNodes = new ArrayList<String>();        String topLevelNode = "/foo";    zk.create(topLevelNode, topLevelNode.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = topLevelNode + "/bar" + i;        String childname_s = "bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        childrenNodes.add(childname_s);    }        List<OpResult> sameChildrenList = multi(zk, Arrays.asList(Op.getChildren(topLevelNode), Op.getChildren(topLevelNode)));        assertEquals(sameChildrenList.size(), 2);    assertEquals(sameChildrenList.get(0), sameChildrenList.get(1));        assertTrue(sameChildrenList.get(0) instanceof OpResult.GetChildrenResult);    OpResult.GetChildrenResult gcr = (OpResult.GetChildrenResult) sameChildrenList.get(0);        assertEquals(new TreeSet<String>(gcr.getChildren()), new TreeSet<String>(childrenNodes));}
b656a4bad1c1d50b0a3e8e52e154467c724bea3e896958d8d2a94a05f98dd198
testMultiGetChildrenAuthentication
public void testMultiGetChildrenAuthentication() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);        List<OpResult> multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());}
5ed2cb053577824c128cff61bc7905e3eb99f27909515cfc9528da3cf0e612b8
testMultiGetChildrenMixedAuthenticationErrorFirst
public void testMultiGetChildrenMixedAuthenticationErrorFirst() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);    List<OpResult> multiChildrenList;        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth"), Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());    assertTrue(multiChildrenList.get(1) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(1)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");}
f5e903330d3a0f81372194300602630bb6d0f39c1a3010a58e3770bfa5075a66
testMultiGetChildrenMixedAuthenticationCorrectFirst
public void testMultiGetChildrenMixedAuthenticationCorrectFirst() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);            List<OpResult> multiChildrenList;    multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth"), Op.getChildren("/foo_no_auth")));    assertSame(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");    assertTrue(multiChildrenList.get(1) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(1)).getErr(), KeeperException.Code.NOAUTH.intValue());}
8764602d9135eb6482a163efbfb175592590d60f35b16593b2a8fc6b86a2579d
testMultiGetData
public void testMultiGetData() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiData = multi(zk, Arrays.asList(Op.getData("/node1"), Op.getData("/node2")));    assertEquals(multiData.size(), 2);    assertArrayEquals(((OpResult.GetDataResult) multiData.get(0)).getData(), "data1".getBytes());    assertArrayEquals(((OpResult.GetDataResult) multiData.get(1)).getData(), "data2".getBytes());}
beafd5448e948b72245a17d9397d232eebde361f1584913f1cece412594070c1
testMultiRead
public void testMultiRead() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.create("/node1/node1", "data11".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node1/node2", "data12".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiRead = multi(zk, Arrays.asList(Op.getChildren("/node1"), Op.getData("/node1"), Op.getChildren("/node2"), Op.getData("/node2")));    assertEquals(multiRead.size(), 4);    assertTrue(multiRead.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiRead.get(0)).getChildren();    assertEquals(childrenList.size(), 2);    assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(Arrays.asList("node1", "node2")));    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(1)).getData(), "data1".getBytes());    Stat stat = ((OpResult.GetDataResult) multiRead.get(1)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(2, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(2, stat.getNumChildren());    assertTrue(multiRead.get(2) instanceof OpResult.GetChildrenResult);    childrenList = ((OpResult.GetChildrenResult) multiRead.get(2)).getChildren();    assertTrue(childrenList.isEmpty());    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(3)).getData(), "data2".getBytes());    stat = ((OpResult.GetDataResult) multiRead.get(3)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getMzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
642af0a7fc5f4d5486f553d226708f9a9e95397e7cb212483bada6be3fae4845
testMixedReadAndTransaction
public void testMixedReadAndTransaction() throws Exception
{    zk.create("/node", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        List<OpResult> multiRead = multi(zk, Arrays.asList(Op.setData("/node1", "data1".getBytes(), -1), Op.getData("/node1")));        fail("Mixed kind of operations are not allowed");    } catch (IllegalArgumentException e) {        }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    triggered.countDown();}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    done.countDown();}
ca86f0db8b699367a1e071192b0ab724903096b25a11d522de42a85bae0700a9
setUp
public static void setUp()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ClientCnxnSocketNetty.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
7bc01499962f9db4f29ce028fa1e575b4b5f7e9b37f763467d82ccb96ea15886
tearDown
public static void tearDown()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);}
7a41fc174399e969efa145954d1604a7c2cfd2c9150f5f9e197e58524de38921
setUpTest
public void setUpTest() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
924be818da79eae0dc1b306d7e406b7aa61e97ec3d49cdae94670169255e3305
tearDownTest
public void tearDownTest() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
e05bb4d16539c0ff235d0ad50f4a1d304d72eaf39689b2bd277e99d43c5c257a
testFileDescriptorLeak
public void testFileDescriptorLeak() throws Exception
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {        LOG.info("Unable to run test on non-unix system");        return;    }    long startFdCount = osMbean.getOpenFileDescriptorCount();    LOG.info("Start fdcount is: " + startFdCount);    for (int i = 0; i < 50; ++i) {        NIOServerCnxnFactory factory = new NIOServerCnxnFactory();        factory.configure(new InetSocketAddress("127.0.0.1", PortAssignment.unique()), 10);        factory.start();        Thread.sleep(100);        factory.shutdown();    }    long endFdCount = osMbean.getOpenFileDescriptorCount();    LOG.info("End fdcount is: " + endFdCount);        assertTrue("Possible fd leakage", ((endFdCount - startFdCount) < 50));}
ca86f0db8b699367a1e071192b0ab724903096b25a11d522de42a85bae0700a9
setUp
public static void setUp()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
7bc01499962f9db4f29ce028fa1e575b4b5f7e9b37f763467d82ccb96ea15886
tearDown
public static void tearDown()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
7a41fc174399e969efa145954d1604a7c2cfd2c9150f5f9e197e58524de38921
setUpTest
public void setUpTest() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
924be818da79eae0dc1b306d7e406b7aa61e97ec3d49cdae94670169255e3305
tearDownTest
public void tearDownTest() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
94136f72e9d0ed1786e9b9541f42d218ed3dcc75a6fda2bfbaca891c027bd2dd
testZooKeeperServiceAvailableOnLeader
public void testZooKeeperServiceAvailableOnLeader() throws Exception
{    int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";    zk.create(NODE_PATH, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        QuorumPeer leader = getLeaderQuorumPeer(mt);    assertNotNull("Leader must have been elected by now", leader);        FileTxnSnapLog snapLog = leader.getActiveServer().getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase originalZKDatabase = leader.getActiveServer().getZKDatabase();    long leaderCurrentEpoch = leader.getCurrentEpoch();    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    leader.getActiveServer().setZKDatabase(newDB);    try {                zk.create(uniqueZnode(), data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected due to error injected to transaction log commit");    } catch (Exception e) {        }                watcher.reset();    waitForNewLeaderElection(leader, leaderCurrentEpoch);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        leader.getActiveServer().setZKDatabase(originalZKDatabase);        leader = getLeaderQuorumPeer(mt);    assertNotNull("New leader must have been elected by now", leader);    String uniqueNode = uniqueZnode();    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String createNode = zk.create(uniqueNode, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            assertEquals("Failed to create znode", uniqueNode, createNode);    zk.close();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    throw new IOException("Input/output error");}
19366be5774299c3612aade944da4ff55cf99b3fc03a7003abb46079b724712a
waitForNewLeaderElection
private void waitForNewLeaderElection(QuorumPeer peer, long leaderCurrentEpoch) throws IOException, InterruptedException
{    LOG.info("Waiting for new LE cycle..");        int count = 100;    while (count > 0) {        if (leaderCurrentEpoch == peer.getCurrentEpoch()) {            Thread.sleep(100);        }        count--;    }    assertNotEquals("New LE cycle must have triggered", leaderCurrentEpoch, peer.getCurrentEpoch());}
8d4c1f1f9334a3752ca1c0ef371a5546e727f8cf523111ea0588e17976e5c792
getLeaderQuorumPeer
private QuorumPeer getLeaderQuorumPeer(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
f8f899fea8825c5a8d656af6b3f90c8b5e42cb0743822b4c3cc5b09996726158
uniqueZnode
private String uniqueZnode()
{    UUID randomUUID = UUID.randomUUID();    String node = NODE_PATH + "/" + randomUUID.toString();    return node;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{        snapCount = System.getProperty("zookeeper.snapCount", "1024");    System.setProperty("zookeeper.snapCount", "10");    super.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.setProperty("zookeeper.snapCount", snapCount);    super.tearDown();}
34e23de89c562fba79b58b84b5ae89b6616023cac66bc6ee18a931ec836d5aaf
testNullData
public void testNullData() throws IOException, InterruptedException, KeeperException
{    String path = "/SIZE";    ZooKeeper zk = null;    zk = createClient();    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.exists(path, false);        zk.exists(path, false, this, null);        cn.await(10, TimeUnit.SECONDS);        assertSame(0L, cn.getCount());    } finally {        if (zk != null) {            zk.close();        }    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    cn.countDown();}
55c7f912e3bdbbc650628d1dfae3f15ae36da080d2d4694288944ec060b28458
startServers
 void startServers() throws Exception
{    startServers(true);}
76c66a305e01eb33fd2c753108fa5e8a472dfd822234742cf4a930105658a51d
shutdown
protected void shutdown(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
24ee8d734782b0ca6395d1096afd1ee3a151fae7453c4685632994a5f5360512
testHierarchicalQuorum
public void testHierarchicalQuorum() throws Throwable
{    cht.runHammer(5, 10);}
ff8a2bce47d45a5a53550c2d64ea87579c45282c8b55a763dcad74a8d74630b5
establishThreeParticipantOneObserverEnsemble
public void establishThreeParticipantOneObserverEnsemble() throws Exception
{    qb.setUp(true);    ct.hostPort = qb.hostPort;    ct.setUpAll();    qb.s5.shutdown();}
c07509c9ad21ab65edf0f023a49a10b146f8b64f37698c7694c5da415244dbb2
shutdownQuorum
public void shutdownQuorum() throws Exception
{    ct.tearDownAll();    qb.tearDown();}
18580b6edd3bd35c0e8fa4d568ec2a411217172c99c1693f1e39d814fb311e7c
testLEWithObserver
public void testLEWithObserver() throws Exception
{    QuorumPeer leader = null;    for (QuorumPeer server : Arrays.asList(qb.s1, qb.s2, qb.s3)) {        if (server.getServerState().equals(QuorumStats.Provider.FOLLOWING_STATE)) {            server.shutdown();            assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + server.getClientPort(), ClientBase.CONNECTION_TIMEOUT));        } else {            assertNull("More than one leader found", leader);            leader = server;        }    }    assertTrue("Leader is not in Looking state", ClientBase.waitForServerState(leader, ClientBase.CONNECTION_TIMEOUT, QuorumStats.Provider.LOOKING_STATE));}
530ee67749d6f2eff038a16df2c40b771781f68f89687d55f9dec83e341d4cb1
data
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } });}
1e3d467ea60e846684bd255fa3d78500012f2936f545607881aafa2a68e5b10f
setUp
private PortForwarder setUp(final int omProxyPort) throws IOException
{    ClientBase.setupTestEnv();    final int PORT_QP1 = PortAssignment.unique();    final int PORT_QP2 = PortAssignment.unique();    final int PORT_OBS = PortAssignment.unique();    final int PORT_QP_LE1 = PortAssignment.unique();    final int PORT_QP_LE2 = PortAssignment.unique();    final int PORT_OBS_LE = PortAssignment.unique();    CLIENT_PORT_QP1 = PortAssignment.unique();    CLIENT_PORT_QP2 = PortAssignment.unique();    CLIENT_PORT_OBS = PortAssignment.unique();    OM_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PORT_QP1) + ":" + (PORT_QP_LE1) + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + (PORT_QP2) + ":" + (PORT_QP_LE2) + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + (PORT_OBS) + ":" + (PORT_OBS_LE) + ":observer" + ";" + CLIENT_PORT_OBS;    String extraCfgs = testObserverMaster ? String.format("observerMasterPort=%d%n", OM_PORT) : "";    String extraCfgsObs = testObserverMaster ? String.format("observerMasterPort=%d%n", omProxyPort <= 0 ? OM_PORT : omProxyPort) : "";    PortForwarder forwarder = null;    if (testObserverMaster && omProxyPort >= 0) {        forwarder = new PortForwarder(omProxyPort, OM_PORT);    }    q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, extraCfgs);    q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, extraCfgs);    q3 = new MainThread(3, CLIENT_PORT_OBS, quorumCfgSection, extraCfgsObs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    return forwarder;}
03721707180e2b8e0a48bc6aee80746e814ee6041dd9015d4b650534102428d0
shutdown
private void shutdown() throws InterruptedException
{    LOG.info("Shutting down all servers");    zk.close();    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue("Waiting for server 1 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 3 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT));}
7d0541fd785569ea641633877b2e645d698e307bd932f6b411f67a42003db0c9
testLaggingObserverMaster
public void testLaggingObserverMaster() throws Exception
{    final int OM_PROXY_PORT = PortAssignment.unique();    PortForwarder forwarder = setUp(OM_PROXY_PORT);        int leaderPort;    MainThread leader;    MainThread follower;    if (q1.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP1;        leader = q1;        follower = q2;    } else if (q2.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP2;        leader = q2;        follower = q1;    } else {        throw new RuntimeException("No leader");    }        zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long lastLoggedZxid = leader.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);        if (forwarder != null) {        forwarder.shutdown();    }    for (int i = 0; i < 10; i++) {        zk.create("/basic" + i, "second".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    DelayRequestProcessor delayRequestProcessor = null;    if (testObserverMaster) {        FollowerZooKeeperServer followerZooKeeperServer = (FollowerZooKeeperServer) follower.getQuorumPeer().getActiveServer();        delayRequestProcessor = DelayRequestProcessor.injectDelayRequestProcessor(followerZooKeeperServer);    }    zk.create("/target1", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/target2", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    LOG.info("observer zxid " + Long.toHexString(q3.getQuorumPeer().getLastLoggedZxid()) + (testObserverMaster ? "" : " observer master zxid " + Long.toHexString(follower.getQuorumPeer().getLastLoggedZxid())) + " leader zxid " + Long.toHexString(leader.getQuorumPeer().getLastLoggedZxid()));        forwarder = testObserverMaster ? new PortForwarder(OM_PROXY_PORT, OM_PORT) : null;    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    assertNotNull("Leader switched", leader.getQuorumPeer().leader);    if (delayRequestProcessor != null) {        delayRequestProcessor.unblockQueue();    }    latch = new CountDownLatch(1);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/finalop", "fourth".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("first", new String(obsZk.getData("/init", null, null)));    assertEquals("third", new String(obsZk.getData("/target1", null, null)));    obsZk.close();    shutdown();    try {        if (forwarder != null) {            forwarder.shutdown();        }    } catch (Exception e) {        }}
e3a36a472a70586e1bea5255176f82aba09b135223441cdb532b91b7c61e9f7f
evaluate
public boolean evaluate()
{    return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();}
c5d2bffe4441b397c226837a4bd598b612f450938d000d18e3d38e9652b541dd
testObserver
public void testObserver() throws Exception
{        latch = new CountDownLatch(2);    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    if (testObserverMaster) {        int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();        LOG.info("port " + masterPort + " " + OM_PORT);        assertEquals("observer failed to connect to observer master", masterPort, OM_PORT);    }    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertEquals(new String(zk.getData("/obstest", null, null)), "test");        zk.sync("/", null, null);    zk.setData("/obstest", "test2".getBytes(), -1);    zk.getChildren("/", false);    assertEquals(zk.getState(), States.CONNECTED);    LOG.info("Shutting down server 2");        q2.shutdown();    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    LOG.info("Server 2 down");        latch.await();    assertNotSame("Client is still connected to non-quorate cluster", KeeperState.SyncConnected, lastEvent.getState());    LOG.info("Latch returned");    try {        assertNotEquals("Shouldn't get a response when cluster not quorate!", "test", new String(zk.getData("/obstest", null, null)));    } catch (ConnectionLossException c) {        LOG.info("Connection loss exception caught - ensemble not quorate (this is expected)");    }    latch = new CountDownLatch(1);    LOG.info("Restarting server 2");            q2.start();    LOG.info("Waiting for server 2 to come up");    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    LOG.info("Server 2 started, waiting for latch");    latch.await();            assertTrue("Client didn't reconnect to quorate ensemble (state was" + lastEvent.getState() + ")", (KeeperState.SyncConnected == lastEvent.getState() || KeeperState.Expired == lastEvent.getState()));    LOG.info("perform a revalidation test");    int leaderProxyPort = PortAssignment.unique();    int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    ZooKeeper client = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    client.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", client.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(client.getData("/revalidtest", null, null)), "test");    client.close();    obsPF.shutdown();    shutdown();}
dc195f6286bd9b4b7fbf4cf9f601b76f2cbccdea9227faeaecaa8eeb88675a93
testRevalidation
public void testRevalidation() throws Exception
{    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final int leaderProxyPort = PortAssignment.unique();    final int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    zk = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", zk.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(zk.getData("/revalidtest", null, null)), "test");    obsPF.shutdown();    shutdown();}
38f403c2dfd7c60ec1abe882b3b3ea9364eaff1e3cd52ed3391060fd25aa0d59
testInOrderCommits
public void testInOrderCommits() throws Exception
{    setUp(-1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, null);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("Initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long zxid = q1.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return zxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    int followerPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP1 : CLIENT_PORT_QP2;    ZooKeeper fZk = new ZooKeeper("127.0.0.1:" + followerPort, ClientBase.CONNECTION_TIMEOUT, this);    final int numTransactions = 10001;    CountDownLatch gate = new CountDownLatch(1);    CountDownLatch oAsyncLatch = new CountDownLatch(numTransactions);    Thread oAsyncWriteThread = new Thread(new AsyncWriter(obsZk, numTransactions, true, oAsyncLatch, "/obs", gate));    CountDownLatch fAsyncLatch = new CountDownLatch(numTransactions);    Thread fAsyncWriteThread = new Thread(new AsyncWriter(fZk, numTransactions, true, fAsyncLatch, "/follower", gate));    LOG.info("ASYNC WRITES");    oAsyncWriteThread.start();    fAsyncWriteThread.start();    gate.countDown();    oAsyncLatch.await();    fAsyncLatch.await();    oAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (oAsyncWriteThread.isAlive()) {        LOG.error("asyncWriteThread is still alive");    }    fAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (fAsyncWriteThread.isAlive()) {        LOG.error("asyncWriteThread is still alive");    }    obsZk.close();    fZk.close();    shutdown();}
e3a36a472a70586e1bea5255176f82aba09b135223441cdb532b91b7c61e9f7f
evaluate
public boolean evaluate()
{    return zxid == q3.getQuorumPeer().getLastLoggedZxid();}
3702b997451e3263359076aae4b4c347b044a7c31881d3b86accfe81aa75d34e
testAdminCommands
public void testAdminCommands() throws IOException, MBeanException, InstanceNotFoundException, ReflectionException, InterruptedException, MalformedObjectNameException, AttributeNotFoundException, InvalidAttributeValueException, KeeperException
{        for (ZKMBeanInfo beanInfo : MBeanRegistry.getInstance().getRegisteredBeans()) {        MBeanRegistry.getInstance().unregister(beanInfo);    }    JMXEnv.setUp();    setUp(-1);    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));        zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/obstest", null, null)), "test");        final Map<String, String> emptyMap = Collections.emptyMap();    Map<String, Object> stats = Commands.runCommand("mntr", q3.getQuorumPeer().getActiveServer(), emptyMap).toMap();    assertTrue("observer not emitting observer_master_id", stats.containsKey("observer_master_id"));        if (testObserverMaster) {        if (q1.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q1.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q1.getQuorumPeer().leader == null) {            assertNull(q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        }    }        if (testObserverMaster) {        if (q2.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q2.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q2.getQuorumPeer().leader == null) {            assertNull(q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        }    }        ObjectName connBean = null;    for (ObjectName bean : JMXEnv.conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null)) {        if (bean.getCanonicalName().contains("Learner_Connections") && bean.getCanonicalName().contains("id:" + q3.getQuorumPeer().getId())) {            connBean = bean;            break;        }    }    assertNotNull("could not find connection bean", connBean);    latch = new CountDownLatch(1);    JMXEnv.conn().invoke(connBean, "terminateConnection", new Object[0], null);    assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT / 2, TimeUnit.MILLISECONDS));    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final String obsBeanName = String.format("org.apache.ZooKeeperService:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Observer", q3.getQuorumPeer().getId(), q3.getQuorumPeer().getId());    Set<ObjectName> names = JMXEnv.conn().queryNames(new ObjectName(obsBeanName), null);    assertEquals("expecting singular observer bean", 1, names.size());    ObjectName obsBean = names.iterator().next();    if (testObserverMaster) {                long observerMasterId = q3.getQuorumPeer().observer.getLearnerMasterId();        latch = new CountDownLatch(1);        JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - observerMasterId)));        assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    } else {                final long leaderId = q1.getQuorumPeer().leader == null ? 2 : 1;        try {            JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - leaderId)));            fail("should have seen an exception on previous command");        } catch (RuntimeMBeanException e) {            assertEquals("mbean failed for the wrong reason", IllegalArgumentException.class, e.getCause().getClass());        }    }    shutdown();    JMXEnv.tearDown();}
55c12e01ec15803179135e5b7771cd53053b2f09adc7eb9f97f7f4c82af7ed99
createServerString
private String createServerString(String type, long serverId, int clientPort)
{    return "server." + serverId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + type + ";" + clientPort;}
e95ca61e1157a0a535be6a145b57bd4e573b619991f6875919f82c623510a84b
waitServerUp
private void waitServerUp(int clientPort)
{    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
fa244007a5c61ea0735df428de167cace6054a451605a73759daa09e58d78a7b
createAdmin
private ZooKeeperAdmin createAdmin(int clientPort) throws IOException
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);    ZooKeeperAdmin admin = new ZooKeeperAdmin("127.0.0.1:" + clientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    admin.addAuthInfo("digest", "super:test".getBytes());    return admin;}
a8aad6b6d9e04f4d42e6e54782a1602442244c3ff759d5d2f7083d076bf8c47b
testDynamicReconfig
public void testDynamicReconfig() throws InterruptedException, IOException, KeeperException
{    if (!testObserverMaster) {        return;    }    ClientBase.setupTestEnv();                            int clientPort1 = PortAssignment.unique();    int clientPort2 = PortAssignment.unique();    int omPort1 = PortAssignment.unique();    int omPort2 = PortAssignment.unique();    String quorumCfgSection = createServerString("participant", 1, clientPort1) + "\n" + createServerString("participant", 2, clientPort2);    MainThread s1 = new MainThread(1, clientPort1, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort1));    MainThread s2 = new MainThread(2, clientPort2, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort2));    s1.start();    s2.start();    waitServerUp(clientPort1);    waitServerUp(clientPort2);        long nonLeaderOMPort = s1.getQuorumPeer().leader == null ? omPort1 : omPort2;    int observerClientPort = PortAssignment.unique();    int observerId = 10;    MainThread observer = new MainThread(observerId, observerClientPort, quorumCfgSection + "\n" + createServerString("observer", observerId, observerClientPort), String.format("observerMasterPort=%d%n", nonLeaderOMPort));    LOG.info("starting observer");    observer.start();    waitServerUp(observerClientPort);        final LinkedBlockingQueue<KeeperState> states = new LinkedBlockingQueue<KeeperState>();    ZooKeeper observerClient = new ZooKeeper("127.0.0.1:" + observerClientPort, ClientBase.CONNECTION_TIMEOUT, event -> {        try {            states.put(event.getState());        } catch (InterruptedException ignore) {        }    });        KeeperState state = states.poll(1000, TimeUnit.MILLISECONDS);    assertEquals(KeeperState.SyncConnected, state);        ArrayList<String> newServers = new ArrayList<String>();    String server = "server.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + PortAssignment.unique();    newServers.add(server);    ZooKeeperAdmin admin = createAdmin(clientPort1);    ReconfigTest.reconfig(admin, newServers, null, null, -1);        ReconfigTest.testServerHasConfig(observerClient, newServers, null);            state = states.poll(1000, TimeUnit.MILLISECONDS);    assertNull(state);    admin.close();    observerClient.close();    observer.shutdown();    s2.shutdown();    s1.shutdown();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    lastEvent = event;    if (latch != null) {        latch.countDown();    }    LOG.info("Latch got event :: " + event);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    if (gate != null) {        try {            gate.await();        } catch (InterruptedException e) {            LOG.error("Gate interrupted");            return;        }    }    for (int i = 0; i < numTransactions; i++) {        final boolean pleaseLog = i % 100 == 0;        client.create(root + i, "inner thread".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                writerLatch.countDown();                if (pleaseLog) {                    LOG.info("wrote {}", path);                }            }        }, null);        if (pleaseLog) {            LOG.info("async wrote {}{}", root, i);            if (issueSync) {                client.sync(root + "0", null, null);            }        }    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    writerLatch.countDown();    if (pleaseLog) {        LOG.info("wrote {}", path);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qb.setUp(true);    cht.hostPort = qb.hostPort;    cht.setUpAll();}
932290a23a1b216cd9575cf86642443915c728311d4285af7b6d95c469d7e635
testHammerBasic
public void testHammerBasic() throws Throwable
{    cht.testHammerBasic();}
9df9b43fa0bee003a0dfc4d48f9938d0af3f637e9d56f94100e01156dc17a317
testObserverOnly
public void testObserverOnly() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer;" + CLIENT_PORT_QP1 + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
0900763e490d013c547924322fb29945fb78a62034792fc5c6f494371f5ea7c3
testObserverWithStandlone
public void testObserverWithStandlone() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer\n" + "server.2=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + "\npeerType=observer\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
992130c0bdeb73a89bf695ae15631d4b6d027b1859b9f7271480628775c7635d
testOOM
public void testOOM() throws IOException, InterruptedException, KeeperException
{    File tmpDir = ClientBase.createTmpDir();            List<byte[]> hog = new ArrayList<>();    while (true) {        try {            hog.add(new byte[1024 * 1024 * 2]);        } catch (OutOfMemoryError e) {            hog.remove(0);            break;        }    }    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = PortAssignment.unique();    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));    System.err.println("OOM Stage 0");    utestPrep(PORT);    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 1");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestExists(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 2");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestGet(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 3");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestChildren(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    hog.get(0)[0] = (byte) 1;    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));}
cc4139b43fa8e8881167c1ec579f18905c4a21a222ae42f48c6631e8cba5bdac
utestExists
private void utestExists(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.exists("/this/path/doesnt_exist!", true);    }    zk.close();}
e20a249db4179db224e62b47439ef9caf8955f299fbbcdc8d7530617e578fa16
utestPrep
private void utestPrep(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.create("/" + i, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
e90a735b07ae3e74aa799da19026dfcb90561b9fdba61668e34887027613e4a8
utestGet
private void utestGet(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        Stat stat = new Stat();        zk.getData("/" + i, true, stat);    }    zk.close();}
24bee16672c1aca8a1e8772cffa5719eaf1a7cd4ec79a63d5dce2e65e08a64e0
utestChildren
private void utestChildren(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.getChildren("/" + i, true);    }    zk.close();}
46ffa8d56c2364376c7a2fb00ff1e97ead501825886406f582f8797ba07e934c
initialize
public void initialize()
{    this.osMbean = new OSMXBean();    assertNotNull("Could not initialize OSMXBean object!", osMbean);}
a2264266816a7300a301a649422e931ecc3d9c4a6d7a81938c8edf68ab004ad1
testGetUnix
public final void testGetUnix()
{    boolean isUnix = osMbean.getUnix();    if (!isUnix) {        LOG.info("Running in a Windows system! Output won't be printed!");    } else {        LOG.info("Running in a Unix or Linux system!");    }}
c115c1bf3fd0073215528e9ab9a2448bd081cd4fabbc9a6b859c08848ac08621
testGetOpenFileDescriptorCount
public final void testGetOpenFileDescriptorCount()
{    if (osMbean != null && osMbean.getUnix()) {        ofdc = osMbean.getOpenFileDescriptorCount();        LOG.info("open fdcount is: " + ofdc);    }    assertFalse("The number of open file descriptor is negative", (ofdc < 0));}
faf2d9c19129ee8de6e7c9f8c2014cbf707bdddfce7446515f94a57faa49c92c
testGetMaxFileDescriptorCount
public final void testGetMaxFileDescriptorCount()
{    if (osMbean != null && osMbean.getUnix()) {        mfdc = osMbean.getMaxFileDescriptorCount();        LOG.info("max fdcount is: " + mfdc);    }    assertFalse("The max file descriptor number is negative", (mfdc < 0));}
1eeb1102bce7e6e987c547d40b38c59192fcbd975c451ef3811bb29a90c72382
testNull
public void testNull()
{}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    setUp(false);}
99c1f7ae902c1f4e90bf907d6bf545123275ee39caae087d0f90476d9361ca75
setUp
protected void setUp(boolean withObservers) throws Exception
{    LOG.info("QuorumBase.setup " + getTestName());    setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    portLE1 = PortAssignment.unique();    portLE2 = PortAssignment.unique();    portLE3 = PortAssignment.unique();    portLE4 = PortAssignment.unique();    portLE5 = PortAssignment.unique();    portClient1 = PortAssignment.unique();    portClient2 = PortAssignment.unique();    portClient3 = PortAssignment.unique();    portClient4 = PortAssignment.unique();    portClient5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + portClient1 + ",127.0.0.1:" + portClient2 + ",127.0.0.1:" + portClient3 + ",127.0.0.1:" + portClient4 + ",127.0.0.1:" + portClient5;    LOG.info("Ports are: " + hostPort);    s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    startServers(withObservers);    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        LOG.info("Initial fdcount is: " + osMbean.getOpenFileDescriptorCount());    }    LOG.info("Setup finished");}
55c7f912e3bdbbc650628d1dfae3f15ae36da080d2d4694288944ec060b28458
startServers
 void startServers() throws Exception
{    startServers(false);}
5e75faf7716ad05969c1b9f60fb5924ed7d85841e7404e22fa33899ccbdca2fd
startServers
 void startServers(boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    if (withObservers) {        peers.get(Long.valueOf(4)).type = LearnerType.OBSERVER;        peers.get(Long.valueOf(5)).type = LearnerType.OBSERVER;    }    LOG.info("creating QuorumPeer 1 port " + portClient1);    s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient1, s1.getClientPort());    LOG.info("creating QuorumPeer 2 port " + portClient2);    s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient2, s2.getClientPort());    LOG.info("creating QuorumPeer 3 port " + portClient3);    s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient3, s3.getClientPort());    LOG.info("creating QuorumPeer 4 port " + portClient4);    s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient4, s4.getClientPort());    LOG.info("creating QuorumPeer 5 port " + portClient5);    s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient5, s5.getClientPort());    if (withObservers) {        s4.setLearnerType(LearnerType.OBSERVER);        s5.setLearnerType(LearnerType.OBSERVER);    }    LOG.info("QuorumPeer 1 voting view: " + s1.getVotingView());    LOG.info("QuorumPeer 2 voting view: " + s2.getVotingView());    LOG.info("QuorumPeer 3 voting view: " + s3.getVotingView());    LOG.info("QuorumPeer 4 voting view: " + s4.getVotingView());    LOG.info("QuorumPeer 5 voting view: " + s5.getVotingView());    s1.enableLocalSessions(localSessionsEnabled);    s2.enableLocalSessions(localSessionsEnabled);    s3.enableLocalSessions(localSessionsEnabled);    s4.enableLocalSessions(localSessionsEnabled);    s5.enableLocalSessions(localSessionsEnabled);    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s3.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s4.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s5.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    LOG.info("start QuorumPeer 1");    s1.start();    LOG.info("start QuorumPeer 2");    s2.start();    LOG.info("start QuorumPeer 3");    s3.start();    LOG.info("start QuorumPeer 4");    s4.start();    LOG.info("start QuorumPeer 5");    s5.start();    LOG.info("started QuorumPeer 5");    LOG.info("Checking ports " + hostPort);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));        LOG.info(hp + " is accepting client connections");    }        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= 5; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= 5; i++) {        for (int j = 1; j <= 5; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));}
502445c1e64a1a2cb8adee3b122ba56d37f245efdff1407b045691dd0204ffc3
getLeaderIndex
public int getLeaderIndex()
{    if (s1.getPeerState() == ServerState.LEADING) {        return 0;    } else if (s2.getPeerState() == ServerState.LEADING) {        return 1;    } else if (s3.getPeerState() == ServerState.LEADING) {        return 2;    } else if (s4.getPeerState() == ServerState.LEADING) {        return 3;    } else if (s5.getPeerState() == ServerState.LEADING) {        return 4;    }    return -1;}
3031fcafd09c1e6fe424f6c5ef96e1a22dbc5ead4e0c23fa7abb6f5d55ca90ee
getPeersMatching
public String getPeersMatching(ServerState state)
{    StringBuilder hosts = new StringBuilder();    for (QuorumPeer p : getPeerList()) {        if (p.getPeerState() == state) {            hosts.append(String.format("%s:%d,", LOCALADDR, p.getClientAddress().getPort()));        }    }    LOG.info("getPeersMatching ports are {}", hosts);    return hosts.toString();}
6a422a746bb7818d1ef6380950a325f572d2fa5aa974790337f74cad2e87150a
getPeerList
public ArrayList<QuorumPeer> getPeerList()
{    ArrayList<QuorumPeer> peers = new ArrayList<QuorumPeer>();    peers.add(s1);    peers.add(s2);    peers.add(s3);    peers.add(s4);    peers.add(s5);    return peers;}
341f276e9f05d2e24558c8d8864ae95ae1b53121d388caae1d82d25397e44bca
getPeerByClientPort
public QuorumPeer getPeerByClientPort(int clientPort)
{    for (QuorumPeer p : getPeerList()) {        if (p.getClientAddress().getPort() == clientPort) {            return p;        }    }    return null;}
2ce75ab68dcc93c3ba91f0dfb1ec9b3d0d95e9849cd72d96b385a4929d1119b1
setupServers
public void setupServers() throws IOException
{    setupServer(1);    setupServer(2);    setupServer(3);    setupServer(4);    setupServer(5);}
ec1316775f5780ef56cf2f4d9e1e5c1d2959a60253bc4816a7792ea710bfc70a
setupServer
public void setupServer(int i) throws IOException
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    if (peers == null) {        peers = new HashMap<Long, QuorumServer>();        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    }    switch(i) {        case 1:            LOG.info("creating QuorumPeer 1 port " + portClient1);            s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient1, s1.getClientPort());            break;        case 2:            LOG.info("creating QuorumPeer 2 port " + portClient2);            s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient2, s2.getClientPort());            break;        case 3:            LOG.info("creating QuorumPeer 3 port " + portClient3);            s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient3, s3.getClientPort());            break;        case 4:            LOG.info("creating QuorumPeer 4 port " + portClient4);            s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient4, s4.getClientPort());            break;        case 5:            LOG.info("creating QuorumPeer 5 port " + portClient5);            s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient5, s5.getClientPort());    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("TearDown started");    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        LOG.info("fdcount after test is: " + osMbean.getOpenFileDescriptorCount());    }    shutdownServers();    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));        LOG.info(hp + " is no longer accepting client connections");    }    JMXEnv.tearDown();}
1ac55bceebac3c27f19513e7fc351534c2f0aeec52da3389439cd72c6b086d12
shutdownServers
public void shutdownServers()
{    shutdown(s1);    shutdown(s2);    shutdown(s3);    shutdown(s4);    shutdown(s5);}
242a5fc910d568f9ee8d7f87790d2562fd53028c90e1c400504f8e3b0b13f223
shutdown
public static void shutdown(QuorumPeer qp)
{    if (qp == null) {        return;    }    try {        LOG.info("Shutting down quorum peer " + qp.getName());        qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {            LOG.info("Shutting down leader election " + qp.getName());            e.shutdown();        } else {            LOG.info("No election available to shutdown " + qp.getName());        }        LOG.info("Waiting for " + qp.getName() + " to exit thread");        long readTimeout = qp.getTickTime() * qp.getInitLimit();        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();        long maxTimeout = Math.max(readTimeout, connectTimeout);        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);        qp.join(maxTimeout * 2);        if (qp.isAlive()) {            fail("QP failed to shutdown in " + (maxTimeout * 2) + " seconds: " + qp.getName());        }    } catch (InterruptedException e) {        LOG.debug("QP interrupted: " + qp.getName(), e);    }}
e020061391c4c99e64b2a900513ff8c46b803dc4c97eea1533ff800109075622
createClient
protected TestableZooKeeper createClient() throws IOException, InterruptedException
{    return createClient(hostPort);}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
7edb2ffee9973482d999ddcb3ac8f5ea70e5358f09068540b891d02354401329
createClient
protected TestableZooKeeper createClient(CountdownWatcher watcher, ServerState state) throws IOException, InterruptedException
{    return createClient(watcher, getPeersMatching(state));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qb.setUp();    cht.hostPort = qb.hostPort;    cht.setUpAll();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    cht.tearDownAll();    qb.tearDown();}
932290a23a1b216cd9575cf86642443915c728311d4285af7b6d95c469d7e635
testHammerBasic
public void testHammerBasic() throws Throwable
{    cht.testHammerBasic();}
970dc725d21c4928af25254cbbc2369edda80f6d464c263cca050f5ca7fbda2a
testMajQuorums
public void testMajQuorums() throws Throwable
{    LOG.info("Verify QuorumPeer#electionTimeTaken jmx bean attribute");    ArrayList<QuorumPeer> peers = getPeerList();    for (int i = 1; i <= peers.size(); i++) {        QuorumPeer qp = peers.get(i - 1);        Long electionTimeTaken = -1L;        String bean = "";        if (qp.getPeerState() == ServerState.FOLLOWING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower", MBeanRegistry.DOMAIN, i, i);        } else if (qp.getPeerState() == ServerState.LEADING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader", MBeanRegistry.DOMAIN, i, i);        }        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, "ElectionTimeTaken");        assertTrue("Wrong electionTimeTaken value!", electionTimeTaken >= 0);    }        setUp(false);    Proposal p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    p.addAck(Long.valueOf(2));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(3));    assertEquals(true, p.hasAllQuorums());        setUp(true);    p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(4));    p.addAck(Long.valueOf(5));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(2));    assertEquals(true, p.hasAllQuorums());}
79f1713df7dd6d0eba4667eb27412c6880f43513d49879ab329f763c580a7ed9
testQuotaWithQuorum
public void testQuotaWithQuorum() throws Exception
{    ZooKeeper zk = createClient();    zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int i = 0;    for (i = 0; i < 300; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    SetQuotaCommand.createQuota(zk, "/a", 1000L, 5000);    String statPath = Quotas.quotaZookeeper + "/a" + "/" + Quotas.statNode;    byte[] data = zk.getData(statPath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 1204L);    assertTrue("num count is set", st.getCount() == 301);    for (i = 300; i < 600; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    data = zk.getData(statPath, false, new Stat());    st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 2404L);    assertTrue("num count is set", st.getCount() == 601);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qb.setUp();    ct.hostPort = qb.hostPort;    ct.setUpAll();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    ct.tearDownAll();    qb.tearDown();    if (qu != null) {        qu.tearDown();    }}
e496dc4cf0ca72f4e56323791ff91072eb9499035f84285dfaef361dc9f228f4
testDeleteWithChildren
public void testDeleteWithChildren() throws Exception
{    ct.testDeleteWithChildren();}
5ee85b93d3b1559356fdc23406dc8e9078b44c9ef2227f4a90d6f64bf4b41e15
testPing
public void testPing() throws Exception
{    ct.testPing();}
679eaf5aa7d5a2ce15ce0ea9a72ec361c6b0eac49559ea53a5e6d9a6dd794087
testSequentialNodeNames
public void testSequentialNodeNames() throws IOException, InterruptedException, KeeperException
{    ct.testSequentialNodeNames();}
6a61f835063aafdf158d8c874fdfd302b777b0a1ff9fc63b4da5f55fa40ed383
testACLs
public void testACLs() throws Exception
{    ct.testACLs();}
463eb0e3351446d0de5f3393cdd4c9cbc1cf030b72a726f9dab669da0ae95288
testClientwithoutWatcherObj
public void testClientwithoutWatcherObj() throws IOException, InterruptedException, KeeperException
{    ct.testClientwithoutWatcherObj();}
be1a1d5bbe6be668fac984e6224420544c8c82754ab059974d01b55dfd61e741
testClientWithWatcherObj
public void testClientWithWatcherObj() throws IOException, InterruptedException, KeeperException
{    ct.testClientWithWatcherObj();}
aa75fc435e2b38ad10dd39b6dffa9e7dfb3bf09ab83812e606283a899b14bcfe
testGetView
public void testGetView()
{    assertEquals(5, qb.s1.getView().size());    assertEquals(5, qb.s2.getView().size());    assertEquals(5, qb.s3.getView().size());    assertEquals(5, qb.s4.getView().size());    assertEquals(5, qb.s5.getView().size());}
4ec8ab609d2e2f148ab089a72e28e624222a5a3d0b5a065c09a8cb49c9a4b950
testViewContains
public void testViewContains()
{        assertTrue(qb.s1.viewContains(qb.s1.getId()));        assertTrue(qb.s1.viewContains(qb.s2.getId()));        assertFalse(qb.s1.viewContains(-1L));}
30b9a8c90042790bceff5c5443ac53cebc7864af71e3ca3ac5dc8ec69b38e926
testLeaderShutdown
public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new DisconnectableZooKeeper(qb.hostPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/blah/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Leader leader = qb.s1.leader;    if (leader == null) {        leader = qb.s2.leader;    }    if (leader == null) {        leader = qb.s3.leader;    }    if (leader == null) {        leader = qb.s4.leader;    }    if (leader == null) {        leader = qb.s5.leader;    }    assertNotNull(leader);    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }    for (LearnerHandler f : leader.getForwardingFollowers()) {        f.getSocket().shutdownInput();    }    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }        assertTrue(qb.s1.isAlive());    assertTrue(qb.s2.isAlive());    assertTrue(qb.s3.isAlive());    assertTrue(qb.s4.isAlive());    assertTrue(qb.s5.isAlive());    zk.close();}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
eae1214fe94020f5f10b56958faa97c5b9e1aa94ed8907ea3d3531e10872000a
testMultipleWatcherObjs
public void testMultipleWatcherObjs() throws IOException, InterruptedException, KeeperException
{    ct.testMutipleWatcherObjs();}
f4b41349f381f6be898043d7867a1c478d1b3b42208d85393f00ed7b7871f090
testSessionMoved
public void testSessionMoved() throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());        zknew.setData("/", new byte[1], -1);        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }        LOG.info(hostPorts[(i + 1) % hostPorts.length] + " Sync returned " + result[0]);        assertTrue(result[0] == KeeperException.Code.OK.intValue());        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {        }        zk = zknew;    }    zk.close();}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        zkDisco = true;    }}
66a1c59530a465e2d685f64486fd82ac4322521b7b54925337ed2d7be665a6db
testSessionMovedWithMultiOp
public void testSessionMovedWithMultiOp() throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        ZooKeeper zknew = new ZooKeeper(hostPorts[1], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());    zknew.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        try {        zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-Failed", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {    }    zk.close();    zknew.close();}
ba3934a5dd06f3b42036e443e4742603557af13f8351abd976596df5324cafb0
testSessionMove
public void testSessionMove() throws Exception
{    String[] hps = qb.hostPort.split(",");    DiscoWatcher oldWatcher = new DiscoWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hps[0], ClientBase.CONNECTION_TIMEOUT, oldWatcher);    zk.create("/t1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.dontReconnect();        DiscoWatcher watcher = new DiscoWatcher();    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, watcher, zk.getSessionId(), zk.getSessionPasswd());    zknew.create("/t2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    try {        zk.create("/t3", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {                for (int i = 0; i < 30; i++) {            if (oldWatcher.zkDisco) {                break;            }            Thread.sleep(1000);        }        assertTrue(oldWatcher.zkDisco);    }    ArrayList<ZooKeeper> toClose = new ArrayList<ZooKeeper>();    toClose.add(zknew);        for (int i = 0; i < 10; i++) {        zknew.dontReconnect();        zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, new DiscoWatcher(), zk.getSessionId(), zk.getSessionPasswd());        toClose.add(zknew);        zknew.create("/t-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }    for (ZooKeeper z : toClose) {        z.close();    }    zk.close();}
303d2fb0411d5a890adfa7c417192ca264a7408c91c6a800158edc424ac061a5
testFollowersStartAfterLeader
public void testFollowersStartAfterLeader() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }        qu.shutdown(index);        qu.start(index);            ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (TimeoutException e) {        fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");    }    zk.close();}
9c8146b06b521fbc40f6c55e866f2ffcd8d90ce3eeb67495e1eab84f206fe469
testMultiToFollower
public void testMultiToFollower() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.multi(Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);    zk.close();}
bddb1acf6acce7f1a6b5e58979159945fda57712dcf85f0433b095fafeec7422
getPeer
public PeerStruct getPeer(int id)
{    return peers.get(id);}
3556003dfe568f5e53cb3ac60063c46cd4ab3a6f83a343f853e65e18a9411c68
enableLocalSession
public void enableLocalSession(boolean localSessionEnabled)
{    this.localSessionEnabled = localSessionEnabled;}
eb47678cea4cda410078df895dbef25e1909087b9e5d586d44dbf1aebe8ab90b
startAll
public void startAll() throws IOException
{    shutdownAll();    for (int i = 1; i <= ALL; ++i) {        start(i);        LOG.info("Started QuorumPeer " + i);    }    LOG.info("Checking ports " + hostPort);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT));        LOG.info(hp + " is accepting client connections");    }        if (disableJMXTest) {        return;    }        try {        JMXEnv.dump();                Set<String> ensureNames = new LinkedHashSet<String>();        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("InMemoryDataTree");        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");        }        for (int i = 1; i <= ALL; ++i) {            for (int j = 1; j <= ALL; ++j) {                ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);            }        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i);        }        JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    } catch (IOException e) {        LOG.warn("IOException during JMXEnv operation", e);    } catch (InterruptedException e) {        LOG.warn("InterruptedException during JMXEnv operation", e);    }}
8a38903b04927bae3089e63856cd0eebef1198efc2c598381878b3a98c3cbfe1
startQuorum
public void startQuorum() throws IOException
{    shutdownAll();    for (int i = 1; i <= N + 1; ++i) {        start(i);    }    for (int i = 1; i <= N + 1; ++i) {        assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(i).clientPort, ClientBase.CONNECTION_TIMEOUT));    }}
9d422ff51a5b1d13208e2d81c9d17d53eee06d9e036d01e5f8fb147bebfe5fe3
start
public void start(int id) throws IOException
{    PeerStruct ps = getPeer(id);    LOG.info("Creating QuorumPeer " + ps.id + "; public port " + ps.clientPort);    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    if (localSessionEnabled) {        ps.peer.enableLocalSessions(true);    }    assertEquals(ps.clientPort, ps.peer.getClientPort());    ps.peer.start();}
6e3a1af5fd1145bce77215d9db0571a8fa774731d34f68af7468eb8d63b35a9e
restart
public void restart(int id) throws IOException
{    start(id);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT));}
55cedb7bfb8103d46f63f470f3ad754619170ed587715071d1afe991d7254840
startThenShutdown
public void startThenShutdown(int id) throws IOException
{    PeerStruct ps = getPeer(id);    LOG.info("Creating QuorumPeer " + ps.id + "; public port " + ps.clientPort);    ps.peer = new QuorumPeer(peersView, ps.dataDir, ps.dataDir, ps.clientPort, electionAlg, ps.id, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    if (localSessionEnabled) {        ps.peer.enableLocalSessions(true);    }    assertEquals(ps.clientPort, ps.peer.getClientPort());    ps.peer.start();    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT));    shutdown(id);}
15224d50b980b3fcce7a9435512ebe5e1ded1f5558580a0592775f26a3a4a017
shutdownAll
public void shutdownAll()
{    for (int i = 1; i <= ALL; ++i) {        shutdown(i);    }    for (String hp : hostPort.split(",")) {        assertTrue("Waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));        LOG.info(hp + " is no longer accepting client connections");    }}
6c32ba360308adabf64295e4517ce0aa43353b80826db5d349077d7a56a1e9fb
shutdown
public void shutdown(int id)
{    QuorumPeer qp = getPeer(id).peer;    try {        LOG.info("Shutting down quorum peer " + qp.getName());        qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {            LOG.info("Shutting down leader election " + qp.getName());            e.shutdown();        } else {            LOG.info("No election available to shutdown " + qp.getName());        }        LOG.info("Waiting for " + qp.getName() + " to exit thread");        qp.join(30000);        if (qp.isAlive()) {            fail("QP failed to shutdown in 30 seconds: " + qp.getName());        }    } catch (InterruptedException e) {        LOG.debug("QP interrupted: " + qp.getName(), e);    }}
bbd846489733caa6c51e5a98298fc2e276faff3ca52a2abbd48923393dc25280
getConnString
public String getConnString()
{    return hostPort;}
a7b305e7c80bfc3bc01195be5f0156f094ed0dcbc4ab12b17b7354ff3d660a69
getConnectString
public String getConnectString(QuorumPeer peer)
{    return "127.0.0.1:" + peer.getClientPort();}
47d926a6b4e2e8a8f3b6c15c0c6fe9c00c043a0eddac3c3d38c9ce7d7b744139
getLeaderQuorumPeer
public QuorumPeer getLeaderQuorumPeer()
{    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader != null) {            return ps.peer;        }    }    throw new RuntimeException("Unable to find a leader peer");}
2318188422df2418951031e516e33f3459b5ea90dda56a692d377e2585d6d0c9
getFollowerQuorumPeers
public List<QuorumPeer> getFollowerQuorumPeers()
{    List<QuorumPeer> peerList = new ArrayList<QuorumPeer>(ALL - 1);    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader == null) {            peerList.add(ps.peer);        }    }    return Collections.unmodifiableList(peerList);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("TearDown started");    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        LOG.info("fdcount after test is: " + osMbean.getOpenFileDescriptorCount());    }    shutdownAll();    JMXEnv.tearDown();}
f843e416a1e18acfb2ea7b901237a90324e0741de8db87e60f5e7e78ffe68bc6
getLeaderServer
public int getLeaderServer()
{    int index = 0;    for (int i = 1; i <= ALL; i++) {        if (getPeer(i).peer.leader != null) {            index = i;            break;        }    }    assertTrue("Leader server not found.", index > 0);    return index;}
5089361050bd3e62da2d205fc303cebc25a6ffcc2d8df6ebf01975fffd0afffd
getConnectionStringForServer
public String getConnectionStringForServer(final int index)
{    return "127.0.0.1:" + getPeer(index).clientPort;}
d0351469e6b626f1eb51ce272d134e76812d79714cdd2e196b427b7a5b77b96e
validateAllMXBeanAreUnregistered
public void validateAllMXBeanAreUnregistered() throws IOException
{    QuorumUtil qU = new QuorumUtil(1);    LOG.info(">-->> Starting up all servers...");    qU.startAll();    LOG.info(">-->> Servers up and running...");    int leaderIndex = qU.getLeaderServer();    int firstFollowerIndex = 0;    int secondFollowerIndex = 0;    switch(leaderIndex) {        case 1:            firstFollowerIndex = 2;            secondFollowerIndex = 3;            break;        case 2:            firstFollowerIndex = 1;            secondFollowerIndex = 3;            break;        case 3:            firstFollowerIndex = 1;            secondFollowerIndex = 2;            break;        default:            fail("Unexpected leaderIndex value: " + leaderIndex);            break;    }    LOG.info(">-->> Shuting down server [{}]", firstFollowerIndex);    qU.shutdown(firstFollowerIndex);    LOG.info(">-->> Shuting down server [{}]", secondFollowerIndex);    qU.shutdown(secondFollowerIndex);    LOG.info(">-->> Restarting server [{}]", firstFollowerIndex);    qU.restart(firstFollowerIndex);    LOG.info(">-->> Restarting server [{}]", secondFollowerIndex);    qU.restart(secondFollowerIndex);    qU.shutdownAll();    Set<ZKMBeanInfo> pending = MBeanRegistry.getInstance().getRegisteredBeans();    assertTrue("The following beans should have been unregistered: " + pending, pending.isEmpty());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    qb.setUp();}
215b0a363a75bd9737f76dc5f51ebb4afb0a58c3daeb0c6b9665d6595033a715
testBehindLeader
public void testBehindLeader() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    cleanAndInitializeDataDir(qb.s1dir);    cleanAndInitializeDataDir(qb.s2dir);    cleanAndInitializeDataDir(qb.s3dir);    cleanAndInitializeDataDir(qb.s4dir);    qb.setupServers();    qb.s1.start();    qb.s2.start();    qb.s3.start();    qb.s4.start();    assertTrue("Servers didn't come up", ClientBase.waitForServerUp(qb.hostPort, 10000));    qb.s5.start();    String hostPort = "127.0.0.1:" + qb.s5.getClientPort();    assertFalse("Servers came up, but shouldn't have since it's ahead of leader", ClientBase.waitForServerUp(hostPort, 10000));}
b10a558155994d1864fba01dac8db8166bfd95791c5325542bcb4d26169c2bae
cleanAndInitializeDataDir
private void cleanAndInitializeDataDir(File f) throws IOException
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        c.delete();    }    ClientBase.createInitializeFile(f);}
dc9f6093f05cee5211f98caa14ef33601f4c3cf2dad2addefc65ef74d0e8cd5d
testLateLogs
public void testLateLogs() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    deleteLogs(qb.s1dir);    deleteLogs(qb.s2dir);    deleteLogs(qb.s3dir);    deleteLogs(qb.s4dir);    deleteLogs(qb.s5dir);    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    boolean saw2 = false;    for (String child : zk.getChildren("/", false)) {        if (child.equals("2")) {            saw2 = true;        }    }    zk.close();    assertTrue("Didn't see /2 (went back in time)", saw2);}
199fccf7fbfeca5813e40a43aae7c5f2d3cbfb21722adf6f6b243a4094942904
deleteLogs
private void deleteLogs(File f)
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        if (c.getName().startsWith("log")) {            c.delete();        }    }}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    qb.tearDown();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty("readonlymode.enabled", "true");    qu.startQuorum();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.setProperty("readonlymode.enabled", "false");    qu.tearDown();}
c699c4147360affb4611883f980bcf321574182e7de2008541bea9ae8adfb514
testMultiTransaction
public void testMultiTransaction() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node1 = "/tnode1";    final String node2 = "/tnode2";    zk.create(node1, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in r-o mode", States.CONNECTEDREADONLY, zk.getState());        String remoteData = new String(zk.getData(node1, false, null));    assertEquals("Failed to read data in r-o mode", data, remoteData);    try {        Transaction transaction = zk.transaction();        transaction.setData(node1, "no way".getBytes(), -1);        transaction.create(node2, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        transaction.commit();        fail("Write operation using multi-transaction" + " api has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    assertNull("Should have created the znode:" + node2, zk.exists(node2, false));}
2afc683ea9b08fca64f7e194661ca2f9c7d0d6f0a3397e6ab513da9a7240e107
testReadOnlyClient
public void testReadOnlyClient() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node = "/tnode";    zk.create(node, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    zk.close();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);        String remoteData = new String(zk.getData(node, false, null));    assertEquals(data, remoteData);    try {        zk.setData(node, "no way".getBytes(), -1);        fail("Write operation has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));    zk.close();    watcher.reset();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.setData(node, "We're in the quorum now".getBytes(), -1);    zk.close();}
1b666156fc4611fcbf5482b99f49c653921c8ab7ee23e10d8e5f0b74bf8de896
testConnectionEvents
public void testConnectionEvents() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    boolean success = false;    for (int i = 0; i < 30; i++) {        try {            zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            success = true;            break;        } catch (KeeperException.ConnectionLossException e) {            Thread.sleep(1000);        }    }    assertTrue("Did not succeed in connecting in 30s", success);    assertFalse("The connection should not be read-only yet", watcher.readOnlyConnected);            qu.shutdown(2);            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    long start = Time.currentElapsedTime();    while (!(zk.getState() == States.CONNECTEDREADONLY)) {        Thread.sleep(200);                assertTrue("Can't connect to the server", Time.currentElapsedTime() - start < 30000);    }    watcher.waitForReadOnlyConnected(5000);    zk.close();}
505accff8c29d76339b95811a4cb0c8eabfa2d5a1c60347b10c70b52bb9793d8
testSessionEstablishment
public void testSessionEstablishment() throws Exception
{    qu.shutdown(2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertSame("should be in r/o mode", States.CONNECTEDREADONLY, zk.getState());    long fakeId = zk.getSessionId();    LOG.info("Connected as r/o mode with state {} and session id {}", zk.getState(), fakeId);    watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));    LOG.info("Server 127.0.0.1:{} is up", qu.getPeer(2).clientPort);                            watcher.waitForSyncConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in read-write mode", States.CONNECTED, zk.getState());    LOG.info("Connected as rw mode with state {} and session id {}", zk.getState(), zk.getSessionId());    zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("fake session and real session have same id", zk.getSessionId() == fakeId);    zk.close();}
733debc1de5749cf427ca3d79164059b0d62c075575d470cb7501c815d708ef2
testSeekForRwServer
public void testSeekForRwServer() throws Exception
{        Layout layout = Logger.getRootLogger().getAppender("CONSOLE").getLayout();    ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = new WriterAppender(layout, os);    appender.setImmediateFlush(true);    appender.setThreshold(Level.INFO);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        qu.shutdown(2);        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);                qu.getPeer(1).peer.suspend();                        watcher.reset();        qu.start(2);        qu.start(3);        ClientBase.waitForServerUp(qu.getConnString(), 2000);        watcher.waitForConnected(CONNECTION_TIMEOUT);        zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                qu.getPeer(1).peer.resume();    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    Pattern p = Pattern.compile(".*Majority server found.*");    boolean found = false;    while ((line = r.readLine()) != null) {        if (p.matcher(line).matches()) {            found = true;            break;        }    }    assertTrue("Majority server wasn't found while connected to r/o server", found);}
ca48c3d2e221895f7802958943a552c7e2cf368edfa5c652d37e858cd24e1b3f
setup
public void setup() throws InterruptedException
{    System.setProperty(authProvider, superDigest);    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    resetZKAdmin();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(authProvider);    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
300a238e48f850a6d2b79317c68f79a3e6b2bb9ff19eacabaa0c42821cc05fb8
testReconfigDisabled
public void testReconfigDisabled() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(false);    try {        reconfigPort();        fail("Reconfig should be disabled.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.RECONFIGDISABLED);    }}
ad84b49f02c858db3d9fd729a0e44d969a78335be93b7ff8c7a27224ba9f4e11
testReconfigFailWithoutAuth
public void testReconfigFailWithoutAuth() throws InterruptedException
{    try {        reconfigPort();        fail("Reconfig should fail without auth.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
1ad4bd072fe7308476e68b9a23701de76d9e165aa55033b38688bb3dceb341b7
testReconfigEnabledWithSuperUser
public void testReconfigEnabledWithSuperUser() throws InterruptedException
{    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
cb4055c63f8227c50dfb1851071356e4b1218080714e03cbc822bdb937503a9e
testReconfigFailWithAuthWithNoACL
public void testReconfigFailWithAuthWithNoACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail without a valid ACL associated with user.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
9c3e72dafd16534bad44fd6e4fa2344099059cbc13c3a7bd55ffd3be9b4c30c0
testReconfigEnabledWithAuthAndWrongACL
public void testReconfigEnabledWithAuthAndWrongACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());                ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail with an ACL that is read only!");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
7f8825ba125d94265a96e62d0ed52dfe284fc3d1bbebba83199e4bff491abfbb
testReconfigEnabledWithAuthAndACL
public void testReconfigEnabledWithAuthAndACL() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
b9f64ad8f62deacc292cd54d0c5c257df8458cc5dae990aa60b0cfdebffc1e6a
resetZKAdmin
private void resetZKAdmin() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        if (zkAdmin != null) {            zkAdmin.close();        }        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
f0c569fd842c20ba90befcd40a3f7f7b7af8671b42730b880b9175d993797fe6
reconfigPort
private boolean reconfigPort() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
ca48c3d2e221895f7802958943a552c7e2cf368edfa5c652d37e858cd24e1b3f
setup
public void setup() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    instantiateZKAdmin();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
4936a4daa96234dce47b3734ff9c7ffe8419ddf91f8576bd94d76427b045d347
testReconfigFailWithoutSuperuserPasswordConfiguredOnServer
public void testReconfigFailWithoutSuperuserPasswordConfiguredOnServer() throws InterruptedException
{        try {        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }    try {        zkAdmin.addAuthInfo("digest", "super:".getBytes());        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
ee21e09a797ad8d282f8f859d68a3ea84fcb72fc84c0e3a4ecaa505d033c9852
instantiateZKAdmin
private void instantiateZKAdmin() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
f0c569fd842c20ba90befcd40a3f7f7b7af8671b42730b880b9175d993797fe6
reconfigPort
private boolean reconfigPort() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    closeAllHandles(zkArr, zkAdminArr);    if (qu != null) {        qu.tearDown();    }}
225254579db89d5b34b605bfc85b00ca4d792225a7e5a6ad96735f2bd00c30c4
reconfig
public static String reconfig(ZooKeeperAdmin zkAdmin, List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig) throws KeeperException, InterruptedException
{    byte[] config = null;    String failure = null;    for (int j = 0; j < 30; j++) {        try {            config = zkAdmin.reconfigure(joiningServers, leavingServers, newMembers, fromConfig, new Stat());            failure = null;            break;        } catch (KeeperException.ConnectionLossException e) {            failure = "client could not connect to reestablished quorum: giving up after 30+ seconds.";        } catch (KeeperException.ReconfigInProgress e) {            failure = "reconfig still in progress: giving up after 30+ seconds.";        }        Thread.sleep(1000);    }    if (failure != null) {        fail(failure);    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
a62d742ef737121801aa651e8f357eb854bcb9db2dcac9bba83f4c36c4b32b78
testServerHasConfig
public static String testServerHasConfig(ZooKeeper zk, List<String> joiningServers, List<String> leavingServers) throws KeeperException, InterruptedException
{    boolean testNodeExists = false;    byte[] config = null;    for (int j = 0; j < 30; j++) {        try {            if (!testNodeExists) {                createZNode(zk, "/dummy", "dummy");                testNodeExists = true;            }                                    zk.setData("/dummy", "dummy".getBytes(), -1);            config = zk.getConfig(false, new Stat());            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
46dfc0fd205ac5e8a497fae81655b1cc02832b66f3d3728e537bc8eb558da961
testNormalOperation
public static void testNormalOperation(ZooKeeper writer, ZooKeeper reader) throws KeeperException, InterruptedException
{    boolean testReaderNodeExists = false;    boolean testWriterNodeExists = false;    for (int j = 0; j < 30; j++) {        try {            if (!testWriterNodeExists) {                createZNode(writer, "/test", "test");                testWriterNodeExists = true;            }            if (!testReaderNodeExists) {                createZNode(reader, "/dummy", "dummy");                testReaderNodeExists = true;            }            String data = "test" + j;            writer.setData("/test", data.getBytes(), -1);                                    reader.setData("/dummy", "dummy".getBytes(), -1);            byte[] res = reader.getData("/test", null, new Stat());            assertEquals(data, new String(res));            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }}
74597b11cab3b7ccaf72205e12a5c97dcf08edab4dc7f72bdd13a75b205b9403
createZNode
private static void createZNode(ZooKeeper zk, String path, String data) throws KeeperException, InterruptedException
{    try {        zk.create(path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {    }}
80c107d624fd427beabaa7316e0b3e14370e42c63c3f2efa3e99965255e19cd0
getLeaderId
private int getLeaderId(QuorumUtil qu)
{    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    return leaderId;}
231bea6caaee249bfb42632d3e256218a3753d2ba2a825499c4460aab47289cc
createHandles
public static ZooKeeper[] createHandles(QuorumUtil qu) throws IOException
{            ZooKeeper[] zkArr = new ZooKeeper[qu.ALL + 1];        zkArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkArr[i] = new ZooKeeper("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    }    return zkArr;}
12d2aa4e9261e0afe337f0b0ae567bcecb7b2b2948ad4310a304040e0816e00e
createAdminHandles
public static ZooKeeperAdmin[] createAdminHandles(QuorumUtil qu) throws IOException
{            ZooKeeperAdmin[] zkAdminArr = new ZooKeeperAdmin[qu.ALL + 1];        zkAdminArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkAdminArr[i] = new ZooKeeperAdmin("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[i].addAuthInfo("digest", "super:test".getBytes());    }    return zkAdminArr;}
ca3e457bf480136a026ec68238c9b2b338664aa2b1ba0a1d4bdda003570194f3
closeAllHandles
public static void closeAllHandles(ZooKeeper[] zkArr, ZooKeeperAdmin[] zkAdminArr) throws InterruptedException
{    if (zkArr != null) {        for (ZooKeeper zk : zkArr) {            if (zk != null) {                zk.close();            }        }    }    if (zkAdminArr != null) {        for (ZooKeeperAdmin zkAdmin : zkAdminArr) {            if (zkAdmin != null) {                zkAdmin.close();            }        }    }}
c6d1032889714034ae102a63fb2ac7a4606d60b326f056ed10710499627142df
testRemoveAddOne
public void testRemoveAddOne() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);            int leavingIndex = (leaderIndex == 1) ? 2 : 1;    for (int i = 0; i < 2; i++) {                                                        ZooKeeper zk1 = (leavingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeper zk2 = (leavingIndex == leaderIndex) ? zkArr[(leaderIndex % qu.ALL) + 1] : zkArr[leaderIndex];        ZooKeeperAdmin zkAdmin1 = (leavingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin2 = (leavingIndex == leaderIndex) ? zkAdminArr[(leaderIndex % qu.ALL) + 1] : zkAdminArr[leaderIndex];        leavingServers.add(Integer.toString(leavingIndex));                joiningServers.add("server." + leavingIndex + "=localhost:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex).peer.getClientPort());        String configStr = reconfig(zkAdmin1, null, leavingServers, null, -1);        testServerHasConfig(zk2, null, leavingServers);        testNormalOperation(zk2, zk1);        QuorumVerifier qv = qu.getPeer(1).peer.configFromString(configStr);        long version = qv.getVersion();                try {            reconfig(zkAdmin2, joiningServers, null, null, version + 1);            fail("reconfig succeeded even though version condition was incorrect!");        } catch (KeeperException.BadVersionException e) {        }        reconfig(zkAdmin2, joiningServers, null, null, version);        testNormalOperation(zk1, zk2);        testServerHasConfig(zk1, joiningServers, null);                        leavingIndex = leaderIndex = getLeaderId(qu);        leavingServers.clear();        joiningServers.clear();    }}
91df9dea0dd00a276b57e404a74358e2035bb11016532fd91618856b5a2fc18a
testRemoveAddTwo
public void testRemoveAddTwo() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);        int leavingIndex1 = leaderIndex;    int leavingIndex2 = (leaderIndex == 1) ? 2 : 1;        int stayingIndex1 = 1, stayingIndex2 = 1, stayingIndex3 = 1;    while (stayingIndex1 == leavingIndex1 || stayingIndex1 == leavingIndex2) {        stayingIndex1++;    }    while (stayingIndex2 == leavingIndex1 || stayingIndex2 == leavingIndex2 || stayingIndex2 == stayingIndex1) {        stayingIndex2++;    }    while (stayingIndex3 == leavingIndex1 || stayingIndex3 == leavingIndex2 || stayingIndex3 == stayingIndex1 || stayingIndex3 == stayingIndex2) {        stayingIndex3++;    }    leavingServers.add(Integer.toString(leavingIndex1));    leavingServers.add(Integer.toString(leavingIndex2));        joiningServers.add("server." + leavingIndex1 + "=localhost:" + qu.getPeer(leavingIndex1).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex1).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex1).peer.getClientPort());        joiningServers.add("server." + leavingIndex2 + "=localhost:" + qu.getPeer(leavingIndex2).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex2).peer.getElectionAddress().getPort() + ":observer;localhost:" + qu.getPeer(leavingIndex2).peer.getClientPort());    qu.shutdown(leavingIndex1);    qu.shutdown(leavingIndex2);        reconfig(zkAdminArr[stayingIndex2], null, leavingServers, null, -1);    qu.shutdown(stayingIndex2);                testServerHasConfig(zkArr[stayingIndex1], null, leavingServers);    testServerHasConfig(zkArr[stayingIndex3], null, leavingServers);    testNormalOperation(zkArr[stayingIndex1], zkArr[stayingIndex3]);                        Thread.sleep(10000);    try {        reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }        qu.restart(stayingIndex2);    reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);    testNormalOperation(zkArr[stayingIndex2], zkArr[stayingIndex3]);    testServerHasConfig(zkArr[stayingIndex2], joiningServers, null);                qu.restart(leavingIndex2);    assertTrue(qu.getPeer(leavingIndex2).peer.getPeerState() == ServerState.OBSERVING);    testNormalOperation(zkArr[stayingIndex2], zkArr[leavingIndex2]);    testServerHasConfig(zkArr[leavingIndex2], joiningServers, null);}
2f3bdbd835293ba4bf203515a8ed190b321bb62d6cb18e48e849a91377ddedb9
testBulkReconfig
public void testBulkReconfig() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            ArrayList<String> newServers = new ArrayList<String>();    for (int i = 1; i <= 5; i++) {        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + ((i == 4 || i == 5) ? "observer" : "participant") + ";localhost:" + qu.getPeer(i).peer.getClientPort();        newServers.add(server);    }    qu.shutdown(3);    qu.shutdown(6);    qu.shutdown(7);    reconfig(zkAdminArr[1], null, null, newServers, -1);    testNormalOperation(zkArr[1], zkArr[2]);    testServerHasConfig(zkArr[1], newServers, null);    testServerHasConfig(zkArr[2], newServers, null);    testServerHasConfig(zkArr[4], newServers, null);    testServerHasConfig(zkArr[5], newServers, null);    qu.shutdown(5);    qu.shutdown(4);    testNormalOperation(zkArr[1], zkArr[2]);}
ab839d6a730dfadee7db2cf521b080f6bf26e7a475f7d6a9ef696dfec41a37cd
testRemoveOneAsynchronous
public void testRemoveOneAsynchronous() throws Exception
{    qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();        leavingServers.add(getLeaderId(qu) == 5 ? "4" : "5");    List<Integer> results = new LinkedList<Integer>();    zkAdminArr[1].reconfigure(null, leavingServers, null, -1, this, results);    synchronized (results) {        while (results.size() < 1) {            results.wait();        }    }    assertEquals(0, (int) results.get(0));    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 5; i++) {        testServerHasConfig(zkArr[i], null, leavingServers);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
74880e14814f08c2e8ceb095ddaf65fb3e5d742f1d2dc780cc44675e67be22ff
testRoleChange
public void testRoleChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);                    int changingIndex = (leaderIndex == 1) ? 2 : 1;            String newRole = "observer";    for (int i = 0; i < 4; i++) {                                                        ZooKeeper zk1 = (changingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin1 = (changingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];                joiningServers.add("server." + changingIndex + "=localhost:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";localhost:" + qu.getPeer(changingIndex).peer.getClientPort());        reconfig(zkAdmin1, joiningServers, null, null, -1);        testNormalOperation(zkArr[changingIndex], zk1);        if (newRole.equals("observer")) {            assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);        } else {            assertTrue(qu.getPeer(changingIndex).peer.observer == null && (qu.getPeer(changingIndex).peer.follower != null || qu.getPeer(changingIndex).peer.leader != null));            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.FOLLOWING || qu.getPeer(changingIndex).peer.getPeerState() == ServerState.LEADING);        }        joiningServers.clear();        if (newRole.equals("observer")) {            newRole = "participant";        } else {                        newRole = "observer";            leaderIndex = getLeaderId(qu);            changingIndex = leaderIndex;        }    }}
55024d9edb1d5773fec7366a8b3ec1d71d646e7682c804657b2c167970ebd264
testPortChange
public void testPortChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;        int quorumPort = qu.getPeer(followerIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(followerIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(followerIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    joiningServers.add("server." + followerIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);            testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    reconfig(zkAdminArr[followerIndex], joiningServers, null, null, -1);    try {        for (int i = 0; i < 20; i++) {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);        }    } catch (KeeperException.ConnectionLossException e) {        fail("Existing client disconnected when client port changed!");    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    for (int i = 0; i < 10; i++) {        try {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to old client port!");        } catch (KeeperException.ConnectionLossException e) {        }    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    testServerHasConfig(zkArr[followerIndex], joiningServers, null);    assertEquals(newClientPort, qu.getPeer(followerIndex).peer.getClientPort());    joiningServers.clear();        int newQuorumPort = PortAssignment.unique();    joiningServers.add("server." + leaderIndex + "=localhost:" + newQuorumPort + ":" + qu.getPeer(leaderIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leaderIndex).peer.getClientPort());    reconfig(zkAdminArr[leaderIndex], joiningServers, null, null, -1);    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    assertTrue(qu.getPeer(leaderIndex).peer.getQuorumAddress().getPort() == newQuorumPort);    joiningServers.clear();    for (int i = 1; i <= 3; i++) {        joiningServers.add("server." + i + "=localhost:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + PortAssignment.unique() + ":participant;localhost:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], joiningServers, null, null, -1);    leaderIndex = getLeaderId(qu);    int follower1 = leaderIndex == 1 ? 2 : 1;    int follower2 = 1;    while (follower2 == leaderIndex || follower2 == follower1) {        follower2++;    }        qu.shutdown(getLeaderId(qu));    testNormalOperation(zkArr[follower2], zkArr[follower1]);    testServerHasConfig(zkArr[follower1], joiningServers, null);    testServerHasConfig(zkArr[follower2], joiningServers, null);}
ddf36e914d8556363c168646a5428d2b5eb60d9b36573dd3c04363399de302da
testPortChangeToBlockedPortFollower
public void testPortChangeToBlockedPortFollower() throws Exception
{    testPortChangeToBlockedPort(false);}
a00b7c64deb922676668a489ef90b9c94b0f3499148dce2c4b671ee47a578b92
testPortChangeToBlockedPortLeader
public void testPortChangeToBlockedPortLeader() throws Exception
{    testPortChangeToBlockedPort(true);}
d06d9e09cf2f34e7484b33fbde3e5a2605f4cb9d971b8ed78416478a05b33556
testPortChangeToBlockedPort
private void testPortChangeToBlockedPort(boolean testLeader) throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;    int serverIndex = testLeader ? leaderIndex : followerIndex;    int reconfigIndex = testLeader ? followerIndex : leaderIndex;        int quorumPort = qu.getPeer(serverIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(serverIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(serverIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    try (ServerSocket ss = new ServerSocket()) {        ss.bind(new InetSocketAddress(getLoopbackAddress(), newClientPort));        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);                        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);                reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        Thread.sleep(1000);                zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[serverIndex].close();        zkAdminArr[serverIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        try {            Thread.sleep(1000);            zkArr[serverIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to new client port!");        } catch (KeeperException.ConnectionLossException e) {                }        try (ServerSocket ss2 = new ServerSocket()) {            ss2.bind(new InetSocketAddress(getLoopbackAddress(), oldClientPort));        }                joiningServers.clear();        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + oldClientPort);        reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);        testServerHasConfig(zkArr[serverIndex], joiningServers, null);        assertEquals(oldClientPort, qu.getPeer(serverIndex).peer.getClientPort());    }}
e50edcbdbf573422d7e5c7252c15134c773f27900dde4c27f379941d3c4674f3
testUnspecifiedClientAddress
public void testUnspecifiedClientAddress() throws Exception
{    int[] ports = { PortAssignment.unique(), PortAssignment.unique(), PortAssignment.unique() };    String server = "server.0=localhost:" + ports[0] + ":" + ports[1] + ";" + ports[2];    QuorumServer qs = new QuorumServer(0, server);    assertEquals(qs.clientAddr.getHostString(), "0.0.0.0");    assertEquals(qs.clientAddr.getPort(), ports[2]);}
52ac3dd16576c9fe4c33a5ba6e5c835ec12fea06390df5b441d2d96c2008b1ba
testQuorumSystemChange
public void testQuorumSystemChange() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    ArrayList<String> members = new ArrayList<>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[2], zkArr[3]);    testNormalOperation(zkArr[4], zkArr[5]);    for (int i = 1; i <= 5; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumHierarchical)) {            fail("peer " + i + " doesn't think the quorum system is Hieararchical!");        }    }    qu.shutdown(1);    qu.shutdown(2);    qu.shutdown(3);    qu.shutdown(7);    qu.shutdown(6);        testNormalOperation(zkArr[4], zkArr[5]);    qu.restart(1);    qu.restart(2);    members.clear();    for (int i = 1; i <= 3; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[1], zkArr[2]);    qu.shutdown(4);    qu.shutdown(5);        testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 2; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumMaj)) {            fail("peer " + i + " doesn't think the quorum system is a majority quorum system!");        }    }}
c6ad5e339e2507202e78511c577b618c05732a82ec0ce20bdc19f417933df75a
testInitialConfigHasPositiveVersion
public void testInitialConfigHasPositiveVersion() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i < 4; i++) {        String configStr = testServerHasConfig(zkArr[i], null, null);        QuorumVerifier qv = qu.getPeer(i).peer.configFromString(configStr);        long version = qv.getVersion();        assertTrue(version == 0x100000000L);    }}
56830293022bdecc07a06ee9695279e80f8612e8f48ec257993f7bbff67fb5bf
testJMXBeanAfterRemoveAddOne
public void testJMXBeanAfterRemoveAddOne() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();        int leavingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);    ZooKeeper zk = zkArr[leavingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[leavingIndex];    leavingServers.add(Integer.toString(leavingIndex));        joiningServers.add("server." + leavingIndex + "=127.0.0.1:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;127.0.0.1:" + qu.getPeer(leavingIndex).peer.getClientPort());        reconfig(zkAdmin, null, leavingServers, null, -1);        QuorumPeer removedPeer = qu.getPeer(leavingIndex).peer;    String localPeerBean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + leavingIndex + ",name1=replica." + leavingIndex;    assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, false);        JMXEnv.ensureNone(remotePeerBean2);        JMXEnv.ensureNone(remotePeerBean3);        reconfig(zkAdmin, joiningServers, null, null, -1);        assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, true);        leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);}
c47d8161b022690d43d32b107b4825fa51cf0a52e55be4fc5107e7f5b5484710
testJMXBeanAfterRoleChange
public void testJMXBeanAfterRoleChange() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();        int changingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);    String newRole = "observer";    ZooKeeper zk = zkArr[changingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[changingIndex];        joiningServers.add("server." + changingIndex + "=127.0.0.1:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";127.0.0.1:" + qu.getPeer(changingIndex).peer.getClientPort());    reconfig(zkAdmin, joiningServers, null, null, -1);    testNormalOperation(zkArr[changingIndex], zk);    assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);    assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);    QuorumPeer qp = qu.getPeer(changingIndex).peer;    String localPeerBeanName = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + changingIndex + ",name1=replica." + changingIndex;        assertLocalPeerMXBeanAttributes(qp, localPeerBeanName, true);        changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);}
ea6278b5bc5fd23c95fa4eb9b9156764c1fa6b0058c38697e88df25d1a368da1
assertLocalPeerMXBeanAttributes
private void assertLocalPeerMXBeanAttributes(QuorumPeer qp, String beanName, Boolean isPartOfEnsemble) throws Exception
{    assertEquals("Mismatches LearnerType!", qp.getLearnerType().name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", qp.getClientAddress().getHostString() + ":" + qp.getClientAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ClientAddress"));    assertEquals("Mismatches LearnerType!", qp.getElectionAddress().getHostString() + ":" + qp.getElectionAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ElectionAddress"));    assertEquals("Mismatches PartOfEnsemble!", isPartOfEnsemble, JMXEnv.ensureBeanAttribute(beanName, "PartOfEnsemble"));    assertEquals("Mismatches ConfigVersion!", qp.getQuorumVerifier().getVersion(), JMXEnv.ensureBeanAttribute(beanName, "ConfigVersion"));    assertEquals("Mismatches QuorumSystemInfo!", qp.getQuorumVerifier().toString(), JMXEnv.ensureBeanAttribute(beanName, "QuorumSystemInfo"));}
8c10eb6f02ceb03a40a9229d966122eb7d3706962aa2e8aedd4edf57dd82e780
getAddrPortFromBean
 String getAddrPortFromBean(String beanName, String attribute) throws Exception
{    String name = (String) JMXEnv.ensureBeanAttribute(beanName, attribute);    if (!name.contains(":")) {        return name;    }    return getNumericalAddrPort(name);}
421b02d4d8fbb5269a5f7f57228aed46fb122c7a1ec29da2d1bb0943af88fb30
getNumericalAddrPort
 String getNumericalAddrPort(String name) throws UnknownHostException
{    String port = name.split(":")[1];    String addr = name.split(":")[0];    addr = InetAddress.getByName(addr).getHostAddress();    return addr + ":" + port;}
1867505771c599703e19267134f1a402f60b3424e1156f945a1f116bbc5a71a8
assertRemotePeerMXBeanAttributes
private void assertRemotePeerMXBeanAttributes(QuorumServer qs, String beanName) throws Exception
{    assertEquals("Mismatches LearnerType!", qs.type.name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", getNumericalAddrPort(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort()), getAddrPortFromBean(beanName, "ClientAddress"));    assertEquals("Mismatches ElectionAddress!", getNumericalAddrPort(qs.electionAddr.getHostString() + ":" + qs.electionAddr.getPort()), getAddrPortFromBean(beanName, "ElectionAddress"));    assertEquals("Mismatches QuorumAddress!", getNumericalAddrPort(qs.addr.getHostString() + ":" + qs.addr.getPort()), getAddrPortFromBean(beanName, "QuorumAddress"));}
36d99036c7560570022bc23ad4e037bb9a28c9f1a4a3630df9e53e1e0b051c29
testRecovery
public void testRecovery() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    int oldSnapCount = SyncRequestProcessor.getSnapCount();    SyncRequestProcessor.setSnapCount(1000);    try {        final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);        f.startup(zks);        LOG.info("starting up the the server, waiting");        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal = new CountDownLatch(1);        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        String path;        LOG.info("starting creating nodes");        for (int i = 0; i < 10; i++) {            path = "/" + i;            zk.create(path, (path + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                zk.create(subpath, (subpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    zk.create(subsubpath, (subsubpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        Stat stat = new Stat();        for (int i = 0; i < 10; i++) {            path = "/" + i;            LOG.info("Checking " + path);            assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        stat = new Stat();        LOG.info("Check 2");        for (int i = 0; i < 10; i++) {            path = "/" + i;            assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    } finally {        SyncRequestProcessor.setSnapCount(oldSnapCount);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.info("Event:" + event.getState() + " " + event.getType() + " " + event.getPath());    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
9d8b3cd859683a89d41b04646dc9b0ca11cf8184a309f6b27c5868c2dfda3b73
testFail
public void testFail() throws Exception
{    QuorumBase qb = new QuorumBase();    qb.setUp();    System.out.println("Comment: the servers are at " + qb.hostPort);    ZooKeeper zk = qb.createClient();    zk.create("/test", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    QuorumBase.shutdown(qb.s1);    QuorumBase.shutdown(qb.s2);    QuorumBase.shutdown(qb.s3);    QuorumBase.shutdown(qb.s4);    QuorumBase.shutdown(qb.s5);    String hp = qb.hostPort.split(",")[0];    ZooKeeperServer zks = new ZooKeeperServer(qb.s1.getTxnFactory().getSnapDir(), qb.s1.getTxnFactory().getDataDir(), 3000);    final int PORT = Integer.parseInt(hp.split(":")[1]);    ServerCnxnFactory factory = ServerCnxnFactory.createFactory(PORT, -1);    factory.startup(zks);    System.out.println("Comment: starting factory");    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    factory.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    System.out.println("Comment: shutting down standalone");}
094698eaef5d4bda9b33d2f56cf4fb48d70beda0481ffbff06e4577db66632eb
testResponseCache
public void testResponseCache() throws Exception
{    ZooKeeper zk = createClient();    try {        performCacheTest(zk, "/cache", true);        performCacheTest(zk, "/nocache", false);    } finally {        zk.close();    }}
aa291975e9a3f7528e53efc017e65be8fa5434574ac832910098628eb0d1a11e
checkCacheStatus
private void checkCacheStatus(long expectedHits, long expectedMisses)
{    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    assertEquals(expectedHits, metrics.get("response_packet_cache_hits"));    assertEquals(expectedMisses, metrics.get("response_packet_cache_misses"));}
ae9cd21f340f0e28465ed08719ca38c5786f302c87d1be7b8a18513818739efa
performCacheTest
public void performCacheTest(ZooKeeper zk, String path, boolean useCache) throws Exception
{    ServerMetrics.getMetrics().resetAll();    Stat writeStat = new Stat();    Stat readStat = new Stat();    byte[] readData = null;    int reads = 10;    long expectedHits = 0;    long expectedMisses = 0;    serverFactory.getZooKeeperServer().setResponseCachingEnabled(useCache);    LOG.info("caching: {}", useCache);    byte[] writeData = "test1".getBytes();    zk.create(path, writeData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, writeStat);    for (int i = 0; i < reads; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);    writeData = "test2".getBytes();    writeStat = zk.setData(path, writeData, -1);    for (int i = 0; i < 10; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);                    zk.create(path + "/child", "child".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    readData = zk.getData(path, false, readStat);    if (useCache) {        expectedMisses++;    }    assertArrayEquals(writeData, readData);    assertNotSame(writeStat, readStat);    checkCacheStatus(expectedHits, expectedMisses);}
c1b225d4f5421c22f0e600264bd3b4c1b988c78adb107b35eb36b615f3889f36
testRestoreCommittedLogWithSnapSize
public void testRestoreCommittedLogWithSnapSize() throws Exception
{    final int minExpectedSnapshots = 5;    final int minTxnsToSnap = 256;    final int numTransactions = minExpectedSnapshots * minTxnsToSnap;    final StringBuilder sb = new StringBuilder();    for (int i = 0; i < 4 * 1024; i++) {        sb.append("0");    }    final byte[] data = sb.toString().getBytes();    SyncRequestProcessor.setSnapCount(numTransactions * 1000);                SyncRequestProcessor.setSnapSizeInBytes(minTxnsToSnap * data.length);    testRestoreCommittedLog(numTransactions, data, minExpectedSnapshots);}
48d617b2b7ab15c9ce0ed13dcdb5b0f629b1a5610a4f17d45cb3db194c704008
testRestoreCommittedLogWithSnapCount
public void testRestoreCommittedLogWithSnapCount() throws Exception
{    final int minExpectedSnapshots = 30;    final int snapCount = 100;    SyncRequestProcessor.setSnapCount(snapCount);    SyncRequestProcessor.setSnapSizeInBytes(4294967296L);    testRestoreCommittedLog(minExpectedSnapshots * snapCount, new byte[0], minExpectedSnapshots);}
5d6bbeb8782a643624b39e79317804d82242369d3dd4603314a1e2e9eaf0bc34
testRestoreCommittedLog
private void testRestoreCommittedLog(int totalTransactions, byte[] data, int minExpectedSnapshots) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < totalTransactions; i++) {            zk.create("/invalidsnap-" + i, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    final int numSnaps = zks.getTxnLogFactory().findNRecentSnapshots(10 * minExpectedSnapshots).size();    LOG.info("number of snapshots taken {}", numSnaps);    f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    assertTrue("too few snapshot files", numSnaps > minExpectedSnapshots);    assertTrue("too many snapshot files", numSnaps <= minExpectedSnapshots * 2);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    Collection<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();    int logsize = committedLog.size();    LOG.info("committedLog size = {}", logsize);    assertTrue("log size != 0", (logsize != 0));    zks.shutdown();}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
503448d8b510fd1cca8d49378b18c61b4af5e5a76a7c50fc31f0ab645e3931c7
testSaslConfig
public void testSaslConfig() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getChildren("/", false);        assertFalse(zk.getSaslClient().clientTunneledAuthenticationInProgress());        assertEquals(zk.getSaslClient().getSaslState(), ZooKeeperSaslClient.SaslState.COMPLETE);        assertNotNull(javax.security.auth.login.Configuration.getConfiguration().getAppConfigurationEntry("MyZookeeperClient"));        assertSame(zk.getSaslClient().getLoginContext(), "MyZookeeperClient");    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
208a37cdaf1e46d3e83007d4e3e60fc520942bc45870cd11921fc836a3813e7d
testReadAccessUser
public void testReadAccessUser() throws Exception
{    System.setProperty("zookeeper.letAnySaslUserDoX", "anyone");    ZooKeeper zk = createClient();    List<ACL> aclList = new ArrayList<ACL>();    ACL acl = new ACL(Perms.ADMIN | Perms.CREATE | Perms.WRITE | Perms.DELETE, new Id("sasl", "fakeuser"));    ACL acl1 = new ACL(Perms.READ, new Id("sasl", "anyone"));    aclList.add(acl);    aclList.add(acl1);    try {        zk.create("/abc", "testData".getBytes(), aclList, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Unable to create znode");    }    zk.close();    Thread.sleep(100);        zk = createClient();    try {        zk.setData("/abc", "testData1".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException.NoAuthException e) {        }    try {        byte[] bytedata = zk.getData("/abc", null, null);        String data = new String(bytedata);        assertTrue("testData".equals(data));    } catch (KeeperException e) {        fail("failed to get data");    }    zk.close();    Thread.sleep(100);        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "false");    try {        zk = createClient();        try {            zk.getData("/abc", null, null);            fail("Should not be able to read data when not authenticated");        } catch (KeeperException.NoAuthException e) {                }        zk.close();    } finally {                System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "true");    }}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    authCompleted = new CountDownLatch(1);    super.reset();}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();        authCompleted.countDown();    } else if (event.getState() == KeeperState.SaslAuthenticated) {        authCompleted.countDown();    } else {        super.process(event);    }}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = createClient(watcher);    watcher.authCompleted.await(AUTHENTICATION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(authFailed.get(), 0);    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{            CountdownWatcher watcher = new CountdownWatcher();    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                LOG.info("Got exception as expected: " + e);    } finally {        zk.close();    }}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
96d247a793c82e7f29601709422b760d8dfc3efcc456e524a6d3caed5854303f
testAuthFail
public void testAuthFail()
{    try (ZooKeeper zk = createClient()) {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (Exception e) {                LOG.info("Got exception as expected: " + e);    }}
702ff2c4850ecd6efeb466fe7525cc6c6ade55e6f683b2ce48fba10092ae0f6a
testBadSaslAuthNotifiesWatch
public void testBadSaslAuthNotifiesWatch() throws Exception
{    try (ZooKeeper ignored = createClient(new MyWatcher(), hostPort)) {                authFailed.await();    }}
7e5eab181020fbbf92e6e281bfa86376d9464cce1d907b73ae926084501ccdb1
testAuth
public void testAuth() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                LOG.info("Got exception as expected: " + e);    } finally {        zk.close();    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);}
9a06c7a5fb5ed79eae45c9ec00bd53b29bc6c57295fba8bb5c8c1754631011b4
testClientOpWithoutSASLConfigured
public void testClientOpWithoutSASLConfigured() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client is not configured with SASL authentication, so zk.create operation should fail.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH);                        watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
4b8f45af0d1f955ed705ca68f3beffeba21aaa9000e02370e7e3981dd7b9b4d8
setUpBeforeClass
public static void setUpBeforeClass()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas_wrong.conf", "test1"));}
da98d1dd1dca02580c453d82c2bc597fa6dc470df6a86290aef91eaa9fd22b6c
tearDownAfterClass
public static void tearDownAfterClass()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
7b53b09c66e7eff37081015f9616a715689d415fb26d570ed6dda7cfbf6faccc
testClientOpWithFailedSASLAuth
public void testClientOpWithFailedSASLAuth() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/bar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client with wrong SASL config should not pass SASL authentication.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.AUTHFAILED);                watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
4b8f45af0d1f955ed705ca68f3beffeba21aaa9000e02370e7e3981dd7b9b4d8
setUpBeforeClass
public static void setUpBeforeClass()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas.conf", "test"));}
da98d1dd1dca02580c453d82c2bc597fa6dc470df6a86290aef91eaa9fd22b6c
tearDownAfterClass
public static void tearDownAfterClass()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
7ee1292cdbaea1acc5eaa9edd47e09dcc800a4ba41965be15b384a640a7f2aef
testClientOpWithValidSASLAuth
public void testClientOpWithValidSASLAuth() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foobar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Client operation should succeed with valid SASL configuration.");    } finally {        if (zk != null) {            zk.close();        }    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    existingPropertyValue = System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{        if (existingPropertyValue != null) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, existingPropertyValue);    }}
009a9f6bc38b59e1666a835cb35ed5e360780fda6c40f678d306e7c70a694d97
testSaslClientDisabled
public void testSaslClientDisabled()
{    System.clearProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);    assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    for (String value : Arrays.asList("true", "TRUE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }    for (String value : Arrays.asList("false", "FALSE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertFalse("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }}
e445e3dc3157ef0fd8ec03b92490bbb3c30f782c4157c79f21a69b4bb8975625
setupStatic
public static void setupStatic() throws Exception
{    oldAuthProvider = System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    File tmpDir = createTmpDir();    File saslConfFile = new File(tmpDir, "jaas.conf");    FileWriter fwriter = new FileWriter(saslConfFile);    fwriter.write("" + "Server {\n" + "          org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "          user_super_duper=\"test\";\n" + "};\n" + "Client {\n" + "       org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "       username=\"super_duper\"\n" + "       password=\"test\";\n" + "};" + "\n");    fwriter.close();    oldLoginConfig = System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    oldSuperUser = System.setProperty("zookeeper.superUser", "super_duper");    otherDigestUser = new Id("digest", DigestAuthenticationProvider.generateDigest("jack:jack"));}
795659800afe97b144d39841f266b1673df7d7cd32b473c10b643c8b46c54778
cleanupStatic
public static void cleanupStatic()
{    if (oldAuthProvider != null) {        System.setProperty("zookeeper.authProvider.1", oldAuthProvider);    } else {        System.clearProperty("zookeeper.authProvider.1");    }    oldAuthProvider = null;    if (oldLoginConfig != null) {        System.setProperty("java.security.auth.login.config", oldLoginConfig);    } else {        System.clearProperty("java.security.auth.login.config");    }    oldLoginConfig = null;    if (oldSuperUser != null) {        System.setProperty("zookeeper.superUser", oldSuperUser);    } else {        System.clearProperty("zookeeper.superUser");    }    oldSuperUser = null;}
f58c576ed3ef14f5efc0081deb406dd784a3958d0a8b733145efdc7d23f14715
createClient
protected TestableZooKeeper createClient(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();    } else {        super.process(event);    }}
1853e1f4fdc503ee745b64f14516cce0bfa7b416a677542449ba01d87defc20b
testSuperIsSuper
public void testSuperIsSuper() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/digest_read", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/digest_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.delete("/digest_read/sub", -1);        zk.delete("/digest_read", -1);        zk.delete("/sasl_read/sub", -1);        zk.delete("/sasl_read", -1);                assertEquals(authFailed.get(), 0);    } finally {        zk.close();    }}
bdf7328ddc75f1debf6c4abcab9b34a12a99651b4da0949fb1b49bcb331a2f97
createJAASConfigFile
 static String createJAASConfigFile(String fileName, String password)
{    String ret = null;    try {        File tmpDir = createTmpDir();        File jaasFile = new File(tmpDir, fileName);        FileWriter fwriter = new FileWriter(jaasFile);        fwriter.write("" + "Server {\n" + "          " + digestLoginModule + " required\n" + "          user_super=\"test\";\n" + "};\n" + "Client {\n" + "       " + digestLoginModule + " required\n" + "       username=\"super\"\n" + "       password=\"" + password + "\";\n" + "};" + "\n");        fwriter.close();        ret = jaasFile.getAbsolutePath();    } catch (IOException e) {        fail("Unable to create JaaS configuration file!");    }    return ret;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    System.setProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, Integer.toString(cnxnTimeout));    super.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    System.clearProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT);}
5bca7076ac4f4d8b717caed189d83ec3d3cf68fa7fe62dc59e15a49b6c40fc35
testServerCnxnExpiry
public void testServerCnxnExpiry() throws Exception
{    verify("ruok", "imok");                String resp = sendRequest("ruok", 2 * cnxnTimeout + 1000);    assertEquals("Connection should have closed", "", resp);}
e0fe16936f7cd53a35d2923f99e973debaf577707eb1c7f3e2f8565c3c279351
verify
private void verify(String cmd, String expected) throws IOException
{    String resp = sendRequest(cmd, 0);    LOG.info("cmd " + cmd + " expected " + expected + " got " + resp);    assertTrue(resp.contains(expected));}
d873659faf41b72b62aa2606f64864cf6a7a8eddb5cbb6eb6f4bb0c40edff95f
sendRequest
private String sendRequest(String cmd, int delay) throws IOException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, delay);}
ce5440fb474c371b3f7fe82d0725d380af8c0e3f5e0698c4b4c5306c502d7201
send4LetterWord
private static String send4LetterWord(String host, int port, String cmd, int delay) throws IOException
{    LOG.info("connecting to " + host + " " + port);    Socket sock = new Socket(host, port);    BufferedReader reader = null;    try {        try {            LOG.info("Sleeping for " + delay + "ms");            Thread.sleep(delay);        } catch (InterruptedException e) {                }        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                sock.shutdownOutput();        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = readLine(reader);        return sb.toString();    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
48491e8a98ed24b462a269d7e6aded16c97fa9b83aef0cb8550615eb1ab10a07
readLine
private static StringBuilder readLine(BufferedReader reader)
{    StringBuilder sb = new StringBuilder();    String line;    try {        while ((line = reader.readLine()) != null) {            sb.append(line + "\n");        }    } catch (IOException ioe) {                                        LOG.info("Connnection is expired", ioe);    }    return sb;}
72c2e90e6686112d6df0152bfc92d30cbba329b7a703251b7a48373f0beef321
testCreateAfterCloseShouldFail
public void testCreateAfterCloseShouldFail() throws Exception
{    for (int i = 0; i < 10; i++) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(44, "len");        ConnectRequest conReq = new ConnectRequest(0, 0, 30000, 0, new byte[16]);        conReq.serialize(boa, "connect");                boa.writeInt(8, "len");        RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.closeSession);        h.serialize(boa, "header");                        boa.writeInt(52, "len");        RequestHeader header = new RequestHeader(2, OpCode.create);        header.serialize(boa, "header");        CreateRequest createReq = new CreateRequest("/foo" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, 1);        createReq.serialize(boa, "request");        baos.close();        System.out.println("Length:" + baos.toByteArray().length);        String[] hp = hostPort.split(":");        Socket sock = new Socket(hp[0], Integer.parseInt(hp[1]));        InputStream resultStream = null;        try {            OutputStream outstream = sock.getOutputStream();            byte[] data = baos.toByteArray();            outstream.write(data);            outstream.flush();            resultStream = sock.getInputStream();            byte[] b = new byte[10000];            int len;            while ((len = resultStream.read(b)) >= 0) {                                System.out.println("gotlen:" + len);            }        } finally {            if (resultStream != null) {                resultStream.close();            }            sock.close();        }    }    ZooKeeper zk = createClient();    assertEquals(1, zk.getChildren("/", false).size());    zk.close();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    if (tmpDir == null) {        tmpDir = ClientBase.createTmpDir();    }    ClientBase.setupTestEnv();    zs = new ZooKeeperServer(tmpDir, tmpDir, TICK_TIME);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    serverFactory = ServerCnxnFactory.createFactory(PORT, -1);    serverFactory.startup(zs);    assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    serverFactory.shutdown();    zs.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
dd97ad02f7f903d23fc7011a3d733f53c882cda0ca9bc6b79d520ed769984e5a
createClient
private DisconnectableZooKeeper createClient() throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(CONNECTION_TIMEOUT, watcher);}
9b6633ae96375b2fdc3c67823f93f1a479d7769e0e18532e7e2f23b44ade1c4a
createClient
private DisconnectableZooKeeper createClient(int timeout) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(timeout, watcher);}
9732d7c511beceb2d87fad746accb59cc981123577918e539f23f84d999fe46b
createClient
private DisconnectableZooKeeper createClient(int timeout, CountdownWatcher watcher) throws IOException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.info(name + " event:" + event.getState() + " " + event.getType() + " " + event.getPath());    if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
6cd721ae24db485731294c3f350a75df0f5f824b2e26fb0c0066a9ec89c437bb
testSession
public void testSession() throws IOException, InterruptedException, KeeperException
{    DisconnectableZooKeeper zk = createClient();    zk.create("/e", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    LOG.info("zk with session id 0x" + Long.toHexString(zk.getSessionId()) + " was destroyed!");                zk.disconnect();    Stat stat = new Stat();    startSignal = new CountDownLatch(1);    zk = new DisconnectableZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, new MyWatcher("testSession"), zk.getSessionId(), zk.getSessionPasswd());    startSignal.await();    LOG.info("zk with session id 0x" + Long.toHexString(zk.getSessionId()) + " was created!");    zk.getData("/e", false, stat);    LOG.info("After get data /e");    zk.close();    zk = createClient();    assertEquals(null, zk.exists("/e", false));    LOG.info("before close zk with session id 0x" + Long.toHexString(zk.getSessionId()) + "!");    zk.close();    try {        zk.getData("/e", false, stat);        fail("Should have received a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {    }    AsyncCallback.DataCallback cb = new AsyncCallback.DataCallback() {        String status = "not done";        public void processResult(int rc, String p, Object c, byte[] b, Stat s) {            synchronized (this) {                status = KeeperException.Code.get(rc).toString();                this.notify();            }        }        public String toString() {            return status;        }    };    zk.getData("/e", false, cb, null);    synchronized (cb) {        if (cb.toString().equals("not done")) {            cb.wait(1000);        }    }    assertEquals(KeeperException.Code.SESSIONEXPIRED.toString(), cb.toString());}
aec1491370c6309063a4f804e0d817f3ac3fea691dad4ffae77cc53b0f79fb0e
processResult
public void processResult(int rc, String p, Object c, byte[] b, Stat s)
{    synchronized (this) {        status = KeeperException.Code.get(rc).toString();        this.notify();    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return status;}
ba3934a5dd06f3b42036e443e4742603557af13f8351abd976596df5324cafb0
testSessionMove
public void testSessionMove() throws Exception
{    String[] hostPorts = HOSTPORT.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], CONNECTION_TIMEOUT, new MyWatcher("0"));    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }        LOG.info(hostPorts[(i + 1) % hostPorts.length] + " Sync returned " + result[0]);        assertTrue(result[0] == KeeperException.Code.OK.intValue());        zknew.setData("/", new byte[1], -1);        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {            LOG.info("Got connection loss exception as expected");        }                zk = zknew;    }    zk.close();}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
90ee8d87e34daf512ce89b2a8dfb7a71535cb9face587f57588d50c717f95f47
testSessionStateNoDupStateReporting
public void testSessionStateNoDupStateReporting() throws IOException, InterruptedException, KeeperException
{    final int TIMEOUT = 3000;    DupWatcher watcher = new DupWatcher();    ZooKeeper zk = createClient(TIMEOUT, watcher);        serverFactory.shutdown();    try {        Thread.sleep(10000);    } catch (InterruptedException e) {        }                    assertEquals(2, watcher.states.size());    zk.close();}
e7b44f2da647688edb65730d069f355084b5e03e5844d4368bf926fbe4f81215
testSessionTimeoutAccess
public void testSessionTimeoutAccess() throws Exception
{        DisconnectableZooKeeper zk = createClient(TICK_TIME * 4);    assertEquals(TICK_TIME * 4, zk.getSessionTimeout());        LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());        zk = createClient(TICK_TIME);    assertEquals(TICK_TIME * 2, zk.getSessionTimeout());    LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());        zk = createClient(TICK_TIME * 30);    assertEquals(TICK_TIME * 20, zk.getSessionTimeout());    LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() == EventType.None) {        states.add(event);    }}
2106c8fe56e22fbf6f2a39d8f90bb4b6c41fe283a8bd3762df17ba33c373f2d2
testMinMaxSessionTimeout
public void testMinMaxSessionTimeout() throws Exception
{        final int MINSESS = 20000;    final int MAXSESS = 240000;    {        ZooKeeperServer zs = serverFactory.getZooKeeperServer();        zs.setMinSessionTimeout(MINSESS);        zs.setMaxSessionTimeout(MAXSESS);    }        int timeout = 120000;    DisconnectableZooKeeper zk = createClient(timeout);    assertEquals(timeout, zk.getSessionTimeout());        LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());        zk = createClient(MINSESS / 2);    assertEquals(MINSESS, zk.getSessionTimeout());    LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());        zk = createClient(MAXSESS * 2);    assertEquals(MAXSESS, zk.getSessionTimeout());    LOG.info(zk.toString());    zk.close();    LOG.info(zk.toString());}
751f79923c9e42d46a8b413db2d25c5497c639b6517cdde9da0646d13ed0642f
testMaximumCnxnPerIP
public void testMaximumCnxnPerIP() throws Exception
{    final int maxClientCnxnsPerIP = 3;    serverFactory.setMaxClientCnxnsPerHost(maxClientCnxnsPerIP);    ZooKeeper[] clients = new ZooKeeper[maxClientCnxnsPerIP + 1];    for (int i = 0; i < clients.length; i++) {        CountdownWatcher watcher = new CountdownWatcher();                int timeout = 3000;        clients[i] = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);        boolean result = watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS);        if (i >= maxClientCnxnsPerIP) {            assertFalse(result);        } else {            assertTrue(result);        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
a38ac3078bd466ebcba6dfa9fa92f82ab5f2955b56c8cf4aa755ef324a2be7f8
testSessionExpiration
public void testSessionExpiration() throws InterruptedException, KeeperException
{    final CountDownLatch expirationLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getState() == Watcher.Event.KeeperState.Expired) {            expirationLatch.countDown();        }    };    zk.exists("/foo", watcher);    zk.getTestable().injectSessionExpiration();    assertTrue(expirationLatch.await(5, TimeUnit.SECONDS));    boolean gotException = false;    try {        zk.exists("/foo", false);        fail("Should have thrown a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {                gotException = true;    }    assertTrue(gotException);}
dc160cb5b6f3f7c53e269cab417c57a1daaf91b86167b8d8d83a71d268a2af18
testQueueEvent
public void testQueueEvent() throws InterruptedException, KeeperException
{    final CountDownLatch eventLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/foo/bar")) {                eventLatch.countDown();            }        }    };    zk.exists("/foo/bar", watcher);    WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.NodeDataChanged, Watcher.Event.KeeperState.SyncConnected, "/foo/bar");    zk.getTestable().queueEvent(event);    assertTrue(eventLatch.await(5, TimeUnit.SECONDS));}
d9216a0f895ba033fbb572ec48937b1e3c4357c70c1e31ca35fa1c825f36f6dd
testSessionDisconnect
public void testSessionDisconnect() throws KeeperException, InterruptedException, IOException
{    zk.create("/sdisconnect", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdisconnect", null));    zk.close();    zk = createClient();    assertNull("Ephemeral node shouldn't exist after client disconnect", zk.exists("/sdisconnect", null));}
02a46b934d211881a962095963220c6eb02318cfd60ac73688ea9a6f296f72c6
testSessionRestore
public void testSessionRestore() throws KeeperException, InterruptedException, IOException
{    zk.create("/srestore", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/srestore", null));    zk.disconnect();    zk.close();    zk = createClient();    assertNotNull("Ephemeral node should be present when session is restored", zk.exists("/srestore", null));}
00e2369c59c62d61d90be3e2dbef82ea98530a08f63f260c3bed659d17a0d8bf
testSessionSurviveServerRestart
public void testSessionSurviveServerRestart() throws Exception
{    zk.create("/sdeath", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdeath", null));    zk.disconnect();    stopServer();    startServer();    zk = createClient();    assertNotNull("Ephemeral node should be present when server restarted", zk.exists("/sdeath", null));}
6143978b9aed171a0f1bdcd090bdbdefd04ff2a38cd72557e505df084e82d8b1
expire
public void expire(Session session)
{}
de9294c8628a308675006686952d17f7c03dd2529a6d217e6790021b29017ba7
getServerId
public long getServerId()
{    return sid;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    sessionsWithTimeouts.clear();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{}
fdfbb47a2c307bc5a5b6640a1164b5204507d9d2ad0e629389d9838ff329918f
testLearnerSessionTracker
public void testLearnerSessionTracker() throws Exception
{    Expirer expirer = new Expirer(1);        LearnerSessionTracker tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = 0xb100ded;    try {        tracker.checkSession(sessionId, null);        fail("Unknown session should have failed");    } catch (SessionExpiredException e) {        }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session should not fail");    }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }        tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Should not get any exception");    }}
9496af3b2b379a9c2810740ee2ef866e6718bb5e22105ebe5ab384b701dab434
testLeaderSessionTracker
public void testLeaderSessionTracker() throws Exception
{    Expirer expirer = new Expirer(2);        LeaderSessionTracker tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = ((expirer.sid + 1) << 56) + 1;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("local session from other server should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session on the leader should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = ((expirer.sid + 1) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from other server should fail");    } catch (SessionExpiredException e) {        }        sessionId = ((expirer.sid) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from the leader should fail");    } catch (SessionExpiredException e) {        }}
5129b23bef73ffa588296e3f285f92a03be2100002c07c2466590061386bd581
testZKSListener
 ZooKeeperServerListener testZKSListener()
{    return new ZooKeeperServerListener() {        @Override        public void notifyStopping(String errMsg, int exitCode) {        }    };}
4195ca76e814e0a1bdabd43317aca878bae1baa2b207b838723ae63b29faebff
notifyStopping
public void notifyStopping(String errMsg, int exitCode)
{}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());    qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());    qb.tearDown();}
b5507efc228ef8a52165eebb84c9c446d3885ca41ed9dc51788a696186a6a255
testLocalSessionsWithoutEphemeralOnFollower
public void testLocalSessionsWithoutEphemeralOnFollower() throws Exception
{    testLocalSessionsWithoutEphemeral(false);}
cf03920c9fa254a6113c70a5864f867834fb58e7302ed7a3247d492b6361e4b4
testLocalSessionsWithoutEphemeralOnLeader
public void testLocalSessionsWithoutEphemeralOnLeader() throws Exception
{    testLocalSessionsWithoutEphemeral(true);}
d978f68d3b7a47a3c10b9acbd326ea386379b273e33ff5b83e68981a942dfa95
testLocalSessionsWithoutEphemeral
private void testLocalSessionsWithoutEphemeral(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();        try {        watcher.reset();        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Connection on the same session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    } catch (KeeperException.ConnectionLossException e) {    }        if (!testLeader) {        try {            watcher.reset();            DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[leaderIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);            zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("Connection on the same session ID should fail.");        } catch (KeeperException.SessionExpiredException e) {        } catch (KeeperException.ConnectionLossException e) {        }    }                zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.create(nodePrefix + "6", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.create(nodePrefix + "7", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }}
24f31f8ba9351cc1aaeea0b37a0fe542f0314fef298e331c18d12b6fce25d0bb
testUpgradeWithEphemeralOnFollower
public void testUpgradeWithEphemeralOnFollower() throws Exception
{    testUpgradeWithEphemeral(false);}
860acdb5bed00fd0500b7162fe2577a9871dec0e989cdd79101982dfd3a7460f
testUpgradeWithEphemeralOnLeader
public void testUpgradeWithEphemeralOnLeader() throws Exception
{    testUpgradeWithEphemeral(true);}
847e3696ba8b85553d09cc4f0993099e385fb1d8c4e117e24968049d68f4954a
testUpgradeWithEphemeral
private void testUpgradeWithEphemeral(boolean testLeader) throws Exception
{    String nodePrefix = "/testUpgrade-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }            long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();    zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        assertNotNull(zk.exists(nodePrefix + i, null));    }            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.exists(nodePrefix + "0", null);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }    watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    for (int i = 0; i < 5; i++) {        assertNull(zk.exists(nodePrefix + i, null));    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Stat stat = new Stat();        String path = zk.create("/hammers/hammer-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        byte[] tag = (path + " was here!").getBytes();        synchronized (this) {            String startPath = "/hammers/start";            System.out.println("Waiting for " + startPath);            while (zk.exists(startPath, true) == null) {                wait();            }            System.out.println("Running");        }        for (int i = 0; i < count; i++) {            try {                System.out.print(i + "\r");                List<String> childs = zk.getChildren("/hammers", false);                Collections.shuffle(childs);                for (String s : childs) {                    if (s.startsWith("hammer-")) {                        s = "/hammers/" + s;                        zk.setData(s, tag, -1);                        for (int j = 0; j < readsPerWrite; j++) {                            zk.getData(s, false, stat);                        }                        break;                    }                }            } catch (KeeperException.ConnectionLossException e) {                        } catch (KeeperException e) {                e.printStackTrace();            }        }        System.out.println();        zk.close();    } catch (RuntimeException e) {        e.printStackTrace();    } catch (InterruptedException e) {        e.printStackTrace();    } catch (KeeperException e) {        e.printStackTrace();    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 3) {        System.err.println("USAGE: SledgeHammer zookeeper_server reps reads_per_rep");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    }    SledgeHammer h = new SledgeHammer(args[0], Integer.parseInt(args[1]), Integer.parseInt(args[2]));    h.start();    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
5dcd71b4114a2e1000f48e52170caf3750ba7b27e9894103951aba8181820c77
setUpSecure
public static ClientX509Util setUpSecure() throws Exception
{    ClientX509Util x509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(x509Util.getSslAuthProviderProperty(), "x509");    System.setProperty(x509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(x509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(x509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(x509Util.getSslTruststorePasswdProperty(), "testpass");    System.setProperty("javax.net.debug", "ssl");    System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");    return x509Util;}
db2584aee7c44cf5c506d34d8198b014a9f6b8c3929ad9b5c45cf68aedbba311
clearSecureSetting
public static void clearSecureSetting(ClientX509Util clientX509Util)
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    System.clearProperty("javax.net.debug");    System.clearProperty("zookeeper.authProvider.x509");    clientX509Util.close();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    clientX509Util = setUpSecure();    String host = "localhost";    int port = PortAssignment.unique();    hostPort = host + ":" + port;    serverFactory = ServerCnxnFactory.createFactory();    serverFactory.configure(new InetSocketAddress(host, port), maxCnxns, -1, true);    super.setUp();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    clearSecureSetting(clientX509Util);}
c7847ced8ec19d9f701478c2374c5dda3b07220e5241260807010c67a3a58d1b
testRejection
public void testRejection() throws Exception
{    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");        System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testUntrustedKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    CountdownWatcher watcher = new CountdownWatcher();        new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Untrusted certificate should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
078bbbd069a59edf8f3695a2314799342b6239e23382626e9ae658c560a6929a
testMisconfiguration
public void testMisconfiguration() throws Exception
{    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    CountdownWatcher watcher = new CountdownWatcher();    new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Missing SSL configuration should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
ea6a9a7a53fbc47b66014f9ab1f83f198319b411c82cbf0c4a53f68a8a6b9062
testNoDynamicConfig
public void testNoDynamicConfig() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, CLIENT_PORT, "", false);    verifyStandalone(mt, CLIENT_PORT);}
6598cdf8e7775fbe395519d4f6bb42060c025b199c2f0b220383a5d971476836
testClientPortInDynamicFile
public void testClientPortInDynamicFile() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection);    verifyStandalone(mt, CLIENT_PORT);}
b019203b4e1b459dcaca7dffeaac01d3c5616eaa2d9c00579ef82e452e34e51f
testClientPortInStaticFile
public void testClientPortInStaticFile() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection, false);    verifyStandalone(mt, CLIENT_PORT);}
10023c497e19912cebd5007f7b018ab659a2baec20b4966920e6954e38a2569f
verifyStandalone
 void verifyStandalone(MainThread mt, int clientPort) throws InterruptedException
{    mt.start();    try {        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    } finally {        assertFalse("Error- MainThread started in Quorum Mode!", mt.isQuorumPeerRunning());        mt.shutdown();    }}
cb1ffce689d2b45c8ea31bcd56187cc195c2385fc9560f597839838b2f248c30
testStandaloneReconfigFails
public void testStandaloneReconfigFails() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, watcher);    ZooKeeperAdmin zkAdmin = new ZooKeeperAdmin(HOSTPORT, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    List<String> joiners = new ArrayList<String>();    joiners.add("server.2=localhost:1234:1235;1236");        try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        zkAdmin.reconfigure(joiners, null, null, -1, new Stat());        fail("Reconfiguration in standalone should trigger " + "UnimplementedException");    } catch (KeeperException.UnimplementedException ex) {        }    zk.close();    zks.shutdown();    f.shutdown();    assertTrue("waiting for server being down ", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
ce85ebfbbacccb695ec204f3a0aec8022cc35f5b6462160bc39bc34e6bad95c7
testNextGoesRound
public void testNextGoesRound()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    hostProvider.next(0);    assertEquals(first, hostProvider.next(0));}
1547e91a09fc823e797387273e28a7484bded057c02e56bf7ea067964187773b
testNextGoesRoundAndSleeps
public void testNextGoesRoundAndSleeps()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(1000);    long stop = Time.currentElapsedTime();    assertTrue(900 <= stop - start);}
0a563b5f20b845a39f299d788112a57b6161207b85e79402c94f7315fdac7297
testNextDoesNotSleepForZero
public void testNextDoesNotSleepForZero()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(0);    long stop = Time.currentElapsedTime();    assertTrue(5 > stop - start);}
926b1239257fe32630f3cea6f401c30a7d575ae2ed17cf8fe5ac07db81ba5a2d
testEmptyServerAddressesList
public void testEmptyServerAddressesList()
{    HostProvider hp = new StaticHostProvider(new ArrayList<>());}
333c10dae61e4f2dc8b5fe486997aa6749ec41de922e39c18606ff63ea8d0d0b
testInvalidHostAddresses
public void testInvalidHostAddresses()
{        final List<InetSocketAddress> invalidAddresses = new ArrayList<>();    InetSocketAddress unresolved = InetSocketAddress.createUnresolved("a", 1234);    invalidAddresses.add(unresolved);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) throws UnknownHostException {            throw new UnknownHostException();        }    };    StaticHostProvider sp = new StaticHostProvider(invalidAddresses, resolver);        InetSocketAddress n1 = sp.next(0);    assertTrue("Provider should return unresolved address is host is unresolvable", n1.isUnresolved());    assertSame("Provider should return original address is host is unresolvable", unresolved, n1);}
ba0766b6dc7aece9e196679db3bff11da208cbb672fb59e42898a9cabbad1904
getAllByName
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    throw new UnknownHostException();}
cdaaaf3758b9b34361b5fdc555f370a27bb5c4586751f824c6aa41dd008d3528
testTwoConsequitiveCallsToNextReturnDifferentElement
public void testTwoConsequitiveCallsToNextReturnDifferentElement()
{    HostProvider hostProvider = getHostProvider((byte) 2);    assertNotSame(hostProvider.next(0), hostProvider.next(0));}
aaa45200daa3edf76598f79492ee67516d39bce09bdd0c2630470cd8474d6c19
testOnConnectDoesNotReset
public void testOnConnectDoesNotReset()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    hostProvider.onConnected();    InetSocketAddress second = hostProvider.next(0);    assertNotSame(first, second);}
fad3d8abe02b7e202af103a394116e41739117e206651e707c2c9955b0016098
testUpdateClientMigrateOrNot
public void testUpdateClientMigrateOrNot() throws UnknownHostException
{        HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = getServerAddresses((byte) 3);    InetSocketAddress myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 3 }), 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();        disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();                newList = getServerAddresses((byte) 2);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();            disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();        newList = new ArrayList<InetSocketAddress>(3);    for (byte i = 4; i > 1; i--) {                newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();                        HostProvider[] hostProviderArray = new HostProvider[numClients];    newList = getServerAddresses((byte) 10);    int numDisconnects = 0;    for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            numDisconnects++;        }    }    hostProvider.onConnected();        assertTrue(numDisconnects < upperboundCPS(numClients, 10));}
4cd62875b13dde5bd3ba31a7cf400dca28c2f854d5082eeb10cbaa2e2fa242dd
testUpdateMigrationGoesRound
public void testUpdateMigrationGoesRound() throws UnknownHostException
{    HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 2; i--) {                        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> oldStaying = new ArrayList<InetSocketAddress>(2);    for (byte i = 4; i > 2; i--) {                oldStaying.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> newComing = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 4; i--) {                newComing.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }                    boolean disconnectRequired = hostProvider.updateServerList(newList, new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235));    assertTrue(disconnectRequired);                ArrayList<InetSocketAddress> seen = new ArrayList<InetSocketAddress>();    for (int i = 0; i < newComing.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(newComing.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }        seen.clear();    for (int i = 0; i < oldStaying.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(oldStaying.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }            InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    for (int i = 0; i < newList.size() - 1; i++) {        hostProvider.next(0);    }    assertEquals(first, hostProvider.next(0));    hostProvider.onConnected();}
b7ad8801cc9cc0c0838bb60bb77de1d43fbd9c5997f899a2586fe44c7ccd43a5
testUpdateLoadBalancing
public void testUpdateLoadBalancing() throws UnknownHostException
{        boolean disconnectRequired;    HostProvider[] hostProviderArray = new HostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));                numClientsPerHost[i] = 0;    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 6);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 6; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 6));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 6));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[6] == 0);    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);            newList = new ArrayList<InetSocketAddress>(8);    for (byte i = 9; i > 1; i--) {        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    assertTrue(numClientsPerHost[0] == 0);    for (int i = 1; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }        newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
906a94b77b447a4efdfd85fe122049c254626375e8eaa847b3746fbafaaa4f58
testNoCurrentHostDuringNormalMode
public void testNoCurrentHostDuringNormalMode() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        if (i >= (numClients / 2)) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = null;        }    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else if (curHostForEachClient[i] == null) {                        curHostForEachClient[i] = hostProviderArray[i].getServerAtIndex(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;                hostProviderArray[i].onConnected();    }    for (int i = 0; i < 7; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 7));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 7));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));    }}
4bfd6d38b2f41a43f99f2107a01ba40734a104205e216fc1748440a6b346f3f1
testReconfigDuringReconfigMode
public void testReconfigDuringReconfigMode() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);    }            newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                                        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = hostProviderArray[i].getServerAtCurrentIndex();        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
bb7a53209a106b1a2c395fed1340455985f7c0c735ed87cb9f3c4df1205ff8b8
getHostProvider
private StaticHostProvider getHostProvider(byte size)
{    return new StaticHostProvider(getServerAddresses(size), r.nextLong());}
9204139c085b90d38e3b928e0f086856b956f97fc1e99d5eb8ed14c15939b68b
getServerAddresses
private Collection<InetSocketAddress> getServerAddresses(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        try {            list.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, size }), 1234 + size));        } catch (UnknownHostException e) {                        e.printStackTrace();        }        --size;    }    return list;}
07d8a8f71b989195ec0890453e95429bf0856f7ab496fc75f929bdb73651c03d
testUpdateServerList_UnresolvedHostnames_NoDisconnection1
public void testUpdateServerList_UnresolvedHostnames_NoDisconnection1()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(4);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
f8fff2322ada4fe94faf315532313db21c0d454c5ae2fe5e494b2151450e1949
testUpdateServerList_UnresolvedHostnames_NoDisconnection2
public void testUpdateServerList_UnresolvedHostnames_NoDisconnection2()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
9305ae14c3fb44cb4c073403cd82d75dc370daff6f121d011f6f29e7e5c2b7ba
testUpdateServerList_UnresolvedHostnames_Disconnection1
public void testUpdateServerList_UnresolvedHostnames_Disconnection1()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(2);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
51c922e5df488a481a124058622a3b90a9848e773fe77d49cfd786b9c130c825
testUpdateServerList_UnresolvedHostnames_Disconnection2
public void testUpdateServerList_UnresolvedHostnames_Disconnection2()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-4.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
2eb68725d22065afd8f235df733bcfb8bb31feeccab54050fc25964b62bbac0b
testUpdateServerList_ResolvedWithUnResolvedAddress_ForceDisconnect
public void testUpdateServerList_ResolvedWithUnResolvedAddress_ForceDisconnect()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(false));}
06e29abbaa2b5e21040115dad204c1ca877dd61f571b3c55f1d8c7c6a2d6ffee
testUpdateServerList_ResolvedWithResolvedAddress_NoDisconnect
public void testUpdateServerList_ResolvedWithResolvedAddress_NoDisconnect() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), currentHost.getAddress().getAddress()), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
07ef0ec0ab8f4675d5db268bffb155cf806d7782ee076723b9dafdd5d2b8d797
testUpdateServerList_UnResolvedWithUnResolvedAddress_ForceDisconnect
public void testUpdateServerList_UnResolvedWithUnResolvedAddress_ForceDisconnect()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is not resolvable in this test case", currentHost.isUnresolved(), is(true));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(true));}
c34d5fdb78bc15a005e881fe37c80dc264b7104e9188bcb7b17122cc34961948
testUpdateServerList_UnResolvedWithResolvedAddress_ForceDisconnect
public void testUpdateServerList_UnResolvedWithResolvedAddress_ForceDisconnect() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost not resolvable in this test case", currentHost.isUnresolved(), is(true));        byte[] addr = new byte[] { 10, 0, 0, 1 };    InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), addr), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
ba0766b6dc7aece9e196679db3bff11da208cbb672fb59e42898a9cabbad1904
getAllByName
public InetAddress[] getAllByName(String name) throws UnknownHostException
{    if (name.contains("resolvable")) {        byte[] addr = new byte[] { 10, 0, 0, (byte) (counter++ % 10) };        return new InetAddress[] { InetAddress.getByAddress(name, addr) };    }    throw new UnknownHostException();}
39168eaa02d50e707a283945a9d9afe7268e897aeee7e47d7d61f703b3129a96
lowerboundCPS
private double lowerboundCPS(int numClients, int numServers)
{    return (1 - slackPercent / 100.0) * numClients / numServers;}
4d2803ae2b88e76f09fdf4d1e1639721c2b4c7dca96d916f097a0a3bc624b208
upperboundCPS
private double upperboundCPS(int numClients, int numServers)
{    return (1 + slackPercent / 100.0) * numClients / numServers;}
4bec84d827f7854dde73374e5ee2c9401534d9758e113e84e8cc0974655442ec
testLiteralIPNoReverseNS
public void testLiteralIPNoReverseNS()
{    byte size = 30;    HostProvider hostProvider = getHostProviderUnresolved(size);    for (int i = 0; i < size; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat(next, instanceOf(InetSocketAddress.class));        assertFalse(next.isUnresolved());        assertTrue(next.toString().startsWith("/"));                String hostname = next.getHostString();                assertEquals(next.getAddress().getHostAddress(), hostname);    }}
4c6b578d4a22391676a45ae0ad6d790c5b34cb0ecf313ff37d5bd3baff988f7d
testReResolvingSingle
public void testReResolvingSingle() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("issues.apache.org", 1234));    final InetAddress issuesApacheOrg = mock(InetAddress.class);    when(issuesApacheOrg.getHostAddress()).thenReturn("192.168.1.1");    when(issuesApacheOrg.toString()).thenReturn("issues.apache.org");    when(issuesApacheOrg.getHostName()).thenReturn("issues.apache.org");    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return new InetAddress[] { issuesApacheOrg };        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertEquals(issuesApacheOrg, next.getAddress());    }                verify(spyResolver, times(10)).getAllByName("issues.apache.org");}
3b0d84ec257d333b0120de2791b7598f50497a4b4b4f716221b7bf6fe2213544
getAllByName
public InetAddress[] getAllByName(String name)
{    return new InetAddress[] { issuesApacheOrg };}
7f8b5ec122b48551e9079ffb96d8a0c69d5dc025625f826b742491c0361a6960
testReResolvingMultiple
public void testReResolvingMultiple() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    final InetAddress apacheOrg2 = mock(InetAddress.class);    when(apacheOrg2.getHostAddress()).thenReturn("192.168.1.2");    when(apacheOrg2.toString()).thenReturn("www.apache.org");    when(apacheOrg2.getHostName()).thenReturn("www.apache.org");    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    resolvedAddresses.add(apacheOrg1);    resolvedAddresses.add(apacheOrg2);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        assertEquals(1, hostProvider.size());    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat("Bad IP address returned", next.getAddress().getHostAddress(), anyOf(equalTo(apacheOrg1.getHostAddress()), equalTo(apacheOrg2.getHostAddress())));                assertEquals(1, hostProvider.size());    }            verify(spyResolver, times(10)).getAllByName("www.apache.org");}
3b0d84ec257d333b0120de2791b7598f50497a4b4b4f716221b7bf6fe2213544
getAllByName
public InetAddress[] getAllByName(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
9a3df934dac22c0b755b0a41b2ab0f4bd708e212d0edab0bf60658c7fd219b51
testReResolveMultipleOneFailing
public void testReResolveMultipleOneFailing() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final List<String> ipList = new ArrayList<String>();    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    for (int i = 0; i < 3; i++) {        ipList.add(String.format("192.168.1.%d", i + 1));        final InetAddress apacheOrg = mock(InetAddress.class);        when(apacheOrg.getHostAddress()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.toString()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.getHostName()).thenReturn("www.apache.org");        resolvedAddresses.add(apacheOrg);    }    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        InetSocketAddress resolvedFirst = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedFirst.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedFirst.getAddress().getHostAddress()));        hostProvider.onConnected();    InetSocketAddress resolvedSecond = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedSecond.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedSecond.getAddress().getHostAddress()));            InetSocketAddress resolvedThird = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedThird.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedThird.getAddress().getHostAddress()));        verify(spyResolver, times(3)).getAllByName("www.apache.org");}
3b0d84ec257d333b0120de2791b7598f50497a4b4b4f716221b7bf6fe2213544
getAllByName
public InetAddress[] getAllByName(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
a5a5dea0c73243691838dde53d35952b4f56df45b3ea7c805728b20430b9a569
testEmptyResolution
public void testEmptyResolution() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    list.add(InetSocketAddress.createUnresolved("www.google.com", 1234));    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    resolvedAddresses.add(apacheOrg1);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            if ("www.apache.org".equalsIgnoreCase(name)) {                return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);            } else {                return new InetAddress[0];            }        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        for (int i = 0; i < 10; i++) {        InetSocketAddress resolved = hostProvider.next(0);        hostProvider.onConnected();        if (resolved.getHostName().equals("www.google.com")) {            assertTrue("HostProvider should return unresolved address if host is unresolvable", resolved.isUnresolved());        } else {            assertFalse("HostProvider should return resolved addresses", resolved.isUnresolved());            assertEquals("192.168.1.1", resolved.getAddress().getHostAddress());        }    }    verify(spyResolver, times(5)).getAllByName("www.apache.org");    verify(spyResolver, times(5)).getAllByName("www.google.com");}
3b0d84ec257d333b0120de2791b7598f50497a4b4b4f716221b7bf6fe2213544
getAllByName
public InetAddress[] getAllByName(String name)
{    if ("www.apache.org".equalsIgnoreCase(name)) {        return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);    } else {        return new InetAddress[0];    }}
c0ace9823464174ace3873266ff74e0e06cdb6c0972feaf19bf9fdb3e51316ad
testReResolvingLocalhost
public void testReResolvingLocalhost()
{    byte size = 2;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("localhost", 1234));    list.add(InetSocketAddress.createUnresolved("localhost", 1235));    StaticHostProvider hostProvider = new StaticHostProvider(list);    int sizeBefore = hostProvider.size();    InetSocketAddress next = hostProvider.next(0);    next = hostProvider.next(0);    assertTrue("Different number of addresses in the list: " + hostProvider.size() + " (after), " + sizeBefore + " (before)", hostProvider.size() == sizeBefore);}
1614f6f937b27732dd1075d39db1e04350b934b99c971e13c0e317b1f9672cdb
getHostProviderUnresolved
private StaticHostProvider getHostProviderUnresolved(byte size)
{    return new StaticHostProvider(getUnresolvedServerAddresses(size), r.nextLong());}
032b270253bf3532352bbc13b0821cd7b4b2aac6c92c79b6fd6edb8117a5ad91
getUnresolvedServerAddresses
private Collection<InetSocketAddress> getUnresolvedServerAddresses(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved("10.10.10." + size, 1234 + size));        --size;    }    return list;}
3ea6d7ab5819e37e5f388113c46c9cf3513b865ec132a644b1e4594f09f005b5
getHostProviderWithUnresolvedHostnames
private StaticHostProvider getHostProviderWithUnresolvedHostnames(int size)
{    return new StaticHostProvider(getUnresolvedHostnames(size), r.nextLong());}
d5a4492f1c3deeaae30e395b1b38efa88fe0109237879b7533518b241ff4c550
getUnresolvedHostnames
private Collection<InetSocketAddress> getUnresolvedHostnames(int size)
{    ArrayList<InetSocketAddress> list = new ArrayList<>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved(String.format("testhost-%d.testdomain.com", size), 1234 + size));        --size;    }    System.out.println(Arrays.toString(list.toArray()));    return list;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    zk = createClient();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    super.tearDown();    zk.close();}
a993cb48260825ded2036f09cacc202c00816ca496b35697bc8cdddcacf096f2
newStat
private Stat newStat()
{    Stat stat = new Stat();    stat.setAversion(100);    stat.setCtime(100);    stat.setCversion(100);    stat.setCzxid(100);    stat.setDataLength(100);    stat.setEphemeralOwner(100);    stat.setMtime(100);    stat.setMzxid(100);    stat.setNumChildren(100);    stat.setPzxid(100);    stat.setVersion(100);    return stat;}
2585bf2127eef23ad0a8835f64c3546501a5341e2ecfbe10c409035642761304
testBasic
public void testBasic() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
916e69309f1b9a89ed6588b3f9b82970aaf618696f6e2ceec53302471c9f15a5
testChild
public void testChild() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    stat = newStat();    zk.getData(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
382fa1f163b595ec4bde60dd82e880921f10473861e4b08f82023e630699094a
testChildren
public void testChildren() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat;        stat = newStat();        zk.getData(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());    }}
b5fc9f3d6f255d700005c32cd2df2305574f87f5aa88115c893b2096f3a30458
testDataSizeChange
public void testDataSizeChange() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    zk.setData(name, (name + name).getBytes(), -1);    stat = newStat();    zk.getData(name, false, stat);    assertNotSame(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertNotSame(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(1, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length() * 2, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
9cc8285a6f44cf1c1f5f712f4516ddb8796ddb4821a625101321450a65c7dcda
testStrings
public void testStrings()
{    String s1 = "   a  ,   b  , ";    assertEquals("[a, b]", StringUtils.split(s1, ",").toString());    String s2 = "";    assertEquals(0, StringUtils.split(s2, ",").size());    String s3 = "1, , 2";    assertEquals("[1, 2]", StringUtils.split(s3, ",").toString());}
5662ea62c800aca7fb2a0e9f97d55ff62980971a589d1449838c92ba5eae18c8
testSync
public void testSync() throws Exception
{    try {        LOG.info("Starting ZK:" + (new Date()).toString());        opsCount = new CountDownLatch(limit);        ZooKeeper zk = createClient();        LOG.info("Beginning test:" + (new Date()).toString());        for (int i = 0; i < 50; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);        }        for (int i = 50; i < 100; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);        }        zk.sync("/test", this, results);        for (int i = 0; i < 100; i++) {            zk.delete("/test" + i, 0, this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (Children2Callback) this, results);        }        LOG.info("Submitted all operations:" + (new Date()).toString());        if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {            fail("Haven't received all confirmations" + opsCount.getCount());        }        for (int i = 0; i < limit; i++) {            assertEquals(0, (int) results.get(i));        }    } catch (IOException e) {        System.out.println(e.toString());    }}
cac92b0fb5d66d21de711286665096128f53536b61b7812df3b744288e72f8f6
processResult
public void processResult(int rc, String path, Object ctx, List<String> children)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
26a1e47e79f0560cc9d3e572e4a3a7d137ac4dd55fe236182253f5aa5bd7b897
processResult
public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
89f7e9115f244baa96b622281f33653f500ea87b307b7bf40f7c9e69ab715153
getInstance
public static TestByteBufAllocator getInstance()
{    TestByteBufAllocator result = INSTANCE.get();    if (result == null) {        ResourceLeakDetector.Level oldLevel = ResourceLeakDetector.getLevel();        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);        INSTANCE.compareAndSet(null, new TestByteBufAllocator(oldLevel));        result = INSTANCE.get();    }    return result;}
35df44da2da1e872eac16e64fe959529021e415b06a600139674710fb6e68a84
checkForLeaks
public static void checkForLeaks()
{    TestByteBufAllocator result = INSTANCE.getAndSet(null);    if (result != null) {        result.checkInstanceForLeaks();    }}
a96a3763fe7d3240de018ae6ebec01650fadee6fbc12c416192479d1f048e045
newHeapBuffer
protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity)
{    return track(super.newHeapBuffer(initialCapacity, maxCapacity));}
191c7af41bf57591cb7659e05f48018f127f71b2d4bfcbadb6c41b27381f92fd
newDirectBuffer
protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity)
{    return track(super.newDirectBuffer(initialCapacity, maxCapacity));}
e76b900a7e75f5130308ea2d52572dc353f0e0cf1eac8e9bf99e7aa223ad9c10
compositeHeapBuffer
public CompositeByteBuf compositeHeapBuffer(int maxNumComponents)
{    return track(super.compositeHeapBuffer(maxNumComponents));}
bde67cc4fc9cf0d626e706c9b6b6a13e77043aea2c4dafa0354f57412d4622ea
compositeDirectBuffer
public CompositeByteBuf compositeDirectBuffer(int maxNumComponents)
{    return track(super.compositeDirectBuffer(maxNumComponents));}
2c730fa589e868c7808fc3c06899c16d2ffcbf2dfb65fd0457c31ab7292e6cb2
track
private synchronized CompositeByteBuf track(CompositeByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
976d6bcb98fb3ec26d27435ef28487381b3dfb5c9430e1a5a618b746268e578d
track
private synchronized ByteBuf track(ByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
98a3a9dc589312ce091c2765272597b6880df91675dea84bca2c878f72132031
checkInstanceForLeaks
private void checkInstanceForLeaks()
{    try {        long referencedBuffersCount = 0;        synchronized (this) {            referencedBuffersCount = trackedBuffers.stream().filter(byteBuf -> byteBuf.refCnt() > 0).count();                        trackedBuffers.clear();        }                if (referencedBuffersCount > 0) {                                                System.gc();            throw new AssertionError("Found a netty ByteBuf leak!");        }    } finally {        ResourceLeakDetector.setLevel(oldLevel);    }}
f247aaa7b0a87c4dd79a66c68176e18e402cac55d4b2b385cecad1c5207a6099
setTestAllocator
public static void setTestAllocator(ByteBufAllocator allocator) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m1.setAccessible(true);    m1.invoke(null, allocator);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m2.setAccessible(true);    m2.invoke(null, allocator);}
eed1c2b1eea9b558e835bdc8bb13a480f2025796534830e8ad10484c86b3ce28
clearTestAllocator
public static void clearTestAllocator() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("clearTestAllocator");    m1.setAccessible(true);    m1.invoke(null);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("clearTestAllocator");    m2.setAccessible(true);    m2.invoke(null);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    long startTime = Time.currentElapsedTime();    ZooKeeper zk = null;    try {        zk = ClientBase.createZKClient(args[0], 10000);    } catch (Exception e1) {        e1.printStackTrace();        throw new RuntimeException(e1);    }    for (int i = 0; i < REPS; i++) {        try {            String name = zk.create("/testFile-", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);            zk.delete(name, -1, new TestHammer(), null);        } catch (Exception e) {            i--;            e.printStackTrace();        }    }    System.out.println("creates/sec=" + (REPS * 1000 / (Time.currentElapsedTime() - startTime)));}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{}
3e93e6dec2eb407fe98a16426085f1aa323e6783f7a963bcf1a006401fa9714f
deleteFileRecursively
public static boolean deleteFileRecursively(File file, final boolean failOnError)
{    if (file != null) {        if (file.isDirectory()) {            File[] files = file.listFiles();            int size = files.length;            for (int i = 0; i < size; i++) {                File f = files[i];                boolean deleted = deleteFileRecursively(files[i], failOnError);                if (!deleted && failOnError) {                    fail("file '" + f.getAbsolutePath() + "' deletion failed");                }            }        }        return file.delete();    }    return true;}
fd2964d8ab55001959b87cc9118ba029b1eed9713738101db560570ccea80661
deleteFileRecursively
public static boolean deleteFileRecursively(File file)
{    return deleteFileRecursively(file, false);}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    dataDir1 = ClientBase.createTmpDir();    dataDir2 = ClientBase.createTmpDir();    dataDir3 = ClientBase.createTmpDir();}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    ClientBase.recursiveDelete(dataDir1);    ClientBase.recursiveDelete(dataDir2);    ClientBase.recursiveDelete(dataDir3);}
9efdc1821a7ba98ac187cf5e5c225476f63124bacaf04479032d39273077c5dc
testTruncationStreamReset
public void testTruncationStreamReset() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);            snaplog.save(zkdb.getDataTree(), zkdb.getSessionWithTimeOuts(), false);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.truncateLog(1);    append(zkdb, 200);    zkdb.close();            FileTxnLog txnlog = new FileTxnLog(new File(tmpdir, "version-2"));    TxnIterator iter = txnlog.read(1);    TxnHeader hdr = iter.getHeader();    Record txn = iter.getTxn();    assertEquals(1, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.next();    hdr = iter.getHeader();    txn = iter.getTxn();    assertEquals(200, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.close();    ClientBase.recursiveDelete(tmpdir);}
d4b549d811cd5dc0f7b1e7283d80cb55f7213d65038e2acc40560026dad1a8ae
testTruncationNullLog
public void testTruncationNullLog() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.close();    File[] logs = snaplog.getDataDir().listFiles();    for (int i = 0; i < logs.length; i++) {        LOG.debug("Deleting: {}", logs[i].getName());        assertTrue("Failed to delete log file: " + logs[i].getName(), logs[i].delete());    }    try {        zkdb.truncateLog(1);        assertTrue("Should not get here", false);    } catch (IOException e) {        assertTrue("Should have received an IOException", true);    } catch (NullPointerException npe) {        fail("This should not throw NPE!");    }    ClientBase.recursiveDelete(tmpdir);}
b641803c964eb18d693da56ab175dbb89a49238f9a2abc723c64078c03a3fedd
append
private void append(ZKDatabase zkdb, int i) throws IOException
{    TxnHeader hdr = new TxnHeader(1, 1, i, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo" + i, new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    zkdb.append(req);    zkdb.commit();}
916c45f6ee39c9e1c211ac40dd3a75390abaf7f14de7622f4efd389c25f4ff1d
testTruncate
public void testTruncate() throws Exception
{        String hostPort = "127.0.0.1:" + PortAssignment.unique();    int maxCnxns = 100;    ServerCnxnFactory factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ClientBase.shutdownServerInstance(factory, hostPort);        File origfile = new File(new File(dataDir1, "version-2"), "snapshot.0");    File newfile = new File(new File(dataDir1, "version-2"), "snapshot.100000000");    origfile.renameTo(newfile);    factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ZooKeeper zk = ClientBase.createZKClient(hostPort, 15000);    for (int i = 0; i < 50; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    ZKDatabase zkDb;    {        ZooKeeperServer zs = factory.getZooKeeperServer();        zkDb = zs.getZKDatabase();    }    factory.shutdown();    try {        zkDb.close();    } catch (IOException ie) {        LOG.warn("Error closing logs ", ie);    }    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    int port1 = PortAssignment.unique();    int port2 = PortAssignment.unique();    int port3 = PortAssignment.unique();        Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port3)));    QuorumPeer s2 = new QuorumPeer(peers, dataDir2, dataDir2, port2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s2.start();    QuorumPeer s3 = new QuorumPeer(peers, dataDir3, dataDir3, port3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s3.start();    zk = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    final ZooKeeper zk2 = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    zk2.getData("/9", false, new Stat());    try {        zk2.getData("/10", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    QuorumPeer s1 = new QuorumPeer(peers, dataDir1, dataDir1, port1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s1.start();    ZooKeeper zk1 = ClientBase.createZKClient("127.0.0.1:" + port1, 15000);    zk1.getData("/9", false, new Stat());    try {                                                        zk1.getData("/12", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    zk1.close();    QuorumBase.shutdown(s1);    QuorumBase.shutdown(s2);    QuorumBase.shutdown(s3);}
f49894878f1196f3a283f1be6c1e8b365d778ea23bbad2b39b9a5b2696aaf82b
testCreatingWatchedEvent
public void testCreatingWatchedEvent()
{            EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            we = new WatchedEvent(et, ks, "blah");            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
0460c21ef0a2f259a11a9fdc15ccb952ce89eed3a838e8bcff270fa93ff4f84e
testCreatingWatchedEventFromWrapper
public void testCreatingWatchedEventFromWrapper()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    WatcherEvent wep;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            wep = new WatcherEvent(et.getIntValue(), ks.getIntValue(), "blah");            we = new WatchedEvent(wep);            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
2b75b390336d71463b7641fed5b171b1cc9b01dd5701dd727cfe033593098fda
testCreatingWatchedEventFromInvalidWrapper
public void testCreatingWatchedEventFromInvalidWrapper()
{    try {        WatcherEvent wep = new WatcherEvent(-2342, -252352, "foo");        new WatchedEvent(wep);        fail("Was able to create WatchedEvent from bad wrapper");    } catch (RuntimeException re) {        }}
b430c85531bb529a332f96d852fbb33af70e4b04abb98fd5db3cc9a098b326da
testConvertingToEventWrapper
public void testConvertingToEventWrapper()
{    WatchedEvent we = new WatchedEvent(EventType.NodeCreated, KeeperState.Expired, "blah");    WatcherEvent wew = we.getWrapper();    assertEquals(EventType.NodeCreated.getIntValue(), wew.getType());    assertEquals(KeeperState.Expired.getIntValue(), wew.getState());    assertEquals("blah", wew.getPath());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        if (latch != null) {            latch.countDown();        }    }    if (event.getType() == EventType.None) {        return;    }    try {        events.put(event);    } catch (InterruptedException e) {        assertTrue("interruption unexpected", false);    }}
7220eee75d73aceef4a465402594fb10a8ed2833d0996ce488a23481c19a1f45
verify
public void verify(List<EventType> expected) throws InterruptedException
{    WatchedEvent event;    int count = 0;    while (count < expected.size() && (event = events.poll(30, TimeUnit.SECONDS)) != null) {        assertEquals(expected.get(count), event.getType());        count++;    }    assertEquals(expected.size(), count);    events.clear();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    client_latch = new CountDownLatch(1);    client_dwatch = new SimpleWatcher(client_latch);    client = createClient(client_dwatch, client_latch);    lsnr_latch = new CountDownLatch(1);    lsnr_dwatch = new SimpleWatcher(lsnr_latch);    lsnr = createClient(lsnr_dwatch, lsnr_latch);    expected = new ArrayList<EventType>();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    client.close();    lsnr.close();    super.tearDown();}
552ecad0cb37373b3b4e7220284d4697f39b89100d1b28e61b29050a8853f003
createClient
protected ZooKeeper createClient(Watcher watcher, CountDownLatch latch) throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
c50ec2b980ac84e4d64fba09700b39a9ed2fd9fc281a691c97cfd194e2126f21
verify
private void verify() throws InterruptedException
{    lsnr_dwatch.verify(expected);    expected.clear();}
51de026dcac5b3667c91744242a283b26fe5ca62a9b935ca563515cfb4f5b605
testExistsSync
public void testExistsSync() throws IOException, InterruptedException, KeeperException
{    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo/bar", true));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    try {        assertNull(lsnr.exists("/car", true));        client.setData("/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/car", e.getPath());    }    try {        assertNull(lsnr.exists("/foo/car", true));        client.setData("/foo/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/car", e.getPath());    }    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
6a50d74843490bbba81eeb134671b053256444a4951ffc91720f1401d96a7d98
testGetDataSync
public void testGetDataSync() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getData("/foo", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
f1705c1c13c8d9a68c29cdf4b986bdcfc16a7d36b9875a0914e92ef5d2ccb328
testGetChildrenSync
public void testGetChildrenSync() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.delete("/foo/bar", -1);        expected.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
5122f819781ed74aa53bb6905b803ff084f53ef1e4001e92b96fd6ff2b93e18a
testExistsSyncWObj
public void testExistsSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo", w1));    assertNull(lsnr.exists("/foo/bar", w2));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w4));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e2.add(EventType.NodeCreated);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();        assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);        lsnr_dwatch.verify(new ArrayList<EventType>());    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
8a65ce053b25ede5b2af1d14bf1b31be2186414c51b7672dcc1b551d8ee320af
testGetDataSyncWObj
public void testGetDataSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getData("/foo", w1, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", w2, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
725fceaaa9491c1fc940e2d91a8ef9b341b1caa42d925e4867d8b84efb139e34
testGetChildrenSyncWObj
public void testGetChildrenSyncWObj() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.delete("/foo/bar", -1);        e2.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    ((int[]) ctx)[0]++;    this.rc = rc;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        timeOfLastWatcherInvocation = System.currentTimeMillis();        try {            events.put(event);        } catch (InterruptedException e) {            LOG.warn("ignoring interrupt during event.put");        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();            System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "false");}
8f4d754438eb476ccc5f97bc67f8958ea050c7d87db17e27ffd363c6b2c5d1a7
testWatcherCorrectness
public void testWatcherCorrectness() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };        VoidCallback vcb = new VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                        }        };        String[] names = new String[10];        for (int i = 0; i < names.length; i++) {            String name = zk.create("/tc-", "initialvalue".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            names[i] = name;            Stat stat = new Stat();            zk.getData(name, watcher, stat);            zk.setData(name, "new".getBytes(), stat.getVersion(), scb, null);            stat = zk.exists(name, watcher);            zk.delete(name, stat.getVersion(), vcb, null);        }        for (int i = 0; i < names.length; i++) {            String name = names[i];            WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDataChanged, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDeleted, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());        }    } finally {        if (zk != null) {            zk.close();        }    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{}
9c97e95e9bd8365c6f8a5af43db09cce7011122ba1548bb902d85595c9119e22
testWatcherDisconnectOnClose
public void testWatcherDisconnectOnClose() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        final BlockingQueue<WatchedEvent> queue = new LinkedBlockingQueue<>();        MyWatcher connWatcher = new MyWatcher();        Watcher watcher = event -> {            try {                queue.put(event);            } catch (InterruptedException e) {                        }        };        zk = createClient(connWatcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };                zk.exists("/missing", watcher, scb, null);                zk.close();        WatchedEvent event = queue.poll(10, TimeUnit.SECONDS);        assertNotNull("No watch event was received after closing the Zookeeper client. A 'Closed' event should have occurred", event);        assertEquals("Closed events are not generated by the server, and so should have a type of 'None'", Event.EventType.None, event.getType());        assertEquals("A 'Closed' event was expected as the Zookeeper client was closed without altering the node it was watching", Event.KeeperState.Closed, event.getState());    } finally {        if (zk != null) {            zk.close();        }    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{}
0b7143fcd5786ec9174e30c992acff8bd6ebf6a108a75c7d3ade8a4401806d94
testWatcherCount
public void testWatcherCount() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = null, zk2 = null;    try {        MyWatcher w1 = new MyWatcher();        zk1 = createClient(w1, hostPort);        MyWatcher w2 = new MyWatcher();        zk2 = createClient(w2, hostPort);        Stat stat = new Stat();        zk1.create("/watch-count-test", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.create("/watch-count-test-2", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.getData("/watch-count-test", w1, stat);        zk1.getData("/watch-count-test-2", w1, stat);        zk2.getData("/watch-count-test", w2, stat);        assertEquals(serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().getWatchCount(), 3);    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
004f8949d2cc5972628bfa1d6d42cb51cc1616d61618bb013c3fd88e6c94d388
testWatchAutoResetWithPending
public void testWatchAutoResetWithPending() throws Exception
{    MyWatcher[] watches = new MyWatcher[COUNT];    MyStatCallback[] cbs = new MyStatCallback[COUNT];    MyWatcher watcher = new MyWatcher();    int[] count = new int[1];    TestableZooKeeper zk = createClient(watcher, hostPort, 6000);    ZooKeeper zk2 = createClient(watcher, hostPort, 5000);    zk2.create("/test", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    for (int i = 0; i < COUNT / 2; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    zk.exists("/test", false);    assertTrue("Failed to pause the connection!", zk.pauseCnxn(3000));    zk2.close();    stopServer();    watches[0].waitForDisconnected(60000);    for (int i = COUNT / 2; i < COUNT; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    startServer();    watches[COUNT / 2 - 1].waitForConnected(60000);    assertEquals(null, zk.exists("/test", false));    waitForAllWatchers();    for (int i = 0; i < COUNT / 2; i++) {        assertEquals("For " + i, 1, watches[i].events.size());    }    for (int i = COUNT / 2; i < COUNT; i++) {        if (cbs[i].rc == 0) {            assertEquals("For " + i, 1, watches[i].events.size());        } else {            assertEquals("For " + i, 0, watches[i].events.size());        }    }    assertEquals(COUNT, count[0]);    zk.close();}
5d82a01162fc0891915416bc48c74bd81771f8ff53ba5c75f2f917801511b9e1
waitForAllWatchers
private void waitForAllWatchers() throws Exception
{    timeOfLastWatcherInvocation = System.currentTimeMillis();    while (System.currentTimeMillis() - timeOfLastWatcherInvocation < 1000) {        Thread.sleep(1000);    }}
982bc870d756367cd694fcf25875dbeb8f017ee84cb32d7b344ed696d3bcb033
testWatcherAutoResetWithGlobal
public void testWatcherAutoResetWithGlobal() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, watcher);    zk.close();}
365fb71aa2827443739005e706aeaf1ad53b4febb9e0d9943ae7dc4c9bc57be7
testWatcherAutoResetWithLocal
public void testWatcherAutoResetWithLocal() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, new MyWatcher());    zk.close();}
3f933ecb203b115626e7a3e8f942a9f9210401e9b342fe858cb2aeb50aae159a
testWatcherAutoResetDisabledWithGlobal
public void testWatcherAutoResetDisabledWithGlobal() throws Exception
{    /**     * When ZooKeeper is created this property will get used.     */    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithGlobal();}
7ec8abce805fc5527c15d712573520f38e35367b8725daa4cc5c5cf75f32a9ba
testWatcherAutoResetDisabledWithLocal
public void testWatcherAutoResetDisabledWithLocal() throws Exception
{    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithLocal();}
bffea585c8c6a01aaa8e36ce6ec81a60240ec03068913f38b9d32074ec3f146e
testWatcherAutoReset
private void testWatcherAutoReset(ZooKeeper zk, MyWatcher globalWatcher, MyWatcher localWatcher) throws Exception
{    boolean isGlobal = (localWatcher == globalWatcher);        zk.create("/watchtest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/watchtest/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(3000);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(3000);    boolean disableAutoWatchReset = zk.getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    assertTrue(localWatcher.events.isEmpty());    zk.setData("/watchtest/child", new byte[1], -1);    zk.create("/watchtest/child2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e;    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(e.getPath(), EventType.NodeDataChanged, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);                        assertEquals(EventType.NodeCreated, e.getType());        assertEquals("/watchtest/child2", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeChildrenChanged, e.getType());        assertEquals("/watchtest", e.getPath());    } else {            }        assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    try {        try {            localWatcher.waitForDisconnected(500);            if (!isGlobal && !disableAutoWatchReset) {                fail("Got an event when I shouldn't have");            }        } catch (TimeoutException toe) {            if (disableAutoWatchReset) {                fail("Didn't get an event when I should have");            }                }    } catch (Exception e1) {        LOG.error("bad", e1);        throw new RuntimeException(e1);    }    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }            zk.delete("/watchtest/child2", -1);    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeDeleted, e.getType());    assertEquals("/watchtest/child2", e.getPath());    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/watchtest", e.getPath());    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    zk.delete("/watchtest/child", -1);    zk.delete("/watchtest", -1);    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeDeleted, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }        Thread.sleep(1000);    assertTrue(localWatcher.events.isEmpty());}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    super.process(event);    try {        if (event.getType() != Event.EventType.None) {            dataEvents.put(event);        }    } catch (InterruptedException e) {        LOG.warn("ignoring interrupt during EventsWatcher process");    }}
bbbe053ceabcd4e895eb0b0cf6393edfa6b8a227a7d6e1fadd0843417e2d8b38
assertEvent
public void assertEvent(long timeout, EventType eventType)
{    try {        WatchedEvent event = dataEvents.poll(timeout, TimeUnit.MILLISECONDS);        assertNotNull("do not receive a " + eventType, event);        assertEquals(eventType, event.getType());    } catch (InterruptedException e) {        LOG.warn("ignoring interrupt during EventsWatcher assertEvent");    }}
2c430a094e2eb57c6fd647c316faa05b1c86bd72fe16c051b29dd6261306a1a8
createClient
private ZooKeeper createClient(QuorumUtil qu, int id, EventsWatcher watcher) throws IOException
{    String hostPort = "127.0.0.1:" + qu.getPeer(id).clientPort;    ZooKeeper zk = new ZooKeeper(hostPort, TIMEOUT, watcher);    try {        watcher.waitForConnected(TIMEOUT);    } catch (InterruptedException e) {        } catch (TimeoutException e) {        fail("can not connect to " + hostPort);    }    return zk;}
516e802ddbda1c48e80d2de522a44e82563277a940ea20d44b08fc427abfa4a6
createClient
private ZooKeeper createClient(QuorumUtil qu, int id) throws IOException
{    return createClient(qu, id, new EventsWatcher());}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    System.setProperty("zookeeper.admin.enableServer", "false");    qu = new QuorumUtil(1);    qu.startAll();    watcher = new EventsWatcher();    zk1 = createClient(qu, 1, watcher);    zk2 = createClient(qu, 2);}
1582badfde0c1c6b53bdd59eb3936f1476a65e6279df8e633214056dc1f0b19e
tearDown
public void tearDown() throws InterruptedException
{    if (zk1 != null) {        zk1.close();        zk1 = null;    }    if (zk2 != null) {        zk2.close();        zk2 = null;    }    if (watcher != null) {        watcher = null;    }    if (qu != null) {        qu.shutdownAll();        qu = null;    }}
f85fd174b96f16437a3b52e8e1ae6251ad71a8df58d9d253a4ebb5f71426f725
testNodeDataChanged
public void testNodeDataChanged() throws Exception
{    String path = "/test-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat1 = zk1.exists(path, watcher);    qu.shutdown(1);    zk2.setData(path, new byte[2], stat1.getVersion());    qu.start(1);    watcher.waitForConnected(TIMEOUT);    watcher.assertEvent(TIMEOUT, EventType.NodeDataChanged);}
22eea6eed33521b985ffa7e3b96263ed16e03b77bf81316ea4ca33141b5bc0f4
testNodeCreated
public void testNodeCreated() throws Exception
{    String path = "/test1-created";    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeCreated);}
c104472d361bdb7cf2a50a909753c7b5517ba1ec90024a8e52e47ed05a708b57
testNodeDeleted
public void testNodeDeleted() throws Exception
{    String path = "/test-deleted";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getData(path, watcher, null);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);}
8a50c748a22315fe62b17e6603a896ff05bc811440bbedbffef9e8ce1c647144
testNodeChildrenChanged
public void testNodeChildrenChanged() throws Exception
{    String path = "/test-children-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.create(path + "/children-1", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeChildrenChanged);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    System.setProperty("zookeeper.X509AuthenticationProvider.superUser", "CN=SUPER");    System.setProperty("zookeeper.ssl.keyManager", "org.apache.zookeeper.test.X509AuthTest.TestKeyManager");    System.setProperty("zookeeper.ssl.trustManager", "org.apache.zookeeper.test.X509AuthTest.TestTrustManager");    clientCert = new TestCertificate("CLIENT");    superCert = new TestCertificate("SUPER");    unknownCert = new TestCertificate("UNKNOWN");}
7fd007b86120b2522975894dd5f46d7b1dc7969c3df2d38d799f32b2534f61f0
testTrustedAuth
public void testTrustedAuth()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { clientCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));}
beb4b7b406302e2df60064d026fc6b503480410a2620e219566d48ac6aa86f3e
testSuperAuth
public void testSuperAuth()
{    X509AuthenticationProvider provider = createProvider(superCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { superCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));    assertEquals("super", cnxn.getAuthInfo().get(0).getScheme());}
9369ec6f1dd8e7ec7f6f813901b421660940eac3e83bd8cd7d043d53bea4393a
testUntrustedAuth
public void testUntrustedAuth()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { unknownCert };    assertEquals(KeeperException.Code.AUTHFAILED, provider.handleAuthentication(cnxn, null));}
7d0d624b910c835faf2f107fd933c570dabe86c30d3d6d7f18457ccedae5a836
getAlgorithm
public String getAlgorithm()
{    return null;}
a531f284b1b6de7e814da2dabcebe62dec7e6febd622672e32a5aca72e90b97c
getFormat
public String getFormat()
{    return null;}
b1a4c1332cce419aa138a8be74b1dfe1ad160a4f7239af61d96f8a2d339d2279
getEncoded
public byte[] getEncoded()
{    return null;}
dd8f965aa85d45b9ec684ffec645d8242ca7c71458479cec4a81aaf4bf02fecf
hasUnsupportedCriticalExtension
public boolean hasUnsupportedCriticalExtension()
{    return false;}
2d884295333dd88fbe065d82fabb003d82cfc0edf2dc8cce5b60e6e836e06d32
getCriticalExtensionOIDs
public Set<String> getCriticalExtensionOIDs()
{    return null;}
3b683fd8691b0c17398a4436c66ef7162666480a9567224ef1a944c669a4961b
getNonCriticalExtensionOIDs
public Set<String> getNonCriticalExtensionOIDs()
{    return null;}
f6dbc4add2d7d858df79eaf03254b1a4ec39c875c33bb87cf6fae17fd3ce86ea
getExtensionValue
public byte[] getExtensionValue(String oid)
{    return null;}
3c454f8e66d0c0af63a53d65205f8e7362709b0f9507d74adfffd69563716a52
checkValidity
public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException
{}
8813b3df48a97f6909b3ff781e016fb696d6b0a2fa0fb0dee8737900ca87db8a
checkValidity
public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException
{}
54bc0b349a40e5994cc6b2b7c63b7bdb8eaebafd56321e290c868307cb2a4574
getVersion
public int getVersion()
{    return 0;}
ee8643593123b562d62a0d8aceeb7cec5dd6d9fb407e0d40988bcf5d9390a5bd
getSerialNumber
public BigInteger getSerialNumber()
{    return null;}
564a80c57a49a06bda29a5ededf8aad782e39bc5a445f15c11804e2f844c0e87
getIssuerDN
public Principal getIssuerDN()
{    return null;}
d7dc870d61356360028070b62c011f57877cc490ff642bb3872a8ba59a2616f4
getSubjectDN
public Principal getSubjectDN()
{    return null;}
53ec93dc3c7029f6a1c15a7866938cb056b552346ad87e77cdd062afb2bbca7e
getNotBefore
public Date getNotBefore()
{    return null;}
c5c913db1e5145fea22a3672fa3dee105b0afe7d16ff3f9af17b368f2ef8cdd7
getNotAfter
public Date getNotAfter()
{    return null;}
4dec9d57e728ed78932487a8eee1cdef56560f40e0d5a77667b342d136877542
getTBSCertificate
public byte[] getTBSCertificate() throws CertificateEncodingException
{    return null;}
b70fa8115359524fb45d83fffe77397bbb0ed5e9ab0c9f3d1c1fbaffda29e4be
getSignature
public byte[] getSignature()
{    return null;}
92a28861702be52dd3b28a9a41b5741ba8ec41303c1eee8daf0a5da542a73963
getSigAlgName
public String getSigAlgName()
{    return null;}
2887d5640199251415c7da4d0e920394c1bad91dddc6ff00c56adc29aca3c0da
getSigAlgOID
public String getSigAlgOID()
{    return null;}
c348379fe0c54883fc42d7d01509a5dc36bc6989ee8ab724b12ca486af9d5d97
getSigAlgParams
public byte[] getSigAlgParams()
{    return null;}
1191b9235d730201c89476e92f670368666d6f0cab8a3572cba27bdb6ac89da0
getIssuerUniqueID
public boolean[] getIssuerUniqueID()
{    return null;}
21945a0c7afa8cead2074fe0c239c6f1f4b82027a7dd3f0807189508a8d1afe3
getSubjectUniqueID
public boolean[] getSubjectUniqueID()
{    return null;}
ed3403873381bab0b7bdaeb9b98c621d303b1d365d3d8e696624826ba6086399
getKeyUsage
public boolean[] getKeyUsage()
{    return null;}
98cc7a455b5c6eff92cbc0ccbb103a215c7c74f46526c2f0a66fc24fce125da7
getBasicConstraints
public int getBasicConstraints()
{    return 0;}
7ea133ef45f22343498e4ddfd5e3120646822f1bf99d7a38f99c83204b560d05
getEncoded
public byte[] getEncoded() throws CertificateEncodingException
{    return encoded;}
3b317d1ded6c598e6f56f4b76fcdd3fda719d53c0a0f5f8cca7bb2501d1e59a6
verify
public void verify(PublicKey key) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
ea491968cf2e75a3c3970e962dd6f8ac98509b1a83c534652ce1967fbe6d81a3
verify
public void verify(PublicKey key, String sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return null;}
ab1b96a7bd6ea6761d9bf388fbef0ce32434969daf961dbb4b80836b7b12ea43
getPublicKey
public PublicKey getPublicKey()
{    return publicKey;}
73f403eab5c78ab351a3e66386eb03bf1d902977b544ddb9e6f4f551dfc07f6e
getSubjectX500Principal
public X500Principal getSubjectX500Principal()
{    return principal;}
ad5c36fd13283e3eab72d3bf27a630180fd2278f351cf1076fff34f790e7f2d1
chooseClientAlias
public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket)
{    return null;}
8f7264411422f620be5d7a1fa9299c3d8646f4eeff8d7044837bfeae2b8a4643
chooseServerAlias
public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket)
{    return null;}
9284e639eb73c011008708e54c3a84ad3f371cef22bcf921d901880ad3151d05
getCertificateChain
public X509Certificate[] getCertificateChain(String alias)
{    return null;}
9dfc4b784df6d501d3014e5fcae630fb1209809c4e09137947ee006c0d02e8e4
getClientAliases
public String[] getClientAliases(String keyType, Principal[] issuers)
{    return null;}
a08743a4fda461a651078c01fa18d06177b5bfbba8b53b8c1eda5e5f77bf55b3
getPrivateKey
public PrivateKey getPrivateKey(String alias)
{    return null;}
42e3509920f84b92e652b9c56702339e45329b62db1b3a05536dc26d090c9d3e
getServerAliases
public String[] getServerAliases(String keyType, Principal[] issuers)
{    return null;}
90517f191cb750994284134e55560a7721c1ce0abce635b9fa82fea40199ddfe
checkClientTrusted
public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Client cert not trusted");    }}
b4f8e51fdd88049429540611f80d79900cf027c7024dffc82a8eceb056d8fce8
checkServerTrusted
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Server cert not trusted");    }}
b516c58bc22bde695ccdef782f17985d051ddc0b89329e35483cf2a3a576c7fe
getAcceptedIssuers
public X509Certificate[] getAcceptedIssuers()
{    return null;}
722c7dc61932864385204c7b9804c1c529bf31e5d7956623a92b395116245987
createProvider
protected X509AuthenticationProvider createProvider(X509Certificate trustedCert)
{    return new X509AuthenticationProvider(new TestTrustManager(trustedCert), new TestKeyManager());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    LOG.info("STARTING quorum " + getClass().getName());    qb.setUp();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    LOG.info("STOPPING quorum " + getClass().getName());}
ef78a89dd4b6a838de741b6c689232ee38cbd2269e313dd63130af22d1a57643
corruptFile
private void corruptFile(File f) throws IOException
{    RandomAccessFile outFile = new RandomAccessFile(f, "rw");    outFile.write("fail servers".getBytes());    outFile.close();}
4a0089a58fd61ec641c93209efde34b141fc9a4202720d855c45bef7f2ffcdd7
corruptAllSnapshots
private void corruptAllSnapshots(File snapDir) throws IOException
{    File[] listFiles = snapDir.listFiles();    for (File f : listFiles) {        if (f.getName().startsWith("snapshot")) {            corruptFile(f);        }    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{}
39dcd27f4d7f9474028761bb23f869cb074ccfb03ff10a317b396e2e394b60ac
testCorruption
public void testCorruption() throws Exception
{    ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = ClientBase.createZKClient(qb.hostPort, 10000);    SyncRequestProcessor.setSnapCount(100);    for (int i = 0; i < 2000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    long leaderSid = 1;    QuorumPeer leader = null;        for (QuorumPeer quorumPeer : Arrays.asList(qb.s1, qb.s2, qb.s3, qb.s4, qb.s5)) {        if (quorumPeer.getPeerState() == ServerState.LEADING) {            leader = quorumPeer;            break;        }        ++leaderSid;    }    assertNotNull("Cannot find the leader.", leader);    leader.shutdown();        FileTxnSnapLog snapLog = leader.getTxnFactory();    File snapDir = snapLog.getSnapDir();        corruptAllSnapshots(snapDir);    qb.shutdownServers();    qb.setupServers();    if (leaderSid != 1) {        qb.s1.start();    } else {        leader = qb.s1;    }    if (leaderSid != 2) {        qb.s2.start();    } else {        leader = qb.s2;    }    if (leaderSid != 3) {        qb.s3.start();    } else {        leader = qb.s3;    }    if (leaderSid != 4) {        qb.s4.start();    } else {        leader = qb.s4;    }    if (leaderSid != 5) {        qb.s5.start();    } else {        leader = qb.s5;    }    try {        leader.start();        assertTrue(false);    } catch (RuntimeException re) {        LOG.info("Got an error: expected", re);    }        String[] list = qb.hostPort.split(",");    for (int i = 0; i < 5; i++) {        if (leaderSid != (i + 1)) {            String hp = list[i];            assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));            LOG.info("{} is accepting client connections", hp);        } else {            LOG.info("Skipping the leader");        }    }    zk = qb.createClient();    SyncRequestProcessor.setSnapCount(100);    for (int i = 2000; i < 4000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    if (leaderSid != 1) {        QuorumBase.shutdown(qb.s1);    }    if (leaderSid != 2) {        QuorumBase.shutdown(qb.s2);    }    if (leaderSid != 3) {        QuorumBase.shutdown(qb.s3);    }    if (leaderSid != 4) {        QuorumBase.shutdown(qb.s4);    }    if (leaderSid != 5) {        QuorumBase.shutdown(qb.s5);    }}
253bd91772bf7c468c0a18a436b9c2cd0ce82ab31e4525802d5d73ce98d35c09
testAbsentRecentSnapshot
public void testAbsentRecentSnapshot() throws IOException
{    ZKDatabase zkDatabase = new ZKDatabase(new FileTxnSnapLog(new File("foo"), new File("bar")) {        @Override        public File findMostRecentSnapshot() throws IOException {            return null;        }    });    assertEquals(0, zkDatabase.calculateTxnLogSizeLimit());}
1ab8986e0298ca0a88ebe3e5eba4d75d2cee3146ad2b3f9be5d01d979d9c7df4
findMostRecentSnapshot
public File findMostRecentSnapshot() throws IOException
{    return null;}
ed12dbcbd43dd875ed769c0a2f3f08472a940a3db6bcfa6d0e79aaaaee0111ef
testQuota
public void testQuota() throws Exception
{    final ZooKeeper zk = createClient();    final String path = "/a/b/v";        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/d", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    SetQuotaCommand.createQuota(zk, path, 5L, 10);        String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absolutePath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 5L);    assertTrue("num count is set", st.getCount() == 10);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    byte[] qdata = zk.getData(statPath, false, new Stat());    StatsTrack qst = new StatsTrack(new String(qdata));    assertTrue("bytes are set", qst.getBytes() == 8L);    assertTrue("count is set", qst.getCount() == 2);        stopServer();    startServer();    stopServer();    startServer();    ZooKeeperServer server = serverFactory.getZooKeeperServer();    assertNotNull("Quota is still set", server.getZKDatabase().getDataTree().getMaxPrefixWithQuota(path) != null);}
138b0da5242d4e927d3b24da47d8b1f7e70e476acba049c013f0657d9d4ca9d2
testSetQuota
public void testSetQuota() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    String path = "/c1";    String nodeData = "foo";    zk.create(path, nodeData.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int count = 10;    long bytes = 5L;    SetQuotaCommand.createQuota(zk, path, bytes, count);        String absoluteLimitPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absoluteLimitPath, false, null);    StatsTrack st = new StatsTrack(new String(data));    assertEquals(bytes, st.getBytes());    assertEquals(count, st.getCount());        String absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));    assertEquals(nodeData.length(), st.getBytes());    assertEquals(1, st.getCount());        String path2 = "/c1/c2";    String nodeData2 = "bar";    zk.create(path2, nodeData2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));        assertEquals(nodeData.length() + nodeData2.length(), st.getBytes());    assertEquals(2, st.getCount());}
048524d8479728ba2a212124698514b474ab46c5078d829c868d64bce96e152f
testSetQuotaWhenSetQuotaOnParentOrChildPath
public void testSetQuotaWhenSetQuotaOnParentOrChildPath() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    zk.create("/c1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4/c5", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        SetQuotaCommand.createQuota(zk, "/c1/c2/c3", 5L, 10);    try {        SetQuotaCommand.createQuota(zk, "/c1", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1 has a child /c1/c2/c3 which has a quota", e.getMessage());    }    try {        SetQuotaCommand.createQuota(zk, "/c1/c2/c3/c4/c5", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1/c2/c3/c4/c5 has a parent /c1/c2/c3 which has a quota", e.getMessage());    }}
012220923973b31d6b1003ea6b5a48b1a43518303d858d9adf4641eedaa333eb
getEvent
private WatchedEvent getEvent(int numTries) throws InterruptedException
{    WatchedEvent event = null;    for (int i = 0; i < numTries; i++) {        System.out.println("i = " + i);        event = events.poll(10, TimeUnit.SECONDS);        if (event != null) {            break;        }        Thread.sleep(5000);    }    return event;}
4a60756c0ce06d22760da759dca975c0d990ef2f2883e1af8a86a2a35a958cff
deleteZKDir
private void deleteZKDir(ZooKeeper zk, String nodeName) throws IOException, InterruptedException, KeeperException
{    Stat stat = zk.exists(nodeName, false);    if (stat == null) {        return;    }    List<String> children1 = zk.getChildren(nodeName, false);    List<String> c2 = zk.getChildren(nodeName, false, stat);    if (!children1.equals(c2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat.equals(stat)) {        fail("stats from exists()/getChildren2() do not match");    }    if (children1.size() == 0) {        zk.delete(nodeName, -1);        return;    }    for (String n : children1) {        deleteZKDir(zk, n);    }}
46225b6084ddf8907c331b475e27699c16a7d95fcf68f7ef727717942e56d4e2
checkRoot
private void checkRoot() throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    try {        zk.create(dirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + dirOnZK + ": " + ke.getMessage());    }    try {        zk.create(testDirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + testDirOnZK + ": " + ke.getMessage());    }    zk.close();}
2b50ffa6295f6e915109b81ac802db424d3152ee0e58c51a5006152a7d9c1b5d
enode_test_1
private void enode_test_1() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    Stat stat = zk.exists(parentName, false);    if (stat == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    stat = zk.exists(nodeName, false);    if (stat == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("Closing client with sessionid: 0x" + Long.toHexString(zk.getSessionId()));    zk.close();    zk = new ZooKeeper(hostPort, 10000, this);    for (int i = 0; i < 10; i++) {        System.out.println("i = " + i);        stat = zk.exists(nodeName, false);        if (stat != null) {            System.out.println("node " + nodeName + " should not exist after reconnection close");        } else {            System.out.println("node " + nodeName + " is gone after reconnection close!");            break;        }        Thread.sleep(5000);    }    deleteZKDir(zk, nodeName);    zk.close();}
bce45a88c74ec12863d6b09ae2d9baa58c1220d9108e0d024d9e91d9551a8410
enode_test_2
private void enode_test_2() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    ZooKeeper zk_1 = new ZooKeeper(hostPort, 10000, this);    Stat stat_parent = zk_1.exists(parentName, false);    if (stat_parent == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    Stat stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        try {            zk.delete(nodeName, -1);        } catch (KeeperException ke) {            Code code = ke.code();            boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;            if (!valid) {                fail("Unexpected exception code for delete: " + ke.getMessage());            }        }    }    List<String> firstGen1 = zk_1.getChildren(parentName, true);    Stat stat = new Stat();    List<String> firstGen2 = zk_1.getChildren(parentName, true, stat);    if (!firstGen1.equals(firstGen2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat_parent.equals(stat)) {        fail("stat from exists()/getChildren() do not match");    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    Thread.sleep(5000);    WatchedEvent event = events.poll(10, TimeUnit.SECONDS);    if (event == null) {        throw new IOException("No event was delivered promptly");    }    if (event.getType() != EventType.NodeChildrenChanged || !event.getPath().equalsIgnoreCase(parentName)) {        fail("Unexpected event was delivered: " + event.toString());    }    stat_node = zk_1.exists(nodeName, false);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    try {        zk.delete(parentName, -1);        fail("Should be impossible to delete a non-empty node " + parentName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    try {        zk.create(nodeName + "/def", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should be impossible to create child off Ephemeral node " + nodeName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOCHILDRENFOREPHEMERALS;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    try {        List<String> children1 = zk.getChildren(nodeName, false);        List<String> children2 = zk.getChildren(nodeName, false, null);        if (!children1.equals(children2)) {            fail("children lists from getChildren()/getChildren2() does not match");        }        if (children1.size() > 0) {            fail("ephemeral node " + nodeName + " should not have children");        }    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    firstGen1 = zk_1.getChildren(parentName, true);    firstGen2 = zk_1.getChildren(parentName, true, null);    if (!firstGen1.equals(firstGen2)) {        fail("children list from getChildren()/getChildren2() does not match");    }    stat_node = zk_1.exists(nodeName, true);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("session id of zk: " + zk.getSessionId());    System.out.println("session id of zk_1: " + zk_1.getSessionId());    zk.close();    zk_1.exists("nosuchnode", false);    event = this.getEvent(10);    if (event == null) {        throw new Error("First event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected first event was delivered: " + event.toString());    }    event = this.getEvent(10);    if (event == null) {        throw new Error("Second event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected second event was delivered: " + event.toString());    }    firstGen1 = zk_1.getChildren(parentName, false);    stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        fail("node " + nodeName + " should have been deleted");    }    if (firstGen1.contains(nodeName)) {        fail("node " + nodeName + " should not be a children");    }    deleteZKDir(zk_1, nodeName);    zk_1.close();}
518966e224874aea3a02d46c242c5bbe52c7a9bdbc42253afe9c8d73c5aad0fa
delete_create_get_set_test_1
private void delete_create_get_set_test_1() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/benwashere";    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for create: " + ke.getMessage());        }    }    try {        zk.setData(nodeName, "hi".getBytes(), 5700);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        if (ke.code() != Code.BADVERSION) {            fail("Should have gotten BadVersion exception");        }    }    zk.setData(nodeName, "hi".getBytes(), -1);    Stat st = new Stat();    byte[] bytes = zk.getData(nodeName, false, st);    String retrieved = new String(bytes);    if (!"hi".equals(retrieved)) {        fail("The retrieved data [" + retrieved + "] is differented than the expected [hi]");    }    try {        zk.delete(nodeName, 6800);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY || code == KeeperException.Code.BADVERSION;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    deleteZKDir(zk, nodeName);    zk.close();}
36715f1a08e116aa4ba0abc2984c0f029ddd50b2a43a819685bf9fcd9ab55669
deleteNodeIfExists
private void deleteNodeIfExists(ZooKeeper zk, String nodeName) throws InterruptedException
{    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }}
59b3e210f784aa26094fc3548f8909ed18fd863f0e554a98c52b7ab26744188b
create_get_stat_test
private void create_get_stat_test() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/create_with_stat_tmp";    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    Stat stat = new Stat();    zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNotNull(stat);    assertTrue(stat.getCzxid() > 0);    assertTrue(stat.getCtime() > 0);    Stat stat2 = new Stat();    zk.create(nodeName + "_2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat2);    assertNotNull(stat2);    assertTrue(stat2.getCzxid() > stat.getCzxid());    assertTrue(stat2.getCtime() > stat.getCtime());    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    zk.close();}
8ae02ce35911f98f4671bf098f55ab3015bf76c173d4037fe81065d0947f7021
my_test_1
public void my_test_1() throws IOException, InterruptedException, KeeperException
{    enode_test_1();    enode_test_2();    delete_create_get_set_test_1();    create_get_stat_test();}
5ab933558be7f726c95a41e1baa084236360e7f1c7eacaefaad6b8b235a411d5
process
public synchronized void process(WatchedEvent event)
{    try {        System.out.println("Got an event " + event.toString());        events.put(event);    } catch (InterruptedException e) {        e.printStackTrace();    }}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    ZooKeeperTestClient zktc = new ZooKeeperTestClient();    try {        zktc.my_test_1();    } catch (Exception e) {        e.printStackTrace();    }}
93225100db5f1c7da71218a120312aed8bea9b835de21bef0bd981563d8198e6
setXid
 void setXid(int newXid)
{    xid = newXid;}
6b0ab26d8da36fe0ec63ef43a08359975f8ebc048e5f9a1f83123270415f49b4
checkXid
 int checkXid()
{    return xid;}
0da12011de919fb00b90d3ea1da8079b870e716885cdde554abc38004b6045c7
createConnection
protected ClientCnxn createConnection(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new TestableClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watcher, clientCnxnSocket, canBeReadOnly);}
ceeac831898758816c56296657d2555da1d6e18c89fc460392ffb19575ba7a5c
setXid
public void setXid(int xid)
{    ((TestableClientCnxn) cnxn).setXid(xid);}
d6b06c909bd2b034afa0baf4f925f72ba5d1f8aaab5950284d1491f7a88e56fb
checkXid
public int checkXid()
{    return ((TestableClientCnxn) cnxn).checkXid();}
898959b931926e82cf752c7bc398585bd09e470ae309a9fd17becf388174da19
getChildWatches
public List<String> getChildWatches()
{    return super.getChildWatches();}
2895f1361aba882e88752d2a60d8521709cc2dece7cad1621b60ae65f1ab7a09
getDataWatches
public List<String> getDataWatches()
{    return super.getDataWatches();}
8452b213f2ec0bbb0bb7eaa482f455fc31c5dfbc8b4a0b7278b8952ad35631b8
getExistWatches
public List<String> getExistWatches()
{    return super.getExistWatches();}
d7b34a54d670cfbfcc366ebbcbc33f349247e6d45e9bc3e394c2f51b0c579bdd
testableConnloss
public void testableConnloss() throws IOException
{    synchronized (cnxn) {        cnxn.sendThread.testableCloseSocket();    }}
75e7accada2a61a386381f9760f99dd1e25faf782effe8d91d317c31d0162005
pauseCnxn
public boolean pauseCnxn(final long ms)
{    final CountDownLatch initiatedPause = new CountDownLatch(1);    new Thread() {        public void run() {            synchronized (cnxn) {                try {                    try {                        cnxn.sendThread.testableCloseSocket();                    } catch (IOException e) {                        e.printStackTrace();                    } finally {                        initiatedPause.countDown();                    }                    Thread.sleep(ms);                } catch (InterruptedException e) {                }            }        }    }.start();    try {        return initiatedPause.await(ms, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        e.printStackTrace();        return false;    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    synchronized (cnxn) {        try {            try {                cnxn.sendThread.testableCloseSocket();            } catch (IOException e) {                e.printStackTrace();            } finally {                initiatedPause.countDown();            }            Thread.sleep(ms);        } catch (InterruptedException e) {        }    }}
cd1a9d07594e38ddb6c450496b5a2b35cb07027e059629b7f0e0a02d6e2722a9
testableLocalSocketAddress
public SocketAddress testableLocalSocketAddress()
{    return super.testableLocalSocketAddress();}
62c64fc1a19b985d284515894397c5908261438c5d4ea58276cba3909f8e722b
testableRemoteSocketAddress
public SocketAddress testableRemoteSocketAddress()
{    return super.testableRemoteSocketAddress();}
dcbabea6d77ad732d3385499d2d447e71be15579d7aa6e477b13bc53857e20b0
testableLastZxid
public long testableLastZxid()
{    return cnxn.getLastZxid();}
0819b834e6ffe53dee0b345d3f1b9bb49aba2ec36034a5b6cc7e084f7a7e8b3b
submitRequest
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return cnxn.submitRequest(h, request, response, watchRegistration);}
0dba3948e03692823445b16cdfa3dd8b6577a858c451983c8276e1dab61136cc
disconnect
public void disconnect()
{    cnxn.disconnect();}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return BaseX509ParameterizedTestCase.defaultParams();}
19c5b4d34f3edc75dac316e4c394d85ed7dcb93a85742740af78634f745826f7
testLoadPrivateKeyFromKeyStore
public void testLoadPrivateKeyFromKeyStore() throws IOException, GeneralSecurityException
{    Optional<String> optPassword = x509TestContext.getKeyStorePassword().length() > 0 ? Optional.of(x509TestContext.getKeyStorePassword()) : Optional.empty();    PrivateKey privateKey = PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), optPassword);    assertEquals(x509TestContext.getKeyStoreKeyPair().getPrivate(), privateKey);}
5514f1bbc09a7082d7f8c6f9f74b1f0deb426e64883df6e34ff693433cf91b42
testLoadEncryptedPrivateKeyFromKeyStoreWithoutPassword
public void testLoadEncryptedPrivateKeyFromKeyStoreWithoutPassword() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.empty());}
3dbf50b30ee7778605fc5342bc1922e1d2174eb2da6ed7eb5692624062bfb989
testLoadEncryptedPrivateKeyFromKeyStoreWithWrongPassword
public void testLoadEncryptedPrivateKeyFromKeyStoreWithWrongPassword() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
8b0d4244c9f5afe6ab5c333c70136ce4fac724a448ba7bf8d8d4ff02fc97c7d1
testLoadUnencryptedPrivateKeyFromKeyStoreWithWrongPassword
public void testLoadUnencryptedPrivateKeyFromKeyStoreWithWrongPassword() throws GeneralSecurityException, IOException
{    if (x509TestContext.isKeyStoreEncrypted()) {        throw new IOException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
2d35ab2da82f17cee8f27952061af9218bfe50f3bceb1c586811ba5c8f5726da
testLoadPrivateKeyFromTrustStore
public void testLoadPrivateKeyFromTrustStore() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.empty());}
3c6fbec86fb1dc8c3d33f8d074b0d700e6fcb585ba126bff2823bdce07ea58c8
testLoadPrivateKeyFromTrustStoreWithPassword
public void testLoadPrivateKeyFromTrustStoreWithPassword() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.of("foobar"));}
7db34ba80d76206475cbc1912cb4cdd469c7afad4d609a51083ff81f3e80ff68
testLoadCertificateFromKeyStore
public void testLoadCertificateFromKeyStore() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getKeyStoreCertificate(), certs.get(0));}
4f4af470d282c504483aaa2ab1362033c209d1dcf625dfdbd91a2ab7596cddd3
testLoadCertificateFromTrustStore
public void testLoadCertificateFromTrustStore() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getTrustStoreCertificate(), certs.get(0));}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { "1.2.3", new Object[] { 1, 2, 3, null } }, { "1.2.3-dev", new Object[] { 1, 2, 3, "dev" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } }, { "1.2.3.4.5-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3.4.5-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } } });}
4778be699b4cbd1f719cd258e4daf0bba2b4cb606bbf1146b4aebedc8613f8de
testParser
public void testParser()
{    VerGen.Version v = VerGen.parseVersionString(input);    assertEquals(expected[0], v.maj);    assertEquals(expected[1], v.min);    assertEquals(expected[2], v.micro);    assertEquals(expected[3], v.qualifier);}
6848c810a1d91431e45fff80f89ff69eb2931561a2bb95d8f6702726f27c9cae
testGenFile
public void testGenFile() throws Exception
{    VerGen.Version v = VerGen.parseVersionString(input);    File outputDir = ClientBase.createTmpDir();    VerGen.generateFile(outputDir, v, "1", "Nov1");    ClientBase.recursiveDelete(outputDir);}
e6bcdf2eeee213cf416226d4c2350021833ed3f48eda752cf84c1dcecc8e56b2
createRunnerForTestWithParameters
public org.junit.runner.Runner createRunnerForTestWithParameters(TestWithParameters test) throws InitializationError
{    return new ZKParameterized.Runner(test);}
d4c504851dde1789d115d59c710ab958554d54076aa2bfaab3c8f10299f9759a
computeTestMethods
protected List<FrameworkMethod> computeTestMethods()
{    return JUnit4ZKTestRunner.computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
976cb6e2792c5eb10ff14b9aad32588e259743c0039bed43778458fdc19a7b02
methodInvoker
protected Statement methodInvoker(FrameworkMethod method, Object test)
{    return new JUnit4ZKTestRunner.LoggedInvokeMethod(method, test);}
cba37168df759b91c98b3afa9f6b3dca8684d1e64d7c66201a5c016838d5f81c
getTestName
protected String getTestName()
{    return testName;}
2107887c3802075c57c37dac1089d450942b038285d86e72d818e667268281ed
starting
public void starting(Description method)
{                System.setProperty("zookeeper.admin.enableServer", "false");            System.setProperty("zookeeper.4lw.commands.whitelist", "*");    testName = method.getMethodName();    LOG.info("STARTING " + testName);}
ab55b5e0d7f531eb69b545da0fca1d8ca20f07b5112c4e9547a73a4d09e834c6
finished
public void finished(Description method)
{    LOG.info("FINISHED " + testName);}
4fdc85cb6aa26b87e8e267ff823360f036f358793b76a5fe85e595742807c1bb
succeeded
public void succeeded(Description method)
{    LOG.info("SUCCEEDED " + testName);}
a8274ee72588925da585ae7c7560493f0552516b8775a7650d0f81fa5e4753d2
failed
public void failed(Throwable e, Description method)
{    LOG.info("FAILED " + testName, e);}
44b543fbf1f86bda09f81cdf919fc176b1683219d62717ba12630f357e11828e
waitFor
public void waitFor(String msg, WaitForCondition condition, int timeout) throws InterruptedException
{    final LocalDateTime deadline = LocalDateTime.now().plusSeconds(timeout);    while (LocalDateTime.now().isBefore(deadline)) {        if (condition.evaluate()) {            return;        }        Thread.sleep(100);    }    fail(msg);}
7c1203297d6f00c7339a0f8eb5c3970de980476fea8d1f9ae49f44e151af83f4
init
public static void init()
{    testData.mkdirs();}
90b3a80d1d28164a62fc5d35e3f4dc93fa20bb5ff00f9963fa8a95ca4bdf396e
testValidateFileInput
public void testValidateFileInput() throws IOException
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNull(error);}
66663201f15700c938cc04c5a91e7f5a25a4422ec42ee598e82ea25f9a116ba0
testValidateFileInputNotExist
public void testValidateFileInputNotExist()
{    String fileName = UUID.randomUUID().toString();    File file = new File(testData, fileName);    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "File '" + absolutePath + "' does not exist.";    assertEquals(expectedMessage, error);}
9e562139d103641320fb2789ed88043c170797132d0e21f5c0caa43d7500323b
testValidateFileInputDirectory
public void testValidateFileInputDirectory() throws Exception
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();        file.delete();    file.mkdir();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "'" + absolutePath + "' is a direcory. it must be a file.";    assertEquals(expectedMessage, error);}
e6cbca9cf25a82a407b5748ed09c2a4b58b29bbfd56e43b92846549a5a66a2a3
testUnreadableFileInput
public void testUnreadableFileInput() throws Exception
{        assumeTrue(!org.apache.zookeeper.Shell.WINDOWS);    File file = File.createTempFile("test", ".junit", testData);    file.setReadable(false, false);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "Read permission is denied on the file '" + absolutePath + "'";    assertEquals(expectedMessage, error);}
01a45dac47065b80c0ced57eee51f64736e8466abb53993e1e3383101243eacb
testDeleteRecursive
public void testDeleteRecursive() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    assertTrue(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("1 children - c should be deleted ", 1, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
840bb586dc1275f89712d4e613a925a0240bd371e32fc04b84e650bf94ac3905
testDeleteRecursiveFail
public void testDeleteRecursiveFail() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    ACL deleteProtection = new ACL(ZooDefs.Perms.DELETE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="));    List<ACL> acls = Arrays.asList(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE), deleteProtection);        zk.create("/a/c/0/surprise", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(1, zk.getACL("/a/c/0", new Stat()).size());    zk.setACL("/a/c/0", acls, -1);    assertEquals(2, zk.getACL("/a/c/0", new Stat()).size());    assertFalse(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - c should fail to be deleted ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a/b", 1000));    children = zk.getChildren("/a", false);    assertEquals("1 children - b should be deleted ", 1, children.size());        zk.addAuthInfo(deleteProtection.getId().getScheme(), "user:test".getBytes());    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
d306a15e5b8c1ed41ef731492a54a04f2c69f445ff3a1efd97dbd2b5eee65bfe
setupDataTree
private void setupDataTree(ZooKeeper zk) throws KeeperException, InterruptedException
{        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 1000; i < 3000; ++i) {        zk.create("/a/b/v/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 500; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));}
52ee55daf4cc21c3ee9d85286c6a723f51de0c31289a2803d326597079519492
testDeleteRecursiveCli
public void testDeleteRecursiveCli() throws IOException, InterruptedException, CliException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    ZooKeeperMain zkMain = new ZooKeeperMain(zk);            String cmdstring0 = "rmr /a/b/v";    String cmdstring1 = "deleteall /a";    zkMain.cl.parseCommand(cmdstring0);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(null, zk.exists("/a/b/v", null));    zkMain.cl.parseCommand(cmdstring1);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertNull(zk.exists("/a", null));}
8aff903ead4b1392eecc0378e89db2e0d0467f1ee55675b972fc600550c8d129
testDeleteRecursiveAsync
public void testDeleteRecursiveAsync() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 50; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    VoidCallback cb = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            synchronized (ctx) {                ((AtomicInteger) ctx).set(4);                ctx.notify();            }        }    };    final AtomicInteger ctx = new AtomicInteger(3);    ZKUtil.deleteRecursive(zk, "/a", cb, ctx);    synchronized (ctx) {        ctx.wait();    }    assertEquals(4, ctx.get());}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((AtomicInteger) ctx).set(4);        ctx.notify();    }}
427ca960c0ae9d4810758e0f044ccf0e7a153e23a21a921d52e51848844eccb8
testStatWhenPathDoesNotExist
public void testStatWhenPathDoesNotExist() throws IOException, InterruptedException, MalformedCommandException
{    final ZooKeeper zk = createClient();    ZooKeeperMain main = new ZooKeeperMain(zk);    String cmdstring = "stat /invalidPath";    main.cl.parseCommand(cmdstring);    try {        main.processZKCmd(main.cl);        fail("As Node does not exist, command should fail by throwing No Node Exception.");    } catch (CliException e) {        assertEquals("Node does not exist: /invalidPath", e.getMessage());    }}
c96cd53a772de0eed974ed1d0621d6f05d8ddf4eb1aae5b438cd08f73e8250a4
testParseWithExtraSpaces
public void testParseWithExtraSpaces() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "      ls       /  ";    zkMain.cl.parseCommand(cmdstring);    assertEquals("Spaces also considered as characters", zkMain.cl.getNumArguments(), 2);    assertEquals("ls is not taken as first argument", zkMain.cl.getCmdArgument(0), "ls");    assertEquals("/ is not taken as second argument", zkMain.cl.getCmdArgument(1), "/");}
d6962b31650f97ef5759786fee613c079d74c980714a843b4831c592ce895579
testParseWithQuotes
public void testParseWithQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String quoteChar : new String[] { "'", "\"" }) {        String cmdstring = String.format("create /node %1$squoted data%1$s", quoteChar);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), "quoted data");    }}
26c1826d7bdd0116d08967b3bcc388035a5fe59e24af8b4ae34a3ffcd25cd0c9
testParseWithMixedQuotes
public void testParseWithMixedQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String[] quoteChars : new String[][] { { "'", "\"" }, { "\"", "'" } }) {        String outerQuotes = quoteChars[0];        String innerQuotes = quoteChars[1];        String cmdstring = String.format("create /node %1$s%2$squoted data%2$s%1$s", outerQuotes, innerQuotes);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), innerQuotes + "quoted data" + innerQuotes);    }}
1b4a7a6ca2c644e71c723841d3a872fe83e4c60baa31c053f1a37f35c736e6f9
testParseWithEmptyQuotes
public void testParseWithEmptyQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("empty quotes should produce arguments", zkMain.cl.getNumArguments(), 3);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");}
006480e38bbe4872109140a963cb7c3979d0c13ebf53df7404af0ddf3fe797f5
testParseWithMultipleQuotes
public void testParseWithMultipleQuotes() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node '' ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("expected 5 arguments", zkMain.cl.getNumArguments(), 4);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");    assertEquals("empty string is not taken as fourth argument", zkMain.cl.getCmdArgument(3), "");}
f112ac6d541f4a21f2fc36031d9e2a6f4ead393a8a627731767b28000d0fac3d
testNonexistantCommand
public void testNonexistantCommand() throws Exception
{    testInvalidCommand("cret -s /node1", 127);}
bc72fe35b567eec984ad8da1daecdfe719048301ab51fbb989970acb6cc89805
testCreateCommandWithoutPath
public void testCreateCommandWithoutPath() throws Exception
{    testInvalidCommand("create", 1);}
03c6060b0cc64236a65d134af84b9b05b783326818e0b7cee2a468c4b23f74ff
testCreateEphemeralCommandWithoutPath
public void testCreateEphemeralCommandWithoutPath() throws Exception
{    testInvalidCommand("create -e ", 1);}
d4c307a01aa5a99cf818b704cde3e8d6d904d1bc3dc5c7ad21a5ec52789d52c4
testCreateSequentialCommandWithoutPath
public void testCreateSequentialCommandWithoutPath() throws Exception
{    testInvalidCommand("create -s ", 1);}
15daad4e6f3771a9d9934aa82350db10b55996dc2a1f805dfd5610d51060b144
testCreateEphemeralSequentialCommandWithoutPath
public void testCreateEphemeralSequentialCommandWithoutPath() throws Exception
{    testInvalidCommand("create -s -e ", 1);}
805c0a5f6562db05362480b60ccd9f3ddc86ed24ac08d3d9267200f7a73b39bc
testInvalidCommand
private void testInvalidCommand(String cmdString, int exitCode) throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.cl.parseCommand(cmdString);        zkMain.processCmd(zkMain.cl);    assertEquals(exitCode, zkMain.exitCode);        try {        zkMain.processZKCmd(zkMain.cl);        fail();    } catch (CliException e) {        return;    }    fail("invalid command should throw CliException");}
39850f60f1e848475bced16724e98cc41ee59f02175a5668bb0944e651f14c1d
testCreateNodeWithoutData
public void testCreateNodeWithoutData() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create  -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s y /node";    zkMain.cl.parseCommand(cmdstring);    try {        assertTrue("Created node with wrong option", zkMain.processZKCmd(zkMain.cl));        fail("Created the node with wrong option should " + "throw Exception.");    } catch (MalformedPathException e) {        assertEquals("Path must start with / character", e.getMessage());    }}
00c7e28f33ef17e261081b834fc6f4b2d0f67bf701df65c35967280a7b60310c
testACLWithExtraAgruments
public void testACLWithExtraAgruments() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /l data ip:10.18.52.144:cdrwa f g h";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not considering the extra arguments after the acls.", zkMain.processZKCmd(zkMain.cl));}
ee856fff185ee7a7b2b53f6ff406548fb33e86c1afddadc4356648249f29e4b5
testCreatePersistentNode
public void testCreatePersistentNode() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node2";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not creating Persistent node.", zkMain.processZKCmd(zkMain.cl));}
d588d24d86f0ebbff2cd80210ca2cce069b8c9b5ef0b61e20fb792c431381f7f
testDelete
public void testDelete() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node2 data";    String cmdstring2 = "delete /node2";    String cmdstring3 = "ls /node2";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse("", zkMain.processCmd(zkMain.cl));}
bc72beba810377a6ade461830a93f2186e51a8815b36d5e7688d0761ab8f154a
testDeleteNonexistantNode
public void testDeleteNonexistantNode() throws Exception
{    testInvalidCommand("delete /blahblahblah", 1);}
65ee12ae43c9bc058369af7fbab024a157e3d0274c5a7e2e907950aa8a585049
testStatCommand
public void testStatCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node3 data";    String cmdstring2 = "stat /node3";    String cmdstring3 = "delete /node3";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
1480259002014ce022866161b209ddfe4539052ba7be107057246ce25dd34193
testInvalidStatCommand
public void testInvalidStatCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring1 = "stat /node123";    zkMain.cl.parseCommand(cmdstring1);    try {        assertFalse(zkMain.processZKCmd(zkMain.cl));        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
cd25e4c2d2b01bc45010c8ec6810d690e89e0778f3936e98d4a7344b326216d0
testSetData
public void testSetData() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node4 data";    String cmdstring2 = "set /node4 " + "data";    String cmdstring3 = "delete /node4";    Stat stat = new Stat();    int version = 0;    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    version = stat.getVersion();    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    assertEquals(version + 1, stat.getVersion());    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
615f7db5e9210349c04b8d214656e1f156107ff5d258171b990c584bf75839f4
testCheckInvalidAcls
public void testCheckInvalidAcls() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s -e /node data ip:scheme:gggsd";        zkMain.executeLine(cmdstring);}
04d8b2c654d0e8350bce95c21cad99e7112c0ec7b0354dcca6dca5535cab2d39
testDeleteWithInvalidVersionNo
public void testDeleteWithInvalidVersionNo() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create -s -e /node1 data ";        String cmdstring1 = "delete /node1 2";    zkMain.executeLine(cmdstring);        zkMain.executeLine(cmdstring1);}
a9e768aec20c6e3996817332e8d62185c110401f2af277a8f809dcc096b4d4e8
testCliCommandsNotEchoingUsage
public void testCliCommandsNotEchoingUsage() throws Exception
{            final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "printwatches";    zkMain.executeLine(cmd1);    String cmd2 = "history";    zkMain.executeLine(cmd2);    String cmd3 = "redo";    zkMain.executeLine(cmd3);        System.setErr(systemErr);    if (errContent.toString().contains("ZooKeeper -server host:port cmd args")) {        fail("CLI commands (history, redo, connect, printwatches) display usage info!");    }}
e962cbe0eb2cb35b8d9d26752702a8338a377fdbe5770c2087094b453c2cb20b
testRedoWithNegativeCmdNumber
public void testRedoWithNegativeCmdNumber() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "redo -1";                final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    try {        zkMain.executeLine(cmd1);        assertEquals("Command index out of range", errContent.toString().trim());    } finally {                System.setErr(systemErr);    }}
6e35e890b577a436119bd0daf2e838b6d735b1b731d6a6ce474d79dcea2fda22
runCommandExpect
private static void runCommandExpect(CliCommand command, List<String> expectedResults) throws Exception
{        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    PrintStream out = new PrintStream(byteStream);    command.setOut(out);    command.exec();    String result = byteStream.toString();    assertTrue(result, result.contains(StringUtils.joinStrings(expectedResults, LINE_SEPARATOR)));}
8eca8f462b32a87f676b5990ce0c2742932f598e4c891af81ee6eb25a82c8a0f
testSortedLs
public void testSortedLs() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /aa1");    zkMain.executeLine("create /aa2");    zkMain.executeLine("create /aa3");    zkMain.executeLine("create /test1");    zkMain.executeLine("create /zk1");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("[aa1, aa2, aa3, test1, zk1, zookeeper]");    runCommandExpect(cmd, expected);}
14bbc49c1901db4a1ef826566ac0218e8dffb088b26eb9566e296ebd7e801c6a
testLsrCommand
public void testLsrCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /a");    zkMain.executeLine("create /a/b");    zkMain.executeLine("create /a/c");    zkMain.executeLine("create /a/b/d");    zkMain.executeLine("create /a/c/e");    zkMain.executeLine("create /a/f");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /a".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/a");    expected.add("/a/b");    expected.add("/a/c");    expected.add("/a/f");    expected.add("/a/b/d");    expected.add("/a/c/e");    runCommandExpect(cmd, expected);}
5fd99cc04859d4c83c09a76f9a3230dc86077a05d45389329ce9913446c945b9
testLsrRootCommand
public void testLsrRootCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/");    expected.add("/zookeeper");    runCommandExpect(cmd, expected);}
cfe35855308a9d3b379bf885759e1167e449f190a4f448f03df5e09e5703f22e
testLsrLeafCommand
public void testLsrLeafCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/b/c");    runCommandExpect(cmd, expected);}
61b8b588f2ac93cc4a9f2b659ecbbaf7f58948fce85c6e6e6938e477eff41f89
testLsrNonexistantZnodeCommand
public void testLsrNonexistantZnodeCommand() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c/d".split(" "));    try {        runCommandExpect(cmd, new ArrayList<String>());        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
c5315d3fa7fbb71203bb73ec119ab95e6954969692bb69a8a884561bd4b333e9
testSetAclRecursive
public void testSetAclRecursive() throws Exception
{    final ZooKeeper zk = createClient();    final byte[] EMPTY = new byte[0];    zk.setData("/", EMPTY, -1);    zk.create("/a", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/c", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/d", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/e", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String setAclCommand = "setAcl -R /a world:anyone:r";    zkMain.cl.parseCommand(setAclCommand);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b/c", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/d", new Stat()));        assertEquals(Ids.OPEN_ACL_UNSAFE, zk.getACL("/e", new Stat()));}
aaccec40e1bce173dfeca695aa12db3d997ea93da39b3dcc8dc07965a4df34c7
testClientReconnectWithZKClientConfig
public void testClientReconnectWithZKClientConfig() throws Exception
{    ZooKeeper zk = null;    ZooKeeper newZKClient = null;    try {        zk = createClient();        ZKClientConfig clientConfig = new ZKClientConfig();        clientConfig.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");        CountdownWatcher watcher = new CountdownWatcher();        HostProvider aHostProvider = new StaticHostProvider(new ConnectStringParser(hostPort).getServerAddresses());        newZKClient = new ZooKeeper(hostPort, zk.getSessionTimeout(), watcher, zk.getSessionId(), zk.getSessionPasswd(), false, aHostProvider, clientConfig);        watcher.waitForConnected(CONNECTION_TIMEOUT);        assertEquals("Old client session id and new clinet session id must be same", zk.getSessionId(), newZKClient.getSessionId());    } finally {        zk.close();        newZKClient.close();    }}
dfddbfae45ff9ebcb9175240de03a9f19d9f9b2d9b035d03359d7b6bef11abd6
testSyncCommand
public void testSyncCommand() throws Exception
{    final ZooKeeper zk = createClient();    SyncCommand cmd = new SyncCommand();    cmd.setZk(zk);    cmd.parse("sync /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("Sync is OK");    runCommandExpect(cmd, expected);}
